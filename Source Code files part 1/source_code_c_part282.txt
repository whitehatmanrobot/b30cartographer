    else if (obj == _serverVars) {
            obj = null;
        }      

        return (string)obj;
    }

    internal override int CallISAPI(UnsafeNativeMethods.CallISAPIFunc iFunction, byte [] bufIn, byte [] bufOut) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.EcbCallISAPI(_ecb, iFunction, bufIn, bufIn.Length, bufOut, bufOut.Length);
    }
}

//
// In-process ISAPIWorkerRequest specific for IIS6
//
// Uses unicode server vars
//

internal class ISAPIWorkerRequestInProcForIIS6 : ISAPIWorkerRequestInProc {

    private static int _asyncIoCount;

    private IntPtr _savedEcb;

    internal ISAPIWorkerRequestInProcForIIS6(IntPtr ecb) : base(ecb) {
        _savedEcb = ecb;
    }

    internal static void WaitForPendingAsyncIo() {
        while(_asyncIoCount != 0) {
            Thread.Sleep(250);
        }
    }

    internal override void SendEmptyResponse() {
        // facilitate health monitoring for IIS6 -- update last activity timestamp
        // to avoid deadlock detection
        UnsafeNativeMethods.UpdateLastActivityTimeForHealthMonitor();
    }

    internal override String MapPathSlowUsingIISCore(String path) {
        if (_ecb == IntPtr.Zero)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_map_path, path));

        Debug.Trace("MapPath", "MapPath using IIS6 (" + path + ")");

        int size = 256;
        StringBuilder buf = new StringBuilder(size);
        int r = UnsafeNativeMethods.EcbMapUrlToPathUnicode(_ecb, path, buf, size);

        while (r < 0) {
            // buffer not big enough
            size = -r;
            buf = new StringBuilder(size);
            r = UnsafeNativeMethods.EcbMapUrlToPathUnicode(_ecb, path, buf, size);
        }

        if (r != 1)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_map_path, path));

        return buf.ToString();
    }

    internal override String GetServerVariableCore(String name) {
        // fall back for headers (IIS6 doesn't support them as UNICODE_XXX)
        if (name.StartsWith("HTTP_"))
            return base.GetServerVariableCore(name);
        else
            return GetUnicodeServerVariable("UNICODE_" + name);
    }

    internal override void ReadRequestBasics() {

        //
        // server variables needed for request basics
        //

        String APPL_PHYSICAL_PATH, APPL_MD_PATH, REQUEST_METHOD, PATH_INFO, PATH_TRANSLATED, URL;

        ServerVarCharBuffer buf = new ServerVarCharBuffer();

        try {
            APPL_PHYSICAL_PATH  = GetUnicodeServerVariable("UNICODE_APPL_PHYSICAL_PATH", buf);
            APPL_MD_PATH        = GetUnicodeServerVariable("UNICODE_APPL_MD_PATH", buf);
            REQUEST_METHOD      = GetUnicodeServerVariable("UNICODE_REQUEST_METHOD", buf);
            PATH_INFO           = GetUnicodeServerVariable("UNICODE_PATH_INFO", buf);
            PATH_TRANSLATED     = GetUnicodeServerVariable("UNICODE_PATH_TRANSLATED", buf);
            URL                 = GetUnicodeServerVariable("UNICODE_URL", buf);;
        }
        finally {
            buf.Dispose();
        }

        //
        // remember basic strings based on the server vars
        //

        _method = REQUEST_METHOD;

        // _pathInfo is the difference between PATH_INFO and URL
        int lengthDiff = PATH_INFO.Length - URL.Length; 

        if (lengthDiff > 0) {
            _filePath       = URL;
            _pathInfo       = PATH_INFO.Substring(URL.Length);
            _path           = PATH_INFO;
            
            int pathTranslatedLength = PATH_TRANSLATED.Length - lengthDiff;
            if (pathTranslatedLength > 0)
                _pathTranslated = PATH_TRANSLATED.Substring(0, pathTranslatedLength);
            else
                _pathTranslated = PATH_TRANSLATED;
        }
        else {
            _filePath       = PATH_INFO;
            _pathInfo       = String.Empty;
            _path           = PATH_INFO;
            _pathTranslated = PATH_TRANSLATED;
        }

        _appPathTranslated = APPL_PHYSICAL_PATH;

        // virtual path starts on fifth '/' in APPL_MD_PATH as in "/LM/W3SVC/1/Root/foo"
        int iAppPathStart = 0;
        for (int i = 0; i < 4 && iAppPathStart >= 0; i++)
            iAppPathStart = APPL_MD_PATH.IndexOf('/', iAppPathStart+1);
        _appPath = (iAppPathStart >= 0) ? APPL_MD_PATH.Substring(iAppPathStart) : "/";

        //
        // other (int) request basics
        //

        int[] contentInfo = null;

        try {
            contentInfo = RecyclableArrayHelper.GetIntegerArray(4);
            UnsafeNativeMethods.EcbGetBasicsContentInfo(_ecb, contentInfo);

            _contentType        = contentInfo[0];
            _contentTotalLength = contentInfo[1];
            _contentAvailLength = contentInfo[2];
            _queryStringLength  = contentInfo[3];
        }
        finally {
            RecyclableArrayHelper.ReuseIntegerArray(contentInfo);
        }
    }

    private String GetUnicodeServerVariable(String name) {
        String value = null;
        ServerVarCharBuffer buf = new ServerVarCharBuffer();

        try {
            value = GetUnicodeServerVariable(name, buf);
        }
        finally {
            buf.Dispose();
        }

        return value;
    }

    private String GetUnicodeServerVariable(String name, ServerVarCharBuffer buffer) {
        int r = UnsafeNativeMethods.EcbGetUnicodeServerVariable(_ecb, name, buffer.PinnedAddress, buffer.Length);

        if (r < 0) {
            buffer.Resize(-r);
            r = UnsafeNativeMethods.EcbGetUnicodeServerVariable(_ecb, name, buffer.PinnedAddress, buffer.Length);
        }

        if (r > 0)
            return Marshal.PtrToStringUni(buffer.PinnedAddress, r);
        else
            return null;
    }

    //
    // Support for async VectorSend and kernel mode cache on IIS6
    //

    private const int MIN_ASYNC_SIZE = 2048;
    private GCHandle _rootedThis;      // for the duration of async
    private ISAPIAsyncCompletionCallback _asyncFlushCompletionCallback;
    private int _asyncFinalStatus;

    private bool _cacheInKernelMode = false;
    private String _kernelModeCacheKey;
    private CacheDependency _cacheDependency;
    private DateTime _cacheExpiration;
    private static CacheItemRemovedCallback s_cacheCallback;

    internal override void FlushCore(byte[]     status, 
                                     byte[]     header, 
                                     int        keepConnected,
                                     int        totalBodySize,
                                     int        numBodyFragments,
                                     IntPtr[]   bodyFragments,
                                     int[]      bodyFragmentLengths,
                                     int        doneWithSession,
                                     int        finalStatus,
                                     out bool   async) {
        async = false;

        if (_ecb == IntPtr.Zero)
            return;

        if (totalBodySize > 0)
            PerfCounters.IncrementCounterEx(AppPerfCounter.REQUEST_BYTES_OUT, totalBodySize);

        // async only for large responses and only on the last flush
        // don't do async if shutting down (async IO holds up app domain shutdown)
        if (totalBodySize >= MIN_ASYNC_SIZE && doneWithSession != 0 && !HttpRuntime.ShutdownInProgress) {
            _asyncFlushCompletionCallback = new ISAPIAsyncCompletionCallback(OnAsyncFlushCompletion);
            _asyncFinalStatus = finalStatus;    // remember to pass to DoneWithSession on completion
            _rootedThis = GCHandle.Alloc(this); // root for the duration of IO
            doneWithSession = 0;                // will do on completion
            async = true;
            Interlocked.Increment(ref _asyncIoCount);  // increment async io count
        }

        int rc = UnsafeNativeMethods.EcbFlushCore(
                        _ecb, 
                        status, 
                        header,
                        keepConnected,
                        totalBodySize,
                        numBodyFragments,
                        bodyFragments,
                        bodyFragmentLengths,
                        doneWithSession,
                        finalStatus,
                        _cacheInKernelMode ? 1 : 0,
                        async ? 1 : 0,
                        _asyncFlushCompletionCallback);

        if (rc == 1 && _cacheInKernelMode) {
            // create cache callback once (the method is static)
            if (s_cacheCallback == null)
                s_cacheCallback = new CacheItemRemovedCallback(OnKernelCacheDependencyChange);

            // start watching for changes to flush from kernel cache
            HttpRuntime.CacheInternal.UtcInsert(
                "HTTP.SYS:" + _kernelModeCacheKey,
                _kernelModeCacheKey,
                _cacheDependency,
                _cacheExpiration, 
                Cache.NoSlidingExpiration,
                CacheItemPriority.NotRemovable,
                s_cacheCallback);
        }

        if (rc == 0 && async) {
            // on async failure default to sync path
            async = false;

            // unroot
            _rootedThis.Free();

            // call DoneWithSession
            UnsafeNativeMethods.EcbFlushCore(_ecb, null, null, 0, 0, 0, null, null, 1, _asyncFinalStatus, 0, 0, null);

            // decrement async io count
            Interlocked.Decrement(ref _asyncIoCount);
        }
    }

    private void OnAsyncFlushCompletion(IntPtr ecb, int byteCount, int error) {
        try {
            Debug.Assert(ecb == _savedEcb);
            
            // unroot
            _rootedThis.Free();

            // call DoneWithSession
            UnsafeNativeMethods.EcbFlushCore(ecb, null, null, 0, 0, 0, null, null, 1, _asyncFinalStatus, 0, 0, null);
            
            // unlock pinned memory (at the latest of this completion and exit from the FlushCore on stack)
            UnlockCachedResponseBytesOnceAfterIoComplete();
            
            // call the HttpRuntime to recycle buffers (at the latest of this completion and EndRequest)
            CallEndOfRequestCallbackOnceAfterAllIoComplete();
        }
        finally {
            // decrement async io count
            Interlocked.Decrement(ref _asyncIoCount);
        }
    }

    internal void CacheInKernelMode(CacheDependency dependency, DateTime expiration) {
        if (_ecb == IntPtr.Zero)
            return;

        _kernelModeCacheKey = GetUnicodeServerVariable("UNICODE_CACHE_URL");

        if (_kernelModeCacheKey != null && _kernelModeCacheKey.Length > 0) {
            _cacheInKernelMode = true;
            _cacheDependency = dependency;
            _cacheExpiration = expiration;
        }
    }

    private static void OnKernelCacheDependencyChange(String key, Object value, CacheItemRemovedReason reason) {
        // value is the CACHE_URL -- the kernel mode cache key
        // Don't invalidate the item if a new item has been inserted into the 
        // cache with the same key - the kernel cache already then cached the
        // new response.
        if (HttpRuntime.CacheInternal[key] == null) {
            UnsafeNativeMethods.InvalidateKernelCache(value as String);
        }
    }
}

//
// Out-of-process worker request
//

internal class ISAPIWorkerRequestOutOfProc : ISAPIWorkerRequest {

    // sends chunks separately if the total length exceeds the following
    // to relieve the memory pressure on named pipes
    const int PM_FLUSH_THRESHOLD = 31*1024;

    internal ISAPIWorkerRequestOutOfProc(IntPtr ecb) : base(ecb) {
    }

    private const int _numServerVars = 32;
    private IDictionary _serverVars;

    private static String[] _serverVarNames = 
        new String[_numServerVars] {
            "APPL_MD_PATH", /* this one is not UTF8 so we don't decode it here */
            "ALL_RAW",
            "AUTH_PASSWORD",
            "AUTH_TYPE",
            "CERT_COOKIE",
            "CERT_FLAGS",
            "CERT_ISSUER",
            "CERT_KEYSIZE",
            "CERT_SECRETKEYSIZE",
            "CERT_SERIALNUMBER",
            "CERT_SERVER_ISSUER",
            "CERT_SERVER_SUBJECT",
            "CERT_SUBJECT",
            "GATEWAY_INTERFACE",
            "HTTP_COOKIE",
            "HTTP_USER_AGENT",
            "HTTPS",
            "HTTPS_KEYSIZE",
            "HTTPS_SECRETKEYSIZE",
            "HTTPS_SERVER_ISSUER",
            "HTTPS_SERVER_SUBJECT",
            "INSTANCE_ID",
            "INSTANCE_META_PATH",
            "LOCAL_ADDR",
            "LOGON_USER",
            "REMOTE_ADDR",
            "REMOTE_HOST",
            "SERVER_NAME",
            "SERVER_PORT",
            "SERVER_PROTOCOL",
            "SERVER_SOFTWARE",
            "REMOTE_PORT"
        };

    private void GetAllServerVars() {
        RecyclableByteBuffer buf = new RecyclableByteBuffer();

        int r = UnsafeNativeMethods.PMGetAllServerVariables(_ecb, buf.Buffer, buf.Buffer.Length);

        while (r < 0) {
            buf.Resize(-r);     // buffer not big enough
            r = UnsafeNativeMethods.PMGetAllServerVariables(_ecb, buf.Buffer, buf.Buffer.Length);
        }

        if (r == 0)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_retrieve_request_data));

        // stub out first server var is it could contain non-UTF8 data
        // convert to characters and split the buffer into strings using utf-8 encoding

        String[] ss = buf.GetDecodedTabSeparatedStrings(Encoding.UTF8, _numServerVars-1, 1);

        // recycle buffers

        buf.Dispose();

        // fill in the hashtable

        _serverVars = new Hashtable(_numServerVars, SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

        _serverVars.Add("APPL_MD_PATH", HttpRuntime.AppDomainAppIdInternal);

        for (int i = 1; i < _numServerVars; i++) {       // starting with 1 to skip APPL_MD_PATH
            _serverVars.Add(_serverVarNames[i], ss[i-1]);
        }
    }


    internal override int GetBasicsCore(byte[] buffer, int size, int[] contentInfo) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.PMGetBasics(_ecb, buffer, size, contentInfo);
    }
    
    internal override int GetQueryStringCore(int encode, StringBuilder buffer, int size) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.PMGetQueryString(_ecb, encode, buffer, size);
    }

    internal override int GetQueryStringRawBytesCore(byte[] buffer, int size) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.PMGetQueryStringRawBytes(_ecb, buffer, size);
    }

    internal override int GetPreloadedPostedContentCore(byte[] bytes, int bufferSize) {
        if (_ecb == IntPtr.Zero)
            return 0;
        int rc = UnsafeNativeMethods.PMGetPreloadedPostedContent(_ecb, bytes, bufferSize);
        if (rc > 0)
            PerfCounters.IncrementCounterEx(AppPerfCounter.REQUEST_BYTES_IN, rc);
        return rc;
    }

    internal override int GetAdditionalPostedContentCore(byte[] bytes, int bufferSize) {
        if (_ecb == IntPtr.Zero)
            return 0;
        int rc = UnsafeNativeMethods.PMGetAdditionalPostedContent(_ecb, bytes, bufferSize);
        if (rc > 0)
            PerfCounters.IncrementCounterEx(AppPerfCounter.REQUEST_BYTES_IN, rc);
        return rc;
    }

    internal override int IsClientConnectedCore() {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.PMIsClientConnected(_ecb);
    }

    internal override void FlushCore(byte[]     status, 
                                     byte[]     header, 
                                     int        keepConnected,
                                     int        totalBodySize,
                                     int        numBodyFragments,
                                     IntPtr[]   bodyFragments,
                                     int[]      bodyFragmentLengths,
                                     int        doneWithSession,
                                     int        finalStatus,
                                     out bool   async) {
        async = false;

        if (_ecb == IntPtr.Zero)
            return;

        if (totalBodySize > 0)
            PerfCounters.IncrementCounterEx(AppPerfCounter.REQUEST_BYTES_OUT, totalBodySize);


        if (numBodyFragments > 1) {
            // Don't flush all at once if the length is over the threshold

            int i = 0;
            while (i < numBodyFragments) {
                bool first = (i == 0);

                int size = bodyFragmentLengths[i];
                int idx = i+1;
                while (idx < numBodyFragments && size + bodyFragmentLengths[idx] < PM_FLUSH_THRESHOLD) {
                    size += bodyFragmentLengths[idx];
                    idx++;
                }

                bool last = (idx == numBodyFragments);

                UnsafeNativeMethods.PMFlushCore(
                                        _ecb, 
                                        first ? status : null, 
                                        first ? header : null,
                                        keepConnected,
                                        size,
                                        i,
                                        idx-i,
                                        bodyFragments,
                                        bodyFragmentLengths,
                                        last ? doneWithSession : 0,
                                        last ? finalStatus : 0);

                i = idx;
            }
        }
        else {
            // Everything in one chunk
            UnsafeNativeMethods.PMFlushCore(
                                    _ecb, 
                                    status, 
                                    header,
                                    keepConnected,
                                    totalBodySize,
                                    0,
                                    numBodyFragments,
                                    bodyFragments,
                                    bodyFragmentLengths,
                                    doneWithSession,
                                    finalStatus);
        }
    }

    internal override int CloseConnectionCore() {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.PMCloseConnection(_ecb);
    }

    internal override int MapUrlToPathCore(String url, byte[] buffer, int size) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.PMMapUrlToPath(_ecb, url, buffer, size);
    }

    internal override IntPtr GetUserTokenCore() {
        if (_token == IntPtr.Zero && _ecb != IntPtr.Zero)
            _token = UnsafeNativeMethods.PMGetImpersonationToken(_ecb);

        return _token;
    }

    internal override IntPtr GetVirtualPathTokenCore() {
        if (_token == IntPtr.Zero && _ecb != IntPtr.Zero)
            _token = UnsafeNativeMethods.PMGetVirtualPathToken(_ecb);

        return _token;
    }

    internal override int AppendLogParameterCore(String logParam) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.PMAppendLogParameter(_ecb, logParam);
    }

    internal override int GetClientCertificateCore(byte[] buffer, int [] pInts, long [] pDates) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.PMGetClientCertificate(_ecb, buffer, buffer.Length, pInts, pDates);
    }

    public override String GetServerVariable(String name) {
        // PATH_TRANSLATED is mangled -- do not use the original server variable
        if (name.Equals("PATH_TRANSLATED"))
            return GetFilePathTranslated();

        if (_serverVars == null)
            GetAllServerVars();

        return (String)_serverVars[name];
    }

    internal override int CallISAPI(UnsafeNativeMethods.CallISAPIFunc iFunction, byte [] bufIn, byte [] bufOut) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.PMCallISAPI(_ecb, iFunction, bufIn, bufIn.Length, bufOut, bufOut.Length);
    }

    internal override void SendEmptyResponse() {
        if (_ecb == IntPtr.Zero)
            return;

        UnsafeNativeMethods.PMEmptyResponse(_ecb);
    }

    internal override DateTime GetStartTime() {
        if (_ecb == IntPtr.Zero)
            return base.GetStartTime();
        
        long fileTime = UnsafeNativeMethods.PMGetStartTimeStamp(_ecb);
        
        return DateTimeUtil.FromFileTimeToUtc(fileTime);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\formsidentity.cs ===
//------------------------------------------------------------------------------
// <copyright file="FormsIdentity.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * FormsIdentity
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Security {
    using  System.Security.Principal;
    using System.Security.Permissions;

    /// <include file='doc\FormsIdentity.uex' path='docs/doc[@for="FormsIdentity"]/*' />
    /// <devdoc>
    ///    This class is an IIdentity derived class
    ///    used by FormsAuthenticationModule. It provides a way for an application to
    ///    access the cookie authentication ticket.
    /// </devdoc>
    [Serializable]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class FormsIdentity : IIdentity {
        /// <include file='doc\FormsIdentity.uex' path='docs/doc[@for="FormsIdentity.Name"]/*' />
        /// <devdoc>
        ///    The name of the identity (in this case, the
        ///    passport user name).
        /// </devdoc>
        public  String                       Name { get { return _Ticket.Name;}}
        /// <include file='doc\FormsIdentity.uex' path='docs/doc[@for="FormsIdentity.AuthenticationType"]/*' />
        /// <devdoc>
        ///    The type of the identity (in this case,
        ///    "Forms").
        /// </devdoc>
        public  String                       AuthenticationType { get { return "Forms";}}
        /// <include file='doc\FormsIdentity.uex' path='docs/doc[@for="FormsIdentity.IsAuthenticated"]/*' />
        /// <devdoc>
        ///    Indicates whether or not authentication took
        ///    place.
        /// </devdoc>
        public  bool                         IsAuthenticated { get { return true;}}
        /// <include file='doc\FormsIdentity.uex' path='docs/doc[@for="FormsIdentity.Ticket"]/*' />
        /// <devdoc>
        ///    Returns the FormsAuthenticationTicket
        ///    associated with the current request.
        /// </devdoc>
        public  FormsAuthenticationTicket   Ticket { get { return _Ticket;}}

        /// <include file='doc\FormsIdentity.uex' path='docs/doc[@for="FormsIdentity.FormsIdentity"]/*' />
        /// <devdoc>
        ///    Constructor.
        /// </devdoc>
        public FormsIdentity (FormsAuthenticationTicket ticket) {
            _Ticket = ticket;
        }


        private FormsAuthenticationTicket _Ticket;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\formsauthenticationmodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="FormsAuthenticationModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * FormsAuthenticationModule class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Security {
    using System.Web;
    using System.Text;
    using System.Web.Configuration;
    using System.Web.Caching;
    using System.Collections;
    using System.Web.Util;
    using System.Security.Principal;
    using System.Security.Permissions;


    /// <include file='doc\FormsAuthenticationModule.uex' path='docs/doc[@for="FormsAuthenticationModule"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class FormsAuthenticationModule : IHttpModule {

        // Config values
        private string           _FormsName;
        private string           _LoginUrl;
        private static bool      _fAuthChecked;
        private static bool      _fAuthRequired;
        private        bool      _fFormsInit;

        private FormsAuthenticationEventHandler _eventHandler;

        // Config format
        private  const string   CONFIG_DEFAULT_COOKIE  = ".ASPXAUTH";
        private  const string   CONFIG_DEFAULT_LOGINURL= "login.aspx";

        /// <include file='doc\FormsAuthenticationModule.uex' path='docs/doc[@for="FormsAuthenticationModule.FormsAuthenticationModule"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.Security.FormsAuthenticationModule'/>
        ///       class.
        ///     </para>
        /// </devdoc>
        public FormsAuthenticationModule() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }

        /// <include file='doc\FormsAuthenticationModule.uex' path='docs/doc[@for="FormsAuthenticationModule.Authenticate"]/*' />
        /// <devdoc>
        ///    This is a Global.asax event which must be
        ///    named FormsAuthenticate_OnAuthenticate event. It's used by advanced users to
        ///    customize cookie authentication.
        /// </devdoc>
        public event FormsAuthenticationEventHandler Authenticate {
            add {
                _eventHandler += value;
            }
            remove {
                _eventHandler -= value;
            }
        }

        /// <include file='doc\FormsAuthenticationModule.uex' path='docs/doc[@for="FormsAuthenticationModule.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dispose() {
        }

        /// <include file='doc\FormsAuthenticationModule.uex' path='docs/doc[@for="FormsAuthenticationModule.Init"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Init(HttpApplication app) {
            app.AuthenticateRequest += new EventHandler(this.OnEnter);
            app.EndRequest += new EventHandler(this.OnLeave);
        }

        ////////////////////////////////////////////////////////////
        // OnAuthenticate: Forms Authentication modules can override
        //             this method to create a Forms IPrincipal object from
        //             a WindowsIdentity
        private void OnAuthenticate(FormsAuthenticationEventArgs e) {

            HttpCookie cookie = null;

            ////////////////////////////////////////////////////////////
            // Step 1: If there are event handlers, invoke the handlers
            if (_eventHandler != null)
                _eventHandler(this, e);

            ////////////////////////////////////////////////////////////
            // Step 2: Check if the event handler create a user-object
            if (e.Context.User != null || e.User != null) 
            { // It did
                e.Context.User = (e.Context.User == null ? e.User : e.Context.User);
                return;
            }


            ////////////////////////////////////////////////////////////
            // Step 3: Extract the cookie and create a ticket from it
            FormsAuthenticationTicket ticket = null;
            try {
                ticket = ExtractTicketFromCookie(e.Context, _FormsName);
            } catch(Exception) {
                ticket = null;
            }            

            ////////////////////////////////////////////////////////////
            // Step 4: See if the ticket was created: No => exit immediately 
            if (ticket == null || ticket.Expired) 
                return;

            
            ////////////////////////////////////////////////////////////
            // Step 5: Renew the ticket
            FormsAuthenticationTicket ticket2 = ticket;
            if (FormsAuthentication.SlidingExpiration)
                ticket2 = FormsAuthentication.RenewTicketIfOld(ticket);

            ////////////////////////////////////////////////////////////
            // Step 6: Create a user object for the ticket
            e.Context.User = new GenericPrincipal(new FormsIdentity(ticket2), new String[0]);

            ////////////////////////////////////////////////////////////
            // Step 7: Browser does not send us the correct cookie-path
            //         Update the cookie to show the correct path
            if (!ticket2.CookiePath.Equals("/")) 
            {
                cookie = e.Context.Request.Cookies[_FormsName];                    
                if (cookie != null) {
                    cookie.Path = ticket2.CookiePath;                        
                    if (ticket2.IsPersistent)
                        cookie.Expires = ticket2.Expiration;                   
                }
            }

            ////////////////////////////////////////////////////////////
            // Step 8: If the ticket was renewed, save the ticket in the cookie
            if (ticket2 != ticket) 
            {
                String  strEnc = FormsAuthentication.Encrypt(ticket2);

                if (cookie != null)
                    cookie = e.Context.Request.Cookies[_FormsName];                    

                if (cookie == null)
                {
                    cookie = new HttpCookie(_FormsName, strEnc);
                    cookie.Path = ticket2.CookiePath;
                }

                if (ticket2.IsPersistent)
                    cookie.Expires = ticket2.Expiration;                   
                cookie.Value = strEnc;
                cookie.Secure = FormsAuthentication.RequireSSL;
            }
            if (cookie != null)
                e.Context.Response.Cookies.Add(cookie);

        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        /// <include file='doc\FormsAuthenticationModule.uex' path='docs/doc[@for="FormsAuthenticationModule.OnEnter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        private void OnEnter(Object source, EventArgs eventArgs) {
            if (_fAuthChecked && !_fAuthRequired)
                return;

            HttpApplication app;
            HttpContext context;

            app = (HttpApplication)source;
            context = app.Context;

            AuthenticationConfig settings = (AuthenticationConfig) context.GetConfig("system.web/authentication");

            if (!_fAuthChecked) {
                _fAuthRequired  = (settings.Mode == AuthenticationMode.Forms);
                _fAuthChecked = true;
            }                    

            if (!_fAuthRequired)
                return;


            if (!_fFormsInit) {
                Trace("Initializing Forms Auth Manager"); 
                FormsAuthentication.Initialize();
                _FormsName = settings.CookieName;

                if (_FormsName == null)
                    _FormsName = CONFIG_DEFAULT_COOKIE;
                Trace("Forms name is: " + _FormsName); 


                _LoginUrl = settings.LoginUrl;
                if (_LoginUrl == null)
                    _LoginUrl = CONFIG_DEFAULT_LOGINURL;
                _fFormsInit = true;
            }

            ////////////////////////////////////////////////////////
            // Step 2: Call OnAuthenticate virtual method to create
            //    an IPrincipal for this request
            OnAuthenticate( new FormsAuthenticationEventArgs(context) );
            
            ////////////////////////////////////////////////////////
            // Skip AuthZ if accessing the login page
            context.SkipAuthorization = AuthenticationConfig.AccessingLoginPage(context, _LoginUrl);
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\FormsAuthenticationModule.uex' path='docs/doc[@for="FormsAuthenticationModule.OnLeave"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        private void OnLeave(Object source, EventArgs eventArgs) {
            if (!_fAuthChecked || !_fAuthRequired)  // not-checked means OnEnter was not called
                return;

            HttpApplication    app;
            HttpContext        context;

            app       = (HttpApplication)source;
            context   = app.Context;

            ////////////////////////////////////////////////////////////
            // Step 1: Check if we are using cookie authentication and 
            //         if authentication failed
            if (context.Response.StatusCode != 401)
                return;

            
            ////////////////////////////////////////////////////////////
            // Change 401 to a redirect to login page

            // Don't do it if already there is ReturnUrl, already being redirected,
            // to avoid infinite redirection loop
            if (context.Request.QueryString["ReturnUrl"] != null)
                return;


            ////////////////////////////////////////////////////////////
            // Step 2: Get the complete url to the login-page
            String loginUrl = null;
            if (_LoginUrl != null && _LoginUrl.Length > 0)
                loginUrl = AuthenticationConfig.GetCompleteLoginUrl(context, _LoginUrl);
            
            ////////////////////////////////////////////////////////////
            // Step 3: Check if we have a valid url to the login-page
            if (loginUrl == null || loginUrl.Length <= 0) 
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Auth_Invalid_Login_Url));


            ////////////////////////////////////////////////////////////
            // Step 4: Construct the redirect-to url
            String             strUrl       = context.Request.PathWithQueryString;
            String             strRedirect;
            int                iIndex;
            String             strSep;
            

            if(context.Request.Browser["isMobileDevice"] == "true") {
                //__redir=1 is marker for devices that post on redirect
                if(strUrl.IndexOf("__redir=1") >= 0) {
                    strUrl = SanitizeUrlForCookieless(strUrl);
                }
                else {
                    if(strUrl.IndexOf('?') >= 0)
                        strSep = "&";
                    else 
                        strSep = "?";
                    strUrl = SanitizeUrlForCookieless(strUrl + strSep + "__redir=1");
                }
            }

            if (loginUrl.IndexOf('?') >= 0)
                strSep = "&";
            else
                strSep = "?";

            strRedirect = loginUrl  + strSep + "ReturnUrl=" + HttpUtility.UrlEncode(strUrl, context.Request.ContentEncoding);

            ////////////////////////////////////////////////////////////
            // Step 5: Add the query-string from the current url
            iIndex = strUrl.IndexOf('?');
            if (iIndex >= 0 && iIndex < strUrl.Length-1)
                strRedirect += "&" + strUrl.Substring(iIndex+1);


            ////////////////////////////////////////////////////////////
            // Step 6: Do the redirect
            context.Response.Redirect(strRedirect, false);
        }


        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        // Private method for removing ticket from querystring
        private string SanitizeUrlForCookieless(string strUrl) {
            //find the ticket assignment
            int iIndex = strUrl.IndexOf("?" + _FormsName + "=");
            if(iIndex == -1) {
                iIndex = strUrl.IndexOf("&" + _FormsName + "=");
            }
            if(iIndex >= 0) {
                //if querystring continues, remove redundant ampersand
                int iEnd = strUrl.IndexOf('&', iIndex + 1);
                if(iEnd >= 0) {
                    strUrl = strUrl.Remove(iIndex + 1, iEnd - iIndex);
                }
                else {
                //if querystring does not continue, remove leading separator
                    strUrl = strUrl.Substring(0, iIndex);
                }
            }
            return strUrl;
        }
        

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        // Private method for decrypting a cookie
        private static FormsAuthenticationTicket ExtractTicketFromCookie(HttpContext context, String name) {
            if (context == null || name == null)
                return null;

            Trace("Extracting cookie: " + name); 

            // Look in the cookie collection
            String                      strEncrypted   = null;
            HttpCookie                  cookie         = context.Request.Cookies[name];
            FormsAuthenticationTicket  ticket         = null;
            if (cookie != null) {
                strEncrypted = cookie.Value;
            }
            else {
                strEncrypted = context.Request[name];
                if (strEncrypted == null)
                    return null;
            }

            Trace("Encrypted cookie: " + strEncrypted); 

            ticket = FormsAuthentication.Decrypt(strEncrypted);

            if (ticket != null)
                Trace("Found ticket for user: " + ticket.Name);

            if (ticket != null && cookie == null && !ticket.Expired) {
                Trace("Saving ticket as cookie: " + name + ", " + strEncrypted + ", " + ticket.Expiration); 
                cookie = new HttpCookie(name, strEncrypted);
                cookie.Path = ticket.CookiePath;
                if (ticket.IsPersistent)
                    cookie.Expires = ticket.Expiration;
                context.Response.Cookies.Add( cookie );                    
            }
            else if (ticket != null && cookie != null && ticket.Expired) {
                Trace("Ticket in cookie is expired.");
                strEncrypted = context.Request.QueryString[name];
                if (strEncrypted != null) {
                    Trace("Encrypted ticket: " + strEncrypted);
                    ticket = FormsAuthentication.Decrypt(strEncrypted);
                    if(ticket != null)
                        Trace("Found ticket for user: " + ticket.Name);
                }
                else {
                    ticket = null;
                }
            }

            return ticket;
        }

        private static void Trace(String str) {
            Debug.Trace("cookieauth", str);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\genericauthenticationeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="GenericAuthenticationEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * DefaultAuthenticationEventArgs class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.Security {
    using  System.Security.Principal;
    using System.Security.Permissions;

    /// <include file='doc\GenericAuthenticationEventArgs.uex' path='docs/doc[@for="DefaultAuthenticationEventArgs"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DefaultAuthenticationEventArgs : EventArgs {
        private HttpContext       _Context;
        /// <include file='doc\GenericAuthenticationEventArgs.uex' path='docs/doc[@for="DefaultAuthenticationEventArgs.Context"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public  HttpContext       Context { get { return _Context;}}

        /// <include file='doc\GenericAuthenticationEventArgs.uex' path='docs/doc[@for="DefaultAuthenticationEventArgs.DefaultAuthenticationEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DefaultAuthenticationEventArgs(HttpContext context) {
            _Context = context;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\formsauthenticationticket.cs ===
//------------------------------------------------------------------------------
// <copyright file="FormsAuthenticationTicket.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * FormsAuthenticationTicket class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Security {
    using  System.Security.Principal;
    using System.Security.Permissions;


    /// <include file='doc\FormsAuthenticationTicket.uex' path='docs/doc[@for="FormsAuthenticationTicket"]/*' />
    /// <devdoc>
    ///    <para>This class encapsulates the information represented in
    ///       an authentication cookie as used by FormsAuthenticationModule.</para>
    /// </devdoc>
    [Serializable]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class FormsAuthenticationTicket {
        /// <include file='doc\FormsAuthenticationTicket.uex' path='docs/doc[@for="FormsAuthenticationTicket.Version"]/*' />
        /// <devdoc>
        ///    <para>A one byte version number for future
        ///       use.</para>
        /// </devdoc>
        public int       Version { get { return _Version;}}
        /// <include file='doc\FormsAuthenticationTicket.uex' path='docs/doc[@for="FormsAuthenticationTicket.Name"]/*' />
        /// <devdoc>
        ///    The user name associated with the
        ///    authentication cookie. Note that, at most, 32 bytes are stored in the
        ///    cookie.
        /// </devdoc>
        public String    Name { get { return _Name;}}
        /// <include file='doc\FormsAuthenticationTicket.uex' path='docs/doc[@for="FormsAuthenticationTicket.Expiration"]/*' />
        /// <devdoc>
        ///    The date/time at which the cookie
        ///    expires.
        /// </devdoc>
        public DateTime  Expiration { get { return _Expiration;}}
        /// <include file='doc\FormsAuthenticationTicket.uex' path='docs/doc[@for="FormsAuthenticationTicket.IssueDate"]/*' />
        /// <devdoc>
        ///    The time at which the cookie was originally
        ///    issued. This can be used for custom expiration schemes.
        /// </devdoc>
        public DateTime  IssueDate { get { return _IssueDate;}}
        /// <include file='doc\FormsAuthenticationTicket.uex' path='docs/doc[@for="FormsAuthenticationTicket.IsPersistent"]/*' />
        /// <devdoc>
        ///    True if a durable cookie was issued.
        ///    Otherwise, the authentication cookie is scoped to the browser lifetime.
        /// </devdoc>
        public bool      IsPersistent { get { return _IsPersistent;}}
        /// <include file='doc\FormsAuthenticationTicket.uex' path='docs/doc[@for="FormsAuthenticationTicket.Expired"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool      Expired { get { return Expiration < DateTime.Now;}}
        /// <include file='doc\FormsAuthenticationTicket.uex' path='docs/doc[@for="FormsAuthenticationTicket.UserData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String    UserData { get { return _UserData;}}

        /// <include file='doc\FormsAuthenticationTicket.uex' path='docs/doc[@for="FormsAuthenticationTicket.CookiePath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String    CookiePath { get { return _CookiePath;}}


        private int       _Version;
        private String    _Name;
        private DateTime  _Expiration;
        private DateTime  _IssueDate;
        private bool      _IsPersistent;
        private String    _UserData;
        private String    _CookiePath;

        /// <include file='doc\FormsAuthenticationTicket.uex' path='docs/doc[@for="FormsAuthenticationTicket.FormsAuthenticationTicket"]/*' />
        /// <devdoc>
        ///    <para>This constructor creates a
        ///       FormsAuthenticationTicket instance with explicit values.</para>
        /// </devdoc>
        public FormsAuthenticationTicket(int version, 
                                          String name, 
                                          DateTime issueDate, 
                                          DateTime expiration, 
                                          bool isPersistent, 
                                          String userData) {
            _Version = version;
            _Name = name;
            _Expiration = expiration;
            _IssueDate = issueDate;
            _IsPersistent = isPersistent;
            _UserData = userData;
            _CookiePath = FormsAuthentication.FormsCookiePath;
        }

        /// <include file='doc\FormsAuthenticationTicket.uex' path='docs/doc[@for="FormsAuthenticationTicket.FormsAuthenticationTicket2"]/*' />
        public FormsAuthenticationTicket(int version, 
                                          String name, 
                                          DateTime issueDate, 
                                          DateTime expiration, 
                                          bool isPersistent, 
                                          String userData,
                                          String cookiePath) {
            _Version = version;
            _Name = name;
            _Expiration = expiration;
            _IssueDate = issueDate;
            _IsPersistent = isPersistent;
            _UserData = userData;
            _CookiePath = cookiePath;
        }

        /// <include file='doc\FormsAuthenticationTicket.uex' path='docs/doc[@for="FormsAuthenticationTicket.FormsAuthenticationTicket1"]/*' />
        /// <devdoc>
        ///    <para> This constructor creates
        ///       a FormsAuthenticationTicket instance with the specified name and cookie durability,
        ///       and default values for the other settings.</para>
        /// </devdoc>
        public FormsAuthenticationTicket(String name, bool isPersistent, Int32 timeout) {
            _Version = 1;
            _Name = name;
            _IssueDate = DateTime.Now;
            _IsPersistent = isPersistent;
            _UserData = "";
            if (isPersistent)
                _Expiration = DateTime.Now.AddYears(50);
            else
                _Expiration = DateTime.Now.AddMinutes(timeout);
            _CookiePath = FormsAuthentication.FormsCookiePath;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\genericauthenticationeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="GenericAuthenticationEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * DefaultAuthenticationEventHandler class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.Security {
    using  System.Security.Principal;

    /// <include file='doc\GenericAuthenticationEventHandler.uex' path='docs/doc[@for="DefaultAuthenticationEventHandler"]/*' />
    /// <devdoc>
    ///    This delegate defines the signature of the
    ///    event handler for the PassportAuthentication_OnAuthenticate event.
    /// </devdoc>
    public delegate void DefaultAuthenticationEventHandler(Object sender,  DefaultAuthenticationEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\passportauthenticationeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="PassportAuthenticationEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * PassportAuthenticationEventHandler class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.Security {
    using  System.Security.Principal;

    /// <include file='doc\PassportAuthenticationEventHandler.uex' path='docs/doc[@for="PassportAuthenticationEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void PassportAuthenticationEventHandler(Object sender,  PassportAuthenticationEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\passportauthenticationeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="PassportAuthenticationEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * PassportAuthenticationEventArgs class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.Security {
    using  System.Security.Principal;
    using System.Security.Permissions;

    /// <include file='doc\PassportAuthenticationEventArgs.uex' path='docs/doc[@for="PassportAuthenticationEventArgs"]/*' />
    /// <devdoc>
    ///    <SPAN>The 
    ///       event argument passed to the PassportAuthentication_OnAuthenticate event by the
    ///       PassportAuthentication module.<SPAN>
    ///    </SPAN>Since there is already an identity at this point, this is useful mainly 
    ///    for attaching a custom IPrincipal object to the context using the supplied
    ///    identity.</SPAN>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class PassportAuthenticationEventArgs : EventArgs {
        private IPrincipal             _User;
        private HttpContext       _Context;
        private PassportIdentity  _Identity;

        /// <include file='doc\PassportAuthenticationEventArgs.uex' path='docs/doc[@for="PassportAuthenticationEventArgs.User"]/*' />
        /// <devdoc>
        ///    <SPAN>IPrincipal 
        ///       object to be associated with the request.<SPAN>
        ///    </SPAN>The user object should be attached to the context.<SPAN> </SPAN>If User is non null and Context.User is 
        ///    null, the PassportAuthenticationModule will initialize Context.User with
        ///    PassportAuthenticationEventArgs.User.</SPAN>
        /// </devdoc>        
        public  IPrincipal             User { 
            get { return _User;} 
            set { 
                InternalSecurityPermissions.ControlPrincipal.Demand();
                _User = value;
            }
        }
        /// <include file='doc\PassportAuthenticationEventArgs.uex' path='docs/doc[@for="PassportAuthenticationEventArgs.Context"]/*' />
        /// <devdoc>
        ///    <SPAN>The 
        ///       HttpContext intrinsic - most notably provides access to Request, Response, and
        ///       User objects.<SPAN> </SPAN></SPAN>
        /// </devdoc>
        public  HttpContext       Context { get { return _Context;}}
        /// <include file='doc\PassportAuthenticationEventArgs.uex' path='docs/doc[@for="PassportAuthenticationEventArgs.Identity"]/*' />
        /// <devdoc>
        ///    An authenticated Passport identity.
        /// </devdoc>
        public  PassportIdentity  Identity { get { return _Identity;}}

        /// <include file='doc\PassportAuthenticationEventArgs.uex' path='docs/doc[@for="PassportAuthenticationEventArgs.PassportAuthenticationEventArgs"]/*' />
        /// <devdoc>
        ///    Constructor
        /// </devdoc>
        public PassportAuthenticationEventArgs(PassportIdentity identity, HttpContext context) {
            _Identity = identity;
            _Context = context;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\passportidentity.cs ===
//------------------------------------------------------------------------------
// <copyright file="PassportIdentity.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * PassportIdentity
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Security {
    using System.Text;
    using System.Web;
    using System.Web.Util;
    using System.Security.Principal;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;

    /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity"]/*' />
    /// <devdoc>
    ///    This IIdenty derived class provides access
    ///    to the Passport profile information contained in the Passport profile cookies.
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class PassportIdentity : IIdentity {
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        // Private Data
        private  String        _Name;
        private  bool          _Authenticated;
        private  IntPtr        _iPassport;
        private static int     _iPassportVer=0;
        private  bool          _WWWAuthHeaderSet = false;
        internal bool          WWWAuthHeaderSet { get { return _WWWAuthHeaderSet; }}

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        // Construtor
        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.PassportIdentity"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PassportIdentity() {
            InternalSecurityPermissions.UnmanagedCode.Demand();

            HttpContext context  = HttpContext.Current;

            if (_iPassportVer == 0)
                _iPassportVer = UnsafeNativeMethods.PassportVersion();

            if (_iPassportVer < 3) {
                String      strTVariable       = context.Request.QueryString["t"];
                String      strPVariable       = context.Request.QueryString["p"];
                HttpCookie  cookieAuth         = context.Request.Cookies["MSPAuth"];
                HttpCookie  cookieProf         = context.Request.Cookies["MSPProf"];
                HttpCookie  cookieProfC        = context.Request.Cookies["MSPProfC"];
                String      strMSPAuthCookie   = ((cookieAuth  != null && cookieAuth.Value  != null) ? cookieAuth.Value  : "");
                String      strMSPProfCookie   = ((cookieProf  != null && cookieProf.Value  != null) ? cookieProf.Value  : "");
                String      strMSPProfCCookie  = ((cookieProfC != null && cookieProfC.Value != null) ? cookieProfC.Value : "");

                StringBuilder strA = new  StringBuilder(1028);
                StringBuilder strP = new  StringBuilder(1028);

                strMSPAuthCookie  = HttpUtility.UrlDecode(strMSPAuthCookie);
                strMSPProfCookie  = HttpUtility.UrlDecode(strMSPProfCookie);
                strMSPProfCCookie = HttpUtility.UrlDecode(strMSPProfCCookie);

                int iRet = UnsafeNativeMethods.PassportCreate(strTVariable, strPVariable, strMSPAuthCookie, 
                                                              strMSPProfCookie, strMSPProfCCookie, strA, strP, 1024, ref _iPassport);
                if (_iPassport == (IntPtr)0)
                    throw new COMException(HttpRuntime.FormatResourceString(SR.Could_not_create_passport_identity), iRet);

                String strACookie = UrlEncodeCookie(strA.ToString()); //HttpUtility.AspCompatUrlEncode(strA.ToString());
                String strPCookie = UrlEncodeCookie(strP.ToString()); //HttpUtility.AspCompatUrlEncode(strP.ToString());

                if (strACookie.Length > 1)
                {
                    context.Response.AppendHeader("Set-Cookie", strACookie);
                }             
                if (strPCookie.Length > 1) {
                    context.Response.AppendHeader("Set-Cookie", strPCookie);
                }

            } else {                
                String   strRequestLine = context.Request.HttpMethod + " " + 
                                          context.Request.RawUrl + " " + 
                                          context.Request.ServerVariables["SERVER_PROTOCOL"] + "\r\n";
                StringBuilder szOut = new StringBuilder(4092);
                int iRet = UnsafeNativeMethods.PassportCreateHttpRaw(strRequestLine, 
                                                                     context.Request.ServerVariables["ALL_RAW"],
                                                                     context.Request.IsSecureConnection ? 1 : 0,
                                                                     szOut, 4090, ref _iPassport);
                
                if (_iPassport == (IntPtr)0)
                    throw new COMException(HttpRuntime.FormatResourceString(SR.Could_not_create_passport_identity), iRet);

                // Should we call PassportContinue?
                if ((UInt32)iRet == 0x80040207) {                    
                    byte []   bufContent     = new byte[4096];
                    uint      iContent       = 4090;
                    byte []   bufPostedData  = new byte[context.Request.TotalBytes];

                    if (bufPostedData.Length > 0)
                        context.Request.InputStream.Read(bufPostedData, 0, bufPostedData.Length);

                    iRet = UnsafeNativeMethods.PassportContinueStartPageHTTPRaw(_iPassport, bufPostedData, (int) bufPostedData.Length, 
                                                                                szOut, 4090, bufContent, ref iContent);

                    if(iRet ==  HResults.E_INSUFFICIENT_BUFFER && iContent > 4090)
                    {
                        bufContent = new byte[iContent];
                        iRet = UnsafeNativeMethods.PassportContinueStartPageHTTPRaw(_iPassport, bufPostedData, (int) bufPostedData.Length, 
                                                                                    szOut, 4090, bufContent, ref iContent);
                    }

                    if (iRet == 0 && iContent > 0)
                        context.Response.OutputStream.Write(bufContent, 0, (int)iContent); 
                }                
                
                String strResponseHeaders = szOut.ToString();                
                SetHeaders(context, strResponseHeaders);
            }

            _Authenticated = GetIsAuthenticated(-1, -1, -1);
            if (_Authenticated == false) {
                _Name = "";            
            }                        
        }


        private void SetHeaders(HttpContext context, String strResponseHeaders) {
            for(int iStart = 0; iStart < strResponseHeaders.Length;)
            {
                int iEnd = strResponseHeaders.IndexOf('\r', iStart);
                if (iEnd < 0)
                    iEnd = strResponseHeaders.Length;
                String strCurrentHeader = strResponseHeaders.Substring(iStart, iEnd - iStart);
                int iColon = strCurrentHeader.IndexOf(':');
                if (iColon > 0)
                {
                    String strHeader = strCurrentHeader.Substring(0, iColon);
                    String strValue = strCurrentHeader.Substring(iColon+1);
                    context.Response.AppendHeader(strHeader, strValue);
                }

                iStart = iEnd + 2;
            }
        } 

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.Finalize"]/*' />
        ~PassportIdentity() {
            UnsafeNativeMethods.PassportDestroy(_iPassport);
            _iPassport = (IntPtr)0;
        }


        private static string UrlEncodeCookie(string strIn) {
            if (strIn == null || strIn.Length < 1)
                return "";
            int iPos1 = strIn.IndexOf('=');
            if (iPos1 < 0)
                return HttpUtility.AspCompatUrlEncode(strIn);
            
            iPos1++;
            int iPos2 = strIn.IndexOf(';', iPos1);
            if (iPos2 < 0)
                return HttpUtility.AspCompatUrlEncode(strIn);           

            string str1 = strIn.Substring(0, iPos1);
            string str2 = strIn.Substring(iPos1, iPos2-iPos1);
            string str3 = strIn.Substring(iPos2, strIn.Length-iPos2);

            return str1 + HttpUtility.AspCompatUrlEncode(str2) + str3;
        }


        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        // Properties
        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.Name"]/*' />
        /// <devdoc>
        ///    The name of the identity. In this
        ///    case, the Passport user name.
        /// </devdoc>
        public   String    Name { 
            get { 
                if (_Name == null) {
                    if (_iPassportVer >= 3)
                        _Name = HexPUID;
                    else
                        if (HasProfile("core")) 
                            _Name = Int32.Parse(this["MemberIDHigh"]).ToString("X8") + Int32.Parse(this["MemberIDLow"]).ToString("X8");
                        else
                            _Name = "";
                }

                return _Name; 
            } 
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.AuthenticationType"]/*' />
        /// <devdoc>
        ///    The type of the identity. In this
        ///    case, "Passport".
        /// </devdoc>
        public   String    AuthenticationType { get { return "Passport";}}
        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.IsAuthenticated"]/*' />
        /// <devdoc>
        ///    <para>True if the user is authenticated against a
        ///       Passport authority.</para>
        /// </devdoc>
        public   bool      IsAuthenticated { get { return _Authenticated;}}

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String  this[String strProfileName]
        {
            get { 
                Object oValue = GetProfileObject(strProfileName);
                if (oValue == null)
                    return "";
                if (oValue.GetType() == typeof(String))
                    return(String) oValue;
                else
                    return oValue.ToString();
            }            
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.GetIsAuthenticated"]/*' />
        /// <devdoc>
        ///    Returns true if the user is authenticated
        ///    against a Passport authority.
        /// </devdoc>
        public bool GetIsAuthenticated(int    iTimeWindow,
                                       bool   bForceLogin,
                                       bool   bCheckSecure)
        {
            return GetIsAuthenticated(iTimeWindow, bForceLogin ? 1 : 0, bCheckSecure ? 10 : 0);
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.GetIsAuthenticated1"]/*' />
        public bool GetIsAuthenticated(int   iTimeWindow,
                                       int   iForceLogin,
                                       int   iCheckSecure)
        {
            int iRet = UnsafeNativeMethods.PassportIsAuthenticated(_iPassport, 
                                                                   iTimeWindow, 
                                                                   iForceLogin, 
                                                                   iCheckSecure);
            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
                     
            return (iRet == 0);            
        }
                                       

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.GetProfileObject"]/*' />
        /// <devdoc>
        ///    Returns Passport profile information for
        ///    the supplied profile attribute.
        /// </devdoc>
        public Object GetProfileObject(String strProfileName) {
            Object oOut = new Object();

            int iRet = UnsafeNativeMethods.PassportGetProfile(_iPassport, strProfileName, out oOut);
            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return oOut;
        } 

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.Error"]/*' />
        /// <devdoc>
        ///    Returns an error state associated with the
        ///    current Passport ticket. See the error property in the Passport documentation
        ///    for more information.
        /// </devdoc>
        public int Error {
            get {
                return UnsafeNativeMethods.PassportGetError(_iPassport);
            }
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.GetFromNetworkServer"]/*' />
        /// <devdoc>
        ///    True if a connection is coming back from
        ///    the Passport server (log-in, update, or registration) and if the Passport data
        ///    contained on the query string is valid.
        /// </devdoc>
        public bool GetFromNetworkServer {
            get {
                int iRet = UnsafeNativeMethods.PassportGetFromNetworkServer(_iPassport);
                if (iRet < 0)
                    throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
                return(iRet == 0);
            }
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.GetDomainFromMemberName"]/*' />
        /// <devdoc>
        ///    Returns the Passport domain from the member
        ///    name string.
        /// </devdoc>
        public String GetDomainFromMemberName(String strMemberName) {
            StringBuilder str = new StringBuilder(1028);                
            int iRet = UnsafeNativeMethods.PassportDomainFromMemberName(_iPassport, strMemberName, str, 1024);
            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return str.ToString();
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.HasProfile"]/*' />
        /// <devdoc>
        ///    Determines whether or not a given profile
        ///    attribute exists in this user's profile.
        /// </devdoc>
        public bool HasProfile(String strProfile) {
            int iRet = UnsafeNativeMethods.PassportHasProfile(_iPassport, strProfile);
            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return(iRet == 0);
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.HasProfile1"]/*' />
        public bool HasFlag(int iFlagMask) {
            int iRet = UnsafeNativeMethods.PassportHasFlag(_iPassport, iFlagMask);
            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return(iRet == 0);
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.HaveConsent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool HaveConsent(bool bNeedFullConsent, bool bNeedBirthdate) {
            int iRet = UnsafeNativeMethods.PassportHasConsent(_iPassport, bNeedFullConsent ? 1 : 0, bNeedBirthdate ? 1 : 0);
            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return(iRet == 0);
        }


        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.GetOption"]/*' />
        public Object GetOption(String strOpt) {
            Object vOut = new Object();
            int iRet = UnsafeNativeMethods.PassportGetOption(_iPassport, strOpt, out vOut);
            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return vOut;
        } 

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.SetOption"]/*' />
        public void SetOption(String strOpt, Object vOpt) {
            int iRet = UnsafeNativeMethods.PassportSetOption(_iPassport, strOpt, vOpt);
            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
        } 

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LogoutURL"]/*' />
        public String LogoutURL() {
            return LogoutURL(null, null, -1, null, -1);
        }
    
        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LogoutURL1"]/*' />
        public String LogoutURL(String      szReturnURL,
                                String      szCOBrandArgs,
                                int         iLangID,
                                String      strDomain,
                                int         iUseSecureAuth) {
            StringBuilder szOut = new StringBuilder(4096);                
            int iRet = UnsafeNativeMethods.PassportLogoutURL(_iPassport,
                                                             szReturnURL,
                                                             szCOBrandArgs,
                                                             iLangID,
                                                             strDomain,
                                                             iUseSecureAuth,
                                                             szOut,
                                                             4096);

            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return szOut.ToString();
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.HasSavedPassword"]/*' />
        /// <devdoc>
        ///    True if the Passport member's ticket
        ///    indicates that they have chosen to save the password on the Passport login page
        ///    of the last ticket refresh.
        /// </devdoc>
        public bool HasSavedPassword {
            get {
                int iRet = UnsafeNativeMethods.PassportGetHasSavedPassword(_iPassport);
                if (iRet < 0)
                    throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
                return(iRet == 0);
            }
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.HasTicket"]/*' />
        /// <devdoc>
        ///    True if there is a Passport ticket as a
        ///    cookie on thequery string.
        /// </devdoc>
        public bool HasTicket {
            get {
                int iRet = UnsafeNativeMethods.PassportHasTicket(_iPassport);
                if (iRet < 0)
                    throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
                return(iRet == 0);
            }
        }


        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.TicketAge"]/*' />
        /// <devdoc>
        ///    Time in seconds since the last ticket was
        ///    issued or refreshed.
        /// </devdoc>
        public int TicketAge {
            get {
                int iRet = UnsafeNativeMethods.PassportGetTicketAge(_iPassport);
                if (iRet < 0)
                    throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
                return iRet;
            }
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.TimeSinceSignIn"]/*' />
        /// <devdoc>
        ///    The time is seconds since a member's
        ///    sign-in to the Passport login server.
        /// </devdoc>
        public int TimeSinceSignIn {
            get {
                int iRet = UnsafeNativeMethods.PassportGetTimeSinceSignIn(_iPassport);
                if (iRet < 0)
                    throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
                return iRet;
            }
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        // Functions
        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LogoTag"]/*' />
        /// <devdoc>
        ///    <para>Returns an HTML snippet containing an image tag for a Passport link. This is 
        ///       based on the current state of the identity (already signed in, and such).</para>
        /// </devdoc>
          public  String  LogoTag() {
              return LogoTag(null, -1, 
                             -1, null, -1, -1,
                             null, -1, -1);
          }

          /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LogoTag4"]/*' />
          public  String  LogoTag(String strReturnUrl) {
              return LogoTag(strReturnUrl, -1, 
                             -1, null, -1, -1,
                             null, -1, -1);
          }


        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LogoTag2"]/*' />
        public  String  LogoTag2() {
            return LogoTag2(null, -1, 
                           -1, null, -1, -1,
                           null, -1, -1);
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LogoTag23"]/*' />
        public  String  LogoTag2(String strReturnUrl) {
            return LogoTag2(strReturnUrl, -1, 
                           -1, null, -1, -1,
                           null, -1, -1);
        }


        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LogoTag1"]/*' />
        /// <devdoc>
        ///    Similar to LogoTag(), this method returns
        ///    an HTML snippet for the Passport Logo for the current member
        /// </devdoc>
          public String LogoTag(String    strReturnUrl, 
                                  int       iTimeWindow, 
                                  bool      fForceLogin, 
                                  String    strCoBrandedArgs,
                                  int       iLangID,
                                bool      fSecure,
                                String    strNameSpace,
                                int       iKPP,
                                bool      bUseSecureAuth)
        {
            return LogoTag(                                                
                    strReturnUrl, 
                    iTimeWindow, 
                    (fForceLogin ? 1 : 0), 
                    strCoBrandedArgs, 
                    iLangID,
                    fSecure ? 1 : 0,
                    strNameSpace,
                    iKPP,
                    bUseSecureAuth ? 10 : 0);
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LogoTag3"]/*' />
        public String LogoTag(String    strReturnUrl, 
                              int       iTimeWindow, 
                              int       iForceLogin, 
                              String    strCoBrandedArgs,
                              int       iLangID,
                              int       iSecure,
                              String    strNameSpace,
                              int       iKPP,
                              int       iUseSecureAuth)
        {
            StringBuilder str = new StringBuilder(4092);
            int iRet = UnsafeNativeMethods.PassportLogoTag(_iPassport, 
                                                     strReturnUrl, 
                                                     iTimeWindow, 
                                                     iForceLogin, 
                                                     strCoBrandedArgs, 
                                                     iLangID,
                                                     iSecure,
                                                     strNameSpace,
                                                     iKPP,
                                                     iUseSecureAuth,
                                                     str, 
                                                     4090);

            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return str.ToString();
        }



        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LogoTag21"]/*' />
        public String LogoTag2(String    strReturnUrl, 
                                int       iTimeWindow, 
                                bool      fForceLogin, 
                                String    strCoBrandedArgs,
                                int       iLangID,
                                bool      fSecure,
                                String    strNameSpace,
                                int       iKPP,
                                bool      bUseSecureAuth)
        {
            return LogoTag2(
                    strReturnUrl, 
                    iTimeWindow, 
                    fForceLogin ? 1 : 0, 
                    strCoBrandedArgs,
                    iLangID,
                    fSecure ? 1 : 0,
                    strNameSpace,
                    iKPP,
                    bUseSecureAuth ? 10 : 0);
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LogoTag22"]/*' />
        public String LogoTag2(String    strReturnUrl, 
                              int       iTimeWindow, 
                              int       iForceLogin, 
                              String    strCoBrandedArgs,
                              int       iLangID,
                              int       iSecure,
                              String    strNameSpace,
                              int       iKPP,
                              int       iUseSecureAuth)
        {
            StringBuilder str = new StringBuilder(4092);
            int iRet = UnsafeNativeMethods.PassportLogoTag2(_iPassport, 
                                                     strReturnUrl, 
                                                     iTimeWindow, 
                                                     iForceLogin, 
                                                     strCoBrandedArgs, 
                                                     iLangID,
                                                     iSecure,
                                                     strNameSpace,
                                                     iKPP,
                                                     iUseSecureAuth,
                                                     str, 
                                                     4090);

            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return str.ToString();
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.AuthUrl"]/*' />
        /// <devdoc>
        /// </devdoc>
        public  String  AuthUrl() {
            return AuthUrl(null, -1, -1, null, -1, null, -1, -1); 
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.AuthUrl4"]/*' />
        public  String  AuthUrl(String strReturnUrl) {
            return AuthUrl(strReturnUrl, -1, -1, null, -1, null, -1, -1); 
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.AuthUrl2"]/*' />
        public  String  AuthUrl2() {
            return AuthUrl2(null, -1, -1, null, -1, null, -1, -1); 
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.AuthUrl23"]/*' />
        public  String  AuthUrl2(String strReturnUrl) {
            return AuthUrl2(strReturnUrl, -1, -1, null, -1, null, -1, -1); 
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.AuthUrl1"]/*' />
        /// <devdoc>
        ///    <para>Similar to AuthUrl(). Returns the authentication server URL for
        ///       a member</para>
        /// </devdoc>
        public String AuthUrl  (String    strReturnUrl, 
                                int       iTimeWindow, 
                                bool      fForceLogin, 
                                String    strCoBrandedArgs,
                                int       iLangID,
                                String    strNameSpace,
                                int       iKPP,
                                bool      bUseSecureAuth)            
        {
            StringBuilder str = new StringBuilder(4092);
            int iRet = UnsafeNativeMethods.PassportAuthURL(_iPassport, 
                                                     strReturnUrl, 
                                                     iTimeWindow, 
                                                     (fForceLogin ? 1 : 0), 
                                                     strCoBrandedArgs, 
                                                     iLangID, 
                                                     strNameSpace,
                                                     iKPP,
                                                     bUseSecureAuth ? 10 : 0,
                                                     str,
                                                     4090);

            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return str.ToString();
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.AuthUrl21"]/*' />
        public String AuthUrl2  (String    strReturnUrl, 
                                int       iTimeWindow, 
                                bool      fForceLogin, 
                                String    strCoBrandedArgs,
                                int       iLangID,
                                String    strNameSpace,
                                int       iKPP,
                                bool      bUseSecureAuth)
            
        {
            StringBuilder str = new StringBuilder(4092);
            int iRet = UnsafeNativeMethods.PassportAuthURL2(_iPassport, 
                                                     strReturnUrl, 
                                                     iTimeWindow, 
                                                     (fForceLogin ? 1 : 0), 
                                                     strCoBrandedArgs, 
                                                     iLangID, 
                                                     strNameSpace,
                                                     iKPP,
                                                     bUseSecureAuth ? 10 : 0,
                                                     str,
                                                     4090);

            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return str.ToString();
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.AuthUrl3"]/*' />
        public String AuthUrl  (String    strReturnUrl, 
                                int       iTimeWindow, 
                                int       iForceLogin, 
                                String    strCoBrandedArgs,
                                int       iLangID,
                                String    strNameSpace,
                                int       iKPP,
                                int       iUseSecureAuth)

        {
            StringBuilder str = new StringBuilder(4092);
            int iRet = UnsafeNativeMethods.PassportAuthURL(_iPassport, 
                                                     strReturnUrl, 
                                                     iTimeWindow, 
                                                     iForceLogin, 
                                                     strCoBrandedArgs, 
                                                     iLangID, 
                                                     strNameSpace,
                                                     iKPP,
                                                     iUseSecureAuth,
                                                     str,
                                                     4090);

            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return str.ToString();
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.AuthUrl22"]/*' />
        public String AuthUrl2  (String    strReturnUrl, 
                                int       iTimeWindow, 
                                int       iForceLogin, 
                                String    strCoBrandedArgs,
                                int       iLangID,
                                String    strNameSpace,
                                int       iKPP,
                                int       iUseSecureAuth) {
            StringBuilder str = new StringBuilder(4092);
            int iRet = UnsafeNativeMethods.PassportAuthURL2(_iPassport, 
                                                     strReturnUrl, 
                                                     iTimeWindow, 
                                                     iForceLogin, 
                                                     strCoBrandedArgs, 
                                                     iLangID, 
                                                     strNameSpace,
                                                     iKPP,
                                                     iUseSecureAuth,
                                                     str,
                                                     4090);

            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return str.ToString();
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LoginUser"]/*' />
        public int LoginUser(
                String        szRetURL,
                int           iTimeWindow,
                bool          fForceLogin,
                String        szCOBrandArgs,
                int           iLangID,
                String        strNameSpace,
                int           iKPP,
                bool          fUseSecureAuth,
                object        oExtraParams) {
            return LoginUser(
                szRetURL,
                iTimeWindow,
                fForceLogin ? 1 : 0,
                szCOBrandArgs,
                iLangID,
                strNameSpace,
                iKPP,
                fUseSecureAuth ? 10 : 0,
                oExtraParams);
        }
                
        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LoginUser1"]/*' />
        public int LoginUser(
                String        szRetURL,
                int           iTimeWindow,
                int           fForceLogin,
                String        szCOBrandArgs,
                int           iLangID,
                String        strNameSpace,
                int           iKPP,
                int           iUseSecureAuth,
                object        oExtraParams) {

            String str = GetLoginChallenge(szRetURL, iTimeWindow, fForceLogin, szCOBrandArgs, 
                                           iLangID, strNameSpace, iKPP, iUseSecureAuth, oExtraParams);

            if (str == null || str.Length < 1)
                return -1;

            HttpContext context = HttpContext.Current;
            SetHeaders(context, str);
            _WWWAuthHeaderSet = true;

            str = context.Request.Headers["Accept-Auth"];
            if (str != null && str.Length > 0 && str.IndexOf("Passport") >= 0) {
                context.Response.StatusCode = 401;
                context.Response.End();
                return 0;
            }

            str = AuthUrl(szRetURL, iTimeWindow, fForceLogin, szCOBrandArgs,
                          iLangID, strNameSpace, iKPP, iUseSecureAuth);

            if (str != null && str.Length > 0) {
                context.Response.Redirect(str, false);
                return 0;
            }

            return -1;
        }
                

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LoginUser2"]/*' />
        public int LoginUser() {
            return LoginUser(null, -1, -1, null, -1, null, -1, -1, null);            
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.LoginUser3"]/*' />
        public int LoginUser(String strReturnUrl) {
            return LoginUser(strReturnUrl, -1, -1, null, -1, null, -1, -1, null);            
        }
                

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.GetLoginChallenge"]/*' />
        public String GetLoginChallenge() {
            return GetLoginChallenge(null, -1, -1, null, -1, null, -1, -1, null);
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.GetLoginChallenge2"]/*' />
        public String GetLoginChallenge(String strReturnUrl) {
            return GetLoginChallenge(strReturnUrl, -1, -1, null, -1, null, -1, -1, null);
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.GetLoginChallenge1"]/*' />
        public String GetLoginChallenge(
                String        szRetURL,
                int           iTimeWindow,
                int           fForceLogin,
                String        szCOBrandArgs,
                int           iLangID,
                String        strNameSpace,
                int           iKPP,
                int           iUseSecureAuth,
                object        oExtraParams) {

            StringBuilder str = new StringBuilder(4092);
            int iRet = UnsafeNativeMethods.PassportGetLoginChallenge(
                    _iPassport,                    
                    szRetURL,
                    iTimeWindow,
                    fForceLogin,
                    szCOBrandArgs,
                    iLangID,
                    strNameSpace,
                    iKPP,
                    iUseSecureAuth,
                    oExtraParams,
                    str, 4090);

            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            String strRet = str.ToString();
            if (strRet != null && !strRet.StartsWith("WWW-Authenticate"))
                strRet = "WWW-Authenticate: " + strRet;
            return strRet;
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.GetDomainAttribute"]/*' />
        /// <devdoc>
        ///    Provides information for a Passport domain
        ///    by querying the Passport CCD for the requested domain attribute.
        /// </devdoc>
        public String GetDomainAttribute(String strAttribute, int iLCID, String strDomain) {
            StringBuilder str = new  StringBuilder(1028);            
            int iRet = UnsafeNativeMethods.PassportGetDomainAttribute(_iPassport, strAttribute, iLCID, strDomain, str, 1024);
            if (iRet >= 0)
                return str.ToString();
            else
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.Ticket"]/*' />
        public Object Ticket(String strAttribute) {
            Object oOut = new Object();
            int iRet = UnsafeNativeMethods.PassportTicket(_iPassport, strAttribute, out oOut);
            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return oOut;
        }    

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.GetCurrentConfig"]/*' />
        public Object GetCurrentConfig(String strAttribute) {
            Object oOut = new Object();
            int iRet = UnsafeNativeMethods.PassportGetCurrentConfig(_iPassport, strAttribute, out oOut);
            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return oOut;
        }    

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.HexPUID"]/*' />
        public String HexPUID { get {
            StringBuilder str = new StringBuilder(1024);
            int iRet = UnsafeNativeMethods.PassportHexPUID(_iPassport, str, 1024);
            if (iRet >= 0)
                return str.ToString();
            else
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
        } }
        

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.SignOut"]/*' />
        /// <devdoc>
        ///    Signs out the given Passport member from
        ///    their current session.
        /// </devdoc>
        public static void SignOut(String strSignOutDotGifFileName) {
            HttpContext      context         = HttpContext.Current;
            String []        sCookieNames    = {"MSPAuth", "MSPProf", "MSPConsent", "MSPSecAuth", "MSPProfC"};
            String []        sCookieDomains  = {"TicketDomain", "TicketDomain", "ProfileDomain", "SecureDomain", "TicketDomain"};
            String []        sCookiePaths    = {"TicketPath", "TicketPath", "ProfilePath", "SecurePath", "TicketPath"};
            String []        sCookieDomainsV = new String[5];
            String []        sCookiePathsV   = new String[5];
            PassportIdentity pi              = null;
            int              iter            = 0;
            
            ////////////////////////////////////////////////////////////
            // Step 1: Clear all headers
            context.Response.ClearHeaders();

            ////////////////////////////////////////////////////////////
            // Step 2: Get passport config information (if using Passport 2.0 sdk)
            try {
                if (context.User.Identity is PassportIdentity) {
                    pi = (PassportIdentity) context.User.Identity;
                } else {
                    pi = new PassportIdentity();
                }

                if (pi != null && _iPassportVer >= 3) {
                    // Get Domains
                    for(iter=0; iter<5; iter++) {
                        Object obj = pi.GetCurrentConfig(sCookieDomains[iter]);
                        if (obj != null && (obj is String))
                            sCookieDomainsV[iter] = (String) obj; 
                    }
                    
                    // Get Paths
                    for(iter=0; iter<5; iter++) {
                        Object obj = pi.GetCurrentConfig(sCookiePaths[iter]);
                        if (obj != null && (obj is String))
                            sCookiePathsV[iter] = (String) obj; 
                    }
                }
            } catch(Exception) { 
                // swallow exceptions
            }                            


            ////////////////////////////////////////////////////////////
            // Step 3: Add cookies
            for(iter=0; iter<5; iter++) {
                HttpCookie cookie = new HttpCookie(sCookieNames[iter], "");
                cookie.Expires = new DateTime(1998, 1, 1);
                if (sCookieDomainsV[iter] != null && sCookieDomainsV[iter].Length > 0)
                    cookie.Domain = sCookieDomainsV[iter];
                if (sCookiePathsV[iter] != null && sCookiePathsV[iter].Length > 0)
                    cookie.Path = sCookiePathsV[iter];
                else
                    cookie.Path = "/";
                context.Response.Cookies.Add(cookie);      
            }

            // context.Response.AppendHeader("P3P", "CP=\"TST\"");

            ////////////////////////////////////////////////////////////
            // Step 4: Add no-cache headers
            context.Response.Expires = -1;
            context.Response.Cache.SetCacheability(HttpCacheability.NoCache);
            context.Response.AppendHeader("Pragma", "no-cache");
            context.Response.ContentType = "image/gif";

            ////////////////////////////////////////////////////////////
            // Step 5: Write Image file
            context.Response.WriteFile(strSignOutDotGifFileName);

            ////////////////////////////////////////////////////////////
            // Step 6: Mobile device support: Redirect to the "ru" in the QS (if present)
            String strRU = context.Request.QueryString["ru"];
            if (strRU != null && strRU.Length > 1) 
                context.Response.Redirect(strRU, false);
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.Encrypt"]/*' />
        /// <devdoc>
        ///    Encrypts data using the Passport
        ///    participant keycfor the current site. Maximum input size is 2045 characters.
        /// </devdoc>
        static public String Encrypt(String strData) {
            return CallPassportCryptFunction(0, strData);
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.Decrypt"]/*' />
        /// <devdoc>
        ///    Decrypts data using the Passport
        ///    participant key for the current site.
        /// </devdoc>
        static public String Decrypt(String strData) {
            return CallPassportCryptFunction(1, strData);
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.Compress"]/*' />
        static public String Compress(String strData) {
            return CallPassportCryptFunction(2, strData);
        }
        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.Decompress"]/*' />
        static public String Decompress(String strData) {
            return CallPassportCryptFunction(3, strData);
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.CryptPutHost"]/*' />
        static public int CryptPutHost(String strHost) {
            int iRet =  UnsafeNativeMethods.PassportCryptPut(0, strHost);
            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    

            return iRet;
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.CryptPutSite"]/*' />
        static public int CryptPutSite(String strSite) {
            int iRet = UnsafeNativeMethods.PassportCryptPut(1, strSite);
            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    

            return iRet;
        }

        /// <include file='doc\PassportIdentity.uex' path='docs/doc[@for="PassportIdentity.CryptIsValid"]/*' />
        static public bool CryptIsValid() {
            int iRet = UnsafeNativeMethods.PassportCryptIsValid();
            if (iRet < 0)
                throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            return (iRet == 0);
        }  


        static private String CallPassportCryptFunction(int iFunctionID, String strData) {           
            int   iRet  = 0;
            int   iSize = ((strData == null || strData.Length < 512) ? 512 : strData.Length);

            do  {
                iSize *= 2;
                StringBuilder str = new StringBuilder(iSize);                
                iRet = UnsafeNativeMethods.PassportCrypt(iFunctionID, strData, str, iSize);                            

                if (iRet == 0) // Worked
                    return str.ToString();
                if (iRet != HResults.E_INSUFFICIENT_BUFFER && iRet < 0)
                    throw new COMException(HttpRuntime.FormatResourceString(SR.Passport_method_failed), iRet);                    
            }
            while  ( iRet ==  HResults.E_INSUFFICIENT_BUFFER &&
                     iSize < 10*1024*1024 ); // Less than 10MB

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\passportauthenticationmodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="PassportAuthenticationModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * PassportAuthenticationModule class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Security {
    using System.Web;
    using  System.Security.Principal;
    using System.Web.Configuration;
    using System.Globalization;
    using System.Security.Permissions;


    /// <include file='doc\PassportAuthenticationModule.uex' path='docs/doc[@for="PassportAuthenticationModule"]/*' />
    /// <devdoc>
    ///    This 
    ///       module provides a wrapper around passport authentication services. 
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class PassportAuthenticationModule : IHttpModule {
        private PassportAuthenticationEventHandler _eventHandler;

        private static bool _fAuthChecked  = false;
        private static bool _fAuthRequired = false;
        private static String _LoginUrl    = null;

        /// <include file='doc\PassportAuthenticationModule.uex' path='docs/doc[@for="PassportAuthenticationModule.PassportAuthenticationModule"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.Security.PassportAuthenticationModule'/>
        ///       class.
        ///     </para>
        /// </devdoc>
        public PassportAuthenticationModule() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }

        ////////////////////////////////////////////////////////////
        // AddOnAuthenticate and RemoveOnAuthenticate: Use these
        //   methods to hook up event handlers to handle the
        //   OnAuthenticate Event
        /// <include file='doc\PassportAuthenticationModule.uex' path='docs/doc[@for="PassportAuthenticationModule.Authenticate"]/*' />
        /// <devdoc>
        ///    This is a global.asax event that must be
        ///    named PassportAuthenticate_OnAuthenticate event.
        /// </devdoc>
        public event PassportAuthenticationEventHandler Authenticate {
            add {
                _eventHandler += value;
            }
            remove {
                _eventHandler -= value;
            }
        }

        /// <include file='doc\PassportAuthenticationModule.uex' path='docs/doc[@for="PassportAuthenticationModule.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dispose() {
        }

        /// <include file='doc\PassportAuthenticationModule.uex' path='docs/doc[@for="PassportAuthenticationModule.Init"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Init(HttpApplication app) {
            app.AuthenticateRequest += new EventHandler(this.OnEnter);
            app.EndRequest += new EventHandler(this.OnLeave);
        }

        ////////////////////////////////////////////////////////////
        // OnAuthenticate: Custom Authentication modules can override
        //             this method to create a custom IPrincipal object from
        //             a PassportIdentity
        /// <include file='doc\PassportAuthenticationModule.uex' path='docs/doc[@for="PassportAuthenticationModule.OnAuthenticate"]/*' />
        /// <devdoc>
        ///    Calls the
        ///    PassportAuthentication_OnAuthenticate handler, if one exists.
        /// </devdoc>
        void OnAuthenticate(PassportAuthenticationEventArgs e) {
            ////////////////////////////////////////////////////////////
            // If there are event handlers, invoke the handlers
            if (_eventHandler != null) {
                _eventHandler(this, e);
                if (e.Context.User == null && e.User != null)
                    e.Context.User = e.User;
            }

            ////////////////////////////////////////////////////////////
            // Default Implementation: If IPrincipal has not been created,
            //                         create a PassportUser
            if (e.Context.User == null)
                e.Context.User = new GenericPrincipal(e.Identity, new String[0]);
        }


        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        // Methods for internal implementation
        /// <include file='doc\PassportAuthenticationModule.uex' path='docs/doc[@for="PassportAuthenticationModule.OnEnter"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        void OnEnter(Object source, EventArgs eventArgs) {
            if (_fAuthChecked && !_fAuthRequired)
                return;

            HttpApplication app;
            HttpContext context;

            app = (HttpApplication)source;
            context = app.Context;

            if (!_fAuthChecked) {
                AuthenticationConfig settings = (AuthenticationConfig) context.GetConfig("system.web/authentication");
                _fAuthRequired  = (settings.Mode == AuthenticationMode.Passport);
                _LoginUrl = settings.PassportUrl;
                _fAuthChecked = true;
            }                    

            if (!_fAuthRequired)
                return;

            ////////////////////////////////////////////////////////
            // Step 1: See if this request is valid or not
            if ( context.Response.StatusCode == 401 || 
                 context.Response.StatusCode == 400 || 
                 context.Response.StatusCode == 500 ||
                 context.User                != null ) {   // Some module has already verified that the credentials are invalid
                return;
            }

            ////////////////////////////////////////////////////////
            // Step 2: Create a Passport Identity from the credentials
            //     from IIS
            PassportIdentity identity = new PassportIdentity();

            ////////////////////////////////////////////////////////
            // Step 4: Call OnAuthenticate virtual method to create
            //    an IPrincipal for this request
            OnAuthenticate( new PassportAuthenticationEventArgs(identity, context) );

            ////////////////////////////////////////////////////////
            // Skip AuthZ if accessing the login page
            context.SkipAuthorization = AuthenticationConfig.AccessingLoginPage(context, _LoginUrl);
        }

        void OnLeave(Object source, EventArgs eventArgs) {
            HttpApplication app;
            HttpContext context;
            app = (HttpApplication)source;
            context = app.Context;
            if (!_fAuthChecked || !_fAuthRequired || context.User == null || context.User.Identity == null || !(context.User.Identity is PassportIdentity))
                return;



            PassportIdentity id = (PassportIdentity) context.User.Identity;
            if (context.Response.StatusCode != 401 || id.WWWAuthHeaderSet)
                return;

            if ( _LoginUrl==null || _LoginUrl.Length < 1 || String.Compare(_LoginUrl, "internal", false, CultureInfo.InvariantCulture) == 0) {
                context.Response.Clear();
                context.Response.StatusCode = 200;

                String strUrl = context.Request.Url.ToString();
                int    iPos   = strUrl.IndexOf('?');
                if (iPos >= 0)
                {
                    strUrl = strUrl.Substring(0, iPos);
                }
                String strLogoTag = id.LogoTag2(HttpUtility.UrlEncode(strUrl, context.Request.ContentEncoding));

                String strMsg = HttpRuntime.FormatResourceString(SR.PassportAuthFailed, strLogoTag);
                context.Response.Write(strMsg);
            }
            else {
                ////////////////////////////////////////////////////////////
                // Step 1: Get the redirect url
                String redirectUrl = AuthenticationConfig.GetCompleteLoginUrl(context, _LoginUrl);
                
                ////////////////////////////////////////////////////////////
                // Step 2: Check if we have a valid url to the redirect-page
                if (redirectUrl == null || redirectUrl.Length <= 0) 
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_Passport_Redirect_URL));

                
                ////////////////////////////////////////////////////////////
                // Step 3: Construct the redirect-to url
                String             strUrl       = context.Request.Url.ToString();
                String             strRedirect;
                int                iIndex;
                String             strSep;
            
                if (redirectUrl.IndexOf('?') >= 0)
                    strSep = "&";
                else
                    strSep = "?";
                
                strRedirect = redirectUrl  + strSep + "ReturnUrl=" + HttpUtility.UrlEncode(strUrl, context.Request.ContentEncoding);
                

                ////////////////////////////////////////////////////////////
                // Step 4: Add the query-string from the current url
                iIndex = strUrl.IndexOf('?');
                if (iIndex >= 0 && iIndex < strUrl.Length-1)
                    strRedirect += "&" + strUrl.Substring(iIndex+1);
                

                ////////////////////////////////////////////////////////////
                // Step 5: Do the redirect
                context.Response.Redirect(strRedirect, false);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\windowsauthenticationeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="WindowsAuthenticationEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * WindowsAuthenticationEventHandler class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.Security {
    using  System.Security.Principal;
    /// <include file='doc\WindowsAuthenticationEventHandler.uex' path='docs/doc[@for="WindowsAuthenticationEventHandler"]/*' />
    /// <devdoc>
    ///    Defines the signature for the
    ///    WindowsAuthentication_OnAuthenticate event handler.
    /// </devdoc>

    public delegate void WindowsAuthenticationEventHandler(Object sender,  WindowsAuthenticationEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\urlauthorizationmodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="UrlAuthorizationModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * UrlAuthorizationModule class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Security {
    using System.Runtime.Serialization;
    using System.Web;
    using System.Collections;
    using System.Web.Configuration;
    using System.IO;
    using System.Security.Principal;
    using System.Security.Permissions;


    /// <include file='doc\UrlAuthorizationModule.uex' path='docs/doc[@for="UrlAuthorizationModule"]/*' />
    /// <devdoc>
    ///    This module provides URL based
    ///    authorization services for allowing or denying access to specified resources
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class UrlAuthorizationModule : IHttpModule {

        /// <include file='doc\UrlAuthorizationModule.uex' path='docs/doc[@for="UrlAuthorizationModule.UrlAuthorizationModule"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.Security.UrlAuthorizationModule'/>
        ///       class.
        ///     </para>
        /// </devdoc>
        public UrlAuthorizationModule() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }

        /// <include file='doc\UrlAuthorizationModule.uex' path='docs/doc[@for="UrlAuthorizationModule.Init"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Init(HttpApplication app) {
            app.AuthorizeRequest += new EventHandler(this.OnEnter);
        }

        /// <include file='doc\UrlAuthorizationModule.uex' path='docs/doc[@for="UrlAuthorizationModule.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dispose() {
        }

        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        // Module Enter: Get the authorization configuration section
        //    and see if this user is allowed or not
        void OnEnter(Object source, EventArgs eventArgs) {
            HttpApplication    app;
            HttpContext        context;

            app = (HttpApplication)source;
            context = app.Context;
            if (context.SkipAuthorization)
            {
                if (context.User.Identity.IsAuthenticated == false)
                    PerfCounters.IncrementCounter(AppPerfCounter.ANONYMOUS_REQUESTS);
                return;
            }

            // Get the authorization config object
            AuthorizationConfig settings = (AuthorizationConfig) context.GetConfig("system.web/authorization");

            // Check if the user is allowed, or the request is for the login page
            if ( !settings.IsUserAllowed(context.User, context.Request.RequestType))
            {
                // Deny access
                context.Response.StatusCode = 401;
                WriteErrorMessage(context);
                app.CompleteRequest();
            }
            else
            {
                if (context.User.Identity.IsAuthenticated == false)
                    PerfCounters.IncrementCounter(AppPerfCounter.ANONYMOUS_REQUESTS);
            }
        }

        /////////////////////////////////////////////////////////////////////////////
        void WriteErrorMessage(HttpContext context) {
            context.Response.Write(UrlAuthFailedErrorFormatter.GetErrorText());
        }

        static internal bool RequestRequiresAuthorization(HttpContext context) {
            if (context.SkipAuthorization)
                return false;

            AuthorizationConfig settings = (AuthorizationConfig) context.GetConfig("system.web/authorization");

            // Check if the anonymous user is allowed
            if (_AnonUser == null)
                _AnonUser = new GenericPrincipal(new GenericIdentity(String.Empty, String.Empty), new String[0]); 
            
            return settings.IsUserAllowed(_AnonUser, context.Request.RequestType);
        }

        static GenericPrincipal _AnonUser;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\windowsauthenticationeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="WindowsAuthenticationEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * WindowsAuthenticationEventArgs class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.Security {
    using  System.Security.Principal;
    using System.Security.Permissions;

    /// <include file='doc\WindowsAuthenticationEventArgs.uex' path='docs/doc[@for="WindowsAuthenticationEventArgs"]/*' />
    /// <devdoc>
    ///    <para>The Windows authentication module raises this event. This 
    ///       is the event argument passed to the WindowsAuthentication_OnAuthenticate event.
    ///       Contains a WindowsIdentity object and the IPrincipal object used for the context.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class WindowsAuthenticationEventArgs : EventArgs {
        private IPrincipal             _User;
        private HttpContext       _Context;
        private WindowsIdentity   _Identity;

        /// <include file='doc\WindowsAuthenticationEventArgs.uex' path='docs/doc[@for="WindowsAuthenticationEventArgs.User"]/*' />
        /// <devdoc>
        ///    <para>IPrincipal object to be associated with the request.
        ///       <SPAN>
        ///       </SPAN>The user object should be attached 
        ///       to the context.<SPAN>
        ///    </SPAN>If User is non null
        ///    and Context.User is null, the WindowsAuthenticationModule will initialize
        ///    Context.User with WindowsAuthenticationEventArgs.User.</para>
        /// </devdoc>
        public  IPrincipal            User { 
            get { return _User;} 
            set { 
                InternalSecurityPermissions.ControlPrincipal.Demand();
                _User = value;
            }
        }

        /// <include file='doc\WindowsAuthenticationEventArgs.uex' path='docs/doc[@for="WindowsAuthenticationEventArgs.Context"]/*' />
        /// <devdoc>
        ///    The HttpContext intrinsic (provides access to
        ///    Request, Response, and User objects).
        /// </devdoc>
        public  HttpContext      Context { get { return _Context;}}
        /// <include file='doc\WindowsAuthenticationEventArgs.uex' path='docs/doc[@for="WindowsAuthenticationEventArgs.Identity"]/*' />
        /// <devdoc>
        ///    An authenticated Windows identity.
        /// </devdoc>
        public  WindowsIdentity  Identity { get { return _Identity;}}

        /// <include file='doc\WindowsAuthenticationEventArgs.uex' path='docs/doc[@for="WindowsAuthenticationEventArgs.WindowsAuthenticationEventArgs"]/*' />
        /// <devdoc>
        ///    <para>Initializes a newly created instance of the
        ///       WindowsAuthenticationEventArgs Class.</para>
        /// </devdoc>
        public WindowsAuthenticationEventArgs(WindowsIdentity identity, HttpContext context) {
            _Identity = identity;
            _Context = context;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\state\irequiressessionstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="IRequiresSessionState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * IRequiresSessionState
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.SessionState {

/*
 * Marker interface to indicate that class uses session state.
 */

    /// <include file='doc\IRequiresSessionState.uex' path='docs/doc[@for="IRequiresSessionState"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IRequiresSessionState {
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\state\outofprocstateclientmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="OutOfProcStateClientManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#define SYNCHRONOUS

namespace System.Web.SessionState {
    using System.Collections;
    using System.Configuration;
    using System.Web.Configuration;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Text;
    using System.Threading;
    using System.Web;
    using System.Web.Caching;
    using System.Web.Util;

    /*
     * Provides out-of-proc session state via stweb.exe.
     */
    internal class OutOfProcStateClientManager : StateClientManager, IStateClientManager {
        internal static readonly IntPtr  INVALID_SOCKET = (IntPtr) (-1);     

        static ResourcePool s_rpool;
        static String       s_server;
        static int          s_port;
        static string       s_uribase;
        static int          s_networkTimeout;

        byte[]          _bufGet;

        internal OutOfProcStateClientManager() {
        }

        void IStateClientManager.SetStateModule(SessionStateModule module) {
        }

        /*public*/ void IStateClientManager.ConfigInit(SessionStateSectionHandler.Config config, SessionOnEndTarget onEndTarget) {
            int hr;
            
            try {
                /*
                 * stateConnection string has the following format:
                 * 
                 *     "tcpip=<server>:<port>"
                 */
                string [] parts = config._stateConnectionString.Split(new char[] {'='});
                if (parts.Length != 2 || parts[0] != "tcpip") {
                    throw new ArgumentException();
                }

                parts = parts[1].Split(new char[] {':'});
                if (parts.Length != 2) {
                    throw new ArgumentException();
                }

                s_server = parts[0];
                s_port = (int) System.UInt16.Parse(parts[1]);
                s_networkTimeout = config._stateNetworkTimeout;

                // At v1, we won't accept server name that has non-ascii characters
                foreach (char c in s_server) {
                    if (c > 0x7F) {
                        throw new ArgumentException();
                    }
                }
            }
            catch {
                throw new ConfigurationException(
                        HttpRuntime.FormatResourceString(SR.Invalid_value_for_sessionstate_stateConnectionString, config._stateConnectionString),
                        config._configFileName, config._stateLine);
            }

            string appId = HttpRuntime.AppDomainAppIdInternal;
            string idHash = MachineKey.HashAndBase64EncodeString(appId);

            s_uribase = "/" + appId + "(" + idHash + ")/";
            s_rpool = new ResourcePool(new TimeSpan(0, 0, 5), int.MaxValue);

            hr = UnsafeNativeMethods.SessionNDConnectToService(s_server);
            if (hr != 0) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cant_connect_to_session_service), hr);
            }
        }

        /*public*/ void IStateClientManager.Dispose() {
            s_rpool.Dispose();
        }

        void MakeRequest(
                UnsafeNativeMethods.StateProtocolVerb   verb, 
                String                                  id, 
                UnsafeNativeMethods.StateProtocolExclusive    exclusiveAccess, 
                int                                     timeout,
                int                                     lockCookie,  
                byte[]                                  buf,         
                int                                     cb,        
                int                                     networkTimeout,
                out UnsafeNativeMethods.SessionNDMakeRequestResults results) {

            int                         hr;
            string                      uri;
            OutOfProcConnection         conn;
            HandleRef                   socketHandle;

            conn = (OutOfProcConnection) s_rpool.RetrieveResource();
            if (conn != null) {
                socketHandle = new HandleRef(this, conn._socketHandle.Handle);
            } 
            else {
                socketHandle = new HandleRef(this, INVALID_SOCKET);
            }

            Debug.Trace("SessionStateClientManagerMakeRequest", 
                        "Calling MakeRequest, " + 
                        "socket=" + (IntPtr) socketHandle.Handle + 
                        "verb=" + verb +
                        " id=" + id + 
                        " exclusiveAccess=" + exclusiveAccess +
                        " timeout=" + timeout +
                        " buf=" + ((buf != null) ? "non-null" : "null") + 
                        " cb=" + cb);

            uri = s_uribase + id;
            hr = UnsafeNativeMethods.SessionNDMakeRequest(
                    socketHandle, s_server, s_port, networkTimeout, verb, uri,
                    exclusiveAccess, timeout, lockCookie,
                    buf, cb, out results);

            Debug.Trace("SessionStateClientManagerMakeRequest", "MakeRequest returned: " +
                        "hr=" + hr +
                        " socket=" + (IntPtr) results.socket +
                        " httpstatus=" + results.httpStatus + 
                        " timeout=" + results.timeout +
                        " contentlength=" + results.contentLength + 
                        " uri=" + (IntPtr)results.content +
                        " lockCookie=" + results.lockCookie +
                        " lockDate=" + string.Format("{0:x}", results.lockDate) +
                        " lockAge=" + results.lockAge);

            if (conn != null) {
                if (results.socket == INVALID_SOCKET) {
                    conn.Detach();
                    conn = null;
                }
                else if (results.socket != socketHandle.Handle) {
                    // The original socket is no good.  We've got a new one.
                    // Pleae note that EnsureConnected has closed the bad
                    // one already.
                    conn._socketHandle = new HandleRef(this, results.socket);
                }
            }
            else if (results.socket != INVALID_SOCKET) {
                conn = new OutOfProcConnection(results.socket);
            }

            if (conn != null) {
                s_rpool.StoreResource(conn);
            }

            if (hr != 0) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Cant_make_session_request),
                    hr);
            }
        }

        internal SessionStateItem DoGet(String id, UnsafeNativeMethods.StateProtocolExclusive exclusiveAccess) {
            SessionStateItem    item = null;
            MemoryStream        stream;
            int                 contentLength;
            TimeSpan            lockAge;
            UnsafeNativeMethods.SessionNDMakeRequestResults results;

            MakeRequest(UnsafeNativeMethods.StateProtocolVerb.GET, 
                        id, exclusiveAccess, 0, 0, 
                        null, 0, s_networkTimeout, out results);

            switch (results.httpStatus) {
                case 200:
                    /* item found, deserialize it */
                    contentLength = results.contentLength;
                    if (contentLength > 0) {
                        if (_bufGet == null || _bufGet.Length < contentLength) {
                            _bufGet = new byte[contentLength];
                        }
        
                        UnsafeNativeMethods.SessionNDGetBody(new HandleRef(this, results.content), _bufGet, contentLength);
                        stream = new MemoryStream(_bufGet);
                        item = (SessionStateItem) Deserialize(stream, results.lockCookie);
                        stream.Close();
                    }

                    break;

                case 423:
                    /* state locked, return lock information */
                    if (0 <= results.lockAge) {
                        if (results.lockAge < Sec.ONE_YEAR) {
                            lockAge = new TimeSpan(0, 0, results.lockAge);
                        }
                        else {
                            lockAge = TimeSpan.Zero;
                        }
                    }
                    else {
                        DateTime now = DateTime.Now;
                        if (0 < results.lockDate && results.lockDate < now.Ticks) {
                            lockAge = now - new DateTime(results.lockDate);
                        }
                        else {
                            lockAge = TimeSpan.Zero;
                        }
                    }

                    item = new SessionStateItem (
                            null, null, 0, false, 0, true, lockAge, results.lockCookie);

                    break;
            }

            return item;
        }

        protected override SessionStateItem Get(String id) {
            Debug.Trace("SessionStateClientManager", "Calling Get, id=" + id);

            return DoGet(id, UnsafeNativeMethods.StateProtocolExclusive.NONE);
        }

        /*public*/ IAsyncResult IStateClientManager.BeginGet(String id, AsyncCallback cb, Object state) {
            return BeginGetSync(id, cb, state);
        }

        /*public*/ SessionStateItem IStateClientManager.EndGet(IAsyncResult ar) {
            return EndGetSync(ar);
        }

        protected override SessionStateItem GetExclusive(String id) {
            Debug.Trace("SessionStateClientManager", "Calling GetExlusive, id=" + id);

            return DoGet(id, UnsafeNativeMethods.StateProtocolExclusive.ACQUIRE);
        }

        /*public*/ IAsyncResult IStateClientManager.BeginGetExclusive(String id, AsyncCallback cb, Object state) {
            return BeginGetExclusiveSync(id, cb, state);
        }

        /*public*/ SessionStateItem IStateClientManager.EndGetExclusive(IAsyncResult ar) {
            return EndGetExclusiveSync(ar);
        }
    
        /*public*/ void IStateClientManager.ReleaseExclusive(String id, int lockCookie) {
#if SYNCHRONOUS
            ReleaseExclusiveAsyncWorker(id, lockCookie);
#else
            ReleaseExclusiveAsync(id, lockCookie);
#endif
        }

        protected override void ReleaseExclusiveAsyncWorker(String id, int lockCookie) {
            UnsafeNativeMethods.SessionNDMakeRequestResults results;
            Debug.Trace("SessionStateClientManager", "Calling ReleaseExclusive, id=" + id);
            MakeRequest(UnsafeNativeMethods.StateProtocolVerb.GET, id, 
                        UnsafeNativeMethods.StateProtocolExclusive.RELEASE, 0,
                        lockCookie, null, 0, s_networkTimeout, out results);
        }

        /*public*/ void IStateClientManager.Set(String id, SessionStateItem item, bool inStorage) {
            byte[]          buf;
            MemoryStream    stream;
            int             length;

            try {            
                stream = new MemoryStream();
                Serialize(item, stream);
                buf = stream.GetBuffer();
                length = (int) stream.Length;
                stream.Close();
            }
            catch {
                if (inStorage) {
                    ((IStateClientManager)this).ReleaseExclusive(id, item.lockCookie);
                }
                throw;
            }

#if SYNCHRONOUS
            SetAsyncWorker(id, item, buf, length, inStorage);
#else

            if (inStorage) {
                SetAsync(id, item, buf, length, inStorage);
            }
            else {
                SetAsyncWorker(id, item, buf, length inStorage);
            }
#endif
        }

        protected override void SetAsyncWorker(String id, SessionStateItem item, 
                                    byte[] buf, int length, bool inStorage) {
            UnsafeNativeMethods.SessionNDMakeRequestResults results;

            Debug.Trace("SessionStateClientManager", "Calling Set, id=" + id + " dict=" + item.dict + " timeout=" + item.timeout);

            MakeRequest(UnsafeNativeMethods.StateProtocolVerb.PUT, id, 
                        UnsafeNativeMethods.StateProtocolExclusive.NONE, item.timeout, item.lockCookie, 
                        buf, length, s_networkTimeout, out results);


        }

        /*public*/ void IStateClientManager.Remove(String id, int lockCookie) {
#if SYNCHRONOUS
            RemoveAsyncWorker(id, lockCookie);
#else
            RemoveAsync(id, lockCookie);
#endif
        }

        protected override void RemoveAsyncWorker(String id, int lockCookie) {
            UnsafeNativeMethods.SessionNDMakeRequestResults results;

            Debug.Trace("SessionStateClientManager", "Calling Remove, id=" + id);
            MakeRequest(UnsafeNativeMethods.StateProtocolVerb.DELETE, id, 
                        UnsafeNativeMethods.StateProtocolExclusive.NONE, 0, lockCookie, 
                        null, 0, s_networkTimeout, out results);
        }

        /*public*/ void IStateClientManager.ResetTimeout(String id) {
#if SYNCHRONOUS
            ResetTimeoutAsyncWorker(id);
#else
            ResetTimeoutAsync(id);
#endif
        }

        protected override void ResetTimeoutAsyncWorker(String id) {
            UnsafeNativeMethods.SessionNDMakeRequestResults results;

            Debug.Trace("SessionStateClientManager", "Calling ResetTimeout, id=" + id);
            MakeRequest(UnsafeNativeMethods.StateProtocolVerb.HEAD, id, 
                        UnsafeNativeMethods.StateProtocolExclusive.NONE, 0, 0, 
                        null, 0, s_networkTimeout, out results);
        }

        class OutOfProcConnection : IDisposable {
            internal HandleRef _socketHandle;
    
            internal OutOfProcConnection(IntPtr socket) {
                Debug.Assert(socket != OutOfProcStateClientManager.INVALID_SOCKET, 
                             "socket != OutOfProcStateClientManager.INVALID_SOCKET");

                _socketHandle = new HandleRef(this, socket);
                PerfCounters.IncrementCounter(AppPerfCounter.SESSION_STATE_SERVER_CONNECTIONS);
            }

            ~OutOfProcConnection() {
                Dispose(false);
            }
    
            public void Dispose() {
                Dispose(true);
                System.GC.SuppressFinalize(this);
            }

            private void Dispose(bool dummy) {
                if (_socketHandle.Handle != OutOfProcStateClientManager.INVALID_SOCKET) {
                    UnsafeNativeMethods.SessionNDCloseConnection(_socketHandle);
                    _socketHandle = new HandleRef(this, OutOfProcStateClientManager.INVALID_SOCKET);
                    PerfCounters.DecrementCounter(AppPerfCounter.SESSION_STATE_SERVER_CONNECTIONS);
                }
            }
    
            internal void Detach() {
                _socketHandle = new HandleRef(this, OutOfProcStateClientManager.INVALID_SOCKET);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\state\ireadonlysessionstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="IReadOnlySessionState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * IReadOnlySessionState
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.SessionState {

/*
 * Marker interface to indicate that class needs only read-only
 * access to session state.
 */

    /// <include file='doc\IReadOnlySessionState.uex' path='docs/doc[@for="IReadOnlySessionState"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IReadOnlySessionState : IRequiresSessionState {
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\windowsauthenticationmodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="WindowsAuthenticationModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * WindowsAuthenticationModule class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Security {
    using System.Web;
    using System.Web.Configuration;
    using System.Security.Principal;
    using System.Security.Permissions;
    using System.Globalization;
    

    /// <include file='doc\WindowsAuthenticationModule.uex' path='docs/doc[@for="WindowsAuthenticationModule"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Allows ASP.NET applications to use Windows/IIS authentication.
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class WindowsAuthenticationModule : IHttpModule {
        private WindowsAuthenticationEventHandler _eventHandler;

        private static bool             _fAuthChecked;
        private static bool             _fAuthRequired;
        private static WindowsIdentity  _anonymousIdentity;
        private static WindowsPrincipal _anonymousPrincipal;

        /// <include file='doc\WindowsAuthenticationModule.uex' path='docs/doc[@for="WindowsAuthenticationModule.WindowsAuthenticationModule"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.Security.WindowsAuthenticationModule'/>
        ///       class.
        ///     </para>
        /// </devdoc>
        public WindowsAuthenticationModule() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }

        /// <include file='doc\WindowsAuthenticationModule.uex' path='docs/doc[@for="WindowsAuthenticationModule.Authenticate"]/*' />
        /// <devdoc>
        ///    This is a global.asax event that must be
        ///    named WindowsAuthenticate_OnAuthenticate event. It's used primarily to attach a
        ///    custom IPrincipal object to the context.
        /// </devdoc>
        public event WindowsAuthenticationEventHandler Authenticate {
            add {
                _eventHandler += value;
            }
            remove {
                _eventHandler -= value;
            }
        }

        /// <include file='doc\WindowsAuthenticationModule.uex' path='docs/doc[@for="WindowsAuthenticationModule.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dispose() {
        }

        /// <include file='doc\WindowsAuthenticationModule.uex' path='docs/doc[@for="WindowsAuthenticationModule.Init"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Init(HttpApplication app) {
            app.AuthenticateRequest += new EventHandler(this.OnEnter);
        }

        ////////////////////////////////////////////////////////////
        // OnAuthenticate: Custom Authentication modules can override
        //             this method to create a custom IPrincipal object from
        //             a WindowsIdentity
        /// <include file='doc\WindowsAuthenticationModule.uex' path='docs/doc[@for="WindowsAuthenticationModule.OnAuthenticate"]/*' />
        /// <devdoc>
        ///    Calls the
        ///    WindowsAuthentication_OnAuthenticate handler if one exists.
        /// </devdoc>
        void OnAuthenticate(WindowsAuthenticationEventArgs e) {
            ////////////////////////////////////////////////////////////
            // If there are event handlers, invoke the handlers
            if (_eventHandler != null)
                 _eventHandler(this, e);

            if (e.Context.User == null)
            {
                if (e.User != null)
                    e.Context.User = e.User;
                else  if (e.Identity == _anonymousIdentity)
                    e.Context.User = _anonymousPrincipal;
                else
                    e.Context.User = new WindowsPrincipal(e.Identity);
            }
        }



        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        // Methods for internal implementation
        /// <include file='doc\WindowsAuthenticationModule.uex' path='docs/doc[@for="WindowsAuthenticationModule.OnEnter"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        void OnEnter(Object source, EventArgs eventArgs) {
            if (_fAuthChecked && !_fAuthRequired)
                return;

            HttpApplication         app;
            HttpContext             context;
            WindowsIdentity         identity;
            AuthenticationConfig    settings;

            app = (HttpApplication)source;
            context = app.Context;
            
            if (!_fAuthChecked) {
                settings = (AuthenticationConfig) context.GetConfig("system.web/authentication");
                _fAuthRequired  = (settings == null || settings.Mode == AuthenticationMode.Windows);
                if (!_fAuthRequired)
                    return;

                _anonymousIdentity  = WindowsIdentity.GetAnonymous();
                _anonymousPrincipal = new WindowsPrincipal(_anonymousIdentity);

                _fAuthChecked = true;
            }                    

            if (!_fAuthRequired)
                return;

            ////////////////////////////////////////////////////////
            // Step 2: Check whether IIS has authenticated this request
            String  strLogonUser  = context.WorkerRequest.GetServerVariable("LOGON_USER");
            String  strAuthType   = context.WorkerRequest.GetServerVariable("AUTH_TYPE");
            if (strLogonUser == null)
                strLogonUser = "";
            if (strAuthType == null)
                strAuthType = "";

            if (strLogonUser.Length == 0 && (strAuthType.Length == 0 || 
                                             String.Compare(strAuthType, "basic", true, CultureInfo.InvariantCulture) == 0)) 
            {
                ////////////////////////////////////////////////////////
                // Step 3a: Use the anonymous identity
                identity = _anonymousIdentity;
            }
            else
            {
                /*
                  IntPtr iToken =  ( HttpRuntime.IsOnUNCShareInternal ?
                  context.WorkerRequest.GetVirtualPathToken() :
                  context.WorkerRequest.GetUserToken() );                
                */

                ////////////////////////////////////////////////////////
                // Step 3b: Create a Windows Identity from the credentials
                //     from IIS
                identity = new WindowsIdentity(
                        context.WorkerRequest.GetUserToken(), 
                        strAuthType,
                        WindowsAccountType.Normal,
                        true);
            }

            ////////////////////////////////////////////////////////
            // Step 4: Call OnAuthenticate virtual method to create
            //    an IPrincipal for this request
            OnAuthenticate( new WindowsAuthenticationEventArgs(identity, context) );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\state\inprocstateclientmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="InProcStateClientManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.SessionState {
    using System.Threading;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Runtime.Serialization;

    using System.Text;
    using System.Collections;
    using System.IO;
    using System.Web;
    using System.Web.Caching;
    using System.Web.Util;

    internal sealed class InProcSessionState {
        internal SessionDictionary              dict;
        internal HttpStaticObjectsCollection    staticObjects;
        internal int                            timeout;        // USed to set slidingExpiration in CacheEntry
        internal bool                           isCookieless;
        internal int                            streamLength;
        internal bool                           locked;         // If it's locked by another thread
        internal DateTime                       utcLockDate;
        internal int                            lockCookie;
        internal ReadWriteSpinLock              spinLock;

        internal InProcSessionState(
                SessionDictionary           dict, 
                HttpStaticObjectsCollection staticObjects, 
                int                         timeout,
                bool                        isCookieless,
                int                         streamLength,
                bool                        locked,
                DateTime                    utcLockDate,
                int                         lockCookie) {

            Copy(dict, staticObjects, timeout, isCookieless, streamLength, locked, utcLockDate, lockCookie);
        }

        internal void Copy(
                SessionDictionary           dict, 
                HttpStaticObjectsCollection staticObjects, 
                int                         timeout,
                bool                        isCookieless,
                int                         streamLength,
                bool                        locked,
                DateTime                    utcLockDate,
                int                         lockCookie) {

            this.dict = dict;
            this.staticObjects = staticObjects;
            this.timeout = timeout;
            this.isCookieless = isCookieless;
            this.streamLength = streamLength;
            this.locked = locked;
            this.utcLockDate = utcLockDate;
            this.lockCookie = lockCookie;
        }
    }

    /*
     * Provides in-proc session state via the cache.
     */
    internal sealed class InProcStateClientManager : StateClientManager, IStateClientManager {
        internal const string           CACHEKEYPREFIX = "System.Web.SessionState.SessionStateItem:";
        internal static readonly int    CACHEKEYPREFIXLENGTH = CACHEKEYPREFIX.Length;

        static CacheItemRemovedCallback s_callback;

        internal InProcStateClientManager() {
        }

        void IStateClientManager.SetStateModule(SessionStateModule module) {
        }

        /*public*/ void IStateClientManager.ConfigInit(SessionStateSectionHandler.Config config, SessionOnEndTarget onEndTarget) {
            s_callback = new CacheItemRemovedCallback(onEndTarget.OnCacheItemRemoved);
        }

        private string CreateSessionStateCacheKey(String id) {
            return CACHEKEYPREFIX + id;
        }

        /*public*/ void IStateClientManager.Dispose() {}

        protected override SessionStateItem Get(String id) {
            string  key = CreateSessionStateCacheKey(id);
            InProcSessionState state = (InProcSessionState) HttpRuntime.CacheInternal.Get(key);
            if (state != null) {
                return new SessionStateItem(
                    state.dict,   
                    state.staticObjects, 
                    state.timeout,       
                    state.isCookieless,  
                    state.streamLength,  
                    state.locked,        
                    TimeSpan.Zero,
                    state.lockCookie);
            }

            return null;
        }

        /*public*/ IAsyncResult IStateClientManager.BeginGet(String id, AsyncCallback cb, Object state) {
            return BeginGetSync(id, cb, state);
        }

        /*public*/ SessionStateItem IStateClientManager.EndGet(IAsyncResult ar) {
            return EndGetSync(ar);
        }

        protected override SessionStateItem GetExclusive(String id) {
            string  key = CreateSessionStateCacheKey(id);
            InProcSessionState state = (InProcSessionState) HttpRuntime.CacheInternal.Get(key);
            if (state != null) {
                bool locked = true;     // True if the state is locked by another session

                // If unlocked, use a spinlock to test and lock the state.
                if (!state.locked) {
                    state.spinLock.AcquireWriterLock();
                    try {
                        if (!state.locked) {
                            locked = false;
                            state.locked = true;
                            state.utcLockDate = DateTime.UtcNow;
                            state.lockCookie++;
                        }
                    }
                    finally {
                        state.spinLock.ReleaseWriterLock();
                    }
                }

                TimeSpan lockAge = locked ? DateTime.UtcNow - state.utcLockDate : TimeSpan.Zero;

                return new SessionStateItem(
                    state.dict,   
                    state.staticObjects, 
                    state.timeout,       
                    state.isCookieless,  
                    state.streamLength,  
                    locked,
                    lockAge,
                    state.lockCookie);
            }

            return null;
        }

        /*public*/ IAsyncResult IStateClientManager.BeginGetExclusive(String id, AsyncCallback cb, Object state) {
            return BeginGetExclusiveSync(id, cb, state);
        }

        /*public*/ SessionStateItem IStateClientManager.EndGetExclusive(IAsyncResult ar) {
            return EndGetExclusiveSync(ar);
        }
    
        /*public*/ void IStateClientManager.ReleaseExclusive(String id, int lockCookie) {
            string  key = CreateSessionStateCacheKey(id);
            InProcSessionState state = (InProcSessionState) HttpRuntime.CacheInternal.Get(key);

            /* If the state isn't there, we probably took too long to run. */
            if (state == null)
                return;

            if (state.locked) {
                state.spinLock.AcquireWriterLock();
                try {
                    if (state.locked && lockCookie == state.lockCookie) {
                        state.locked = false;
                    }
                }
                finally {
                    state.spinLock.ReleaseWriterLock();
                }
            }
        }

        /*public*/ void IStateClientManager.Set(String id, SessionStateItem item, bool inStorage) {
            string          key = CreateSessionStateCacheKey(id);
            bool            doInsert = true;
            CacheInternal   cacheInternal = HttpRuntime.CacheInternal;

            Debug.Assert(!item.locked, "!item.locked");
            Debug.Assert(item.lockAge == TimeSpan.Zero, "item.lockAge == TimeSpan.Zero");

            if (inStorage) {
                Debug.Assert(item.lockCookie != 0, "item.lockCookie != 0");
                InProcSessionState stateCurrent = (InProcSessionState) cacheInternal.Get(key);

                /* If the state isn't there, we probably took too long to run. */
                if (stateCurrent == null)
                    return;

                Debug.Trace("SessionStateClientSet", "state is inStorage; key = " + key);
                
                stateCurrent.spinLock.AcquireWriterLock();
                try {
                    /* Only set the state if we are the owner */
                    if (!stateCurrent.locked || stateCurrent.lockCookie != item.lockCookie) {
                        Debug.Trace("SessionStateClientSet", "Leave because we're not the owner; key = " + key);
                        return;
                    }

                    /* We can change the state in place if the timeout hasn't changed */
                    if (stateCurrent.timeout == item.timeout) {
                        stateCurrent.Copy(
                            item.dict,
                            item.staticObjects,
                            item.timeout,
                            item.isCookieless,
                            item.streamLength,
                            false,
                            DateTime.MinValue,
                            item.lockCookie);

                        doInsert = false;
                        Debug.Trace("SessionStateClientSet", "Changing state inplace; key = " + key);
                    }
                    else {
                        /* prevent overwriting when we drop the lock */
                        stateCurrent.lockCookie = 0;
                    }
                }
                finally {
                    stateCurrent.spinLock.ReleaseWriterLock();
                }
            } else {
                PerfCounters.IncrementCounter(AppPerfCounter.SESSIONS_TOTAL);
                PerfCounters.IncrementCounter(AppPerfCounter.SESSIONS_ACTIVE);

                TraceSessionStats();
            }

            if (doInsert) {
                Debug.Trace("SessionStateClientSet", "Inserting state into Cache; key = " + key);
                InProcSessionState state = new InProcSessionState(
                        item.dict,
                        item.staticObjects,
                        item.timeout,
                        item.isCookieless,
                        item.streamLength,
                        false,
                        DateTime.MinValue,
                        1);
                
                cacheInternal.UtcInsert(
                        key, state, null, Cache.NoAbsoluteExpiration, new TimeSpan(0, state.timeout, 0),
                        CacheItemPriority.NotRemovable, s_callback);
            }
        }

        /*public*/ void IStateClientManager.Remove(String id, int lockCookie) {
            string          key = CreateSessionStateCacheKey(id);
            CacheInternal   cacheInternal = HttpRuntime.CacheInternal;

            InProcSessionState state = (InProcSessionState) cacheInternal.Get(key);

            /* If the item isn't there, we probably took too long to run. */
            if (state == null)
                return;

            state.spinLock.AcquireWriterLock();
            try {

                /* Only remove the item if we are the owner */
                if (!state.locked || state.lockCookie != lockCookie)
                    return;

                /* prevent overwriting when we drop the lock */
                state.lockCookie = 0;
            }
            finally {
                state.spinLock.ReleaseWriterLock();
            }

            cacheInternal.Remove(key);

            TraceSessionStats();
        }

        /*public*/ void IStateClientManager.ResetTimeout(String id) {
            string  key = CreateSessionStateCacheKey(id);
            HttpRuntime.CacheInternal.Get(key);
        }

        [System.Diagnostics.Conditional("DBG")]
        internal static void TraceSessionStats() {
#if DBG
            Debug.Trace("SessionState", 
                        "sessionsTotal="          + PerfCounters.GetCounter(AppPerfCounter.SESSIONS_TOTAL) + 
                        ", sessionsActive="       + PerfCounters.GetCounter(AppPerfCounter.SESSIONS_ACTIVE) + 
                        ", sessionsAbandoned="    + PerfCounters.GetCounter(AppPerfCounter.SESSIONS_ABANDONED) + 
                        ", sessionsTimedout="     + PerfCounters.GetCounter(AppPerfCounter.SESSIONS_TIMED_OUT)
                        );
#endif
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\state\sessionstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="SessionState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HttpSessionState
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.SessionState {

    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Web;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Text;
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\SessionState.uex' path='docs/doc[@for="SessionStateMode"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum SessionStateMode {
        /// <include file='doc\SessionState.uex' path='docs/doc[@for="SessionStateMode.Off"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Off         = 0,
        /// <include file='doc\SessionState.uex' path='docs/doc[@for="SessionStateMode.InProc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        InProc      = 1,
        /// <include file='doc\SessionState.uex' path='docs/doc[@for="SessionStateMode.StateServer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        StateServer = 2,
        /// <include file='doc\SessionState.uex' path='docs/doc[@for="SessionStateMode.SQLServer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SQLServer   = 3
    };

    /*
    * Describes the configuration of a Session.
    */
    /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpSessionState : ICollection {
        String                      _id;
        SessionDictionary           _dict;
        HttpStaticObjectsCollection _staticObjects;
        int                         _timeout;
        bool                        _newSession;
        bool                        _isCookieless;
        SessionStateMode            _mode;
        bool                        _abandon;
        bool                        _isReadonly;

        internal HttpSessionState(
                                 String                      id, 
                                 SessionDictionary           dict,
                                 HttpStaticObjectsCollection staticObjects,
                                 int                         timeout,
                                 bool                        newSession,
                                 bool                        isCookieless,
                                 SessionStateMode            mode,
                                 bool                        isReadonly) {
            _id = id;
            _dict = dict;
            _staticObjects = staticObjects;
            _timeout = timeout;    
            _newSession = newSession; 
            _isCookieless = isCookieless;
            _mode = mode;
            _isReadonly = isReadonly;
        }

        /*
         * The Id of the session.
         */
        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.SessionID"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String SessionID {
            get {return _id;}
        }

        /*
         * The length of a session before it times out, in minutes.
         */
        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.Timeout"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Timeout {
            get {return _timeout;}
            set {
                if (value <= 0) {
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Timeout_must_be_positive));
                }

                _timeout = value;
            }
        }

        /*
         * Is this a new session?
         */
        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.IsNewSession"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNewSession {
            get {return _newSession;}
        }

        /*
         * Is session state in a separate process
         */
        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.Mode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SessionStateMode Mode {
            get {return _mode;}
        }

        /*
         * Is session state cookieless?
         */
        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.IsCookieless"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsCookieless {
            get {return _isCookieless;}
        }

        /*
         * Abandon the session.
         * 
         */
        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.Abandon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Abandon() {
            _abandon = true;
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.LCID"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int LCID {
            // REVIEW:
            // ASP-classic API compat only -- doesn't really store LCID in session
            // Page.LCID should be used instead
            get { return Thread.CurrentThread.CurrentCulture.LCID; }
            set { Thread.CurrentThread.CurrentCulture = HttpServerUtility.CreateReadOnlyCultureInfo(value); }
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.CodePage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CodePage {
            // REVIEW:
            // ASP-classic API compat only -- doesn't really store LCID in session
            // Response.ContentEncoding should be used instead
            get { 
                if (HttpContext.Current != null)
                    return HttpContext.Current.Response.ContentEncoding.CodePage;
                else
                    return Encoding.Default.CodePage;
            }
            set { 
                if (HttpContext.Current != null)
                    HttpContext.Current.Response.ContentEncoding = Encoding.GetEncoding(value);
            }
        }

        internal bool IsAbandoned {
            get {return _abandon;}
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.Contents"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HttpSessionState Contents {
            get {return this;}
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.StaticObjects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HttpStaticObjectsCollection StaticObjects {
            get { return _staticObjects;}
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Object this[String name]
        {
            get {
                return _dict[name];
            }
            set {
                _dict[name] = value;
            }
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Object this[int index]
        {
            get {return _dict[index];}
            set {_dict[index] = value;}
        }
        
        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(String name, Object value) {
            _dict[name] = value;        
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(String name) {
            _dict.Remove(name);
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            _dict.RemoveAt(index);
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.Clear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Clear() {
            _dict.Clear();
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.RemoveAll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void RemoveAll() {
            Clear();
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.Count"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Count {
            get {return _dict.Count;}
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.Keys"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public NameObjectCollectionBase.KeysCollection Keys {
            get {return _dict.Keys;}
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return _dict.GetEnumerator();
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Object SyncRoot {
            get { return this;}
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsReadOnly {
            get { return _isReadonly;}
        }

        /// <include file='doc\SessionState.uex' path='docs/doc[@for="HttpSessionState.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsSynchronized {
            get { return false;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\state\sessiondictionary.cs ===
//------------------------------------------------------------------------------
// <copyright file="SessionDictionary.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * SessionDictionary
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.SessionState {

    using System.IO;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Web.Util;

    internal class SessionDictionary : NameObjectCollectionBase {
        static Hashtable s_immutableTypes;

        const int       NO_NULL_KEY = -1;

        bool            _dirty;

        internal SessionDictionary() {
        }

        static SessionDictionary() {
            Type t;
            s_immutableTypes = new Hashtable(19);

            t=typeof(String);
            s_immutableTypes.Add(t, t);
            t=typeof(Int32);
            s_immutableTypes.Add(t, t);
            t=typeof(Boolean);
            s_immutableTypes.Add(t, t);
            t=typeof(DateTime);
            s_immutableTypes.Add(t, t);
            t=typeof(Decimal);
            s_immutableTypes.Add(t, t);
            t=typeof(Byte);
            s_immutableTypes.Add(t, t);
            t=typeof(Char);
            s_immutableTypes.Add(t, t);
            t=typeof(Single);
            s_immutableTypes.Add(t, t);
            t=typeof(Double);
            s_immutableTypes.Add(t, t);
            t=typeof(SByte);
            s_immutableTypes.Add(t, t);
            t=typeof(Int16);
            s_immutableTypes.Add(t, t);
            t=typeof(Int64);
            s_immutableTypes.Add(t, t);
            t=typeof(UInt16);
            s_immutableTypes.Add(t, t);
            t=typeof(UInt32);
            s_immutableTypes.Add(t, t);
            t=typeof(UInt64);
            s_immutableTypes.Add(t, t);
            t=typeof(TimeSpan);
            s_immutableTypes.Add(t, t);
            t=typeof(Guid);
            s_immutableTypes.Add(t, t);
            t=typeof(IntPtr);
            s_immutableTypes.Add(t, t);
            t=typeof(UIntPtr);
            s_immutableTypes.Add(t, t);
        }

        static internal bool IsImmutable(Object o) {
            return s_immutableTypes[o.GetType()] != null;
        }

        internal bool Dirty {
            get {return _dirty;}
            set {_dirty = value;}
        }

        internal Object this[String name]
        {
            get {
                Object obj = BaseGet(name);
                if (obj != null) {
                    if (!IsImmutable(obj)) {
                        Debug.Trace("SessionStateDictionary", "Setting _dirty to true in get");
                        _dirty = true;
                    }
                }

                return obj;
            }

            set {   
                Object oldValue = BaseGet(name);
                if (oldValue == null && value == null)
                    return;

                Debug.Trace("SessionStateDictionary", "Setting _dirty to true in set");
                BaseSet(name, value);
                _dirty = true;
            }
        }

        /*public*/ internal Object this[int index]
        {
            get {
                Object obj = BaseGet(index);
                if (obj != null) {
                    if (!IsImmutable(obj)) {
                        Debug.Trace("SessionStateDictionary", "Setting _dirty to true in get");
                        _dirty = true;
                    }
                }

                return obj;
            }

            set {   
                Object oldValue = BaseGet(index);
                if (oldValue == null && value == null)
                    return;

                Debug.Trace("SessionStateDictionary", "Setting _dirty to true in set");
                BaseSet(index, value);
                _dirty = true;
            }
        }

        /*public*/ internal String GetKey(int index) {
            return BaseGetKey(index);
        }

        internal void Remove(String name) {
            BaseRemove(name);
            _dirty = true;
        }

        internal void RemoveAt(int index) {
            BaseRemoveAt(index);
            _dirty = true;
        }

        internal void Clear() {
            BaseClear();
            _dirty = true;
        }
        
        internal void Serialize(BinaryWriter writer) {
            int     count;
            int     i;
            String  key;
            Object  value;

            count = Count;
            writer.Write(count);

            if (BaseGet(null) != null) {
                // We have a value with a null key.  Find its index.
                for (i = 0; i < count; i++) {
                    key = BaseGetKey(i);
                    if (key == null) {
                        writer.Write(i);
                        break;
                    }
                }

                Debug.Assert(i != count);
            }
            else {
                writer.Write(NO_NULL_KEY);
            }
            
            for (i = 0; i < count; i++) {
                key = BaseGetKey(i);
                if (key != null) {
                    writer.Write(key);
                }
                value = BaseGet(i);
                AltSerialization.WriteValueToStream(value, writer);
            }
        }

        static internal SessionDictionary Deserialize(BinaryReader reader) {
            SessionDictionary   d = new SessionDictionary();
            int                 count;
            int                 nullKey;
            String              key;
            Object              value;
            int                 i;

            count = reader.ReadInt32();
            nullKey = reader.ReadInt32();

            for (i = 0; i < count; i++) {
                if (i == nullKey) {
                    key = null;
                }
                else {
                    key = reader.ReadString();
                }
                value = AltSerialization.ReadValueFromStream(reader);
                d.BaseSet(key, value);
            }

            d._dirty = false;

            return d;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\std\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\state\sqlstateclientmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="sqlstateclientmanager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * SqlStateClientManager.cs
 * 
 * Copyright (c) 1998-2000, Microsoft Corporation
 * 
 */
 
#define SYNCHRONOUS

namespace System.Web.SessionState {

    using System;
    using System.Configuration;
    using System.Collections;
    using System.Threading;
    using System.IO;
    using System.Web;
    using System.Web.Caching;
    using System.Web.Util;
    using System.Data;
    using System.Data.SqlClient;
    using System.Text;
    using System.Security.Principal;

    /*
     * Provides session state via SQL Server
     */
    internal class SqlStateClientManager : StateClientManager, IStateClientManager {
    
        internal enum SupportFlags : uint {
            None =              0x00000000,
            GetLockAge =        0x00000001,
            Uninitialized =     0xFFFFFFFF
        }
        
        static string       s_sqlConnectionString;
        static string       s_appSuffix;
        static ResourcePool s_rpool;
        static bool         s_useIntegratedSecurity;
        
        static ReadWriteSpinLock   s_lockInit;
        static SupportFlags s_support = SupportFlags.Uninitialized;

        SessionStateModule              _statemodule;

        const int ITEM_SHORT_LENGTH =   7000;
        const int APP_SUFFIX_LENGTH = 8;
        const string APP_SUFFIX_FORMAT = "x8";
        const int ID_LENGTH = SessionId.ID_LENGTH_CHARS + APP_SUFFIX_LENGTH;
        const int SQL_ERROR_PRIMARY_KEY_VIOLATION = 2627;

        internal SqlStateClientManager() {
        }

        void IStateClientManager.SetStateModule(SessionStateModule module) {
            _statemodule = module;
        }

        /*public*/ void IStateClientManager.ConfigInit(SessionStateSectionHandler.Config config, SessionOnEndTarget onEndTarget) {
            /*
             * Parse the connection string for errors. We want to ensure
             * that the user's connection string doesn't contain an
             * Initial Catalog entry, so we must first create a dummy connection.
             */
            SqlConnection   dummyConnection;
            try {
                dummyConnection = new SqlConnection(config._sqlConnectionString);
            }
            catch (Exception e) {
                throw new ConfigurationException(e.Message, e, config._configFileName, config._sqlLine);
            }

            string database = dummyConnection.Database;
            if (database != null && database.Length > 0) {
                throw new ConfigurationException(
                        HttpRuntime.FormatResourceString(SR.No_database_allowed_in_sqlConnectionString),
                        config._configFileName, config._sqlLine);
            }

            s_useIntegratedSecurity = DetectIntegratedSecurity(config._sqlConnectionString);
            s_sqlConnectionString = config._sqlConnectionString + ";Initial Catalog=ASPState";
            s_rpool = new ResourcePool(new TimeSpan(0, 0, 5), int.MaxValue);
        }

        /*public*/ void IStateClientManager.Dispose() {
            s_rpool.Dispose();
        }

        //
        // Detect if integrated security is used.  The following is a complete list
        // of strings the user can specify to use integrated security:
        //
        //  Trusted_Connection=true
        //  Trusted_Connection=yes
        //  Trusted_Connection=SSPI
        //  Integrated Security=true
        //  Integrated Security=yes
        //  Integrated Security=SSPI
        //
        bool DetectIntegratedSecurity(string connectionString) {
            string[]  tokens = connectionString.ToLower().Split(new char[] {';'});

            // Tokens are all in lower case
            foreach (string token in tokens) {
                string[] parts = token.Split(new char[] {'='});

                if (parts.Length == 2) {
                    string key = parts[0].Trim();

                    if (key == "trusted_connection" || key == "integrated security") {
                        string value = parts[1].Trim();

                        if (value == "true" || value == "sspi" || value == "yes") {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        public bool UseIntegratedSecurity {
            get {
                return s_useIntegratedSecurity;
            }
        }

        //
        // Regarding resource pool, we will turn it on if in <identity>:
        //  - User is not using integrated security
        //  - Impersonation = "false"
        //  - Impersonation = "true" and userName/password is NON-null
        //  - Impersonation = "true" and IIS is using Anonymous
        //
        // Otherwise, the impersonated account will be dynamic and we have to turn
        // resource pooling off.
        //
        // Note:
        // In case 2. above, the user can specify different usernames in different 
        // web.config in different subdirs in the app.  In this case, we will just 
        // cache the connections in the resource pool based on the identity of the 
        // connection.  So in this specific scenario it is possible to have the 
        // resource pool filled with mixed identities.
        // 
        bool CanUsePooling() {
            Debug.Assert(_statemodule != null);
            
            HttpContext context = _statemodule.RequestContext;
            bool    ret;

            if (!UseIntegratedSecurity) {
                Debug.Trace("SessionStatePooling", "CanUsePooling: not using integrated security");
                ret = true;
            }
            else if (context == null) {
                // One way this can happen is we hit an error on page compilation,
                // and SessionStateModule.OnEndRequest is called
                Debug.Trace("SessionStatePooling", "CanUsePooling: no context");
                ret = false;
            }
            else if (context.Impersonation.IsNoneOrApplication) {
                Debug.Trace("SessionStatePooling", "CanUsePooling: mode is None or Application");
                ret = true;
            }
            else  if (context.Impersonation.IsUNC) {
                Debug.Trace("SessionStatePooling", "CanUsePooling: mode is UNC");
                ret = false;
            }
            else {
                string logon = context.WorkerRequest.GetServerVariable("LOGON_USER");

                Debug.Trace("SessionStatePooling", "LOGON_USER = '" + logon + "'; identity = '" + context.User.Identity.Name + "'; IsUNC = " + context.Impersonation.IsUNC);

                if (logon == null || logon == "") {
                    ret = true;
                }
                else {
                    ret = false;
                }
            }

            Debug.Trace("SessionStatePooling", "CanUsePooling returns " + ret);
            return ret;
        }

        SqlStateConnection GetConnection(ref bool usePooling) {
            SqlStateConnection conn = null;
            
            usePooling = CanUsePooling();
            if (usePooling) {            
                conn = (SqlStateConnection) s_rpool.RetrieveResource();
            }
            if (conn == null) {
                conn = new SqlStateConnection(s_sqlConnectionString);
            }

            return conn;
        }

        void ReuseConnection(ref SqlStateConnection conn, bool usePooling) {
            if (usePooling) {
                s_rpool.StoreResource(conn);
            }
            conn = null;
        }

        SessionStateItem DoGet(String id, SqlCommand cmd) {
            SqlDataReader       reader;
            byte []             buf;
            MemoryStream        stream;
            SessionStateItem    item;
            bool                locked;
            int                 lockCookie;
            TimeSpan            lockAge;
            bool                useGetLockAge = false;

            buf = null;
            reader = null;

            Debug.Assert(SqlStateClientManager.s_support != SupportFlags.Uninitialized);
            if ((SqlStateClientManager.s_support & SupportFlags.GetLockAge) != 0) {
                useGetLockAge = true;
            }

            cmd.Parameters[0].Value = id + s_appSuffix; // @id
            cmd.Parameters[1].Value = Convert.DBNull;   // @itemShort
            cmd.Parameters[2].Value = Convert.DBNull;   // @locked
            cmd.Parameters[3].Value = Convert.DBNull;   // @lockDate or @lockAge
            cmd.Parameters[4].Value = Convert.DBNull;   // @lockCookie

            try {
                reader = cmd.ExecuteReader();

                /* If the cmd returned data, we must read it all before getting out params */
                if (reader != null) {
                    try {
                        if (reader.Read()) {
                            Debug.Trace("SessionStateClientManager", "Sql Get returned long item");
                            buf = (byte[]) reader[0];
                        }
                    }
                    finally {
                        reader.Close();
                    }
                }
            }
            catch (Exception e) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Cant_connect_sql_session_database),
                    e);
            }

            /* Check if value was returned */
            if (Convert.IsDBNull(cmd.Parameters[2].Value)) {
                Debug.Trace("SessionStateClientManager", "Sql Get returned null");
                return null;
            }

            /* Check if item is locked */
            Debug.Assert(!Convert.IsDBNull(cmd.Parameters[3].Value), "!Convert.IsDBNull(cmd.Parameters[3].Value)");
            Debug.Assert(!Convert.IsDBNull(cmd.Parameters[4].Value), "!Convert.IsDBNull(cmd.Parameters[4].Value)");

            locked = (bool) cmd.Parameters[2].Value;

            if (useGetLockAge) {
                lockAge = new TimeSpan(0, 0, (int) cmd.Parameters[3].Value);
            }
            else {
                DateTime            lockDate;
                lockDate = (DateTime) cmd.Parameters[3].Value;
                lockAge = DateTime.Now - lockDate;
            }

            Debug.Trace("SessionStateClientManager", "LockAge = " + lockAge);

            if (lockAge > new TimeSpan(0, 0, Sec.ONE_YEAR)) {
                Debug.Trace("SessionStateClientManager", "Lock age is more than 1 year!!!");
                lockAge = TimeSpan.Zero;
            }
            
            lockCookie = (int) cmd.Parameters[4].Value;
            

            if (locked) {
                Debug.Trace("SessionStateClientManager", "Sql Get returned item that was locked");
                return new SessionStateItem (
                    null, null, 0, false, 0, 
                    true, lockAge, lockCookie);
            }

            if (buf == null) {
                /* Get short item */
                Debug.Assert(!Convert.IsDBNull(cmd.Parameters[1].Value), "!Convert.IsDBNull(cmd.Parameters[1].Value)");
                Debug.Trace("SessionStateClientManager", "Sql Get returned short item");
                buf = (byte[]) cmd.Parameters[1].Value;
                Debug.Assert(buf != null, "buf != null");
            }

            stream = new MemoryStream(buf);
            item = Deserialize(stream, lockCookie);
            stream.Close();
            return item;
        }

        protected override SessionStateItem Get(String id) {
            Debug.Trace("SessionStateClientManager", "Calling Sql Get, id=" + id);

            bool                usePooling = true;
            SqlStateConnection conn = GetConnection(ref usePooling);
            SessionStateItem    item;

            try {
                item = DoGet(id, conn._cmdTempGet);
            }
            catch {
                conn.Dispose();
                throw;
            }

            ReuseConnection(ref conn, usePooling);
            return item;
        }

        /*public*/ IAsyncResult IStateClientManager.BeginGet(String id, AsyncCallback cb, Object state) {
            return BeginGetSync(id, cb, state);
        }

        /*public*/ SessionStateItem IStateClientManager.EndGet(IAsyncResult ar) {
            return EndGetSync(ar);
        }

        protected override SessionStateItem GetExclusive(String id) {
            Debug.Trace("SessionStateClientManager", "Calling Sql GetExclusive, id=" + id);

            bool             usePooling = true;
            SessionStateItem item;
            SqlStateConnection conn = GetConnection(ref usePooling);

            try {
                item = DoGet(id, conn._cmdTempGetExclusive);
            }
            catch {
                conn.Dispose();
                throw;
            }

            ReuseConnection(ref conn, usePooling);
            return item;
        }

        /*public*/ IAsyncResult IStateClientManager.BeginGetExclusive(String id, AsyncCallback cb, Object state) {
            return BeginGetExclusiveSync(id, cb, state);
        }

        /*public*/ SessionStateItem IStateClientManager.EndGetExclusive(IAsyncResult ar) {
            return EndGetExclusiveSync(ar);
        }
    
        /*public*/ void IStateClientManager.ReleaseExclusive(String id, int lockCookie) {
#if SYNCHRONOUS
            ReleaseExclusiveAsyncWorker(id, lockCookie);
#else
            ReleaseExclusiveAsync(id, lockCookie);
#endif
        }

        protected override void ReleaseExclusiveAsyncWorker(String id, int lockCookie) {
            Debug.Trace("SessionStateClientManager", "Calling Sql ReleaseExclusive, id=" + id);

            bool                usePooling = true;
            SqlStateConnection conn = GetConnection(ref usePooling);

            try {
                conn._cmdTempReleaseExclusive.Parameters[0].Value = id + s_appSuffix;
                conn._cmdTempReleaseExclusive.Parameters[1].Value = lockCookie;
                conn._cmdTempReleaseExclusive.ExecuteNonQuery();
            }
            catch (Exception e) {
                conn.Dispose();
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Cant_connect_sql_session_database),
                    e);
            }

            ReuseConnection(ref conn, usePooling);
        }

        /*public*/ void IStateClientManager.Set(String id, SessionStateItem item, bool inStorage) {
            byte []         buf;
            int             length;
            MemoryStream    s;

            try {
                s = new MemoryStream(ITEM_SHORT_LENGTH);
                Serialize(item, s);
                buf = s.GetBuffer();
                length = (int) s.Length;
                s.Close();
            }
            catch {
                if (inStorage) {
                    ((IStateClientManager)this).ReleaseExclusive(id, item.lockCookie);
                }
                throw;
            }

#if SYNCHRONOUS
            SetAsyncWorker(id, item, buf, length, inStorage);
#else
            if (inStorage) {
                SetAsync(id, item, buf, length, inStorage);
            }
            else {
                SetAsyncWorker(id, item, buf, length, inStorage);
            }
#endif            
        }

        protected override void SetAsyncWorker(String id, SessionStateItem item, 
                                    byte[] buf, int length, bool inStorage) {
            SqlCommand      cmd;

            Debug.Trace("SessionStateClientManager", "Calling Sql Set, id=" + id);

            bool                usePooling = true;
            SqlStateConnection conn = GetConnection(ref usePooling);

            try {
                if (inStorage) {
                    Debug.Assert(item.streamLength > 0, "item.streamLength > 0");
                    if (length <= ITEM_SHORT_LENGTH) {
                        if (item.streamLength <= ITEM_SHORT_LENGTH) {
                            cmd = conn._cmdTempUpdateShort;
                        }
                        else {
                            cmd = conn._cmdTempUpdateShortNullLong;
                        }
                    }
                    else {
                        if (item.streamLength <= ITEM_SHORT_LENGTH) {
                            cmd = conn._cmdTempUpdateLongNullShort;
                        }
                        else {
                            cmd = conn._cmdTempUpdateLong;
                        }
                    }

                }
                else {
                    if (length <= ITEM_SHORT_LENGTH) {
                        cmd = conn._cmdTempInsertShort;
                    }
                    else {
                        cmd = conn._cmdTempInsertLong;
                    }
                }

                cmd.Parameters[0].Value = id + s_appSuffix;
                cmd.Parameters[1].Size = length;
                cmd.Parameters[1].Value = buf;
                cmd.Parameters[2].Value = item.timeout;
                if (inStorage) {
                    cmd.Parameters[3].Value = item.lockCookie;
                }

                try {
                    cmd.ExecuteNonQuery();
                }
                catch (Exception e) {
                    SqlException sqlExpt = e as SqlException;
                    if (sqlExpt != null && 
                        sqlExpt.Number == SQL_ERROR_PRIMARY_KEY_VIOLATION &&
                        !inStorage) {

                        Debug.Trace("SessionStateClientSet", 
                            "Insert failed because of primary key violation; just leave gracefully; id=" + id);

                        // It's possible that two threads (from the same session) are creating the session
                        // state, both failed to get it first, and now both tried to insert it.
                        // One thread may lose with a Primary Key Violation error. If so, that thread will
                        // just lose and exit gracefully.
                    }
                    else {
                        throw new HttpException(
                            HttpRuntime.FormatResourceString(SR.Cant_connect_sql_session_database),
                            e);
                    }
                }
            }
            catch {
                conn.Dispose();
                throw;
            }

            ReuseConnection(ref conn, usePooling);
        }

        /*public*/ void IStateClientManager.Remove(String id, int lockCookie) {
#if SYNCHRONOUS
            RemoveAsyncWorker(id, lockCookie);
#else
            RemoveAsync(id, lockCookie);
#endif
        }

        protected override void RemoveAsyncWorker(String id, int lockCookie) {
            Debug.Trace("SessionStateClientManager", "Calling Sql Remove, id=" + id);

            bool                usePooling = true;
            SqlStateConnection conn = GetConnection(ref usePooling);

            try {
                conn._cmdTempRemove.Parameters[0].Value = id + s_appSuffix;
                conn._cmdTempRemove.Parameters[1].Value = lockCookie;
                conn._cmdTempRemove.ExecuteNonQuery();
            }
            catch (Exception e) {
                conn.Dispose();
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Cant_connect_sql_session_database),
                    e);

            }

            ReuseConnection(ref conn, usePooling);
        }

        /*public*/ void IStateClientManager.ResetTimeout(String id) {
#if SYNCHRONOUS
            ResetTimeoutAsyncWorker(id);
#else
            ResetTimeoutAsync(id);
#endif
        }

        protected override void ResetTimeoutAsyncWorker(String id) {
            Debug.Trace("SessionStateClientManager", "Calling Sql ResetTimeout, id=" + id);

            bool                usePooling = true;
            SqlStateConnection conn = GetConnection(ref usePooling);

            try {
                conn._cmdTempResetTimeout.Parameters[0].Value = id + s_appSuffix;
                conn._cmdTempResetTimeout.ExecuteNonQuery();
            }
            catch (Exception e) {
                conn.Dispose();
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Cant_connect_sql_session_database),
                    e);
            }
        
            ReuseConnection(ref conn, usePooling);
        }

        class SqlStateConnection : IDisposable {
            const int APPID_MAX = 280;

            SqlConnection       _sqlConnection;
            internal SqlCommand _cmdTempGet;
            internal SqlCommand _cmdTempGetExclusive;        
            internal SqlCommand _cmdTempReleaseExclusive;    
            internal SqlCommand _cmdTempInsertShort;         
            internal SqlCommand _cmdTempInsertLong;          
            internal SqlCommand _cmdTempUpdateShort;         
            internal SqlCommand _cmdTempUpdateShortNullLong; 
            internal SqlCommand _cmdTempUpdateLong;          
            internal SqlCommand _cmdTempUpdateLongNullShort; 
            internal SqlCommand _cmdTempRemove;              
            internal SqlCommand _cmdTempResetTimeout;        


            internal void GetServerSupportOptions() {
                if (SqlStateClientManager.s_support == SupportFlags.Uninitialized) {

                    SqlStateClientManager.s_lockInit.AcquireWriterLock();
                    try {
                        if (SqlStateClientManager.s_support == SupportFlags.Uninitialized) {
                            SqlCommand  cmd;
                            SqlDataReader reader = null;
                            SupportFlags  flags = SupportFlags.None;

                            cmd = new SqlCommand("Select name from sysobjects where type = 'P' and name = 'TempGetStateItem2'", _sqlConnection);
                            cmd.CommandType = CommandType.Text;

                            try {
                                reader = cmd.ExecuteReader(CommandBehavior.SingleRow);
                                if (reader.Read()) {
                                    flags |= SupportFlags.GetLockAge;
                                }

                                Debug.Trace("SqlStateConnection", "SqlStateClientManager.s_support initialized to " + flags);
                                
                                SqlStateClientManager.s_support = flags;    
                            }
                            catch (Exception e) {
                                _sqlConnection = null;
                                throw new HttpException(
                                    HttpRuntime.FormatResourceString(SR.Cant_connect_sql_session_database),
                                    e);
                            }
                            finally
                            {
                                if (reader != null) {
                                    reader.Close();
                                }
                            }
                        }
                    }
                    finally {
                        SqlStateClientManager.s_lockInit.ReleaseWriterLock();
                    }
                }
            }

            internal SqlStateConnection(string sqlconnectionstring) {
                Debug.Trace("SessionStateConnectionIdentity", "Connecting under " + WindowsIdentity.GetCurrent().Name);
                
                try {
                    _sqlConnection = new SqlConnection(sqlconnectionstring + ";Initial Catalog=ASPState");
                    _sqlConnection.Open();
                }
                catch (Exception e) {
                    _sqlConnection = null;
                    throw new HttpException(
                        HttpRuntime.FormatResourceString(SR.Cant_connect_sql_session_database),
                        e);
                }

                try {
                    /*
                     * Prepare commands.
                     */

                    SqlParameter p;

                    GetServerSupportOptions();
                    Debug.Assert(SqlStateClientManager.s_support != SupportFlags.Uninitialized);
                    
                    if ((SqlStateClientManager.s_support &  SupportFlags.GetLockAge) != 0) {
                        // Use the set of functions that support LockAge
                        
                        _cmdTempGet = new SqlCommand("TempGetStateItem2", _sqlConnection);
                        _cmdTempGet.CommandType = CommandType.StoredProcedure;
                        _cmdTempGet.Parameters.Add(new SqlParameter("@id", SqlDbType.Char, ID_LENGTH));
                        p = _cmdTempGet.Parameters.Add(new SqlParameter("@itemShort", SqlDbType.VarBinary, ITEM_SHORT_LENGTH));
                        p.Direction = ParameterDirection.Output;
                        p = _cmdTempGet.Parameters.Add(new SqlParameter("@locked", SqlDbType.Bit));
                        p.Direction = ParameterDirection.Output;
                        p = _cmdTempGet.Parameters.Add(new SqlParameter("@lockAge", SqlDbType.Int));
                        p.Direction = ParameterDirection.Output;
                        p = _cmdTempGet.Parameters.Add(new SqlParameter("@lockCookie", SqlDbType.Int));
                        p.Direction = ParameterDirection.Output;

                        _cmdTempGetExclusive = new SqlCommand("TempGetStateItemExclusive2", _sqlConnection);
                        _cmdTempGetExclusive.CommandType = CommandType.StoredProcedure;
                        _cmdTempGetExclusive.Parameters.Add(new SqlParameter("@id", SqlDbType.Char, ID_LENGTH));
                        p = _cmdTempGetExclusive.Parameters.Add(new SqlParameter("@itemShort", SqlDbType.VarBinary, ITEM_SHORT_LENGTH));
                        p.Direction = ParameterDirection.Output;
                        p = _cmdTempGetExclusive.Parameters.Add(new SqlParameter("@locked", SqlDbType.Bit));
                        p.Direction = ParameterDirection.Output;
                        p = _cmdTempGetExclusive.Parameters.Add(new SqlParameter("@lockAge", SqlDbType.Int));
                        p.Direction = ParameterDirection.Output;
                        p = _cmdTempGetExclusive.Parameters.Add(new SqlParameter("@lockCookie", SqlDbType.Int));
                        p.Direction = ParameterDirection.Output;
                    }
                    else {
                        _cmdTempGet = new SqlCommand("TempGetStateItem", _sqlConnection);
                        _cmdTempGet.CommandType = CommandType.StoredProcedure;
                        _cmdTempGet.Parameters.Add(new SqlParameter("@id", SqlDbType.Char, ID_LENGTH));
                        p = _cmdTempGet.Parameters.Add(new SqlParameter("@itemShort", SqlDbType.VarBinary, ITEM_SHORT_LENGTH));
                        p.Direction = ParameterDirection.Output;
                        p = _cmdTempGet.Parameters.Add(new SqlParameter("@locked", SqlDbType.Bit));
                        p.Direction = ParameterDirection.Output;
                        p = _cmdTempGet.Parameters.Add(new SqlParameter("@lockDate", SqlDbType.DateTime));
                        p.Direction = ParameterDirection.Output;
                        p = _cmdTempGet.Parameters.Add(new SqlParameter("@lockCookie", SqlDbType.Int));
                        p.Direction = ParameterDirection.Output;

                        _cmdTempGetExclusive = new SqlCommand("TempGetStateItemExclusive", _sqlConnection);
                        _cmdTempGetExclusive.CommandType = CommandType.StoredProcedure;
                        _cmdTempGetExclusive.Parameters.Add(new SqlParameter("@id", SqlDbType.Char, ID_LENGTH));
                        p = _cmdTempGetExclusive.Parameters.Add(new SqlParameter("@itemShort", SqlDbType.VarBinary, ITEM_SHORT_LENGTH));
                        p.Direction = ParameterDirection.Output;
                        p = _cmdTempGetExclusive.Parameters.Add(new SqlParameter("@locked", SqlDbType.Bit));
                        p.Direction = ParameterDirection.Output;
                        p = _cmdTempGetExclusive.Parameters.Add(new SqlParameter("@lockDate", SqlDbType.DateTime));
                        p.Direction = ParameterDirection.Output;
                        p = _cmdTempGetExclusive.Parameters.Add(new SqlParameter("@lockCookie", SqlDbType.Int));
                        p.Direction = ParameterDirection.Output;
                    }

                    /* ReleaseExlusive */
                    _cmdTempReleaseExclusive = new SqlCommand("TempReleaseStateItemExclusive", _sqlConnection);
                    _cmdTempReleaseExclusive.CommandType = CommandType.StoredProcedure;
                    _cmdTempReleaseExclusive.Parameters.Add(new SqlParameter("@id", SqlDbType.Char, ID_LENGTH));
                    _cmdTempReleaseExclusive.Parameters.Add(new SqlParameter("@lockCookie", SqlDbType.Int));

                    /* Insert */
                    _cmdTempInsertShort = new SqlCommand("TempInsertStateItemShort", _sqlConnection);
                    _cmdTempInsertShort.CommandType = CommandType.StoredProcedure;
                    _cmdTempInsertShort.Parameters.Add(new SqlParameter("@id", SqlDbType.Char, ID_LENGTH));
                    _cmdTempInsertShort.Parameters.Add(new SqlParameter("@itemShort", SqlDbType.VarBinary, ITEM_SHORT_LENGTH));
                    _cmdTempInsertShort.Parameters.Add(new SqlParameter("@timeout", SqlDbType.Int));

                    _cmdTempInsertLong = new SqlCommand("TempInsertStateItemLong", _sqlConnection);
                    _cmdTempInsertLong.CommandType = CommandType.StoredProcedure;
                    _cmdTempInsertLong.Parameters.Add(new SqlParameter("@id", SqlDbType.Char, ID_LENGTH));
                    _cmdTempInsertLong.Parameters.Add(new SqlParameter("@itemLong", SqlDbType.Image, 8000));
                    _cmdTempInsertLong.Parameters.Add(new SqlParameter("@timeout", SqlDbType.Int));

                    /* Update */
                    _cmdTempUpdateShort = new SqlCommand("TempUpdateStateItemShort", _sqlConnection);
                    _cmdTempUpdateShort.CommandType = CommandType.StoredProcedure;
                    _cmdTempUpdateShort.Parameters.Add(new SqlParameter("@id", SqlDbType.Char, ID_LENGTH));
                    _cmdTempUpdateShort.Parameters.Add(new SqlParameter("@itemShort", SqlDbType.VarBinary, ITEM_SHORT_LENGTH));
                    _cmdTempUpdateShort.Parameters.Add(new SqlParameter("@timeout", SqlDbType.Int));
                    _cmdTempUpdateShort.Parameters.Add(new SqlParameter("@lockCookie", SqlDbType.Int));

                    _cmdTempUpdateShortNullLong = new SqlCommand("TempUpdateStateItemShortNullLong", _sqlConnection);
                    _cmdTempUpdateShortNullLong.CommandType = CommandType.StoredProcedure;
                    _cmdTempUpdateShortNullLong.Parameters.Add(new SqlParameter("@id", SqlDbType.Char, ID_LENGTH));
                    _cmdTempUpdateShortNullLong.Parameters.Add(new SqlParameter("@itemShort", SqlDbType.VarBinary, ITEM_SHORT_LENGTH));
                    _cmdTempUpdateShortNullLong.Parameters.Add(new SqlParameter("@timeout", SqlDbType.Int));
                    _cmdTempUpdateShortNullLong.Parameters.Add(new SqlParameter("@lockCookie", SqlDbType.Int));

                    _cmdTempUpdateLong = new SqlCommand("TempUpdateStateItemLong", _sqlConnection);
                    _cmdTempUpdateLong.CommandType = CommandType.StoredProcedure;
                    _cmdTempUpdateLong.Parameters.Add(new SqlParameter("@id", SqlDbType.Char, ID_LENGTH));
                    _cmdTempUpdateLong.Parameters.Add(new SqlParameter("@itemLong", SqlDbType.Image, 8000));
                    _cmdTempUpdateLong.Parameters.Add(new SqlParameter("@timeout", SqlDbType.Int));
                    _cmdTempUpdateLong.Parameters.Add(new SqlParameter("@lockCookie", SqlDbType.Int));

                    _cmdTempUpdateLongNullShort = new SqlCommand("TempUpdateStateItemLongNullShort", _sqlConnection);
                    _cmdTempUpdateLongNullShort.CommandType = CommandType.StoredProcedure;
                    _cmdTempUpdateLongNullShort.Parameters.Add(new SqlParameter("@id", SqlDbType.Char, ID_LENGTH));
                    _cmdTempUpdateLongNullShort.Parameters.Add(new SqlParameter("@itemLong", SqlDbType.Image, 8000));
                    _cmdTempUpdateLongNullShort.Parameters.Add(new SqlParameter("@timeout", SqlDbType.Int));
                    _cmdTempUpdateLongNullShort.Parameters.Add(new SqlParameter("@lockCookie", SqlDbType.Int));

                    /* Remove */
                    _cmdTempRemove = new SqlCommand("TempRemoveStateItem", _sqlConnection);
                    _cmdTempRemove.CommandType = CommandType.StoredProcedure;
                    _cmdTempRemove.Parameters.Add(new SqlParameter("@id", SqlDbType.Char, ID_LENGTH));
                    _cmdTempRemove.Parameters.Add(new SqlParameter("@lockCookie", SqlDbType.Int));

                    /* ResetTimeout */
                    _cmdTempResetTimeout = new SqlCommand("TempResetTimeout", _sqlConnection);
                    _cmdTempResetTimeout.CommandType = CommandType.StoredProcedure;
                    _cmdTempResetTimeout.Parameters.Add(new SqlParameter("@id", SqlDbType.Char, ID_LENGTH));

                    if (SqlStateClientManager.s_appSuffix == null) {
                        SqlCommand  cmdTempGetAppId = new SqlCommand("TempGetAppID", _sqlConnection);
                        cmdTempGetAppId.CommandType = CommandType.StoredProcedure;
                        p = cmdTempGetAppId.Parameters.Add(new SqlParameter("@appName", SqlDbType.VarChar, APPID_MAX));
                        p.Value = HttpRuntime.AppDomainAppIdInternal;
                        p = cmdTempGetAppId.Parameters.Add(new SqlParameter("@appId", SqlDbType.Int));
                        p.Direction = ParameterDirection.Output;
                        p.Value = Convert.DBNull;

                        cmdTempGetAppId.ExecuteNonQuery();
                        Debug.Assert(!Convert.IsDBNull(p), "!Convert.IsDBNull(p)");
                        int appId = (int) p.Value;
                        SqlStateClientManager.s_appSuffix = (appId).ToString(APP_SUFFIX_FORMAT);
                    }

                    PerfCounters.IncrementCounter(AppPerfCounter.SESSION_SQL_SERVER_CONNECTIONS);
                }
                catch {
                    Dispose();
                    throw;
                }
            }

            public void Dispose() {
                if (_sqlConnection != null) {
                    _sqlConnection.Close();
                    _sqlConnection = null;
                    PerfCounters.DecrementCounter(AppPerfCounter.SESSION_SQL_SERVER_CONNECTIONS);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\state\stateclientmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="StateClientManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * StateClientManager
 * 
 */
namespace System.Web.SessionState {
    using System.Threading;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Runtime.Serialization;

    using System.Text;
    using System.Collections;
    using System.IO;
    using System.Web;
    using System.Web.Caching;
    using System.Web.Util;

    internal class SessionStateItem {
        internal SessionDictionary              dict;
        internal HttpStaticObjectsCollection    staticObjects;
        internal int                            timeout;        // USed to set slidingExpiration in CacheEntry
        internal bool                           isCookieless;
        internal int                            streamLength;
        internal bool                           locked;         // If it's locked by another thread
        internal TimeSpan                       lockAge;
        internal int                            lockCookie;

        internal SessionStateItem(
                SessionDictionary           dict, 
                HttpStaticObjectsCollection staticObjects, 
                int                         timeout,
                bool                        isCookieless,
                int                         streamLength,
                bool                        locked,
                TimeSpan                    lockAge,
                int                         lockCookie) {

            this.dict = dict;
            this.staticObjects = staticObjects;
            this.timeout = timeout;
            this.isCookieless = isCookieless;
            this.streamLength = streamLength;
            this.locked = locked;
            this.lockAge = lockAge;
            this.lockCookie = lockCookie;
        }
    }


    internal interface IStateClientManager {
        void              ConfigInit(SessionStateSectionHandler.Config config, SessionOnEndTarget onEndTarget);
        void              Dispose();
        void              SetStateModule(SessionStateModule module);

        IAsyncResult      BeginGet(String id, AsyncCallback cb, Object state);
        SessionStateItem  EndGet(IAsyncResult ar);

        // Get with a lock
        IAsyncResult      BeginGetExclusive(String id, AsyncCallback cb, Object state);
        SessionStateItem  EndGetExclusive(IAsyncResult ar);

        // Unlock the item
        void              ReleaseExclusive(String id, int lockCookie);
        
        void              Set(String id, SessionStateItem item, bool inStorage);
        void              Remove(String id, int lockCookie);
        void              ResetTimeout(String id);
    }


    /*
     * An abstraction so that the session state module can be
     * coded without knowledge of the location of session state.
     */

    internal abstract class StateClientManager {
        protected virtual SessionStateItem Get(String id) {
            return null;
        }

        // Called by IStateClientManager::BeginGet
        protected IAsyncResult BeginGetSync(String id, AsyncCallback cb, Object state) {
            SessionStateItem item = Get(id);
            return new HttpAsyncResult(cb, state, true, item, null);
        }

        // Called by IStateClientManager::EndGet
        protected SessionStateItem  EndGetSync(IAsyncResult ar) {
            return (SessionStateItem)((HttpAsyncResult)ar).End();
        }

        // Implemented by derived class to support GetExclusiveSync
        protected virtual SessionStateItem GetExclusive(String id) {
            return null;
        }

        // Called by IStateClientManager::BeginGetExclusive
        protected IAsyncResult       BeginGetExclusiveSync(String id, AsyncCallback cb, Object state) {
            SessionStateItem item = GetExclusive(id);
            return new HttpAsyncResult(cb, state, true, item, null);
        }

        // Called by IStateClientManager::EndGetExclusive
        protected SessionStateItem   EndGetExclusiveSync(IAsyncResult ar) {
            return (SessionStateItem)((HttpAsyncResult)ar).End();
        }
    
        class AsyncWorkItem
        {
            StateClientManager _manager;
            String             _id;
            SessionStateItem   _item;
            bool               _inStorage;
            int                _lockCookie;
            byte[]             _buf;
            int                _length;

            internal AsyncWorkItem(StateClientManager manager, String id, SessionStateItem item, 
                                        byte[] buf, int length, bool inStorage, int lockCookie) {
                _manager = manager;
                _id = id;
                _item = item;
                _buf = buf;
                _length = length;
                _inStorage = inStorage;
                _lockCookie = lockCookie;
            }

            internal void ReleaseExclusiveAsyncCallback() {
                _manager.ReleaseExclusiveAsyncWorker(_id, _lockCookie);
            }

            internal void SetAsyncCallback() {
                _manager.SetAsyncWorker(_id, _item, _buf, _length, _inStorage);
            }

            internal void RemoveAsyncCallback() {
                _manager.RemoveAsyncWorker(_id, _lockCookie);
            }

            internal void ResetTimeoutAsyncCallback() {
                _manager.ResetTimeoutAsyncWorker(_id);
            }
        }

        // Called by IStateClientManager::ReleaseExclusive
        protected void  ReleaseExclusiveAsync(String id, int lockCookie) {
            AsyncWorkItem asyncWorkItem = new AsyncWorkItem(this, id, null, null, 0, false, lockCookie);
            WorkItem.PostInternal(new WorkItemCallback(asyncWorkItem.ReleaseExclusiveAsyncCallback));
        }

        // Callback func for the worker thread from ReleaseExclusiveAsync 
        protected virtual void ReleaseExclusiveAsyncWorker(String id, int lockCookie) {}


        // Called by IStateClientManager::Set
        protected void  SetAsync(String id, SessionStateItem item, 
                                    byte[] buf, int length, bool inStorage) {
            AsyncWorkItem asyncWorkItem = new AsyncWorkItem(this, id, item, buf, length, inStorage, 0);
            WorkItem.PostInternal(new WorkItemCallback(asyncWorkItem.SetAsyncCallback));
        }

        // Callback func for the worker thread from SetAsync 
        protected virtual void  SetAsyncWorker(String id, SessionStateItem item, 
                                    byte[] buf, int lenght, bool inStorage) {}

        // Called by IStateClientManager::Remove
        protected void  RemoveAsync(String id, int lockCookie) {
            AsyncWorkItem asyncWorkItem = new AsyncWorkItem(this, id, null, null, 0, false, lockCookie);
            WorkItem.PostInternal(new WorkItemCallback(asyncWorkItem.RemoveAsyncCallback));
        }

        // Callback func for the worker thread from RemoveAsync 
        protected virtual void RemoveAsyncWorker(String id, int lockCookie) {}

        // Called by IStateClientManager::ResetTimeout
        protected void  ResetTimeoutAsync(String id) {
            AsyncWorkItem asyncWorkItem = new AsyncWorkItem(this, id, null, null, 0, false, 0);
            WorkItem.PostInternal(new WorkItemCallback(asyncWorkItem.ResetTimeoutAsyncCallback));
        }

        // Callback func for the worker thread from ResetTimeoutAsync 
        protected virtual void ResetTimeoutAsyncWorker(String id) {}

        static protected void Serialize(SessionStateItem item, Stream stream) {
            bool    hasDict;
            bool    hasStaticObjects;

            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(item.timeout);

            writer.Write(item.isCookieless);

            hasDict = item.dict != null;
            writer.Write(hasDict);

            hasStaticObjects = item.staticObjects != null;
            writer.Write(hasStaticObjects);

            if (hasDict) {
                item.dict.Serialize(writer);
            }

            if (hasStaticObjects) {
                item.staticObjects.Serialize(writer);
            }

            // Prevent truncation of the stream
            writer.Write(unchecked((byte)0xff));
        }


        static protected SessionStateItem Deserialize(
                Stream      stream,
                int         lockCookie) {

            SessionStateItem    item;
            int                 timeout;
            bool                isCookieless;
            SessionDictionary   dict;
            bool                hasDict;
            bool                hasStaticObjects;
            HttpStaticObjectsCollection col;
            Byte                eof;

            BinaryReader reader = new BinaryReader(stream);
            timeout = reader.ReadInt32();
            isCookieless = reader.ReadBoolean();
            hasDict = reader.ReadBoolean();
            hasStaticObjects = reader.ReadBoolean();

            if (hasDict) {
                dict = SessionDictionary.Deserialize(reader);
            }
            else {
                dict = null;
            }

            if (hasStaticObjects) {
                col = HttpStaticObjectsCollection.Deserialize(reader);
            }
            else {
                col = null;
            }

            eof = reader.ReadByte();
            Debug.Assert(eof == 0xff);

            item = new SessionStateItem(
                    dict, col, timeout, isCookieless, (int) stream.Position, 
                    false, TimeSpan.Zero, lockCookie);

            return item;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\attributecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="AttributeCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * AttributeCollection.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI {
    using System.IO;
    using System.Collections;
    using System.Reflection;
    using System.Web.UI;
    using System.Globalization;
    using System.Security.Permissions;
    
/*
 * The AttributeCollection represents Attributes on an Html control.
 */
/// <include file='doc\AttributeCollection.uex' path='docs/doc[@for="AttributeCollection"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='AttributeCollection'/> class provides object-model access
///       to all attributes declared on an HTML server control element.
///    </para>
/// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class AttributeCollection {
        private StateBag _bag;
        private CssStyleCollection _styleColl;

        /*
         *      Constructs an AttributeCollection given a StateBag.
         */
        /// <include file='doc\AttributeCollection.uex' path='docs/doc[@for="AttributeCollection.AttributeCollection"]/*' />
        /// <devdoc>
        /// </devdoc>
        public AttributeCollection(StateBag bag) {
            _bag = bag;
        }

        /*
         * Automatically adds new keys.
         */
        /// <include file='doc\AttributeCollection.uex' path='docs/doc[@for="AttributeCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a specified attribute value.
        ///    </para>
        /// </devdoc>
        public string this[string key]
        {
            get { 
                if (_styleColl != null && String.Compare (key, "style", true, CultureInfo.InvariantCulture) == 0)
                    return _styleColl.Style;
                else
                    return(string)_bag[key]; 
            }

            set { 
                Add(key, value); 
            }
        }

        /*
         * Returns a collection of keys.
         */
        /// <include file='doc\AttributeCollection.uex' path='docs/doc[@for="AttributeCollection.Keys"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of keys to all the attributes in the
        ///    <see langword='AttributeCollection'/>.
        ///    </para>
        /// </devdoc>
        public ICollection Keys {
            get { 
                return _bag.Keys;
            }
        }

        /// <include file='doc\AttributeCollection.uex' path='docs/doc[@for="AttributeCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of items in the <see langword='AttributeCollection'/>.
        ///    </para>
        /// </devdoc>
        public int Count {
            get { 
                return _bag.Count; 
            }
        }

        /// <include file='doc\AttributeCollection.uex' path='docs/doc[@for="AttributeCollection.CssStyle"]/*' />
        /// <devdoc>
        /// </devdoc>
        public CssStyleCollection CssStyle {
            get {
                if (_styleColl == null) {
                    _styleColl = new CssStyleCollection(_bag);
                }
                return _styleColl;
            }
        }

        /// <include file='doc\AttributeCollection.uex' path='docs/doc[@for="AttributeCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an item to the <see langword='AttributeCollection'/>.
        ///    </para>
        /// </devdoc>
        public void Add(string key, string value) {
            if (_styleColl != null && String.Compare (key, "style", true, CultureInfo.InvariantCulture) == 0)
                _styleColl.Style = value;
            else
                _bag[key] = value;
        }

        /// <include file='doc\AttributeCollection.uex' path='docs/doc[@for="AttributeCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes an attribute from the <see langword='AttributeCollection'/>.
        ///    </para>
        /// </devdoc>
        public void Remove(string key) {
            if (_styleColl != null && String.Compare (key, "style", true, CultureInfo.InvariantCulture) == 0)
                _styleColl.Clear();
            else
                _bag.Remove(key);
        }

        /// <include file='doc\AttributeCollection.uex' path='docs/doc[@for="AttributeCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes all attributes from the <see langword='AttributeCollection'/>.
        ///    </para>
        /// </devdoc>
        public void Clear() {
            _bag.Clear();
            if (_styleColl != null)
                _styleColl.Clear();
        }

        /// <include file='doc\AttributeCollection.uex' path='docs/doc[@for="AttributeCollection.Render"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Render(HtmlTextWriter writer) {
            if (_bag.Count > 0) {
                IDictionaryEnumerator e = _bag.GetEnumerator();

                while (e.MoveNext()) {
                    StateItem item = e.Value as StateItem;
                    if (item != null) {
                        string value = item.Value as string;
                        string key = e.Key as string;
                        if (key != null && value != null) {
                            writer.WriteAttribute(key, value, true /*fEncode*/);
                        }
                    }
                }
            }
        }

        /// <include file='doc\AttributeCollection.uex' path='docs/doc[@for="AttributeCollection.AddAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddAttributes(HtmlTextWriter writer) {
            if (_bag.Count > 0) {
                IDictionaryEnumerator e = _bag.GetEnumerator();

                while (e.MoveNext()) {
                    StateItem item = e.Value as StateItem;
                    if (item != null) {
                        string value = item.Value as string;
                        string key = e.Key as string;
                        if (key != null && value != null) {
                            writer.AddAttribute(key, value, true /*fEncode*/);
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\state\stateruntime.cs ===
//------------------------------------------------------------------------------
// <copyright file="StateRuntime.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * StateWebRuntime
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.SessionState {

    using System.Threading;
    using System.Runtime.InteropServices;   
    using System.IO;    
    using System.Web;
    using System.Web.Caching;
    using System.Web.Util;
    using System.Security.Permissions;

    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    [ComImport, Guid("7297744b-e188-40bf-b7e9-56698d25cf44"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    public interface IStateRuntime {
        /// <include file='doc\StateRuntime.uex' path='docs/doc[@for="IStateRuntime.StopProcessing"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        void StopProcessing();
        /// <include file='doc\StateRuntime.uex' path='docs/doc[@for="IStateRuntime.ProcessRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        
        void ProcessRequest(
               [In, MarshalAs(UnmanagedType.SysInt)]
               IntPtr tracker,
               [In, MarshalAs(UnmanagedType.I4)]
               int verb,
               [In, MarshalAs(UnmanagedType.LPWStr)]
               string uri,
               [In, MarshalAs(UnmanagedType.I4)]
               int exclusive,
               [In, MarshalAs(UnmanagedType.I4)]
               int timeout,
               [In, MarshalAs(UnmanagedType.I4)]
               int lockCookieExists,
               [In, MarshalAs(UnmanagedType.I4)]
               int lockCookie,
               [In, MarshalAs(UnmanagedType.I4)]
               int contentLength,
               [In, MarshalAs(UnmanagedType.SysInt)]
               IntPtr content);

    }

    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class StateRuntime : IStateRuntime {
        static StateRuntime() {
            StateApplication app = new StateApplication();

            HttpApplicationFactory.SetCustomApplication(app);

            PerfCounters.Open(null);
            ResetStateServerCounters();
        }

        /// <include file='doc\StateRuntime.uex' path='docs/doc[@for="StateRuntime.StateRuntime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.State.StateRuntime'/>
        ///       class.
        ///     </para>
        /// </devdoc>
        public StateRuntime() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }

        /*
         * Shutdown runtime
         */
        /// <include file='doc\StateRuntime.uex' path='docs/doc[@for="StateRuntime.StopProcessing"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void StopProcessing() {
            ResetStateServerCounters();
            HttpRuntime.Close();
        }

        static void ResetStateServerCounters() {
            PerfCounters.SetGlobalCounter(GlobalPerfCounter.STATE_SERVER_SESSIONS_TOTAL, 0);
            PerfCounters.SetGlobalCounter(GlobalPerfCounter.STATE_SERVER_SESSIONS_ACTIVE, 0);
            PerfCounters.SetGlobalCounter(GlobalPerfCounter.STATE_SERVER_SESSIONS_TIMED_OUT, 0);
            PerfCounters.SetGlobalCounter(GlobalPerfCounter.STATE_SERVER_SESSIONS_ABANDONED, 0);
        }

        /*
         * Process one ISAPI request
         *
         * @param ecb ECB
         */
        /// <include file='doc\StateRuntime.uex' path='docs/doc[@for="StateRuntime.ProcessRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ProcessRequest(
                  IntPtr tracker,
                  int verb,
                  string uri,
                  int exclusive,
                  int timeout,
                  int lockCookieExists,
                  int lockCookie,
                  int contentLength,
                  IntPtr content
                  ) {

            StateHttpWorkerRequest  wr;

            wr = new StateHttpWorkerRequest(
                       tracker, (UnsafeNativeMethods.StateProtocolVerb) verb, uri, 
                       (UnsafeNativeMethods.StateProtocolExclusive) exclusive, timeout, 
                       lockCookieExists, lockCookie, contentLength, content);

            HttpRuntime.ProcessRequest(wr);
        }
    }

    internal sealed class StateHeaders {
        internal const String EXCLUSIVE_NAME = "Http_Exclusive";
        internal const String EXCLUSIVE_VALUE_ACQUIRE = "acquire";
        internal const String EXCLUSIVE_VALUE_RELEASE = "release";
        internal const String TIMEOUT_NAME = "Http_Timeout";
        internal const String TIMEOUT_NAME_RAW = "Timeout";
        internal const String LOCKCOOKIE_NAME = "Http_LockCookie";
        internal const String LOCKCOOKIE_NAME_RAW = "LockCookie";
        internal const String LOCKDATE_NAME = "Http_LockDate";
        internal const String LOCKDATE_NAME_RAW = "LockDate";
        internal const String LOCKAGE_NAME = "Http_LockAge";
        internal const String LOCKAGE_NAME_RAW = "LockAge";

        internal StateHeaders() {}
    };

    internal sealed class CachedContent {
        internal byte[]             _content;
        internal IntPtr             _stateItem;
        internal bool               _locked;
        internal DateTime           _utcLockDate;
        internal int                _lockCookie;
        internal ReadWriteSpinLock  _spinLock;

        internal CachedContent(
                byte []     content, 
                IntPtr      stateItem,
                bool        locked,
                DateTime    utcLockDate,
                int         lockCookie) {

            _content = content;
            _stateItem = stateItem;
            _locked = locked;
            _utcLockDate = utcLockDate;
            _lockCookie = lockCookie;
        }
    }

    internal class StateApplication : IHttpHandler {
        CacheItemRemovedCallback _removedHandler;

        internal StateApplication() {
            _removedHandler = new CacheItemRemovedCallback(this.OnCacheItemRemoved);
        }

        public void ProcessRequest(HttpContext context) {
            String method;

            // Don't send content-type header.
            context.Response.ContentType = null;

            method = context.Request.HttpMethod;

            switch (method.Length) {
                case 3:
                    if (method.Equals("GET"))           DoGet(context);
                    else if (method.Equals("PUT"))      DoPut(context);
                    else                                DoUnknown(context);
                    break;
                case 4:
                    if (method.Equals("HEAD"))          DoHead(context);
                    else                                DoUnknown(context);
                    break;
                case 6:
                    if (method.Equals("DELETE"))        DoDelete(context);
                    else                                DoUnknown(context);
                    break;
	        default:                                DoUnknown(context);
		    break;
            }
        }

        public bool IsReusable {
            get { return true; }
        }

        private string CreateKey(HttpRequest request) {
            return "System.Web.SessionState.StateApplication:" + request.Path;
        }

        private void ReportInvalidHeader(HttpContext context, String header) {
            HttpResponse    response;

            response = context.Response;
            response.StatusCode = 400;
            response.Write("<html><head><title>Bad Request</title></head>\r\n");
            response.Write("<body><h1>Http/1.1 400 Bad Request</h1>");
            response.Write("Invalid header <b>" + header + "</b></body></html>");
        }

        private void ReportLocked(HttpContext context, CachedContent content) {
            HttpResponse    response;
            DateTime        localLockDate;
            long            lockAge;

            // Note that due to a bug in the RTM state server client, 
            // we cannot add to body of the response when sending this
            // message, otherwise the client will leak memory.
            response = context.Response;
            response.StatusCode = 423;
            localLockDate = DateTimeUtil.ConvertToLocalTime(content._utcLockDate);
            lockAge = (DateTime.UtcNow - content._utcLockDate).Ticks / TimeSpan.TicksPerSecond;
            response.AppendHeader(StateHeaders.LOCKDATE_NAME_RAW, localLockDate.Ticks.ToString());
            response.AppendHeader(StateHeaders.LOCKAGE_NAME_RAW, lockAge.ToString());
            response.AppendHeader(StateHeaders.LOCKCOOKIE_NAME_RAW, content._lockCookie.ToString());
        }

        private void ReportNotFound(HttpContext context) {
            context.Response.StatusCode = 404;
        }

        bool GetOptionalNonNegativeInt32HeaderValue(HttpContext context, string header, out int value)
        {
            bool headerValid;
            string valueAsString;

            value = -1;
            valueAsString = context.Request.Headers[header];
            if (valueAsString == null) {
                headerValid = true;
            }
            else {
                headerValid = false;
                try {
                    value = Int32.Parse(valueAsString);
                    if (value >= 0) {
                        headerValid = true;
                    }
                }
                catch {
                }
            }

            if (!headerValid) {
                ReportInvalidHeader(context, header);
            }

            return headerValid;
        }

        bool GetRequiredNonNegativeInt32HeaderValue(HttpContext context, string header, out int value)
        {
            bool headerValid = GetOptionalNonNegativeInt32HeaderValue(context, header, out value);
            if (headerValid && value == -1) {
                headerValid = false;
                ReportInvalidHeader(context, header);
            }

            return headerValid;
        }

        /*
         * Check Exclusive header for get, getexlusive, releaseexclusive
         * use the path as the id
         * Create the cache key
         * follow inproc.
         */
        internal /*public*/ void DoGet(HttpContext context) {
            HttpRequest     request = context.Request;
            HttpResponse    response = context.Response;
            Stream          responseStream;
            byte[]          buf;
            string          exclusiveAccess;
            string          key;
            CachedContent   content;
            CacheEntry      entry;
            int             lockCookie;
            int             timeout;

            key = CreateKey(request);
            entry = (CacheEntry) HttpRuntime.CacheInternal.Get(key, CacheGetOptions.ReturnCacheEntry);
            if (entry == null) {
                ReportNotFound(context);
                return;
            }

            exclusiveAccess = request.Headers[StateHeaders.EXCLUSIVE_NAME];
            content = (CachedContent) entry.Value;
            content._spinLock.AcquireWriterLock();
            try {
                if (content._content == null) {
                    ReportNotFound(context);
                    return;
                }
                
                if (exclusiveAccess == StateHeaders.EXCLUSIVE_VALUE_RELEASE) {
                    if (!GetRequiredNonNegativeInt32HeaderValue(context, StateHeaders.LOCKCOOKIE_NAME, out lockCookie))
                        return;
                     
                    if (content._locked) {
                        if (lockCookie == content._lockCookie) {
                            content._locked = false;
                        }
                        else {
                            ReportLocked(context, content);
                        }
                    }
                    else {
                        // should be locked but isn't.
                        context.Response.StatusCode = 400;
                    }
                } 
                else {
                    if (content._locked) {
                        ReportLocked(context, content);
                        return;
                    }

                    if (exclusiveAccess == StateHeaders.EXCLUSIVE_VALUE_ACQUIRE) {
                        content._locked = true;
                        content._utcLockDate = DateTime.UtcNow;
                        content._lockCookie++;

                        response.AppendHeader(StateHeaders.LOCKCOOKIE_NAME_RAW, (content._lockCookie).ToString());
                    }

                    timeout = (int) (entry.SlidingExpiration.Ticks / TimeSpan.TicksPerMinute);
                    response.AppendHeader(StateHeaders.TIMEOUT_NAME_RAW, (timeout).ToString());
                    responseStream = response.OutputStream;
                    buf = content._content;
                    responseStream.Write(buf, 0, buf.Length);
                    response.Flush();
                }
            }
            finally {
                content._spinLock.ReleaseWriterLock();
            }
        }


        internal /*public*/ void DoPut(HttpContext context) {
            IntPtr  stateItemDelete;

            stateItemDelete = FinishPut(context);
            if (stateItemDelete != IntPtr.Zero) {
                UnsafeNativeMethods.STWNDDeleteStateItem(stateItemDelete);
            }
        }

        unsafe IntPtr FinishPut(HttpContext context) {
            HttpRequest         request = context.Request;   
            HttpResponse        response = context.Response; 
            Stream              requestStream;               
            byte[]              buf;                         
            int                 timeoutMinutes;
            TimeSpan            timeout;
            string              key;                         
            CachedContent       content;
            CachedContent       contentCurrent;
            int                 lockCookie;
            IntPtr              stateItem;
            CacheInternal       cacheInternal = HttpRuntime.CacheInternal;

            /* create the content */
            requestStream = request.InputStream;
            int bufferSize = (int)(requestStream.Length - requestStream.Position);
            buf = new byte[bufferSize];
            requestStream.Read(buf, 0 , buf.Length);

            fixed (byte * pBuf = buf) {
                stateItem = (IntPtr)(*((void **)pBuf));
            }

            /* get headers */
            if (!GetOptionalNonNegativeInt32HeaderValue(context, StateHeaders.TIMEOUT_NAME, out timeoutMinutes)) {
                return stateItem;
            }

            if (timeoutMinutes == -1) {
                timeoutMinutes = SessionStateModule.TIMEOUT_DEFAULT;
            }

            timeout = new TimeSpan(0, timeoutMinutes, 0);

            /* lookup current value */
            key = CreateKey(request);
            CacheEntry entry = (CacheEntry) cacheInternal.Get(key, CacheGetOptions.ReturnCacheEntry);
            if (entry != null) {
                if (!GetOptionalNonNegativeInt32HeaderValue(context, StateHeaders.LOCKCOOKIE_NAME, out lockCookie)) {
                    return stateItem;
                }

                contentCurrent = (CachedContent) entry.Value;
                contentCurrent._spinLock.AcquireWriterLock();
                try {
                    if (contentCurrent._content == null) {
                        ReportNotFound(context);
                        return stateItem;
                    }

                    /* Only set the item if we are the owner */
                    if (contentCurrent._locked && (lockCookie == -1 || lockCookie != contentCurrent._lockCookie)) {
                        ReportLocked(context, contentCurrent);
                        return stateItem;
                    }

                    if (entry.SlidingExpiration == timeout && contentCurrent._content != null) {
                        /* delete the old state item */
                        IntPtr stateItemOld = contentCurrent._stateItem;

                        /* change the item in place */
                        contentCurrent._content = buf;
                        contentCurrent._stateItem = stateItem;
                        contentCurrent._locked = false;
                        return stateItemOld;
                    }

                    /*
                     * If not locked, keep it locked until it is completely replaced.
                     * Prevent overwriting when we drop the lock.
                     */
                    contentCurrent._locked = true;
                    contentCurrent._lockCookie = 0;
                }
                finally {
                    contentCurrent._spinLock.ReleaseWriterLock();
                }
            }

            content = new CachedContent(buf, stateItem, false, DateTime.MinValue, 1);
            cacheInternal.UtcInsert(
                    key, content, null, Cache.NoAbsoluteExpiration, timeout,
                    CacheItemPriority.NotRemovable, _removedHandler);

            if (entry == null) {
                IncrementGlobalCounter(GlobalPerfCounter.STATE_SERVER_SESSIONS_TOTAL);
                IncrementGlobalCounter(GlobalPerfCounter.STATE_SERVER_SESSIONS_ACTIVE);
            }

            return IntPtr.Zero;
        }

        internal /*public*/ void DoDelete(HttpContext context) {
            string          key = CreateKey(context.Request);
            CacheInternal   cacheInternal = HttpRuntime.CacheInternal;
            CachedContent   content = (CachedContent) cacheInternal.Get(key);

            /* If the item isn't there, we probably took too long to run. */
            if (content == null) {
                ReportNotFound(context);
                return;
            }

            int lockCookie;
            if (!GetOptionalNonNegativeInt32HeaderValue(context, StateHeaders.LOCKCOOKIE_NAME, out lockCookie))
                return;

            content._spinLock.AcquireWriterLock();
            try {
                if (content._content == null) {
                    ReportNotFound(context);
                    return;
                }

                /* Only remove the item if we are the owner */
                if (content._locked && (lockCookie == -1 || content._lockCookie != lockCookie)) {
                    ReportLocked(context, content);
                    return;
                }

                /*
                 * If not locked, keep it locked until it is completely removed.
                 * Prevent overwriting when we drop the lock.
                 */
                content._locked = true;
                content._lockCookie = 0;
            }
            finally {
                content._spinLock.ReleaseWriterLock();
            }


            cacheInternal.Remove(key);
        }

        internal /*public*/ void DoHead(HttpContext context) {
            string  key;
            Object  item;

            key = CreateKey(context.Request);
            item = HttpRuntime.CacheInternal.Get(key);
            if (item == null) {
                ReportNotFound(context);
            }
        }

        /*
         * Unknown Http verb. Responds with "400 Bad Request".
         * Override this method to report different Http code.
         */
        internal /*public*/ void DoUnknown(HttpContext context) {
            context.Response.StatusCode = 400;
        }

        unsafe void OnCacheItemRemoved(String key, Object value, CacheItemRemovedReason reason) {
            CachedContent   content;
            IntPtr          stateItem;

            content = (CachedContent) value;

            content._spinLock.AcquireWriterLock();
            try {
                stateItem = content._stateItem;
                content._content = null;
                content._stateItem = IntPtr.Zero;
            }
            finally {
                content._spinLock.ReleaseWriterLock();
            }
           
            UnsafeNativeMethods.STWNDDeleteStateItem(stateItem);

            switch (reason) {
                case CacheItemRemovedReason.Expired: 
                    IncrementGlobalCounter(GlobalPerfCounter.STATE_SERVER_SESSIONS_TIMED_OUT);
                    break;

                case CacheItemRemovedReason.Removed:
                    IncrementGlobalCounter(GlobalPerfCounter.STATE_SERVER_SESSIONS_ABANDONED);
                    break;

                default:
                    break;    
            }

            DecrementGlobalCounter(GlobalPerfCounter.STATE_SERVER_SESSIONS_ACTIVE);
        }

        private void DecrementGlobalCounter(GlobalPerfCounter counter) {
            if (HttpRuntime.ShutdownInProgress) {
                return;
            }

            PerfCounters.DecrementGlobalCounter(counter);
        }

        private void IncrementGlobalCounter(GlobalPerfCounter counter) {
            if (HttpRuntime.ShutdownInProgress) {
                return;
            }

            PerfCounters.IncrementGlobalCounter(counter);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\state\stateworkerrequest.cs ===
//------------------------------------------------------------------------------
// <copyright file="StateWorkerRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * StateHttpWorkerRequest
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.SessionState {

    using System.Text;
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;   
    using System.Collections;    
    using System.Web;
    using System.Web.Util;

    class StateHttpWorkerRequest : HttpWorkerRequest {
        const int ADDRESS_LENGTH_MAX = 15; /* "xxx.xxx.xxx.xxx" */

        IntPtr                                  _tracker;
        string                                  _uri;              
        UnsafeNativeMethods.StateProtocolExclusive    _exclusive;        
        int                                     _timeout;           
        int                                     _lockCookie;        
        bool                                    _lockCookieExists;  
        int                                     _contentLength;     
        byte[]                                  _content;           


        UnsafeNativeMethods.StateProtocolVerb   _methodIndex;
        string                                  _method;         
                                                                 
        string                                  _remoteAddress;  
        int                                     _remotePort;     
        string                                  _localAddress;   
        int                                     _localPort;      
                                                                 
        StringBuilder                           _status;         
        int                                     _statusCode;     
        StringBuilder                           _headers;        
        IntPtr                           _unmanagedState; 
        bool                                    _sent;           

        internal StateHttpWorkerRequest(
                   IntPtr tracker,
                   UnsafeNativeMethods.StateProtocolVerb methodIndex,
                   string uri,
                   UnsafeNativeMethods.StateProtocolExclusive exclusive,
                   int timeout,
                   int lockCookieExists,
                   int lockCookie,
                   int contentLength,
                   IntPtr content
                   ) {
            _tracker = tracker;
            _methodIndex = methodIndex;
            switch (_methodIndex) {
                case UnsafeNativeMethods.StateProtocolVerb.GET:
                    _method = "GET";
                    break;

                case UnsafeNativeMethods.StateProtocolVerb.PUT:
                    _method = "PUT";
                    break;

                case UnsafeNativeMethods.StateProtocolVerb.HEAD:
                    _method = "HEAD";
                    break;

                case UnsafeNativeMethods.StateProtocolVerb.DELETE:
                    _method = "DELETE";
                    break;

                default:
                    Debug.Assert(false, "Shouldn't get here!");
                    break;
            }

            _uri = uri;
            _exclusive = exclusive;
            _timeout = timeout;
            _lockCookie = lockCookie;
            _lockCookieExists = lockCookieExists != 0;
            _contentLength = contentLength;
            if (contentLength != 0) {
                Debug.Assert(_contentLength == IntPtr.Size);
                if (IntPtr.Size == 4) {
                    uint p = (uint) content;
                    _content = new byte[4] 
                    {
                        (byte) ((p & 0x000000ff)),
                        (byte) ((p & 0x0000ff00) >> 8),
                        (byte) ((p & 0x00ff0000) >> 16),
                        (byte) ((p & 0xff000000) >> 24),
                    };
                }
                else {
                    ulong p = (ulong) content;
                    _content = new byte[8] 
                    {
                        (byte) ((p & 0x00000000000000ff)),
                        (byte) ((p & 0x000000000000ff00) >> 8),
                        (byte) ((p & 0x0000000000ff0000) >> 16),
                        (byte) ((p & 0x00000000ff000000) >> 24),
                        (byte) ((p & 0x000000ff00000000) >> 32),
                        (byte) ((p & 0x0000ff0000000000) >> 40),
                        (byte) ((p & 0x00ff000000000000) >> 48),
                        (byte) ((p & 0xff00000000000000) >> 56),
                    };
                }
            }

            _status  = new StringBuilder(256);
            _headers = new StringBuilder(256);
        }

        public override string GetUriPath() {
            return _uri;
        }

        public override string GetQueryString() {
            return null;
        }

        public override string GetRawUrl() {
            return _uri;
        }

        public override string GetHttpVerbName() {
            return _method;
        }

        public override string GetHttpVersion() {
            return "HTTP/1.0";
        }

        public override string GetRemoteAddress() {
            StringBuilder   buf;

            if (_remoteAddress == null) {
                buf = new StringBuilder(ADDRESS_LENGTH_MAX);
                UnsafeNativeMethods.STWNDGetRemoteAddress(_tracker, buf);
                _remoteAddress = buf.ToString();
            }

            return _remoteAddress;
        }

        public override int GetRemotePort() {
            if (_remotePort == 0) {
                _remotePort = UnsafeNativeMethods.STWNDGetRemotePort(_tracker);
            }

            return _remotePort;
        }

        public override string GetLocalAddress() {
            StringBuilder   buf;

            if (_localAddress == null) {
                buf = new StringBuilder(ADDRESS_LENGTH_MAX);
                UnsafeNativeMethods.STWNDGetLocalAddress(_tracker, buf);
                _localAddress = buf.ToString();
            }

            return _localAddress;
        }

        public override int GetLocalPort() {
            if (_localPort == 0) {
                _localPort = UnsafeNativeMethods.STWNDGetLocalPort(_tracker);
            }

            return _localPort;
        }

        public override byte[] GetPreloadedEntityBody() {
            return _content;
        }


        public override bool IsEntireEntityBodyIsPreloaded() {
            /* Request is always preloaded */
            return true;
        }


        public override string MapPath(string virtualPath) {
            /*
             * Physical and virtual are identical to state server.
             */
            return virtualPath;
        }

        public override int ReadEntityBody(byte[] buffer, int size) {
            /* pretend everything is preloaded */
            return 0;
        }

        public override long GetBytesRead() {
            /* State web doesn't support partial reads */
            throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.Not_supported));
        }

        public override string GetKnownRequestHeader(int index) {
            string s = null;

            switch (index) {
                /* special case important ones */
                case HeaderContentLength:
                    s = (_contentLength).ToString();
                    break;
            }

            return s;
        }

        public override string GetUnknownRequestHeader(string name) {
            string s = null;

            if (name.Equals(StateHeaders.EXCLUSIVE_NAME)) {
                switch (_exclusive) {
                    case UnsafeNativeMethods.StateProtocolExclusive.ACQUIRE:
                        s = StateHeaders.EXCLUSIVE_VALUE_ACQUIRE;
                        break;

                    case UnsafeNativeMethods.StateProtocolExclusive.RELEASE:
                        s = StateHeaders.EXCLUSIVE_VALUE_RELEASE;
                        break;
                }
            }
            else if (name.Equals(StateHeaders.TIMEOUT_NAME)) {
                if (_timeout != -1) {
                    s = (_timeout).ToString();
                }
            }
            else if (name.Equals(StateHeaders.LOCKCOOKIE_NAME)) {
                if (_lockCookieExists) {
                    s = (_lockCookie).ToString();
                }
            }

            return s;
        }

        public override string[][] GetUnknownRequestHeaders() {
            string [][] ret;
            int         c, i;

            c = 0;
            if (_exclusive != (UnsafeNativeMethods.StateProtocolExclusive) (-1)) {
                c++;
            }

            if (_timeout != -1) {
                c++;
            }

            if (_lockCookieExists) {
                c++;
            }

            if (c == 0)
                return null;

            ret = new string[c][];
            i = 0;
            if (_exclusive != (UnsafeNativeMethods.StateProtocolExclusive) (-1)) {
                ret[0] = new string[2];
                ret[0][0] = StateHeaders.EXCLUSIVE_NAME;
                if (_exclusive == UnsafeNativeMethods.StateProtocolExclusive.ACQUIRE) {
                    ret[0][1] = StateHeaders.EXCLUSIVE_VALUE_ACQUIRE;
                }
                else {
                    Debug.Assert(_exclusive == UnsafeNativeMethods.StateProtocolExclusive.RELEASE, "_exclusive == UnsafeNativeMethods.StateProtocolExclusive.RELEASE");
                    ret[0][1] = StateHeaders.EXCLUSIVE_VALUE_RELEASE;
                }

                i++;
            }

            if (_timeout != -1) {
                ret[i] = new string[2];
                ret[i][0] = StateHeaders.TIMEOUT_NAME;
                ret[i][1] = (_timeout).ToString();

                i++;
            }

            if (_lockCookieExists) {
                ret[i] = new string[2];
                ret[i][0] = StateHeaders.LOCKCOOKIE_NAME;
                ret[i][1] = (_lockCookie).ToString();

                i++;
            }

            return ret;
        }

        public override void SendStatus(int statusCode, string statusDescription) {
            Debug.Assert(!_sent);
            _statusCode = statusCode;
            _status.Append((statusCode).ToString() + " " + statusDescription + "\r\n");
        }

        public override void SendKnownResponseHeader(int index, string value) {
            Debug.Assert(!_sent);
            _headers.Append(GetKnownResponseHeaderName(index));
            _headers.Append(": ");
            _headers.Append(value);
            _headers.Append("\r\n");
        }

        public override void SendUnknownResponseHeader(string name, string value) {
            Debug.Assert(!_sent);
            _headers.Append(name);
            _headers.Append(": ");
            _headers.Append(value);
            _headers.Append("\r\n");
        }

        public override void SendCalculatedContentLength(int contentLength) {
            Debug.Assert(!_sent);
            /*
             * Do nothing - we append the content-length in STWNDSendResponse.
             */
        }

        public override bool HeadersSent() {
            return _sent;
        }

        public override bool IsClientConnected() {
            return UnsafeNativeMethods.STWNDIsClientConnected(_tracker);
        }

        public override void CloseConnection() {
            UnsafeNativeMethods.STWNDCloseConnection(_tracker);
        }

        private void SendResponse() {
            if (!_sent) {
                _sent = true;
                UnsafeNativeMethods.STWNDSendResponse(
                                    _tracker, 
                                    _status, 
                                    _status.Length, 
                                    _headers, 
                                    _headers.Length, 
                                    _unmanagedState);
            }
        }

        public override void SendResponseFromMemory(byte[] data, int length) {
            /*
             * The only content besides error message text is the pointer
             * to the state item in unmanaged memory.
             */
            if (_statusCode == 200) {
                Debug.Assert(_unmanagedState == (IntPtr)0, "_unmanagedState == 0");
                Debug.Assert(length == 4, "length == 4");
                Debug.Assert(_methodIndex == UnsafeNativeMethods.StateProtocolVerb.GET, "verb == GET");
                Debug.Assert(_exclusive != UnsafeNativeMethods.StateProtocolExclusive.RELEASE,
                             "correct exclusive method");

                if (IntPtr.Size == 4) {
                    _unmanagedState = (IntPtr)
                        (((int)data[0])       |
                         ((int)data[1] << 8)  |
                         ((int)data[2] << 16) |
                         ((int)data[3] << 24));
                }
                else {
                    _unmanagedState = (IntPtr)
                        (((long)data[0])       |
                         ((long)data[1] << 8)  |
                         ((long)data[2] << 16) |
                         ((long)data[3] << 24) |
                         ((long)data[4] << 32) |
                         ((long)data[5] << 40) |
                         ((long)data[6] << 48) |
                         ((long)data[7] << 56));
                }

                Debug.Assert(_unmanagedState != (IntPtr)0, "_unmanagedState != 0");
            }

            SendResponse();
        }

        public override void SendResponseFromFile(string filename, long offset, long length) {
            /* Not needed by state application */
            throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.Not_supported));
        }

        public override void SendResponseFromFile(IntPtr handle, long offset, long length) {
            /* Not needed by state application */
            throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.Not_supported));
        }

        public override void FlushResponse(bool finalFlush) {
            SendResponse();
        }

        public override void EndOfRequest() {
            SendResponse();
            UnsafeNativeMethods.STWNDEndOfRequest(_tracker);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\baseparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Implements the ASP.NET template parser
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

// Turn this on to do regex profiling
//#define PROFILE_REGEX

// Turn this on to run regex's in interpreted (non-compiled) mode
//#define INTERPRETED_REGEX

namespace System.Web.UI {
using System.Runtime.Serialization.Formatters;
using System.Text;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Reflection;
using System.Globalization;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Web.Caching;
using System.Web.Util;
using System.Web.Compilation;
using System.Web.Configuration;
using HttpException = System.Web.HttpException;
using System.Text.RegularExpressions;
using System.Web.RegularExpressions;
using System.Security.Permissions;


/// <include file='doc\BaseParser.uex' path='docs/doc[@for="BaseParser"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public class BaseParser {

    // The Http context used to resolve paths
    private HttpContext _context;
    internal HttpContext Context {
        get { return _context; }
        set { _context = value; }
    }

    // The directory used for relative path calculations
    internal string _basePhysicalDir;
    private string _baseVirtualDir;
    internal string BaseVirtualDir {
        get { return _baseVirtualDir; }
        set { _baseVirtualDir = value; }
    }

    // The virtual path to the file currently being processed
    private string _currentVirtualPath;
    internal string CurrentVirtualPath {
        get { return _currentVirtualPath; }
        set {
            _currentVirtualPath = value;

            // Can happen in the designer
            if (value == null) return;

            _baseVirtualDir = UrlPath.GetDirectory(value);
        }
    }

    internal readonly static Regex tagRegex = new TagRegex();
    internal readonly static Regex directiveRegex = new DirectiveRegex();
    internal readonly static Regex endtagRegex = new EndTagRegex();
    internal readonly static Regex aspCodeRegex = new AspCodeRegex();
    internal readonly static Regex aspExprRegex = new AspExprRegex();
    internal readonly static Regex databindExprRegex = new DatabindExprRegex();
    internal readonly static Regex commentRegex = new CommentRegex();
    internal readonly static Regex includeRegex = new IncludeRegex();
    internal readonly static Regex textRegex = new TextRegex();

    // Regexes used in DetectSpecialServerTagError
    internal readonly static Regex gtRegex = new GTRegex();
    internal readonly static Regex ltRegex = new LTRegex();
    internal readonly static Regex serverTagsRegex = new ServerTagsRegex();
    internal readonly static Regex runatServerRegex = new RunatServerRegex();


    /*
     * Calls Request.MapPath if the path is absolute.  Otherwise, treat it
     * as relative to the current file.
     */
    internal string MapPath(string path) {
        return MapPath(path, true /*allowCrossAppMapping*/);
    }
    internal string MapPath(string path, bool allowCrossAppMapping) {
        return Context.Request.MapPath(path, BaseVirtualDir, allowCrossAppMapping);
    }

    /*
     * Calls Path.Combine to deal with relative physical paths
     */
    internal string PhysicalPath(string path) {
        return Path.GetFullPath(Path.Combine(_basePhysicalDir, path.Replace('/', '\\')));
    }
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\codeblockbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeBlockBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Handle <%= ... %>, <% ... %> and <%# ... %> blocks
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web.UI {

using System;
using System.IO;

internal class CodeBlockBuilder : ControlBuilder {
    protected CodeBlockType _blockType;
    protected string _content;

    internal CodeBlockBuilder(CodeBlockType blockType, string content,
                           int lineNumber, string sourceFileName) {
        _content = content;
        _blockType = blockType;
        _line = lineNumber;
        _sourceFileName = sourceFileName;
    }

    internal override object BuildObject() {
        return null;
    }

    internal /*public*/ string Content {
        get {
            return _content;
        }

        set {
            _content = value;
        }
    }

    internal /*public*/ CodeBlockType BlockType {
        get { return _blockType;}
    }
}

internal enum CodeBlockType {
    Code,               // <% ... %>
    Expression,         // <%= ... %>
    DataBinding         // <%# ... %>
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\state\sessionstatemodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="SessionStateModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * SessionIdModule
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.SessionState {

    using System;
    using System.Threading;
    using System.Collections;
    using System.Configuration;
    using System.IO;
    using System.Web.Caching;
    using System.Web.Util;
    using System.Web.Configuration;
    using System.Xml;
    using System.Security.Cryptography;
    using System.Data.SqlClient;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Text;
    
    class SessionOnEndTargetWorkItem {
        SessionOnEndTarget  _target;
        HttpSessionState    _sessionState;

        internal SessionOnEndTargetWorkItem(SessionOnEndTarget target, HttpSessionState sessionState) {
            _target = target;
            _sessionState = sessionState;
        }

        internal void RaiseOnEndCallback() {
            _target.RaiseOnEnd(_sessionState);
        }
    }

    /*
     * Calls the OnSessionEnd event. We use an object other than the SessionStateModule
     * because the state of the module is unknown - it could have been disposed
     * when a session ends.
     */
    class SessionOnEndTarget {
        EventHandler    _sessionEndEventHandler;  

        internal SessionOnEndTarget() {
        }

        internal event EventHandler End {
            add{
                _sessionEndEventHandler += value;
            }
            remove {
                _sessionEndEventHandler -= value;
            }
        }

        internal void RaiseOnEnd(HttpSessionState sessionState) {
            Debug.Trace("SessionOnEnd", "Firing OnSessionEnd for " + sessionState.SessionID);

            if (_sessionEndEventHandler != null) {
                HttpApplicationFactory.EndSession(sessionState, this, EventArgs.Empty);
            }
        }

        /*
         * Handle callbacks from the cache for in-proc session state.
         */
        internal void OnCacheItemRemoved(String key, Object value, CacheItemRemovedReason reason) {
            InProcSessionState state;
            SessionDictionary dict;
            String id;

            Debug.Trace("SessionOnEnd", "OnCacheItemRemoved called, reason = " + reason);

            switch (reason) {
                case CacheItemRemovedReason.Expired: 
                    PerfCounters.IncrementCounter(AppPerfCounter.SESSIONS_TIMED_OUT);
                    break;

                case CacheItemRemovedReason.Removed:
                    PerfCounters.IncrementCounter(AppPerfCounter.SESSIONS_ABANDONED);
                    break;

                default:
                    break;    
            }

            PerfCounters.DecrementCounter(AppPerfCounter.SESSIONS_ACTIVE);

            InProcStateClientManager.TraceSessionStats();

            if (_sessionEndEventHandler != null) {
                id = key.Substring(InProcStateClientManager.CACHEKEYPREFIXLENGTH);

                state = (InProcSessionState) value;

                dict = state.dict;
                if (dict == null) {
                    dict = new SessionDictionary();
                }

                HttpSessionState sessionState = new HttpSessionState(
                        id,
                        dict,
                        state.staticObjects,
                        state.timeout,
                        false,
                        state.isCookieless,
                        SessionStateMode.InProc,
                        true);

                if (HttpRuntime.ShutdownInProgress) {
                    // call directly when shutting down
                    RaiseOnEnd(sessionState);
                }
                else {
                    // post via thread pool
                    SessionOnEndTargetWorkItem workItem = new SessionOnEndTargetWorkItem(this, sessionState);
                    WorkItem.PostInternal(new WorkItemCallback(workItem.RaiseOnEndCallback));
                }
            }
        }
    }

    /*
     * The sesssion state module provides session state services
     * for an application.
     */
    /// <include file='doc\SessionStateModule.uex' path='docs/doc[@for="SessionStateModule"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class SessionStateModule : IHttpModule {
        // cookieless vars

        const int COOKIELESS_SESSION_LENGTH = SessionId.ID_LENGTH_CHARS + 2;

        internal const String COOKIELESS_SESSION_KEY = "AspCookielessSession";
        const String  COOKIELESS_SESSION_FILTER_HEADER = "AspFilterSessionId";
        
        static string   s_appPath;
        static int      s_iSessionId;
        static int      s_iRestOfPath;


        internal const String               SESSION_KEY = "AspSession";

        internal const string               SQL_CONNECTION_STRING_DEFAULT = "data source=127.0.0.1;user id=sa;password=";
        internal const string               STATE_CONNECTION_STRING_DEFAULT = "127.0.0.1:42424";
        internal const int                  PORT_DEFAULT = 42424;
        internal const string               SERVER_DEFAULT = "127.0.0.1";
        internal const int                  TIMEOUT_DEFAULT = 20;
        internal const bool                 ISCOOKIELESS_DEFAULT = false;
        internal const SessionStateMode     MODE_DEFAULT = SessionStateMode.InProc;

        const String                        SESSION_COOKIE = "ASP.NET_SessionId";

        const long                          LOCKED_ITEM_POLLING_INTERVAL = 500; // in milliseconds
        static readonly TimeSpan            LOCKED_ITEM_POLLING_DELTA = new TimeSpan(250 * TimeSpan.TicksPerMillisecond);

        static readonly SessionOnEndTarget  s_OnEndTarget = new SessionOnEndTarget();
        static SessionStateSectionHandler.Config s_config;  
        static ReadWriteSpinLock            s_lock;

        static bool                         s_trustLevelInsufficient;

        /* per application vars */
        EventHandler                   _sessionStartEventHandler; 
        IStateClientManager            _mgr;
        Timer                          _timer;
        TimerCallback                  _timerCallback;
        int                            _timerId;
        RandomNumberGenerator          _randgen;


        /* per request data goes in _rq* variables */
        bool                           _acquireCalled;
        bool                           _releaseCalled;
        HttpSessionState               _rqSessionState;    
        String                         _rqId;
        SessionDictionary              _rqDict;
        HttpStaticObjectsCollection    _rqStaticObjects;
        int                            _rqTimeout; /* in minutes */
        int                            _rqStreamLength;
        bool                           _rqIsNewSession;
        bool                           _rqReadonly;
        bool                           _rqInStorage;
        SessionStateItem               _rqItem;
        HttpContext                    _rqContext;
        HttpAsyncResult                _rqAr;
        int                            _rqLockCookie;   // The id of its SessionStateItem ownership
                                                        // If the ownership change hands (e.g. this ownership
                                                        // times out, the LockCookie at the SessionStateItem
                                                        // object will change.
        int                            _rqInCallback;
        DateTime                       _rqLastPollCompleted;
        TimeSpan                       _rqExecutionTimeout;
        bool                           _rqAddedCookie;

        /// <include file='doc\SessionStateModule.uex' path='docs/doc[@for="SessionStateModule.SessionStateModule"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.State.SessionStateModule'/>
        ///       class.
        ///     </para>
        /// </devdoc>
        public SessionStateModule() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }

        internal HttpContext RequestContext {
            get { return _rqContext; }
        }

        static string AppPathModifierFromSessionId(string id) {
            return "(" + id + ")";
        }

        static bool CheckTrustLevel(SessionStateSectionHandler.Config config) {
            switch (config._mode) {
                case SessionStateMode.SQLServer:
                case SessionStateMode.StateServer:
                    return HttpRuntime.HasAspNetHostingPermission(AspNetHostingPermissionLevel.Medium);

                default:
                case SessionStateMode.Off:
                case SessionStateMode.InProc: // In-proc session doesn't require any trust level (part of ASURT 124513)
                    return true;
            }
        }

        void InitModuleFromConfig(
            HttpApplication app, SessionStateSectionHandler.Config config, bool configInit) {

            if (config._mode != SessionStateMode.Off) {
                if (config._isCookieless) {
                    app.BeginRequest += new EventHandler(this.OnBeginRequest);

                    if (configInit) {
                        s_appPath = HttpContext.Current.Request.ApplicationPath;
                        if (s_appPath[s_appPath.Length - 1] != '/') {
                            s_appPath += "/";
                        }

                        s_iSessionId = s_appPath.Length;
                        s_iRestOfPath = s_iSessionId + COOKIELESS_SESSION_LENGTH;
                    }
                }

                app.AddOnAcquireRequestStateAsync(
                        new BeginEventHandler(this.BeginAcquireState), 
                        new EndEventHandler(this.EndAcquireState));
    
                app.ReleaseRequestState += new EventHandler(this.OnReleaseState);
                app.EndRequest += new EventHandler(this.OnEndRequest);

                switch (config._mode) {
                    case SessionStateMode.InProc:
                        _mgr = new InProcStateClientManager();
                        break;

                    case SessionStateMode.StateServer:
                        _mgr = new OutOfProcStateClientManager();
                        break;

                    case SessionStateMode.SQLServer:
                        _mgr = new SqlStateClientManager();
                        break;

                    default:
                    case SessionStateMode.Off:
                        break;
                }

                if (configInit) {
                    _mgr.ConfigInit(config, s_OnEndTarget);
                }

                _mgr.SetStateModule(this);

            }
        }

        /// <include file='doc\SessionStateModule.uex' path='docs/doc[@for="SessionStateModule.Init"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Init(HttpApplication app) {
            if (s_config == null) {
                s_lock.AcquireWriterLock();
                try {
                    if (s_config == null) {
                        SessionStateSectionHandler.Config config = (SessionStateSectionHandler.Config) HttpContext.GetAppConfig("system.web/sessionState");
                        if (config == null) {
                            config = new SessionStateSectionHandler.Config();
                        }
                        
                        Debug.Trace("SessionStateModuleInit",
                                    "Configuration: _mode=" + config._mode +
                                    ";_timeout=" + config._timeout +
                                    ";_isCookieless" + config._isCookieless +
                                    ";_sqlConnectionString" + config._sqlConnectionString +
                                    ";_stateConnectionString" + config._stateConnectionString);

                        InitModuleFromConfig(app, config, true);

                        if (!CheckTrustLevel(config))
                            s_trustLevelInsufficient = true;

                        s_config = config;
                    }
                }
                finally {
                    s_lock.ReleaseWriterLock();
                }
            }
            
            if (_mgr == null) {
                InitModuleFromConfig(app, s_config, false);
            }

            if (s_trustLevelInsufficient) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Session_state_need_higher_trust));
            }
        }

        /// <include file='doc\SessionStateModule.uex' path='docs/doc[@for="SessionStateModule.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dispose() {
            if (_timer != null) {
                ((IDisposable)_timer).Dispose();
            }

            if (_mgr != null) {
                _mgr.Dispose();
            }
        }

        void OnBeginRequest(Object source, EventArgs eventArgs) {
            HttpApplication app;
            HttpContext     context;
            HttpRequest     request; 
            string          path = null;    
            string          header;      
            string          id;      

            Debug.Trace("SessionStateModuleOnBeginRequest", "Beginning SessionStateModule::OnBeginRequestEnter");

            app = (HttpApplication)source;
            context = app.Context;
            request = context.Request;

#if MYWEB
            /*
             * Check whether we're configured for cookieless.
             */
            if (String.Compare(request.Url.Scheme, "myweb", false, CultureInfo.InvariantCulture) == 0) {
                Debug.Trace("SessionStateModuleOnBeginRequest", "Cookieless sessions not supported on MyWeb\nReturning from SessionStateModule::OnBeginRequest");
                return;
            }
#endif

            /*
             * First check whether the ISAPI filter added the session id
             * as a header.
             */
            header = id = request.Headers[COOKIELESS_SESSION_FILTER_HEADER];
            if (id == null) {
                Debug.Trace("SessionStateModuleOnBeginRequest", "Filter did not get cookie id.");

                Debug.Assert(String.Compare(s_appPath, 0, request.ApplicationPath, 0, request.ApplicationPath.Length, true, CultureInfo.InvariantCulture) == 0,
                             "String.Compare(s_appPath, 0, request.ApplicationPath, 0, request.ApplicationPath.Length, true, CultureInfo.InvariantCulture) == 0");

                path = request.Path;

                Debug.Assert(String.Compare(path, 0, s_appPath, 0, s_appPath.Length, true, CultureInfo.InvariantCulture) == 0,
                             "String.Compare(path, 0, s_appPath, 0, s_appPath.Length, true, CultureInfo.InvariantCulture) == 0");

                /*
                 * Get the session id if it is present.
                 */
                if (    path.Length <= s_iRestOfPath 
                        || path[s_iSessionId] != '('    
                        || path[s_iRestOfPath - 1] != ')'
                        || path[s_iRestOfPath] != '/') {
                    Debug.Trace("SessionStateModuleOnBeginRequest", "No cookie on path\nReturning from SessionStateModule::OnBeginRequest");
                    return;
                }

                id = path.Substring(s_iSessionId + 1, SessionId.ID_LENGTH_CHARS);
            }

            id = id.ToLower(CultureInfo.InvariantCulture);
            if (!SessionId.IsLegit(id)) {
                Debug.Trace("SessionStateModuleOnBeginRequest", "No legitimate cookie on path\nReturning from SessionStateModule::OnBeginRequest");
                return;
            }

            context.Items.Add(COOKIELESS_SESSION_KEY, id);
            context.Response.SetAppPathModifier(AppPathModifierFromSessionId(id));

            /*
             * Remove session id from path if the filter didn't get the cookie id.
             */
            if (header == null) {
                if (path.Length <= s_iRestOfPath + 1) {
                    path = path.Substring(0, s_iSessionId);
                }
                else {
                    path = path.Substring(0, s_iSessionId) + path.Substring(s_iRestOfPath + 1);
                }

                context.RewritePath(path);

            }

            Debug.Trace("SessionStateModuleOnBeginRequest", "CookielessSessionModule found SessionId=" + id + 
                        "\nReturning from SessionStateModule::OnBeginRequest");
        }

        void ResetPerRequestFields() {
            _rqSessionState = null;             
            _rqId = null;                       
            _rqDict = null;                     
            _rqStaticObjects = null;            
            _rqTimeout = 0;
            _rqStreamLength = 0;             
            _rqIsNewSession = false;             
            _rqReadonly = false;                 
            _rqInStorage = false;                
            _rqItem = null;
            _rqContext = null;
            _rqAr = null;
            _rqLockCookie = 0;
            _rqInCallback = 0;
            _rqLastPollCompleted = DateTime.MinValue;
            _rqExecutionTimeout = TimeSpan.Zero;
            _rqAddedCookie = false;
        }

        /*
         * Add a OnStart event handler.
         * 
         * @param sessionEventHandler
         */
        /// <include file='doc\SessionStateModule.uex' path='docs/doc[@for="SessionStateModule.Start"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler Start {
            add {
                _sessionStartEventHandler += value;
            }
            remove {
                _sessionStartEventHandler -= value;
            }
        }

        void RaiseOnStart(EventArgs e) {
            if (_sessionStartEventHandler != null) {
                _sessionStartEventHandler(this, e);
            }
        }
        
        /*
         * Fire the OnStart event.
         * 
         * @param e 
         */
        void OnStart(EventArgs e) {
            RaiseOnStart(e);
        }

        /*
         * Add a OnEnd event handler.
         * 
         * @param sessionEventHandler
         */
        /// <include file='doc\SessionStateModule.uex' path='docs/doc[@for="SessionStateModule.End"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler End {
            add {
                s_OnEndTarget.End += value;
            }
            remove {
                s_OnEndTarget.End -= value;
            }
        }

        static HttpCookie CreateSessionCookie(String id) {
            HttpCookie  cookie;

            cookie = new HttpCookie(SESSION_COOKIE, id);
            cookie.Path = "/";
            return cookie;
        }

        String GetSessionId(HttpContext context) {
            String      s = null;
            HttpCookie  cookie;

            if (s_config._isCookieless) {
                s = (String) context.Items[COOKIELESS_SESSION_KEY];
            }
            else {
                cookie = context.Request.Cookies[SESSION_COOKIE];
                if (cookie != null) {
                    s = cookie.Value;
                    if (s != null) {
                        s = s.ToLower(CultureInfo.InvariantCulture);

                        if (!SessionId.IsLegit(s)) {
                            s = null;
                        }
                    }
                }
            }

            return s;
        }

        /*
         * Acquire session state
         */
        IAsyncResult BeginAcquireState(Object source, EventArgs e, AsyncCallback cb, Object extraData) {
            HttpApplication     app;
            IHttpHandler        handler;
            bool                requiresState;
            HttpCookie          cookie;
            bool                isCompleted = true;

            Debug.Trace("SessionStateModuleOnAcquireState", "Beginning SessionStateModule::OnAcquireState");

            _acquireCalled = true;
            _releaseCalled = false;
            ResetPerRequestFields();

            _rqAr = new HttpAsyncResult(cb, extraData);

            app = (HttpApplication)source;
            _rqContext = app.Context;
            _rqExecutionTimeout = _rqContext.Timeout;

            /* Get sessionid */
            _rqId = GetSessionId(_rqContext);
            Debug.Trace("SessionStateModuleOnAcquireState", "Current request id=" + _rqId);

            /* determine if the request requires state at all */
            handler = _rqContext.Handler;
            requiresState = (handler != null && handler is IRequiresSessionState);
            if (!requiresState) {
                if (_rqId == null) {
                    Debug.Trace("SessionStateModuleOnAcquireState", 
                                "Handler does not require state, " +
                                "no session id found." + 
                                "\nReturning from SessionStateModule::OnAcquireState");
                }
                else {
                    Debug.Trace("SessionStateModuleOnAcquireState", 
                                "Handler does not require state, " +
                                "resetting timeout for SessionId=" + _rqId +
                                "\nReturning from SessionStateModule::OnAcquireState");

                    _mgr.ResetTimeout(_rqId);
                }

                _rqAr.Complete(true, null, null);
                return _rqAr;
            }

            /* determine if we need just read-only access */
            _rqReadonly = (handler is IReadOnlySessionState);

            if (_rqId != null) {
                /* get the session state corresponding to this session id */
                isCompleted = GetSessionStateItem();
            }
            else {
                /* if there's no id yet, create it */
                _rqId = SessionId.Create(ref _randgen);

                if (!s_config._isCookieless) {
                    /*
                     * Set the cookie.
                     */
                    Debug.Trace("SessionStateModuleOnAcquireState", 
                                "Creating session cookie, id=" + _rqId);

                    cookie = CreateSessionCookie(_rqId);
                    if (!_rqContext.Response.IsBuffered()) {
                        /* The response is already flushed. We cannot send the id back
                           using the cookie. */
                        throw new HttpException(
                            HttpRuntime.FormatResourceString(SR.Cant_write_session_id_in_cookie_because_response_was_flushed));
                    }
                    _rqContext.Response.Cookies.Add(cookie);
                    _rqAddedCookie = true;
                }
                else {
                    _rqContext.Response.SetAppPathModifier(AppPathModifierFromSessionId(_rqId));

                    /*
                     * Redirect.
                     */
                    Debug.Trace("SessionStateModuleOnAcquireState", 
                                "Redirecting to create cookieless session." + 
                                "\nReturning from SessionStateModule::OnAcquireState");

                    HttpRequest request = _rqContext.Request;
                    string path = request.Path;
                    string qs = request.QueryStringText;
                    if (qs != null && qs.Length > 0) {
                        path = path + "?" + qs;
                    }

                    _rqContext.Response.Redirect(path, false);
                    _rqAr.Complete(true, null, null);
                    IAsyncResult ar = _rqAr;
                    app.CompleteRequest();
                    return ar;
                }
            }

            if (isCompleted) {
                CompleteAcquireState();
                _rqAr.Complete(true, null, null);
            }
                    
            return _rqAr;
        }

        // Called when AcquireState is done.  This function will create a HttpSessionState out
        // of _rqItem, and add it to _rqContext
        void CompleteAcquireState() {
            Debug.Trace("SessionStateModuleOnAcquireState", "Item retrieved=" + (_rqItem != null).ToString());

            if (_rqItem != null) {
                if (_rqItem.dict != null) {
                    _rqDict = _rqItem.dict;
                }
                else {
                    _rqDict = new SessionDictionary();
                }

                _rqStaticObjects = (_rqItem.staticObjects != null) ? _rqItem.staticObjects : _rqContext.Application.SessionStaticObjects.Clone();
                _rqTimeout = _rqItem.timeout;
                _rqIsNewSession = false;
                _rqInStorage = true;
                _rqStreamLength = _rqItem.streamLength;
            }
            else {
                _rqDict = new SessionDictionary();
                _rqStaticObjects = _rqContext.Application.SessionStaticObjects.Clone();
                _rqTimeout = s_config._timeout;
                _rqIsNewSession = true;
                _rqInStorage = false;
            }

            _rqDict.Dirty = false;
            _rqSessionState = new HttpSessionState(
                      _rqId,
                      _rqDict,
                      _rqStaticObjects,
                      _rqTimeout,
                      _rqIsNewSession,
                      s_config._isCookieless,
                      s_config._mode,
                      _rqReadonly);

            _rqContext.Items.Add(SESSION_KEY, _rqSessionState);

            if (_rqIsNewSession) {
                OnStart(EventArgs.Empty);
            }

#if DBG
            if (_rqIsNewSession) {
                Debug.Trace("SessionStateModuleOnAcquireState", "Created new session, SessionId= " + _rqId +
                            "\nReturning from SessionStateModule::OnAcquireState");

            }
            else {
                Debug.Trace("SessionStateModuleOnAcquireState", "Retrieved old session, SessionId= " + _rqId +
                            "\nReturning from SessionStateModule::OnAcquireState");

            }
#endif
        }

        
        bool GetSessionStateItem() {
            bool            isCompleted = true;
            IAsyncResult    ar;

            if (_rqReadonly) {
                ar = _mgr.BeginGet(_rqId, null, null);
            }
            else {
                ar = _mgr.BeginGetExclusive(_rqId, null, null);
            }

            if (!ar.IsCompleted) {
                /*
                 * CONSIDER: add async handling code here.
                 */

                _rqItem = null;
            } else {
                if (_rqReadonly) {
                    _rqItem = _mgr.EndGet(ar);
                }
                else {
                    _rqItem = _mgr.EndGetExclusive(ar);
                }

                if (_rqItem != null) {
                    _rqLockCookie = _rqItem.lockCookie;
                    if (_rqItem.locked) {
                        if (_rqItem.lockAge >= _rqExecutionTimeout) {
                            /* Release the lock on the item, which is held by another thread*/
                            Debug.Trace("SessionStateModuleOnAcquireState", 
                                        "Lock timed out, lockAge=" + _rqItem.lockAge + 
                                        ", id=" + _rqId);

                            _mgr.ReleaseExclusive(_rqId, _rqLockCookie);
                        }

                        Debug.Trace("SessionStateModuleOnAcquireState", 
                                    "Item is locked, will poll, id=" + _rqId);

                        isCompleted = false;
                        PollLockedSession();
                    }
                }
            }

            return isCompleted;
        }

        void PollLockedSession() {
            if (_timerCallback == null) {
                _timerCallback = new TimerCallback(this.PollLockedSessionCallback);
            }

            if (_timer == null) {
                _timerId++;

#if DBG
                if (!Debug.IsTagPresent("Timer") || Debug.IsTagEnabled("Timer"))
#endif
                {
                    _timer = new Timer(_timerCallback, _timerId, LOCKED_ITEM_POLLING_INTERVAL, LOCKED_ITEM_POLLING_INTERVAL);
                }
            }
        }

        void ResetPollTimer() {
            _timerId++;
            if (_timer != null) {
                ((IDisposable)_timer).Dispose();
                _timer = null;
            }
        }

        bool ImpersonateInCallback() {
            if (s_config._mode == SessionStateMode.SQLServer &&
                ((SqlStateClientManager)_mgr).UseIntegratedSecurity) {
                return _rqContext.Impersonation.Start(false, false, true);       
            }
            else {
                return false;
            }
        }

        void RevertInCallback() {
            Debug.Trace("SessionStateModuleOnAcquireState", "Stop impersonation");
            _rqContext.Impersonation.Stop(true);
        }

        void PollLockedSessionCallback(object state) {
            Debug.Trace("SessionStateModuleOnAcquireState", 
                        "Polling callback called from timer, id=" + _rqId);

            /* check whether we are currently in a callback */
            if (Interlocked.CompareExchange(ref _rqInCallback, 1, 0) != 0)
                return;

            try {
                /*
                 * check whether this callback is for the current request,
                 * and whether sufficient time has passed since the last poll
                 * to try again.
                 */
                int timerId = (int) state;
                if (    (timerId == _timerId) && 
                        (DateTime.UtcNow - _rqLastPollCompleted >= LOCKED_ITEM_POLLING_DELTA)) {

                    bool    impersonated = false;

                    try {

                        // This is a callback, and that means we're running in Process account.
                        // If impersonation is used, we have to impersonate in here before
                        // we make a connection.
                        impersonated = ImpersonateInCallback();
                    
                        bool isCompleted = GetSessionStateItem();
                        _rqLastPollCompleted = DateTime.UtcNow;
                        if (isCompleted) {
                            Debug.Assert(_timer != null, "_timer != null");
                            ResetPollTimer();
                            CompleteAcquireState();
                            _rqAr.Complete(false, null, null);
                        }
                    }
                    finally {
                        if (impersonated) {
                            RevertInCallback();
                        }
                    }
                }
            }
            catch (Exception e) {
                ResetPollTimer();
                _rqAr.Complete(false, null, e);
            }
            finally {
                Interlocked.Exchange(ref _rqInCallback, 0);
            }
        }


        void EndAcquireState(IAsyncResult ar) {
            ((HttpAsyncResult)ar).End();
        }

        /*
         * Release session state
         */
        /// <include file='doc\SessionStateModule.uex' path='docs/doc[@for="SessionStateModule.OnReleaseState"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void OnReleaseState(Object source, EventArgs eventArgs) {
            HttpApplication             app;
            HttpContext                 context;
            SessionStateItem            item;
            SessionDictionary           dict;
            HttpStaticObjectsCollection staticObjects;
            bool                        removeCookie = true;

            Debug.Trace("SessionStateOnReleaseState", "Beginning SessionStateModule::OnReleaseState");

            _releaseCalled = true;

            app = (HttpApplication)source;
            context = app.Context;
            if (_rqSessionState != null) {

                Debug.Assert(_rqIsNewSession || _rqInStorage, "_rqIsNewSession || _rqInStorage");

                /*
                 * Remove SessionState from context.
                 */
                context.Items.Remove(SESSION_KEY);

                /*
                 * Don't store untouched new sessions.
                 */

                if (       _sessionStartEventHandler == null 
                           && !_rqDict.Dirty
                           && !_rqInStorage     
                           && _rqIsNewSession
                           && _rqStaticObjects.GetInstanceCount() == 0) {

                    Debug.Trace("SessionStateOnReleaseState", "Not storing unused new session.");
                    Debug.Trace("SessionStateOnReleaseState", "Returning from SessionStateModule::OnReleaseState");
                }
                else if (_rqSessionState.IsAbandoned) {
                    Debug.Trace("SessionStateOnReleaseState", "Removing session due to abandonment, SessionId=" + _rqId);

                    if (_rqInStorage) {
                        removeCookie = false;
                        _mgr.Remove(_rqId, _rqLockCookie);
                    }
                }
                else if (!_rqReadonly) {
                    if (    context.Error == null 
                            && (   _rqDict.Dirty 
                                || _rqStaticObjects.GetInstanceCount() > 0 
                                || _rqTimeout != _rqSessionState.Timeout
                                || _rqIsNewSession)) {
#if DBG
                        if (_rqDict.Dirty) {
                            Debug.Trace("SessionStateOnReleaseState", "Setting new session due dirty dictionary, SessionId=" + _rqId);
                        }
                        else {
                            Debug.Trace("SessionStateOnReleaseState", "Setting new session due to options change, SessionId=" + _rqId +
                                        "\n\t_rq.timeout=" + _rqTimeout.ToString() +
                                        ", config.timeout=" + _rqSessionState.Timeout.ToString());
                        }
#endif

                        dict = _rqDict;
                        if (dict.Count == 0) {
                            dict = null;
                        }

                        staticObjects = _rqStaticObjects;
                        if (staticObjects.GetInstanceCount() == 0) {
                            staticObjects = null;
                        }

                        item = new SessionStateItem(
                                dict, staticObjects, _rqSessionState.Timeout, 
                                s_config._isCookieless, _rqStreamLength, false, 
                                TimeSpan.Zero, _rqLockCookie);

                        removeCookie = false;
                        _mgr.Set(_rqId, item, _rqInStorage);
                    }
                    else {
                        Debug.Trace("SessionStateOnReleaseState", "Checking in session, SessionId=" + _rqId);
                        Debug.Assert(_rqInStorage || context.Error != null, "_rqInStorage || context.Error != null");
                        if (_rqInStorage) {
                            removeCookie = false;
                            _mgr.ReleaseExclusive(_rqId, _rqLockCookie);
                        }
                    }
                }
#if DBG
                else {
                    Debug.Trace("SessionStateOnReleaseState", "Session is read-only, ignoring SessionId=" + _rqId);
                }
#endif

                Debug.Trace("SessionStateOnReleaseState", "Returning from SessionStateModule::OnReleaseState");
            }

            if (removeCookie && _rqAddedCookie && context.Response.IsBuffered()) {
                context.Response.Cookies.RemoveCookie(SESSION_COOKIE);
            }

        }

        /*
         * End of request processing. Possibly does release if skipped due to errors
         */
        /// <include file='doc\SessionStateModule.uex' path='docs/doc[@for="SessionStateModule.OnEndRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void OnEndRequest(Object source, EventArgs eventArgs) {
            HttpApplication app;
            HttpContext context;
            String id;

            Debug.Trace("SessionStateOnEndRequest", "Beginning SessionStateModule::OnEndRequest");

            try {
                if (!_releaseCalled) {
                    if (_acquireCalled) {
                        /*
                         * need to do release here if the request short-circuited due to an error
                         */
                        OnReleaseState(source, eventArgs);
                    }
                    else {
                        /*
                         * 'advise' -- update session timeout                    
                         */
                        app = (HttpApplication)source;
                        context = app.Context;

                        id = GetSessionId(context);
                        if (id != null) {
                            Debug.Trace("SessionStateOnEndRequest", "Resetting timeout for SessionId=" + id);
                            _mgr.ResetTimeout(id);
                        }
#if DBG
                        else {
                            Debug.Trace("SessionStateOnEndRequest", "No session id found.");
                        }
#endif
                    }
                }
            }
            finally {
                _acquireCalled = false;
                _releaseCalled = false;
                ResetPerRequestFields();
            }

            Debug.Trace("SessionStateOnEndRequest", "Returning from SessionStateModule::OnEndRequest");
        }
    }

    /* Session State configuration handler */
    /// <include file='doc\SessionStateModule.uex' path='docs/doc[@for="SessionStateSectionHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal class SessionStateSectionHandler : IConfigurationSectionHandler {
        internal class Config {
            internal readonly string            _sqlConnectionString;
            internal readonly string            _stateConnectionString;
            internal readonly int               _timeout;
            internal readonly bool              _isCookieless;
            internal readonly SessionStateMode  _mode;
            internal readonly string            _configFileName;
            internal readonly int               _sqlLine;
            internal readonly int               _stateLine;
            internal readonly int               _stateNetworkTimeout;

            internal LockedAttributeState _lockedAttributeState;

            internal Config() {
                _mode                   = SessionStateModule.MODE_DEFAULT;
                _timeout                = SessionStateModule.TIMEOUT_DEFAULT;
                _isCookieless           = SessionStateModule.ISCOOKIELESS_DEFAULT;
                _stateConnectionString  = SessionStateModule.STATE_CONNECTION_STRING_DEFAULT;
                _sqlConnectionString    = SessionStateModule.SQL_CONNECTION_STRING_DEFAULT;
            }

            internal Config(
                       SessionStateMode     mode,
                       int                  timeout, 
                       bool                 isCookieless,
                       string               stateConnectionString, 
                       string               sqlConnectionString,
                       string               configFileName,   
                       int                  sqlLine,
                       int                  stateLine,
                       int                  stateNetworkTimeout,
                       LockedAttributeState lockedAttributeState) {
                _mode = mode;
                _timeout = timeout;
                _isCookieless = isCookieless;
                _stateConnectionString = stateConnectionString;
                _sqlConnectionString = sqlConnectionString;
                _configFileName = configFileName; 
                _sqlLine = sqlLine;
                _stateLine = stateLine;
                _stateNetworkTimeout = stateNetworkTimeout;
                _lockedAttributeState = lockedAttributeState;
            }
        }

        internal SessionStateSectionHandler() {
        }

        /// <include file='doc\SessionStateModule.uex' path='docs/doc[@for="SessionStateSectionHandler.Create"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Create(object parent, object configContextObj, XmlNode section) {
            string                configFileName;
            string                sqlConnectionString;            
            string                stateConnectionString;            
            int                   timeout;           
            int                   stateNetworkTimeout;
            SessionStateMode      mode;
            bool                  isCookieless; 
            int                   sqlLine;
            int                   stateLine;
            Config                parentConfig;
            XmlNode               node;
            LockedAttributeState  lockedAttributeState;

            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;

            /*
             * Always load config from application directory, since it
             * is always wrong for subdirs to override.
             */
            HttpConfigurationContext configContext = (HttpConfigurationContext)configContextObj;
            if (HandlerBase.IsPathAtAppLevel(configContext.VirtualPath) == PathLevel.BelowApp) {
                throw new ConfigurationException(
                        HttpRuntime.FormatResourceString(SR.No_Session_Config_In_subdir), 
                        section);
            }

            if (parent == null) {
                parentConfig = new Config();
            }
            else {
                parentConfig = (Config) parent;
            }

            lockedAttributeState = parentConfig._lockedAttributeState;
            if (lockedAttributeState == null) {
                lockedAttributeState = new LockedAttributeState();
            }
            string [] lockableAttributes = new string [] {
                "cookieless", "mode", "sqlConnectionString", 
                "stateConnectionString", "stateNetworkTimeout", "timeout"};
            lockedAttributeState.CheckAndUpdate(section, lockableAttributes);

            // section can have no content
            HandlerBase.CheckForChildNodes(section);

            configFileName = ConfigurationException.GetXmlNodeFilename(section);

            mode = parentConfig._mode;
            int iMode = 0;
            node = HandlerBase.GetAndRemoveEnumAttribute(section, "mode", typeof(SessionStateMode), ref iMode);
            if (node != null) {
                mode = (SessionStateMode)iMode;
            }

            stateConnectionString = parentConfig._stateConnectionString;
            stateLine = parentConfig._stateLine;
            node = HandlerBase.GetAndRemoveStringAttribute(section, "stateConnectionString", ref stateConnectionString);
            if (stateConnectionString != null && (stateConnectionString.StartsWith("registry:") || stateConnectionString.StartsWith("Registry:")))
            {
                StringBuilder str = new StringBuilder(1024);
                UnsafeNativeMethods.GetCredentialFromRegistry(stateConnectionString, str, 1024);
                stateConnectionString = str.ToString();                
            }

            if (node != null) {
                /*
                 * Delay evaluation of a syntax error until we use it,
                 * to be consistent with SQL.
                 */

                stateLine = ConfigurationException.GetXmlNodeLineNumber(node);
            }

            sqlConnectionString = parentConfig._sqlConnectionString;
            sqlLine = parentConfig._sqlLine;
            node = HandlerBase.GetAndRemoveStringAttribute(section, "sqlConnectionString", ref sqlConnectionString);
            if (sqlConnectionString != null && (sqlConnectionString.StartsWith("registry:") || sqlConnectionString.StartsWith("Registry:")))
            {
                StringBuilder str = new StringBuilder(1024);
                UnsafeNativeMethods.GetCredentialFromRegistry(sqlConnectionString, str, 1024);
                sqlConnectionString = str.ToString();                
            }

            if (node != null) {
                /*
                 * Delay evaluation of a syntax error until we use it,
                 * to avoid unnecessarily pulling in the the data classes.
                 */
                sqlLine = ConfigurationException.GetXmlNodeLineNumber(node);
            }

            timeout = parentConfig._timeout;
            HandlerBase.GetAndRemovePositiveIntegerAttribute(section, "timeout", ref timeout);

            isCookieless = parentConfig._isCookieless;
            HandlerBase.GetAndRemoveBooleanAttribute(section, "cookieless", ref isCookieless);

            stateNetworkTimeout = parentConfig._stateNetworkTimeout;
            HandlerBase.GetAndRemovePositiveIntegerAttribute(section, "stateNetworkTimeout", ref stateNetworkTimeout);

            HandlerBase.CheckForUnrecognizedAttributes(section);
                
            Config config = new Config(
                                   mode,
                                   timeout,
                                   isCookieless,
                                   stateConnectionString,
                                   sqlConnectionString,
                                   configFileName,
                                   sqlLine,
                                   stateLine,
                                   stateNetworkTimeout,
                                   lockedAttributeState);

            return config;
        }
    }

    /*
     * Provides and verifies the integrity of a session id.
     * 
     * A session id is a logically 120 bit random number,
     * represented in a string of 20 characters from a 
     * size 64 character set. The session id can be placed
     * in a url without url-encoding.
     */
    internal class SessionId {
        internal const int  NUM_CHARS_IN_ENCODING = 32;
        internal const int  ENCODING_BITS_PER_CHAR = 5;
        internal const int  ID_LENGTH_BITS  = 120;
        internal const int  ID_LENGTH_BYTES = (ID_LENGTH_BITS / 8 );                        // 15
        internal const int  ID_LENGTH_CHARS = (ID_LENGTH_BITS / ENCODING_BITS_PER_CHAR);    // 24


        static char[] s_encoding = new char[NUM_CHARS_IN_ENCODING]
        {
            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
            '0', '1', '2', '3', '4', '5'
        };

        static bool[] s_legalchars;

        static SessionId() {
            int     i;
            char    ch;

            s_legalchars = new bool[128];
            for (i = s_encoding.Length - 1; i >= 0; i--) {
                ch = s_encoding[i];
                s_legalchars[ch] = true;
            }
        }

        private SessionId() {
        }

        internal static bool IsLegit(String s) {
            int     i;
            char    ch;

            if (s == null || s.Length != ID_LENGTH_CHARS)
                return false;

            try {
                i = ID_LENGTH_CHARS;
                while (--i >= 0) {
                    ch = s[i];
                    if (!s_legalchars[ch])
                        return false;
                }

                return true;
            }
            catch (Exception) {
                return false;
            }
        }

        static String Encode(byte[] buffer) {
            int     i, j, k, n;
            char[]  chars = new char[ID_LENGTH_CHARS];

            Debug.Assert(buffer.Length == ID_LENGTH_BYTES);

            j = 0;
            for (i = 0; i < ID_LENGTH_BYTES; i += 5) {
                n =  (int) buffer[i] | 
                     ((int) buffer[i+1] << 8)  | 
                     ((int) buffer[i+2] << 16) |
                     ((int) buffer[i+3] << 24);

                k = (n & 0x0000001F);
                chars[j++] = s_encoding[k];

                k = ((n >> 5) & 0x0000001F);
                chars[j++] = s_encoding[k];

                k = ((n >> 10) & 0x0000001F);
                chars[j++] = s_encoding[k];

                k = ((n >> 15) & 0x0000001F);
                chars[j++] = s_encoding[k];

                k = ((n >> 20) & 0x0000001F);
                chars[j++] = s_encoding[k];

                k = ((n >> 25) & 0x0000001F);
                chars[j++] = s_encoding[k];

                n = (n >> 30) | ((int) buffer[i+4] << 2);

                k = (n & 0x0000001F);
                chars[j++] = s_encoding[k];

                k = ((n >> 5) & 0x0000001F);
                chars[j++] = s_encoding[k];
            }

            Debug.Assert(j == ID_LENGTH_CHARS);

            return new String(chars);
        }

        static internal /*public*/ String Create(ref RandomNumberGenerator randgen) {
            byte[]  buffer;
            String  encoding;

            if (randgen == null) {
                randgen = new RNGCryptoServiceProvider();
            }

            buffer = new byte [15];
            randgen.GetBytes(buffer);
            encoding = Encode(buffer);
            return encoding;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\applicationfileparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="ApplicationFileParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Implements the ASP.NET template parser
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

// Turn this on to do regex profiling
//#define PROFILE_REGEX

// Turn this on to run regex's in interpreted (non-compiled) mode
//#define INTERPRETED_REGEX

namespace System.Web.UI {

using System;
using System.Collections;
using System.IO;
using System.Web.Util;
using System.Web.Compilation;
using Debug=System.Web.Util.Debug;


/*
 * Parser for global.asax files
 */
internal sealed class ApplicationFileParser : TemplateParser {

    internal ApplicationFileParser() {}

    protected override Type CompileIntoType() {
        return ApplicationFileCompiler.CompileApplicationFileType(this);
    }

    /*
     * Compile an .aspx file into an HttpApplication Type
     */
    internal static Type GetCompiledApplicationType(string inputFile, HttpContext context,
        out ApplicationFileParser parser) {

        parser = new ApplicationFileParser();
        parser.CurrentVirtualPath = UrlPath.Combine(context.Request.ApplicationPath,
            HttpApplicationFactory.applicationFileName);
        parser.InputFile = inputFile;
        parser.Context = context;

        // Never use trivial pages for global.asax (ASURT 32420)
        parser._fAlwaysCompile = true;

        ParserCacheItem cacheItem = parser.GetParserCacheItem();
        Debug.Assert(cacheItem.type != null);
        return cacheItem.type;
    }

    internal override Type DefaultBaseType { get { return typeof(System.Web.HttpApplication); } }

    internal override bool FApplicationFile { get { return true; } }

    internal const string defaultDirectiveName = "application";
    internal override string DefaultDirectiveName {
        get { return defaultDirectiveName; }
    }

    internal override void CheckObjectTagScope(ref ObjectTagScope scope) {

        // Map the default scope to AppInstance
        if (scope == ObjectTagScope.Default)
            scope = ObjectTagScope.AppInstance;

        // Check for invalid scopes
        if (scope == ObjectTagScope.Page) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Page_scope_in_global_asax));
        }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\collectionbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="CollectionBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Classes related to complex property support.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.UI {

    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Reflection;

    [AttributeUsage(AttributeTargets.Property)]
    internal sealed class IgnoreUnknownContentAttribute : Attribute {
        internal IgnoreUnknownContentAttribute() {}
    }

    /// <include file='doc\CollectionBuilder.uex' path='docs/doc[@for="CollectionBuilder"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal sealed class CollectionBuilder : ControlBuilder {

        private Type _itemType;
        private bool _ignoreUnknownContent;

        internal CollectionBuilder(bool ignoreUnknownContent) { _ignoreUnknownContent = ignoreUnknownContent; }

        /// <include file='doc\CollectionBuilder.uex' path='docs/doc[@for="CollectionBuilder.Init"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Init(TemplateParser parser, ControlBuilder parentBuilder,
                                  Type type, string tagName, string ID, IDictionary attribs) {
            
            base.Init(parser, parentBuilder, type /*type*/, tagName, ID, attribs);

            // REVIEW: it's a pain to have to re-fetch the Type here, since
            //      we had already done it in GetChildControlType
            // Get the Type of the collection
            PropertyInfo propInfo = parentBuilder.ControlType.GetProperty(
                tagName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.IgnoreCase);
            _ctrlType = propInfo.PropertyType;
            Debug.Assert(_ctrlType != null, "_ctrlType != null");

            // Look for an "item" property on the collection
            propInfo = _ctrlType.GetProperty("Item", BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);

            // If we got one, use it to determine the type of the items
            if (propInfo != null)
                _itemType = propInfo.PropertyType;
        }

        // This code is only executed when used from the desiger
        /// <include file='doc\CollectionBuilder.uex' path='docs/doc[@for="CollectionBuilder.BuildObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal override object BuildObject() {
            return this;
        }

        /// <include file='doc\CollectionBuilder.uex' path='docs/doc[@for="CollectionBuilder.GetChildControlType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Type GetChildControlType(string tagName, IDictionary attribs) {

            Type childType = Parser.MapStringToType(tagName);

            // If possible, check if the item is of the required type
            if (_itemType != null) {

                if (!_itemType.IsAssignableFrom(childType)) {

                    if (_ignoreUnknownContent)
                        return null;

                    throw new HttpException(HttpRuntime.FormatResourceString(
                        SR.Invalid_collection_item_type, new String[] { ControlType.FullName, 
                                                                        _itemType.FullName,
                                                                        tagName,
                                                                        childType.FullName}));
                }

            }

            return childType;
        }

        /// <include file='doc\CollectionBuilder.uex' path='docs/doc[@for="CollectionBuilder.AppendLiteralString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void AppendLiteralString(string s) {

            if (_ignoreUnknownContent)
                return;

            // Don't allow non-whitespace literal content
            if (!Util.IsWhiteSpaceString(s)) {
                throw new HttpException(HttpRuntime.FormatResourceString(
                    SR.Literal_content_not_allowed, _ctrlType.FullName, s.Trim()));
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\batchparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="BatchParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {
using System;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Threading;
using System.Globalization;
using System.Web.Caching;
using System.Web.Util;
using System.Web.Compilation;
using HttpException = System.Web.HttpException;
using Debug=System.Web.Util.Debug;
using System.Text.RegularExpressions;


/*
 * The idea:
 * (1) Create a new batch parser
 * (2) Keep calling AddSource() for each file to be parsed
 * (3) At the end, call GetSourceReferences() for an array of SourceReference's to be manipulated
 */

internal sealed class BatchTemplateParser : BaseParser {
    /// <include file='doc\BatchParser.uex' path='docs/doc[@for="BatchTemplateParser.BatchTemplateParser"]/*' />
    /// <devdoc>
    /// </devdoc>
    internal BatchTemplateParser(HttpContext context) {
        Context = context;
    }

    private ArrayList _sources = new ArrayList();   // List of source file names
    private ArrayList _dependencies = new ArrayList();  // List of ArrayList's of dependency source file names
    private ArrayList _curdeps;                     // List of dependency source file names

    /// <include file='doc\BatchParser.uex' path='docs/doc[@for="BatchTemplateParser.AddSource"]/*' />
    /// <devdoc>
    /// </devdoc>
    internal void AddSource(string filename) {
        _sources.Add(filename);
        _curdeps = new ArrayList();
        _dependencies.Add(_curdeps);

        // Always set the culture to Invariant when parsing (ASURT 99071)
        Thread currentThread = Thread.CurrentThread;
        CultureInfo prevCulture = currentThread.CurrentCulture;
        currentThread.CurrentCulture = CultureInfo.InvariantCulture;

        try {
            try {
                BatchParseFileInternal(filename);
            }
            finally {
                // Restore the previous culture
                currentThread.CurrentCulture = prevCulture;
            }
        }
        catch { throw; }    // Prevent Exception Filter Security Issue (ASURT 122835)
    }

    private void AddPageDependency(string filename) {
        Debug.Trace("Template", "Parsed dependency: " + _sources[_sources.Count - 1] + " depends on " + MapPath(filename));
        _curdeps.Add(MapPath(filename));
    }

    /// <include file='doc\BatchParser.uex' path='docs/doc[@for="BatchTemplateParser.GetSourceReferences"]/*' />
    /// <devdoc>
    /// </devdoc>
    internal SourceReference[] GetSourceReferences() {
        Hashtable curReferences = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

        // Create a SourceReference for each source file and add it the the hashtable
        foreach (string source in _sources)
            curReferences[source] = new SourceReference(source);

        for (int i = 0; i < _dependencies.Count; i++) {
            ArrayList deplist = (ArrayList)_dependencies[i];
            SourceReference sr = (SourceReference)curReferences[((string)_sources[i])];

            // Go through all the dependencies of the current SourceReference
            foreach (string dep in deplist) {

                // If the dependency is itself in the hashtable, add it as a
                // dependency of the SourceReference object.
                SourceReference srdep = (SourceReference)curReferences[dep];
                if (srdep != null)
                    sr.AddDependency(srdep);
            }
        }

        SourceReference[] result = new SourceReference[curReferences.Count];

        {
            int k;
            IDictionaryEnumerator en;

            for (en = curReferences.GetEnumerator(), k = 0; en.MoveNext(); k++) {
                result[k] = (SourceReference)en.Value;
            }
        }

        return result;
    }

    private void BatchParseFileInternal(string filename) {
        string text = Util.StringFromFile(filename, Context);
        _basePhysicalDir = System.IO.Path.GetDirectoryName(filename);

        int textPos = 0;

        for (;;) {
            Match match;

            // 1: scan for text up to the next tag.

            if ((match = textRegex.Match(text, textPos)).Success) {
                textPos = match.Index + match.Length;
            }

            // we might be done now

            if (textPos == text.Length)
                break;

            // 2: handle constructs that start with <

            // Check to see if it's a directive (i.e. <%@ %> block)

            if ((match = directiveRegex.Match(text, textPos)).Success) {
                ProcessDirective(match);
                textPos = match.Index + match.Length;
            }

            else if ((match = includeRegex.Match(text, textPos)).Success) {
                // do later
                // ProcessBatchServerInclude(match);
                textPos = match.Index + match.Length;
            }

            else if ((match = commentRegex.Match(text, textPos)).Success) {
                // Just skip it
                textPos = match.Index + match.Length;
            }

            else {
                return;
            }

            // we might be done now
            if (textPos == text.Length)
                return;
        }
    }

    /*
     * Process a <%@ %> block
     */
    private void ProcessDirective(Match match) {
        // Get all the directives into a bag
        IDictionary directive = CollectionsUtil.CreateCaseInsensitiveSortedList();
        string directiveName = ProcessAttributes(match, directive);

        // Check for the main directive, which is "page" for an aspx.
        if (directiveName == null ||
            string.Compare(directiveName, "page", true, CultureInfo.InvariantCulture) == 0 ||
            string.Compare(directiveName, "control", true, CultureInfo.InvariantCulture) == 0) {
            // A "src" attribute is equivalent to an imported source file
            string src = Util.GetAndRemoveNonEmptyAttribute(directive, "src");
            if (src != null)
                AddPageDependency(src);
        }
        else if (string.Compare(directiveName, "register", true, CultureInfo.InvariantCulture) == 0) {

            string src = Util.GetAndRemoveNonEmptyAttribute(directive, "src");

            if (src != null) {
                AddPageDependency(src);
            }
        }
        else if (string.Compare(directiveName, "reference", true, CultureInfo.InvariantCulture) == 0) {

            string page = Util.GetAndRemoveNonEmptyNoSpaceAttribute(directive, "page");
            if (page != null)
                AddPageDependency(page);

            string control = Util.GetAndRemoveNonEmptyNoSpaceAttribute(directive, "control");
            if (control != null)
                AddPageDependency(control);
        }
        else if (string.Compare(directiveName, "assembly", true, CultureInfo.InvariantCulture) == 0) {

            string src = Util.GetAndRemoveNonEmptyAttribute(directive, "src");
            if (src != null)
                AddPageDependency(src);
        }
    }

    /*
     * Adds attributes and their values to the attribs
     */
    private string ProcessAttributes(Match match, IDictionary attribs) {
        string ret = null;
        CaptureCollection attrnames = match.Groups["attrname"].Captures;
        CaptureCollection attrvalues = match.Groups["attrval"].Captures;
        CaptureCollection equalsign = match.Groups["equal"].Captures;

        for (int i = 0; i < attrnames.Count; i++) {
            string attribName = attrnames[i].ToString();
            string attribValue = attrvalues[i].ToString();
            bool fHasEqual = (equalsign[i].ToString().Length > 0);

            if (attribName != null && !fHasEqual && ret == null) {
                ret = attribName;
                continue;
            }

            try {
                if (attribs != null)
                    attribs.Add(attribName, attribValue);
            }
            catch (ArgumentException) {}
        }

        return ret;
    }
}


/// <include file='doc\BatchParser.uex' path='docs/doc[@for="BatchDependencyWalker"]/*' />
/// <internalonly/>
/// <devdoc>
/// </devdoc>
internal sealed class BatchDependencyWalker {
    private BatchDependencyWalker() {}

    internal static SourceReference[][] Split(SourceReference[] input) {
        // First phase: compute levels in the dependency tree

        int totaldepth = 0;
        Hashtable depth = new Hashtable();
        ArrayList stack = new ArrayList();

        // compute depths
        for (int i = 0; i < input.Length; i++) {
            stack.Add(input[i]);

            while (stack.Count > 0) {
                SourceReference curnode = (SourceReference)stack[stack.Count - 1];

                bool recurse = false;
                int maxdepth = 0;

                for (IEnumerator en = curnode.Dependencies.GetEnumerator(); en.MoveNext(); ) {
                    SourceReference child = (SourceReference) en.Current;

                    if (depth.ContainsKey(child)) {
                        if (maxdepth <= (int)depth[child])
                            maxdepth = (int)depth[child] + 1;
                        else if ((int)depth[child] == -1)
                            throw new HttpException(child.Filename + " has a circular reference!");
                    }
                    else {
                        recurse = true;
                        stack.Add(child);
                    }
                }

                if (recurse)
                    depth[curnode] = -1; // being computed;
                else {
                    stack.RemoveAt(stack.Count - 1);
                    depth[curnode] = maxdepth;
                    if (totaldepth <= maxdepth)
                        totaldepth = maxdepth + 1;
                }
            }
        }

        // drop into buckets by depth
        ArrayList[] codeLevel = new ArrayList[totaldepth];

        for (IDictionaryEnumerator en = (IDictionaryEnumerator)depth.GetEnumerator(); en.MoveNext();) {
            int level = (int)en.Value;

            if (codeLevel[level] == null)
                codeLevel[level] = new ArrayList();

            codeLevel[level].Add(en.Key);
        }

        // return buckets as array of arrays.
        SourceReference[][] result = new SourceReference[totaldepth][];

        for (int i = 0; i < totaldepth; i++) {
            result[i] = (SourceReference[])codeLevel[i].ToArray(typeof(SourceReference));
        }

        return result;
    }
}

/// <include file='doc\BatchParser.uex' path='docs/doc[@for="SourceReference"]/*' />
/// <internalonly/>
/// <devdoc>
/// </devdoc>
internal sealed class SourceReference {
    /// <include file='doc\BatchParser.uex' path='docs/doc[@for="SourceReference.SourceReference"]/*' />
    /// <devdoc>
    /// </devdoc>
    internal SourceReference(string filename) {
        _filename = filename;
    }

    /// <include file='doc\BatchParser.uex' path='docs/doc[@for="SourceReference.Filename"]/*' />
    /// <devdoc>
    /// </devdoc>
    internal string Filename {
        get {
            return _filename;
        }
    }

    private string _filename;

    /// <include file='doc\BatchParser.uex' path='docs/doc[@for="SourceReference.Dependencies"]/*' />
    /// <devdoc>
    /// </devdoc>
    internal ICollection Dependencies {
        get {
            return _dependencies.Values;
        }
    }

    /// <include file='doc\BatchParser.uex' path='docs/doc[@for="SourceReference.AddDependency"]/*' />
    /// <devdoc>
    /// </devdoc>
    internal void AddDependency(SourceReference dep) {
        Debug.Trace("Template", "Discovered dependency: " + _filename + " depends on " + dep.Filename);
        _dependencies[dep] = dep;
    }

    private IDictionary _dependencies = new Hashtable();

}

#if DAVIDEBB_TEST

internal abstract class DependencyParser : BaseParser {

    private string _filename;
    private IDictionary _physicalPathDependencies;  // String keys, null values

    internal void Init(HttpContext context, string filename) {
        Context = context;
        _filename = filename;
    }

    internal void GetPhysicalPathDependencies(IDictionary physicalPathDependencies) {

        _physicalPathDependencies = physicalPathDependencies;

        // Always set the culture to Invariant when parsing (ASURT 99071)
        Thread currentThread = Thread.CurrentThread;
        CultureInfo prevCulture = currentThread.CurrentCulture;
        currentThread.CurrentCulture = CultureInfo.InvariantCulture;

        try {
            try {
                ParseFileInternal(_filename);
            }
            finally {
                // Restore the previous culture
                currentThread.CurrentCulture = prevCulture;
            }
        }
        catch { throw; }    // Prevent Exception Filter Security Issue (ASURT 122835)
    }

    private void AddDependency(string filename) {
        Debug.Trace("Template", "Parsed dependency: " + _filename + " depends on " + MapPath(filename));
        _physicalPathDependencies[MapPath(filename)] = null;
    }

    internal abstract string DefaultDirectiveName { get; }

    private void ParseFileInternal(string filename) {
        string text = Util.StringFromFile(filename, Context);
        _basePhysicalDir = System.IO.Path.GetDirectoryName(filename);

        int textPos = 0;

        for (;;) {
            Match match;

            // 1: scan for text up to the next tag.

            if ((match = textRegex.Match(text, textPos)).Success) {
                textPos = match.Index + match.Length;
            }

            // we might be done now

            if (textPos == text.Length)
                break;

            // 2: handle constructs that start with <

            // Check to see if it's a directive (i.e. <%@ %> block)

            if ((match = directiveRegex.Match(text, textPos)).Success) {
                ProcessDirective(match);
                textPos = match.Index + match.Length;
            }

            else if ((match = includeRegex.Match(text, textPos)).Success) {
                // do later
                // ProcessBatchServerInclude(match);
                textPos = match.Index + match.Length;
            }

            else if ((match = commentRegex.Match(text, textPos)).Success) {
                // Just skip it
                textPos = match.Index + match.Length;
            }

            else {
                return;
            }

            // we might be done now
            if (textPos == text.Length)
                return;
        }
    }

    /*
     * Process a <%@ %> block
     */
    private void ProcessDirective(Match match) {
        // Get all the directives into a bag
        IDictionary directive = CollectionsUtil.CreateCaseInsensitiveSortedList();
        string directiveName = ProcessAttributes(match, directive);

        // Check for the main directive (e.g. "page" for an aspx)
        if (directiveName == null ||
            string.Compare(directiveName, DefaultDirectiveName, true, CultureInfo.InvariantCulture) == 0 ) {
            // A "src" attribute is equivalent to an imported source file
            string src = Util.GetAndRemoveNonEmptyAttribute(directive, "src");
            if (src != null)
                AddDependency(src);
        }
        else if (string.Compare(directiveName, "register", true, CultureInfo.InvariantCulture) == 0) {

            string src = Util.GetAndRemoveNonEmptyAttribute(directive, "src");

            if (src != null) {
                AddDependency(src);
            }
        }
        else if (string.Compare(directiveName, "reference", true, CultureInfo.InvariantCulture) == 0) {

            string page = Util.GetAndRemoveNonEmptyNoSpaceAttribute(directive, "page");
            if (page != null)
                AddDependency(page);

            string control = Util.GetAndRemoveNonEmptyNoSpaceAttribute(directive, "control");
            if (control != null)
                AddDependency(control);
        }
        else if (string.Compare(directiveName, "assembly", true, CultureInfo.InvariantCulture) == 0) {

            string src = Util.GetAndRemoveNonEmptyAttribute(directive, "src");
            if (src != null)
                AddDependency(src);
        }
    }

    /*
     * Adds attributes and their values to the attribs
     */
    private string ProcessAttributes(Match match, IDictionary attribs) {
        string ret = null;
        CaptureCollection attrnames = match.Groups["attrname"].Captures;
        CaptureCollection attrvalues = match.Groups["attrval"].Captures;
        CaptureCollection equalsign = match.Groups["equal"].Captures;

        for (int i = 0; i < attrnames.Count; i++) {
            string attribName = attrnames[i].ToString();
            string attribValue = attrvalues[i].ToString();
            bool fHasEqual = (equalsign[i].ToString().Length > 0);

            if (attribName != null && !fHasEqual && ret == null) {
                ret = attribName;
                continue;
            }

            try {
                if (attribs != null)
                    attribs.Add(attribName, attribValue);
            }
            catch (ArgumentException) {}
        }

        return ret;
    }
}


internal abstract class TemplateControlDependencyParser : DependencyParser {
}

internal class PageDependencyParser : TemplateControlDependencyParser {
    internal override string DefaultDirectiveName {
        get { return PageParser.defaultDirectiveName; }
    }
}

internal class UserControlDependencyParser : TemplateControlDependencyParser {
    internal override string DefaultDirectiveName {
        get { return UserControlParser.defaultDirectiveName; }
    }
}


#if OLD
internal abstract class CompilableFile {

    private HttpContext _context;
    private IDictionary _dependentCompilableFiles = new Hashtable();
    private string _filename;

    public void Init(HttpContext context, string filename) {
        _context = context;
        _filename = filename;
    }

    internal string FileName { get { return _filename; } }

    internal ICollection FileNameReferences {
        get {
            DependencyParser parser = CreateDependencyParser();
            parser.Init(_context, _filename);
            return parser.GetFileNameReferences();
        }
    }

    internal ICollection CompilableFileReferences {
        get { return _dependentCompilableFiles.Keys; }
    }

    internal void AddDependentCompilableFile(CompilableFile dependentCf) {
        _dependentCompilableFiles[dependentCf] = null;
    }

    internal abstract DependencyParser CreateDependencyParser();
}

internal abstract class TemplateControlCompilableFile : CompilableFile {
}

internal class PageCompilableFile : TemplateControlCompilableFile {
    internal override DependencyParser CreateDependencyParser() {
        return new PageDependencyParser();
    }
}

internal class UserControlCompilableFile : TemplateControlCompilableFile {
    internal override DependencyParser CreateDependencyParser() {
        return new UserControlDependencyParser();
    }
}

internal class QQQ {

    private HttpContext _context;

    private CompilableFile GetCompilableFileFromExtension(string filename) {
        string ext = Path.GetExtension(filename);

        CompilableFile cf = null;

        switch (ext) {
        case ".aspx":
            cf = new PageCompilableFile();
            break;

        case ".ascx":
            cf = new UserControlCompilableFile();
            break;
        }

        if (cf != null)
            cf.Init(_context, filename);

        return cf;
    }

    internal void foo(string virtualDir, HttpContext context) {
        _context = context;

        Hashtable compilableFiles = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

        string directory = _context.Request.MapPath(virtualDir) + "\\";

        UnsafeNativeMethods.WIN32_FIND_DATA wfd;
        IntPtr hFindFile = UnsafeNativeMethods.FindFirstFile(directory + "*.*", out wfd);

        // No files: do nothing
        if (hFindFile == new IntPtr(-1))
            return;

        try {
            // Go through all the files in the codegen dir. We use the Win32 native API's
            // directly for perf and memory usage reason (ASURT 97791)
            for (bool more=true; more; more=UnsafeNativeMethods.FindNextFile(hFindFile, out wfd)) {

                // Skip directories
                if ((wfd.dwFileAttributes & UnsafeNativeMethods.FILE_ATTRIBUTE_DIRECTORY) != 0)
                    continue;

                string filename = directory + wfd.cFileName;
                CompilableFile cf = GetCompilableFileFromExtension(filename);

                // Ignore unknown extensions
                if (cf == null)
                    continue;

                compilableFiles[filename] = cf;
            }
        }
        finally {
            UnsafeNativeMethods.FindClose(hFindFile);
        }

        foreach (CompilableFile cf in compilableFiles.Values) {
            ICollection references = cf.FileNameReferences;

            foreach (string reference in references) {
                CompilableFile dependentCf = (CompilableFile) compilableFiles[reference];

                if (dependentCf != null)
                    cf.AddDependentCompilableFile(dependentCf);
            }
        }

        CompilableFile[][] buckets = Split(compilableFiles);

#if DBG
        for (int i = 0; i < buckets.Length; i++) {
            CompilableFile[] bucket = buckets[i];
            Debug.Trace("Batching", "");
            Debug.Trace("Batching", "Bucket " + i + " contains " + bucket.Length + " files");

            for (int j = 0; j < bucket.Length; j++)
                Debug.Trace("Batching", bucket[j].FileName);
        }
#endif
    }

    internal static CompilableFile[][] Split(IDictionary compilableFiles) {
        // First phase: compute levels in the dependency tree

        int totaldepth = 0;
        Hashtable depth = new Hashtable();
        Stack stack = new Stack();

        // compute depths
        foreach (CompilableFile cf in compilableFiles.Values) {
            stack.Push(cf);

            while (stack.Count > 0) {
                CompilableFile curnode = (CompilableFile)stack.Peek();

                bool recurse = false;
                int maxdepth = 0;

                foreach (CompilableFile child in curnode.CompilableFileReferences) {

                    if (depth.ContainsKey(child)) {
                        if (maxdepth <= (int)depth[child])
                            maxdepth = (int)depth[child] + 1;
                        else if ((int)depth[child] == -1)
                            throw new HttpException(child.FileName + " has a circular reference!");
                    }
                    else {
                        recurse = true;
                        stack.Push(child);
                    }
                }

                if (recurse)
                    depth[curnode] = -1; // being computed;
                else {
                    stack.Pop();
                    depth[curnode] = maxdepth;
                    if (totaldepth <= maxdepth)
                        totaldepth = maxdepth + 1;
                }
            }
        }

        // drop into buckets by depth
        ArrayList[] codeLevel = new ArrayList[totaldepth];

        for (IDictionaryEnumerator en = (IDictionaryEnumerator)depth.GetEnumerator(); en.MoveNext();) {
            int level = (int)en.Value;

            if (codeLevel[level] == null)
                codeLevel[level] = new ArrayList();

            codeLevel[level].Add(en.Key);
        }

        // return buckets as array of arrays.
        CompilableFile[][] result = new CompilableFile[totaldepth][];

        for (int i = 0; i < totaldepth; i++) {
            result[i] = (CompilableFile[])codeLevel[i].ToArray(typeof(CompilableFile));
        }

        return result;
    }

#if DBG
    public static void Test(string virtualDir, HttpContext context) {
        QQQ qqq = new QQQ();
        qqq.foo(virtualDir, context);
    }
#endif
}

#endif // OLD

#endif // DAVIDEBB_TEST

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\constructorneedstagattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConstructorNeedsTagAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Web.UI {

    using System;
    using System.ComponentModel;
    using System.Security.Permissions;

    /// <include file='doc\ConstructorNeedsTagAttribute.uex' path='docs/doc[@for="ConstructorNeedsTagAttribute"]/*' />
    /// <devdoc>
    ///    <para> Allows a control to specify that it needs a
    ///       tag name in its constructor.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class ConstructorNeedsTagAttribute: Attribute {
        bool needsTag = false;

        /// <include file='doc\ConstructorNeedsTagAttribute.uex' path='docs/doc[@for="ConstructorNeedsTagAttribute.ConstructorNeedsTagAttribute"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.ConstructorNeedsTagAttribute'/> class.</para>
        /// </devdoc>
        public ConstructorNeedsTagAttribute() {
        }

        /// <include file='doc\ConstructorNeedsTagAttribute.uex' path='docs/doc[@for="ConstructorNeedsTagAttribute.ConstructorNeedsTagAttribute1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.ConstructorNeedsTagAttribute'/> class.</para>
        /// </devdoc>
        public ConstructorNeedsTagAttribute(bool needsTag) {
            this.needsTag = needsTag;
        }

        /// <include file='doc\ConstructorNeedsTagAttribute.uex' path='docs/doc[@for="ConstructorNeedsTagAttribute.NeedsTag"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether a control needs a tag in its contstructor. This property is read-only.</para>
        /// </devdoc>
        public bool NeedsTag {
            get {
                return needsTag;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\controlbuilderattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlBuilderAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Web.UI {

    using System;
    using System.ComponentModel;
    using System.Security.Permissions;

    /// <include file='doc\ControlBuilderAttribute.uex' path='docs/doc[@for="ControlBuilderAttribute"]/*' />
    /// <devdoc>
    /// <para>Allows a control to specify a custom <see cref='System.Web.UI.ControlBuilder'/> object
    ///    for building that control within the ASP.NET parser.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class ControlBuilderAttribute : Attribute {

        /// <include file='doc\ControlBuilderAttribute.uex' path='docs/doc[@for="ControlBuilderAttribute.Default"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>The default <see cref='System.Web.UI.ControlBuilderAttribute'/> object is a 
        /// <see langword='null'/> builder. This field is read-only.</para>
        /// </devdoc>
        public static readonly ControlBuilderAttribute Default = new ControlBuilderAttribute(null);

        private Type builderType = null;


        /// <include file='doc\ControlBuilderAttribute.uex' path='docs/doc[@for="ControlBuilderAttribute.ControlBuilderAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        public ControlBuilderAttribute(Type builderType) {
            this.builderType = builderType;
        }

        /// <include file='doc\ControlBuilderAttribute.uex' path='docs/doc[@for="ControlBuilderAttribute.BuilderType"]/*' />
        /// <devdoc>
        ///    <para> Indicates XXX. This property is read-only.</para>
        /// </devdoc>
        public Type BuilderType {
            get {
                return builderType;
            }
        }


        /// <include file='doc\ControlBuilderAttribute.uex' path='docs/doc[@for="ControlBuilderAttribute.GetHashCode"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\ControlBuilderAttribute.uex' path='docs/doc[@for="ControlBuilderAttribute.Equals"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }
            if ((obj != null) && (obj is ControlBuilderAttribute)) {
                return((ControlBuilderAttribute)obj).BuilderType == builderType;
            }

            return false;
        }

        /// <include file='doc\ControlBuilderAttribute.uex' path='docs/doc[@for="ControlBuilderAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override bool IsDefaultAttribute() {
            return this.Equals(Default);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\controlcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.UI {
    using System.Runtime.InteropServices;

    using System;
    using System.Collections;
    using System.Security.Permissions;

    /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The <see langword='ControlCollection'/> class provides a
    ///       collection container that enables a control to maintain a
    ///       list of its child controls.
    ///
    ///       For performance reasons, this is internally strongly typed. Most implementation is copied from
    ///       ArrayList.cs
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ControlCollection : ICollection {
        private Control _owner;
        private Control[] _controls;
        private int _size;
        private int _version;
        private string _readOnlyErrorMsg = null;

        private const int _defaultCapacity = 5;
        private const int _growthFactor = 4;

        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.ControlCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ControlCollection(Control owner) {
            if (owner == null) {
                throw new ArgumentNullException("owner");
            }
            _owner = owner;
        }

        /*
         * Adds a child control to this control.
         */
        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.Add"]/*' />
        /// <devdoc>
        /// <para>Adds the specified <see cref='System.Web.UI.Control'/> object
        ///    to the collection. The new control is logically added to the end of an ordinal
        ///    index array.</para>
        /// </devdoc>
        public virtual void Add(Control child) {
            // Note: duplication of code with AddAt is deliberate for performance reasons. This is the more common form of the call.

            // Check arguments
            if (child == null)
                throw new ArgumentNullException("child");

            if (_readOnlyErrorMsg != null) {
                throw new HttpException(HttpRuntime.FormatResourceString(_readOnlyErrorMsg ));
            }

            // Make sure we have room
            if (_controls == null) {
                _controls = new Control[_defaultCapacity];
            }
            else if (_size >= _controls.Length) {
                Control[] newArray = new Control[_controls.Length * _growthFactor ];
                Array.Copy(_controls, newArray, _controls.Length);
                _controls = newArray;
            }

            // Add the control
            int index = _size;
            _controls[index] = child;
            _size++;
            _version++;

            // Notify Owner
            _owner.AddedControl(child, index);
        }

        /*
         * Adds a child control to this control at a certain index
         */
        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.AddAt"]/*' />
        /// <devdoc>
        /// <para>Adds the specified <see cref='System.Web.UI.Control'/> object to the collection. The new control is added
        ///    to the array at the specified index location.</para>
        /// </devdoc>
        public virtual void AddAt(int index, Control child) {

            // For compatability, we must support this.
            if (index == -1) {
                Add(child);
                return;
            }

            // Check Arguments
            if (child == null) {
                throw new ArgumentNullException("child");
            }
            if (index < 0 || index > _size) {
                throw new ArgumentOutOfRangeException("index");
            }

            if (_readOnlyErrorMsg != null) {
                throw new HttpException(HttpRuntime.FormatResourceString(_readOnlyErrorMsg ));
            }

            // Make sure we have room
            if (_controls == null) {
                _controls = new Control[_defaultCapacity];
            }
            else if (_size >= _controls.Length) {
                Control[] newArray = new Control[_controls.Length * _growthFactor ];
                Array.Copy(_controls, newArray, _controls.Length);
                _controls = newArray;
            }

            // Insert the control
            if (index < _size) {
                Array.Copy(_controls, index, _controls, index + 1, _size - index);
            }
            _controls[index] = child;
            _size++;
            _version++;

            _owner.AddedControl(child, index);
        }

        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes all controls in the collection.
        ///    </para>
        /// </devdoc>
        public virtual void Clear() {
            if (_controls != null) {
                // ASURT 123965: This used to call RemoveAt(0), which was an n^2 operation.  Removing from the end of the array now.
                for (int i = _size - 1; i >= 0; i--) {
                    RemoveAt(i);
                }

                if (_owner is INamingContainer)
                    _owner.ClearNamingContainer();
            }
        }

        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the collection contains a specific object
        ///    </para>
        /// </devdoc>
        public virtual bool Contains(Control c) {
            if (_controls == null || c == null)
                return false;

            for (int i = 0; i < _size; i++) {
                if (Object.ReferenceEquals(c, _controls[i])) {
                    return true;
                }
            }
            return false;
        }

        /*
         * Retrieves the number of child controls.
         */
        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of child controls in the collection.
        ///    </para>
        /// </devdoc>
        public int Count {
            get {
                return _size;
                }
                }

        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.Owner"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected Control Owner {
            get {
                return _owner;
            }
        }

        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the index of a specified <see cref='System.Web.UI.Control'/>
        ///       object
        ///       in the collection.
        ///    </para>
        /// </devdoc>
        public virtual int IndexOf(Control value) {
            if (_controls == null)
                return -1;

            return Array.IndexOf(_controls, value, 0, _size);
            }

        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an enumerator of all controls in the collection.
        ///    </para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return new ControlCollectionEnumerator(this);
        }

        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>Copies the specified child control to a location in the collection.</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            if (_controls == null)
                return;
            if ((array != null) && (array.Rank != 1))
                throw new HttpException(HttpRuntime.FormatResourceString(SR.InvalidArgumentValue, "array"));

            Array.Copy(_controls, 0, array, index, _size);
        }

        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>Gets the parent control of the control collection.</para>
        /// </devdoc>
        public Object SyncRoot {
            get { return this;}
        }

        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the collection is read-only.</para>
        /// </devdoc>
        public bool IsReadOnly {
            get { return (_readOnlyErrorMsg != null); }
        }

        // Setting an error message makes the control collection read only.  If the user tries to modify
        // the collection, we look up the error message in the resources and throw an exception.
        // Set errorMsg to null to make the collection not read only.
        internal string SetCollectionReadOnly(string errorMsg) {
            string olderror = _readOnlyErrorMsg;
            _readOnlyErrorMsg = errorMsg;
            return olderror;
        }

        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para> Gets a value indicating whether the collection
        ///       is synchronized.</para>
        /// </devdoc>
        public bool IsSynchronized {
            get { return false;}
        }


        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a reference to an ordinal-indexed control in the collection.
        ///    </para>
        /// </devdoc>
        virtual public Control this[int index]
        {
            get {
                if (index < 0 || index >= _size) {
                    throw new ArgumentOutOfRangeException("index");
                }
                return _controls[index];
            }
        }

        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the specified child control from the collection.
        ///    </para>
        /// </devdoc>
        public virtual void RemoveAt(int index) {

            if (_readOnlyErrorMsg != null) {
                throw new HttpException(HttpRuntime.FormatResourceString(_readOnlyErrorMsg ));
            }

            Control child = this[index];
            _size--;
            if (index < _size) {
                Array.Copy(_controls, index + 1, _controls, index, _size - index);
            }
            _controls[_size] = null;
            _version++;
            _owner.RemovedControl(child);

        }

        /// <include file='doc\ControlCollection.uex' path='docs/doc[@for="ControlCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the specified
        ///       child control object from the collection.
        ///    </para>
        /// </devdoc>
        public virtual void Remove(Control value) {
            int index = IndexOf(value);
            if (index >=0)
                RemoveAt(index);
        }

        // This is a copy of the ArrayListEnumeratorSimple in ArrayList.cs
        private class ControlCollectionEnumerator : IEnumerator
        {
            private ControlCollection list;
            private int index;
            private int version;
            private Control currentElement;

            internal ControlCollectionEnumerator(ControlCollection list) {
                this.list = list;
                this.index = -1;
                version = list._version;
            }

            public bool MoveNext() {
                if (index < (list.Count-1)) {
                    if (version != list._version)
                        throw new InvalidOperationException(SR.GetString(SR.ListEnumVersionMismatch));
                    index++;
                    currentElement = list[index];
                    return true;
                }
                else
                    index = list.Count;
                return false;
            }

            object IEnumerator.Current {
                get {
                    return Current;
                }
            }

            public Control Current {
                get {
                    if (index == -1)
                        throw new InvalidOperationException(SR.GetString(SR.ListEnumCurrentOutOfRange));
                    if (index >= list.Count)
                        throw new InvalidOperationException(SR.GetString(SR.ListEnumCurrentOutOfRange));
                    return currentElement;
                }
            }

            public void Reset() {
                if (version != list._version)
                    throw new InvalidOperationException(SR.GetString(SR.ListEnumVersionMismatch));
                currentElement = null;
                index = -1;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\compilationconfiguration.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompilationConfiguration.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Code related to the <assemblies> config section
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.UI {

    using System;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Configuration;
    using System.IO;
    using System.Reflection;
    using System.Runtime.Serialization.Formatters;
    using System.Web.Configuration;
    using System.Web.Util;
    using System.Xml;
    using Debug=System.Web.Util.Debug;
    using System.Globalization;
    

    internal class CompilationConfiguration {

        internal const string sectionName = "system.web/compilation";

        static readonly char[] s_fieldSeparators = new char[] {';'};

        // _compilerLanguages : Hashtable <string, CompilerInfo>
        private Hashtable _compilerLanguages;

        // _compilerExtensions : Hashtable <string, CompilerInfo>
        private Hashtable _compilerExtensions;

        // Assembly objects loaded in first call to Assemblies property
        // _assemblies : Hashtable<string, Assembly>
        private Hashtable _assemblies;

        private string _tempDirectory;
        private bool _debug;
        private bool _strict;
        private bool _explicit;
        private bool _batch;
        private const int batchTimeoutDefault = 15;   // Default of 15 seconds
        private const int maxBatchGeneratedFileSizeDefault = 3000;   // Default of 3MB of generated source files per compilation
        private const int maxBatchSizeDefault = 1000;   // Default of 1000 batched classes per compilation
        private const int recompilationsBeforeAppRestartsDefault = 15;
        private int _batchTimeout;
        private int _maxBatchGeneratedFileSize;
        private int _maxBatchSize;
        private int _recompilationsBeforeAppRestarts;
        private string _defaultLanguage;

        // remember if we've already loaded the assemblies
        private bool _assembliesLoaded;


        private CompilationConfiguration() {
            _batch = true;
            _batchTimeout = batchTimeoutDefault;
            _maxBatchGeneratedFileSize = maxBatchGeneratedFileSizeDefault;
            _maxBatchSize = maxBatchSizeDefault;
            _recompilationsBeforeAppRestarts = recompilationsBeforeAppRestartsDefault;
        }

        private CompilationConfiguration(CompilationConfiguration original) {
            if (original._compilerLanguages != null)
                _compilerLanguages  = (Hashtable)original._compilerLanguages.Clone();

            if (original._compilerExtensions != null)
                _compilerExtensions = (Hashtable)original._compilerExtensions.Clone();

            if (original._assemblies != null)
                _assemblies         = (Hashtable)original._assemblies.Clone();

            _defaultLanguage = original._defaultLanguage;
            _tempDirectory = original._tempDirectory;
            _debug = original._debug;
            _strict = original._strict;
            _explicit = original._explicit;
            _batch = original._batch;
            _batchTimeout = original._batchTimeout;
            _maxBatchGeneratedFileSize = original._maxBatchGeneratedFileSize;
            _maxBatchSize = original._maxBatchSize;
            _recompilationsBeforeAppRestarts = original._recompilationsBeforeAppRestarts;
        }

        internal /*public*/ string TempDirectory {
            get {
                return _tempDirectory;
            }
        }

        internal /*public*/ bool DebuggingEnabled {
            get {
                return _debug;
            }
        }

        internal /*public*/ static bool IsDebuggingEnabled() {
            return IsDebuggingEnabled(HttpContext.Current);
        }


        internal /*public*/ static bool IsDebuggingEnabled(HttpContext context) {
            CompilationConfiguration compConfig =
                (UI.CompilationConfiguration)context.GetConfig(sectionName);

            if (compConfig == null)
                return false;

            return compConfig.DebuggingEnabled;
        }

        internal /*public*/ static bool IsBatchingEnabled(HttpContext context) {
            CompilationConfiguration compConfig =
                (UI.CompilationConfiguration)context.GetConfig(sectionName);

            if (compConfig == null)
                return true;

            return compConfig.Batch;
        }

        internal /*public*/ static int GetBatchTimeout(HttpContext context) {
            CompilationConfiguration compConfig =
                (UI.CompilationConfiguration)context.GetConfig(sectionName);

            if (compConfig == null)
                return batchTimeoutDefault;

            return compConfig.BatchTimeout;
        }

        internal /*public*/ static int GetMaxBatchGeneratedFileSize(HttpContext context) {
            CompilationConfiguration compConfig =
                (UI.CompilationConfiguration)context.GetConfig(sectionName);

            if (compConfig == null)
                return maxBatchGeneratedFileSizeDefault;

            return compConfig.MaxBatchGeneratedFileSize;
        }

        internal /*public*/ static int GetMaxBatchSize(HttpContext context) {
            CompilationConfiguration compConfig =
                (UI.CompilationConfiguration)context.GetConfig(sectionName);

            if (compConfig == null)
                return maxBatchSizeDefault;

            return compConfig.MaxBatchSize;
        }

        internal /*public*/ static int GetRecompilationsBeforeAppRestarts(HttpContext context) {
            CompilationConfiguration compConfig =
                (UI.CompilationConfiguration)context.GetConfig(sectionName);

            if (compConfig == null)
                return recompilationsBeforeAppRestartsDefault;

            return compConfig.RecompilationsBeforeAppRestarts;
        }

        internal /*public*/ bool Strict {
            get {
                return _strict;
            }
        }

        internal /*public*/ bool Explicit {
            get {
                return _explicit;
            }
        }

        internal /*public*/ bool Batch {
            get {
                return _batch;
            }
        }

        internal /*public*/ int BatchTimeout {
            get {
                return _batchTimeout;
            }
        }

        internal /*public*/ int MaxBatchGeneratedFileSize {
            get {
                return _maxBatchGeneratedFileSize;
            }
        }

        internal /*public*/ int MaxBatchSize {
            get {
                return _maxBatchSize;
            }
        }

        internal /*public*/ int RecompilationsBeforeAppRestarts {
            get {
                return _recompilationsBeforeAppRestarts;
            }
        }

        /*
         * Maps language name to compiler assembly
         *
         * return : Hashtable<string, string>
         */
        private Hashtable CompilerLanguages {
            get {
                return _compilerLanguages;
            }
        }

        /*
         * Maps file extension to compiler assembly
         *
         * return : Hashtable<string, string>
         */
        private Hashtable CompilerExtensions {
            get {
                return _compilerExtensions;
            }
        }

        private void EnsureAssembliesLoaded() {
            if (!_assembliesLoaded) {
                _assemblies = LoadAssemblies(_assemblies);
                _assembliesLoaded = true;
            }
        }

        /*
         * Maps assembly name strings to assemblies
         * 
         *   - On first invocation loads all assemblies
         *
         * return : Hashtable<string, Assembly>
         */
        internal /*public*/ Hashtable Assemblies {
            get {
                EnsureAssembliesLoaded();
                return _assemblies;
            }
        }

        internal /*public*/ Assembly LoadAssembly(string assemblyName, bool throwOnFail) {
            try {
                // First, try to just load the assembly
                return Assembly.Load(assemblyName);
            }
            catch {
                // If it fails, check if it is simply named
                int comaIndex = assemblyName.IndexOf(",");
                if (comaIndex < 0) {
                    EnsureAssembliesLoaded();

                    // It is simply named.  Go through all the assemblies from
                    // the <assemblies> section, and if we find one that matches
                    // the simple name, return it (ASURT 100546)
                    foreach (string aname in _assemblies.Keys) {
                        string[] parts = aname.Split(',');
                        if (string.Compare(parts[0], assemblyName, true, CultureInfo.InvariantCulture) == 0)
                            return (Assembly) _assemblies[aname];
                    }
                }
                
                if (throwOnFail)
                    throw;
            }

            return null;
        }

        /*
         * Simple wrapper to get the Assemblies for a context
         */
        internal static IDictionary GetAssembliesFromContext(HttpContext context) {
            // Get the CompilationConfiguration object for the passed in context
            CompilationConfiguration compilationConfiguration = 
            (CompilationConfiguration) context.GetConfig(sectionName);

            if (compilationConfiguration == null)
                return null;

            return compilationConfiguration.Assemblies;
        }

        /*
         * Return a CompilerInfo that a language maps to.
         */
        internal static CompilerInfo GetCompilerInfoFromLanguage(HttpContext context, string language) {
            // Get the <compilation> config object
            CompilationConfiguration config = (CompilationConfiguration) context.GetConfig(sectionName);

            if (config == null) {
                // Unsupported language: throw an exception
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_lang, language));
            }

            return config.GetCompilerInfoFromLanguage(language);
        }

        internal /*public*/ static CompilerInfo GetDefaultLanguageCompilerInfo(HttpContext context) {

            CompilationConfiguration config = null;

            // Get the <compilation> config object
            if (context != null)
                config = (CompilationConfiguration) context.GetConfig(sectionName);

            // If no default language was specified in config, use VB
            if (config == null || config._defaultLanguage == null)
                return new CompilerInfo(typeof(Microsoft.VisualBasic.VBCodeProvider));

            return config.GetCompilerInfoFromLanguage(config._defaultLanguage);
        }

        /*
         * Return a CompilerInfo that a language maps to.
         */
        internal CompilerInfo GetCompilerInfoFromLanguage(string language) {

            CompilerInfo compilerInfo = (CompilerInfo) CompilerLanguages[language];

            if (compilerInfo == null) {
                // Unsupported language: throw an exception
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_lang, language));
            }

            // Only allow the use of compilerOptions when we have UnmanagedCode access (ASURT 73678)
            if (compilerInfo.CompilParams.CompilerOptions != null) {
                if (!HttpRuntime.HasUnmanagedPermission()) {
                    throw new ConfigurationException(
                        HttpRuntime.FormatResourceString(SR.Insufficient_trust_for_attribute, "compilerOptions"),
                            compilerInfo.ConfigFileName, compilerInfo.ConfigFileLineNumber);
                }
            }

            // Clone it so the original is not modified
            compilerInfo = compilerInfo.Clone();

            // Set the value of the debug flag in the copy
            compilerInfo.CompilParams.IncludeDebugInformation = _debug;

            return compilerInfo;
        }

        /*
         * Return a CompilerInfo that a file name's extension maps to.
         */
        internal static CompilerInfo GetCompilerInfoFromFileName(HttpContext context, string fileName) {

            // Get the extension of the source file to compile
            string extension = Path.GetExtension(fileName);

            // Make sure there is an extension
            if (extension.Length == 0) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Empty_extension, fileName));
            }

            return GetCompilerInfoFromExtension(context, extension);
        }

        /*
         * Return a CompilerInfo that a extension maps to.
         */
        internal static CompilerInfo GetCompilerInfoFromExtension(HttpContext context, string extension) {
            // Get the <compilation> config object
            CompilationConfiguration config = (CompilationConfiguration) context.GetConfig(sectionName);

            if (config == null) {
                // Unsupported extension: throw an exception
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_lang_extension, extension));
            }

            return config.GetCompilerInfoFromExtension(extension);
        }

        /*
         * Return a CompilerInfo that a extension maps to.
         */
        internal CompilerInfo GetCompilerInfoFromExtension(string extension) {

            CompilerInfo compilerInfo = (CompilerInfo) CompilerExtensions[extension];

            if (compilerInfo == null) {
                // Unsupported extension: throw an exception
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_lang_extension, extension));
            }

            // Clone it so the original is not modified
            compilerInfo = compilerInfo.Clone();

            // Set the value of the debug flag in the copy
            compilerInfo.CompilParams.IncludeDebugInformation = _debug;

            return compilerInfo;
        }

        private static Hashtable LoadAssemblies(Hashtable original) {
            if (original == null)
                return null;

            Hashtable assemblies = new Hashtable();
            foreach(DictionaryEntry de in original) {
                // If value is already an assembly then a parent vnode has already loaded it.
                if (de.Value is Assembly) {
                    assemblies[de.Key] = de.Value;
                }
                else {
                    string assemblyName = (string) de.Key;

                    // Load the assembly and add it to the dictionary.
                    try {
                        assemblies[assemblyName] = Assembly.Load(assemblyName);
                    }
                    catch (Exception e) {

                        // Retrieve the file/line number info that we stored in ProcessAssembliesElement
                        object[] configFileInfo = (object[]) original[assemblyName];

                        Debug.Assert(configFileInfo.Length == 3, "configFileInfo.Length == 3");

                        // Check if this assembly came from the '*' directive
                        bool starDirective = (bool) configFileInfo[2];

                        bool ignoreException = false;

                        if (starDirective) {
                            if (e is BadImageFormatException) {
                                // This is expected to fail for unmanaged DLLs that happen
                                // to be in the bin dir.  Ignore them.
                                ignoreException = true;
                            }
                            else if (e is FileLoadException) {
                                // Also, ignore errors caused by multi part assemblies (ASURT 93073)
                                // We need to use reflection to get the HResult property because
                                // it's protected.
                                PropertyInfo pInfo = typeof(FileLoadException).GetProperty("HResult",
                                    BindingFlags.NonPublic | BindingFlags.Instance);
                                MethodInfo methodInfo = pInfo.GetGetMethod(true /*nonPublic*/);
                                uint hresult = (uint)(int) methodInfo.Invoke(e, null);

                                // Test for COR_E_ASSEMBLYEXPECTED=0x80131018
                                if (hresult == 0x80131018)
                                    ignoreException = true;
                            }
                        }

                        if (ignoreException)
                            continue;

                        throw new ConfigurationException(e.Message, e,
                            (string)configFileInfo[0], (int)configFileInfo[1]);
                    }

                    Debug.Trace("LoadAssembly", "Successfully loaded assembly '" + assemblyName + "'");
                }
            }

            return assemblies;
        }


        internal class SectionHandler {
            private SectionHandler () {
            }

            internal static object CreateStatic(object inheritedObject, XmlNode node) {
                CompilationConfiguration inherited = (CompilationConfiguration)inheritedObject;
                CompilationConfiguration result;

                if (inherited == null)
                    result = new CompilationConfiguration();
                else
                    result = new CompilationConfiguration(inherited);

                //
                // Handle attributes (if they exist)
                //   - tempDirectory - "[directory]"
                //   - debug="true/false"
                //   - strict="true/false"
                //   - explicit="true/false"
                //   - batch="true/false"
                //   - batchtimeout="[time in seconds]"
                //   - maxBatchGeneratedFileSize="[max combined size (in KB) of the generated source files per batched compilation]"
                //   - maxBatchSize="[max number of classes per batched compilation]"
                //   - numRecompilesBeforeAppRestart="[max number of recompilations before appdomain is cycled]"
                //   - defaultLanguage - must be in the list of languages
                //
                XmlNode a = HandlerBase.GetAndRemoveNonEmptyStringAttribute(
                    node, "tempDirectory", ref result._tempDirectory);
                if (a != null) {
                    if (!Path.IsPathRooted(result._tempDirectory)) {
                        throw new ConfigurationException(
                            HttpRuntime.FormatResourceString(SR.Invalid_temp_directory), a);
                    }
                }

                HandlerBase.GetAndRemoveBooleanAttribute(node, "debug", ref result._debug);
                HandlerBase.GetAndRemoveBooleanAttribute(node, "strict", ref result._strict);
                HandlerBase.GetAndRemoveBooleanAttribute(node, "explicit", ref result._explicit);
                HandlerBase.GetAndRemoveBooleanAttribute(node, "batch", ref result._batch);
                HandlerBase.GetAndRemovePositiveIntegerAttribute(node, "batchTimeout", ref result._batchTimeout);
                HandlerBase.GetAndRemovePositiveIntegerAttribute(node, "maxBatchGeneratedFileSize", ref result._maxBatchGeneratedFileSize);
                HandlerBase.GetAndRemovePositiveIntegerAttribute(node, "maxBatchSize", ref result._maxBatchSize);
                HandlerBase.GetAndRemovePositiveIntegerAttribute(node, "numRecompilesBeforeAppRestart", ref result._recompilationsBeforeAppRestarts);
                HandlerBase.GetAndRemoveStringAttribute(node, "defaultLanguage", ref result._defaultLanguage);

                HandlerBase.CheckForUnrecognizedAttributes(node);

                //
                // Handle child elements (if they exist)
                //   - compilers
                //   - assemblies
                //
                foreach (XmlNode child in node.ChildNodes) {

                    // skip whitespace and comments
                    // reject nonelements
                    if (HandlerBase.IsIgnorableAlsoCheckForNonElement(child))
                        continue;

                    // handle <compilers> and <assemblies>
                    if (child.Name == "compilers") {
                        ProcessCompilersElement(result, child);
                    }
                    else if (child.Name == "assemblies") {
                        ProcessAssembliesElement(result, child);
                    }
                    else {
                        HandlerBase.ThrowUnrecognizedElement(child);
                    }
                }

                return result;
            }

            private static void ProcessAssembliesElement(CompilationConfiguration result, XmlNode node) {
                // reject attributes
                HandlerBase.CheckForUnrecognizedAttributes(node);

                string configFile = ConfigurationException.GetXmlNodeFilename(node);

                Hashtable addEntries = null;
                Hashtable removeEntries = null;
                bool hasClear = false;

                foreach(XmlNode child in node.ChildNodes) {

                    // skip whitespace and comments
                    // reject nonelements
                    if (HandlerBase.IsIgnorableAlsoCheckForNonElement(child))
                        continue;

                    // handle <add>, <remove>, <clear> tags

                    if (child.Name == "add") {

                        string assemblyName = GetAssembly(child);

                        // Check for duplicate lines (ASURT 93151)
                        if (addEntries == null)
                            addEntries = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                        if (addEntries.ContainsKey(assemblyName))
                            HandlerBase.ThrowDuplicateLineException(child);
                        addEntries[assemblyName] = null;

                        if (result._assemblies == null)
                            result._assemblies = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));

                        // if key already exists then we might have already loaded it
                        if (result._assemblies.ContainsKey(assemblyName) == false) {

                            if (assemblyName == "*") {
                                AddAllAssembliesFromAppDomainBinDirectory(result, child);
                            }
                            else {
                                // Remember the config file location info, in case an error
                                // occurs later when we try to load the assembly (ASURT 72183)
                                int configFileLine = ConfigurationException.GetXmlNodeLineNumber(child);
                                result._assemblies[assemblyName] = new object[]
                                    { configFile, configFileLine, false /*starDirective*/ };
                            }
                        }

                    }
                    else if (child.Name == "remove") {

                        string assemblyName = GetAssembly(child);

                        // Check for duplicate lines (ASURT 93151)
                        if (removeEntries == null)
                            removeEntries = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                        if (removeEntries.ContainsKey(assemblyName))
                            HandlerBase.ThrowDuplicateLineException(child);
                        removeEntries[assemblyName] = null;

                        if (result._assemblies != null) {

                            // If it's a '*' remove everything
                            if (assemblyName == "*") {
                                result._assemblies.Clear();
                            }
                            else {
                                // Otherwise, just remove the one assembly (if present)
                                result._assemblies.Remove(assemblyName);
                            }
                        }
                    }
                    else if (child.Name == "clear") {
                        // Check for duplicate lines (ASURT 93151)
                        if (hasClear)
                            HandlerBase.ThrowDuplicateLineException(child);
                        hasClear = true;

                        HandlerBase.CheckForUnrecognizedAttributes(child);
                        HandlerBase.CheckForChildNodes(child);
                        if (result._assemblies != null)
                            result._assemblies.Clear();
                    }
                    else {
                        HandlerBase.ThrowUnrecognizedElement(child);
                    }
                }
            }

            private static string GetAssembly(XmlNode node) {
                string assemblyName = null;
                HandlerBase.GetAndRemoveRequiredNonEmptyStringAttribute(node, "assembly", ref assemblyName);

                HandlerBase.CheckForUnrecognizedAttributes(node);
                HandlerBase.CheckForChildNodes(node);

                return assemblyName;
            }

            private static void AddAllAssembliesFromAppDomainBinDirectory(
                CompilationConfiguration result, XmlNode child) {

                // Get the path to the bin directory
                string binPath = HttpRuntime.BinDirectoryInternal;
                FileInfo[] binDlls;

                if (!FileUtil.DirectoryExists(binPath)) {
                    // This is expected to fail if there is no 'bin' dir
                    Debug.Trace("Template", "Failed to access bin dir \"" + binPath + "\"");
                }
                else {
                    DirectoryInfo binPathDirectory = new DirectoryInfo(binPath);
                    // Get a list of all the DLL's in the bin directory
                    binDlls = binPathDirectory.GetFiles("*.dll");

                    string configFile = ConfigurationException.GetXmlNodeFilename(child);

                    for (int i=0; i<binDlls.Length; i++) {

                        string assemblyName = Util.GetAssemblyNameFromFileName(binDlls[i].Name);

                        // Remember the config file location info, in case an error
                        // occurs later when we try to load the assembly (ASURT 72183)
                        int configFileLine = ConfigurationException.GetXmlNodeLineNumber(child);
                        result._assemblies[assemblyName] = new object[]
                            { configFile, configFileLine, true /*starDirective*/ };
                    }
                }
            }


            private static void ProcessCompilersElement(CompilationConfiguration result, XmlNode node) {

                // reject attributes
                HandlerBase.CheckForUnrecognizedAttributes(node);

                string configFile = ConfigurationException.GetXmlNodeFilename(node);

                foreach(XmlNode child in node.ChildNodes) {

                    // skip whitespace and comments
                    // reject nonelements
                    if (HandlerBase.IsIgnorableAlsoCheckForNonElement(child))
                        continue;

                    if (child.Name != "compiler") {
                        HandlerBase.ThrowUnrecognizedElement(child);
                    }

                    string languages = String.Empty;
                    HandlerBase.GetAndRemoveStringAttribute(child, "language", ref languages);
                    string extensions = String.Empty;
                    HandlerBase.GetAndRemoveStringAttribute(child, "extension", ref extensions);
                    string compilerTypeName = null;
                    HandlerBase.GetAndRemoveRequiredNonEmptyStringAttribute(child, "type", ref compilerTypeName);

                    // Create a CompilerParameters for this compiler.
                    CompilerParameters compilParams = new CompilerParameters();

                    int warningLevel = 0;
                    if (HandlerBase.GetAndRemoveNonNegativeIntegerAttribute(child, "warningLevel", ref warningLevel) != null) {
                        compilParams.WarningLevel = warningLevel;

                        // Need to be false if the warning level is 0
                        compilParams.TreatWarningsAsErrors = (warningLevel>0);
                    }
                    string compilerOptions = null;
                    if (HandlerBase.GetAndRemoveStringAttribute(child, "compilerOptions", ref compilerOptions) != null) {
                        compilParams.CompilerOptions = compilerOptions;
                    }

                    HandlerBase.CheckForUnrecognizedAttributes(child);
                    HandlerBase.CheckForChildNodes(child);

                    // Create a CompilerInfo structure for this compiler
                    int configFileLine = ConfigurationException.GetXmlNodeLineNumber(child);
                    CompilerInfo compilInfo = new CompilerInfo(compilParams, compilerTypeName, configFile, configFileLine);

                    if (result._compilerLanguages == null) {
                        result._compilerLanguages = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
                        result._compilerExtensions = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
                    }

                    // Parse the semicolon separated lists
                    string[] languageList = languages.Split(s_fieldSeparators);
                    string[] extensionList = extensions.Split(s_fieldSeparators);

                    foreach (string language in languageList) {

                        result._compilerLanguages[language] = compilInfo;
                    }

                    foreach (string extension in extensionList) {
                        result._compilerExtensions[extension] = compilInfo;
                    }
                }
            }
        }
    }


    internal class CompilerInfo {
        private string _compilerTypeName;
        private string _configFileName;
        private int _configFileLineNumber;
        private Type _compilerType;
        private CompilerParameters _compilParams;

        private CompilerInfo() {}

        internal CompilerInfo(CompilerParameters compilParams, string compilerTypeName,
            string configFileName, int configFileLineNumber) {
            _compilerTypeName = compilerTypeName;
            _configFileName = configFileName;
            _configFileLineNumber = configFileLineNumber;

            if (compilParams == null)
                compilParams = new CompilerParameters();

            _compilParams = compilParams;
        }

        internal CompilerInfo(Type compilerType) {
            _compilerType = compilerType;
            _compilParams = new CompilerParameters();
        }

        public override int GetHashCode() {
            return CompilerType.GetHashCode();
        }

        public override bool Equals(Object o) {
            CompilerInfo other = o as CompilerInfo;
            if (o == null)
                return false;

            return CompilerType == other.CompilerType &&
                CompilParams.WarningLevel == other.CompilParams.WarningLevel &&
                CompilParams.IncludeDebugInformation == other.CompilParams.IncludeDebugInformation &&
                CompilParams.CompilerOptions == other.CompilParams.CompilerOptions;
        }

        internal string ConfigFileName {
            get { return _configFileName; }
        }

        internal int ConfigFileLineNumber {
            get { return _configFileLineNumber; }
        }

        internal Type CompilerType {
            get {
                if (_compilerType == null) {
                    Type compilerType;

                    try {
                        compilerType = Type.GetType(_compilerTypeName, true /*throwOnError*/);
                    }
                    catch (Exception e) {
                        throw new ConfigurationException(e.Message,
                            _configFileName, _configFileLineNumber);
                    }

                    HandlerBase.CheckAssignableType(_configFileName, _configFileLineNumber, typeof(CodeDomProvider), compilerType);

                    // If we're not in full trust, only allow types that have the APTCA bit (ASURT 139687)
                    if (!HttpRuntime.HasAspNetHostingPermission(AspNetHostingPermissionLevel.Unrestricted)) {
                        if (!HandlerMapping.IsTypeFromAssemblyWithAPTCA(compilerType) &&
                            HandlerMapping.IsTypeFromAssemblyWithStrongName(compilerType)) {
                            throw new HttpException(HttpRuntime.FormatResourceString(SR.Type_from_untrusted_assembly, _compilerTypeName));
                        }
                    }

                    _compilerType = compilerType;
                }

                return _compilerType;
            }
        }

        internal CompilerParameters CompilParams {
            get {
                return _compilParams;
            }
        }

        private static CompilerParameters CloneCompilerParameters(CompilerParameters original) {
            CompilerParameters copy = new CompilerParameters();
            copy.IncludeDebugInformation = original.IncludeDebugInformation;
            copy.TreatWarningsAsErrors = original.TreatWarningsAsErrors;
            copy.WarningLevel = original.WarningLevel;
            copy.CompilerOptions = original.CompilerOptions;
            return copy;
        }

        private CompilerParameters CloneCompilParams() {
            // Clone the CompilerParameters to make sure the original is untouched
            return CloneCompilerParameters(_compilParams);
        }

        internal CompilerInfo Clone() {
            CompilerInfo copy = new CompilerInfo();
            copy._compilerTypeName = _compilerTypeName;
            copy._configFileName = _configFileName;
            copy._configFileLineNumber = _configFileLineNumber;
            copy._compilerType = _compilerType;
            copy._compilParams = CloneCompilParams();
            return copy;
        }

    }

    internal class CompilationConfigurationHandler : IConfigurationSectionHandler {
        internal CompilationConfigurationHandler() {
        }

        public virtual object Create(object inheritedObject, object configContextObj, XmlNode node) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;
            
            return CompilationConfiguration.SectionHandler.CreateStatic(inheritedObject, node);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\controlstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The possible states a container control can be in when children are added to it.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.UI {

    internal enum ControlState {
        Constructed = 0,
        ChildrenInitialized = 1,
        Initialized = 2,
        ViewStateLoaded = 3,
        Loaded      = 4,
        PreRendered = 5,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\cssstylecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="CssStyleCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * CssStyleCollection.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI {
    using System.IO;
    using System.Collections;
    using System.Reflection;
    using System.Web.UI;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Security.Permissions;

    /*
     * The CssStyleCollection represents styles on an Html control.
     */
    /// <include file='doc\CssStyleCollection.uex' path='docs/doc[@for="CssStyleCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The <see langword='CssStyleCollection'/>
    ///       class contains HTML
    ///       cascading-style sheets (CSS) inline style attributes. It automatically parses
    ///       and exposes CSS properties through a dictionary pattern API. Each CSS key can be
    ///       manipulated using a key/value indexed collection.
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class CssStyleCollection {

        private StateBag    _state;
        private IDictionary _table;
        private static readonly Regex _styleAttribRegex = new Regex(
                                                                   "\\G(\\s*(;\\s*)*" +        // match leading semicolons and spaces
                                                                   "(?<stylename>[^:]+?)" +    // match stylename - chars up to the semicolon
                                                                   "\\s*:\\s*" +               // spaces, then the colon, then more spaces
                                                                   "(?<styleval>[^;]+)" +      // now match styleval
                                                                   ")*\\s*(;\\s*)*$",          // match a trailing semicolon and trailing spaces
                                                                   RegexOptions.Singleline | 
                                                                   RegexOptions.Multiline |
                                                                   RegexOptions.ExplicitCapture);    


        /*
         * Constructs an CssStyleCollection given a StateBag.
         */
        internal CssStyleCollection(StateBag state) {
            _state = state;
        }

        /*
         * Automatically adds new keys.
         */
        /// <include file='doc\CssStyleCollection.uex' path='docs/doc[@for="CssStyleCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a specified CSS value.
        ///    </para>
        /// </devdoc>
        public string this[string key]
        {
            get {
                if (_table == null)
                    ParseString();
                return(string)_table[key];
            }

            set { 
                Add(key,value); 
            }
        }

        /*
         * Returns a collection of keys.
         */
        /// <include file='doc\CssStyleCollection.uex' path='docs/doc[@for="CssStyleCollection.Keys"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of keys to all the styles in the
        ///    <see langword='CssStyleCollection'/>. 
        ///    </para>
        /// </devdoc>
        public ICollection Keys {
            get { 
                if (_table == null)
                    ParseString();
                return _table.Keys; 
            }
        }

        /// <include file='doc\CssStyleCollection.uex' path='docs/doc[@for="CssStyleCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of items in the <see langword='CssStyleCollection'/>.
        ///    </para>
        /// </devdoc>
        public int Count {
            get { 
                if (_table == null)
                    ParseString();
                return _table.Count; 
            }
        }

        internal string Style {
            get { 
                return(string)_state["style"];
            }

            set { 
                _state["style"] = value;
                _table = null;
            }
        }

        /// <include file='doc\CssStyleCollection.uex' path='docs/doc[@for="CssStyleCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a style to the CssStyleCollection.
        ///    </para>
        /// </devdoc>
        public void Add(string key, string value) {
            if (_table == null)
                ParseString();
            _table[key] = value;

            // keep style attribute synchronized
            _state["style"] = BuildString();
        }

        /// <include file='doc\CssStyleCollection.uex' path='docs/doc[@for="CssStyleCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes a style from the <see langword='CssStyleCollection'/>.
        ///    </para>
        /// </devdoc>
        public void Remove(string key) {
            if (_table == null)
                ParseString();
            if (_table[key] != null) {
                _table.Remove(key);
                // keep style attribute synchronized
                _state["style"] = BuildString();
            }
        }

        /// <include file='doc\CssStyleCollection.uex' path='docs/doc[@for="CssStyleCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes all styles from the <see langword='CssStyleCollection'/>.
        ///    </para>
        /// </devdoc>
        public void Clear() {
            _table = null;
            _state.Remove("style");
        }

        /*  BuildString
         *  Form the style string from data contained in the 
         *  hash table
         */
        private string BuildString() {
            // if the table is null, there is nothing to build
            if (_table != null && _table.Count > 0) {
                StringBuilder sb = new StringBuilder();
                IEnumerator keyEnum = Keys.GetEnumerator();
                string curKey;

                while (keyEnum.MoveNext()) {
                    curKey = (string)keyEnum.Current;
                    sb.Append(curKey + ":" + (string)_table[curKey] + ";");
                }
                return sb.ToString();
            }
            return null;
        }

        /*  ParseString
         *  Parse the style string and fill the hash table with
         *  corresponding values.  
         */
        private void ParseString() {
            _table = new StateBag();
            string s = (string)_state["style"];

            if (s != null) {
                Match match;

                if ((match = _styleAttribRegex.Match( s, 0)).Success) {
                    CaptureCollection stylenames = match.Groups["stylename"].Captures;
                    CaptureCollection stylevalues = match.Groups["styleval"].Captures;

                    for (int i = 0; i < stylenames.Count; i++) {
                        String styleName = stylenames[i].ToString();
                        String styleValue = stylevalues[i].ToString();

                        _table[styleName] = styleValue;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\databinding.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataBinding.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Globalization;
    using System.Security.Permissions;
    
    /// <include file='doc\DataBinding.uex' path='docs/doc[@for="DataBinding"]/*' />
    /// <devdoc>
    ///    <para>Enables RAD designers to create data binding expressions 
    ///       at design time. This class cannot be inherited.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DataBinding {

        private string propertyName;
        private Type propertyType;
        private string expression;

        /// <include file='doc\DataBinding.uex' path='docs/doc[@for="DataBinding.DataBinding"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.DataBinding'/> class.</para>
        /// </devdoc>
        public DataBinding(string propertyName, Type propertyType, string expression) {
            this.propertyName = propertyName;
            this.propertyType = propertyType;
            this.expression = expression;
        }


        /// <include file='doc\DataBinding.uex' path='docs/doc[@for="DataBinding.Expression"]/*' />
        /// <devdoc>
        ///    <para>Indicates the data binding expression to be evaluated.</para>
        /// </devdoc>
        public string Expression {
            get {
                return expression;
            }
            set {
                Debug.Assert((value != null) && (value.Length != 0),
                             "Invalid expression");
                expression = value;
            }
        }

        /// <include file='doc\DataBinding.uex' path='docs/doc[@for="DataBinding.PropertyName"]/*' />
        /// <devdoc>
        ///    <para>Indicates the name of the property that is to be data bound against. This 
        ///       property is read-only.</para>
        /// </devdoc>
        public string PropertyName {
            get {
                return propertyName;
            }
        }

        /// <include file='doc\DataBinding.uex' path='docs/doc[@for="DataBinding.PropertyType"]/*' />
        /// <devdoc>
        ///    <para>Indicates the type of the data bound property. This property is 
        ///       read-only.</para>
        /// </devdoc>
        public Type PropertyType {
            get {
                return propertyType;
            }
        }

        /// <include file='doc\DataBinding.uex' path='docs/doc[@for="DataBinding.GetHashCode"]/*' />
        /// <devdoc>
        ///     DataBinding objects are placed in a hashtable representing the collection
        ///     of bindings on a control. There can only be one binding/property, so
        ///     the hashcode computation should match the Equals implementation and only
        ///    take the property name into account.
        /// </devdoc>
        public override int GetHashCode() {
            return propertyName.ToLower(CultureInfo.InvariantCulture).GetHashCode();
        }

        /// <include file='doc\DataBinding.uex' path='docs/doc[@for="DataBinding.Equals"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override bool Equals(object obj) {
            if ((obj != null) && (obj is DataBinding)) {
                DataBinding binding = (DataBinding)obj;

                return String.Compare(propertyName, binding.PropertyName, true, CultureInfo.InvariantCulture) == 0;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\databindingcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataBindingCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Web.Util;
    using System.Security.Permissions;

    /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection"]/*' />
    /// <devdoc>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DataBindingCollection : ICollection {

        private Hashtable bindings;
        private Hashtable removedBindings;

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.DataBindingCollection"]/*' />
        /// <devdoc>
        /// </devdoc>
        public DataBindingCollection() {
            this.bindings = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
        }

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.Count"]/*' />
        /// <devdoc>
        /// </devdoc>
        public int Count {
            get {
                return bindings.Count;
            }
        }

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.IsReadOnly"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.IsSynchronized"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.RemovedBindings"]/*' />
        /// <devdoc>
        /// </devdoc>
        public string[] RemovedBindings {
            get {
                int bindingCount = 0;
                ICollection keys = null;

                if (removedBindings != null) {
                    keys = removedBindings.Keys;
                    bindingCount = keys.Count;

                    string[] removedNames = new string[bindingCount];
                    int i = 0;

                    foreach (string s in keys) {
                        removedNames[i++] = s;
                    }

                    removedBindings.Clear();
                    return removedNames;
                }
                else {
                    return new string[0];
                }
            }
        }

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.RemovedBindingsTable"]/*' />
        /// <devdoc>
        /// </devdoc>
        private Hashtable RemovedBindingsTable {
            get {
                if (removedBindings == null) {
                    removedBindings = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
                }
                return removedBindings;
            }
        }

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.SyncRoot"]/*' />
        /// <devdoc>
        /// </devdoc>
        public object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.this"]/*' />
        /// <devdoc>
        /// </devdoc>
        public DataBinding this[string propertyName] {
            get {
                object o = bindings[propertyName];
                if (o != null)
                    return(DataBinding)o;
                return null;
            }
        }


        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.Add"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void Add(DataBinding binding) {
            bindings[binding.PropertyName] = binding;
            RemovedBindingsTable.Remove(binding.PropertyName);
        }

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.Clear"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void Clear() {
            ICollection keys = bindings.Keys;
            if ((keys.Count != 0) && (removedBindings == null)) {
                // ensure the removedBindings hashtable is created
                Hashtable h = RemovedBindingsTable;
            }
            foreach (string s in keys) {
                removedBindings[s] = String.Empty;
            }
            
            bindings.Clear();
        }

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.CopyTo"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.GetEnumerator"]/*' />
        /// <devdoc>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return bindings.Values.GetEnumerator();
        }

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.Remove"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void Remove(string propertyName) {
            Remove(propertyName, true);
        }

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.Remove1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void Remove(DataBinding binding) {
            Remove(binding.PropertyName, true);
        }

        /// <include file='doc\DataBindingCollection.uex' path='docs/doc[@for="DataBindingCollection.Remove2"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void Remove(string propertyName, bool addToRemovedList) {
            bindings.Remove(propertyName);
            if (addToRemovedList) {
                RemovedBindingsTable[propertyName] = String.Empty;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\controlbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Implement a generic control builder used by all controls
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.UI {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Reflection;
    using System.Text.RegularExpressions;
    using System.Web;
    using System.Web.RegularExpressions;
    using System.Security.Permissions;

    /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="ControlBuilder"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ControlBuilder {
        private TemplateParser _parser;
        private ControlBuilder _parentBuilder;
        private PropertySetter _attribSetter;
        private PropertySetter _boundAttribSetter;
        private PropertySetter _complexAttribSetter;
        private bool _fIsNonParserAccessor;     // Does object implement IParserAccessor?
        private bool _fChildrenAsProperties;  // Does it contain properties (as opposed to children)
        internal ControlBuilder _defaultPropBuilder;  // Is so, does it have a default one (store its builder)
        internal string _tagName;
        internal string _id;
        internal Type _ctrlType;

        internal ArrayList _subBuilders;
        internal PropertySetter _templateSetter;
        private bool _fHasAspCode;

        // The source file line number at which this builder is defined
        internal int _line;
        internal int Line {
            get { return _line; }
        }

        // The name of the source file in which this builder is defined
        internal string _sourceFileName;
        internal string SourceFileName {
            get { return _sourceFileName; }
        }

        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.InDesigner"]/*' />
        /// <devdoc>
        ///    <para> InDesigner property gets used by control builders so that they can behave
        ///         differently if needed. </para>
        /// </devdoc>
        protected bool InDesigner {
            get { return _parser.FInDesigner; }
        }

        private bool NonCompiledPage {
            get { return _parser.FNonCompiledPage; }
        }

        /*
         * Initialize the builder
         * @param parser The instance of the parser that is controlling us.
         * @param tagName The name of the tag to be built.  This is necessary
         *      to allow a builder to support multiple tag types.
         * @param attribs IDictionary which holds all the attributes of
         *      the tag.  It is immutable.
         * @param type Type of the control that this builder will create.
         */
        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.Init"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void Init(TemplateParser parser, ControlBuilder parentBuilder,
                                 Type type, string tagName, string id, IDictionary attribs) {
            _parser = parser;
            _parentBuilder = parentBuilder;
            _tagName = tagName;
            _id = id;
            _ctrlType = type;

            if (type != null) {

                // Try to get a ParseChildrenAttribute from the object
                ParseChildrenAttribute pca = null;
                object[] attrs = type.GetCustomAttributes(typeof(ParseChildrenAttribute), /*inherit*/ true);
                if ((attrs != null) && (attrs.Length == 1)) {
                    Debug.Assert(attrs[0] is ParseChildrenAttribute);
                    pca = (ParseChildrenAttribute)attrs[0];
                }

                // Is this a builder for an object that implements IParserAccessor?
                if (!typeof(IParserAccessor).IsAssignableFrom(type)) {
                    _fIsNonParserAccessor = true;

                    // Non controls never have children
                    _fChildrenAsProperties = true;
                }
                else {
                    // Check if the nested tags define properties, as opposed to children
                    if (pca != null)
                        _fChildrenAsProperties = pca.ChildrenAsProperties;
                }

                if (_fChildrenAsProperties) {
                    // Check if there is a default property
                    if (pca != null && pca.DefaultProperty.Length != 0) {

                        Type subType = null;

                        // Create a builder for the default prop
                        _defaultPropBuilder = CreateChildBuilder(pca.DefaultProperty, null/*attribs*/,
                            parser, null, null /*id*/, _line, _sourceFileName, ref subType);

                        Debug.Assert(_defaultPropBuilder != null, pca.DefaultProperty);
                    }
                }
            }

            // Process the attributes, if any
            if (attribs != null)
                PreprocessAttributes(attribs);
        }

        // Protected accessors to private fields
        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.Parser"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected TemplateParser Parser { get { return _parser;}}
        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.FIsNonParserAccessor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool FIsNonParserAccessor { get { return _fIsNonParserAccessor;}}
        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.FChildrenAsProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool FChildrenAsProperties { get { return _fChildrenAsProperties;}}
        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.ComplexAttribSetter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal PropertySetter ComplexAttribSetter {
            get { 
                if (_complexAttribSetter == null)
                    _complexAttribSetter = new PropertySetter(_ctrlType, InDesigner || NonCompiledPage);
                return _complexAttribSetter; 
            }
        }

        /*
         * Return the type of the control that this builder creates
         */
        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.ControlType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type ControlType {
            get { return _ctrlType;}
        }

        /*
         * Return the type of the naming container of the control that this builder creates
         */
        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.NamingContainerType"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type NamingContainerType {
            get {
                if (_parentBuilder == null || _parentBuilder.ControlType == null)
                    return typeof(Control);

                // Search for the closest naming container in the tree
                if (typeof(INamingContainer).IsAssignableFrom(_parentBuilder.ControlType))
                    return _parentBuilder.ControlType;

                return _parentBuilder.NamingContainerType;
            }
        }

        /*
         * Return the ID of the control that this builder creates
         */
        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.ID"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ID {
            get { return _id;}
            set { _id = value;}
        }

        private ControlBuilder GetChildPropertyBuilder(string tagName, IDictionary attribs,
            ref Type childType) {

            Debug.Assert(FChildrenAsProperties, "FChildrenAsProperties");

            // The child is supposed to be a property, so look for it
            PropertyInfo pInfo = _ctrlType.GetProperty(
                tagName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.IgnoreCase);

            if (pInfo == null) {
                throw new HttpException(HttpRuntime.FormatResourceString(
                    SR.Type_doesnt_have_property, _ctrlType.FullName, tagName));
            }

            // Get its type
            childType = pInfo.PropertyType;

            ControlBuilder builder = null;

            // If it's a collection, return the collection builder
            if (typeof(ICollection).IsAssignableFrom(childType)) {

                // Check whether the prop has an IgnoreUnknownContentAttribute
                object[] attrs = pInfo.GetCustomAttributes(typeof(IgnoreUnknownContentAttribute),
                    /*inherit*/ true);
                builder = new CollectionBuilder(((attrs != null) && (attrs.Length == 1)) /*ignoreUnknownContent*/);
            }

            // If it's a template, return the template builder
            if (childType == typeof(ITemplate))
                builder = new TemplateBuilder();

            if (builder != null) {
                builder._line = _line;
                builder._sourceFileName = _sourceFileName;

                // Initialize the builder
                builder.Init(_parser, (ControlBuilder)this, null, tagName, null, attribs);
                return builder;
            }

            // Otherwise, simply return the builder for the property
            builder = CreateBuilderFromType(
                _parser, this, childType, tagName, null, attribs,
                _line, _sourceFileName);
            return builder;
        }

        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.GetChildControlType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual Type GetChildControlType(string tagName, IDictionary attribs) {
            return null;
        }

        internal ControlBuilder CreateChildBuilder(string tagName, IDictionary attribs,
            TemplateParser parser, ControlBuilder parentBuilder, string id, int line,
            string sourceFileName, ref Type childType) {

            ControlBuilder subBuilder;

            if (FChildrenAsProperties) {

                // If there is a default property, delegate to its builder
                if (_defaultPropBuilder != null) {
                    subBuilder = _defaultPropBuilder.CreateChildBuilder(tagName, attribs, parser,
                        null, id, line, sourceFileName, ref childType);
                }
                else {
                    subBuilder = GetChildPropertyBuilder(tagName, attribs, ref childType);
                }
            }
            else {

                childType = GetChildControlType(tagName, attribs);
                if (childType == null)
                    return null;

                subBuilder = CreateBuilderFromType(
                    parser, this, childType, tagName, id, attribs, line,
                    sourceFileName);
            }

            if (subBuilder == null)
                return null;

            subBuilder._parentBuilder = (parentBuilder != null) ? parentBuilder : this;

            return subBuilder;
        }

        /*
         * Does this control have a body.  e.g. <foo/> doesn't.
         */
        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.HasBody"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool HasBody() {
            return true;
        }

        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.AllowWhitespaceLiterals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool AllowWhitespaceLiterals() {
            return true;
        }

        internal void AddSubBuilder(object o) {
            if (_subBuilders == null)
                _subBuilders = new ArrayList();

            _subBuilders.Add(o);
        }

        // Return the last sub builder added to this builder
        internal object GetLastBuilder() {
            if (_subBuilders == null)
                return null;

            return _subBuilders[_subBuilders.Count-1];
        }

        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="ControlBuilder.AppendSubBuilder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void AppendSubBuilder(ControlBuilder subBuilder) {

            // Tell the sub builder that it's about to be appended to its parent
            subBuilder.OnAppendToParentBuilder(this);

            if (FChildrenAsProperties) {

                // Don't allow code blocks when properties are expected (ASURT 97838)
                if (subBuilder is CodeBlockBuilder) {
                    throw new HttpException(
                        HttpRuntime.FormatResourceString(SR.Code_not_supported_on_not_controls));
                }

                // If there is a default property, delegate to its builder
                if (_defaultPropBuilder != null) {
                    _defaultPropBuilder.AppendSubBuilder(subBuilder);
                    return;
                }

                // The tagname is the property name
                string propName = subBuilder.TagName;

                if (subBuilder is TemplateBuilder) {   // The subBuilder is for building a template

                    TemplateBuilder tplBuilder = (TemplateBuilder) subBuilder;

                    if (_templateSetter == null) {
                        _templateSetter = new PropertySetter(_ctrlType, InDesigner || NonCompiledPage);
                    }

                    // Add TemplateBuilder to the template setter.
                    _templateSetter.AddTemplateProperty(propName, tplBuilder);
                    return;
                }

                if (subBuilder is CollectionBuilder) {   // The subBuilder is for building a collection

                    // If there are no items in the collection, we're done
                    if (subBuilder.SubBuilders == null || subBuilder.SubBuilders.Count == 0)
                        return;

                    IEnumerator subBuilders = subBuilder.SubBuilders.GetEnumerator();
                    while (subBuilders.MoveNext()) {
                        ControlBuilder builder = (ControlBuilder)subBuilders.Current;
                        subBuilder.ComplexAttribSetter.AddCollectionItem(builder);
                    }
                    subBuilder.SubBuilders.Clear();

                    ComplexAttribSetter.AddComplexProperty(propName, subBuilder);
                    return;
                }

                ComplexAttribSetter.AddComplexProperty(propName, subBuilder);
                return;
            }

            CodeBlockBuilder codeBlockBuilder = subBuilder as CodeBlockBuilder;
            if (codeBlockBuilder != null) {

                // Don't allow code blocks inside non-control tags (ASURT 76719)
                if (ControlType != null && !typeof(Control).IsAssignableFrom(ControlType)) {
                    throw new HttpException(
                        HttpRuntime.FormatResourceString(SR.Code_not_supported_on_not_controls));
                }

                // Is it a databinding expression?  <%# ... %>
                if (codeBlockBuilder.BlockType == CodeBlockType.DataBinding) {

                    if (InDesigner) {

                        // In the designer, don't use the fancy multipart DataBoundLiteralControl,
                        // which breaks a number of things (ASURT 82925,86738).  Instead, use the
                        // simpler DesignerDataBoundLiteralControl, and do standard databinding
                        // on its Text property.
                        IDictionary attribs = new SortedList();
                        attribs.Add("Text", "<%#" + codeBlockBuilder.Content + "%>");
                        subBuilder = CreateBuilderFromType(
                            Parser, this, typeof(DesignerDataBoundLiteralControl),
                            null, null, attribs, codeBlockBuilder.Line, codeBlockBuilder.SourceFileName);
                    }
                    else {
                        // Get the last builder, and check if it's a DataBoundLiteralControlBuilder
                        object lastBuilder = GetLastBuilder();
                        DataBoundLiteralControlBuilder dataBoundBuilder = lastBuilder as DataBoundLiteralControlBuilder;

                        // If not, then we need to create one.  Otherwise, just append to the
                        // existing one
                        bool fNewDataBoundLiteralControl = false;
                        if (dataBoundBuilder == null) {
                            dataBoundBuilder = new DataBoundLiteralControlBuilder();
                            dataBoundBuilder.Init(_parser, this, typeof(DataBoundLiteralControl),
                                null, null, null);

                            fNewDataBoundLiteralControl = true;

                            // If the previous builder was a string, add it as the first
                            // entry in the composite control.
                            string s = lastBuilder as string;
                            if (s != null) {
                                _subBuilders.RemoveAt(_subBuilders.Count-1);
                                dataBoundBuilder.AddLiteralString(s);
                            }

                        }

                        dataBoundBuilder.AddDataBindingExpression(codeBlockBuilder);

                        if (!fNewDataBoundLiteralControl)
                            return;

                        subBuilder = dataBoundBuilder;
                    }
                }
                else {
                    // Set a flag if there is at least one block of ASP code
                    _fHasAspCode = true;
                }

            }

            if (FIsNonParserAccessor) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Children_not_supported_on_not_controls));
            }

            AddSubBuilder(subBuilder);
        }

        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="ControlBuilder.AppendLiteralString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void AppendLiteralString(string s) {
            // Ignore null strings
            if (s == null)
                return;

            // If we are not building a control, or if our children define
            // properties, we should not get literal strings.  Ignore whitespace
            // ones, and fail for others
            if (FIsNonParserAccessor || FChildrenAsProperties) {

                // If there is a default property, delegate to its builder
                if (_defaultPropBuilder != null) {
                    _defaultPropBuilder.AppendLiteralString(s);
                    return;
                }

                if (!Util.IsWhiteSpaceString(s)) {
                    throw new HttpException(HttpRuntime.FormatResourceString(
                        SR.Literal_content_not_allowed, _ctrlType.FullName, s.Trim()));
                }
                return;
            }

            // Ignore literals that are just whitespace if the control does not want them
            if ((AllowWhitespaceLiterals() == false) && Util.IsWhiteSpaceString(s))
                return;

            // A builder can specify its strings need to be html decoded
            if (HtmlDecodeLiterals()) {
                s = HttpUtility.HtmlDecode(s);
            }

            // If the last builder is a DataBoundLiteralControlBuilder, add the string
            // to it instead of to our list of sub-builders
            object lastBuilder = GetLastBuilder();
            DataBoundLiteralControlBuilder dataBoundBuilder = lastBuilder as DataBoundLiteralControlBuilder;

            if (dataBoundBuilder != null) {
                Debug.Assert(!InDesigner, "!InDesigner");
                dataBoundBuilder.AddLiteralString(s);
            }
            else
                AddSubBuilder(s);
        }

        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.CloseControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void CloseControl() {
        }

        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.HtmlDecodeLiterals"]/*' />
        public virtual bool HtmlDecodeLiterals() {
            return false;
        }

        /*
         * Returns true is it needs SetTagInnerText() to be called.
         */
        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.NeedsTagInnerText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool NeedsTagInnerText() {
            return false;
        }

        /*
         * Give the builder the raw inner text of the tag.
         */
        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.SetTagInnerText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void SetTagInnerText(string text) {
        }

        /*
         * This code is only used in the non-compiled mode.
         * It is used at design-time and when the user calls Page.ParseControl.
         */
        internal virtual object BuildObject() {
            Debug.Assert(InDesigner || NonCompiledPage, "Expected to be in designer mode.");

            // If it has a ConstructorNeedsTagAttribute, it needs a tag name
            ConstructorNeedsTagAttribute cnta = (ConstructorNeedsTagAttribute)
                TypeDescriptor.GetAttributes(ControlType)[typeof(ConstructorNeedsTagAttribute)];

            Object obj;

            if (cnta != null && cnta.NeedsTag) {
                // Create the object, using its ctor that takes the tag name
                Object[] args = new Object[] { TagName };
                obj = HttpRuntime.CreatePublicInstance(_ctrlType, args);
            }
            else {
                // Create the object
                obj = HttpRuntime.CreatePublicInstance(_ctrlType);
            }

            InitObject(obj);
            return obj;
        }

        /*
         * This code is only used in the non-compiled, i.e., designer mode
         */
        internal void InitObject(object obj) {
            Debug.Assert(InDesigner || NonCompiledPage, "Expected to be in designer mode.");

            // Set all the properties that were persisted as tag attributes
            if (_attribSetter != null)
                _attribSetter.SetProperties(obj);

            // Set all the complex properties that were persisted as inner properties
            if (_complexAttribSetter != null)
                _complexAttribSetter.SetProperties(obj);

            if (obj is Control) {
                if (_parser.DesignTimeDataBindHandler != null)
                    ((Control)obj).DataBinding += _parser.DesignTimeDataBindHandler;
            
                if (_boundAttribSetter != null)
                    _boundAttribSetter.SetProperties(obj);
            }

            if (typeof(IParserAccessor).IsAssignableFrom(obj.GetType())) {
                // Build the children
                BuildChildren(obj);
            }

            // Set all the templates
            if (_templateSetter != null)
                _templateSetter.SetProperties(obj);
        }

        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.TagName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string TagName {
            get { return _tagName;}
        }

        internal PropertySetter SimpleAttributeSetter {
            get { return _attribSetter;}
        }

        internal PropertySetter BoundAttributeSetter {
            get { return _boundAttribSetter;}
        }

        internal PropertySetter ComplexAttributeSetter {
            get { return _complexAttribSetter;}
        }

        /*
         * Preprocess all the attributes at parse time, so that we'll be left
         * with as little work as possible when we build the control.
         */
        private void PreprocessAttributes(IDictionary attribs) {
            // Preprocess all the attributes
            for (IDictionaryEnumerator e = attribs.GetEnumerator(); e.MoveNext();) {
                string name = (string) e.Key;
                string value = (string) e.Value;

                PreprocessAttribute(name, value);
            }
        }

        // Parses a databinding expression (e.g. <%# i+1 %>
        private readonly static Regex databindRegex = new DataBindRegex();

        /*
         * If the control has a Property which matches the name of the
         * attribute, create an AttributeInfo structure for it, that will
         * be used at BuildControl time.
         */
        internal void PreprocessAttribute(string attribname,string attribvalue) {
            Match match;

            // Treat a null value as an empty string
            if (attribvalue == null)
                attribvalue = "";

            // Is it a databound attribute?
            if ((match = databindRegex.Match(attribvalue, 0)).Success) {

                // If it's a non compiled page, fail if there is code on it
                if (NonCompiledPage) {
                    throw new HttpException(
                        HttpRuntime.FormatResourceString(SR.Code_not_supported_on_non_compiled_page));
                }

                // Get the piece of code
                string code = match.Groups["code"].Value;

                if (_boundAttribSetter == null) {
                    _boundAttribSetter = new PropertySetter(_ctrlType, InDesigner || NonCompiledPage);
                    _boundAttribSetter.SetDataBound();
                }

                _boundAttribSetter.AddProperty(attribname, code);

                return;
            }

            if (_attribSetter == null)
                _attribSetter = new PropertySetter(_ctrlType, InDesigner || NonCompiledPage);

            _attribSetter.AddProperty(attribname, attribvalue);
        }

        /*
         * This method is used to tell the builder that it's about
         * to be appended to its parent.
         */
        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.OnAppendToParentBuilder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void OnAppendToParentBuilder(ControlBuilder parentBuilder) {

            // If we have a default property, add it to ourselves
            if (_defaultPropBuilder != null) {
                ControlBuilder defaultPropBuilder = _defaultPropBuilder;

                // Need to make it null to avoid infinite recursion
                _defaultPropBuilder = null;
                AppendSubBuilder(defaultPropBuilder);
            }
        }

        /*
         * Create a ControlBuilder for a given tag
         */
        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="BaseControlBuilder.CreateBuilderFromType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static ControlBuilder CreateBuilderFromType(TemplateParser parser,
                                                           ControlBuilder parentBuilder, Type type, string tagName,
                                                           string id, IDictionary attribs, int line, string sourceFileName) {
            Type builderType = null;

            // Check whether the control's class exposes a custom builder type
            ControlBuilderAttribute cba = null;
            object[] attrs = type.GetCustomAttributes(typeof(ControlBuilderAttribute), /*inherit*/ true);
            if ((attrs != null) && (attrs.Length == 1)) {
                Debug.Assert(attrs[0] is ControlBuilderAttribute);
                cba = (ControlBuilderAttribute)attrs[0];
            }

            if (cba != null)
                builderType = cba.BuilderType;

            ControlBuilder builder;
            if (builderType != null) {

                // Make sure the type has the correct base class (ASURT 123677)
                Util.CheckAssignableType(typeof(ControlBuilder), builderType);

                // It does, so use it
                builder = (ControlBuilder)HttpRuntime.CreateNonPublicInstance(builderType);
            }
            else {
                // It doesn't, so use a generic one
                builder = new ControlBuilder();
            }

            // REVIEW: I'm not putting this in Init because it seems like
            // it might not be in the spirit of the method (dbau)
            builder._line = line;
            builder._sourceFileName = sourceFileName;

            // Initialize the builder
            builder.Init(parser, parentBuilder, type, tagName, id, attribs);

            return builder;
        }

        internal ArrayList SubBuilders {
            get { return _subBuilders;}
        }

        internal PropertySetter TemplatesSetter {
            get { return _templateSetter;}
        }

        /// <include file='doc\ControlBuilder.uex' path='docs/doc[@for="ControlBuilder.HasAspCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool HasAspCode {
            get { return _fHasAspCode;}
        }

        /*
         * This code is only used in the designer
         */
        internal virtual void BuildChildren(object parentObj) {
            // Create all the children
            if (_subBuilders != null) {
                IEnumerator en = _subBuilders.GetEnumerator();
                for (int i=0; en.MoveNext(); i++) {
                    object childObj;
                    object cur = en.Current;
                    if (cur is string) {
                        childObj = new LiteralControl((string)cur);
                    }
                    else if (cur is CodeBlockBuilder) {
                        // REVIEW: ignoring ASP blocks in designer
                        // Is this the right behavior?
                        continue;
                    }
                    else {
                        object obj = ((ControlBuilder)cur).BuildObject();
                        childObj = obj;
                    }

                    Debug.Assert(childObj != null);
                    Debug.Assert(typeof(IParserAccessor).IsAssignableFrom(parentObj.GetType()));
                    ((IParserAccessor)parentObj).AddParsedSubObject(childObj);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\databinder.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataBinder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;
    using System.Globalization;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Reflection;
    using System.Security.Permissions;

    /// <include file='doc\DataBinder.uex' path='docs/doc[@for="DataBinder"]/*' />
    /// <devdoc>
    ///    <para> Provides design-time support for RAD designers to 
    ///       generate and parse <see topic='cpconDatabindingExpressionSyntax'/> . This class cannot be inherited.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DataBinder {

        private static readonly char[] expressionPartSeparator = new char[] { '.'};
        private static readonly char[] indexExprStartChars = new char[] { '[', '('};
        private static readonly char[] indexExprEndChars = new char[] { ']', ')'};

        /// <internalonly/>
        public DataBinder() {
        }

        /// <include file='doc\DataBinder.uex' path='docs/doc[@for="DataBinder.Eval"]/*' />
        /// <devdoc>
        ///    <para>Evaluates data binding expressions at runtime. While 
        ///       this method is automatically called when you create data bindings in a RAD
        ///       designer, you can also use it declaratively if you want to simplify the casting
        ///       to a text string to be displayed on a browser. To do so, you must place the
        ///       &lt;%# and %&gt; tags, which are also used in standard ASP.NET data binding, around the data binding expression.</para>
        ///    <para>This method is particularly useful when data binding against controls that 
        ///       are in a templated list.</para>
        ///    <note type="caution">
        ///       Since this method is called at runtime, it can cause performance
        ///       to noticeably slow compared to standard ASP.NET databinding syntax.
        ///       Use this method judiciously.
        ///    </note>
        /// </devdoc>
        public static object Eval(object container, string expression) {
            if (expression == null) {
                throw new ArgumentNullException("expression");
            }

            if (container == null) {
                return null;
            }
            
            string[] expressionParts = expression.Trim().Split(expressionPartSeparator);

            return DataBinder.Eval(container, expressionParts);
        }

        /// <include file='doc\DataBinder.uex' path='docs/doc[@for="DataBinder.Eval1"]/*' />
        /// <devdoc>
        /// </devdoc>
        private static object Eval(object container, string[] expressionParts) {
            Debug.Assert((expressionParts != null) && (expressionParts.Length != 0),
                         "invalid expressionParts parameter");

            object prop;
            int i;

            for (prop = container, i = 0; (i < expressionParts.Length) && (prop != null); i++) {
                string expr = expressionParts[i];
                bool indexedExpr = expr.IndexOfAny(indexExprStartChars) >= 0;

                if (indexedExpr == false) {
                    prop = DataBinder.GetPropertyValue(prop, expr);
                }
                else {
                    prop = DataBinder.GetIndexedPropertyValue(prop, expr);
                }
            }

            return prop;
        }

        /// <include file='doc\DataBinder.uex' path='docs/doc[@for="DataBinder.Eval2"]/*' />
        /// <devdoc>
        ///    <para> Evaluates data binding expressions at runtime and 
        ///       formats the output as text to be displayed in the requesting browser. While this
        ///       method is automatically called when you create data bindings in a RAD designer,
        ///       you can also use it declaratively if you want to simplify the casting to a text
        ///       string to be displayed on a browser. To do so, you must place the &lt;%# and %&gt; tags, which are also used in standard ASP.NET data binding, around
        ///       the data binding expression.</para>
        ///    <para>This method is particularly useful when data binding against controls that 
        ///       are in a templated list.</para>
        ///    <note type="caution">
        ///       Since this method is called at
        ///       runtime, it can cause performance to noticeably slow compared to standard ASP.NET
        ///       databinding syntax. Use this method judiciously, particularly when string
        ///       formatting is not required.
        ///    </note>
        /// </devdoc>
        public static string Eval(object container, string expression, string format) {
            object value = DataBinder.Eval(container, expression);

            if ((value == null) || (value == System.DBNull.Value)) {
                return string.Empty;
            }
            else {
                if ((format == null) || (format.Length == 0)) {
                    return value.ToString();
                }
                else {
                    return string.Format(format, value);
                }
            }
        }

        /// <include file='doc\DataBinder.uex' path='docs/doc[@for="DataBinder.GetPropertyValue"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static object GetPropertyValue(object container, string propName) {
            if (container == null) {
                throw new ArgumentNullException("container");
            }
            if ((propName == null) || (propName.Length == 0)) {
                throw new ArgumentNullException("propName");
            }
            
            object prop = null;

            // get a PropertyDescriptor using case-insensitive lookup
            PropertyDescriptor pd = TypeDescriptor.GetProperties(container).Find(propName, true);
            if (pd != null) {
                prop = pd.GetValue(container);
            }
            else {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.DataBinder_Prop_Not_Found, container.GetType().FullName, propName));
            }

            return prop;
        }

        /// <include file='doc\DataBinder.uex' path='docs/doc[@for="DataBinder.GetPropertyValue1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static string GetPropertyValue(object container, string propName, string format) {
            object value = DataBinder.GetPropertyValue(container, propName);

            if ((value == null) || (value == System.DBNull.Value)) {
                return string.Empty;
            }
            else {
                if ((format == null) || (format.Length == 0)) {
                    return value.ToString();
                }
                else {
                    return string.Format(format, value);
                }
            }
        }

        /// <include file='doc\DataBinder.uex' path='docs/doc[@for="DataBinder.GetIndexedPropertyValue"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static object GetIndexedPropertyValue(object container, string expr) {
            if (container == null) {
                throw new ArgumentNullException("container");
            }
            if ((expr == null) || (expr.Length == 0)) {
                throw new ArgumentNullException("expr");
            }
            
            object prop = null;
            bool intIndex = false;

            int indexExprStart = expr.IndexOfAny(indexExprStartChars);
            int indexExprEnd = expr.IndexOfAny(indexExprEndChars, indexExprStart + 1);

            if ((indexExprStart < 0) || (indexExprEnd < 0) ||
                (indexExprEnd == indexExprStart + 1)) {
                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.DataBinder_Invalid_Indexed_Expr, expr));
            }

            string propName = null;
            object indexValue = null;
            string index = expr.Substring(indexExprStart + 1, indexExprEnd - indexExprStart - 1).Trim();

            if (indexExprStart != 0)
                propName = expr.Substring(0, indexExprStart);

            if (index.Length != 0) {
                if (((index[0] == '"') && (index[index.Length - 1] == '"')) ||
                    ((index[0] == '\'') && (index[index.Length - 1] == '\''))) {
                    indexValue = index.Substring(1, index.Length - 2);
                }
                else {
                    if (Char.IsDigit(index[0])) {
                        // treat it as a number
                        try {
                            indexValue = Int32.Parse(index, CultureInfo.InvariantCulture);
                            intIndex = true;
                        }
                        catch (Exception) {
                            // fall back on string
                            indexValue = index;
                        }
                    }
                    else {
                        // treat as a string
                        indexValue = index;
                    }
                }
            }

            if (indexValue == null) {
                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.DataBinder_Invalid_Indexed_Expr, expr));
            }

            object collectionProp = null;
            if ((propName != null) && (propName.Length != 0)) {
                collectionProp = DataBinder.GetPropertyValue(container, propName);
            }
            else {
                collectionProp = container;
            }

            if (collectionProp != null) {
                if ((collectionProp is Array) && intIndex) {
                    prop = ((object[])collectionProp)[(int)indexValue];
                }
                else if ((collectionProp is IList) && intIndex) {
                    prop = ((IList)collectionProp)[(int)indexValue];
                }
                else {
                    PropertyInfo propInfo =
                        collectionProp.GetType().GetProperty("Item", BindingFlags.Public | BindingFlags.Instance, null, null, new Type[] { indexValue.GetType() }, null);
                    if (propInfo != null) {
                        prop = propInfo.GetValue(collectionProp, new object[] { indexValue});
                    }
                    else {
                        throw new ArgumentException(HttpRuntime.FormatResourceString(SR.DataBinder_No_Indexed_Accessor, collectionProp.GetType().FullName));
                    }
                }
            }

            return prop;
        }

        /// <include file='doc\DataBinder.uex' path='docs/doc[@for="DataBinder.GetIndexedPropertyValue1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static string GetIndexedPropertyValue(object container, string propName, string format) {
            object value = DataBinder.GetIndexedPropertyValue(container, propName);

            if ((value == null) || (value == System.DBNull.Value)) {
                return String.Empty;
            }
            else {
                if ((format == null) || (format.Length == 0)) {
                    return value.ToString();
                }
                else {
                    return string.Format(format, value);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\databindinghandlerattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataBindingHandlerAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;
    using System.ComponentModel;
    using System.Security.Permissions;

    /// <include file='doc\DataBindingHandlerAttribute.uex' path='docs/doc[@for="DataBindingHandlerAttribute"]/*' />
    /// <devdoc>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DataBindingHandlerAttribute : Attribute {
        private string typeName;

        /// <include file='doc\DataBindingHandlerAttribute.uex' path='docs/doc[@for="DataBindingHandlerAttribute.Default"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static readonly DataBindingHandlerAttribute Default = new DataBindingHandlerAttribute();

        /// <include file='doc\DataBindingHandlerAttribute.uex' path='docs/doc[@for="DataBindingHandlerAttribute.DataBindingHandlerAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        public DataBindingHandlerAttribute() {
            this.typeName = String.Empty;
        }
        
        /// <include file='doc\DataBindingHandlerAttribute.uex' path='docs/doc[@for="DataBindingHandlerAttribute.DataBindingHandlerAttribute1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public DataBindingHandlerAttribute(Type type) {
            this.typeName = type.AssemblyQualifiedName;
        }

        /// <include file='doc\DataBindingHandlerAttribute.uex' path='docs/doc[@for="DataBindingHandlerAttribute.DataBindingHandlerAttribute2"]/*' />
        /// <devdoc>
        /// </devdoc>
        public DataBindingHandlerAttribute(string typeName) {
            this.typeName = typeName;
        }

        /// <include file='doc\DataBindingHandlerAttribute.uex' path='docs/doc[@for="DataBindingHandlerAttribute.HandlerTypeName"]/*' />
        /// <devdoc>
        /// </devdoc>
        public string HandlerTypeName {
            get {
                return (typeName != null ? typeName : String.Empty);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\datasourcehelper.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataSourceHelper.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;

    internal sealed class DataSourceHelper {

        private DataSourceHelper() {
        }

        internal static IEnumerable GetResolvedDataSource(object dataSource, string dataMember) {
            if (dataSource == null)
                return null;

            IListSource listSource = dataSource as IListSource;
            if (listSource != null) {
                IList memberList = listSource.GetList();

                if (listSource.ContainsListCollection == false) {
                    // the returned list is itself the list we need to bind to
                    // NOTE: I am ignoring the DataMember parameter... ideally we might have
                    //       thrown an exception, but this would mess up design-time usage
                    //       where the user may change the data source from a DataSet to a
                    //       DataTable.
                    return (IEnumerable)memberList;
                }

                if ((memberList != null) && (memberList is ITypedList)) {
                    ITypedList typedMemberList = (ITypedList)memberList;

                    PropertyDescriptorCollection propDescs = typedMemberList.GetItemProperties(new PropertyDescriptor[0]);
                    if ((propDescs != null) && (propDescs.Count != 0)) {
                        PropertyDescriptor listProperty = null;

                        if ((dataMember == null) || (dataMember.Length == 0)) {
                            listProperty = propDescs[0];
                        }
                        else {
                            listProperty = propDescs.Find(dataMember, true);
                        }

                        if (listProperty != null) {
                            object listRow = memberList[0];
                            object list = listProperty.GetValue(listRow);

                            if ((list != null) && (list is IEnumerable)) {
                                return (IEnumerable)list;
                            }
                        }

                        throw new HttpException(HttpRuntime.FormatResourceString(SR.ListSource_Missing_DataMember, dataMember));
                    }
                    else {
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.ListSource_Without_DataMembers));
                    }
                }
            }

            if (dataSource is IEnumerable) {
                return (IEnumerable)dataSource;
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\databoundliteralcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataBoundLiteralControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/*
 * Control that holds databinding expressions and literals
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.UI {

using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Security.Permissions;

internal class DataBoundLiteralControlBuilder : ControlBuilder {

    internal DataBoundLiteralControlBuilder() {
    }

    internal void AddLiteralString(string s) {

        Debug.Assert(!InDesigner, "!InDesigner");

        // Make sure strings and databinding expressions alternate
        object lastBuilder = GetLastBuilder();
        if (lastBuilder != null && lastBuilder is string) {
            AddSubBuilder(null);
        }
        AddSubBuilder(s);
    }

    internal void AddDataBindingExpression(CodeBlockBuilder codeBlockBuilder) {

        Debug.Assert(!InDesigner, "!InDesigner");

        // Make sure strings and databinding expressions alternate
        object lastBuilder = GetLastBuilder();
        if (lastBuilder == null || lastBuilder is CodeBlockBuilder) {
            AddSubBuilder(null);
        }
        AddSubBuilder(codeBlockBuilder);
    }

    internal int GetStaticLiteralsCount() {
        // it's divided by 2 because half are strings and half are databinding
        // expressions).  '+1' because we always start with a literal string.
        return (SubBuilders.Count+1) / 2;
    }

    internal int GetDataBoundLiteralCount() {
        // it's divided by 2 because half are strings and half are databinding
        // expressions)
        return SubBuilders.Count / 2;
    }
}

/// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DataBoundLiteralControl"]/*' />
/// <devdoc>
/// <para>Defines the properties and methods of the DataBoundLiteralControl class. </para>
/// </devdoc>
[
ToolboxItem(false)
]
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public sealed class DataBoundLiteralControl : Control {
    private string[] _staticLiterals;
    private string[] _dataBoundLiteral;
    private bool _hasDataBoundStrings;

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DataBoundLiteralControl.DataBoundLiteralControl"]/*' />
    /// <internalonly/>
    public DataBoundLiteralControl(int staticLiteralsCount, int dataBoundLiteralCount) {
        _staticLiterals = new string[staticLiteralsCount];
        _dataBoundLiteral = new string[dataBoundLiteralCount];
        PreventAutoID();
    }

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DataBoundLiteralControl.SetStaticString"]/*' />
    /// <internalonly/>
    public void SetStaticString(int index, string s) {
        _staticLiterals[index] = s;
    }

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DataBoundLiteralControl.SetDataBoundString"]/*' />
    /// <internalonly/>
    public void SetDataBoundString(int index, string s) {
        _dataBoundLiteral[index] = s;
        _hasDataBoundStrings = true;
    }

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DataBoundLiteralControl.Text"]/*' />
    /// <devdoc>
    ///    <para>Gets the text content of the data-bound literal control.</para>
    /// </devdoc>
    public string Text {
        get {
            StringBuilder sb = new StringBuilder();

            int dataBoundLiteralCount = _dataBoundLiteral.Length;

            // Append literal and databound strings alternatively
            for (int i=0; i<_staticLiterals.Length; i++) {

                if (_staticLiterals[i] != null)
                    sb.Append(_staticLiterals[i]);

                // Could be null if DataBind() was not called
                if (i < dataBoundLiteralCount && _dataBoundLiteral[i] != null)
                    sb.Append(_dataBoundLiteral[i]);
            }

            return sb.ToString();
        }
    }

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DataBoundLiteralControl.CreateControlCollection"]/*' />
    /// <internalonly/>
    protected override ControlCollection CreateControlCollection() {
        return new EmptyControlCollection(this);
    }

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DataBoundLiteralControl.LoadViewState"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>Loads the previously saved state. Overridden to synchronize Text property with
    ///       LiteralContent.</para>
    /// </devdoc>
    protected override void LoadViewState(object savedState) {
        if (savedState != null) {
            _dataBoundLiteral = (string[]) savedState;
            _hasDataBoundStrings = true;
        }
    }

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DataBoundLiteralControl.SaveViewState"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>The object that contains the state changes. </para>
    /// </devdoc>
    protected override object SaveViewState() {

        // Return null if we didn't get any databound strings
        if (!_hasDataBoundStrings)
            return null;

        // Only save the databound literals to the view state
        return _dataBoundLiteral;
    }

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DataBoundLiteralControl.Render"]/*' />
    /// <internalonly/>
    protected override void Render(HtmlTextWriter output) {

        int dataBoundLiteralCount = _dataBoundLiteral.Length;

        // Render literal and databound strings alternatively
        for (int i=0; i<_staticLiterals.Length; i++) {

            if (_staticLiterals[i] != null)
                output.Write(_staticLiterals[i]);

            // Could be null if DataBind() was not called
            if (i < dataBoundLiteralCount && _dataBoundLiteral[i] != null)
                output.Write(_dataBoundLiteral[i]);
        }
    }
}

/// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DesignerDataBoundLiteralControl"]/*' />
/// <devdoc>
/// <para>Simpler version of DataBoundLiteralControlBuilder, used at design time. </para>
/// </devdoc>
[
DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
ToolboxItem(false)
]
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public sealed class DesignerDataBoundLiteralControl : Control {
    private string _text;

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DesignerDataBoundLiteralControl.DesignerDataBoundLiteralControl"]/*' />
    public DesignerDataBoundLiteralControl() {
        PreventAutoID();
    }

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DesignerDataBoundLiteralControl.Text"]/*' />
    /// <devdoc>
    ///    <para>Gets or sets the text content of the data-bound literal control.</para>
    /// </devdoc>
    public string Text {
        get {
            return _text;
        }
        set {
            _text = (value != null) ? value : String.Empty;
        }
    }

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DesignerDataBoundLiteralControl.CreateControlCollection"]/*' />
    protected override ControlCollection CreateControlCollection() {
        return new EmptyControlCollection(this);
    }

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DesignerDataBoundLiteralControl.LoadViewState"]/*' />
    /// <devdoc>
    ///    <para>Loads the previously saved state. Overridden to synchronize Text property with
    ///       LiteralContent.</para>
    /// </devdoc>
    protected override void LoadViewState(object savedState) {
        if (savedState != null)
            _text = (string) savedState;
    }

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DesignerDataBoundLiteralControl.Render"]/*' />
    /// <devdoc>
    ///    <para>Saves any state that was modified after the control began monitoring state changes.</para>
    /// </devdoc>
    protected override void Render(HtmlTextWriter output) {
        output.Write(_text);
    }

    /// <include file='doc\DataBoundLiteralControl.uex' path='docs/doc[@for="DesignerDataBoundLiteralControl.SaveViewState"]/*' />
    /// <devdoc>
    ///    <para>The object that contains the state changes. </para>
    /// </devdoc>
    protected override object SaveViewState() {
        return _text;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\designtimetemplateparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignTimeTemplateParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Security.Permissions;
    using System.Web;

    /// <include file='doc\DesignTimeTemplateParser.uex' path='docs/doc[@for="DesignTimeTemplateParser"]/*' />
    /// <internalonly/>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DesignTimeTemplateParser {

        private DesignTimeTemplateParser() {
        }

        /// <include file='doc\DesignTimeTemplateParser.uex' path='docs/doc[@for="DesignTimeTemplateParser.ParseControl"]/*' />
        public static Control ParseControl(DesignTimeParseData data) {
            // DesignTimeTemplateParser is only meant for use within the designer
            InternalSecurityPermissions.UnmanagedCode.Demand();

            TemplateParser parser = new PageParser();
            parser.FInDesigner = true;
            parser.DesignerHost = data.DesignerHost;
            parser.DesignTimeDataBindHandler = data.DataBindingHandler;
            parser.Text = data.ParseText;

            parser.Parse();

            ArrayList subBuilders = parser.RootBuilder.SubBuilders;

            if (subBuilders != null) {
                // Look for the first control builder
                IEnumerator en = subBuilders.GetEnumerator();

                for (int i = 0; en.MoveNext(); i++) {
                    object cur = en.Current;
                    if ((cur is ControlBuilder) && !(cur is CodeBlockBuilder)) {
                        // Instantiate the control
                        return (Control)((ControlBuilder)cur).BuildObject();
                    }
                }
            }

            return null;
        }

        /// <include file='doc\DesignTimeTemplateParser.uex' path='docs/doc[@for="DesignTimeTemplateParser.ParseTemplate"]/*' />
        public static ITemplate ParseTemplate(DesignTimeParseData data) {
            // DesignTimeTemplateParser is only meant for use within the designer
            InternalSecurityPermissions.UnmanagedCode.Demand();

            TemplateParser parser = new PageParser();
            parser.FInDesigner = true;
            parser.DesignerHost = data.DesignerHost;
            parser.DesignTimeDataBindHandler = data.DataBindingHandler;
            parser.Text = data.ParseText;

            parser.Parse();

            // Set the Text property of the TemplateBuilder to the input text
            parser.RootBuilder.Text = data.ParseText;

            return parser.RootBuilder;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\control.cs ===
//------------------------------------------------------------------------------
// <copyright file="Control.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {
    using System.Text;
    using System.ComponentModel;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;
    using System.IO;
    using HttpException = System.Web.HttpException;
    using System.Web.Util;
    using System.Web.UI.HtmlControls;
    using Debug=System.Diagnostics.Debug;
    using System.Security.Permissions;

    // Delegates used for the compiled template
    /// <include file='doc\Control.uex' path='docs/doc[@for="RenderMethod"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    public delegate void RenderMethod(HtmlTextWriter output, Control container);
    /// <include file='doc\Control.uex' path='docs/doc[@for="BuildMethod"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate Control BuildMethod();

    /// <include file='doc\Control.uex' path='docs/doc[@for="Control"]/*' />
    /// <devdoc>
    ///    <para>Defines the properties,
    ///       methods, and events that are shared by all server controls
    ///       in the Web Forms page framework.</para>
    /// </devdoc>
    [
    DefaultProperty("ID"),
    DesignerCategory("Code"),
    Designer("System.Web.UI.Design.ControlDesigner, " + AssemblyRef.SystemDesign),
    DesignerSerializer("Microsoft.VSDesigner.WebForms.ControlCodeDomSerializer, " + AssemblyRef.MicrosoftVSDesigner,  "System.ComponentModel.Design.Serialization.CodeDomSerializer, " + AssemblyRef.SystemDesign),
    ToolboxItemFilter("System.Web.UI", ToolboxItemFilterType.Require),
    ToolboxItemAttribute("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Control : IComponent, IParserAccessor, IDataBindingsAccessor {

        private static readonly object EventDataBinding = new object();
        private static readonly object EventInit = new object();
        private static readonly object EventLoad = new object();
        private static readonly object EventUnload = new object();
        private static readonly object EventPreRender = new object();
        private static readonly object EventDisposed = new object();

        internal const char ID_SEPARATOR = ':';
        private const char ID_RENDER_SEPARATOR = '_';

        private DataBindingCollection _dataBindings;

        private string _id;
        // allows us to reuse the id variable to store a calculated id w/o polluting the public getter
        private string _cachedUniqueID;
        private Control _parent;
        private ISite _site;

        // Events
        private EventHandlerList _events;

        // fields related to being a container

        private ControlCollection  _controls;
        private ControlState _controlState;
        private RenderMethod _renderMethod;
        private StateBag _viewState;
        private IDictionary _controlsViewState;

        // Only used if we are a naming container.  It contains all the controls
        // in the namespace.
        private IDictionary _namedControls;
        private int _namedControlsID;

        // The naming container that this control leaves in.  Note that even if
        // this ctrl is a naming container, it will not point to itself, but to
        // the naming container that contains it.
        private Control _namingContainer;
        internal Page _page;

        // const masks into the BitVector32
        private const int idNotCalculated   = 0x0001;
        private const int marked            = 0x0002;
        private const int disableViewState  = 0x0004;
        private const int controlsCreated   = 0x0008;
        private const int invisible         = 0x0010;
        private const int visibleDirty      = 0x0020;
        private const int idNotRequired     = 0x0040;
        private const int isNamingContainer = 0x0080;
        private const int creatingControls  = 0x0100;
        private const int nonBindingContainer = 0x0200;
        private SimpleBitVector32 flags;

        private const string automaticIDPrefix = "_ctl";
        private const int automaticIDCount = 128;
        private static readonly string[] automaticIDs = new string [automaticIDCount] {
                   "_ctl0",   "_ctl1",   "_ctl2",   "_ctl3",   "_ctl4",   "_ctl5",
                   "_ctl6",   "_ctl7",   "_ctl8",   "_ctl9",  "_ctl10",  "_ctl11",
                  "_ctl12",  "_ctl13",  "_ctl14",  "_ctl15",  "_ctl16",  "_ctl17",
                  "_ctl18",  "_ctl19",  "_ctl20",  "_ctl21",  "_ctl22",  "_ctl23",
                  "_ctl24",  "_ctl25",  "_ctl26",  "_ctl27",  "_ctl28",  "_ctl29",
                  "_ctl30",  "_ctl31",  "_ctl32",  "_ctl33",  "_ctl34",  "_ctl35",
                  "_ctl36",  "_ctl37",  "_ctl38",  "_ctl39",  "_ctl40",  "_ctl41",
                  "_ctl42",  "_ctl43",  "_ctl44",  "_ctl45",  "_ctl46",  "_ctl47",
                  "_ctl48",  "_ctl49",  "_ctl50",  "_ctl51",  "_ctl52",  "_ctl53",
                  "_ctl54",  "_ctl55",  "_ctl56",  "_ctl57",  "_ctl58",  "_ctl59",
                  "_ctl60",  "_ctl61",  "_ctl62",  "_ctl63",  "_ctl64",  "_ctl65",
                  "_ctl66",  "_ctl67",  "_ctl68",  "_ctl69",  "_ctl70",  "_ctl71",
                  "_ctl72",  "_ctl73",  "_ctl74",  "_ctl75",  "_ctl76",  "_ctl77",
                  "_ctl78",  "_ctl79",  "_ctl80",  "_ctl81",  "_ctl82",  "_ctl83",
                  "_ctl84",  "_ctl85",  "_ctl86",  "_ctl87",  "_ctl88",  "_ctl89",
                  "_ctl90",  "_ctl91",  "_ctl92",  "_ctl93",  "_ctl94",  "_ctl95",
                  "_ctl96",  "_ctl97",  "_ctl98",  "_ctl99", "_ctl100", "_ctl101",
                 "_ctl102", "_ctl103", "_ctl104", "_ctl105", "_ctl106", "_ctl107",
                 "_ctl108", "_ctl109", "_ctl110", "_ctl111", "_ctl112", "_ctl113",
                 "_ctl114", "_ctl115", "_ctl116", "_ctl117", "_ctl118", "_ctl119",
                 "_ctl120", "_ctl121", "_ctl122", "_ctl123", "_ctl124", "_ctl125",
                 "_ctl126", "_ctl127"
        };

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Control"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.Control'/> class.</para>
        /// </devdoc>
        public Control() {
            if (this is INamingContainer) 
                flags[isNamingContainer] = true;
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ClientID"]/*' />
        /// <devdoc>
        ///    <para>Indicates the control identifier generated by the ASP.NET framework. This 
        ///       property is read-only. </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.Control_ClientID)
        ]
        public virtual string ClientID {
            /*
            *  This property is required to render a unique client-friendly id.
            */
            get {
                // Avoid creating a new string if possible
                string uniqueID = UniqueID;

                // if there's no UniqueID, there can't be a client id
                if (UniqueID == null)
                    return null;
                
                if (uniqueID.IndexOf(ID_SEPARATOR) >= 0) {
                    return uniqueID.Replace(ID_SEPARATOR,ID_RENDER_SEPARATOR);
                }
                return uniqueID;
            }
        }

        // Same as UniqueID, with ':'s replaced by '$'.  This is to work around
        // ASURT 142625.
        internal string UniqueIDWithDollars {
            get {
                // Avoid creating a new string if possible
                string uniqueID = UniqueID;

                // if there's no UniqueID, there can't be a client id
                if (uniqueID == null)
                    return null;
                
                if (uniqueID.IndexOf(ID_SEPARATOR) >= 0) {
                    return uniqueID.Replace(ID_SEPARATOR,'$');
                }
                return uniqueID;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Disposed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        WebSysDescription(SR.Control_OnDisposed)
        ]
        public event EventHandler Disposed {
            add {
                Events.AddHandler(EventDisposed, value);
            }
            remove {
                Events.RemoveHandler(EventDisposed, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Context"]/*' />
        /// <devdoc>
        /// <para>Gets the <see langword='HttpContext'/> object of the current Web request. If 
        ///    the control's context is <see langword='null'/>, this will be the context of the
        ///    control's parent, unless the parent control's context is <see langword='null'/>.
        ///    If this is the case, this will be equal to the HttpContext property.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        protected virtual HttpContext Context {
            /*
             * Request context containing the intrinsics
             */
            get {
                if (_page != null) {
                    return _page.Context;
                }
                return HttpContext.Current;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Events"]/*' />
        /// <devdoc>
        ///    <para>Indicates the list of event handler delegates for the control. This property 
        ///       is read-only.</para>
        /// </devdoc>
        protected EventHandlerList Events {
            get {
                if (_events == null) {
                    _events = new EventHandlerList();
                }
                return _events;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ID"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the identifier for the control. Setting the 
        ///       property on a control allows programmatic access to the control's properties. If
        ///       this property is not specified on a control, either declaratively or
        ///       programmatically, then you cannot write event handlers and the like for the control.</para>
        /// </devdoc>
        [
        ParenthesizePropertyName(true),
        MergableProperty(false),
        WebSysDescription(SR.Control_ID)
        ]
        public virtual string ID {
            get {
                if (!flags[idNotCalculated]) {
                    return null;
                }
                return _id;
            }
            set {
                // allow the id to be unset
                if (value != null && value.Length == 0)
                    value = null;
                
                string oldID = _id;

                _id = value;
                ClearCachedUniqueIDRecursive();
                flags[idNotCalculated] = true;

                // Update the ID in the naming container
                if ((_namingContainer != null) && (oldID != null)) {
                    _namingContainer.DirtyNameTable();
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.EnableViewState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the control should maintain its view
        ///       state, and the view state of any child control in contains, when the current
        ///       page request ends.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(true),
        WebSysDescription(SR.Control_MaintainState)
        ]
        public virtual bool EnableViewState {
            get {
                return !flags[disableViewState];
            }
            set {
                flags[disableViewState] = !value;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.NamingContainer"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a reference to the current control's naming container.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.Control_NamingContainer)
        ]
        public virtual Control NamingContainer {
            get {
                if (_namingContainer == null) {
                    if (_parent != null) {
                        // Search for the closest naming container in the tree
                        if (_parent.flags[isNamingContainer])
                            _namingContainer = _parent;
                        else
                            _namingContainer = _parent.NamingContainer;
                    }
                }

                return _namingContainer;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.BindingContainer"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Returns the databinding container of this control.  In most cases,
        ///     this is the same as the NamingContainer. But when using LoadTemplate(),
        ///     we get into a situation where that is not the case (ASURT 94138)</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        EditorBrowsable(EditorBrowsableState.Never)
        ]
        public Control BindingContainer {
            get {
                Control bindingContainer = NamingContainer;
                if (bindingContainer.flags[nonBindingContainer])
                    bindingContainer = bindingContainer.BindingContainer;

                return bindingContainer;
            }
        }

        internal void SetNonBindingContainer() { flags[nonBindingContainer] = true; }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Page"]/*' />
        /// <devdoc>
        /// <para> Gets the <see cref='System.Web.UI.Page'/> object that contains the
        ///    current control.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.Control_Page)
        ]
        public virtual Page Page {
            get {
                if (_page == null) {
                    if (_parent != null) {
                        _page = _parent.Page;
                    }
                }
                return _page;
            }

            set {
                // This is necessary because we need to set the page in generated
                // code before controls are added to the tree (ASURT 75330)
                Debug.Assert(_page == null);
                Debug.Assert(_parent == null);
                _page = value;
            }
        }

        /*
         * Determine whether this control is a descendent of the passed in control
         */
        internal bool IsDescendentOf(Control ancestor) {
            if (this == ancestor)
                return true;

            if (_parent == null)
                return false;

            return _parent.IsDescendentOf(ancestor);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Parent"]/*' />
        /// <devdoc>
        ///    <para> Gets the current control's parent control in the UI hierarchy.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.Control_Parent)
        ]
        public virtual Control Parent {
            get {
                return _parent;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.TemplateSourceDirectory"]/*' />
        /// <devdoc>
        ///    <para> Gets the virtual directory of the Page or UserControl that contains this control.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.Control_TemplateSourceDirectory)
        ]
        public virtual string TemplateSourceDirectory {
            get {
                if (_parent == null) {
                    return String.Empty;
                }

                return _parent.TemplateSourceDirectory;
            }
        }

        internal ControlState ControlState {
            get { return _controlState; }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Site"]/*' />
        /// <devdoc>
        ///    <para>Indicates the site information for the control.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        EditorBrowsable(EditorBrowsableState.Advanced),
        WebSysDescription(SR.Control_Site)
        ]
        public ISite Site {
            get {
                return _site;
            }

            set {
                _site = value;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Visible"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value that indicates whether a control should be rendered on
        ///       the page.
        ///    </para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(true),
        WebSysDescription(SR.Control_Visible)
        ]
        public virtual bool Visible {
            get {
                if (flags[invisible])
                    return false;
                else if (_parent != null)
                    return _parent.Visible;
                else
                    return true;
                
                
            }
            set {
                bool visible = !flags[invisible];
                if (visible != value) {
                    flags[invisible] = !value;
                    if (flags[marked]) {
                        flags[visibleDirty] = true;
                    }
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UniqueID"]/*' />
        /// <devdoc>
        ///    <para> Gets the unique, hierarchically-qualified identifier for 
        ///       a control. This is different from the ID property, in that the fully-qualified
        ///       identifier includes the identifier for the control's naming container.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.Control_UniqueID)
        ]
        public virtual string UniqueID {
            get {
                if (_cachedUniqueID != null) {
                    return _cachedUniqueID;
                }
                
                if (_namingContainer != null) {
                    // if the ID is null at this point, we need to have one created and the control added to the
                    // naming container.
                    if (_id == null) { 
                        GenerateAutomaticID();
                    }

                    if (_page == _namingContainer) {
                        _cachedUniqueID = _id;
                    }
                    else {
                        string uniqueIDPrefix = _namingContainer.GetUniqueIDPrefix();
                        if (uniqueIDPrefix.Length == 0) {
                            // In this case, it is probably a naming container that is not sited, so we don't want to cache it
                            return _id;
                        }
                        else {
                            _cachedUniqueID = _namingContainer.GetUniqueIDPrefix() + _id;
                        }
                    }

                    return _cachedUniqueID;
                }
                else {
                    // punt if we're not sited
                    return _id;
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DataBinding"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control binds to a data source. Notifies the control to perform any data binding during this event.</para>
        /// </devdoc>
        [
        WebCategory("Data"),
        WebSysDescription(SR.Control_OnDataBind)
        ]
        public event EventHandler DataBinding {
            add {
                Events.AddHandler(EventDataBinding, value);
            }
            remove {
                Events.RemoveHandler(EventDataBinding, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Init"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is initialized, the first step in the page lifecycle. Controls should 
        ///       perform any initialization steps that are required to create and set up an
        ///       instantiation.</para>
        /// </devdoc>
        [
        WebSysDescription(SR.Control_OnInit)
        ]
        public event EventHandler Init {
            add {
                Events.AddHandler(EventInit, value);
            }
            remove {
                Events.RemoveHandler(EventInit, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Load"]/*' />
        /// <devdoc>
        /// <para>Occurs when the control is loaded to the <see cref='System.Web.UI.Page'/> object. Notifies the control to perform any steps that 
        ///    need to occur on each page request.</para>
        /// </devdoc>
        [
        WebSysDescription(SR.Control_OnLoad)
        ]
        public event EventHandler Load {
            add {
                Events.AddHandler(EventLoad, value);
            }
            remove {
                Events.RemoveHandler(EventLoad, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.PreRender"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is about to render. Controls 
        ///       should perform any pre-rendering steps necessary before saving view state and
        ///       rendering content to the <see cref='System.Web.UI.Page'/> object.</para>
        /// </devdoc>
        [
        WebSysDescription(SR.Control_OnPreRender)
        ]
        public event EventHandler PreRender {
            add {
                Events.AddHandler(EventPreRender, value);
            }
            remove {
                Events.RemoveHandler(EventPreRender, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Unload"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is unloaded from memory. Controls should perform any 
        ///       final cleanup before this instance of it is </para>
        /// </devdoc>
        [
        WebSysDescription(SR.Control_OnUnload)
        ]
        public event EventHandler Unload {
            add {
                Events.AddHandler(EventUnload, value);
            }
            remove {
                Events.RemoveHandler(EventUnload, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnDataBinding"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='DataBinding'/> event. This 
        ///    notifies a control to perform any data binding logic that is associated with it.</para>
        /// </devdoc>
        protected virtual void OnDataBinding(EventArgs e) {
            if (_events != null) {
                EventHandler handler = _events[EventDataBinding] as EventHandler;
                if (handler != null) {
                    handler(this, e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DataBind"]/*' />
        /// <devdoc>
        ///    <para> Causes data binding to occur on the invoked control and all of its child
        ///       controls.</para>
        /// </devdoc>
        public virtual void DataBind() {
            // Do our own databinding
            OnDataBinding(EventArgs.Empty);

            
            // Do all of our children's databinding
            if (_controls != null) {
                string oldmsg = _controls.SetCollectionReadOnly(SR.Parent_collections_readonly);
                
                int controlCount = _controls.Count;
                for (int i=0; i < controlCount; i++)
                    _controls[i].DataBind();
                
                _controls.SetCollectionReadOnly(oldmsg);
            }
        }

        internal void PreventAutoID() {
            // controls that are also naming containers must always get an id
            if (flags[isNamingContainer] == false) {
                flags[idNotRequired] = true;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AddParsedSubObject"]/*' />
        /// <devdoc>
        ///    <para>Notifies the control that an element, XML or HTML, was parsed, and adds it to 
        ///       the control.</para>
        /// </devdoc>
        protected virtual void AddParsedSubObject(object obj) {
            Control control = obj as Control;
            if (control != null) {
                Controls.Add(control);
            }
        }

        internal void ClearCachedUniqueIDRecursive() {
            _cachedUniqueID = null;

            if (_controls != null) {
                int controlCount = _controls.Count;
                for (int i = 0; i < controlCount; i++) {
                    _controls[i].ClearCachedUniqueIDRecursive();
                }
            }
        }

        private void GenerateAutomaticID() {
            Debug.Assert(_namingContainer != null);
            Debug.Assert(_id == null);

            // Calculate the automatic ID. For performance and memory reasons 
            // we look up a static table entry if possible
            int idNo = _namingContainer._namedControlsID++;
            if (idNo < automaticIDCount) {
                _id = automaticIDs[idNo];
            }
            else {
                _id = automaticIDPrefix + idNo.ToString(NumberFormatInfo.InvariantInfo);
            }

            _namingContainer.DirtyNameTable();
        }

        internal virtual string GetUniqueIDPrefix() {
            string uniqueID = UniqueID;
            if (uniqueID != null && uniqueID.Length > 0) {
                return uniqueID + ID_SEPARATOR.ToString();
            }
            return "";
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnInit"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='Init'/> event. This notifies the control to perform 
        ///    any steps necessary for its creation on a page request.</para>
        /// </devdoc>
        protected virtual void OnInit(EventArgs e) {
            if (_events != null) {
                EventHandler handler = _events[EventInit] as EventHandler;
                if (handler != null) {
                    handler(this, e);
                }
            }
        }

        internal void InitRecursive(Control namingContainer) {
            if (_controls != null) {
                if (flags[isNamingContainer]) {
                    namingContainer = this;
                }            

                string oldmsg = _controls.SetCollectionReadOnly(SR.Parent_collections_readonly);
                
                int controlCount = _controls.Count;
                for (int i = 0; i < controlCount; i++) {
                    Control control = _controls[i];

                    // Propagate the page and namingContainer
                    control._namingContainer = namingContainer;
                    if ((namingContainer != null) && (control._id == null) && !control.flags[idNotRequired]) {
                        control.GenerateAutomaticID();
                    }
                    control._page = _page;

                    control.InitRecursive(namingContainer);
                }
                _controls.SetCollectionReadOnly(oldmsg);
                
            }

            // Only make the actual call if it hasn't already happened (ASURT 111303)
            if (_controlState < ControlState.Initialized) {

                // We need to distinguish between ChildrenInitialized and Initialized
                // to cover certain scenarios (ASURT 127318)
                _controlState = ControlState.ChildrenInitialized;

                OnInit(EventArgs.Empty);

                _controlState = ControlState.Initialized;
            }

            // track all subsequent state changes
            TrackViewState();

#if DEBUG
            ControlInvariant();
#endif
        }

#if DEBUG
        /// <devdoc>
        ///    <para>This should be used to assert internal state about the control</para>
        /// </devdoc>
        internal void ControlInvariant() {

            // If the control is initialized, the naming container and page should have been pushed in
            if (_controlState >= ControlState.Initialized) {
                if (Site != null && Site.DesignMode) {
                    // Top-level UserControls do not have a page or a naming container in the designer
                    // hence the special casing.

                    Debug.Assert((_namingContainer != null) || (this is Page) || (this is UserControl));

                    // CONSIDER(nikhilko): Uncomment this once Ibrahim has checked in the code
                    //                   in vs to always ensure a page (even for user controls)
                    // Note we might not need this special casing of checking Site etc. at all.
                    //Debug.Assert((_page != null) || (this is UserControl));
                }
                else {
                    if (!(this is Page)) {
                        Debug.Assert(_namingContainer != null);
                    }
                    Debug.Assert(_page != null);
                }
            }
            // If naming container is set and the name table exists, the ID should exist in it.
            if (_namingContainer != null && _namingContainer._namedControls != null && _id != null) {
                Debug.Assert(_namingContainer._namedControls.Contains(_id));
            }
        }
#endif 

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ClearChildViewState"]/*' />
        /// <devdoc>
        ///    <para>Deletes the view state information for all of the current control's child 
        ///       controls.</para>
        /// </devdoc>
        protected void ClearChildViewState() {
            _controlsViewState = null;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.HasChildViewState"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the current control's children have any saved view state 
        ///       information. This property is read-only.</para>
        /// </devdoc>
        protected bool HasChildViewState {
            get {
                return (_controlsViewState != null && _controlsViewState.Count > 0);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.LoadViewState"]/*' />
        /// <devdoc>
        ///    <para>Restores the view state information from a previous page 
        ///       request that was saved by the Control.SavedState method.</para>
        /// </devdoc>
        protected virtual void LoadViewState(object savedState) {
            if (savedState != null) {
                ViewState.LoadViewState(savedState);

                // Load values cached out of view state
                object visible = ViewState["Visible"];
                if (visible != null) {
                    flags[invisible] = !((bool)visible);
                    flags[visibleDirty] = true;
                }
            }
        }

        internal void LoadViewStateRecursive(object savedState) {

            // nothing to do if we have no state
            if (savedState == null || flags[disableViewState])
                return;

            Triplet allSavedState = (Triplet)savedState;
            
            if (Page != null && Page.IsPostBack) {
                try {
                    LoadViewState(allSavedState.First);
                }
                catch (InvalidCastException) {
                     // catch all viewstate loading problems with casts.  They are most likely changed control trees.
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Controls_Cant_Change_Between_Posts));
                }
                catch (IndexOutOfRangeException) {
                     // catch all viewstate loading problems with indeces.  They are most likely changed control trees.
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Controls_Cant_Change_Between_Posts));
                }
            }

            if (allSavedState.Second != null) {
                ArrayList indices = (ArrayList) allSavedState.Second;
                ArrayList saved = (ArrayList) allSavedState.Third;

                ControlCollection ctrlColl = Controls;
                int ctrlCount = ctrlColl.Count;
                int indexCount = indices.Count;
                for (int i=0; i<indexCount; i++) {
                    int current = (int) indices[i];     // index of control with state
                    if (current < ctrlCount) {
                        // we have a control for this state blob
                        ctrlColl[current].LoadViewStateRecursive(saved[i]);
                    }
                    else {
                        // couldn't find a control for this state blob, save it for later
                        if (_controlsViewState == null)
                            _controlsViewState = new Hashtable();

                        _controlsViewState[current] = saved[i];
                    }
                }
            } 

            _controlState = ControlState.ViewStateLoaded;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.GetSecureMappedPath"]/*' />
        /// <devdoc>
        /// <para> 
        ///   This function takes a virtual path, that is a relative or root relative URL without a protocol.
        ///   It returns the mapped physcial file name relative to the template source. It throws an exception if
        ///   there is insufficient security access to read or investigate the mapped result. This should be used
        ///   by controls that can read files and live in fully trusted DLLs such as System.Web.dll to prevent
        ///   security issues. The exception thrown does not give away information about the mapping.
        /// </para>
        /// </devdoc>
        protected string MapPathSecure(string virtualPath) {

            string absolutePath = UrlPath.Combine(TemplateSourceDirectory, virtualPath);
            string physicalPath = Context.Request.MapPath(absolutePath);

            // Security check
            if (!HttpRuntime.HasFilePermission(physicalPath)) {
                // It is important not to give away the mapped physical path, which is an information leak.
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Access_denied_to_vpath, virtualPath));
            }
            return physicalPath;
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnLoad"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='Load'/> 
        /// event. This notifies the control that it should perform any work that needs to
        /// occur for each page request.</para>
        /// </devdoc>
        protected virtual void OnLoad(EventArgs e) {
            if (_events != null) {
                EventHandler handler = _events[EventLoad] as EventHandler;
                if (handler != null) {
                    handler(this, e);
                }
            }

        }

        internal void LoadRecursive() {

            // Only make the actual call if it hasn't already happened (ASURT 111303)
            if (_controlState < ControlState.Loaded)
                OnLoad(EventArgs.Empty);
    
            // Call Load on all our children
            if (_controls != null) {
                string oldmsg = _controls.SetCollectionReadOnly(SR.Parent_collections_readonly);
                    
                int controlCount = _controls.Count;
                for (int i = 0; i < controlCount; i++) {
                    _controls[i].LoadRecursive();
                }
                
                _controls.SetCollectionReadOnly(oldmsg);
            }

            if (_controlState < ControlState.Loaded)
                _controlState = ControlState.Loaded;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnPreRender"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='PreRender'/> event. This method uses event arguments 
        ///    to pass the event data to the control.</para>
        /// </devdoc>
        protected virtual void OnPreRender(EventArgs e) {
            if (_events != null) {
                EventHandler handler = _events[EventPreRender] as EventHandler;
                if (handler != null) {
                    handler(this, e);
                }
            }
        }

        internal void PreRenderRecursiveInternal() {
            if (!flags[invisible]) {
                EnsureChildControls();

                OnPreRender(EventArgs.Empty);

                if (_controls != null) {
                    string oldmsg = _controls.SetCollectionReadOnly(SR.Parent_collections_readonly);
                    
                    int controlCount = _controls.Count;
                    for (int i=0; i < controlCount; i++) {
                        _controls[i].PreRenderRecursiveInternal();
                    }
                    _controls.SetCollectionReadOnly(oldmsg);
                }
            }
            _controlState = ControlState.PreRendered;
        }

        /*
         * Walk the tree and fill in profile information
         */
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.BuildProfileTree"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Gathers information about the control and delivers it to the <see cref='System.Web.UI.Page.Trace'/> 
        /// property to be displayed when tracing is enabled for the page.</para>
        /// </devdoc>
        protected void BuildProfileTree(string parentId, bool calcViewState) {
            // estimate the viewstate size.  
            calcViewState = calcViewState && (!flags[disableViewState]);
            int viewstatesize;
            if (calcViewState)
                viewstatesize = LosFormatter.EstimateSize(SaveViewState());
            else
                viewstatesize = 0;
 
            // give it all to the profiler
            Page.Trace.AddNewControl(UniqueID, parentId, this.GetType().FullName, viewstatesize);

            if (_controls != null) {
                int controlCount = _controls.Count;
                for (int i = 0; i < controlCount; i++) {
                    _controls[i].BuildProfileTree(UniqueID, calcViewState);
                }
            }
        }

        // Save modified state the control would like restored on the postback. 
        // Return null if there is no state to save.
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SaveViewState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves view state for use with a later <see cref='System.Web.UI.Control.LoadViewState'/>
        ///       request.
        ///    </para>
        /// </devdoc>
        protected virtual object SaveViewState() {
            // Save values cached out of view state
            if (flags[visibleDirty]) {
                ViewState["Visible"] = !flags[invisible];
            }
            if (_viewState != null)
                return _viewState.SaveViewState();

            return null;
        }

        // Answer any state this control or its descendants want to save on freeze. 
        // The format for saving is Triplet(myState, ArrayList childIDs, ArrayList childStates), 
        // where myState or childStates and childIDs may be null.
        internal object SaveViewStateRecursive() {
            if (flags[disableViewState])
                return null;

            object mySavedState = SaveViewState();

            ArrayList indices = null; 
            ArrayList states  = null; 

            if (_controls != null) {
                int ctrlCount = _controls.Count;

                for (int i=0; i < ctrlCount; i++) {
                    Control child = _controls[i];
                    object childState = child.SaveViewStateRecursive();
                    if (childState != null) {
                        if (indices == null) {
                            indices = new ArrayList();
                            states  = new ArrayList();
                        }

                        indices.Add(i);
                        states.Add(childState);
                    }
                }
            }

            Triplet allSavedState = null;
            if (mySavedState != null || indices != null)
                allSavedState = new Triplet(mySavedState, indices, states);

            return allSavedState;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Render"]/*' />
        /// <devdoc>
        /// <para>Outputs control content to a provided HTMLTextWriter 
        /// output stream.</para>
        /// </devdoc>
        protected virtual void Render(HtmlTextWriter writer) {
            RenderChildren(writer);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RenderChildren"]/*' />
        /// <devdoc>
        /// <para>Outputs the content of a control's children to a provided HTMLTextWriter
        /// output stream.</para>
        /// </devdoc>
        protected virtual void RenderChildren(HtmlTextWriter writer) {
            // If we have a delegate, use it for the rendering.
            // This happens when there is some ASP code.
            if (_renderMethod != null) {
                _renderMethod(writer, this);
                return;
            }

            // Otherwise, do the rendering ourselves
            if (_controls != null) {
                int controlCount = _controls.Count;
                for (int i=0; i < controlCount; i++) {
                    _controls[i].RenderControl(writer);
                }
            }

        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RenderControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void RenderControl(HtmlTextWriter writer) {
            if (!flags[invisible]) {
                HttpContext context = (_page == null) ? null : _page._context;
                if (context  != null && context.TraceIsEnabled) {
                    int presize = context.Response.GetBufferedLength();
                
                    Render(writer);
                    
                    int postsize = context.Response.GetBufferedLength();
                    context.Trace.AddControlSize(UniqueID, postsize - presize);
                }
                else
                    Render(writer);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnUnload"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnUnload(EventArgs e) {
            if (_events != null) {
                EventHandler handler = _events[EventUnload] as EventHandler;
                if (handler != null) {
                    handler(this, e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Dispose"]/*' />
        /// <devdoc>
        ///    <para>Enables a control to perform final cleanup.</para>
        /// </devdoc>
        public virtual void Dispose() {
            IContainer container = null;

            if (_site != null) {
                container = (IContainer)_site.GetService(typeof(IContainer));
                if (container != null) {
                    container.Remove(this);
                    EventHandler disp = Events[EventDisposed] as EventHandler;
                    if (disp != null)
                        disp(this, EventArgs.Empty);
                }
            }
        }


        internal void UnloadRecursive(bool dispose) {
            if (_controls != null) {
                string oldmsg = _controls.SetCollectionReadOnly(SR.Parent_collections_readonly);
            
                int controlCount = _controls.Count;
                for (int i = 0; i < controlCount; i++)
                    _controls[i].UnloadRecursive(dispose);

                _controls.SetCollectionReadOnly(oldmsg);
            }

            OnUnload(EventArgs.Empty);

            // CONSIDER - sanity check: should parent be disposed before children?
            if (dispose) 
                Dispose();
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RaiseBubbleEvent"]/*' />
        /// <devdoc>
        ///    <para>Assigns an sources of the event and its information up the page control 
        ///       hierarchy until they reach the top of the control tree. </para>
        /// </devdoc>
        protected void RaiseBubbleEvent(object source, EventArgs args) {
            Control currentTarget = _parent;
            while (currentTarget != null) {
                if (currentTarget.OnBubbleEvent(source, args)) {
                    return;
                }
                currentTarget = currentTarget.Parent;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnBubbleEvent"]/*' />
        /// <devdoc>
        ///    <para>Determines whether the event for the control should be passed up the page's 
        ///       control hierarchy.</para>
        /// </devdoc>
        protected virtual bool OnBubbleEvent(object source, EventArgs args) {
            return false;
        }


        // Members related to being a container

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Controls"]/*' />
        /// <devdoc>
        ///    <para> Gets a ControlCollection object that represents the child controls for a specified control in the
        ///       UI hierarchy.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.Control_Controls)
        ]
        public virtual ControlCollection Controls {
            get {
                if (_controls == null) {
                    _controls = CreateControlCollection();
                }
                return _controls;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ViewState"]/*' />
        /// <devdoc>
        ///    <para>Indicates a dictionary of state information that allows you to save and restore
        ///       the state of a control across multiple requests for the same page.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.Control_State)
        ]
        protected virtual StateBag ViewState {
            get {
                if (_viewState != null) {   // create a StateBag on demand; WebControl makes its case sensitive
                    return _viewState;
                }

                _viewState = new StateBag(ViewStateIgnoresCase);
                if (IsTrackingViewState)
                    _viewState.TrackViewState();
                return _viewState;
            }
        }

        // fast enough that we cam always use it.
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ViewStateIgnoresCase"]/*' />
        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Web.UI.StateBag'/> object is case-insensitive.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        protected virtual bool ViewStateIgnoresCase {
            get {
                return false;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AddedControl"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected internal virtual void AddedControl(Control control, int index) {
            if (control._parent != null) {
                control._parent.Controls.Remove(control);
            }

            control._parent = this;
            control._page = _page;

            // We only add to naming container if it is available. Otherwise, it will be pushed through
            // during InitRecursive
            Control namingContainer = flags[isNamingContainer] ? this : _namingContainer;
            if (namingContainer != null) {
                control._namingContainer = namingContainer;
                if (control._id == null && !control.flags[idNotRequired]) {
                    // this will also dirty the name table in the naming container
                    control.GenerateAutomaticID();
                }
                else if (control._id != null || control._controls != null) {
                    // If the control has and ID, or has children (which *may* themselves
                    // have ID's), we need to dirty the name table (ASURT 100557)
                    namingContainer.DirtyNameTable();
                }
            }

            /*
             * The following is for times when AddChild is called after CreateChildControls. This
             * allows users to add children at any time in the creation process without having
             * to understand the underlying machinery.
             * Note that if page is null, it means we haven't been attached to a container ourselves.
             * If this is true, when we are, our children will be recursively set up.
             */
            if (_controlState >= ControlState.ChildrenInitialized) {
                Debug.Assert(namingContainer != null);
                control.InitRecursive(namingContainer);
                
                if (_controlState >= ControlState.ViewStateLoaded) {
                    object viewState = null;
                    if (_controlsViewState != null) {
                        viewState = _controlsViewState[index];

                        // This solution takes the conservative approach that once viewstate has been
                        // applied to a child control, it is thrown away.  This eliminates inadvertently
                        // setting viewstate on the wrong control, which can occur in scenarios where
                        // the child control collection is being manipulated via code.  Probably need
                        // to provide a feature where programmer can control whether to reapply viewstate
                        // or not.
                        _controlsViewState.Remove(index);
                    }

                    control.LoadViewStateRecursive(viewState);

                    if (_controlState >= ControlState.Loaded) {
                        control.LoadRecursive();

                        if (_controlState >= ControlState.PreRendered) 
                            control.PreRenderRecursiveInternal();
                    }
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CreateControlCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual ControlCollection CreateControlCollection() {
            return new ControlCollection(this);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CreateChildControls"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notifies any controls that use composition-based implementation to create any
        ///       child controls they contain in preperation for postback or rendering.
        ///    </para>
        /// </devdoc>
        protected virtual void CreateChildControls() {
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ChildControlsCreated"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the control's child controls have been created.</para>
        /// </devdoc>
        protected bool ChildControlsCreated {
            get {
                return flags[controlsCreated];
            }
            set {
                if (!value && flags[controlsCreated]) {
                    Controls.Clear();
                }
                flags[controlsCreated] = value;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ResolveUrl"]/*' />
        /// <devdoc>
        ///    <para>Make a URL absolute using the TemplateSourceDirectory.  The returned URL is for
        ///        client use, and will contain the session cookie if appropriate.</para>
        /// </devdoc>
        public string ResolveUrl(string relativeUrl) {
            if (relativeUrl == null) {
                throw new ArgumentNullException("relativeUrl");
            }

            // check if its empty or already absolute
            if ((relativeUrl.Length == 0) || (UrlPath.IsRelativeUrl(relativeUrl) == false)) {
                return relativeUrl;
            }

            string baseUrl = TemplateSourceDirectory;
            if (baseUrl.Length == 0) {
                return relativeUrl;
            }

            // first make it absolute
            string url = UrlPath.Combine(baseUrl, relativeUrl);

            // include the session cookie if available (ASURT 47658)
            return Context.Response.ApplyAppPathModifier(url);
        }

        /// <devdoc>
        ///    <para> Return a URL that is suitable for use on the client.
        ///     If the URL is absolute, return it unchanged.  If it is relative, turn it into a
        ///     relative URL that is correct from the point of view of the current request path
        ///     (which is what the browser uses for resolution).</para>
        /// </devdoc>
        internal string ResolveClientUrl(string relativeUrl) {
            if (relativeUrl == null) {
                throw new ArgumentNullException("relativeUrl");
            }

            string tplSourceDir = TemplateSourceDirectory;
            if (tplSourceDir.Length == 0) {
                return relativeUrl;
            }

            string baseRequestDir = Context.Request.BaseDir;

            // If the path is app relative (~/...), we cannot take shortcuts, since
            // the ~ is meaningless on the client, and must be resolved
            if (!UrlPath.IsAppRelativePath(relativeUrl)) {

                // If the template source directory is the same as the directory of the request,
                // we don't need to do any adjustments to the input path
                if (string.Compare(baseRequestDir, tplSourceDir, true, CultureInfo.InvariantCulture) == 0)
                    return relativeUrl;

                // check if it's empty or absolute
                if ((relativeUrl.Length == 0) || (!UrlPath.IsRelativeUrl(relativeUrl))) {
                    return relativeUrl;
                }
            }

            // first make it absolute
            string url = UrlPath.Combine(tplSourceDir, relativeUrl);

            // Make sure the path ends with a slash before calling MakeRelative
            baseRequestDir = UrlPath.AppendSlashToPathIfNeeded(baseRequestDir);

            // Now, make it relative to the current request, so that the client will
            // compute the correct path
            return UrlPath.MakeRelative(baseRequestDir, url);
        }

        internal void DirtyNameTable() {
            Debug.Assert(this is INamingContainer);
            _namedControls = null;
        }

        private void EnsureNamedControlsTable() {
            Debug.Assert(this is INamingContainer);
            Debug.Assert(_namedControls == null);
            Debug.Assert(HasControls());

            _namedControls = new HybridDictionary(/*initialSize*/ _namedControlsID, /*caseInsensitive*/ true);
            FillNamedControlsTable(this, _controls);
        }

        private void FillNamedControlsTable(Control namingContainer, ControlCollection controls) {
            Debug.Assert(namingContainer._namedControls != null);
            Debug.Assert((controls != null) && (controls.Count != 0));

            int controlCount = controls.Count;
            for (int i=0; i < controlCount; i++) {
                Control control = controls[i];
                if (control._id != null) {
#if DEBUG
                    if (control._namingContainer != null) {
                        Debug.Assert(control._namingContainer == namingContainer);
                    }
#endif // DEBUG
                    try {
                        namingContainer._namedControls.Add(control._id, control);
                    }
                    catch (Exception) {
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Duplicate_id_used, control._id, "FindControl"));
                    }
                }
                if (control.HasControls() && (control.flags[isNamingContainer] == false)) {
                    FillNamedControlsTable(namingContainer, control.Controls);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.FindControl"]/*' />
        /// <devdoc>
        ///    <para>Searches the current naming container for a control with 
        ///       the specified <paramref name="id"/> .</para>
        /// </devdoc>
        public virtual Control FindControl(String id) {
            return FindControl(id, 0);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.FindControl1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Searches the current naming container for a control with the specified 
        ///    <paramref name="id"/> and an offset to aid in the 
        ///       search.</para>
        /// </devdoc>
        protected virtual Control FindControl(String id, int pathOffset) {
            string childID;

            EnsureChildControls();

            // If we're not the naming container, let it do the job
            if (!(flags[isNamingContainer])) {
                Control namingContainer = NamingContainer;
                if (namingContainer != null) {
                    return namingContainer.FindControl(id, pathOffset);
                }
                return null;
            }

            // No registered control, demand create the named controls table
            if ((_namedControls == null) && HasControls()) {
                EnsureNamedControlsTable();
            }
            if (_namedControls == null) {
                return null;
            }

            // Is it a hierarchical name?
            int newPathOffset = id.IndexOf(ID_SEPARATOR, pathOffset);

            // If not, handle it here
            if (newPathOffset == -1) {
                childID = id.Substring(pathOffset);
                return _namedControls[childID] as Control;
            }

            // Get the name of the child, and try to locate it
            childID = id.Substring(pathOffset, newPathOffset - pathOffset);
            Control child =  _namedControls[childID] as Control;

            // Child doesn't exist: fail
            if (child == null)
                return null;

            return child.FindControl(id, newPathOffset + 1);
        }

        /*
         * Called when the controls of a naming container are cleared.
         */
        internal void ClearNamingContainer() {
            Debug.Assert(this is INamingContainer);

            _namedControlsID = 0;
            DirtyNameTable();
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.HasControls"]/*' />
        /// <devdoc>
        ///    <para>Determines if the current control contains any child 
        ///       controls. Since this method simply deteremines if any child controls exist at
        ///       all, it can enhance performance by avoiding a call to the Count property,
        ///       inherited from the <see cref='System.Web.UI.ControlCollection'/> class, on the <see cref='System.Web.UI.Control.Controls'/>
        ///       property.</para>
        /// </devdoc>
        public virtual bool HasControls() {
            return _controls != null && _controls.Count > 0;
        }

        /*
         * Check if a Control either has children or has a compiled render method.
         * This is to address issues like ASURT 94127
         */
        internal bool HasRenderingData() {
            return HasControls() || (_renderMethod != null);
        }

        /*
         * Returns true if the container contains just a static string, i.e.,
         * when the Controls collection has a single LiteralControl.
         */
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.IsLiteralContent"]/*' />
        /// <devdoc>
        ///    <para>Determines if the container holds literal content only. 
        ///       When this method returns <see langword='true'/>
        ///       , the container collection only holds a single literal control. The
        ///       content is then passed to the requesting browser as HTML.</para>
        /// </devdoc>
        protected bool IsLiteralContent() {
            return (_controls != null) && (_controls.Count == 1) &&
            ((_controls[0] is LiteralControl));
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.IsTrackingViewState"]/*' />
        /// <devdoc>
        ///    <para>Determines if view state changes to the 
        ///    <see langword='Control'/> 
        ///    are being saved. </para>
        /// </devdoc>
        protected bool IsTrackingViewState {
            get {
                return flags[marked];
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.TrackViewState"]/*' />
        /// <devdoc>
        ///    <para>Turns on tracking of view state changes to the control 
        ///       so that they can be stored in the <see langword='StateBag'/>
        ///       object.</para>
        /// </devdoc>
        protected virtual void TrackViewState() {
            if (_viewState != null)
                _viewState.TrackViewState();

            flags[marked] = true;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.EnsureChildControls"]/*' />
        /// <devdoc>
        ///    <para>Checks that the control contains child controls; if it does not, it creates 
        ///       them. This includes any literal content being parsed as a <see cref='System.Web.UI.LiteralControl'/>
        ///       object. </para>
        /// </devdoc>
        protected virtual void EnsureChildControls() {
            if (!ChildControlsCreated && !flags[creatingControls]) {
                flags[creatingControls] = true;
                try {
                    CreateChildControls();
                }
                finally {
                    flags[creatingControls] = false;
                    ChildControlsCreated = true;
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RemovedControl"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected internal virtual void RemovedControl(Control control) {
            if ((_namingContainer != null) && (control._id != null)) {
                _namingContainer.DirtyNameTable();
            }

            // Controls may need to do their own cleanup.
            control.UnloadRecursive(false);

            control._parent = null;
            control._page = null;
            control._namingContainer = null;
            control.ClearCachedUniqueIDRecursive();
        }

        // Set the delegate to the render method
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SetRenderMethodDelegate"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Assigns any event handler delegates for the control to match the parameters 
        ///       defined in the <see cref='System.Web.UI.RenderMethod'/>. </para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public void SetRenderMethodDelegate(RenderMethod renderMethod) {
            _renderMethod = renderMethod;

            // Make the collection readonly if there are code blocks (ASURT 78810)
            Controls.SetCollectionReadOnly(SR.Collection_readonly_Codeblocks);
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.IDataBindingsAccessor.HasDataBindings"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Returns whether the control contains any data binding logic. This method is 
        ///       only accessed by RAD designers.</para>
        /// </devdoc>
        bool IDataBindingsAccessor.HasDataBindings {
            get {
                return (_dataBindings != null) && (_dataBindings.Count != 0);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.IDataBindingsAccessor.DataBindings"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Indicates a collection of all data bindings on the control. This property is 
        /// read-only.</para>
        /// </devdoc>
        DataBindingCollection IDataBindingsAccessor.DataBindings {
            get {
                if (_dataBindings == null) {
                    _dataBindings = new DataBindingCollection();
                }
                return _dataBindings;
            }
        }


        // IParserAccessor interface
        // A sub-object tag was parsed by the parser; add it to this control.
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.IParserAccessor.AddParsedSubObject"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Notifies the control that an element, XML or HTML, was parsed, and adds it to 
        /// the control.</para>
        /// </devdoc>
        void IParserAccessor.AddParsedSubObject(object obj) {
            AddParsedSubObject(obj);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrolpersistable.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlControlPersistable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;

    [AttributeUsage(AttributeTargets.Property)]
    internal sealed class HtmlControlPersistableAttribute : Attribute {

        internal static readonly HtmlControlPersistableAttribute Yes = new HtmlControlPersistableAttribute(true);
        internal static readonly HtmlControlPersistableAttribute No =  new HtmlControlPersistableAttribute(false);
        internal static readonly HtmlControlPersistableAttribute Default = Yes;
        private bool persistable = true;

        internal HtmlControlPersistableAttribute(bool persistable) {
            this.persistable = persistable;
        }

        internal bool HtmlControlPersistable {
            get {
                return persistable;
            }
        }

        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            HtmlControlPersistableAttribute other = obj as HtmlControlPersistableAttribute;
            return (other != null) && other.HtmlControlPersistable == persistable;
        }

        public override int GetHashCode() {
            return persistable.GetHashCode();
        }

        public override bool IsDefaultAttribute() {
            return (this.Equals(Default));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\html32textwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="Html32TextWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {
    using System;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Globalization;
    using System.Web.UI.WebControls;  // CONSIDER: remove dependency, required for FontUnit
    using System.Security.Permissions;

    /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Html32TextWriter : HtmlTextWriter {

        private const int NOTHING = 0x0000;
        private const int FONT_AROUND_CONTENT = 0x0001;
        private const int FONT_AROUND_TAG = 0x0002;
        private const int TABLE_ATTRIBUTES = 0x0004;
        private const int TABLE_AROUND_CONTENT = 0x0008;
        private const int FONT_PROPAGATE = 0x0010;
        private const int FONT_CONSUME = 0x0020;
        private const int SUPPORTS_HEIGHT_WIDTH = 0x0040;
        private const int SUPPORTS_BORDER = 0x0080;

        private StringBuilder _beforeTag;
        private StringBuilder _beforeContent;
        private StringBuilder _afterContent;
        private StringBuilder _afterTag;
        
        //REVIEW, nikhilko: Might want a custom stack implementation, since this affects perf...
        //                   wherever tables are involved.
        private Stack _fontStack;

        private int _tagSupports;
        private bool _renderFontTag;
        private string _fontFace;
        private string _fontColor;
        private string _fontSize;

        /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter.Html32TextWriter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Html32TextWriter(TextWriter writer) : this(writer, DefaultTabString) {
        }

        /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter.Html32TextWriter1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Html32TextWriter(TextWriter writer, string tabString) : base(writer, tabString) {
            // The initial capacities should be set up such that they are at least twice what
            // we expect for the maximum content we're going to stuff in into the builder.
            // This gives the best perf when using the Length property to reset the builder.
            
            _beforeTag = new StringBuilder(256);
            _beforeContent = new StringBuilder(256);
            _afterContent = new StringBuilder(128);
            _afterTag = new StringBuilder(128);
        }

        /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter.FontStack"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected Stack FontStack {
            get {
                if (_fontStack == null) {
                    _fontStack = new Stack(3);
                }
                return _fontStack;
            }
        }

        private void AppendFontTag(StringBuilder sbBegin,StringBuilder sbEnd) {
            AppendFontTag(_fontFace, _fontColor, _fontSize, sbBegin, sbEnd);
        }

        private void AppendFontTag(string fontFace, string fontColor, string fontSize, StringBuilder sbBegin,StringBuilder sbEnd) {
            // append font begin tag 
            sbBegin.Append(TagLeftChar);
            sbBegin.Append("font");
            if (fontFace != null) {
                sbBegin.Append(" face");
                sbBegin.Append(EqualsDoubleQuoteString);
                sbBegin.Append(fontFace);
                sbBegin.Append(DoubleQuoteChar);
            }
            if (fontColor != null) {
                sbBegin.Append(" color=");
                sbBegin.Append(DoubleQuoteChar);
                sbBegin.Append(fontColor);
                sbBegin.Append(DoubleQuoteChar);
            }
            if (fontSize != null) {
                sbBegin.Append(" size=");
                sbBegin.Append(DoubleQuoteChar);
                sbBegin.Append(fontSize);
                sbBegin.Append(DoubleQuoteChar);
            }
            sbBegin.Append(TagRightChar);

            // insert font end tag 
            sbEnd.Insert(0,EndTagLeftChars + "font" + TagRightChar);
        }

        private void AppendOtherTag(string tag) {
            if (Supports(FONT_AROUND_CONTENT))
                AppendOtherTag(tag,_beforeContent,_afterContent);
            else
                AppendOtherTag(tag,_beforeTag,_afterTag);
        }

        private void AppendOtherTag(string tag,StringBuilder sbBegin,StringBuilder sbEnd) {
            // append begin tag 
            sbBegin.Append(TagLeftChar);
            sbBegin.Append(tag);
            sbBegin.Append(TagRightChar);

            // insert end tag 
            sbEnd.Insert(0,EndTagLeftChars + tag + TagRightChar);
        }

        private void AppendOtherTag(string tag, object[] attribs, StringBuilder sbBegin, StringBuilder sbEnd) {
            // append begin tag 
            sbBegin.Append(TagLeftChar);
            sbBegin.Append(tag);
            for (int i = 0; i < attribs.Length; i++) {
                sbBegin.Append(SpaceChar);
                sbBegin.Append(((string[])attribs[i])[0]);
                sbBegin.Append(EqualsDoubleQuoteString);
                sbBegin.Append(((string[])attribs[i])[1]);
                sbBegin.Append(DoubleQuoteChar);
            }
            sbBegin.Append(TagRightChar);

            // insert end tag 
            sbEnd.Insert(0,EndTagLeftChars + tag + TagRightChar);
        }

        private void ConsumeFont(StringBuilder sbBegin, StringBuilder sbEnd) {
            int fontInfoCount = FontStack.Count;

            if (fontInfoCount > 0) {
                FontStackItem[] fontInfo = new FontStackItem[fontInfoCount];
                FontStack.CopyTo(fontInfo, 0);

                string fontFace = null;
                string fontColor = null;
                string fontSize = null;
                int i;

                for (i = 0; i < fontInfoCount && fontFace == null; i++) {
                    fontFace = fontInfo[i].name;
                }
                for (i = 0; i < fontInfoCount && fontColor == null; i++) {
                    fontColor = fontInfo[i].color;
                }
                for (i = 0; i < fontInfoCount && fontSize == null; i++) {
                    fontSize = fontInfo[i].size;
                }
                if ((fontFace != null) || (fontColor != null) || (fontSize != null)) {
                    AppendFontTag(fontFace, fontColor, fontSize, sbBegin, sbEnd);
                }

                for (i = 0; i < fontInfoCount; i++) {
                    if (fontInfo[i].underline == true) {
                        AppendOtherTag("u", sbBegin, sbEnd);
                        break;
                    }
                }
                for (i = 0; i < fontInfoCount; i++) {
                    if (fontInfo[i].italic == true) {
                        AppendOtherTag("i", sbBegin, sbEnd);
                        break;
                    }
                }
                for (i = 0; i < fontInfoCount; i++) {
                    if (fontInfo[i].bold == true) {
                        AppendOtherTag("b", sbBegin, sbEnd);
                        break;
                    }
                }
                for (i = 0; i < fontInfoCount; i++) {
                    if (fontInfo[i].strikeout == true) {
                        AppendOtherTag("strike", sbBegin, sbEnd);
                        break;
                    }
                }
            }
        }

        private string ConvertToHtmlFontSize(string value) {
            FontUnit fu = new FontUnit(value, CultureInfo.InvariantCulture);
            if ((int)(fu.Type) > 3)
                return ((int)(fu.Type)-3).ToString();

            if (fu.Type == FontSize.AsUnit) {
                if (fu.Unit.Type == UnitType.Point) {
                    if (fu.Unit.Value <= 8)
                        return "1";
                    else if (fu.Unit.Value <= 10)
                        return "2";
                    else if (fu.Unit.Value <= 12)
                        return "3";
                    else if (fu.Unit.Value <= 14)
                        return "4";
                    else if (fu.Unit.Value <= 18)
                        return "5";
                    else if (fu.Unit.Value <= 24)
                        return "6";
                    else
                        return "7";
                }
            }

            return null;
        }

        private string ConvertToHtmlSize(string value) {
            Unit u = new Unit(value, CultureInfo.InvariantCulture);
            if (u.Type == UnitType.Pixel) {
                return u.Value.ToString();
            }
            if (u.Type == UnitType.Percentage) {
                return value;
            }
            return null;
        }

        /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter.OnStyleAttributeRender"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override bool OnStyleAttributeRender(string name,string value, HtmlTextWriterStyle key) {

            string s;
            if (Supports(FONT_AROUND_CONTENT)) {
                // tag supports downlevel fonts
                switch (key) {
                    case HtmlTextWriterStyle.FontFamily:
                        _fontFace = value; 
                        _renderFontTag = true;
                        break;
                    case HtmlTextWriterStyle.Color:
                        _fontColor = value;
                        _renderFontTag = true;
                        break;
                    case HtmlTextWriterStyle.FontSize:
                        _fontSize = ConvertToHtmlFontSize(value);
                        if (_fontSize != null)
                            _renderFontTag = true;
                        break;
                    case HtmlTextWriterStyle.FontWeight:
                        if (String.Compare(value, "bold", true, CultureInfo.InvariantCulture) == 0) {
                            AppendOtherTag("b");
                        }
                        break;
                    case HtmlTextWriterStyle.FontStyle:
                        if (String.Compare(value, "normal", true, CultureInfo.InvariantCulture) != 0) {
                            AppendOtherTag("i");
                        }
                        break;
                    case HtmlTextWriterStyle.TextDecoration:
                        s = value.ToLower(CultureInfo.InvariantCulture);
                        if (s.IndexOf("underline") != -1) {
                            AppendOtherTag("u");
                        }
                        if (s.IndexOf("line-through") != -1) {
                            AppendOtherTag("strike");
                        }
                        break;
                }
            }
            else if (Supports(FONT_PROPAGATE)) {
                FontStackItem font = (FontStackItem)FontStack.Peek();

                switch (key) {
                    case HtmlTextWriterStyle.FontFamily:
                        font.name = value;
                        break;
                    case HtmlTextWriterStyle.Color:
                        font.color = value;
                        break;
                    case HtmlTextWriterStyle.FontSize:
                        font.size = ConvertToHtmlFontSize(value);
                        break;
                    case HtmlTextWriterStyle.FontWeight:
                        if (String.Compare(value, "bold", true, CultureInfo.InvariantCulture) == 0) {
                            font.bold = true;
                        }
                        break;
                    case HtmlTextWriterStyle.FontStyle:
                        if (String.Compare(value, "normal", true, CultureInfo.InvariantCulture) != 0) {
                            font.italic = true;
                        }
                        break;
                    case HtmlTextWriterStyle.TextDecoration:
                        s = value.ToLower(CultureInfo.InvariantCulture);
                        if (s.IndexOf("underline") != -1) {
                            font.underline = true;
                        }
                        if (s.IndexOf("line-through") != -1) {
                            font.strikeout = true;
                        }
                        break;
                }
            }

            if (Supports(SUPPORTS_BORDER) && key == HtmlTextWriterStyle.BorderWidth) {
                s = ConvertToHtmlSize(value);
                if (s != null)
                    AddAttribute(HtmlTextWriterAttribute.Border,s);
            }

            if (Supports(SUPPORTS_HEIGHT_WIDTH)) {
                switch(key) {
                    case HtmlTextWriterStyle.Height :
                        s = ConvertToHtmlSize(value);
                        if (s != null)
                            AddAttribute(HtmlTextWriterAttribute.Height,s);
                        break;
                    case HtmlTextWriterStyle.Width :
                        s = ConvertToHtmlSize(value);
                        if (s != null)
                            AddAttribute(HtmlTextWriterAttribute.Width,s);
                        break;
                }
            }

            if (Supports(TABLE_ATTRIBUTES) || Supports(TABLE_AROUND_CONTENT)) {
                // tag supports downlevel table attributes
                switch (key) {
                    case HtmlTextWriterStyle.BorderColor :
                        switch (TagKey) {
                            case HtmlTextWriterTag.Div:
                                AddAttribute(HtmlTextWriterAttribute.Bordercolor, value);
                                break;
                        }
                        break;
                    case HtmlTextWriterStyle.BackgroundColor :
                        switch (TagKey) {
                            case HtmlTextWriterTag.Table :
                            case HtmlTextWriterTag.Tr :
                            case HtmlTextWriterTag.Td :
                            case HtmlTextWriterTag.Th :
                            case HtmlTextWriterTag.Body :
                            case HtmlTextWriterTag.Div:
                                AddAttribute(HtmlTextWriterAttribute.Bgcolor,value);
                                break;
                        }
                        break;
                    case HtmlTextWriterStyle.BackgroundImage :
                        switch (TagKey) {
                            case HtmlTextWriterTag.Table :
                            case HtmlTextWriterTag.Td :
                            case HtmlTextWriterTag.Div:
                            case HtmlTextWriterTag.Th :
                            case HtmlTextWriterTag.Body :
                                // strip url(...) from value
                                if (value.StartsWith("url("))
                                    value = value.Substring(4,value.Length-5);
                                AddAttribute(HtmlTextWriterAttribute.Background,value);
                                break;
                        }
                        break;
                }
            }
            return false;
        }

        /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter.OnTagRender"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override bool OnTagRender(string name, HtmlTextWriterTag key) {
            // handle any tags that do not work downlevel
                
            SetTagSupports();
            if (Supports(FONT_PROPAGATE)) {
                FontStack.Push(new FontStackItem());
            }

            // Make tag look like a table. This must be done after we establish tag support.
            if (key == HtmlTextWriterTag.Div) {
                TagKey = HtmlTextWriterTag.Table;
            }
            
            return base.OnTagRender(name,key);
        }

        /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter.GetTagName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string GetTagName(HtmlTextWriterTag tagKey) {
            if (tagKey == HtmlTextWriterTag.Div) {
                return "table";
            }
            return base.GetTagName(tagKey);
        }


        /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter.RenderBeginTag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void RenderBeginTag(HtmlTextWriterTag tagKey) {
            // flush string buffers to build new tag
            _beforeTag.Length = 0;
            _beforeContent.Length = 0;
            _afterContent.Length = 0;
            _afterTag.Length = 0;

            _renderFontTag = false;
            _fontFace = null;
            _fontColor = null;
            _fontSize = null;

            if (tagKey == HtmlTextWriterTag.Div) {
                AppendOtherTag("tr", _beforeContent, _afterContent);    

                string alignment;
                if (IsAttributeDefined(HtmlTextWriterAttribute.Align, out alignment)) {
                    string[] attribs = new string[] { GetAttributeName(HtmlTextWriterAttribute.Align), alignment };
                    
                    AppendOtherTag("td", new object[] { attribs }, _beforeContent, _afterContent);
                }
                else {
                    AppendOtherTag("td", _beforeContent, _afterContent);
                }
                AddAttribute(HtmlTextWriterAttribute.Cellpadding, "0");
                AddAttribute(HtmlTextWriterAttribute.Cellspacing, "0");
                if (!IsStyleAttributeDefined(HtmlTextWriterStyle.BorderWidth)) {
                    AddAttribute(HtmlTextWriterAttribute.Border, "0");
                }
                if (!IsStyleAttributeDefined(HtmlTextWriterStyle.Width)) {
                    AddAttribute(HtmlTextWriterAttribute.Width, "100%");
                }
            }

            base.RenderBeginTag(tagKey);
        }

        /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter.RenderBeforeTag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string RenderBeforeTag() {
            if (_renderFontTag && Supports(FONT_AROUND_TAG))
                AppendFontTag(_beforeTag,_afterTag);

            if (_beforeTag.Length > 0)
                return(_beforeTag.ToString());

            return base.RenderBeforeTag();
        }

        /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter.RenderBeforeContent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string RenderBeforeContent() {

            if (Supports(FONT_CONSUME)) {
                ConsumeFont(_beforeContent, _afterContent);
            }
            else if (_renderFontTag && Supports(FONT_AROUND_CONTENT)) {
                AppendFontTag(_beforeContent,_afterContent);
            }

            if (_beforeContent.Length > 0)
                return(_beforeContent.ToString());

            return base.RenderBeforeContent();

        }

        /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter.RenderAfterContent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string RenderAfterContent() {
            if (_afterContent.Length > 0)
                return(_afterContent.ToString());

            return base.RenderAfterContent();
        }

        /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter.RenderAfterTag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string RenderAfterTag() {
            if (_afterTag.Length > 0)
                return(_afterTag.ToString());

            return base.RenderAfterTag();
        }

        /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter.RenderEndTag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void RenderEndTag() {
            base.RenderEndTag();
            
            SetTagSupports();
            if (Supports(FONT_PROPAGATE)) {
                FontStack.Pop();
            }
        }

        private void SetTagSupports() {
            // determine what downlevel tag supports
            _tagSupports = NOTHING;
            switch (TagKey) {
                case HtmlTextWriterTag.A :
                case HtmlTextWriterTag.Label :
                case HtmlTextWriterTag.P :
                case HtmlTextWriterTag.Span :
                    _tagSupports |= FONT_AROUND_CONTENT;
                    break;
                case HtmlTextWriterTag.Div :
                    _tagSupports |= FONT_AROUND_CONTENT | FONT_PROPAGATE;
                    break;
                case HtmlTextWriterTag.Table:
                case HtmlTextWriterTag.Tr:
                    _tagSupports |= FONT_PROPAGATE;
                    break;
                case HtmlTextWriterTag.Td :
                case HtmlTextWriterTag.Th :
                    _tagSupports |= FONT_PROPAGATE | FONT_CONSUME;
                    break;
            }

            switch (TagKey) {
                case HtmlTextWriterTag.Div:
                case HtmlTextWriterTag.Img:
                    _tagSupports |= SUPPORTS_HEIGHT_WIDTH | SUPPORTS_BORDER;
                    break;     
                case HtmlTextWriterTag.Table:
                case HtmlTextWriterTag.Th:
                case HtmlTextWriterTag.Td:
                    _tagSupports |= SUPPORTS_HEIGHT_WIDTH;
                    break;
            }

            //switch (TagKey) {
            //    case HtmlTextWriterTag.INPUT :
            //        _tagSupports |= FONT_AROUND_TAG;
            //        break;
            //}

            switch (TagKey) {
                case HtmlTextWriterTag.Table :
                case HtmlTextWriterTag.Tr :
                case HtmlTextWriterTag.Td :
                case HtmlTextWriterTag.Th :
                case HtmlTextWriterTag.Body :
                    _tagSupports |= TABLE_ATTRIBUTES;
                    break;
            }
            switch (TagKey) {
                case HtmlTextWriterTag.Div :
                    _tagSupports |= TABLE_AROUND_CONTENT;
                    break;
            }
        }

        private bool Supports(int flag) {
            return(_tagSupports & flag) == flag;
        }


        /// <include file='doc\Html32TextWriter.uex' path='docs/doc[@for="Html32TextWriter.FontStackItem"]/*' />
        /// <devdoc>
        ///   Contains information about a font placed on the stack of font information.
        /// </devdoc>
        private sealed class FontStackItem {
            public string name;
            public string color;
            public string size;
            public bool bold;
            public bool italic;
            public bool underline;
            public bool strikeout;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\designtimeparsedata.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignTimeParseData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Security.Permissions;

    /// <include file='doc\DesignTimeParseData.uex' path='docs/doc[@for="DesignTimeParseData"]/*' />
    /// <internalonly/>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DesignTimeParseData {

        private static bool _inDesigner;
        
        private IDesignerHost _designerHost;
        private string _documentUrl;
        private EventHandler _dataBindingHandler;
        private string _parseText;

        internal static bool InDesigner { get { return _inDesigner; } }

        /// <include file='doc\DesignTimeParseData.uex' path='docs/doc[@for="DesignTimeParseData.DesignTimeParseData"]/*' />
        public DesignTimeParseData(IDesignerHost designerHost, string parseText) {
            // Is this is ever called, assume we are running in the designer (ASURT 74814)
            _inDesigner = true;

            // note that designerHost can be null, we continue on without using any designer-specific services.

            if ((parseText == null) || (parseText.Length == 0)) {
                throw new ArgumentNullException("parseText");
            }
            
            _designerHost = designerHost;
            _parseText = parseText;
        }

        /// <include file='doc\DesignTimeParseData.uex' path='docs/doc[@for="DesignTimeParseData.DataBindingHandler"]/*' />
        public EventHandler DataBindingHandler {
            get {
                return _dataBindingHandler;
            }
            set {
                _dataBindingHandler = value;
            }
        }
        
        /// <include file='doc\DesignTimeParseData.uex' path='docs/doc[@for="DesignTimeParseData.DesignerHost"]/*' />
        public IDesignerHost DesignerHost {
            get {
                return _designerHost;
            }
        }

        /// <include file='doc\DesignTimeParseData.uex' path='docs/doc[@for="DesignTimeParseData.DocumentUrl"]/*' />
        public string DocumentUrl {
            get {
                if (_documentUrl == null) {
                    return String.Empty;
                }
                return _documentUrl;
            }
            set {
                _documentUrl = value;
            }
        }

        /// <include file='doc\DesignTimeParseData.uex' path='docs/doc[@for="DesignTimeParseData.ParseText"]/*' />
        public string ParseText {
            get {
                return _parseText;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\emptycontrolcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="EmptyControlCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;
    using System.Collections;
    using System.Security.Permissions;

    /// <include file='doc\EmptyControlCollection.uex' path='docs/doc[@for="EmptyControlCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a ControlCollection that is always empty.
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class EmptyControlCollection : ControlCollection {

        /// <include file='doc\EmptyControlCollection.uex' path='docs/doc[@for="EmptyControlCollection.EmptyControlCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EmptyControlCollection(Control owner) : base(owner) {
        }

        private void ThrowNotSupportedException() {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Control_does_not_allow_children,
                                                                     Owner.GetType().ToString()));
        }

        /// <include file='doc\EmptyControlCollection.uex' path='docs/doc[@for="EmptyControlCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Add(Control child) {
            ThrowNotSupportedException();
        }

        /// <include file='doc\EmptyControlCollection.uex' path='docs/doc[@for="EmptyControlCollection.AddAt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void AddAt(int index, Control child) {
            ThrowNotSupportedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlform.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlForm.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

// HtmlForm.cs
//

namespace System.Web.UI.HtmlControls {
    using System.ComponentModel;
    using System;
    using System.IO;
    using System.Collections;
    using System.Web.Util;
    using System.Web.UI;
    using System.Security.Permissions;


/// <include file='doc\HtmlForm.uex' path='docs/doc[@for="HtmlForm"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlForm'/> class defines the methods, properties, and
///       events for the HtmlForm control. This class provides programmatic access to the
///       HTML &lt;form&gt; element on the server.
///    </para>
/// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlForm : HtmlContainerControl {

        private const string SmartNavIncludeScriptKey = "SmartNavIncludeScript";

        /// <include file='doc\HtmlForm.uex' path='docs/doc[@for="HtmlForm.HtmlForm"]/*' />
        /// <devdoc>
        /// </devdoc>
        public HtmlForm() : base("form") {
        }

        /*
         * Encode Type property.
         */
        /// <include file='doc\HtmlForm.uex' path='docs/doc[@for="HtmlForm.Enctype"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the Enctype attribute of the form. This is
        ///       the encoding type that browsers
        ///       use when posting the form's data to the server.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Enctype {
            get {
                string s = Attributes["enctype"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["enctype"] = MapStringAttributeToString(value);
            }
        }

        /*
         * Method property.
         */
        /// <include file='doc\HtmlForm.uex' path='docs/doc[@for="HtmlForm.Method"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the Method attribute for the form. This defines how a browser
        ///       posts form data to the server for processing. The two common methods supported
        ///       by all browsers are GET and POST.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Method {
            get {
                string s = Attributes["method"];
                return((s != null) ? s : "post");
            }
            set {
                Attributes["method"] = MapStringAttributeToString(value);
            }
        }

        /*
         * Name property.
         */
        /// <include file='doc\HtmlForm.uex' path='docs/doc[@for="HtmlForm.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the value of the HTML Name attribute that will be rendered to the
        ///       browser.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public virtual string Name {
            get {
                return UniqueID;
            }
            set {
                // no-op setter to prevent the name from being set
            }
        }

        /*
         * Target property.
         */
        /// <include file='doc\HtmlForm.uex' path='docs/doc[@for="HtmlForm.Target"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the Uri of the frame or window to render the results of a Form
        ///       POST request. Developers can use this property to redirect these results to
        ///       another browser window or frame.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Target {
            get {
                string s = Attributes["target"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["target"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlForm.uex' path='docs/doc[@for="HtmlForm.Render"]/*' />
        protected override void Render(HtmlTextWriter output)
        {
            Page p = Page;
            if (p == null)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Form_Needs_Page));

            if (p.SmartNavigation) {
                ((IAttributeAccessor)this).SetAttribute("__smartNavEnabled", "true");

                // Output the IFrame
                output.WriteLine("<IFRAME ID=__hifSmartNav NAME=__hifSmartNav STYLE=display:none src=\"" + Util.GetScriptLocation(Context) + "SmartNav.htm\"></IFRAME>");

                // Register the smartnav script file reference so it gets rendered
                p.RegisterClientScriptFileInternal(SmartNavIncludeScriptKey, "JScript", "SmartNav.js");
            }

            base.Render(output);
        }

        private string GetActionAttribute() {

            string currentExecutionFilePath = Context.Request.CurrentExecutionFilePath;
            string filePath = Context.Request.FilePath;
            string action;

            // ASURT 15075/11054/59970: always set the action to the current page

            if (Object.ReferenceEquals(currentExecutionFilePath, filePath)) {

                // There hasn't been any Server.Transfer, so just the FilePath

                // ASURT 15979: need to use a relative path, not absolute
                action = filePath;
                int iPos = action.LastIndexOf('/');
                if (iPos >= 0)
                    action = action.Substring(iPos+1);
            }
            else {
                // Server.Transfer case.  We need to make the form action relative
                // to the original FilePath (since that's where the browser thinks
                // we are).

                action = UrlPath.MakeRelative(filePath, currentExecutionFilePath);
            }

            // ASURT 15355: don't lose the query string if there is one
            string queryString = Context.Request.QueryStringText;
            if (queryString != null && queryString.Length != 0)
                action += "?" + queryString;

            return action;
        }

        /// <include file='doc\HtmlForm.uex' path='docs/doc[@for="HtmlForm.OnInit"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para> Call RegisterViewStateHandler().</para>
        /// </devdoc>
        protected override void OnInit(EventArgs e) {
            base.OnInit(e);

            Page.SetForm(this);

            // Make sure view state is calculated (see ASURT 73020)
            Page.RegisterViewStateHandler();
        }

        /// <include file='doc\HtmlForm.uex' path='docs/doc[@for="HtmlForm.RenderAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderAttributes(HtmlTextWriter writer) {
            writer.WriteAttribute("name", Name);
            Attributes.Remove("name");
            writer.WriteAttribute("method", Method);
            Attributes.Remove("method");
            // Encode the action attribute - ASURT 66784
            writer.WriteAttribute("action", GetActionAttribute(), true /*encode*/);
            Attributes.Remove("action");

            // see if the page has a submit event
            string onSubmit = Page.ClientOnSubmitEvent;
            if (onSubmit != null && onSubmit.Length > 0) {
                if (Attributes["onsubmit"] != null) {
                    onSubmit += Attributes["onsubmit"];
                    Attributes.Remove("onsubmit");
                }
                // to avoid being affected by earlier instructions we must
                // write out the language as well
                writer.WriteAttribute("language", "javascript");
                writer.WriteAttribute("onsubmit", onSubmit);
            }

            // We always want the form to have an id on the client, so if it's null, write it here.
            // Otherwise, base.RenderAttributes takes care of it.
            // REVIEW: this is a bit hacky.
            if (ID == null)
                writer.WriteAttribute("id", ClientID);

            base.RenderAttributes(writer);
        }

        /// <include file='doc\HtmlForm.uex' path='docs/doc[@for="HtmlForm.RenderChildren"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderChildren(HtmlTextWriter writer) {
            Page.OnFormRender(writer, UniqueID);

            base.RenderChildren(writer);

            Page.OnFormPostRender(writer, UniqueID);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmltagnametotypemapper.cs ===
//------------------------------------------------------------------------------
// <copyright file="HTMLTagNameToTypeMapper.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Mapper of html tags to control types.
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web.UI {
    using System.ComponentModel;

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Reflection;
    using System.Web.UI.HtmlControls;
    using System.Web.Util;
    using Debug=System.Diagnostics.Debug;
    using System.Globalization;
    
    internal class HtmlTagNameToTypeMapper : ITagNameToTypeMapper {
        static Hashtable _tagMap;
        static Hashtable _inputTypes;

        internal HtmlTagNameToTypeMapper() {
        }

        /*public*/ Type ITagNameToTypeMapper.GetControlType(string tagName, IDictionary attributeBag) {
            Type controlType;

            if (_tagMap == null) {
                Hashtable t = new Hashtable(10, SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
                t.Add("a", typeof(HtmlAnchor));
                t.Add("button", typeof(HtmlButton));
                t.Add("form", typeof(HtmlForm));
                t.Add("img", typeof(HtmlImage));
                t.Add("textarea", typeof(HtmlTextArea));
                t.Add("select", typeof(HtmlSelect));
                t.Add("table", typeof(HtmlTable));
                t.Add("tr", typeof(HtmlTableRow));
                t.Add("td", typeof(HtmlTableCell));
                t.Add("th", typeof(HtmlTableCell));
                _tagMap = t;
            }

            if (_inputTypes == null) {
                Hashtable t = new Hashtable(10, SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
                t.Add("text", typeof(HtmlInputText));
                t.Add("password", typeof(HtmlInputText));
                t.Add("button", typeof(HtmlInputButton));
                t.Add("submit", typeof(HtmlInputButton));
                t.Add("reset", typeof(HtmlInputButton));
                t.Add("image", typeof(HtmlInputImage));
                t.Add("checkbox", typeof(HtmlInputCheckBox));
                t.Add("radio", typeof(HtmlInputRadioButton));
                t.Add("hidden", typeof(HtmlInputHidden));
                t.Add("file", typeof(HtmlInputFile));
                _inputTypes = t;
            }

            if (string.Compare("input", tagName, true, CultureInfo.InvariantCulture) == 0) {
                string type = (string)attributeBag["type"];
                if (type == null)
                    type = "text";

                controlType = (Type)_inputTypes[type];

                if (controlType == null)
                    throw new HttpException(
                        HttpRuntime.FormatResourceString(SR.Invalid_type_for_input_tag, type));
            }
            else {
                controlType = (Type)_tagMap[tagName];
                if (controlType == null)
                    controlType = typeof(HtmlGenericControl);
            }

            return controlType;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmltextwriterstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlTextWriterStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {
    using System;

    /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum HtmlTextWriterStyle {
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.BackgroundColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BackgroundColor,
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BackgroundImage,
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.BorderCollapse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BorderCollapse,
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.BorderColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BorderColor,
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.BorderStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BorderStyle,
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.BorderWidth"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BorderWidth,
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.Color"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Color,
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.FontFamily"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FontFamily,
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.FontSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FontSize,
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.FontStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FontStyle,
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.FontWeight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FontWeight,
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.Height"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Height,
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.TextDecoration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        TextDecoration,
        /// <include file='doc\HtmlTextWriterStyle.uex' path='docs/doc[@for="HtmlTextWriterStyle.Width"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Width,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmltextwriterattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlTextWriterAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {
    using System;

    /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum HtmlTextWriterAttribute {
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Accesskey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Accesskey,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Align"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Align,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Alt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Alt,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Background"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Background,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Bgcolor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Bgcolor,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Border"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Border,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Bordercolor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Bordercolor,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Cellpadding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Cellpadding,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Cellspacing"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Cellspacing,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Checked"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Checked,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Class"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Class,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Cols"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Cols,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Colspan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Colspan,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Disabled"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Disabled,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.For"]/*' />
        For,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Height"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Height,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Href"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Href,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Id"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Id,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Maxlength"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Maxlength,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Multiple"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Multiple,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Name,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Nowrap"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Nowrap,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Onchange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Onchange,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Onclick"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Onclick,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.ReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ReadOnly,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Rows"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rows,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Rowspan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rowspan,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Rules"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rules,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Selected"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Selected,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Size"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Size,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Src"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Src,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Style"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Style,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Tabindex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Tabindex,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Target"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Target,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Title"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Title,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Type"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Type,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Valign"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Valign,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Value,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Width"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Width,
        /// <include file='doc\HtmlTextWriterAttribute.uex' path='docs/doc[@for="HtmlTextWriterAttribute.Wrap"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Wrap,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmltextwritertag.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlTextWriterTag.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {
    using System;

    /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum HtmlTextWriterTag {

        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Unknown"]/*' />
        Unknown,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.A"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        A,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Acronym"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Acronym,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Address"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Address,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Area"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Area,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.B"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        B,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Base"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Base,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Basefont"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Basefont,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Bdo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Bdo,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Bgsound"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Bgsound,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Big"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Big,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Blockquote"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Blockquote,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Body"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Body,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Br"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Br,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Button"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Button,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Caption"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Caption,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Center"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Center,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Cite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Cite,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Code"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Code,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Col"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Col,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Colgroup"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Colgroup,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Dd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Dd,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Del"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Del,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Dfn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Dfn,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Dir"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Dir,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Div"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Div,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Dl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Dl,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Dt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Dt,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Em"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Em,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Embed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Embed,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Fieldset"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Fieldset,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Font"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Font,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Form"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Form,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Frame"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Frame,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Frameset"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Frameset,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.H1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        H1,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.H2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        H2,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.H3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        H3,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.H4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        H4,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.H5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        H5,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.H6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        H6,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Head"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Head,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Hr"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Hr,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Html"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Html,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.I"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        I,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Iframe"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Iframe,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Img"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Img,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Input"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Input,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Ins"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ins,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Isindex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Isindex,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Kbd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Kbd,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Label"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Label,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Legend"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Legend,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Li"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Li,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Link"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Link,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Map"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Map,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Marquee"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Marquee,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Menu"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Menu,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Meta"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Meta,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Nobr"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Nobr,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Noframes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Noframes,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Noscript"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Noscript,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Object"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Object,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Ol"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ol,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Option"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Option,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.P"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        P,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Param"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Param,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Pre"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Pre,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Q"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Q,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Rt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rt,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Ruby"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ruby,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.S"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        S,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Samp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Samp,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Script"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Script,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Select"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Select,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Small"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Small,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Span"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Span,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Strike"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Strike,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Strong"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Strong,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Style"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Style,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Sub"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Sub,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Sup"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Sup,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Table"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Table,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Tbody"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Tbody,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Td"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Td,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Textarea"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Textarea,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Tfoot"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Tfoot,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Th"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Th,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Thead"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Thead,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Title"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Title,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Tr"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Tr,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Tt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Tt,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.U"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        U,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Ul"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ul,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Var"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Var,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Wbr"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Wbr,
        /// <include file='doc\HtmlTextWriterTag.uex' path='docs/doc[@for="HtmlTextWriterTag.Xml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Xml,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\iattributeaccessor.cs ===
//------------------------------------------------------------------------------
// <copyright file="IAttributeAccessor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Interface implemented by objects that need to expose string properties
 * with arbitrary names.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.UI {

/// <include file='doc\IAttributeAccessor.uex' path='docs/doc[@for="IAttributeAccessor"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
public interface IAttributeAccessor {
    /*
     * Get the string value of a named property
     */
    /// <include file='doc\IAttributeAccessor.uex' path='docs/doc[@for="IAttributeAccessor.GetAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    string GetAttribute(string key);

    /*
     * Set a named property with a string value
     */
    /// <include file='doc\IAttributeAccessor.uex' path='docs/doc[@for="IAttributeAccessor.SetAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    void SetAttribute(string key, string value);

}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\imageclickeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageClickEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Web.UI {

    using System;

    /// <include file='doc\ImageClickEventHandler.uex' path='docs/doc[@for="ImageClickEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void ImageClickEventHandler(object sender, ImageClickEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\idatabindingsaccessor.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDataBindingsAccessor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;

    /// <include file='doc\IDataBindingsAccessor.uex' path='docs/doc[@for="IDataBindingsAccessor"]/*' />
    /// <devdoc>
    ///  Used to access data bindings of a Control.
    ///  Only valid for use at design-time.
    /// </devdoc>
    public interface IDataBindingsAccessor {

        /// <include file='doc\IDataBindingsAccessor.uex' path='docs/doc[@for="IDataBindingsAccessor.DataBindings"]/*' />
        /// <devdoc>
        ///    <para>Indicates a collection of all data bindings on the control. This property is 
        ///       read-only.</para>
        /// </devdoc>
        DataBindingCollection DataBindings {
            get;
        }
        
        /// <include file='doc\IDataBindingsAccessor.uex' path='docs/doc[@for="IDataBindingsAccessor.HasDataBindings"]/*' />
        /// <devdoc>
        ///    <para>Returns whether the control contains any data binding logic. This method is 
        ///       only accessed by RAD designers.</para>
        /// </devdoc>
        bool HasDataBindings {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\iparseraccessor.cs ===
//------------------------------------------------------------------------------
// <copyright file="IParserAccessor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The interface used to interact with the Parser.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.UI {

using System;

/// <include file='doc\IParserAccessor.uex' path='docs/doc[@for="IParserAccessor"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
public interface IParserAccessor {
    /*
     * A sub-object tag was parsed by the parser; add it to this container.
     */
    /// <include file='doc\IParserAccessor.uex' path='docs/doc[@for="IParserAccessor.AddParsedSubObject"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    void AddParsedSubObject(object obj);
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\inamingcontainer.cs ===
//------------------------------------------------------------------------------
// <copyright file="INamingContainer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Marker interface implemented by all controls that wish to introduce a new
 * logical namespace into the control hierarchy tree.
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */
namespace System.Web.UI {
    using System.ComponentModel;

using System;

/// <include file='doc\INamingContainer.uex' path='docs/doc[@for="INamingContainer"]/*' />
/// <devdoc>
///    <para>Identifies 
///       a container control that scopes a new ID namespace within a page's control
///       hierarchy. This is a marker interface only.</para>
/// </devdoc>
public interface INamingContainer {
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\ipostbackdatahandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="IPostBackDataHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Controls that can accept postback data should implement this interface.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.UI {

using System;
using System.Collections;
using System.Collections.Specialized;

/// <include file='doc\IPostBackDataHandler.uex' path='docs/doc[@for="IPostBackDataHandler"]/*' />
/// <devdoc>
///    <para>Defines the contract that controls must implement in order to
///       automatically load post back data.</para>
/// </devdoc>
public interface IPostBackDataHandler {
    /*
     * Processes the post data returned from the client for this control.
     * Answer true if the post data causes our state to change.
     */
    /// <include file='doc\IPostBackDataHandler.uex' path='docs/doc[@for="IPostBackDataHandler.LoadPostData"]/*' />
    /// <devdoc>
    ///    <para>Processes the post back data for the specified control. </para>
    ///    </devdoc>
    bool LoadPostData(string postDataKey, NameValueCollection postCollection);

    /*
     * Notify any listeners that our state has changed as the result of
     * a post back.
     */
    /// <include file='doc\IPostBackDataHandler.uex' path='docs/doc[@for="IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
    /// <devdoc>
    ///    <para>Signals the control to notify any listeners that the state of the
    ///       control has changed.</para>
    /// </devdoc>
    void RaisePostDataChangedEvent();
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\imageclickeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageClickEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI {

    using System;
    using System.Security.Permissions;

    /// <include file='doc\ImageClickEventArgs.uex' path='docs/doc[@for="ImageClickEventArgs"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class ImageClickEventArgs : EventArgs {
        /// <include file='doc\ImageClickEventArgs.uex' path='docs/doc[@for="ImageClickEventArgs.X"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int X;
        /// <include file='doc\ImageClickEventArgs.uex' path='docs/doc[@for="ImageClickEventArgs.Y"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Y;


        /// <include file='doc\ImageClickEventArgs.uex' path='docs/doc[@for="ImageClickEventArgs.ImageClickEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ImageClickEventArgs(int x,int y) {
            this.X = x;
            this.Y = y;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmltextwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HTMLTextWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// HtmlTextWriter.cs
//

namespace System.Web.UI {
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.IO;
    using System.Text;
    using System.Globalization;
    using System.Security.Permissions;
    
    /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlTextWriter : TextWriter {
        private TextWriter writer;
        private int indentLevel;
        private bool tabsPending;
        private string tabString;
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.TagLeftChar"]/*' />
        public const char TagLeftChar = '<';
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.TagRightChar"]/*' />
        public const char TagRightChar = '>';
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.SelfClosingChars"]/*' />
        public const string SelfClosingChars = " /";
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.SelfClosingTagEnd"]/*' />
        public const string SelfClosingTagEnd = " />";
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.EndTagLeftChars"]/*' />
        public const string EndTagLeftChars = "</";
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.DoubleQuoteChar"]/*' />
        public const char DoubleQuoteChar = '"';
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.SingleQuoteChar"]/*' />
        public const char SingleQuoteChar = '\'';
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.SpaceChar"]/*' />
        public const char SpaceChar = ' ';
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.EqualsChar"]/*' />
        public const char EqualsChar = '=';
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.SlashChar"]/*' />
        public const char SlashChar = '/';
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.EqualsQuoteString"]/*' />
        public const string EqualsDoubleQuoteString = "=\"";
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.SemicolonChar"]/*' />
        public const char SemicolonChar = ';';
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.StyleEqualsChar"]/*' />
        public const char StyleEqualsChar = ':';
        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.DefaultTabString"]/*' />
        public const string DefaultTabString = "\t";

        private static Hashtable _tagKeyLookupTable;
        private static Hashtable _attrKeyLookupTable;
        private static Hashtable _styleKeyLookupTable;
        private static TagInformation[] _tagNameLookupArray;
        private static AttributeInformation[] _attrNameLookupArray;
        private static string[] _styleNameLookupArray;

        private TagStackEntry[] _endTags;
        private int _endTagCount;
        private int _inlineCount;

        private string _tagName;
        private HtmlTextWriterTag _tagKey;
        private int _tagIndex;
        private RenderAttribute[] _attrList;
        private int _attrCount;
        private RenderStyle[] _styleList;
        private int _styleCount;

        private HttpWriter _httpWriter;
        private bool _isDescendant;

        static HtmlTextWriter() {

            // register known tags
            _tagKeyLookupTable = new Hashtable((int)HtmlTextWriterTag.Xml + 1);
            _tagNameLookupArray = new TagInformation[(int)HtmlTextWriterTag.Xml + 1];

            RegisterTag("",           HtmlTextWriterTag.Unknown,        TagType.Other);
            RegisterTag("a",          HtmlTextWriterTag.A,              TagType.Inline);
            RegisterTag("acronym",    HtmlTextWriterTag.Acronym,        TagType.Inline);
            RegisterTag("address",    HtmlTextWriterTag.Address,        TagType.Other);
            RegisterTag("area",       HtmlTextWriterTag.Area,           TagType.Other);
            RegisterTag("b",          HtmlTextWriterTag.B,              TagType.Inline);
            RegisterTag("base",       HtmlTextWriterTag.Base,           TagType.NonClosing);
            RegisterTag("basefont",   HtmlTextWriterTag.Basefont,       TagType.NonClosing);
            RegisterTag("bdo",        HtmlTextWriterTag.Bdo,            TagType.Inline);
            RegisterTag("bgsound",    HtmlTextWriterTag.Bgsound,        TagType.NonClosing);
            RegisterTag("big",        HtmlTextWriterTag.Big,            TagType.Inline);
            RegisterTag("blockquote", HtmlTextWriterTag.Blockquote,     TagType.Other);
            RegisterTag("body",       HtmlTextWriterTag.Body,           TagType.Other);
            RegisterTag("br",         HtmlTextWriterTag.Br,             TagType.Other);
            RegisterTag("button",     HtmlTextWriterTag.Button,         TagType.Inline);
            RegisterTag("caption",    HtmlTextWriterTag.Caption,        TagType.Other);
            RegisterTag("center",     HtmlTextWriterTag.Center,         TagType.Other);
            RegisterTag("cite",       HtmlTextWriterTag.Cite,           TagType.Inline);
            RegisterTag("code",       HtmlTextWriterTag.Code,           TagType.Inline);
            RegisterTag("col",        HtmlTextWriterTag.Col,            TagType.NonClosing);
            RegisterTag("colgroup",   HtmlTextWriterTag.Colgroup,       TagType.Other);
            RegisterTag("del",        HtmlTextWriterTag.Del,            TagType.Inline);
            RegisterTag("dd",         HtmlTextWriterTag.Dd,             TagType.Inline);
            RegisterTag("dfn",        HtmlTextWriterTag.Dfn,            TagType.Inline);
            RegisterTag("dir",        HtmlTextWriterTag.Dir,            TagType.Other);
            RegisterTag("div",        HtmlTextWriterTag.Div,            TagType.Other);
            RegisterTag("dl",         HtmlTextWriterTag.Dl,             TagType.Other);
            RegisterTag("dt",         HtmlTextWriterTag.Dt,             TagType.Inline);
            RegisterTag("em",         HtmlTextWriterTag.Em,             TagType.Inline);
            RegisterTag("embed",      HtmlTextWriterTag.Embed,          TagType.NonClosing);
            RegisterTag("fieldset",   HtmlTextWriterTag.Fieldset,       TagType.Other);
            RegisterTag("font",       HtmlTextWriterTag.Font,           TagType.Inline);
            RegisterTag("form",       HtmlTextWriterTag.Form,           TagType.Other);
            RegisterTag("frame",      HtmlTextWriterTag.Frame,          TagType.NonClosing);
            RegisterTag("frameset",   HtmlTextWriterTag.Frameset,       TagType.Other);
            RegisterTag("h1",         HtmlTextWriterTag.H1,             TagType.Other);
            RegisterTag("h2",         HtmlTextWriterTag.H2,             TagType.Other);
            RegisterTag("h3",         HtmlTextWriterTag.H3,             TagType.Other);
            RegisterTag("h4",         HtmlTextWriterTag.H4,             TagType.Other);
            RegisterTag("h5",         HtmlTextWriterTag.H5,             TagType.Other);
            RegisterTag("h6",         HtmlTextWriterTag.H6,             TagType.Other);
            RegisterTag("head",       HtmlTextWriterTag.Head,           TagType.Other);
            RegisterTag("hr",         HtmlTextWriterTag.Hr,             TagType.NonClosing);
            RegisterTag("html",       HtmlTextWriterTag.Html,           TagType.Other);
            RegisterTag("i",          HtmlTextWriterTag.I,              TagType.Inline);
            RegisterTag("iframe",     HtmlTextWriterTag.Iframe,         TagType.Other);
            RegisterTag("img",        HtmlTextWriterTag.Img,            TagType.NonClosing);
            RegisterTag("input",      HtmlTextWriterTag.Input,          TagType.NonClosing);
            RegisterTag("ins",        HtmlTextWriterTag.Ins,            TagType.Inline);
            RegisterTag("isindex",    HtmlTextWriterTag.Isindex,        TagType.NonClosing);
            RegisterTag("kbd",        HtmlTextWriterTag.Kbd,            TagType.Inline);
            RegisterTag("label",      HtmlTextWriterTag.Label,          TagType.Inline);
            RegisterTag("legend",     HtmlTextWriterTag.Legend,         TagType.Other);
            RegisterTag("li",         HtmlTextWriterTag.Li,             TagType.Inline);
            RegisterTag("link",       HtmlTextWriterTag.Link,           TagType.NonClosing);
            RegisterTag("map",        HtmlTextWriterTag.Map,            TagType.Other);
            RegisterTag("marquee",    HtmlTextWriterTag.Marquee,        TagType.Other);
            RegisterTag("menu",       HtmlTextWriterTag.Menu,           TagType.Other);
            RegisterTag("meta",       HtmlTextWriterTag.Meta,           TagType.NonClosing);
            RegisterTag("nobr",       HtmlTextWriterTag.Nobr,           TagType.Inline);
            RegisterTag("noframes",   HtmlTextWriterTag.Noframes,       TagType.Other);
            RegisterTag("noscript",   HtmlTextWriterTag.Noscript,       TagType.Other);
            RegisterTag("object",     HtmlTextWriterTag.Object,         TagType.Other);
            RegisterTag("ol",         HtmlTextWriterTag.Ol,             TagType.Other);
            RegisterTag("option",     HtmlTextWriterTag.Option,         TagType.Other);
            RegisterTag("p",          HtmlTextWriterTag.P,              TagType.Inline);
            RegisterTag("param",      HtmlTextWriterTag.Param,          TagType.Other);
            RegisterTag("pre",        HtmlTextWriterTag.Pre,            TagType.Other);
            RegisterTag("ruby",       HtmlTextWriterTag.Ruby,           TagType.Other);
            RegisterTag("rt",         HtmlTextWriterTag.Rt,             TagType.Other);
            RegisterTag("q",          HtmlTextWriterTag.Q,              TagType.Inline);
            RegisterTag("s",          HtmlTextWriterTag.S,              TagType.Inline);
            RegisterTag("samp",       HtmlTextWriterTag.Samp,           TagType.Inline);
            RegisterTag("script",     HtmlTextWriterTag.Script,         TagType.Other);
            RegisterTag("select",     HtmlTextWriterTag.Select,         TagType.Other);
            RegisterTag("small",      HtmlTextWriterTag.Small,          TagType.Other);
            RegisterTag("span",       HtmlTextWriterTag.Span,           TagType.Inline);
            RegisterTag("strike",     HtmlTextWriterTag.Strike,         TagType.Inline);
            RegisterTag("strong",     HtmlTextWriterTag.Strong,         TagType.Inline);
            RegisterTag("style",      HtmlTextWriterTag.Style,          TagType.Other);
            RegisterTag("sub",        HtmlTextWriterTag.Sub,            TagType.Inline);
            RegisterTag("sup",        HtmlTextWriterTag.Sup,            TagType.Inline);
            RegisterTag("table",      HtmlTextWriterTag.Table,          TagType.Other);
            RegisterTag("tbody",      HtmlTextWriterTag.Tbody,          TagType.Other);
            RegisterTag("td",         HtmlTextWriterTag.Td,             TagType.Inline);
            RegisterTag("textarea",   HtmlTextWriterTag.Textarea,       TagType.Inline);
            RegisterTag("tfoot",      HtmlTextWriterTag.Tfoot,          TagType.Other);
            RegisterTag("th",         HtmlTextWriterTag.Th,             TagType.Inline);
            RegisterTag("thead",      HtmlTextWriterTag.Thead,          TagType.Other);
            RegisterTag("title",      HtmlTextWriterTag.Title,          TagType.Other);
            RegisterTag("tr",         HtmlTextWriterTag.Tr,             TagType.Other);
            RegisterTag("tt",         HtmlTextWriterTag.Tt,             TagType.Inline);
            RegisterTag("u",          HtmlTextWriterTag.U,              TagType.Inline);
            RegisterTag("ul",         HtmlTextWriterTag.Ul,             TagType.Other);
            RegisterTag("var",        HtmlTextWriterTag.Var,            TagType.Inline);
            RegisterTag("wbr",        HtmlTextWriterTag.Wbr,            TagType.NonClosing);
            RegisterTag("xml",        HtmlTextWriterTag.Xml,            TagType.Other);

            // register known attributes
            _attrKeyLookupTable = new Hashtable((int)HtmlTextWriterAttribute.Wrap + 1);
            _attrNameLookupArray = new AttributeInformation[(int)HtmlTextWriterAttribute.Wrap+1];

            RegisterAttribute("accesskey",      HtmlTextWriterAttribute.Accesskey,   true);
            RegisterAttribute("align",          HtmlTextWriterAttribute.Align,       false);
            RegisterAttribute("alt",            HtmlTextWriterAttribute.Alt,         true);
            RegisterAttribute("background",     HtmlTextWriterAttribute.Background,  true);
            RegisterAttribute("bgcolor",        HtmlTextWriterAttribute.Bgcolor,     false);
            RegisterAttribute("border",         HtmlTextWriterAttribute.Border,      false);
            RegisterAttribute("bordercolor",    HtmlTextWriterAttribute.Bordercolor, false);
            RegisterAttribute("cellpadding",    HtmlTextWriterAttribute.Cellpadding, false);
            RegisterAttribute("cellspacing",    HtmlTextWriterAttribute.Cellspacing, false);
            RegisterAttribute("checked",        HtmlTextWriterAttribute.Checked,     false);
            RegisterAttribute("class",          HtmlTextWriterAttribute.Class,       true);
            RegisterAttribute("cols",           HtmlTextWriterAttribute.Cols,        false);
            RegisterAttribute("colspan",        HtmlTextWriterAttribute.Colspan,     false);
            RegisterAttribute("disabled",       HtmlTextWriterAttribute.Disabled,    false);
            RegisterAttribute("for",            HtmlTextWriterAttribute.For,         false);
            RegisterAttribute("height",         HtmlTextWriterAttribute.Height,      false);
            RegisterAttribute("href",           HtmlTextWriterAttribute.Href,        true);
            RegisterAttribute("id",             HtmlTextWriterAttribute.Id,          false);
            RegisterAttribute("maxlength",      HtmlTextWriterAttribute.Maxlength,   false);
            RegisterAttribute("multiple",       HtmlTextWriterAttribute.Multiple,    false);
            RegisterAttribute("name",           HtmlTextWriterAttribute.Name,        false);
            RegisterAttribute("nowrap",         HtmlTextWriterAttribute.Nowrap,      false);
            RegisterAttribute("onclick",        HtmlTextWriterAttribute.Onclick,     true);
            RegisterAttribute("onchange",       HtmlTextWriterAttribute.Onchange,    true);
            RegisterAttribute("readonly",       HtmlTextWriterAttribute.ReadOnly,    false);
            RegisterAttribute("rows",           HtmlTextWriterAttribute.Rows,        false);
            RegisterAttribute("rowspan",        HtmlTextWriterAttribute.Rowspan,     false);
            RegisterAttribute("rules",          HtmlTextWriterAttribute.Rules,       false);
            RegisterAttribute("selected",       HtmlTextWriterAttribute.Selected,    false);
            RegisterAttribute("size",           HtmlTextWriterAttribute.Size,        false);
            RegisterAttribute("src",            HtmlTextWriterAttribute.Src,         true);
            RegisterAttribute("style",          HtmlTextWriterAttribute.Style,       false);
            RegisterAttribute("tabindex",       HtmlTextWriterAttribute.Tabindex,    false);
            RegisterAttribute("target",         HtmlTextWriterAttribute.Target,      false);
            RegisterAttribute("title",          HtmlTextWriterAttribute.Title,       true);
            RegisterAttribute("type",           HtmlTextWriterAttribute.Type,        false);
            RegisterAttribute("valign",         HtmlTextWriterAttribute.Valign,      false);
            RegisterAttribute("value",          HtmlTextWriterAttribute.Value,       true);
            RegisterAttribute("width",          HtmlTextWriterAttribute.Width,       false);
            RegisterAttribute("wrap",           HtmlTextWriterAttribute.Wrap,        false);

            // register known styles
            _styleKeyLookupTable = new Hashtable((int)HtmlTextWriterStyle.Width + 1);
            _styleNameLookupArray = new string[(int)HtmlTextWriterStyle.Width+1];

            RegisterStyle("background-color",HtmlTextWriterStyle.BackgroundColor);
            RegisterStyle("background-image",HtmlTextWriterStyle.BackgroundImage);
            RegisterStyle("border-collapse",HtmlTextWriterStyle.BorderCollapse);
            RegisterStyle("border-color",HtmlTextWriterStyle.BorderColor);
            RegisterStyle("border-style",HtmlTextWriterStyle.BorderStyle);
            RegisterStyle("border-width",HtmlTextWriterStyle.BorderWidth);
            RegisterStyle("color",HtmlTextWriterStyle.Color);
            RegisterStyle("font-family",HtmlTextWriterStyle.FontFamily);
            RegisterStyle("font-size",HtmlTextWriterStyle.FontSize);
            RegisterStyle("font-style",HtmlTextWriterStyle.FontStyle);
            RegisterStyle("font-weight",HtmlTextWriterStyle.FontWeight);
            RegisterStyle("height",HtmlTextWriterStyle.Height);
            RegisterStyle("text-decoration",HtmlTextWriterStyle.TextDecoration);
            RegisterStyle("width",HtmlTextWriterStyle.Width);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Encoding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Encoding Encoding {
            get {
                return writer.Encoding;
            }
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.NewLine"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the new line character to use.
        ///    </para>
        /// </devdoc>
        public override string NewLine {
            get {
                return writer.NewLine;
            }

            set {
                writer.NewLine = value;
            }
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Indent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of spaces to indent.
        ///    </para>
        /// </devdoc>
        public int Indent {
            get {
                return indentLevel;
            }
            set {
                Diagnostics.Debug.Assert(value >= 0, "Bogus Indent... probably caused by mismatched Indent++ and Indent--");
                if (value < 0) {
                    value = 0;
                }
                indentLevel = value;
            }
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.InnerWriter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the TextWriter to use.
        ///    </para>
        /// </devdoc>
        public TextWriter InnerWriter {
            get {
                return writer;
            }
            set {
                writer = value;
                _httpWriter = value as HttpWriter;
            }
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes the document being written to.
        ///    </para>
        /// </devdoc>
        public override void Close() {
            writer.Close();
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Flush"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Flush() {
            writer.Flush();
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.OutputTabs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OutputTabs() {
            if (tabsPending) {
                for (int i=0; i < indentLevel; i++) {
                    writer.Write(tabString);
                }
                tabsPending = false;
            }
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Write"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes a string
        ///       to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(string s) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(s);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Write1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of a Boolean value to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(bool value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(value);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Write2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes a character to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(char value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(value);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Write3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes a
        ///       character array to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(char[] buffer) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(buffer);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Write4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes a subarray
        ///       of characters to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(char[] buffer, int index, int count) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(buffer, index, count);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Write5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of a Double to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(double value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(value);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Write6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of
        ///       a Single to the text
        ///       stream.
        ///    </para>
        /// </devdoc>
        public override void Write(float value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(value);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Write7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of an integer to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(int value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(value);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Write8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of an 8-byte integer to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(long value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(value);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Write9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of an object
        ///       to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(object value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(value);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Write10"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out a formatted string, using the same semantics as specified.
        ///    </para>
        /// </devdoc>
        public override void Write(string format, object arg0) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(format, arg0);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Write11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out a formatted string,
        ///       using the same semantics as specified.
        ///    </para>
        /// </devdoc>
        public override void Write(string format, object arg0, object arg1) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(format, arg0, arg1);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.Write12"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out a formatted string,
        ///       using the same semantics as specified.
        ///    </para>
        /// </devdoc>
        public override void Write(string format, params object[] arg) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(format, arg);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLineNoTabs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the specified
        ///       string to a line without tabs.
        ///    </para>
        /// </devdoc>
        public void WriteLineNoTabs(string s) {
            writer.WriteLine(s);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the specified string followed by
        ///       a line terminator to the text stream.
        ///    </para>
        /// </devdoc>
        public override void WriteLine(string s) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(s);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes a line terminator.
        ///    </para>
        /// </devdoc>
        public override void WriteLine() {
            writer.WriteLine();
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of a Boolean followed by a line terminator to
        ///       the text stream.
        ///    </para>
        /// </devdoc>
        public override void WriteLine(bool value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(char value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(char[] buffer) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(buffer);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(char[] buffer, int index, int count) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(buffer, index, count);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(double value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(float value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine8"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(int value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine9"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(long value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine10"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(object value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine11"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(string format, object arg0) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(format, arg0);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine12"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(string format, object arg0, object arg1) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(format, arg0, arg1);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine13"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(string format, params object[] arg) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(format, arg);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteLine14"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [CLSCompliant(false)]
        public override void WriteLine(UInt32 value) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.RegisterTag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected static void RegisterTag(string name, HtmlTextWriterTag key) {
            RegisterTag(name, key, TagType.Other);
        }

        private static void RegisterTag(string name, HtmlTextWriterTag key, TagType type) {
            string nameLCase = name.ToLower(CultureInfo.InvariantCulture);

            _tagKeyLookupTable.Add(nameLCase, key);

            // Pre-resolve the end tag
            string endTag = null;
            if (type != TagType.NonClosing && key != HtmlTextWriterTag.Unknown) {
                endTag = EndTagLeftChars + nameLCase + TagRightChar.ToString();
            }

            if ((int)key < _tagNameLookupArray.Length) {
                _tagNameLookupArray[(int)key] = new TagInformation(name, type, endTag);
            }
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.RegisterAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected static void RegisterAttribute(string name, HtmlTextWriterAttribute key) {
            RegisterAttribute(name, key, false);
        }

        private static void RegisterAttribute(string name, HtmlTextWriterAttribute key, bool fEncode) {
            string nameLCase = name.ToLower(CultureInfo.InvariantCulture);

            _attrKeyLookupTable.Add(nameLCase, key);

            if ((int)key < _attrNameLookupArray.Length) {
                _attrNameLookupArray[(int)key] = new AttributeInformation(name, fEncode);
            }
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.RegisterStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected static void RegisterStyle(string name, HtmlTextWriterStyle key) {
            string nameLCase = name.ToLower(CultureInfo.InvariantCulture);
            
            _styleKeyLookupTable.Add(nameLCase, key);
            if ((int)key < _styleNameLookupArray.Length)
                _styleNameLookupArray[(int)key] = name;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.HtmlTextWriter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HtmlTextWriter(TextWriter writer) : this(writer, DefaultTabString) {
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.HtmlTextWriter1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HtmlTextWriter(TextWriter writer, string tabString) {
            this.writer = writer;
            this.tabString = tabString;
            indentLevel = 0;
            tabsPending = false;

            // If it's an http writer, save it
            _httpWriter = writer as HttpWriter;

            _isDescendant = (GetType() != typeof(HtmlTextWriter));


            _attrList = new RenderAttribute[20];
            _attrCount = 0;
            _styleList = new RenderStyle[20];
            _styleCount = 0;
            _endTags = new TagStackEntry[16];
            _endTagCount = 0;
            _inlineCount = 0;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.TagKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected HtmlTextWriterTag TagKey {
            get {   
                return _tagKey; 
            }
            set {
                _tagIndex = (int) value;
                if (_tagIndex < 0 || _tagIndex >= _tagNameLookupArray.Length) {
                    throw new ArgumentOutOfRangeException("value");
                }
                _tagKey = value;
                // If explicitly setting to uknown, keep the old tag name. This allows a string tag
                // to be set without clobbering it if setting TagKey to itself.
                if (value != HtmlTextWriterTag.Unknown) {
                    _tagName = _tagNameLookupArray[_tagIndex].name;
                }
            }
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.TagName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected string TagName {
            get {   
                return _tagName; 
            }
            set {
                _tagName = value;
                _tagKey = GetTagKey(_tagName);
                _tagIndex = (int) _tagKey;
                Diagnostics.Debug.Assert(_tagIndex >= 0 && _tagIndex < _tagNameLookupArray.Length);
            }
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.AddAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void AddAttribute(string name,string value) {
            HtmlTextWriterAttribute attrKey = GetAttributeKey(name);
            value = EncodeAttributeValue(attrKey, value);

            AddAttribute(name, value, attrKey);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.AddAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void AddAttribute(string name,string value, bool fEndode) {
            value = EncodeAttributeValue(value, fEndode);
            AddAttribute(name, value, GetAttributeKey(name));
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.AddAttribute2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void AddAttribute(HtmlTextWriterAttribute key,string value) {
            int attributeIndex = (int) key;
            if (attributeIndex >= 0 &&  attributeIndex < _attrNameLookupArray.Length) {
                AttributeInformation info = _attrNameLookupArray[attributeIndex];
                AddAttribute(info.name,value,key, info.encode);        
            }
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.AddAttribute3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void AddAttribute(HtmlTextWriterAttribute key,string value, bool fEncode) {
            int attributeIndex = (int) key;
            if (attributeIndex >= 0 &&  attributeIndex < _attrNameLookupArray.Length) {
                AttributeInformation info = _attrNameLookupArray[attributeIndex];
                AddAttribute(info.name,value,key, fEncode);        
            }
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.AddAttribute4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void AddAttribute(string name, string value, HtmlTextWriterAttribute key) {
            AddAttribute(name, value, key, false);
        }


        private void AddAttribute(string name, string value, HtmlTextWriterAttribute key, bool encode) {
            if (_attrCount >= _attrList.Length) {
                RenderAttribute[] newArray = new RenderAttribute[_attrList.Length * 2];
                Array.Copy(_attrList, newArray, _attrList.Length);
                _attrList = newArray;
            }
            RenderAttribute attr;
            attr.name = name;
            attr.value = value;
            attr.key = key;
            attr.encode = encode;
            _attrList[_attrCount] = attr;
            _attrCount++;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.AddStyleAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void AddStyleAttribute(string name, string value) {
            AddStyleAttribute(name,value,GetStyleKey(name));
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.AddStyleAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void AddStyleAttribute(HtmlTextWriterStyle key, string value) {
            AddStyleAttribute(GetStyleName(key),value,key);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.AddStyleAttribute2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void AddStyleAttribute(string name, string value, HtmlTextWriterStyle key) {
            if (_styleCount > _styleList.Length) {
                RenderStyle[] newArray = new RenderStyle[_styleList.Length * 2];
                Array.Copy(_styleList, newArray, _styleList.Length);
                _styleList = newArray;
            }
            RenderStyle style;
            style.name = name;
            style.value = value;
            style.key = key;
            _styleList[_styleCount] = style;
            _styleCount++;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.EncodeAttributeValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected string EncodeAttributeValue(string value, bool fEncode) {
            if (value == null) {
                return null;
            }

            if (!fEncode)
                return value;

            return HttpUtility.HtmlAttributeEncode(value);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.EncodeAttributeValue1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string EncodeAttributeValue(HtmlTextWriterAttribute attrKey, string value) {
            bool fEncode = true;

            if (0 <= (int)attrKey && (int)attrKey < _attrNameLookupArray.Length) {
                fEncode = _attrNameLookupArray[(int)attrKey].encode;
            }

            return EncodeAttributeValue(value, fEncode);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.EncodeUrl"]/*' />
        /// <devdoc>
        ///   This does minimal URL encoding by converting spaces in the url
        ///   to "%20".
        /// </devdoc>
        protected string EncodeUrl(string url) {
            int index = url.IndexOf(SpaceChar);

            if (index < 0)
                return url;

            StringBuilder builder = new StringBuilder();

            int cb = url.Length;
            for (int i = 0; i < cb; i++) {
                char ch = url[i];

                if (ch != ' ')
                    builder.Append(ch);
                else
                    builder.Append("%20");
            }

            return builder.ToString();
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.GetAttributeKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected HtmlTextWriterAttribute GetAttributeKey(string attrName) {
            if (attrName != null && attrName.Length > 0) {
                object key = _attrKeyLookupTable[attrName.ToLower(CultureInfo.InvariantCulture)];
                if (key != null)
                    return (HtmlTextWriterAttribute)key;
            }

            return (HtmlTextWriterAttribute)(-1);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.GetAttributeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected string GetAttributeName(HtmlTextWriterAttribute attrKey) {
            if ((int)attrKey >= 0 && (int)attrKey < _attrNameLookupArray.Length)
                return _attrNameLookupArray[(int)attrKey].name;

            return string.Empty;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.GetStyleKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected HtmlTextWriterStyle GetStyleKey(string styleName) {
            if (styleName != null && styleName.Length > 0) {
                object key = _styleKeyLookupTable[styleName.ToLower(CultureInfo.InvariantCulture)];
                if (key != null)
                    return (HtmlTextWriterStyle)key;
            }

            return (HtmlTextWriterStyle)(-1);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.GetStyleName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected string GetStyleName(HtmlTextWriterStyle styleKey) {
            if ((int)styleKey >= 0 && (int)styleKey < _styleNameLookupArray.Length)
                return _styleNameLookupArray[(int)styleKey];

            return string.Empty;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.GetTagKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual HtmlTextWriterTag GetTagKey(string tagName) {
            if (tagName != null && tagName.Length > 0) {
                object key = _tagKeyLookupTable[tagName.ToLower(CultureInfo.InvariantCulture)];
                if (key != null)
                    return (HtmlTextWriterTag)key;
            }

            return HtmlTextWriterTag.Unknown;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.GetTagName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string GetTagName(HtmlTextWriterTag tagKey) {
            int tagIndex = (int) tagKey;
            if (tagIndex >= 0 && tagIndex < _tagNameLookupArray.Length)
                return _tagNameLookupArray[tagIndex].name;

            return string.Empty;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.IsAttributeDefined"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool IsAttributeDefined(HtmlTextWriterAttribute key) {
            for (int i = 0; i < _attrCount; i++) {
                if (_attrList[i].key == key) {
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.IsAttributeDefined1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool IsAttributeDefined(HtmlTextWriterAttribute key, out string value) {
            value = null;
            for (int i = 0; i < _attrCount; i++) {
                if (_attrList[i].key == key) {
                    value = _attrList[i].value;
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.IsStyleAttributeDefined"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool IsStyleAttributeDefined(HtmlTextWriterStyle key) {
            for (int i = 0; i < _styleCount; i++) {
                if (_styleList[i].key == key) {
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.IsStyleAttributeDefined1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool IsStyleAttributeDefined(HtmlTextWriterStyle key, out string value) {
            value = null;
            for (int i = 0; i < _styleCount; i++) {
                if (_styleList[i].key == key) {
                    value = _styleList[i].value;
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.OnAttributeRender"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool OnAttributeRender(string name, string value, HtmlTextWriterAttribute key) {
            return true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.OnStyleAttributeRender"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool OnStyleAttributeRender(string name, string value, HtmlTextWriterStyle key) {
            return true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.OnTagRender"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool OnTagRender(string name, HtmlTextWriterTag key) {
            return true;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.PopEndTag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected string PopEndTag() {
            if (_endTagCount <= 0) {
                throw new InvalidOperationException(SR.GetString(SR.HTMLTextWriterUnbalancedPop));
            }
            _endTagCount--;
            TagKey = _endTags[_endTagCount].tagKey;
            return _endTags[_endTagCount].endTagText;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.PushEndTag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void PushEndTag(string endTag) {
            if (_endTagCount >= _endTags.Length) {
                TagStackEntry[] newArray = new TagStackEntry[_endTags.Length * 2];
                Array.Copy(_endTags, newArray, _endTags.Length);
                _endTags = newArray;
            }
            _endTags[_endTagCount].tagKey = _tagKey;
            _endTags[_endTagCount].endTagText= endTag;
            _endTagCount++;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.PreFilterProperties"]/*' />
        /// <devdoc>
        ///    <para>This calls filers out all attributes and style attributes by calling OnAttributeRender 
        ///    and OnStyleAttributeRender on all properites and updates the lists</para>
        /// </devdoc>
        protected virtual void FilterAttributes() {

            // Create the filtered list of styles
            int newStyleCount = 0;
            for (int i = 0; i < _styleCount; i++) {
                RenderStyle style = _styleList[i];
                if (OnStyleAttributeRender(style.name, style.value, style.key)) {
                    // Update the list. This can be done in place
                    _styleList[newStyleCount] = style;
                    newStyleCount++;
                }
            }
            // Update the count
            _styleCount = newStyleCount;

            // Create the filtered list of attributes
            int newAttrCount = 0;
            for (int i = 0; i < _attrCount; i++) {
                RenderAttribute attr = _attrList[i];    
                if (OnAttributeRender(attr.name, attr.value, attr.key)) {
                    // Update the list. This can be done in place
                    _attrList[newAttrCount] = attr;
                    newAttrCount++;
                }
            }
            // Update the count
            _attrCount = newAttrCount;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.RenderBeginTag2"]/*' />
        public virtual void RenderBeginTag(string tagName) {
            this.TagName = tagName;
            RenderBeginTag(_tagKey);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.RenderBeginTag1"]/*' />
        public virtual void RenderBeginTag(HtmlTextWriterTag tagKey) {

            this.TagKey = tagKey;
            bool renderTag = true;

            if (_isDescendant) {
                renderTag = OnTagRender(_tagName, _tagKey);

                // Inherited renderers will be expecting to be able to filter any of the attributes at this point
                FilterAttributes();

                // write text before begin tag
                string textBeforeTag = RenderBeforeTag();
                if (textBeforeTag != null) {
                    if (tabsPending) {
                        OutputTabs();
                    }
                    writer.Write(textBeforeTag);
                }
            }

            // gather information about this tag.
            TagInformation tagInfo = _tagNameLookupArray[_tagIndex];
            TagType tagType = tagInfo.tagType;
            string endTag = tagInfo.closingTag;
            bool renderEndTag = renderTag && (tagType != TagType.NonClosing);

            // write the begin tag
            if (renderTag) {
                if (tabsPending) {
                    OutputTabs();
                }
                writer.Write(TagLeftChar);
                writer.Write(_tagName);

                string styleValue = null;

                for (int i = 0; i < _attrCount; i++) {
                    RenderAttribute attr = _attrList[i];    
                    if (attr.key == HtmlTextWriterAttribute.Style) {
                        // append style attribute in with other styles
                        styleValue = attr.value;
                    }
                    else {
                        writer.Write(SpaceChar);
                        writer.Write(attr.name);
                        if (attr.value != null) {
                            writer.Write(EqualsChar);
                            writer.Write(DoubleQuoteChar);
                            if (attr.encode) {
                                if (_httpWriter == null) {
                                    HttpUtility.HtmlAttributeEncode(attr.value, writer);
                                }
                                else {
                                    HttpUtility.HtmlAttributeEncodeInternal(attr.value, _httpWriter);
                                }
                            }
                            else {
                                writer.Write(attr.value);
                            }
                            writer.Write(DoubleQuoteChar);
                        }
                    }
                }


                if (_styleCount > 0 || styleValue != null) {
                    writer.Write(SpaceChar);
                    writer.Write("style");
                    writer.Write(EqualsChar);
                    writer.Write(DoubleQuoteChar);

                    for (int i = 0; i< _styleCount; i++) {
                        RenderStyle style = _styleList[i];
                        writer.Write(style.name);
                        writer.Write(StyleEqualsChar);
                        // CONSIDER: Should Style attributes be encoded... any form of encoding?
                        writer.Write(style.value);
                        writer.Write(SemicolonChar);
                    }

                    if (styleValue != null) {
                        writer.Write(styleValue);
                    }
                    writer.Write(DoubleQuoteChar);
                }

                if (tagType == TagType.NonClosing) {
                    writer.Write(SpaceChar);
                    writer.Write(SlashChar);
                    writer.Write(TagRightChar);
                }
                else {
                    writer.Write(TagRightChar);
                }
            }

            string textBeforeContent = RenderBeforeContent();
            if (textBeforeContent != null) {
                if (tabsPending) {
                    OutputTabs();
                }
                writer.Write(textBeforeContent);
            }

            // write text before the content
            if (renderEndTag) {

                if (tagType == TagType.Inline) {
                    _inlineCount += 1;
                }
                else {
                    // writeline and indent before rendering content
                    WriteLine();
                    Indent++;
                }
                // Manually build end tags for unknown tag types.
                if (endTag == null) {
                    endTag = EndTagLeftChars + _tagName + TagRightChar.ToString();
                }
            }

            if (_isDescendant) {
                // build end content and push it on stack to write in RenderEndTag
                // prepend text after the content
                string textAfterContent = RenderAfterContent();
                if (textAfterContent != null) {
                    endTag = (endTag == null) ? textAfterContent : textAfterContent + endTag;
                }

                // append text after the tag
                string textAfterTag = RenderAfterTag();
                if (textAfterTag != null) {
                    endTag = (endTag == null) ? textAfterTag : textAfterTag + endTag;
                }
            }

            // push end tag onto stack
            PushEndTag(endTag);

            // flush attribute and style lists for next tag
            _attrCount = 0;
            _styleCount = 0;

        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.RenderEndTag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void RenderEndTag() {
            string endTag = PopEndTag();

            if (endTag != null) {
                if (_tagNameLookupArray[_tagIndex].tagType == TagType.Inline) {
                    _inlineCount -= 1;
                    // Never inject crlfs at end of inline tags.
                    //
                    Write(endTag);
                }
                else {
                    // unindent if not an inline tag
                    WriteLine();
                    this.Indent--;
                    Write(endTag);
                }
            }
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.RenderBeforeTag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string RenderBeforeTag() {
            return null;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.RenderBeforeContent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string RenderBeforeContent() {
            return null;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.RenderAfterContent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string RenderAfterContent() {
            return null;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.RenderAfterTag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string RenderAfterTag() {
            return null;
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void WriteAttribute(string name, string value) {
            WriteAttribute(name, value, false /*fEncode*/);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void WriteAttribute(string name, string value, bool fEncode) {
            writer.Write(SpaceChar);
            writer.Write(name);
            if (value != null) {
                writer.Write(EqualsChar);
                writer.Write(DoubleQuoteChar);
                if (fEncode) {
                    if (_httpWriter == null) {
                        HttpUtility.HtmlAttributeEncode(value, writer);
                    }
                    else {
                        HttpUtility.HtmlAttributeEncodeInternal(value, _httpWriter);
                    }
                }
                else {
                    writer.Write(value);
                }
                writer.Write(DoubleQuoteChar);
            }
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteBeginTag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void WriteBeginTag(string tagName) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(TagLeftChar);
            writer.Write(tagName);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteFullBeginTag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void WriteFullBeginTag(string tagName) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(TagLeftChar);
            writer.Write(tagName);
            writer.Write(TagRightChar);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteEndTag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void WriteEndTag(string tagName) {
            if (tabsPending) {
                OutputTabs();
            }
            writer.Write(TagLeftChar);
            writer.Write(SlashChar);
            writer.Write(tagName);
            writer.Write(TagRightChar);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteStyleAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void WriteStyleAttribute(string name, string value) {
            WriteStyleAttribute(name, value, false /*fEncode*/);
        }

        /// <include file='doc\HtmlTextWriter.uex' path='docs/doc[@for="HtmlTextWriter.WriteStyleAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void WriteStyleAttribute(string name, string value, bool fEncode) {
            writer.Write(name);
            writer.Write(StyleEqualsChar);
            if (fEncode) {
                if (_httpWriter == null) {
                    HttpUtility.HtmlAttributeEncode(value, writer);
                }
                else {
                    HttpUtility.HtmlAttributeEncodeInternal(value, _httpWriter);
                }
            }
            else {
                writer.Write(value);
            }
            writer.Write(SemicolonChar);
        }

        internal void WriteUTF8ResourceString(IntPtr pv, int offset, int size, bool fAsciiOnly) {

            // If we have an http writer, we can use the faster code path.  Otherwise,
            // get a String out of the resource and write it.
            if (_httpWriter != null) {
                _httpWriter.WriteUTF8ResourceString(pv, offset, size, fAsciiOnly);
            } else {
                Write(StringResourceManager.ResourceToString(pv, offset, size));
            }
        }

        private struct TagStackEntry {
            public HtmlTextWriterTag tagKey;
            public string endTagText;
        }

        private struct RenderAttribute {
            public string name;
            public string value;
            public HtmlTextWriterAttribute key;
            public bool encode;
        }

        private struct RenderStyle {
            public string name;
            public string value;
            public HtmlTextWriterStyle key;
        }

        private struct AttributeInformation {
            public string name;
            public bool encode;

            public AttributeInformation(string name, bool encode) {
                this.name = name;
                this.encode = encode;
            }
        }

        private enum TagType {
            Inline,
            NonClosing,
            Other,
        }

        private struct TagInformation {
            public string name;
            public TagType tagType;
            public string closingTag;

            public TagInformation(string name, TagType tagType, string closingTag) {
                this.name = name;
                this.tagType = tagType;
                this.closingTag = closingTag;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\ipostbackeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="IPostBackEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Controls that will generate postback events from the client should implement this interface.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.UI {
using System;


/// <include file='doc\IPostBackEventHandler.uex' path='docs/doc[@for="IPostBackEventHandler"]/*' />
/// <devdoc>
///    <para> Defines the contract that controls must implement to
///       handle low-level post back events.</para>
/// </devdoc>
public interface IPostBackEventHandler {
    /*
     * Process the event that this control wanted fired from a form post back.
     */
    /// <include file='doc\IPostBackEventHandler.uex' path='docs/doc[@for="IPostBackEventHandler.RaisePostBackEvent"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Enables a control to process the event fired by a form post back.
    ///    </para>
    /// </devdoc>
    void RaisePostBackEvent(string eventArgument);
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\itemplate.cs ===
//------------------------------------------------------------------------------
// <copyright file="ITemplate.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * A factory for populating a control with children and setting attributes on the
 * control.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.UI {

using System;

/// <include file='doc\ITemplate.uex' path='docs/doc[@for="ITemplate"]/*' />
/// <devdoc>
///    <para>
///       Provides a factory definition for populating a control with child
///       controls from an inline template within a page file.
///    </para>
/// </devdoc>
public interface ITemplate {
    /// <include file='doc\ITemplate.uex' path='docs/doc[@for="ITemplate.InstantiateIn"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Iteratively populates a provided <see cref='System.Web.UI.ControlCollection'/>
    ///       Control with a sub-hierarchy of child controls represented by the template.
    ///    </para>
    /// </devdoc>
    void InstantiateIn(Control container);
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\istatemanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="IStateManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Interface implemented by objects that support state management.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.UI {

/// <include file='doc\IStateManager.uex' path='docs/doc[@for="IStateManager"]/*' />
/// <devdoc>
///    <para>Defines the contract that controls must implement to support state 
///       management.</para>
/// </devdoc>
public interface IStateManager {
    /*
     * Return true if tracking state changes.
     */
    /// <include file='doc\IStateManager.uex' path='docs/doc[@for="IStateManager.IsTrackingViewState"]/*' />
    /// <devdoc>
    ///    <para>Determines if state changes are being tracked.</para>
    ///    </devdoc>
    bool IsTrackingViewState {
        get;
    }
    
    /*
     * Load previously saved state.
     */
    /// <include file='doc\IStateManager.uex' path='docs/doc[@for="IStateManager.LoadViewState"]/*' />
    /// <devdoc>
    ///    <para>Loads the specified control's previously saved state.</para>
    ///    </devdoc>
    void LoadViewState(object state);

    /*
     * Return object containing state changes.
     */
    /// <include file='doc\IStateManager.uex' path='docs/doc[@for="IStateManager.SaveViewState"]/*' />
    /// <devdoc>
    ///    <para>Returns the object that contains the state changes.</para>
    ///    </devdoc>
    object SaveViewState();

    /*
     * Start tracking state changes.
     */
    /// <include file='doc\IStateManager.uex' path='docs/doc[@for="IStateManager.TrackViewState"]/*' />
    /// <devdoc>
    ///    <para>Instructs the control to start tracking changes in state.</para>
    ///    </devdoc>
    void TrackViewState();


}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\ivalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="IValidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI {

    /// <include file='doc\IValidator.uex' path='docs/doc[@for="IValidator"]/*' />
    /// <devdoc>
    ///    <para>Defines the contract that the validation controls must implement.</para>
    /// </devdoc>
    public interface IValidator {    
                
        /// <include file='doc\IValidator.uex' path='docs/doc[@for="IValidator.IsValid"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the content entered in a control is valid.</para>
        /// </devdoc>
        bool IsValid {
            get;
            set;
        }
        
        /// <include file='doc\IValidator.uex' path='docs/doc[@for="IValidator.ErrorMessage"]/*' />
        /// <devdoc>
        ///    <para>Indicates the error message text generated when the control's content is not 
        ///       valid.</para>
        /// </devdoc>
        string ErrorMessage { 
            get;
            set;
        }
                
        /// <include file='doc\IValidator.uex' path='docs/doc[@for="IValidator.Validate"]/*' />
        /// <devdoc>
        ///    <para>Compares the entered content with the valid parameters provided by the 
        ///       validation control.</para>
        /// </devdoc>
        void Validate();
    }              
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\iusercontroldesigneraccessor.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDataBindingsAccessor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;

    /// <include file='doc\IUserControlDesignerAccessor.uex' path='docs/doc[@for="IUserControlDesignerAccessor"]/*' />
    /// <devdoc>
    ///   <para>Allows designer functionality to access information about a UserControl, that is
    ///     applicable at design-time only.
    ///   </para>
    /// </devdoc>
    public interface IUserControlDesignerAccessor {

        /// <include file='doc\IUserControlDesignerAccessor.uex' path='docs/doc[@for="IUserControlDesignerAccessor.InnerText"]/*' />
        string InnerText {
            get;
            set;
        }

        /// <include file='doc\IUserControlDesignerAccessor.uex' path='docs/doc[@for="IUserControlDesignerAccessor.TagName"]/*' />
        string TagName {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\objectconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * An object that can convert from one object type to another, potentially using a format
 * string if the conversion is to a string.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.UI {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;

    using System;
    using System.Security.Permissions;

// CONSIDER: This should be made sane with the Convert class; it just doesn't support
// format strings, or automatic type conversion.
    /// <include file='doc\ObjectConverter.uex' path='docs/doc[@for="ObjectConverter"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [Obsolete("Use the System.Convert class and String.Format instead")]
    public sealed class ObjectConverter {
        internal static readonly char [] formatSeparator = new char[] { ','};

        /// <include file='doc\ObjectConverter.uex' path='docs/doc[@for="ObjectConverter.ConvertValue"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public static object ConvertValue(object value, Type toType, string formatString) {
            // Workaround for now to handle inability of reflection to deal with Null.
            if (value == null || Convert.IsDBNull(value)) {
                return value;
            }

            Type fromType = value.GetType();

            if (toType.IsAssignableFrom(fromType)) {
                return value;
            }

            // for now, just hit the sweet spots.
            if (typeof(string).IsAssignableFrom(fromType)) {
                if (typeof(int).IsAssignableFrom(toType)) {
                    return Convert.ToInt32((string)value);
                }
                else if (typeof(bool).IsAssignableFrom(toType)) {
                    return Convert.ToBoolean((string)value);
                }
                else if (typeof(DateTime).IsAssignableFrom(toType)) {
                    return Convert.ToDateTime((string)value);
                }
                else if (typeof(Decimal).IsAssignableFrom(toType)) {
                    TypeConverter tc = new DecimalConverter();                
                    return tc.ConvertFromInvariantString((string)value);
                }
                else if (typeof(Double).IsAssignableFrom(toType)) {
                    return Convert.ToDouble((string)value);
                }
                else if (typeof(Int16).IsAssignableFrom(toType)) {
                    return Convert.ToInt16((Int16)value);
                }
                else {
                    throw new ArgumentException(
                                               HttpRuntime.FormatResourceString(SR.Cannot_convert_from_to, fromType.ToString(), toType.ToString()));
                }
            }
            else if (typeof(string).IsAssignableFrom(toType)) {
                if (typeof(int).IsAssignableFrom(fromType)) {
                    return ((int)value).ToString(formatString);
                }
                else if (typeof(bool).IsAssignableFrom(fromType)) {
                    string [] tokens=null;

                    if (formatString != null) {
                        tokens = formatString.Split(formatSeparator);
                        if (tokens.Length != 2) {
                            tokens = null;
                        }
                    }

                    if ((bool)value) {
                        if (tokens != null) {
                            return tokens[0];
                        }
                        else {
                            return "true";
                        }
                    }
                    else {
                        if (tokens != null) {
                            return tokens[1];
                        }
                        else {
                            return "false";
                        }
                    }
                }
                else if (typeof(DateTime).IsAssignableFrom(fromType)) {
                    return((DateTime)value).ToString(formatString);
                }
                else if (typeof(Decimal).IsAssignableFrom(fromType)) {
                    return ((Decimal)value).ToString(formatString);
                }
                else if (typeof(Double).IsAssignableFrom(fromType)) {
                    return ((Double)value).ToString(formatString);
                }
                else if (typeof(Single).IsAssignableFrom(fromType)) {
                    return ((Single)value).ToString(formatString);
                }
                else if (typeof(Int16).IsAssignableFrom(fromType)) {
                    return ((Int16)value).ToString(formatString);
                }
                else {
                    throw new ArgumentException(
                                               HttpRuntime.FormatResourceString(SR.Cannot_convert_from_to, fromType.ToString(), toType.ToString()));
                }
            }
            else {
                throw new ArgumentException(
                                           HttpRuntime.FormatResourceString(SR.Cannot_convert_from_to, fromType.ToString(), toType.ToString()));
            }
        }
/*

    string t1;
    int t2;
    bool t3;
    DateTime t4;
    bool t5;
    Currency t6;
    string t7, t8, t9, t10, t11;
    string t12;

    void Test()
    {


        t1 = (string)ObjectConverter.ConvertValue("Should be a string", typeof(string), null);

        t2 = (int)ObjectConverter.ConvertValue("32", typeof(int), null);

        t3 = (bool)ObjectConverter.ConvertValue("true", typeof(bool), null);

        t4 = (DateTime)ObjectConverter.ConvertValue("11/14/62", typeof(DateTime), null);

        t5 = (bool)ObjectConverter.ConvertValue("false",  typeof(bool), null);

        t6 = (Currency)ObjectConverter.ConvertValue("$12.50", typeof(Currency),  null);

        t7 = (string)ObjectConverter.ConvertValue(32,  typeof(string), "#");

        t8 = (string)ObjectConverter.ConvertValue(true,  typeof(string), "yes;no");

        t9 = (string)ObjectConverter.ConvertValue(false,  typeof(string), "yes;no");

        t10 = (string)ObjectConverter.ConvertValue(DateTime.Now, typeof(string), "hh:mm");

        t11 = (string)ObjectConverter.ConvertValue(new Currency(12), typeof(string), "C");
    }

    public static void Main(string[] args)
    {
        new ObjectConverter().Test();
    }
    */

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\pagehandlerfactory.cs ===
//------------------------------------------------------------------------------
// <copyright file="PageHandlerFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Handler Factory implementation for Page files
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.UI {
using System.Runtime.Serialization.Formatters;

using System.IO;
using Debug=System.Web.Util.Debug;

/*
 * Handler Factory implementation for ASP.NET files
 */
internal class PageHandlerFactory : IHttpHandlerFactory {
    internal PageHandlerFactory() {
    }

    public virtual IHttpHandler GetHandler(HttpContext context, string requestType, string url, string path) {
        Debug.Trace("PageHandlerFactory", "PageHandlerFactory: " + url);

        // We need to assert here since there may be user code on the stack,
        // and code may demand UnmanagedCode permission
        InternalSecurityPermissions.UnmanagedCode.Assert();

        return PageParser.GetCompiledPageInstanceInternal(url, path, context);
    }

    public virtual void ReleaseHandler(IHttpHandler handler) {}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\literalcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="LiteralControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Control that holds a literal string
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.UI {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.IO;
    using System.Security.Permissions;

    /// <include file='doc\LiteralControl.uex' path='docs/doc[@for="LiteralControl"]/*' />
    /// <devdoc>
    /// <para>Defines the properties and methods of the LiteralControl class. A 
    ///    literal control is usually rendered as HTML text on a page. </para>
    /// <para>
    ///    LiteralControls behave as text holders, i.e., the parent of a LiteralControl may decide
    ///    to extract its text, and remove the control from its Control collection (typically for
    ///    performance reasons).
    ///    Therefore a control derived from LiteralControl must do any preprocessing of its Text
    ///    when it hands it out, that it would otherwise have done in its Render implementation.
    /// </para>
    /// </devdoc>
    [
    ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class LiteralControl : Control {
        internal string _text;

        /// <include file='doc\LiteralControl.uex' path='docs/doc[@for="LiteralControl.LiteralControl"]/*' />
        /// <devdoc>
        ///    <para>Creates a control that holds a literal string.</para>
        /// </devdoc>
        public LiteralControl() {
            PreventAutoID();
            EnableViewState = false;
        }

        /// <include file='doc\LiteralControl.uex' path='docs/doc[@for="LiteralControl.LiteralControl1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the LiteralControl class with
        ///    the specified text.</para>
        /// </devdoc>
        public LiteralControl(string text) {
            PreventAutoID();
            EnableViewState = false;
            _text = (text != null) ? text : String.Empty;
        }

        /// <include file='doc\LiteralControl.uex' path='docs/doc[@for="LiteralControl.Text"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the text content of the literal control.</para>
        /// </devdoc>
        public virtual string Text {
            get {
                return _text;
            }
            set {
                _text = (value != null) ? value : String.Empty;
            }
        }

        /// <include file='doc\LiteralControl.uex' path='docs/doc[@for="LiteralControl.CreateControlCollection"]/*' />
        protected override ControlCollection CreateControlCollection() {
            return new EmptyControlCollection(this);
        }

        /// <include file='doc\LiteralControl.uex' path='docs/doc[@for="LiteralControl.Render"]/*' />
        /// <devdoc>
        ///    <para>Saves any state that was modified after mark.</para>
        /// </devdoc>
        protected override void Render(HtmlTextWriter output) {
            output.Write(_text);
        }
    }


    /*
     * Class used to access literal strings stored in a resource (perf optimization).
     * This class is only public because it needs to be used by the generated classes.
     * Users should not use directly.
     */
    internal class ResourceBasedLiteralControl : LiteralControl {
        private TemplateControl _tplControl;
        private int _offset;    // Offset of the start of this string in the resource
        private int _size;      // Size of this string in bytes
        private bool _fAsciiOnly;    // Does the string contain only 7-bit ascii characters

        internal ResourceBasedLiteralControl(TemplateControl tplControl, int offset, int size, bool fAsciiOnly) {

            // Make sure we don't access invalid data
            if (offset < 0 || offset+size > tplControl.MaxResourceOffset)
                throw new ArgumentException();

            _tplControl = tplControl;
            _offset = offset;
            _size = size;
            _fAsciiOnly = fAsciiOnly;

            PreventAutoID();
            EnableViewState = false;
        }

        public override string Text {
            get {
                // If it's just a normal string, call the base
                if (_size == 0)
                    return base.Text;
                    
                return StringResourceManager.ResourceToString(
                    _tplControl.StringResourcePointer, _offset, _size);
            }
            set {
                // From now on, this will behave like a normal LiteralControl
                _size = 0;
                base.Text = value;
            }
        }

        protected override void Render(HtmlTextWriter output) {

            // If it's just a normal string, call the base
            if (_size == 0) {
                base.Render(output);
                return;
            }

            output.WriteUTF8ResourceString(_tplControl.StringResourcePointer, _offset, _size, _fAsciiOnly);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\objecttag.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectTag.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Implements the <object runat=server> tag
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.UI {

using System;
using System.IO;
using System.Collections;
using System.Web;
using System.Web.Util;
using System.Globalization;
using System.Security.Permissions;

/*
 * ObjectTag is a marker class, that should never be instantiated.  Its
 * only purpose is to point to the ObjectTagBuilder class through its
 * metadata.
 */
[
    ControlBuilderAttribute(typeof(ObjectTagBuilder))
]
internal class ObjectTag {
    private ObjectTag() {
    }
}

/// <include file='doc\ObjectTag.uex' path='docs/doc[@for="ObjectTagBuilder"]/*' />
/// <internalonly/>
/// <devdoc>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public sealed class ObjectTagBuilder : ControlBuilder {

    private ObjectTagScope _scope;
    private Type _type;
    private bool _lateBound;
    private string _progid; // Only used for latebound objects
    private string _clsid;  // Only used for latebound objects
    private bool _fLateBinding; // Force latebinding when early binding could be done

    /// <include file='doc\ObjectTag.uex' path='docs/doc[@for="ObjectTagBuilder.Init"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    public override void Init(TemplateParser parser, ControlBuilder parentBuilder,
        Type type, string tagName,
        string id, IDictionary attribs) {

        if (id == null) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Object_tag_must_have_id));
        }

        _id = id;

        // Get the scope attribute of the object tag
        string scope = (string) attribs["scope"];

        // Map it to an ObjectTagScope enum
        if (scope == null)
            _scope = ObjectTagScope.Default;
        else if (string.Compare(scope, "page", true, CultureInfo.InvariantCulture) == 0)
            _scope = ObjectTagScope.Page;
        else if (string.Compare(scope, "session", true, CultureInfo.InvariantCulture) == 0)
            _scope = ObjectTagScope.Session;
        else if (string.Compare(scope, "application", true, CultureInfo.InvariantCulture) == 0)
            _scope = ObjectTagScope.Application;
        else if (string.Compare(scope, "appinstance", true, CultureInfo.InvariantCulture) == 0)
            _scope = ObjectTagScope.AppInstance;
        else
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_scope, scope));

        Util.GetAndRemoveBooleanAttribute(attribs, "latebinding",
            ref _fLateBinding);

        string tmp = (string) attribs["class"];

        // Is there a 'class' attribute?
        if (tmp != null) {
            // Get a Type object from the type string
            _type = parser.GetType(tmp);
        }

        // If we don't have a type, check for a classid attribute
        if (_type == null) {
            tmp = (string) attribs["classid"];

            if (tmp != null) {
                // Create a Guid out of it
                Guid clsid = new Guid(tmp);

                // Turn it into a type
                _type = Type.GetTypeFromCLSID(clsid);

                if (_type == null)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_clsid, tmp));

                // REVIEW: Currently, it is still required to use tlbimp and
                // comreg in order to use a COM DLL.  If this has not
                // been done, we get an object of type System.__ComObject.
                // Per ASURT 8737, we will generate a field of type object for this,
                // and create it at runtime using the progid.
                if (_fLateBinding || Util.IsLateBoundComClassicType(_type)) {
                    _lateBound = true;
                    _clsid = tmp;
                }
                else {

                    // Add a dependency to the type, so that the user can use it without
                    // having to import it
                    parser.AddTypeDependency(_type);
                }
            }
        }

        // If we don't have a type, check for a progid attribute
        if (_type == null) {
            tmp = (string) attribs["progid"];

            if (tmp != null) {
                // Turn it into a type
                _type = Type.GetTypeFromProgID(tmp);

                if (_type == null)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_progid, tmp));

                Debug.Trace("Template", "<object> type: " + _type.FullName);

                // REVIEW: Currently, it is still required to use tlbimp and
                // comreg in order to use a COM DLL.  If this has not
                // been done, we get an object of type System.__ComObject.
                // Per ASURT 8737, we will generate a field of type object for this,
                // and create it at runtime using the progid.
                if (_fLateBinding || Util.IsLateBoundComClassicType(_type)) {
                    _lateBound = true;
                    _progid = tmp;
                }
                else {

                    // Add a dependency to the type, so that the user can use it without
                    // having to import it
                    parser.AddTypeDependency(_type);
                }
            }
        }

        // If we still don't have a type, fail
        if (_type == null) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Object_tag_must_have_class_classid_or_progid));
        }
    }

    // Ignore all content
    /// <include file='doc\ObjectTag.uex' path='docs/doc[@for="ObjectTagBuilder.AppendSubBuilder"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    public override void AppendSubBuilder(ControlBuilder subBuilder) {}
    /// <include file='doc\ObjectTag.uex' path='docs/doc[@for="ObjectTagBuilder.AppendLiteralString"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    public override void AppendLiteralString(string s) {}

    internal ObjectTagScope Scope {
        get { return _scope; }
    }

    internal Type ObjectType {
        get { return _type; }
    }

    internal bool LateBound {
        get { return _lateBound;} 
    }

    internal Type DeclaredType {
        get { return _lateBound ? typeof(object) : ObjectType; }
    }

    internal string Progid {
        get { return _progid; }
    }

    internal string Clsid {
        get { return _clsid; }
    }
}

/*
 * Enum for the scope of an object tag
 */
internal enum ObjectTagScope {
    Default = 0,
    Page = 1,
    Session = 2,
    Application = 3,
    AppInstance = 4
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\loswriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="LosWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {
    using System.Text;
    using System.IO;
    using System.Collections;
    using System.Globalization;
    using System.Web.Configuration;

    internal class LosWriter : TextWriter{

        private const int BUFFER_SIZE       = 4096;
        private const int MAX_FREE_BUFFERS  = 16;
        
        private static CharBufferAllocator  _charBufferAllocator;
        private static CharBufferAllocator  _charBufferAllocatorBase64;
        private static UbyteBufferAllocator _byteBufferAllocator;


        private char[]  _charBuffer;
        private byte[]  _byteBuffer;
        private int     _size;
        private int     _freePos;
        private bool    _recyclable;

        static LosWriter() {
            _charBufferAllocator = new CharBufferAllocator(BUFFER_SIZE, MAX_FREE_BUFFERS);

            int byteBufferSize = Encoding.UTF8.GetMaxByteCount(BUFFER_SIZE);
            _byteBufferAllocator = new UbyteBufferAllocator(byteBufferSize, MAX_FREE_BUFFERS);

            // base64 increases data by up to 33%, so we err on the side of caution here
            _charBufferAllocatorBase64 = new CharBufferAllocator((int) (byteBufferSize * 1.35), MAX_FREE_BUFFERS);
        }
        
        internal LosWriter() {
            _charBuffer = (char[])_charBufferAllocator.GetBuffer();
            _size = _charBuffer.Length;
            _freePos = 0;
            _recyclable = true;
        }

        internal void Dispose() {
            if (_recyclable) {
                if (_charBuffer != null)
                _charBufferAllocator.ReuseBuffer(_charBuffer);

                if (_byteBuffer != null)
                _byteBufferAllocator.ReuseBuffer(_byteBuffer);
            }

            _byteBuffer = null;
            _charBuffer = null;
        }

        public override Encoding Encoding {
            get { return null; }
        }
        

        private void Grow(int newSize) {
            if (newSize <= _size)
                return;

            if (newSize < _size*2)
                newSize = _size*2;

            char[] newBuffer = new char[newSize];

            if (_freePos > 0)
                Array.Copy(_charBuffer, newBuffer, _freePos);

            _charBuffer = newBuffer;
            _size = newSize;
            _recyclable = false;
        }

        public override void Write(char ch) {
            if (_freePos >= _size)
                Grow(_freePos+1);

            _charBuffer[_freePos++] = ch;
        }

        public override void Write(String s) {
            int len = s.Length;
            int newFreePos = _freePos + len;

            if (newFreePos > _size)
                Grow(newFreePos);

            s.CopyTo(0, _charBuffer, _freePos, len);
            _freePos = newFreePos;
        }

        
        internal /*public*/ void CompleteTransforms(TextWriter output, bool enableMac, byte[] macKey) {
            int len = 0;

            // convert to bytes
            if (_recyclable) {
                // still using the original recyclable char buffer 
                // -- can use recyclable byte buffer
                _byteBuffer = (byte[])_byteBufferAllocator.GetBuffer();

                if (_freePos > 0)
                    len = Encoding.UTF8.GetBytes(_charBuffer, 0, _freePos, _byteBuffer, 0);

                // do the mac encoding if requested
                if (enableMac) { 
                    // the size of the output array depends on the key length and encryption type
                    // so we can't use the recyclable buffers after this
                    byte[] data = MachineKey.GetEncodedData(_byteBuffer, macKey, 0, ref len);
                    string serialized = Convert.ToBase64String(data, 0, len);
                    output.Write(serialized);
                }
                else {
                    char[] base64chars = (char[]) _charBufferAllocatorBase64.GetBuffer();
                    len = Convert.ToBase64CharArray(_byteBuffer, 0, len, base64chars, 0);
                    output.Write(base64chars, 0, len);
                    _charBufferAllocatorBase64.ReuseBuffer(base64chars);
                }
            }
            else {
                _byteBuffer = Encoding.UTF8.GetBytes(_charBuffer, 0, _freePos);


                len = _byteBuffer.Length;
                if (enableMac) 
                    _byteBuffer = MachineKey.GetEncodedData(_byteBuffer, macKey, 0, ref len);
                
                string serialized = Convert.ToBase64String(_byteBuffer);
                output.Write(serialized);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\losformatter.cs ===
//------------------------------------------------------------------------------
// <copyright file="LOSFormatter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// uncomment for "human readable" debugging output - no base64 encoding.
//#define NO_BASE64

namespace System.Web.UI {
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Runtime.Serialization;
    using System;
    using System.IO;
    using System.Security.Principal;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Globalization;
    using System.Threading;
    using System.Text;
    using System.Web.Configuration;
    using System.Security.Permissions;

    /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="LosFormatter"]/*' />
    /// <devdoc>
    ///    <para>Serializes Web Froms view state. The limited object serialization (LOS) 
    ///       formatter is designed for highly compact ASCII format serialization. This class
    ///       supports serializing any object graph, but is optimized for those containing
    ///       strings, arrays, and hashtables. It offers second order optimization for many of
    ///       the .NET primitive types.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class LosFormatter {

        // NOTE : This formatter is not very fault tolerant, by design. I want
        //      : to avoid a bunch of reduntant checking... Since the format
        //      : is short lived we shouldn't have to worry about it.
        //

        // NOTE : Although hex encoding of numbers would be more effecient, it
        //      : would make it much harder to determine what are numbers vs.
        //      : names & types. Unless this becomes a problem, I suggest we
        //      : keep encoding in decimal.
        //

        // Known Types. There can only be 50 of these... The order shouldn't
        // matter, we store and index into this array... although there is a
        // slight perf advantage being at the top of the list...
        //
        private static readonly Type[] knownTypes = new Type[]
        {
            typeof(object),
            typeof(System.Web.UI.WebControls.Unit),
            typeof(System.Drawing.Color),
            typeof(System.Int16),
            typeof(System.Int64),
        };

        static readonly Encoding EncodingInstance = new UTF8Encoding(false);
        static readonly NumberFormatInfo NumberFormat = NumberFormatInfo.InvariantInfo;

        private const int UntypedTypeId = -1;
        private const int NoTypeId = -2;
        private const int InitialBufferSize = 24;
        private const int BufferGrowth = 48;


        // Constant chars and strings... you can change these and all references to the
        // begin, end, and delimiter chars are fixed up
        private const char leftAngleBracketChar = '<';
        private const char rightAngleBracketChar = '>';
        private const char valueDelimiterChar = ';';

        private static readonly char[] escapedCharacters = { leftAngleBracketChar, rightAngleBracketChar, valueDelimiterChar, '\\' };
        private static CharBufferAllocator _charBufferAllocator = new CharBufferAllocator(256, 16);

        // reusable Temp buffer used for constructing strings from char arrays... this is
        // more performant than using a StringBuilder.
        //
        private char[] _builder;
        private bool _recyclable;

        // Tables used to build up the type and name tables during
        // serialization. Not used during deserilization.
        private IDictionary _typeTable;

        // Deserialization variables. Not used during serialization.
        private ArrayList       _deserializedTypeTable;
        private ListDictionary  _deserializedConverterTable;
        private char[]          _deserializationData;
        private int             _current;

        // MAC authentication 
        private bool _enableViewStateMac;
        private bool EnableViewStateMac {
            get { return _enableViewStateMac; }
        }

        private byte [] _macKey = null;

        /// <include file='doc\LosFormatter.uex' path='docs/doc[@for="LosFormatter.LosFormatter"]/*' />
        /// <devdoc>
        ///    <para>Creates a LosFormatter object.</para>
        /// </devdoc>
        public LosFormatter() {}

        /// <include file='doc\LosFormatter.uex' path='docs/doc[@for="LosFormatter.LosFormatter1"]/*' />
        /// <devdoc>
        ///    <para>Creates a LosFormatter object, specifying whether view state mac should be
        ///         enabled.  If it is, use macKeyModifier to modify the mac key.</para>
        /// </devdoc>
        public LosFormatter(bool enableMac, string macKeyModifier) {
            _enableViewStateMac = enableMac;

            if (macKeyModifier != null)
                _macKey = Encoding.Unicode.GetBytes(macKeyModifier);
        }

        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="LosFormatter.Deserialize"]/*' />
        /// <devdoc>
        /// <para> Deserializes a LOS-formatted object from a <see cref='System.IO.Stream'/> object.</para>
        /// </devdoc>
        public object Deserialize(Stream stream) {
            TextReader input = null;
            input = new StreamReader(stream);
            return Deserialize(input);
        }

        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="LosFormatter.Deserialize1"]/*' />
        /// <devdoc>
        /// <para>Deserializes a LOS-formatted object from a <see cref='System.IO.TextReader'/> object.</para>
        /// </devdoc>
        public object Deserialize(TextReader input) {
            char[] data = new char[128];
            int read = 0;
            int current = 0;
            int blockSize = InitialBufferSize;
            do {
                read = input.Read(data, current, blockSize);
                current += read;
                if (current > data.Length - blockSize) {
                    char[] bigger = new char[data.Length * 2];
                    Array.Copy(data, bigger, data.Length);
                    data = bigger;
                }
            } while (read == blockSize);

            return Deserialize(new String(data, 0, current));
        }

        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="LosFormatter.Deserialize2"]/*' />
        /// <devdoc>
        ///    <para>Deserializes a LOS formatted object from a string.</para>
        /// </devdoc>
        public object Deserialize(string input) {

#if NO_BASE64
            char[] data = input.ToCharArray();
#else
            byte[] dataBytes = Convert.FromBase64String(input);

            int dataLength = -1;
            if (EnableViewStateMac) {

                try {
                    dataBytes = MachineKey.GetDecodedData(dataBytes, _macKey, 0, dataBytes.Length, ref dataLength);
                }
                catch {
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_Viewstate));
                }
            }

            if (dataLength == -1) {
                dataLength = dataBytes.Length;
            }

            char[] data = EncodingInstance.GetChars(dataBytes, 0, dataLength);
#endif


            // clear or allocate name and type tables.
            //
            if (_deserializedTypeTable == null) {
                _deserializedTypeTable = new ArrayList();
                _deserializedConverterTable = new ListDictionary();
            }
            else {
                _deserializedTypeTable.Clear();
                _deserializedConverterTable.Clear();
            }

            _builder = (char[])  _charBufferAllocator.GetBuffer();
            _recyclable = true;

            // DeserializeValueInternal is recursive, so we just kick this off
            // starting at 0
            _current = 0;
            _deserializationData = data;
            object ret = DeserializeValueInternal();

            if (_recyclable)
                _charBufferAllocator.ReuseBuffer(_builder);
            
            return ret;
        }

        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="LosFormatter.DeserializeValueInternal"]/*' />
        /// <devdoc>
        ///     Deserializes a value from tokens, starting at current. When this
        ///     function returns, current will be left at the next token.
        ///
        ///     This function is recursive.
        /// </devdoc>
        private object DeserializeValueInternal() {
            // Determine the data type... possible combinations are:
            //
            //   @<...>     == array of strings
            //   @T<...>    == array of (typeref T)
            //   b<...>     == base64 encoded value
            //   h<...>     == hashtable
            //   l<...>     == arraylist
            //   p<...>     == pair
            //   t<...>     == triplet
            //   i<...>     == int
            //   o<t/f>     == boolean true/false
            //   T<...>     == (typeref T)
            //   ...        == string 
            //

            object value = null;

            string token = ConsumeOneToken();

            if (_current >= _deserializationData.Length || _deserializationData[_current] != leftAngleBracketChar) {
                // just a string - next token is not a left angle bracket
                // we can shortcut here and just return the string
                //_current++; //consume right angle bracket or delimiter
                return token;
            }

            _current++; // consume left angle bracket

            // otherwise, we have typeref followed by value
            if (token.Length == 1) {
                // simple type we recognize
                char ch = token[0];
                if (ch == 'p') {
                    Pair p = new Pair();

                    if (_deserializationData[_current] != valueDelimiterChar) {
                        p.First = DeserializeValueInternal();
                    }
                    _current++; // consume delimeter
                    if (_deserializationData[_current] != rightAngleBracketChar) {
                        p.Second = DeserializeValueInternal();
                    }
                    value = p;
                }
                else if (ch == 't') {
                    Triplet t = new Triplet();

                    if (_deserializationData[_current] != valueDelimiterChar) {
                        t.First = DeserializeValueInternal();
                    }
                    _current++; // consume delimeter
                    if (_deserializationData[_current] != valueDelimiterChar) {
                        t.Second = DeserializeValueInternal();
                    }
                    _current++; // consume delimeter
                    if (_deserializationData[_current] != rightAngleBracketChar) {
                        t.Third = DeserializeValueInternal();
                    }
                    value = t;
                }
                    
                // Parse int32...
                else if (ch == 'i') {
                    value = Int32.Parse(ConsumeOneToken(), NumberFormat);
                }

                else if (ch == 'o') {
                    value = _deserializationData[_current] == 't'; 
                    _current++;  // consume t or f
                }

                // Parse arrayList...
                //
                else if (ch == 'l') {
                    ArrayList data = new ArrayList();

                    while (_deserializationData[_current] != rightAngleBracketChar) {
                        object itemValue = null;
                        if (_deserializationData[_current] != valueDelimiterChar) {
                            itemValue = DeserializeValueInternal();
                        }
                        data.Add(itemValue);
                        _current++; //consume the delimiter
                    }

                    value = data;
                }
                else if (ch == '@') {
                    // if we're here, length == 1 so this is a string array
                    value = ConsumeStringArray();
                }

                // Parse hashtable...
                //
                else if (ch == 'h') {
                    Hashtable data = new Hashtable();

                    while (_deserializationData[_current] != rightAngleBracketChar) {
                        object key;
                        key = DeserializeValueInternal();   // hashtable key cannot be null

                        _current++; // consume delimiter
                        if (_deserializationData[_current] != valueDelimiterChar) {
                            data[key] = DeserializeValueInternal();
                        }
                        else {
                            data[key] = null;
                        }

                        _current++; // consume delimiter
                    }

                    value = data;
                }

                // base64 encoded...
                //
                else if (ch == 'b') {
                    string text = ConsumeOneToken();
                    byte[] serializedData;
                    serializedData = Convert.FromBase64String(text);

                    if (serializedData != null && serializedData.Length > 0) {
                        System.Runtime.Serialization.IFormatter formatter = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter();
                        value = formatter.Deserialize(new MemoryStream(serializedData));
                    }
                }

                // Parse typeconverter value ...
                //
                else {
                    // we have a typeref which is only one character long
                    value = ConsumeTypeConverterValue(token);
                }

                
            }
            else {
                // length > 1

                // Parse array...
                //
                if (token[0] == '@') {
                    // if we're here, length > 1 so we must have a type ref after the @
                    Type creatableType = TypeFromTypeRef(token.Substring(1));
                    value = ConsumeArray(creatableType);
                }

                // Parse typeconverter value ...
                //
                else {
                    // we have a typeref which is more than one character long
                    value = ConsumeTypeConverterValue(token);
                }
            }

            _current++; //consume right angle bracket
            return value;
        }



        private string ConsumeOneToken() {
            int locInBuilder = 0;

            while (_current < _deserializationData.Length)
            {
                switch (_deserializationData[_current]) {
                    case '\\':
                        _current++; // skip slash
                        if (_deserializationData[_current] == 'e') {
                            _current++;
                            return String.Empty;
                        }
                        _builder[locInBuilder] = _deserializationData[_current];
                        locInBuilder++;
                        break;
                    case valueDelimiterChar:
                    case leftAngleBracketChar:
                    case rightAngleBracketChar:
                        return new string(_builder, 0, locInBuilder);

                    default:
                        _builder[locInBuilder] = _deserializationData[_current];
                        locInBuilder++;
                        break;
                }

                _current++;

                // Alloc _builder always 2 greater than locInBuilder to make sure
                // we can do nested/escape parsing without error...
                //
                if (locInBuilder >= _builder.Length) {
                    char[] bigger = new char[_builder.Length + BufferGrowth];
                    Array.Copy(_builder, bigger, _builder.Length);
                    _builder = bigger;
                    _recyclable = false;
                }
            }
            return new string(_builder, 0, locInBuilder);
        }

        private object ConsumeStringArray() {
            ArrayList data = new ArrayList();
            while (_deserializationData[_current] != rightAngleBracketChar) {
                object itemValue = null;
                if (_deserializationData[_current] != valueDelimiterChar) {
                    itemValue = ConsumeOneToken();
                }
                data.Add(itemValue);
                _current++; //consume the delimiter
            }

            return data.ToArray(typeof(string));
        }
        
        private object ConsumeArray(Type creatableType) {
            ArrayList data = new ArrayList();
            while (_deserializationData[_current] != rightAngleBracketChar) {
                object itemValue = null;
                if (_deserializationData[_current] != valueDelimiterChar) {
                    itemValue = DeserializeValueInternal();
                }
                data.Add(itemValue);
                _current++; //consume the delimiter
            }

            return data.ToArray(creatableType);
        }

        private object ConsumeTypeConverterValue(string token) {
            int typeref = ParseNumericString(token);
            TypeConverter tc;

            if (typeref != -1) {
                // token is the string representation of the number here
                tc = (TypeConverter) _deserializedConverterTable[token];
                if (tc == null) {
                    // wasn't in the converter table, add it now
                    // we need this case because arrays can add types but not typeconverters
                    Type t = TypeFromTypeCode(typeref);
                    tc = TypeDescriptor.GetConverter(t);
                    _deserializedConverterTable[token] = tc;
                }
            }
            else {
                // it's just a name, lookup type and add to type table
                Type t = Type.GetType(token);
                tc = TypeDescriptor.GetConverter(t);

                // add to type table and converter table.
                _deserializedConverterTable[(_deserializedTypeTable.Count + 50).ToString(NumberFormat)] = tc;
                _deserializedTypeTable.Add(t);
            }
            string text = ConsumeOneToken();
            return tc.ConvertFrom(null, CultureInfo.InvariantCulture, text);
        }

        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="LosFormatter.Serialize"]/*' />
        /// <devdoc>
        ///    <para>Serializes the Web Forms view state value into 
        ///       a <see cref='System.IO.Stream'/> object.</para>
        /// </devdoc>
        public void Serialize(Stream stream, object value) {
            TextWriter output = new StreamWriter(stream);
            SerializeInternal(output, value);
            output.Flush();
        }

        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="LosFormatter.Serialize1"]/*' />
        /// <devdoc>
        /// <para>Serializes the view state value into a <see cref='System.IO.TextWriter'/> object.</para>
        /// </devdoc>
        public void Serialize(TextWriter output, object value) {
            SerializeInternal(output, value);
        }

        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="LosFormatter.SerializeInternal"]/*' />
        /// <devdoc>
        ///     Serialized value into the writer.
        /// </devdoc>
        private void SerializeInternal(TextWriter output, object value) {
            if (value == null)
                return;

            if (_typeTable == null) 
                _typeTable = new HybridDictionary();
            else 
                _typeTable.Clear();

#if NO_BASE64
            SerializeValue(output, value);
#else 

            LosWriter writer = new LosWriter();

            SerializeValue(writer, value);

            writer.CompleteTransforms(output, EnableViewStateMac, _macKey); 
            writer.Dispose();
#endif

        }

        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="LosFormatter.SerializeValue"]/*' />
        /// <devdoc>
        ///     Recursively serializes value into the writer.
        /// </devdoc>
        private void SerializeValue(TextWriter output, object value) {
            if (value == null) 
                return;
            
            // First determine the type... either typeless (string), array,
            // typed array, hashtable, pair, triplet, knowntype, typetable reference, or
            // type...
            //
            
            // serialize string...
            //
            if (value is string) {
                WriteEscapedString(output, (string)value);
            }

            // serialize Int32...
            //
            else if (value is Int32) {
                output.Write('i');
                output.Write(leftAngleBracketChar);
                output.Write(((Int32)value).ToString(NumberFormat));
                output.Write(rightAngleBracketChar);
            }
            else if (value is Boolean) {
                output.Write('o');
                output.Write(leftAngleBracketChar);
                output.Write( ((bool) value) ? 't' : 'f');
                output.Write(rightAngleBracketChar);
            }

            // serialize arraylist...
            //
            else if (value is ArrayList) {
                output.Write('l');
                output.Write(leftAngleBracketChar);

                ArrayList ar = (ArrayList)value;
                int c = ar.Count;
                for (int i=0; i<c; i++) {
                    SerializeValue(output, ar[i]);
                    output.Write(valueDelimiterChar);
                }
                output.Write(rightAngleBracketChar);
            }

            // serialize hashtable...
            //
            else if (value is Hashtable) {
                output.Write('h');
                output.Write(leftAngleBracketChar);

                Hashtable table = (Hashtable)value;

                IDictionaryEnumerator e = table.GetEnumerator();
                while (e.MoveNext()) {
                    SerializeValue(output, e.Key);
                    output.Write(valueDelimiterChar);

                    SerializeValue(output, e.Value);
                    output.Write(valueDelimiterChar);
                }
                output.Write(rightAngleBracketChar);
            }

            else {
                // we'll need the Type object for the last two possibilities
                Type valueType = value.GetType();
                Type strtype = typeof(string);

                // serialize Pair
                if (valueType == typeof(Pair)) {
                    Pair p = (Pair) value;
                    output.Write('p');
                    output.Write(leftAngleBracketChar);

                    SerializeValue(output, p.First);
                    output.Write(valueDelimiterChar);
                    SerializeValue(output, p.Second);
                    output.Write(rightAngleBracketChar);
                }

                // serialize Triplet
                //
                else if (valueType == typeof(Triplet)) {
                    Triplet t = (Triplet) value;
                    output.Write('t');
                    output.Write(leftAngleBracketChar);

                    SerializeValue(output, t.First);
                    output.Write(valueDelimiterChar);
                    SerializeValue(output, t.Second);
                    output.Write(valueDelimiterChar);
                    SerializeValue(output, t.Third);
                    output.Write(rightAngleBracketChar);
                }

                // serialize array...
                //
                else if (valueType.IsArray) {
                    Type underlyingValueType;
                    underlyingValueType = valueType.GetElementType();

                    output.Write('@');

                    if (underlyingValueType != strtype) {
                        // write type of array before elements
                        int typeId = GetTypeId(underlyingValueType);
                        WriteTypeId(output, typeId, underlyingValueType);

                        output.Write(leftAngleBracketChar);
                        Array ar = (Array)value;
                        for (int i=0; i<ar.Length; i++) {
                            SerializeValue(output, ar.GetValue(i));
                            output.Write(valueDelimiterChar);
                        }
                    }
                    else {
                        // optimization: since we know the underlying values are strings, 
                        // we can skip the recursive call to SerializeValue
                        output.Write(leftAngleBracketChar);
                        string[] ar = (string[])value;
                        for (int i=0; i<ar.Length; i++) {
                            WriteEscapedString(output, ar[i]);
                            output.Write(valueDelimiterChar);
                        }
                    }
                    output.Write(rightAngleBracketChar);
                }

                // serialize other value...
                //
                else {
                    int typeId = GetTypeId(valueType);

                    // get the type converter 
                    TypeConverter tc = TypeDescriptor.GetConverter(valueType);

                    bool toString;
                    bool fromString;
                    if (tc == null || tc is ReferenceConverter) { 
                        toString = false;
                        fromString = false;
                    }
                    else {
                        toString = tc.CanConvertTo(strtype);
                        fromString = tc.CanConvertFrom(strtype);
                    }
                    
                    if (toString && fromString) {
                        //we can convert to and from a string
                        WriteTypeId(output, typeId, valueType);
                        
                        output.Write(leftAngleBracketChar);
                        WriteEscapedString(output, tc.ConvertToInvariantString(null, value));
                    }
                    else {
                        // the typeconverter failed us, so we are resorting to binary serialization
                        MemoryStream ms = new MemoryStream();
                        System.Runtime.Serialization.IFormatter formatter = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter(); 
                        try {
                            formatter.Serialize(ms, value);
                        }
                        catch (SerializationException) {
                            throw new HttpException(HttpRuntime.FormatResourceString(SR.Object_Must_Be_Serializable, value.GetType().FullName));
                        }

                        output.Write('b');
                        output.Write(leftAngleBracketChar);

                        // Since base64 doesn't have any chars that we escape, we can
                        // skip WriteEscapedString
                        output.Write(Convert.ToBase64String(ms.GetBuffer(), 0, (int) ms.Length));
                    }
                    output.Write(rightAngleBracketChar);
                }
            }
        }

        private int GetTypeId(Type valueType) {

            int typeId = NoTypeId;

            // check if it is a known type
            for (int i=0; i<knownTypes.Length; i++) {
                if (valueType == knownTypes[i]) {
                    typeId = i;
                    break;
                }
            }


            if (typeId == NoTypeId) {
                // not a known type, see if it's in the type table
                object found = _typeTable[valueType];
                if (found != null) 
                    typeId = 50 + (int)found;
            }

            return typeId;
        }

        private void WriteTypeId(TextWriter output, int typeId, Type valueType) {
            if (typeId != NoTypeId)
                output.Write(typeId.ToString(NumberFormat));
            else {
                // ASURT 60173: use AssemblyQualifiedName here, not FullName
                WriteEscapedString(output, valueType.AssemblyQualifiedName);
                // CONSIDER: can we store the typeconverter in the type table as well? 
                _typeTable[valueType] = _typeTable.Count;
            }
        }


        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="LosFormatter.TypeFromTypeRef"]/*' />
        /// <devdoc>
        ///     Takes a typeRef, and converts it to a Type. Either by returning
        ///     Type.GetType(typeRef), or looking it up.
        /// </devdoc>
        private Type TypeFromTypeRef(string typeRef) {

            int number = ParseNumericString(typeRef);

            Type t = TypeFromTypeCode(number);

            if (t != null)
                return t;

            // it's just a name, lookup type and add to type table
            t = Type.GetType(typeRef);
            _deserializedTypeTable.Add(t);
            return t;

        }

        private Type TypeFromTypeCode(int number) {
            if (number != -1) {
                // it is a type id, either in the known table or in our type table
                if (number <= 49)
                    return knownTypes[number];

                return (Type) _deserializedTypeTable[number - 50];

            }
            return null;
        }


        // Note : We have to determine if "typeRef" is a number. The easiest
        //      : and fastest way to do this is to walk the string. While
        //      : we are doing this, lets build up the number... after
        //      : all this is much faster than Int32.Parse
        //
        private int ParseNumericString(string num) {
            int number = 0;
            int len = num.Length;

            for (int i=0; i<len; i++) {
                switch (num[i]) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                        number *= 10;
                        number += (((int)num[i]) - ((int)'0'));
                        break;
                    default:
                        number = -1;
                        i = len;
                        break;
                }
            }
            return number;
        }

        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="LosFormatter.WriteEscapedString"]/*' />
        /// <devdoc>
        ///     Escapes and writes the escaped value of str into the writer.
        /// </devdoc>
        private void WriteEscapedString(TextWriter output, string str) {

            if (str == null)
                return;
            
            // need to "escape" the empty string to distinguish it
            // from a null value
            if (str.Length == 0) {
                output.Write('\\');
                output.Write('e');
                return;
            }

            int first = str.IndexOfAny(escapedCharacters);
            if (first == -1) {
                output.Write(str);
            }
            else {
                char[] strData = str.ToCharArray();
                output.Write(strData, 0, first);
                int len = strData.Length;

                for (int i=first; i<len; i++) {
                    char c = strData[i];
                    switch (c) {
                        case '\\':
                            output.Write('\\');
                            output.Write('\\');
                            break;
                        case leftAngleBracketChar:
                            output.Write('\\');
                            output.Write(leftAngleBracketChar);
                            break;
                        case rightAngleBracketChar:
                            output.Write('\\');
                            output.Write(rightAngleBracketChar);
                            break;
                        case valueDelimiterChar:
                            output.Write('\\');
                            output.Write(valueDelimiterChar);
                            break;
                        default:
                            output.Write(c);
                            break;
                    }
                }
            }
        }

        static internal int EstimateSize(object obj) {
            if (obj == null)
                return 0;
            StringWriter sw = new StringWriter();
            LosFormatter formatter = new LosFormatter();
            formatter.Serialize(sw, obj);
            return sw.ToString().Length;
        }
    }

    /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="Pair"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Pair {
        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="Pair.First"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object First;
        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="Pair.Second"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Second;

        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="Pair.Pair"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Pair () {}
        
        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="Pair.Pair1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Pair (object x, object y) {
            First = x;
            Second = y;
        }
    }

    /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="Triplet"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Triplet {
        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="Triplet.First"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object First;
        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="Triplet.Second"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Second;
        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="Triplet.Third"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Third;

        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="Triplet.Triplet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Triplet() {}

        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="Triplet.Triplet1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Triplet (object x, object y) {
            First = x;
            Second = y;
        }

        /// <include file='doc\LOSFormatter.uex' path='docs/doc[@for="Triplet.Triplet2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Triplet (object x, object y, object z) {
            First = x;
            Second = y;
            Third = z;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\partialcachingcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="PartialCachingControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

using System;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.Caching;
using System.Security.Permissions;

/// <include file='doc\PartialCachingControl.uex' path='docs/doc[@for="BasePartialCachingControl"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[
ToolboxItem(false)
]
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public abstract class BasePartialCachingControl : Control {

    private Control _cachedCtrl;
    internal string _ctrlID;
    internal string _guid;
    internal int _duration;
    internal string[] _varyByParamsCollection;
    internal string[] _varyByControlsCollection;
    internal string _varyByCustom;
    private string _outputString;
    private string _cacheKey;
    private CacheDependency _cacheDependency;

    internal static readonly char[] s_varySeparators = new char[] {';'};

    /// <include file='doc\PartialCachingControl.uex' path='docs/doc[@for="BasePartialCachingControl.OnInit"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected override void OnInit(EventArgs e) {
        base.OnInit(e);

        _cacheKey = GetCacheKey();
        // Lookup the cache to see if we have the required output
        _outputString = (string) HttpRuntime.CacheInternal.Get(_cacheKey);

        // If we don't, create the control and make it our child
        if (_outputString == null) {
            _cachedCtrl = CreateCachedControl();
            Controls.Add(_cachedCtrl);
        }
    }

    /// <include file='doc\PartialCachingControl.uex' path='docs/doc[@for="BasePartialCachingControl.Dispose"]/*' />
    /// <internalonly/>
    public override void Dispose() {
        if (_cacheDependency != null) {
            _cacheDependency.Dispose();
            _cacheDependency = null;
        }

        base.Dispose();
    }

    internal abstract Control CreateCachedControl();

    /// <include file='doc\PartialCachingControl.uex' path='docs/doc[@for="BasePartialCachingControl.Dependency"]/*' />
    /// <devdoc>
    ///    <para> Gets or sets the CacheDependency used to cache the control output.</para>
    /// </devdoc>
    public CacheDependency Dependency {
        get { return _cacheDependency; }
        set { _cacheDependency = value; }
    }

    /// <include file='doc\PartialCachingControl.uex' path='docs/doc[@for="PartialCachingControl.Render"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected override void Render(HtmlTextWriter output) {

        // If the output is cached, use it and do nothing else
        if (_outputString != null) {
            output.Write(_outputString);
            return;
        }

        // Create a new HtmlTextWriter, with the same type as the current one (see ASURT 118922)
        StringWriter tmpWriter = new StringWriter();
        HtmlTextWriter tmpHtmlWriter = Page.CreateHtmlTextWriterFromType(tmpWriter, output.GetType());

        TextWriter savedWriter = Context.Response.SwitchWriter(tmpWriter);

        try {
            _cachedCtrl.RenderControl(tmpHtmlWriter);
        }
        finally {
            Context.Response.SwitchWriter(savedWriter);
        }

        string outputString = tmpWriter.ToString();

        // Send the output to the response
        output.Write(outputString);

        // Cache the output
        // Compute the expiration time
        DateTime utcExpires = DateTime.UtcNow.AddSeconds(_duration);

        HttpRuntime.CacheInternal.UtcInsert(_cacheKey, outputString, _cacheDependency /*dependencies*/, utcExpires,
            Cache.NoSlidingExpiration);
    }

    // Return the key used to cache the output
    private string GetCacheKey() {

        // Create a cache key by combining various elements
        HashCodeCombiner combinedHashCode = new HashCodeCombiner();

        // Start with the guid
        combinedHashCode.AddObject(_guid);

        // Make the key vary based on the type of the writer (ASURT 118922)
        HttpBrowserCapabilities browserCap = Context.Request.Browser;
        if (browserCap != null)
            combinedHashCode.AddObject(browserCap.TagWriter);

        // If there are no vary params, we're done with the key
        if (_varyByParamsCollection == null && _varyByControlsCollection == null && _varyByCustom == null)
            return combinedHashCode.CombinedHashString;

        // Get the request value collection
        NameValueCollection reqValCollection = Page.RequestValueCollection;

        // If it's not set, get it based on the method
        if (reqValCollection == null)
            reqValCollection = Page.GetCollectionBasedOnMethod();

        if (_varyByParamsCollection != null) {

            ICollection itemsToUseForHashCode;

            // If '*' was specified, use all the items in the request collection.
            // Otherwise, use only those specified.
            if (_varyByParamsCollection.Length == 1 && _varyByParamsCollection[0] == "*")
                itemsToUseForHashCode = reqValCollection;
            else
                itemsToUseForHashCode = _varyByParamsCollection;

            // Add the items and their values to compute the hash code
            foreach (string varyByParam in itemsToUseForHashCode) {
                combinedHashCode.AddCaseInsensitiveString(varyByParam);
                string val = reqValCollection[varyByParam];
                if (val != null)
                    combinedHashCode.AddObject(reqValCollection[varyByParam]);
            }
        }

        if (_varyByControlsCollection != null) {

            // Prepend them with a prefix to make them fully qualified
            string prefix = NamingContainer.UniqueID;
            if (prefix != null)
                prefix += Control.ID_SEPARATOR;
            prefix += _ctrlID + Control.ID_SEPARATOR;

            // Add all the relative vary params and their values to the hash code
            foreach (string varyByParam in _varyByControlsCollection) {

                string temp = prefix + varyByParam;
                combinedHashCode.AddCaseInsensitiveString(temp);
                string val = reqValCollection[temp];
                if (val != null)
                    combinedHashCode.AddObject(reqValCollection[temp]);
            }
        }

        if (_varyByCustom != null) {
            string customString = Context.ApplicationInstance.GetVaryByCustomString(
                Context, _varyByCustom);
            if (customString != null)
                combinedHashCode.AddObject(customString);
        }

        return combinedHashCode.CombinedHashString;
    }
}

/// <include file='doc\PartialCachingControl.uex' path='docs/doc[@for="StaticPartialCachingControl"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public class StaticPartialCachingControl : BasePartialCachingControl {

    private BuildMethod _buildMethod;

    /// <include file='doc\PartialCachingControl.uex' path='docs/doc[@for="StaticPartialCachingControl.StaticPartialCachingControl"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public StaticPartialCachingControl(string ctrlID, string guid, int duration,
        string varyByParams, string varyByControls, string varyByCustom,
        BuildMethod buildMethod) {
        _ctrlID = ctrlID;
        _duration = duration;
        if (varyByParams != null)
            _varyByParamsCollection = varyByParams.Split(s_varySeparators);
        if (varyByControls != null)
            _varyByControlsCollection = varyByControls.Split(s_varySeparators);
        _varyByCustom = varyByCustom;
        _guid = guid;
        _buildMethod = buildMethod;
    }

    internal override Control CreateCachedControl() {
        return _buildMethod();
    }

    /*
     * Called by generated code (hence must be public).
     * Create a StaticPartialCachingControl and add it as a child
     */
    /// <include file='doc\PartialCachingControl.uex' path='docs/doc[@for="StaticPartialCachingControl.BuildCachedControl"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    static public void BuildCachedControl(Control parent, string ctrlID, string guid,
        int duration, string varyByParams, string varyByControls, string varyByCustom,
        BuildMethod buildMethod) {

        StaticPartialCachingControl pcc = new StaticPartialCachingControl(
            ctrlID, guid, duration, varyByParams, varyByControls, varyByCustom,
            buildMethod);
            
        ((IParserAccessor)parent).AddParsedSubObject(pcc);
    }
}

/// <include file='doc\PartialCachingControl.uex' path='docs/doc[@for="PartialCachingControl"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public class PartialCachingControl : BasePartialCachingControl {

    private Type _createCachedControlType;

    private Control _cachedControl;
    /// <include file='doc\PartialCachingControl.uex' path='docs/doc[@for="PartialCachingControl.CachedControl"]/*' />
    public Control CachedControl { get { return _cachedControl; } }

    internal PartialCachingControl(Type createCachedControlType,
        PartialCachingAttribute cacheAttrib, string cacheKey) {

        _ctrlID = cacheKey;
        _duration = cacheAttrib.Duration;
        if (cacheAttrib.VaryByParams != null)
            _varyByParamsCollection = cacheAttrib.VaryByParams.Split(s_varySeparators);
        if (cacheAttrib.VaryByControls != null)
            _varyByControlsCollection = cacheAttrib.VaryByControls.Split(s_varySeparators);
        _varyByCustom = cacheAttrib.VaryByCustom;
        _guid = cacheKey;
        _createCachedControlType = createCachedControlType;
    }

    internal override Control CreateCachedControl() {

        // Make sure the type has the correct base class (ASURT 123677)
        Util.CheckAssignableType(typeof(Control), _createCachedControlType);

        // Instantiate the control
        _cachedControl = (Control) HttpRuntime.CreatePublicInstance(_createCachedControlType);

        if (_cachedControl is UserControl) {
            ((UserControl)_cachedControl).InitializeAsUserControl(Page);
        }

        _cachedControl.ID = _ctrlID;

        return _cachedControl;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\partialcachingattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="PartialCachingAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Fragment caching attribute
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.UI {

using System;
using System.Collections;
using System.ComponentModel;
using System.Security.Permissions;

/*
 * This class defines the PartialCachingAttribute attribute that can be placed on
 * user controls classes to enable the fragmant caching feature.
 */
/// <include file='doc\PartialCachingAttribute.uex' path='docs/doc[@for="PartialCachingAttribute"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AttributeUsage(AttributeTargets.Class)]
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public sealed class PartialCachingAttribute : Attribute {
    private int _duration;
    /// <include file='doc\PartialCachingAttribute.uex' path='docs/doc[@for="PartialCachingAttribute.Duration"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public int Duration { get { return _duration;}}

    private string _varyByParams;
    /// <include file='doc\PartialCachingAttribute.uex' path='docs/doc[@for="PartialCachingAttribute.VaryByParams"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string VaryByParams { get { return _varyByParams; } }

    private string _varyByControls;
    /// <include file='doc\PartialCachingAttribute.uex' path='docs/doc[@for="PartialCachingAttribute.VaryByControls"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string VaryByControls { get { return _varyByControls; } }

    private string _varyByCustom;
    /// <include file='doc\PartialCachingAttribute.uex' path='docs/doc[@for="PartialCachingAttribute.VaryByCustom"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string VaryByCustom { get { return _varyByCustom; } }

    private bool _shared;
    /// <include file='doc\PartialCachingAttribute.uex' path='docs/doc[@for="PartialCachingAttribute.Shared"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public bool Shared { get { return _shared; } }


    /// <include file='doc\PartialCachingAttribute.uex' path='docs/doc[@for="PartialCachingAttribute.PartialCachingAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public PartialCachingAttribute(int duration) {
        _duration = duration;
    }

    /// <include file='doc\PartialCachingAttribute.uex' path='docs/doc[@for="PartialCachingAttribute.PartialCachingAttribute1"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public PartialCachingAttribute(int duration, string varyByParams,
        string varyByControls, string varyByCustom) {
        _duration = duration;
        _varyByParams = varyByParams;
        _varyByControls = varyByControls;
        _varyByCustom = varyByCustom;
    }

    /// <include file='doc\PartialCachingAttribute.uex' path='docs/doc[@for="PartialCachingAttribute.PartialCachingAttribute2"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public PartialCachingAttribute(int duration, string varyByParams,
        string varyByControls, string varyByCustom, bool shared) {
        _duration = duration;
        _varyByParams = varyByParams;
        _varyByControls = varyByControls;
        _varyByCustom = varyByCustom;
        _shared = shared;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\pagesconfiguration.cs ===
//------------------------------------------------------------------------------
// <copyright file="PagesConfiguration.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Code related to the <assemblies> config section
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.UI {

    using System;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Configuration;
    using System.IO;
    using System.Reflection;
    using System.Runtime.Serialization.Formatters;
    using System.Web.Configuration;
    using System.Web.Util;
    using System.Xml;


    internal class PagesConfiguration {

        internal const string sectionName = "system.web/pages";

        private bool _fBuffer;
        private bool _fRequiresSessionState;
        private bool _fReadOnlySessionState;
        private bool _fEnableViewState;
        private bool _fEnableViewStateMac;
        private bool _smartNavigation;
        private bool _validateRequest;
        private bool _fAutoEventWireup;
        private bool _fAspCompat;
        private Type _pageBaseType;
        private Type _userControlBaseType;

        private PagesConfiguration() {
            _fRequiresSessionState = true;
            _fEnableViewState = true;
            _fAutoEventWireup = true;
            _validateRequest = true;
        }

        private PagesConfiguration(PagesConfiguration original) {

            _fBuffer = original._fBuffer;
            _fRequiresSessionState = original._fRequiresSessionState;
            _fReadOnlySessionState = original._fReadOnlySessionState;
            _fEnableViewState = original._fEnableViewState;
            _fEnableViewStateMac = original._fEnableViewStateMac;
            _smartNavigation = original._smartNavigation;
            _validateRequest = original._validateRequest;
            _fAutoEventWireup = original._fAutoEventWireup;
            _fAspCompat = original._fAspCompat;
            _pageBaseType = original._pageBaseType;
            _userControlBaseType = original._userControlBaseType;
        }

        internal /*public*/ bool FBuffer {
            get { return _fBuffer; }
        }

        internal /*public*/ bool FRequiresSessionState {
            get { return _fRequiresSessionState; }
        }

        internal /*public*/ bool FReadOnlySessionState {
            get { return _fReadOnlySessionState; }
        }

        internal /*public*/ bool FEnableViewState {
            get { return _fEnableViewState; }
        }

        internal /*public*/ bool FEnableViewStateMac {
            get { return _fEnableViewStateMac; }
        }

        internal /*public*/ bool SmartNavigation {
            get { return _smartNavigation; }
        }

        internal /*public*/ bool ValidateRequest {
            get { return _validateRequest; }
        }

        internal /*public*/ bool FAutoEventWireup {
            get { return _fAutoEventWireup; }
        }

        internal /*public*/ bool FAspCompat {
            get { return _fAspCompat; }
        }

        internal /*public*/ Type PageBaseType {
            get { return _pageBaseType; }
        }

        internal /*public*/ Type UserControlBaseType {
            get { return _userControlBaseType; }
        }


        internal class SectionHandler {
            private SectionHandler() {
            }

            internal static object CreateStatic(object inheritedObject, XmlNode node) {
                PagesConfiguration inherited = (PagesConfiguration)inheritedObject;
                PagesConfiguration result;

                if (inherited == null)
                    result = new PagesConfiguration();
                else
                    result = new PagesConfiguration(inherited);

                //
                // Handle attributes (if they exist)
                //   - buffer="true/false"
                //   - enableSessionState="true/false/readonly"
                //   - enableViewState="true/false"
                //   - enableViewStateMac="true/false"
                //   - smartNavigation="true/false"
                //   - autoEventWireup="true/false"
                //   - pageBaseType=[typename]
                //   - userControlBaseType=[typename]

                HandlerBase.GetAndRemoveBooleanAttribute(node, "buffer", ref result._fBuffer);
                HandlerBase.GetAndRemoveBooleanAttribute(node, "enableViewState", ref result._fEnableViewState);
                HandlerBase.GetAndRemoveBooleanAttribute(node, "enableViewStateMac", ref result._fEnableViewStateMac);
                HandlerBase.GetAndRemoveBooleanAttribute(node, "smartNavigation", ref result._smartNavigation);
                HandlerBase.GetAndRemoveBooleanAttribute(node, "validateRequest", ref result._validateRequest);
                HandlerBase.GetAndRemoveBooleanAttribute(node, "autoEventWireup", ref result._fAutoEventWireup);

                if (HandlerBase.GetAndRemoveTypeAttribute(node, "pageBaseType", ref result._pageBaseType) != null)
                    CheckBaseType(node, typeof(System.Web.UI.Page), result._pageBaseType);

                if (HandlerBase.GetAndRemoveTypeAttribute(node, "userControlBaseType", ref result._userControlBaseType) != null)
                    CheckBaseType(node, typeof(System.Web.UI.UserControl), result._userControlBaseType);

                int enableSessionState = 0;
                string [] enableSessionStateValues = {"false", "true", "ReadOnly"};
                if (HandlerBase.GetAndRemoveEnumAttribute(node, "enableSessionState", enableSessionStateValues, ref enableSessionState) != null) {
                    if (enableSessionState == 0) { // false
                        result._fRequiresSessionState = false;
                    }
                    else if (enableSessionState == 1) { // true
                        result._fRequiresSessionState = true;
                        result._fReadOnlySessionState = false;
                    }
                    else if (enableSessionState == 2) { // ReadOnly
                        result._fReadOnlySessionState = true;
                    }
                }

                HandlerBase.CheckForUnrecognizedAttributes(node);
                HandlerBase.CheckForChildNodes(node);

                return result;
            }

            private static void CheckBaseType(XmlNode node, Type expectedBaseType, Type userBaseType) {

                // Make sure the base type is valid
                if (!expectedBaseType.IsAssignableFrom(userBaseType)) {
                    throw new ConfigurationException(
                        HttpRuntime.FormatResourceString(SR.Invalid_type_to_inherit_from,
                            userBaseType.FullName,
                            expectedBaseType.FullName), node);
                }
            }
        }
    }

    internal class PagesConfigurationHandler : IConfigurationSectionHandler {
        internal PagesConfigurationHandler() {
        }

        public virtual object Create(object inheritedObject, object configContextObj, XmlNode node) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;

            return PagesConfiguration.SectionHandler.CreateStatic(inheritedObject, node);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\parsechildrenaspropertiesattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ParseChildrenAsPropertiesAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Security.Permissions;

    /*
     * Define the metadata attribute that controls use to mark the fact
     * that their children are in fact properties.
     * Furthermore, if a string is passed in the constructor, it specifies
     * the name of the defaultproperty.
     */
    /// <include file='doc\ParseChildrenAsPropertiesAttribute.uex' path='docs/doc[@for="ParseChildrenAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class ParseChildrenAttribute : Attribute {

        /// <include file='doc\ParseChildrenAsPropertiesAttribute.uex' path='docs/doc[@for="ParseChildrenAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly ParseChildrenAttribute Default = new ParseChildrenAttribute(false);

        private bool _childrenAsProps;
        private string _defaultProperty;

        /// <include file='doc\ParseChildrenAsPropertiesAttribute.uex' path='docs/doc[@for="ParseChildrenAttribute.ChildrenAsProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool ChildrenAsProperties {
            get {
                return _childrenAsProps;
            }
            set {
                _childrenAsProps = value;
            }
        }

        /// <include file='doc\ParseChildrenAsPropertiesAttribute.uex' path='docs/doc[@for="ParseChildrenAttribute.DefaultProperty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string DefaultProperty {
            get {
                if (_defaultProperty == null) {
                    return String.Empty;
                }
                return _defaultProperty;
            }
            set {
                _defaultProperty = value;
            }
        }

        /// <include file='doc\ParseChildrenAsPropertiesAttribute.uex' path='docs/doc[@for="ParseChildrenAttribute.ParseChildrenAttribute"]/*' />
        /// <devdoc>
        ///    <para>Needed to use named parameters (ASURT 78869)</para>
        /// </devdoc>
        public ParseChildrenAttribute() {}

        /// <include file='doc\ParseChildrenAsPropertiesAttribute.uex' path='docs/doc[@for="ParseChildrenAttribute.ParseChildrenAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ParseChildrenAttribute(bool childrenAsProperties) {
            _childrenAsProps = childrenAsProperties;
        }

        /// <include file='doc\ParseChildrenAsPropertiesAttribute.uex' path='docs/doc[@for="ParseChildrenAttribute.ParseChildrenAttribute2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ParseChildrenAttribute(bool childrenAsProperties, string defaultProperty) {
            _childrenAsProps = childrenAsProperties;
            if (_childrenAsProps == true) {
                _defaultProperty = defaultProperty;
            }
        }

        /// <include file='doc\ParseChildrenAsPropertiesAttribute.uex' path='docs/doc[@for="ParseChildrenAttribute.GetHashCode"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\ParseChildrenAsPropertiesAttribute.uex' path='docs/doc[@for="ParseChildrenAttribute.Equals"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            ParseChildrenAttribute pca = obj as ParseChildrenAttribute;
            if (pca != null) {
                if (_childrenAsProps == false) {
                    return pca.ChildrenAsProperties == false;
                }
                else {
                    return pca.ChildrenAsProperties && (DefaultProperty.Equals(pca.DefaultProperty));
                }
            }
            return false;
        }

        /// <include file='doc\ParseChildrenAsPropertiesAttribute.uex' path='docs/doc[@for="ParseChildrenAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override bool IsDefaultAttribute() {
            return this.Equals(Default);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\persistchildrenattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="PersistChildrenAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;
    using System.ComponentModel;
    using System.Security.Permissions;

    /// <include file='doc\PersistChildrenAttribute.uex' path='docs/doc[@for="PersistChildrenAttribute"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Indicates whether
    ///       the contents within a tag representing a custom
    ///       or Web control should be treated as literal text. Web controls supporting complex properties, like
    ///       templates, and
    ///       so on, typically mark themselves as "literals", thereby letting the designer
    ///       infra-structure deal with the persistence of those attributes.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class PersistChildrenAttribute : Attribute {

        /// <include file='doc\PersistChildrenAttribute.uex' path='docs/doc[@for="PersistChildrenAttribute.Yes"]/*' />
        /// <devdoc>
        ///    <para>Indicates that the children of a control should be persisted at design-time.
        ///       </para>
        /// </devdoc>
        public static readonly PersistChildrenAttribute Yes = new PersistChildrenAttribute(true);

        /// <include file='doc\PersistChildrenAttribute.uex' path='docs/doc[@for="PersistChildrenAttribute.No"]/*' />
        /// <devdoc>
        ///    <para>Indicates that the children of a control should not be persisted at design-time.</para>
        /// </devdoc>
        public static readonly PersistChildrenAttribute No = new PersistChildrenAttribute(false);

        /// <include file='doc\PersistChildrenAttribute.uex' path='docs/doc[@for="PersistChildrenAttribute.Default"]/*' />
        /// <devdoc>
        ///     This marks the default child persistence behavior for a control at design time. (equal to Yes.)
        /// </devdoc>
        public static readonly PersistChildrenAttribute Default = Yes;

        private bool persist;


        /// <include file='doc\PersistChildrenAttribute.uex' path='docs/doc[@for="PersistChildrenAttribute.PersistChildrenAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        public PersistChildrenAttribute(bool persist) {
            this.persist = persist;
        }


        /// <include file='doc\PersistChildrenAttribute.uex' path='docs/doc[@for="PersistChildrenAttribute.Persist"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the children of a control should be persisted at design-time.
        ///       This property is read-only.</para>
        /// </devdoc>
        public bool Persist {
            get {
                return persist;
            }
        }

        /// <include file='doc\PersistChildrenAttribute.uex' path='docs/doc[@for="PersistChildrenAttribute.GetHashCode"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\PersistChildrenAttribute.uex' path='docs/doc[@for="PersistChildrenAttribute.Equals"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }
            if ((obj != null) && (obj is PersistChildrenAttribute)) {
                return((PersistChildrenAttribute)obj).Persist == persist;
            }

            return false;
        }

        /// <include file='doc\PersistChildrenAttribute.uex' path='docs/doc[@for="PersistChildrenAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override bool IsDefaultAttribute() {
            return this.Equals(Default);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\persistencemode.cs ===
//------------------------------------------------------------------------------
// <copyright file="PersistenceMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;

    /// <include file='doc\PersistenceMode.uex' path='docs/doc[@for="PersistenceMode"]/*' />
    /// <devdoc>
    ///    <para>Specifies whether properties and events are presistable 
    ///       in an HTML tag.</para>
    /// </devdoc>
    public enum PersistenceMode {

        /// <include file='doc\PersistenceMode.uex' path='docs/doc[@for="PersistenceMode.Attribute"]/*' />
        /// <devdoc>
        ///    <para>The property or event is persistable in the HTML tag as an attribute.</para>
        /// </devdoc>
        Attribute = 0,

        /// <include file='doc\PersistenceMode.uex' path='docs/doc[@for="PersistenceMode.InnerProperty"]/*' />
        /// <devdoc>
        ///    <para>The property or event is persistable within the HTML tag.</para>
        /// </devdoc>
        InnerProperty = 1,

        /// <include file='doc\PersistenceMode.uex' path='docs/doc[@for="PersistenceMode.InnerDefaultProperty"]/*' />
        /// <devdoc>
        ///    <para>The property or event is persistable within the HTML tag as a child. Only
        ///    a single property can be marked as InnerDefaultProperty.</para>
        /// </devdoc>
        InnerDefaultProperty = 2,

        /// <include file='doc\PersistenceMode.uex' path='docs/doc[@for="PersistenceMode.EncodedInnerDefaultProperty"]/*' />
        /// <devdoc>
        ///    <para>The property or event is persistable within the HTML tag as a child. Only
        ///    a single property can be marked as InnerDefaultProperty. Furthermode, this
        ///    persistence mode can only be applied to string properties.</para>
        /// </devdoc>
        EncodedInnerDefaultProperty = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\pageparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="PageParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Implements the ASP.NET template parser
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web.UI {
using System.Runtime.Serialization.Formatters;
using System.Text;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Reflection;
using System.Globalization;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Web.Caching;
using System.Web.Util;
using System.Web.Compilation;
using System.Web.Configuration;
using System.EnterpriseServices;
using HttpException = System.Web.HttpException;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Security.Permissions;

/*
 * Parser for .aspx files
 */
/// <include file='doc\PageParser.uex' path='docs/doc[@for="PageParser"]/*' />
/// <internalonly/>
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public sealed class PageParser : TemplateControlParser {

    // true by default
    private bool _fBuffer = true;
    internal bool FBuffer { get { return _fBuffer ; } }

    private int _transactionMode = 0 /*TransactionOption.Disabled*/;
    internal int TransactionMode { get { return _transactionMode; } }

    private TraceMode _traceMode = System.Web.TraceMode.Default;
    internal TraceMode TraceMode { get { return _traceMode; } }

    private TraceEnable _traceEnabled = TraceEnable.Default;
    internal TraceEnable TraceEnabled { get { return _traceEnabled; } }

    private string _contentType;
    internal string ContentType { get { return _contentType; } }

    private int _codePage;
    internal int CodePage { get { return _codePage; } }

    private string _responseEncoding;
    internal string ResponseEncoding { get { return _responseEncoding; } }

    private int _lcid;
    internal int Lcid { get { return _lcid; } }

    private string _culture;
    internal string Culture { get { return _culture; } }

    private string _uiCulture;
    internal string UICulture { get { return _uiCulture; } }

    private bool _fRequiresSessionState = true;
    internal bool FRequiresSessionState { get { return _fRequiresSessionState; } }

    private bool _fReadOnlySessionState;
    internal bool FReadOnlySessionState { get { return _fReadOnlySessionState; } }

    private string _errorPage;
    internal string ErrorPage { get { return _errorPage; } }

    private string _clientTarget;
    internal string ClientTarget { get { return _clientTarget; } }

    private bool _aspCompatMode;
    internal bool AspCompatMode { get { return _aspCompatMode; } }

    private bool _enableViewStateMac;
    internal bool EnableViewStateMac { get { return _enableViewStateMac; } }

    private bool _smartNavigation;
    internal bool SmartNavigation { get { return _smartNavigation; } }

    private bool _validateRequest = true;
    internal bool ValidateRequest { get { return _validateRequest; } }

    private string _varyByHeader;
    internal string VaryByHeader { get { return _varyByHeader; } }

    private OutputCacheLocation _outputCacheLocation;
    internal OutputCacheLocation OutputCacheLocation { get { return _outputCacheLocation; } }

    /*
     * Compile an .aspx file into a Page object
     */
    /// <include file='doc\PageParser.uex' path='docs/doc[@for="PageParser.GetCompiledPageInstance"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public static IHttpHandler GetCompiledPageInstance(string virtualPath,
        string inputFile, HttpContext context) {

        // Only allowed in full trust (ASURT 123086)
        InternalSecurityPermissions.UnmanagedCode.Demand();

        // Suspend client impersonation (ASURT 139770)
        HttpContext.ImpersonationSuspendContext ictx = context.Impersonation.SuspendIfClient();

        try {
            try {
                return GetCompiledPageInstanceInternal(virtualPath, inputFile, context);
            }
            finally {
                // Resume client impersonation
                ictx.Resume();
            }
        }
        catch { throw; }    // Prevent Exception Filter Security Issue (ASURT 122835)
    }

    internal static IHttpHandler GetCompiledPageInstanceInternal(string virtualPath,
        string inputFile, HttpContext context) {

        PageParser parser = new PageParser();
        return (IHttpHandler) parser.GetCompiledInstance(virtualPath, inputFile, context);
    }

    internal override Type DefaultBaseType { get { return typeof(System.Web.UI.Page); } }

    /// <include file='doc\PageParser.uex' path='docs/doc[@for="PageParser.CompileIntoType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected override Type CompileIntoType() {
        return PageCompiler.CompilePageType(this);
    }

    // Get default settings from config
    internal override void ProcessConfigSettings() {
        base.ProcessConfigSettings();

        if (PagesConfig != null) {
            _fBuffer = PagesConfig.FBuffer;
            _fRequiresSessionState = PagesConfig.FRequiresSessionState;
            _fReadOnlySessionState = PagesConfig.FReadOnlySessionState;
            _enableViewStateMac = PagesConfig.FEnableViewStateMac;
            _smartNavigation = PagesConfig.SmartNavigation;
            _validateRequest = PagesConfig.ValidateRequest;
            _aspCompatMode = PagesConfig.FAspCompat;
            if (PagesConfig.PageBaseType != null)
                BaseType = PagesConfig.PageBaseType;
        }
    }

    internal override void ProcessMainDirective(IDictionary mainDirective) {

        // Get the error page (if any).
        _errorPage = Util.GetAndRemoveNonEmptyAttribute(mainDirective, "errorpage");

        // Get various attributes

        _clientTarget = Util.GetAndRemove(mainDirective, "clienttarget");

        _contentType = Util.GetAndRemoveNonEmptyAttribute(mainDirective, "contenttype");

        Util.GetAndRemoveBooleanAttribute(mainDirective, "buffer",
                                          ref _fBuffer);

        if (!_fBuffer && _errorPage != null) {
            throw new HttpException(
                                   HttpRuntime.FormatResourceString(SR.Error_page_not_supported_when_buffering_off));
        }

        string tmp = Util.GetAndRemove(mainDirective, "enablesessionstate");
        if (tmp != null) {
            _fRequiresSessionState = true;
            _fReadOnlySessionState = false;
            if (Util.IsFalseString(tmp)) {
                _fRequiresSessionState = false;
            }
            else if (string.Compare(tmp, "readonly", true, CultureInfo.InvariantCulture) == 0) {
                _fReadOnlySessionState = true;
            }
            else if (!Util.IsTrueString(tmp)) {
                throw new HttpException(
                                       HttpRuntime.FormatResourceString(SR.Enablesessionstate_must_be_true_false_or_readonly));
            }
        }

        _culture = Util.GetAndRemoveNonEmptyAttribute(mainDirective, "culture");

        // If it was specified, create a CultureInfo just to verify validity
        if (_culture != null) {
            CultureInfo cultureInfo;

            try {
                cultureInfo = HttpServerUtility.CreateReadOnlyCultureInfo(_culture);
            }
            catch {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Invalid_attribute_value, _culture, "culture"));
            }

            // Don't allow neutral cultures (ASURT 77930)
            if (cultureInfo.IsNeutralCulture) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Invalid_culture_attribute,
                        Util.GetSpecificCulturesFormattedList(cultureInfo)));
            }
        }

        bool fHasLcid = Util.GetAndRemoveNonNegativeIntegerAttribute(mainDirective, "lcid", ref _lcid);

        // If it was specified, create a CultureInfo just to verify validity
        if (fHasLcid) {
            try {
                HttpServerUtility.CreateReadOnlyCultureInfo(_lcid);
            }
            catch {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Invalid_attribute_value, _lcid.ToString(), "lcid"));
            }
        }

        if (_culture != null && fHasLcid)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Attributes_mutually_exclusive, "Culture", "LCID"));

        _uiCulture = Util.GetAndRemoveNonEmptyAttribute(mainDirective, "uiculture");

        _responseEncoding = Util.GetAndRemoveNonEmptyAttribute(mainDirective, "responseencoding");
        // If it was specified, call Encoding.GetEncoding just to verify validity
        if (_responseEncoding != null)
            Encoding.GetEncoding(_responseEncoding);

        bool fHasCodePage = Util.GetAndRemoveNonNegativeIntegerAttribute(mainDirective, "codepage", ref _codePage);
        // If it was specified, call Encoding.GetEncoding just to verify validity
        if (fHasCodePage)
            Encoding.GetEncoding(_codePage);

        if (_responseEncoding != null && fHasCodePage) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Attributes_mutually_exclusive, "ResponseEncoding", "CodePage"));
        }

        if (mainDirective["transaction"] != null) {
            ParseTransactionAttribute(mainDirective);
        }

        if (Util.GetAndRemoveBooleanAttribute(mainDirective, "aspcompat", ref _aspCompatMode)) {

            // Only allow the use of aspcompat when we have UnmanagedCode access (ASURT 76694)
            if (_aspCompatMode && !HttpRuntime.HasUnmanagedPermission()) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Insufficient_trust_for_attribute, "AspCompat"));
            }
        }

        // We use TraceModeInternal instead of TraceMode to disallow the 'default' value (ASURT 75783)
        object tmpObj = Util.GetAndRemoveEnumAttribute(
            mainDirective, typeof(TraceModeInternal), "tracemode");
        if (tmpObj != null)
            _traceMode = (TraceMode) tmpObj;

        bool traceEnabled = false;
        if(Util.GetAndRemoveBooleanAttribute(mainDirective, "trace", ref traceEnabled)) {
            if (traceEnabled)
                _traceEnabled = TraceEnable.Enable;
            else
                _traceEnabled = TraceEnable.Disable;
        }

        Util.GetAndRemoveBooleanAttribute(mainDirective, "enableviewstatemac", ref _enableViewStateMac);

        Util.GetAndRemoveBooleanAttribute(mainDirective, "smartnavigation", ref _smartNavigation);

        Util.GetAndRemoveBooleanAttribute(mainDirective, "validaterequest", ref _validateRequest);

        base.ProcessMainDirective(mainDirective);
    }

    private enum TraceModeInternal {
        SortByTime = 0,
        SortByCategory = 1
    }

    // This must be in its own method to avoid jitting System.EnterpriseServices.dll
    // when it is not needed (ASURT 71868)
    private void ParseTransactionAttribute(IDictionary directive) {
        object tmpObj = Util.GetAndRemoveEnumAttribute(
            directive, typeof(TransactionOption), "transaction");
        if (tmpObj != null) {
            _transactionMode = (int) tmpObj;

            // Add a reference to the transaction assembly only if needed
            if (_transactionMode != 0 /*TransactionOption.Disabled*/) {

                if (!HttpRuntime.HasAspNetHostingPermission(AspNetHostingPermissionLevel.Medium)) {
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Insufficient_trust_for_attribute, "transaction"));
                }

                AddAssemblyDependency(typeof(TransactionOption).Assembly);
            }
        }
    }

    internal const string defaultDirectiveName = "page";
    internal override string DefaultDirectiveName {
        get { return defaultDirectiveName; }
    }

    /*
     * Process the contents of the <%@ OutputCache ... %> directive
     */
    internal override void ProcessOutputCacheDirective(string directiveName, IDictionary directive) {

        _varyByHeader = Util.GetAndRemoveNonEmptyAttribute(directive, "varybyheader");
        object tmpObj = Util.GetAndRemoveEnumAttribute(directive,
            typeof(OutputCacheLocation), "location");
        if (tmpObj != null)
            _outputCacheLocation = (OutputCacheLocation) tmpObj;

        base.ProcessOutputCacheDirective(directiveName, directive);
    }

    internal override bool FDurationRequiredOnOutputCache {
        get { return _outputCacheLocation != OutputCacheLocation.None; }
    }

    internal override bool FVaryByParamsRequiredOnOutputCache {
        get { return _outputCacheLocation != OutputCacheLocation.None; }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\page.cs ===
//------------------------------------------------------------------------------
// <copyright file="Page.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

/*
 * Page class definition
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web.UI {

using System.Text;
using System.Runtime.Serialization.Formatters;
using System.Threading;
using System.Runtime.Serialization;
using System.ComponentModel;
using System.Reflection;
using System;
using System.IO;
using System.Security.Principal;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel.Design;
using System.ComponentModel.Design.Serialization;
using System.Globalization;
using System.Web;
using System.Web.Util;
using System.Web.SessionState;
using System.Web.Caching;
using HtmlForm=System.Web.UI.HtmlControls.HtmlForm;
using System.EnterpriseServices;
using System.Security;
using System.Security.Permissions;
using Debug=System.Diagnostics.Debug;


/// <include file='doc\Page.uex' path='docs/doc[@for="Page"]/*' />
/// <devdoc>
///    <para>
///       Defines the properties, methods, and events common to
///       all pages that are processed on the server by the Web Forms page framework.
///    <see langword='Page '/>
///    objects are compiled and cached in
///    memory when any ASP.NET page is
///    requested.</para>
///    <para>This class is not marked as abstract, because the VS designer
///          needs to instantiate it when opening .ascx files</para>
/// </devdoc>
[
DefaultEvent("Load"),
Designer("Microsoft.VSDesigner.WebForms.WebFormDesigner, " + AssemblyRef.MicrosoftVSDesigner, typeof(IRootDesigner)),
DesignerCategory("ASPXCodeBehind"),
RootDesignerSerializer("Microsoft.VSDesigner.WebForms.RootCodeDomSerializer, " + AssemblyRef.MicrosoftVSDesigner,  "System.ComponentModel.Design.Serialization.CodeDomSerializer, " + AssemblyRef.SystemDesign, true),
ToolboxItem(false)
]
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public class Page: TemplateControl, IHttpHandler {
    // Has the page layout changed since last request
    private bool _fPageLayoutChanged;

    // Session state
    private bool                _sessionRetrieved;
    private HttpSessionState    _session;

    private int _transactionMode = 0 /*TransactionOption.Disabled*/;
    private bool _aspCompatMode;

    // Http Intrinsics
    internal HttpRequest _request;
    internal HttpResponse _response;
    internal HttpApplicationState _application;
    internal Cache _cache;

    internal string _errorPage;
    private string _clientTarget;

    // Form related fields
    private LosFormatter _formatter;
    private HtmlForm _form;
    private bool _inOnFormRender;
    private bool _fOnFormRenderCalled;
    private bool _fRequirePostBackScript;
    private bool _fPostBackScriptRendered;

    private const string systemPostFieldPrefix = "__";
    private const string postBackFunctionName = "__doPostBack";
    private const string jscriptPrefix = "javascript:";

    private const string IncludeScriptFormat = @"
<script language=""{0}"" src=""{1}{2}""></script>";

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.postEventSourceID"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected const string postEventSourceID = systemPostFieldPrefix + "EVENTTARGET";

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.postEventArgumentID"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected const string postEventArgumentID = systemPostFieldPrefix + "EVENTARGUMENT";

    internal const string viewStateID = systemPostFieldPrefix + "VIEWSTATE";
    private const string clientScriptStart = "<script language=\"javascript\">\r\n<!--";
    private const string clientScriptEnd = "// -->\r\n</script>";

    private IDictionary _registeredClientScriptBlocks;
    private IDictionary _registeredClientStartupScripts;
    private IDictionary _registeredOnSubmitStatements;
    private IDictionary _registeredArrayDeclares;
    private IDictionary _registeredHiddenFields;
    private ArrayList   _controlsRequiringPostBack;
    private ArrayList   _registeredControlsThatRequirePostBack;
    private NameValueCollection _leftoverPostData;
    private IPostBackEventHandler _registeredControlThatRequireRaiseEvent;
    private ArrayList _changedPostDataConsumers;

    private bool    _needToPersistViewState;
    private bool    _enableViewStateMac;
    private object  _viewStateToPersist;
    private string _viewStateUserKey;

    private SmartNavigationSupport _smartNavSupport;
    internal HttpContext _context;

    private ValidatorCollection _validators;
    private bool _validated = false;

    // Can be either Context.Request.Form or Context.Request.QueryString
    // depending on the method used.
    private NameValueCollection _requestValueCollection;

    private static IDictionary s_systemPostFields;
    static Page() {
        // Create a static hashtable with all the names that should be
        // ignored in ProcessPostData().
        s_systemPostFields = new HybridDictionary();
        s_systemPostFields[postEventSourceID] = null;
        s_systemPostFields[postEventArgumentID] = null;
        s_systemPostFields[viewStateID] = null;
    }


    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Page"]/*' />
    /// <devdoc>
    /// <para>Initializes a new instance of the <see cref='System.Web.UI.Page'/> class.</para>
    /// </devdoc>
    public Page() {
        _page = this;   // Set the page to ourselves
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Context"]/*' />
    /// <devdoc>
    /// <para>Gets the HttpContext for the Page.</para>
    /// </devdoc>
    protected override HttpContext Context {
        get {
            if (_context == null) {
                _context = HttpContext.Current;
            }
            return _context;
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Application"]/*' />
    /// <devdoc>
    /// <para>Gets the <see langword='Application'/> object provided by the HTTP Runtime.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public HttpApplicationState Application { get { return _application;} }

    /*
     * Any onsubmit statment to hook up by the form. The HtmlForm object calls this
     * during RenderAttributes.
     */
    internal string ClientOnSubmitEvent {
        get {
            if (_registeredOnSubmitStatements != null) {
                string s = string.Empty;
                IDictionaryEnumerator e = _registeredOnSubmitStatements.GetEnumerator();
                while (e.MoveNext()) {
                    s += (string)e.Value;
                }
                return s;
            }
            return string.Empty;
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.ClientTarget"]/*' />
    /// <devdoc>
    ///    <para>Indicates whether the requesting browser is uplevel or downlevel so that the appropriate behavior can be
    ///       generated for the request.</para>
    /// </devdoc>
    [
    DefaultValue(""),
    WebSysDescription(SR.Page_ClientTarget),
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public string ClientTarget {
        get {
            return (_clientTarget == null) ? "" : _clientTarget;
        }
        set {
            _clientTarget = value;
            if (_request != null) {
                _request.ClientTarget = value;
            }
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.ErrorPage"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Gets or sets the error page to which the requesting browser should be
    ///       redirected in the event of an unhandled page exception.
    ///    </para>
    /// </devdoc>
    [
    DefaultValue(""),
    WebSysDescription(SR.Page_ErrorPage),
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public string ErrorPage {
        get {
            return _errorPage;
        }
        set {
            _errorPage = value;
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.IsReusable"]/*' />
    /// <internalonly/>
    /// <devdoc>Page class can be cached/reused</devdoc>
    [
    Browsable(false),
    EditorBrowsable(EditorBrowsableState.Never)
    ]
    public bool IsReusable {
        get { return false; }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Trace"]/*' />
    /// <devdoc>
    /// <para>Gets the <see cref='System.Web.TraceContext'/> object for the current Web
    ///    request. Tracing tracks and presents the execution details about a Web request. </para>
    /// For trace data to be visible in a rendered page, you must
    /// turn tracing on for that page.
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public TraceContext Trace {
        get {
            return Context.Trace;
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Request"]/*' />
    /// <devdoc>
    /// <para>Gets the <see langword='Request'/> object provided by the HTTP Runtime, which
    ///    allows you to access data from incoming HTTP requests.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public HttpRequest Request {
        get {
            if (_request == null)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Request_not_available));

            return _request;
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Response"]/*' />
    /// <devdoc>
    /// <para>Gets the <see langword='Response '/>object provided by the HTTP Runtime, which
    ///    allows you to send HTTP response data to a client browser.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public HttpResponse Response {
        get {
            if (_response == null)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Response_not_available));

            return _response;
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Server"]/*' />
    /// <devdoc>
    /// <para>Gets the <see langword='Server'/> object supplied by the HTTP runtime.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public HttpServerUtility Server {
        get { return Context.Server;}
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Cache"]/*' />
    /// <devdoc>
    /// <para>Retrieves a <see langword='Cache'/> object in which to store the page for
    ///    subsequent requests. This property is read-only.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public Cache Cache {
        get {
            if (_cache == null)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cache_not_available));

            return _cache;
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Session"]/*' />
    /// <devdoc>
    /// <para>Gets the <see langword='Session'/>
    /// object provided by the HTTP Runtime. This object provides information about the current request's session.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public virtual HttpSessionState Session {
        get {
            if (!_sessionRetrieved) {
                /* try just once to retrieve it */
                _sessionRetrieved = true;

                try {
                    _session = Context.Session;
                }
                catch (Exception) {
                    /*
                     * Just ignore exceptions, return null.
                     */
                }
            }

            if (_session == null) {
                throw new HttpException(
                                       HttpRuntime.FormatResourceString(SR.Session_not_enabled));
            }

            return _session;
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.User"]/*' />
    /// <devdoc>
    ///    <para>Indicates the user making the page request. This property uses the
    ///       Context.User property to determine where the request originates. This property
    ///       is read-only.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public IPrincipal User {
        get { return Context.User;}
    }

    /*
     * This protected virtual method is called by the Page to create the HtmlTextWriter
     * to use for rendering. The class created is based on the TagWriter property on
     * the browser capabilities.
     */
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.CreateHtmlTextWriter"]/*' />
    /// <devdoc>
    /// <para>Creates an <see cref='System.Web.UI.HtmlTextWriter'/> object to render the page's
    ///    content. If the <see langword='IsUplevel'/> property is set to
    /// <see langword='false'/>, an <see langword='Html32TextWriter'/> object is created
    ///    to render requests originating from downlevel browsers. For derived pages, you
    ///    can override this method to create a custom text writer.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual HtmlTextWriter CreateHtmlTextWriter(TextWriter tw) {
        return CreateHtmlTextWriterInternal(tw, _request );
    }

    internal static HtmlTextWriter CreateHtmlTextWriterInternal(TextWriter tw, HttpRequest request) {
        if (request != null) {
            Type tagWriter = request.Browser.TagWriter;
            if (tagWriter != null)
                return CreateHtmlTextWriterFromType(tw, request.Browser.TagWriter);
        }

        // Fall back to Html 3.2
        return new Html32TextWriter(tw);
    }

    internal static HtmlTextWriter CreateHtmlTextWriterFromType(TextWriter tw, Type writerType) {
        if (writerType == typeof(HtmlTextWriter)) {
            return new HtmlTextWriter(tw);
        }
        else {
            try {
                // Make sure the type has the correct base class (ASURT 123677)
                Util.CheckAssignableType(typeof(HtmlTextWriter), writerType);

                return (HtmlTextWriter)HttpRuntime.CreateNonPublicInstance(writerType, new object[] {tw});
            }
            catch (Exception) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_HtmlTextWriter, writerType.FullName));
            }
        }
    }

    /*
     * This method is implemented by the Page classes that we generate on
     * the fly.  It returns a has code unique to the control layout.
     */
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.GetTypeHashCode"]/*' />
    /// <devdoc>
    /// <para>Retrieves a hash code that is generated by <see langword='Page'/> objects that
    ///    are generated at runtime. This hash code is unique to the page's control
    ///    layout.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public virtual int GetTypeHashCode() {
        return 0;
    }

    /*
     * Override for small efficiency win: page doesn't prepend its name
     */
    internal override string GetUniqueIDPrefix() {
        // Only overridde if we're at the top level
        if (Parent == null)
            return "";

        // Use base implementation for interior nodes
        return base.GetUniqueIDPrefix();
    }

    /*
     * Called when an exception occurs in ProcessRequest
     */
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.HandleError"]/*' />
    /// <devdoc>
    /// <para>Throws an <see cref='System.Web.HttpException'/> object when an error occurs during a call to the
    /// <see cref='System.Web.UI.Page.ProcessRequest'/> method. If there is a custom error page, and
    ///    custom error page handling is enabled, the method redirects to the specified
    ///    custom error page.</para>
    /// </devdoc>
    private bool HandleError(Exception e) {
        try {
            // Remember the exception to be accessed via Server.GetLastError/ClearError
            Context.TempError = e;
            // Raise the error event
            OnError(EventArgs.Empty);
            // If the error has been cleared by the event handler, nothing else to do
            if (Context.TempError == null)
                return true;
        } finally {
            Context.TempError = null;
        }

        // If an error page was specified, redirect to it
        if (_errorPage != null) {
            // only redirect if custom errors are enabled:

            if (CustomErrors.GetSettings(Context).CustomErrorsEnabled(_request)) {
                _response.RedirectToErrorPage(_errorPage);
                return true;
            }
        }

        // Increment all of the appropriate error counters
        PerfCounters.IncrementCounter(AppPerfCounter.ERRORS_UNHANDLED);

        string traceString = null;
        if (Context.TraceIsEnabled) {
            Trace.Warn(HttpRuntime.FormatResourceString(SR.Unhandled_Err_Error), null, e);
            if (Trace.PageOutput) {
                StringWriter sw = new StringWriter();
                HtmlTextWriter htw = new HtmlTextWriter(sw);

                // these three calls will happen again at the end of the request, but
                // in order to have the full trace log on the rendered page, we need
                // to call them now.
                Trace.EndRequest();
                Trace.StatusCode = 500;
                Trace.Render(htw);
                traceString = sw.ToString();
            }
        }

        // If the exception is an HttpException with a formatter, just
        // rethrow it instead of a new one (ASURT 45479)
        if (HttpException.GetErrorFormatter(e) != null) {
            return false;
        }

        // Don't touch security exceptions (ASURT 78366)
        if (e is System.Security.SecurityException)
            return false;

        throw new HttpUnhandledException(null, traceString, e);
    }

    /*
     * Returns true if this is a postback, which means it has some
     * previous viewstate to reload. Use this in the Load method to differentiate
     * an initial load from a postback reload.
     */
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.IsPostBack"]/*' />
    /// <devdoc>
    ///    <para>Gets a value indicating whether the page is being loaded in response to a
    ///       client postback, or if it is being loaded and accessed for the first time.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public bool IsPostBack {
        get {
            if (_requestValueCollection == null)
                return false;

            // If the page control layout has changed, pretend that we are in
            // a non-postback situation.
            return !_fPageLayoutChanged;
        }
    }

    internal NameValueCollection RequestValueCollection {
        get { return _requestValueCollection; }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.EnableViewState"]/*' />
    [
    Browsable(false)
    ]
    public override bool EnableViewState {
        get {
            return base.EnableViewState;
        }
        set {
            base.EnableViewState = value;
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.ViewStateUserKey"]/*' />
    /// <devdoc>
    ///    <para>Setting this property helps prevent one-click attacks (ASURT 126375)</para>
    /// </devdoc>
    [
    Browsable(false)
    ]
    public string ViewStateUserKey {
        get {
            return _viewStateUserKey;
        }
        set {
            // Make sure it's not called too late
            if (ControlState >= ControlState.Initialized) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Too_late_for_ViewStateUserKey));
            }

            _viewStateUserKey = value;
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.ID"]/*' />
    [
    Browsable(false)
    ]
    public override string ID {
        get {
            return base.ID;
        }
        set {
            base.ID = value;
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Visible"]/*' />
    [
    Browsable(false)
    ]
    public override bool Visible {
        get {
            return base.Visible;
        }
        set {
            base.Visible = value;
        }
    }

    /*
     * Performs intialization of the page required by the designer.
     */
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.DesignerInitialize"]/*' />
    /// <devdoc>
    ///    <para>Performs any initialization of the page that is required by RAD designers.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public void DesignerInitialize() {
        InitRecursive(null);
    }

    internal NameValueCollection GetCollectionBasedOnMethod() {
        // Get the right NameValueCollection base on the method
        if (string.Compare(_request.HttpMethod, "POST", false, CultureInfo.InvariantCulture) == 0)
            return _request.Form;
        else
            return _request.QueryString;
    }

    /*
     * Determine which of the following three cases we're in:
     * - Initial request.  No postback, return null
     * - GET postback request.  Return Context.Request.QueryString
     * - POST postback request.  Return Context.Request.Form
     */
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.DeterminePostBackMode"]/*' />
    /// <devdoc>
    ///    <para>Determines the type of request made for the page based on if the page was a
    ///       postback, and whether a GET or POST method was used for the request.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual NameValueCollection DeterminePostBackMode() {
        if (Context.Request == null)
            return null;

        // If we're in a Transfer/Execute, never treat as postback (ASURT 121000)
        if (Context.ServerExecuteDepth > 0)
            return null;

        NameValueCollection ret = GetCollectionBasedOnMethod();

        // If there is no view state or postEventSourceID in the request,
        // it's an initial request
        // REVIEW: we should not have to check for both.  Right now we do
        // because some tests only specify viewStateID while others only
        // specify postEventSourceID.
        if (ret[viewStateID] == null && ret[postEventSourceID] == null)
            ret = null;

        return ret;
    }

    internal void LoadPageViewState() {
        // The state was saved as an array of objects:
        // 1. The hash code string
        // 2. The state of the entire control hierarchy
        // 3. A list of controls that require postback
        Triplet allSavedState = (Triplet)LoadPageStateFromPersistenceMedium();

        // Is there any state?
        if (allSavedState != null) {
            // Get the hash code from the state
            string hashCode = (string) allSavedState.First;

            // If it's different from the current one, the layout has changed
            int viewhash = Int32.Parse(hashCode, NumberFormatInfo.InvariantInfo);
            _fPageLayoutChanged = Int32.Parse(hashCode, NumberFormatInfo.InvariantInfo) != GetTypeHashCode() ;

            // If the page control layout has changed, don't attempt to
            // load any more state.
            if (!_fPageLayoutChanged) {
                // UNCOMMENT FOR DEBUG OUTPUT
                // WalkViewState(allSavedState.Second, null, 0);
                LoadViewStateRecursive(allSavedState.Second);

                _controlsRequiringPostBack = (ArrayList)allSavedState.Third;
            }
        }
    }

    /*
     * Override this method to persist view state to something other
     * than hidden fields (CONSIDER: we may want a switch for session too).
     * You must also override SaveStateToPersistenceMedium().
     */
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.LoadPageStateFromPersistenceMedium"]/*' />
    /// <devdoc>
    ///    <para>Loads any saved view state information to the page. Override this method if
    ///       you want to load the page view state in anything other than a hidden field.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual object LoadPageStateFromPersistenceMedium() {
        if (_requestValueCollection == null)
            return null;

        string persistedState = _requestValueCollection[viewStateID];

        if (persistedState == null)
            return null;

        if (_formatter == null)
            CreateLosFormatter();

        try {
            return _formatter.Deserialize(persistedState);
        }
        catch {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_Viewstate));
        }
    }

    // Compute a mac key modifier for the page (ASURT 58215)
    private string GetMacKeyModifier() {
        //Note: duplicated in MobilePage.cs, keep in sync

        // Use the page's directory and class name as part of the key (ASURT 64044)
        // We need to make sure that the hash is case insensitive, since the file system
        // is, and strange view state errors could otherwise happen (ASURT 128657)
        int pageHashCode = SymbolHashCodeProvider.Default.GetHashCode(TemplateSourceDirectory);
        pageHashCode += SymbolHashCodeProvider.Default.GetHashCode(GetType().Name);

        string strKey = pageHashCode.ToString(NumberFormatInfo.InvariantInfo);

        // Modify the key with the ViewStateUserKey, if any (ASURT 126375)
        if (ViewStateUserKey != null)
            strKey += ViewStateUserKey;

        return strKey;
    }

    private void CreateLosFormatter() {
        if (!EnableViewStateMac){
            _formatter = new LosFormatter();
        }
        else {
                // Tell the formatter to generate a mac string if the option is on (ASURT 5295)
                _formatter = new LosFormatter(true, GetMacKeyModifier());
        }
    }

    internal void OnFormRender(HtmlTextWriter writer, string formUniqueID) {
        // Make sure there is only one form tag (ASURT 18891, 18894)
        if (_fOnFormRenderCalled) {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Multiple_forms_not_allowed));
        }

        _fOnFormRenderCalled = true;
        _inOnFormRender = true;

        RenderHiddenFields(writer);

        if (_viewStateToPersist != null) {
            if (_formatter == null)
                CreateLosFormatter();

            writer.WriteLine();
            writer.Write("<input type=\"hidden\" name=\"");
            writer.Write(viewStateID);
            writer.Write("\" value=\"");

            // LosFormatter base64 encodes the viewstate, so we don't have to worry about
            // HtmlEncoding
            _formatter.Serialize(writer, _viewStateToPersist);

            writer.WriteLine("\" />");
        }
        else {
            // ASURT 106992
            // Need to always render out the viewstate field so alternate viewstate persistence will get called
            writer.WriteLine();
            writer.Write("<input type=\"hidden\" name=\"");
            writer.Write(viewStateID);
            writer.Write("\" value=\"\" />");
        }

        if (_fRequirePostBackScript)
            RenderPostBackScript(writer, formUniqueID);

        RenderScriptBlock(writer, _registeredClientScriptBlocks);
    }

    internal void OnFormPostRender(HtmlTextWriter writer, string formUniqueID) {

        if (_registeredArrayDeclares != null) {
            writer.WriteLine();
            writer.WriteLine(clientScriptStart);
            writer.Indent++;

            IDictionaryEnumerator arrays = _registeredArrayDeclares.GetEnumerator();
            while (arrays.MoveNext()) {
                writer.Write("var ");
                writer.Write(arrays.Key);
                writer.Write(" =  new Array(");

                IEnumerator elements = ((ArrayList)arrays.Value).GetEnumerator();
                bool first = true;
                while (elements.MoveNext()) {
                    if (first) {
                        first = false;
                    }
                    else {
                        writer.Write(", ");
                    }
                    writer.Write(elements.Current);
                }

                writer.WriteLine(");");
            }

            writer.Indent++;
            writer.WriteLine(clientScriptEnd);
            writer.WriteLine();
        }

        RenderHiddenFields(writer);

        if (_fRequirePostBackScript && !_fPostBackScriptRendered)
            RenderPostBackScript(writer, formUniqueID);

        RenderScriptBlock(writer, _registeredClientStartupScripts);

        _inOnFormRender = false;
    }


    private void RenderHiddenFields(HtmlTextWriter writer) {
        if (_registeredHiddenFields != null) {
            IDictionaryEnumerator e = _registeredHiddenFields.GetEnumerator();

            while (e.MoveNext()) {
                writer.WriteLine();
                writer.Write("<input type=\"hidden\" name=\"");
                writer.Write((string)e.Key);
                writer.Write("\" value=\"");
                HttpUtility.HtmlEncode((string)e.Value, writer);
                writer.Write("\" />");
            }
            _registeredHiddenFields = null;
        }
    }

    private void RenderScriptBlock(HtmlTextWriter writer, IDictionary scriptBlocks) {

        if (scriptBlocks != null) {
            writer.Indent++;
            IDictionaryEnumerator e = scriptBlocks.GetEnumerator();

            while (e.MoveNext()) {
                writer.WriteLine((string)e.Value);
                writer.WriteLine();
            }
            writer.Indent--;
        }

    }

    /*
     * Enables controls to obtain client-side script function that will cause
     * (when invoked) a server post-back to the form.
     */
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.GetPostBackEventReference"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Associates the reference to the control that will
    ///       process the postback on the server.
    ///    </para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public string GetPostBackEventReference(Control control) {
        return GetPostBackEventReference(control, string.Empty);
    }

    /*
     * Enables controls to obtain client-side script function that will cause
     * (when invoked) a server post-back to the form.
     * argument: Parameter that will be passed to control on server
     */
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.GetPostBackEventReference1"]/*' />
    /// <devdoc>
    ///    <para>Passes a parameter to the control that will do the postback processing on the
    ///       server.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public string GetPostBackEventReference(Control control,
                                                   string argument) {
        RegisterPostBackScript();

        // Use '$''s for the IS separator, but make sure we don't do it for
        // mobile pages, hence the _inOnFormRender check (ASURT 142625)
        if (_inOnFormRender) {
            return postBackFunctionName + "('" + control.UniqueIDWithDollars + "','" +
                Util.QuoteJScriptString(argument) + "')";
        }

        // The argument needs to be quoted, in case in contains characters that
        // can't be used in JScript strings (ASURT 71818).
        return postBackFunctionName + "('" + control.UniqueID + "','" +
            Util.QuoteJScriptString(argument) + "')";
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.GetPostBackClientEvent"]/*' />
    /// <devdoc>
    ///    <para>This returs a string that can be put in client event to post back to the named control</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public string GetPostBackClientEvent(Control control, string argument) {
        return GetPostBackEventReference(control, argument);
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.GetPostBackClientHyperlink"]/*' />
    /// <devdoc>
    ///    <para>This returs a string that can be put in client event to post back to the named control</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public string GetPostBackClientHyperlink(Control control, string argument) {
        // Hyperlinks always need the language prefix
        return jscriptPrefix + GetPostBackEventReference(control, argument);
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.RegisterArrayDeclaration"]/*' />
    /// <devdoc>
    ///    <para>Declares a value that will be declared as a JavaScript array declaration
    ///       when the page renders. This can be used by script-based controls to declare
    ///       themselves within an array so that a client script library can work with
    ///       all the controls of the same type.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public void RegisterArrayDeclaration(string arrayName, string arrayValue) {
        if (_registeredArrayDeclares == null) {
            _registeredArrayDeclares = new HybridDictionary();
        }
        if (!_registeredArrayDeclares.Contains(arrayName)) {
            _registeredArrayDeclares[arrayName] = new ArrayList();
        }

        ArrayList elements = (ArrayList) _registeredArrayDeclares[arrayName];
        elements.Add(arrayValue);
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.RegisterHiddenField"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Allows controls to automatically register a hidden field on the form. The
    ///       field will be emitted when the form control renders itself.
    ///    </para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual void RegisterHiddenField(string hiddenFieldName,
                                            string hiddenFieldInitialValue) {
        if (_registeredHiddenFields == null)
            _registeredHiddenFields = new HybridDictionary();

        if (!_registeredHiddenFields.Contains(hiddenFieldName))
            _registeredHiddenFields.Add(hiddenFieldName, hiddenFieldInitialValue);
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.RegisterPostBackScript"]/*' />
    /// <devdoc>
    ///    <para>Allows controls on a page to access to the _doPostBack JavaScript handler on the
    ///       client. This method can be called multiple times by multiple controls. It should
    ///       render only one instance of the _doPostBack script.</para>
    /// </devdoc>
    internal void RegisterPostBackScript() {
        if (_fPostBackScriptRendered)
            return;

        if (!_fRequirePostBackScript) {
            RegisterHiddenField(postEventSourceID, "");
            RegisterHiddenField(postEventArgumentID, "");
        }

        _fRequirePostBackScript = true;
    }

    private void RenderPostBackScript(HtmlTextWriter writer, string formUniqueID) {
        writer.Write(
                    "\r\n" + clientScriptStart +
                    "\r\n\tfunction " + postBackFunctionName + "(eventTarget, eventArgument) {" +
                    "\r\n\t\tvar theform;" +
                    "\r\n\t\tif (window.navigator.appName.toLowerCase().indexOf(\"netscape\") > -1) {" +
                    // We cannot write document._ctl0__ctl0, because Netscape doesn't understand ID's (ASURT 140787)
                    "\r\n\t\t\ttheform = document.forms[\"" + formUniqueID + "\"];" +
                    "\r\n\t\t}" +
                    "\r\n\t\telse {" +
                    "\r\n\t\t\ttheform = document." + formUniqueID + ";" +
                    "\r\n\t\t}" +
                    // Restore the '$'s into ':'s (ASURT 142625)
                    "\r\n\t\ttheform." + postEventSourceID + ".value = eventTarget.split(\"$\").join(\":\");" +
                    "\r\n\t\ttheform." + postEventArgumentID + ".value = eventArgument;" +
                    "\r\n\t\ttheform.submit();" +
                    "\r\n\t}" +
                    "\r\n" + clientScriptEnd + "\r\n"
                    );

        _fPostBackScriptRendered=true;
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.IsStartupScriptRegistered"]/*' />
    /// <devdoc>
    ///    <para>Determines if the client startup script is registered with the
    ///       page.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public bool IsStartupScriptRegistered(string key) {
        return (_registeredClientStartupScripts != null
                && _registeredClientStartupScripts.Contains(key));
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.IsClientScriptBlockRegistered"]/*' />
    /// <devdoc>
    ///    <para>Determines if the client script block is registered with the page.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public bool IsClientScriptBlockRegistered(string key) {
        return (_registeredClientScriptBlocks != null
                && _registeredClientScriptBlocks.Contains(key));
    }

    private void RegisterScriptBlock(string key, string script, ref IDictionary scriptBlocks) {
        if (scriptBlocks == null)
            scriptBlocks = new HybridDictionary();

        if (!scriptBlocks.Contains(key))
            scriptBlocks.Add(key, script);
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.RegisterClientScriptBlock"]/*' />
    /// <devdoc>
    ///    <para> Prevents controls from sending duplicate blocks of
    ///       client-side script to the client. Any script blocks with the same <paramref name="key"/> parameter
    ///       values are considered duplicates.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual void RegisterClientScriptBlock(string key, string script) {
        RegisterScriptBlock(key, script, ref _registeredClientScriptBlocks);
    }

    internal string GetClientScriptFileIncludeScript(string language, string fileName) {
        string location = Util.GetScriptLocation(Context);
        return String.Format(IncludeScriptFormat, language, location, fileName);
    }

    internal void RegisterClientScriptFileInternal(string key, string language, string fileName) {

        // prepare script include
        string location = Util.GetScriptLocation(Context);

        RegisterClientScriptFileInternal(key, language, location, fileName);
    }

    internal void RegisterClientScriptFileInternal(string key, string language, string location, string fileName) {

        string includeScript = String.Format(IncludeScriptFormat, language, location, fileName);

        RegisterClientScriptBlock(key, includeScript);

    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.RegisterStartupScript"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Allows controls to keep duplicate blocks of client-side script code from
    ///       being sent to the client. Any script blocks with the same <paramref name="key"/> parameter
    ///       value are considered duplicates.
    ///    </para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual void RegisterStartupScript(string key, string script) {
        RegisterScriptBlock(key, script, ref _registeredClientStartupScripts);
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.RegisterOnSubmitStatement"]/*' />
    /// <devdoc>
    ///    <para>Allows a control to access a the client
    ///    <see langword='onsubmit'/> event.
    ///       The script should be a function call to client code registered elsewhere.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public void RegisterOnSubmitStatement(string key, string script) {
        if (_registeredOnSubmitStatements == null)
            _registeredOnSubmitStatements = new HybridDictionary();

        if (!_registeredOnSubmitStatements.Contains(key))
            _registeredOnSubmitStatements.Add(key, script);
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.RegisterRequiresPostBack"]/*' />
    /// <devdoc>
    ///    <para>Registers a control as one that requires postback handling.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public void RegisterRequiresPostBack(Control control) {
        if (_registeredControlsThatRequirePostBack == null)
            _registeredControlsThatRequirePostBack = new ArrayList();

        _registeredControlsThatRequirePostBack.Add(control.UniqueID);
    }

    /*
     * This method will process the data posted back in the request header.
     * The collection of posted data keys consists of three types :
     * 1.  Fully qualified ids of controls.  The associated value is the data
     *     posted back by the browser for an intrinsic html element.
     * 2.  Fully qualified ids of controls that have explicitly registered that
     *     they want to be notified on postback.  This is required for intrinsic
     *     html elements that for some states do not postback data ( e.g. a select
     *     when there is no selection, a checkbox or radiobutton that is not checked )
     *     The associated value for these keys is not relevant.
     * 3.  Framework generated hidden fields for event processing, whose values are
     *     set by client-side script prior to postback.
     *
     * This method handles the process of notifying the relevant controls that a postback
     * has occurred, via the IPostBackDataHandler interface.
     *
     * It can potentially be called twice: before and after LoadControl.  This is to
     * handle the case where users programmatically add controls in Page_Load (ASURT 29045).
     */
    private void ProcessPostData(NameValueCollection postData, bool fBeforeLoad) {
        if (_changedPostDataConsumers == null)
            _changedPostDataConsumers = new ArrayList();

        // identify controls that have postback data
        if (postData != null) {
            foreach (string postKey in postData) {
                if (postKey != null) {
                    // Ignore system post fields
                    if (s_systemPostFields.Contains(postKey))
                        continue;

                    Control ctrl = FindControl(postKey);
                    if (ctrl == null) {
                        if (fBeforeLoad) {
                            // It was not found, so keep track of it for the post load attempt
                            if (_leftoverPostData == null)
                                _leftoverPostData = new NameValueCollection();
                            _leftoverPostData.Add(postKey, null);
                        }
                        continue;
                    }

                    // Ignore controls that are not IPostBackDataHandler (see ASURT 13581)
                    if (!(ctrl is IPostBackDataHandler)) {

                        // If it's a IPostBackEventHandler (which doesn't implement IPostBackDataHandler),
                        // register it (ASURT 39040)
                        if (ctrl is IPostBackEventHandler)
                            RegisterRequiresRaiseEvent((IPostBackEventHandler)ctrl);

                        continue;
                    }

                    IPostBackDataHandler consumer = (IPostBackDataHandler)ctrl;

                    bool changed = consumer.LoadPostData(postKey, _requestValueCollection);
                    if (changed)
                        _changedPostDataConsumers.Add(consumer);

                    // ensure controls are only notified of postback once
                    if (_controlsRequiringPostBack != null)
                        _controlsRequiringPostBack.Remove(postKey);
                }
            }
        }

        // Keep track of the leftover for the post-load attempt
        ArrayList leftOverControlsRequiringPostBack = null;

        // process controls that explicitly registered to be notified of postback
        if (_controlsRequiringPostBack != null) {
            foreach (string controlID in _controlsRequiringPostBack) {
                Control c = FindControl(controlID);

                if (c != null) {
                    IPostBackDataHandler consumer = c as IPostBackDataHandler;

                    // Give a helpful error if the control is not a IPostBackDataHandler (ASURT 128532)
                    if (consumer == null) {
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Postback_ctrl_not_found, controlID));
                    }

                    bool changed = consumer.LoadPostData(controlID, _requestValueCollection);
                    if (changed)
                        _changedPostDataConsumers.Add(consumer);
                }
                else {
                    Debug.Assert(fBeforeLoad, "Control '" + controlID + "' requires postback, but could not be found");
                    if (fBeforeLoad) {
                        if (leftOverControlsRequiringPostBack == null)
                            leftOverControlsRequiringPostBack = new ArrayList();
                        leftOverControlsRequiringPostBack.Add(controlID);
                    }
                }
            }

            _controlsRequiringPostBack = leftOverControlsRequiringPostBack;
        }

    }

    /*
     * This method will raise change events for those controls that indicated
     * during PostProcessData that their data has changed.
     */
    internal void RaiseChangedEvents() {
        if (_changedPostDataConsumers != null) {
            // fire change notifications for those controls that changed as a result of postback
            for (int i=0; i < _changedPostDataConsumers.Count; i++) {
                IPostBackDataHandler changedPostDataConsumer = (IPostBackDataHandler)_changedPostDataConsumers[i];

                // Make sure the IPostBackDataHandler is still in the tree (ASURT 82495)
                Control c = changedPostDataConsumer as Control;
                if (c != null && !c.IsDescendentOf(this))
                    continue;

                changedPostDataConsumer.RaisePostDataChangedEvent();
            }
        }
    }

    private void RaisePostBackEvent(NameValueCollection postData) {

        // first check if there is a register control needing the postback event
        // if we don't have one of those, fall back to the hidden field
        // Note: this must happen before we look at postData[postEventArgumentID] (ASURT 50106)
        if (_registeredControlThatRequireRaiseEvent != null) {
            RaisePostBackEvent(_registeredControlThatRequireRaiseEvent, null);
        }
        else {
            string eventSource = postData[postEventSourceID];
            if (eventSource != null && eventSource.Length > 0) {
                Control sourceControl = FindControl(eventSource);

                if (sourceControl != null && sourceControl is IPostBackEventHandler) {
                    string eventArgument = postData[postEventArgumentID];
                    RaisePostBackEvent(((IPostBackEventHandler)sourceControl), eventArgument);
                }
            }
            else {
                Validate();
            }
        }
    }

    // Overridable method that just calls RaisePostBackEvent on controls (ASURT 48154)
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.RaisePostBackEvent"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void RaisePostBackEvent(IPostBackEventHandler sourceControl, string eventArgument) {
        sourceControl.RaisePostBackEvent(eventArgument);
    }

    // REVIEW: @WFCCONTROLSPLIT: this method was internal.  Investigate what it should be.
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.RegisterRequiresRaiseEvent"]/*' />
    /// <devdoc>
    ///    <para>Registers a control as requiring an event to be raised when it is processed
    ///       on the page.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual void RegisterRequiresRaiseEvent(IPostBackEventHandler control) {
        Debug.Assert(_registeredControlThatRequireRaiseEvent == null, "_registeredControlThatRequireRaiseEvent == null");
        _registeredControlThatRequireRaiseEvent = control;
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.IsValid"]/*' />
    /// <devdoc>
    ///    <para> Indicates whether page validation succeeded.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public bool IsValid {
        get {
            if (!_validated)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.IsValid_Cant_Be_Called));

            if (_validators != null) {
                ValidatorCollection vc = Validators;
                int count = vc.Count;
                for (int i = 0; i < count; i++) {
                    if (!vc[i].IsValid) {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Validators"]/*' />
    /// <devdoc>
    ///    <para>Gets a collection of all validation controls contained on the requested page.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public ValidatorCollection Validators {
        get {
            if (_validators == null) {
                _validators = new ValidatorCollection();
            }
            return _validators;
        }
    }

    /*
     * Map virtual path (absolute or relative) to physical path
     */
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.MapPath"]/*' />
    /// <devdoc>
    ///    <para>Assigns a virtual path, either absolute or relative, to a physical path.</para>
    /// </devdoc>
    public string MapPath(string virtualPath) {
        return _request.MapPath(virtualPath);
    }

    /*
     * The following members should only be set by derived class through codegen.
     * REVIEW: hide them from the user if possible
     */

    static char[] s_varySeparator = new char[] {';'};

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.InitOutputCache"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    ///    Note: this methods needs to be virtual because the Mobile control team
    ///    overrides it (ASURT 66157)
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected virtual void InitOutputCache(int duration, string varyByHeader, string varyByCustom,
        OutputCacheLocation location, string varyByParam) {

        HttpCachePolicy     cache = Response.Cache;
        HttpCacheability    cacheability;

        switch (location) {
            case OutputCacheLocation.Any:
                cacheability = HttpCacheability.Public;
                break;

            case OutputCacheLocation.Server:
                cacheability = HttpCacheability.ServerAndNoCache;
                break;

            case OutputCacheLocation.ServerAndClient:
                cacheability = HttpCacheability.ServerAndPrivate;
                break;

            case OutputCacheLocation.Client:
                cacheability = HttpCacheability.Private;
                break;

            case OutputCacheLocation.Downstream:
                cacheability = HttpCacheability.Public;
                cache.SetNoServerCaching();
                break;

            case OutputCacheLocation.None:
                cacheability = HttpCacheability.NoCache;
                break;

            default:
                throw new ArgumentOutOfRangeException("location");
        }

        cache.SetCacheability(cacheability);

        if (location != OutputCacheLocation.None) {
            cache.SetExpires(Context.Timestamp.AddSeconds(duration));
            cache.SetMaxAge(new TimeSpan(0, 0, duration));
            cache.SetValidUntilExpires(true);
            cache.SetLastModified(Context.Timestamp);

            //
            // A client cache'd item won't be cached on
            // the server or a proxy, so it doesn't need
            // a Varies header.
            //
            if (location != OutputCacheLocation.Client) {
                if (varyByHeader != null) {
                    string[] a = varyByHeader.Split(s_varySeparator);
                    foreach (string s in a) {
                        cache.VaryByHeaders[s.Trim()] = true;
                    }
                }

                //
                // Only items cached on the server need VaryByCustom and
                // VaryByParam
                //
                if (location != OutputCacheLocation.Downstream) {
                    if (varyByCustom != null) {
                        cache.SetVaryByCustom(varyByCustom);
                    }

                    if (varyByParam == null || varyByParam.Length == 0) {
                        cache.VaryByParams.IgnoreParams = true;
                    }
                    else {
                        string[] a = varyByParam.Split(s_varySeparator);
                        foreach (string s in a) {
                            cache.VaryByParams[s.Trim()] = true;
                        }
                    }
                }
            }
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.FileDependencies"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected ArrayList FileDependencies {
        set { Response.AddFileDependencies(value); }
    }
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Buffer"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected bool Buffer {
        set { Response.BufferOutput = value; }
    }
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.ContentType"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected string ContentType {
        set { Response.ContentType = value; }
    }
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.CodePage"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected int CodePage {
        set { Response.ContentEncoding = Encoding.GetEncoding(value); }
    }
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.ResponseEncoding"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected string ResponseEncoding {
        set { Response.ContentEncoding = Encoding.GetEncoding(value); }
    }
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Culture"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected string Culture {
        set { Thread.CurrentThread.CurrentCulture = HttpServerUtility.CreateReadOnlyCultureInfo(value); }
    }
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.LCID"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected int LCID {
        set { Thread.CurrentThread.CurrentCulture = HttpServerUtility.CreateReadOnlyCultureInfo(value); }
    }
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.UICulture"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected string UICulture {
        set { Thread.CurrentThread.CurrentUICulture = HttpServerUtility.CreateReadOnlyCultureInfo(value); }
    }
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.TransactionMode"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected int TransactionMode {
        set { _transactionMode = value; }
    }
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.AspCompatMode"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected bool AspCompatMode {
        set { _aspCompatMode = value; }
    }
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.TraceEnabled"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected bool TraceEnabled {
        set { Trace.IsEnabled = value; }
    }
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.TraceModeValue"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected TraceMode TraceModeValue {
        set { Trace.TraceMode = value; }
    }
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.EnableViewStateMac"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected bool EnableViewStateMac {
        get { return _enableViewStateMac; }
        set { _enableViewStateMac = value; }
    }
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.SmartNavigation"]/*' />
    /// <devdoc>
    ///    <para>Is the SmartNavigation feature in use</para>
    /// </devdoc>
    [
    Browsable(false)
    ]
    public bool SmartNavigation {
        get {
            // If it's not supported or asked for, return false
            if (_smartNavSupport == SmartNavigationSupport.NotDesiredOrSupported)
                return false;

            // Otherwise, determine what the browser supports
            if (_smartNavSupport == SmartNavigationSupport.Desired) {

                HttpContext currentContext = HttpContext.Current;
                // Make sure that there is a current context
                if (currentContext == null) {
                    // If there isn't one, assume SmartNavigation is off
                    return false;
                }

                HttpBrowserCapabilities browser = currentContext.Request.Browser;

                // If it's not IE5.5+, we don't support Smart Navigation
                if (browser.Browser.ToLower(CultureInfo.InvariantCulture) != "ie" || browser.MajorVersion < 5 ||
                        (browser.MinorVersion < 0.5 && browser.MajorVersion == 5)) {
                    _smartNavSupport = SmartNavigationSupport.NotDesiredOrSupported;
                }
                else
                    _smartNavSupport = SmartNavigationSupport.IE55OrNewer;
            }

            return (_smartNavSupport != SmartNavigationSupport.NotDesiredOrSupported);
        }
        set {
            if (value)
                _smartNavSupport = SmartNavigationSupport.Desired;
            else
                _smartNavSupport = SmartNavigationSupport.NotDesiredOrSupported;
        }
    }
    internal bool IsTransacted { get { return (_transactionMode != 0 /*TransactionOption.Disabled*/); } }
    internal bool IsInAspCompatMode { get { return _aspCompatMode; } }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.ProcessRequest"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public void ProcessRequest(HttpContext context) {
        SetIntrinsics(context);
        ProcessRequest();
    }

    //
    // ProcessRequestXXX methods are there because
    // transacted pages require some code (ProcessRequestMain)
    // to run inside the transaction and some outside
    //

    private void ProcessRequest() {
        // save culture
        Thread currentThread = Thread.CurrentThread;
        CultureInfo prevCulture = currentThread.CurrentCulture;
        CultureInfo prevUICulture = currentThread.CurrentUICulture;
        System.Web.Util.Debug.Trace("Culture", "Before request, culture is " + prevCulture.DisplayName);
        System.Web.Util.Debug.Trace("Culture", "Before request, UI culture is " + prevUICulture.DisplayName);

        // Initialize the object and build the tree of controls.
        // This must happen *after* the intrinsics have been set.
        FrameworkInitialize();

        try {
            try {
                if (IsTransacted) {
                    ProcessRequestTransacted();
                }
                else {
                    // No transactions
                    ProcessRequestMain();
                }

                ProcessRequestEndTrace();
            }
            finally {
                ProcessRequestCleanup();

                // restore culture
                System.Web.Util.Debug.Trace("Culture", "After request, culture is " + currentThread.CurrentCulture.DisplayName);
                System.Web.Util.Debug.Trace("Culture", "After request, UI culture is " + currentThread.CurrentUICulture.DisplayName);


                // assert SecurityPermission, for ASURT #112116
                InternalSecurityPermissions.ControlThread.Assert();
                currentThread.CurrentCulture = prevCulture;

                currentThread.CurrentUICulture = prevUICulture;
                System.Web.Util.Debug.Trace("Culture", "Restored culture to " + prevCulture.DisplayName);
                System.Web.Util.Debug.Trace("Culture", "Restored UI culture to " + prevUICulture.DisplayName);
            }
        }
        catch { throw; }    // Prevent Exception Filter Security Issue (ASURT 122835)
    }

    // This must be in its own method to avoid jitting System.EnterpriseServices.dll
    // when it is not needed (ASURT 71868)
    private void ProcessRequestTransacted() {

        bool transactionAborted = false;
        TransactedCallback processRequestCallback = new TransactedCallback(ProcessRequestMain);

        // Part of the request needs to be done under transacted context
        Transactions.InvokeTransacted(processRequestCallback,
            (TransactionOption) _transactionMode, ref transactionAborted);

        // The remainder has to be done outside
        try {
            if (transactionAborted)
                OnAbortTransaction(EventArgs.Empty);
            else
                OnCommitTransaction(EventArgs.Empty);
        }
        catch (ThreadAbortException) {
            // If it's a ThreadAbortException (which commonly happens as a result of
            // a Response.Redirect call, make sure the Unload phase happens (ASURT 43980).
            UnloadRecursive(true);
        }
        catch (Exception e) {
            // Increment all of the appropriate error counters
            PerfCounters.IncrementCounter(AppPerfCounter.ERRORS_DURING_REQUEST);
            PerfCounters.IncrementCounter(AppPerfCounter.ERRORS_TOTAL);

            // If it hasn't been handled, rethrow it
            if (!HandleError(e))
                throw;
        }
    }

    private void ProcessRequestCleanup() {
        _request = null;
        _response = null;
        UnloadRecursive(true);
    }

    private void ProcessRequestEndTrace() {
        if (Context.TraceIsEnabled) {
            Trace.EndRequest();
            if (Trace.PageOutput) {
                Trace.Render(CreateHtmlTextWriter(Response.Output));

                // responses with trace should not be cached
                Response.Cache.SetCacheability(HttpCacheability.NoCache);
            }
        }
    }

    private void ProcessRequestMain() {
        try {
            // Is it a GET, POST or initial request?
            _requestValueCollection = DeterminePostBackMode();

            // we can't cache the value of IsEnabled because it could change during any phase.
            HttpContext con = Context;
            if (con.TraceIsEnabled) Trace.Write("aspx.page", "Begin Init");
            InitRecursive(null);
            if (con.TraceIsEnabled) Trace.Write("aspx.page", "End Init");

            if (IsPostBack) {
                if (con.TraceIsEnabled) Trace.Write("aspx.page", "Begin LoadViewState");
                LoadPageViewState();
                if (con.TraceIsEnabled) {
                    Trace.Write("aspx.page", "End LoadViewState");
                    Trace.Write("aspx.page", "Begin ProcessPostData");
                }
                ProcessPostData(_requestValueCollection, true /* fBeforeLoad */);
                if (con.TraceIsEnabled) Trace.Write("aspx.page", "End ProcessPostData");
            }

            LoadRecursive();

            if (IsPostBack) {
                // Try process the post data again (ASURT 29045)
                if (con.TraceIsEnabled) Trace.Write("aspx.page", "Begin ProcessPostData Second Try");
                ProcessPostData(_leftoverPostData, false /* !fBeforeLoad */);
                if (con.TraceIsEnabled) {
                    Trace.Write("aspx.page", "End ProcessPostData Second Try");
                    Trace.Write("aspx.page", "Begin Raise ChangedEvents");
                }

                RaiseChangedEvents();
                if (con.TraceIsEnabled) {
                    Trace.Write("aspx.page", "End Raise ChangedEvents");
                    Trace.Write("aspx.page", "Begin Raise PostBackEvent");
                }
                RaisePostBackEvent(_requestValueCollection);
                if (con.TraceIsEnabled) Trace.Write("aspx.page", "End Raise PostBackEvent");
            }

            if (con.TraceIsEnabled) Trace.Write("aspx.page", "Begin PreRender");
            PreRenderRecursiveInternal();

            if (con.TraceIsEnabled) {
                Trace.Write("aspx.page", "End PreRender");
                BuildProfileTree("ROOT", EnableViewState);
                Trace.Write("aspx.page", "Begin SaveViewState");
            }
            SavePageViewState();
            if (con.TraceIsEnabled) {
                Trace.Write("aspx.page", "End SaveViewState");
                Trace.Write("aspx.page", "Begin Render");
            }
            RenderControl(CreateHtmlTextWriter(Response.Output));
            if (con.TraceIsEnabled) Trace.Write("aspx.page", "End Render");
        }
        catch (ThreadAbortException) {
            // If it's a ThreadAbortException (which commonly happens as a result of
            // a Response.Redirect call, make sure the Unload phase happens (ASURT 43980).
            UnloadRecursive(true);
        }
        catch (System.Configuration.ConfigurationException) {
            throw;
        }
        catch (Exception e) {
            // Increment all of the appropriate error counters
            PerfCounters.IncrementCounter(AppPerfCounter.ERRORS_DURING_REQUEST);
            PerfCounters.IncrementCounter(AppPerfCounter.ERRORS_TOTAL);

            // If it hasn't been handled, rethrow it
            if (!HandleError(e))
                throw;
        }
    }

    internal void SetForm(HtmlForm form) {
        _form = form;
    }

    // REVIEW: consider making this public at some point
    internal HtmlForm Form { get { return _form; } }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.RegisterViewStateHandler"]/*' />
    /// <devdoc>
    ///    <para>If called, ViewState will be persisted (see ASURT 73020).</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public void RegisterViewStateHandler() {
        _needToPersistViewState = true;
    }

    internal void SavePageViewState() {

        // Don't do anything if no one cares about the view state (see ASURT 73020)
        if (!_needToPersistViewState)
            return;

        // The state is saved as an array of objects:
        // 1. The hash code string
        // 2. The state of the entire control hierarchy
        // 3. A list of controls that require postback

        Triplet allSavedState = new Triplet();
        allSavedState.First = GetTypeHashCode().ToString(NumberFormatInfo.InvariantInfo);
        allSavedState.Third = _registeredControlsThatRequirePostBack;

        if (Context.TraceIsEnabled)
            Trace.AddControlViewstateSize(UniqueID, LosFormatter.EstimateSize(allSavedState));

        allSavedState.Second = SaveViewStateRecursive();

        SavePageStateToPersistenceMedium(allSavedState);
    }

    /*
     * Override this method to persist view state to something other
     * than hidden fields (CONSIDER: we may want a switch for session too).
     * You must also override LoadStateFromPersistenceMedium().
     */
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.SavePageStateToPersistenceMedium"]/*' />
    /// <devdoc>
    ///    <para>Saves any view state information for the page. Override
    ///       this method if you want to save the page view state in anything other than a hidden field.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    protected virtual void SavePageStateToPersistenceMedium(object viewState) {
        _viewStateToPersist = viewState;
    }

    /*
     * Set the intrinsics in this page object
     */
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.SetIntrinsics"]/*' />
    /// <devdoc>
    ///    <para>Assigns the current request's context information to the page. This
    ///       includes information about the current <see langword='Cache'/>,
    ///    <see langword='Application'/>, <see langword='Request'/> and
    ///    <see langword='Response'/> objects.</para>
    /// </devdoc>
    private void SetIntrinsics(HttpContext context) {
        _context = context;
        _request = context.Request;
        _response = context.Response;
        _application = context.Application;
        _cache = context.Cache;

        // Synchronize the ClientTarget
        if (_clientTarget != null && _clientTarget.Length > 0) {
            _request.ClientTarget = _clientTarget;
        }

        // Hook up any automatic handler we may find (e.g. Page_Load)
        HookUpAutomaticHandlers();
    }

    // ASP Compat helpers

    private AspCompatApplicationStep _aspCompatStep;

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.AspCompatBeginProcessRequest"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected IAsyncResult AspCompatBeginProcessRequest(HttpContext context, AsyncCallback cb, Object extraData) {
        SetIntrinsics(context);
        _aspCompatStep = new AspCompatApplicationStep(context, new AspCompatCallback(ProcessRequest));
        return _aspCompatStep.BeginAspCompatExecution(cb, extraData);
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.AspCompatEndProcessRequest"]/*' />
    /// <internalonly/>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected void AspCompatEndProcessRequest(IAsyncResult result) {
        _aspCompatStep.EndAspCompatExecution(result);
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.Validate"]/*' />
    /// <devdoc>
    ///    <para>Instructs any validation controls included on the page to validate their
    ///       assigned information for the incoming page request.</para>
    /// </devdoc>
    public virtual void Validate() {
        _validated = true;
        if (_validators != null) {
            for (int i = 0; i < Validators.Count; i++) {
                Validators[i].Validate();
            }
        }
    }

    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.VerifyRenderingInServerForm"]/*' />
    /// <devdoc>
    ///    <para>Throws an exception if it is runtime and we are not currently rendering the form runat=server tag.
    ///          Most controls that post back or that use client script require to be in this tag to function, so
    ///          they can call this during rendering. At design time this will do nothing.</para>
    ///    <para>Custom Control creators should call this during render if they render any sort of input tag, if they call
    ///          GetPostBackEventReference, or if they emit client script. A composite control does not need to make this
    ///          call.</para>
    ///    <para>This method should not be overriden unless creating an alternative page framework.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public virtual void VerifyRenderingInServerForm(Control control) {
        // We only want to make this check if we are definitely at runtime
        if (Context == null || (Site != null && Site.DesignMode)) {
            return;
        }

        if (!_inOnFormRender) {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.ControlRenderedOutsideServerForm, control.ClientID, control.GetType().Name));
        }
    }

#if DBG
    // Temporary debugging method
    /// <include file='doc\Page.uex' path='docs/doc[@for="Page.WalkViewState"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    public virtual void WalkViewState(object viewState, Control control, int indentLevel) {
        if (viewState == null) {
            return;
        }
        object [] viewStateArray = (object [])viewState;
        object controlViewState = viewStateArray[0];
        IDictionary childViewState = (IDictionary)viewStateArray[1];

        string prefix = "";
        for (int i=0; i < indentLevel; i++) {
            prefix = prefix + "  ";
        }

        if (controlViewState == null) {
            System.Web.Util.Debug.Trace("tpeters", prefix + "ObjViewState: null");
        }
        else {
            System.Web.Util.Debug.Trace("tpeters", prefix + "ObjViewState: " + controlViewState.ToString());
        }

        if (childViewState != null) {
            for (IDictionaryEnumerator e = childViewState.GetEnumerator(); e.MoveNext();) {
                int index = (int) e.Key;
                object value = e.Value;

                if (control == null) {
                    System.Web.Util.Debug.Trace("tpeters", prefix + "Control index: " + index.ToString());
                    WalkViewState(value, null, indentLevel + 1);
                }
                else {

                    string s = "None";
                    bool recurse = false;
                    if (control.HasControls()) {
                        if (index < control.Controls.Count) {
                            s = control.Controls[index].ToString();
                            recurse = true;
                        }
                        else {
                            s = "out of range";
                        }
                    }
                    System.Web.Util.Debug.Trace("tpeters", prefix + "Control index: " + index.ToString() + " control: " + s);
                    if (recurse) {
                        WalkViewState(value, control.Controls[index], indentLevel + 1);
                    }
                }
            }
        }
    }
#endif // DBG
}

// Used to define the list of valid values of the location attribute of the
// OutputCache directive.
/// <include file='doc\Page.uex' path='docs/doc[@for="OutputCacheLocation"]/*' />
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
public enum OutputCacheLocation {
    /// <include file='doc\Page.uex' path='docs/doc[@for="OutputCacheLocation.Any"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    Any,
    /// <include file='doc\Page.uex' path='docs/doc[@for="OutputCacheLocation.Client"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    Client,
    /// <include file='doc\Page.uex' path='docs/doc[@for="OutputCacheLocation.Downstream"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    Downstream,
    /// <include file='doc\Page.uex' path='docs/doc[@for="OutputCacheLocation.Server"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    Server,
    /// <include file='doc\Page.uex' path='docs/doc[@for="OutputCacheLocation.None"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    None,
    /// <include file='doc\Page.uex' path='docs/doc[@for="OutputCacheLocation.ServerAndClient"]/*' />
    ServerAndClient
}

internal enum SmartNavigationSupport {
    NotDesiredOrSupported=0,   // The Page does not ask for SmartNav, or the browser doesn't support it
    Desired,        // The Page asks for SmartNavigation, but we have not checked browser support
    IE55OrNewer     // SmartNavigation supported by IE5.5 or newer browsers
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\propertymapper.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyMapper.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * PropertyMapper.cs
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.UI {
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Reflection;

    internal sealed class PropertyMapper {
        private const char PERSIST_CHAR = '-';
        private const char OM_CHAR = '.';
        private const string STR_OM_CHAR = ".";


        /*
         * Maps persisted attribute names to the object model equivalents.
         * This class should not be instantiated by itself.
         */
        private PropertyMapper() {
        }

        /*
         * Returns the PropertyInfo or FieldInfo corresponding to the
         * specified property name.
         */
        internal static MemberInfo GetMemberInfo(Type ctrlType, string name, out string nameForCodeGen) {
            Type currentType = ctrlType;
            PropertyInfo propInfo = null;
            FieldInfo fieldInfo = null;

            string mappedName = MapNameToPropertyName(ctrlType,name);
            nameForCodeGen = null;

            int startIndex = 0;
            while (startIndex < mappedName.Length) {   // parse thru dots of object model to locate PropertyInfo
                string propName;
                int index = mappedName.IndexOf(OM_CHAR, startIndex);

                if (index < 0) {
                    propName = mappedName.Substring(startIndex);
                    startIndex = mappedName.Length;
                }
                else {
                    propName = mappedName.Substring(startIndex, index - startIndex);
                    startIndex = index + 1;
                }

                propInfo = currentType.GetProperty(propName,
                                                   BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.IgnoreCase);

                if (propInfo == null) {   // could not find a public property, look for a public field
                    fieldInfo = currentType.GetField(propName,
                                                     BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.IgnoreCase);
                    if (fieldInfo == null) {
                        nameForCodeGen = null;
                        break;
                    }
                }

                propName = null;
                if (propInfo != null) {   // found a public property
                    currentType = propInfo.PropertyType;
                    propName = propInfo.Name;
                }
                else {   // found a public field
                    currentType = fieldInfo.FieldType;
                    propName = fieldInfo.Name;
                }

                // Throw if the type of not CLS-compliant (ASURT 83438)
                CLSCompliantAttribute clsCompliant = null;
                object[] attrs = currentType.GetCustomAttributes(typeof(CLSCompliantAttribute), /*inherit*/ true);
                if ((attrs != null) && (attrs.Length == 1)) {
                    clsCompliant = (CLSCompliantAttribute)attrs[0];
                    if (!clsCompliant.IsCompliant) {
                        throw new HttpException(HttpRuntime.FormatResourceString(
                            SR.Property_Not_ClsCompliant, name, ctrlType.FullName, currentType.FullName));
                    }
                }

                if (propName != null) {
                    if (nameForCodeGen == null)
                        nameForCodeGen = propName;
                    else
                        nameForCodeGen += STR_OM_CHAR + propName;
                }
            }

            if (propInfo != null)
                return propInfo;
            else
                return fieldInfo;
        }

        /*
         * Maps the specified persisted name to its object model equivalent.
         * The convention is to map all dashes to dots.
         * For example :  Font-Size maps to Font.Size
         *                HeaderStyle-Font-Name maps to HeaderStyle.Font.Name
         */
        internal static string MapNameToPropertyName(Type ctrlType, string attrName) {
            return attrName.Replace(PERSIST_CHAR,OM_CHAR);
        }

        /*
         * Walks the object model using the mapped property name to set the
         * value of an instance's property.
         */
        internal static void SetMappedPropertyValue(object obj, string mappedName, object value) {
            MethodInfo methodInfo = null;
            object currentObject = obj;
            Type currentType = obj.GetType();
            PropertyInfo propInfo;
            FieldInfo fieldInfo = null;
            string propName;
            int index;
            int startIndex = 0;

            // step through the dots of the object model to extract the PropertyInfo
            // and object on which the property will be set
            while (startIndex < mappedName.Length) {
                index = mappedName.IndexOf(OM_CHAR, startIndex);

                if (index < 0) {
                    propName = mappedName.Substring(startIndex);
                    startIndex = mappedName.Length;
                }
                else {
                    propName = mappedName.Substring(startIndex, index - startIndex);
                    startIndex = index + 1;
                }

                propInfo = currentType.GetProperty(propName);

                if (propInfo == null) {
                    fieldInfo = currentType.GetField(propName);

                    if (fieldInfo == null)
                        break;
                }

                methodInfo = null;
                if (propInfo != null) {
                    currentType = propInfo.PropertyType;

                    if (index < 0) {
                        methodInfo = propInfo.GetSetMethod();
                    }
                    else {
                        methodInfo = propInfo.GetGetMethod();
                        currentObject = Util.InvokeMethod(methodInfo,
                                                          currentObject, null);
                    }
                }
                else {
                    currentType = fieldInfo.FieldType;

                    if (index >= 0)
                        currentObject = fieldInfo.GetValue(currentObject);
                }
            }

            if (methodInfo != null) {
                object[] parameters = new object[] { value};
                Util.InvokeMethod(methodInfo, currentObject, parameters);
            }
            else if (fieldInfo != null) {
                fieldInfo.SetValue(currentObject, value);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\rootbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="RootBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Implements the root builder
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web.UI {
    using System.Runtime.InteropServices;

    using System;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Web;
    using System.Web.Util;
    using System.Security.Permissions;

    /// <include file='doc\RootBuilder.uex' path='docs/doc[@for="RootBuilder"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class RootBuilder : TemplateBuilder {
        private MainTagNameToTypeMapper _typeMapper;

        /// <include file='doc\RootBuilder.uex' path='docs/doc[@for="RootBuilder.RootBuilder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public RootBuilder(TemplateParser parser) {
            // Initialize the type mapper
            _typeMapper = new MainTagNameToTypeMapper();

            // Map asp: prefix to System.Web.UI.WebControls
            _typeMapper.AddSubMapper("asp", "System.Web.UI.WebControls", GetType().Assembly);

            // Register the <object> tag
            _typeMapper.RegisterTag("object", typeof(System.Web.UI.ObjectTag));
        }

        /// <include file='doc\RootBuilder.uex' path='docs/doc[@for="RootBuilder.GetChildControlType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Type GetChildControlType(string tagName,
                                                 IDictionary attribs) {
            // Is there a type to handle this control
            Type type = _typeMapper.GetControlType(tagName, attribs,
                                                   true /*fAllowHtmlTags*/);

            return type;
        }

        /*
         * Register a new prefix for tags
         */
        internal void RegisterTagPrefix(string prefix, string ns, Assembly assembly) {
            _typeMapper.AddSubMapper(prefix, ns, assembly);
        }

        /*
         * Register a tag to type mapping
         */
        internal void RegisterTag(string tagName, Type type) {
            _typeMapper.RegisterTag(tagName, type);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\simplehandlerfactory.cs ===
//------------------------------------------------------------------------------
// <copyright file="SimpleHandlerFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Handler Factory implementation for ASP.NET files
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI {

using System;

/*
 * Handler Factory implementation for ASP.NET files
 */
internal class SimpleHandlerFactory : IHttpHandlerFactory {
    internal SimpleHandlerFactory() {
    }

    public virtual IHttpHandler GetHandler(HttpContext context, string requestType,
        string virtualPath, string path) {

        // Parse and (possibly) compile the file into a type
        Type t = WebHandlerParser.GetCompiledType(virtualPath, path, context);

        // Make sure the type has the correct base class (ASURT 123677)
        Util.CheckAssignableType(typeof(IHttpHandler), t);

        // Create an instance of the type
        Object obj = HttpRuntime.CreateNonPublicInstance(t);

        return(IHttpHandler) obj;
    }

    public virtual void ReleaseHandler(IHttpHandler handler) {
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\persistencetypeattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="PersistenceTypeAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {
    using System.Runtime.InteropServices;

    using System;
    using System.ComponentModel;
    using System.Security.Permissions;

    /// <include file='doc\PersistenceTypeAttribute.uex' path='docs/doc[@for="PersistenceModeAttribute"]/*' />
    /// <devdoc>
    ///     LiteralContentAttribute indicates whether the contents within a tag representing
    ///     a custom/web control should be treated by Trident as a "literal/text" content.
    ///     Web controls supporting complex properties (like Templates, etc.) typically
    ///     mark themselves as "literals", thereby letting the designer infra-structure
    ///     and Trident deal with the persistence of those attributes.
    ///
    ///     If LiteralContentAttribute.No is present or no LiteralContentAttribute marking
    ///     exists, then the tag corresponding to the web control is not treated as a literal
    ///     content tag.
    ///     If LiteralContentAttribute.Yes is present, then the tag corresponding to the web
    ///     control is treated as a literal content tag.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class PersistenceModeAttribute : Attribute {

        /// <include file='doc\PersistenceTypeAttribute.uex' path='docs/doc[@for="PersistenceModeAttribute.Attribute"]/*' />
        /// <devdoc>
        ///     This marks a property or event as persistable in the HTML tag as an attribute.
        /// </devdoc>
        public static readonly PersistenceModeAttribute Attribute = new PersistenceModeAttribute(PersistenceMode.Attribute);

        /// <include file='doc\PersistenceTypeAttribute.uex' path='docs/doc[@for="PersistenceModeAttribute.InnerProperty"]/*' />
        /// <devdoc>
        ///     This marks a property or event as persistable within the HTML tag as a nested tag.
        /// </devdoc>
        public static readonly PersistenceModeAttribute InnerProperty = new PersistenceModeAttribute(PersistenceMode.InnerProperty);

        /// <include file='doc\PersistenceTypeAttribute.uex' path='docs/doc[@for="PersistenceModeAttribute.InnerDefaultProperty"]/*' />
        /// <devdoc>
        ///     This marks a property or event as persistable within the HTML tag as a child.
        /// </devdoc>
        public static readonly PersistenceModeAttribute InnerDefaultProperty = new PersistenceModeAttribute(PersistenceMode.InnerDefaultProperty);

        /// <include file='doc\PersistenceTypeAttribute.uex' path='docs/doc[@for="PersistenceModeAttribute.EncodedInnerDefaultProperty"]/*' />
        /// <devdoc>
        ///     This marks a property or event as persistable within the HTML tag as a child.
        /// </devdoc>
        public static readonly PersistenceModeAttribute EncodedInnerDefaultProperty = new PersistenceModeAttribute(PersistenceMode.EncodedInnerDefaultProperty);

    
        /// <include file='doc\PersistenceTypeAttribute.uex' path='docs/doc[@for="PersistenceModeAttribute.Default"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static readonly PersistenceModeAttribute Default = Attribute;

        private PersistenceMode mode = PersistenceMode.Attribute;


        /// <include file='doc\PersistenceTypeAttribute.uex' path='docs/doc[@for="PersistenceModeAttribute.PersistenceModeAttribute"]/*' />
        /// <internalonly/>
        public PersistenceModeAttribute(PersistenceMode mode) {
            if (mode < PersistenceMode.Attribute || mode > PersistenceMode.EncodedInnerDefaultProperty) {
                throw new ArgumentOutOfRangeException("mode");
            }
            this.mode = mode;
        }


        /// <include file='doc\PersistenceTypeAttribute.uex' path='docs/doc[@for="PersistenceModeAttribute.Mode"]/*' />
        /// <devdoc>
        /// </devdoc>
        public PersistenceMode Mode {
            get {
                return mode;
            }
        }

        /// <include file='doc\PersistenceTypeAttribute.uex' path='docs/doc[@for="PersistenceModeAttribute.GetHashCode"]/*' />
        /// <internalonly/>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\PersistenceTypeAttribute.uex' path='docs/doc[@for="PersistenceModeAttribute.Equals"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }
            if ((obj != null) && (obj is PersistenceModeAttribute)) {
                return((PersistenceModeAttribute)obj).Mode == mode;
            }

            return false;
        }

        /// <include file='doc\PersistenceTypeAttribute.uex' path='docs/doc[@for="PersistenceModeAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override bool IsDefaultAttribute() {
            return this.Equals(Default);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\propertyconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// PropertyConverter.cs
//

namespace System.Web.UI {
    using System.Runtime.Serialization.Formatters;
    using System;
    using System.Reflection;
    using System.Globalization;
    using System.ComponentModel;
    using Debug=System.Diagnostics.Debug;
    using System.Security.Permissions;

    /// <include file='doc\PropertyConverter.uex' path='docs/doc[@for="PropertyConverter"]/*' />
    /// <devdoc>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class PropertyConverter {

        static Type[] s_parseMethodTypes;
        static Type[] s_parseMethodTypesWithSOP;
        static PropertyConverter() {

            // Precompute the types of the params of the static Parse methods
            s_parseMethodTypes = new Type[1];
            s_parseMethodTypes[0] = typeof(string);

            s_parseMethodTypesWithSOP = new Type[2];
            s_parseMethodTypesWithSOP[0] = typeof(string);
            s_parseMethodTypesWithSOP[1] = typeof(IServiceProvider);
        }

        /*
         * Contains helpers to convert properties from strings to their types and vice versa.
         * This class should not be directly instantiated.
         */
        private PropertyConverter() {
        }

        /*
         * Converts a persisted enumeration value into its numeric value.
         * Hyphen characters in the persisted format are converted to underscores.
         */
        /// <include file='doc\PropertyConverter.uex' path='docs/doc[@for="PropertyConverter.EnumFromString"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static object EnumFromString(Type enumType, string value) {
            try {
                return Enum.Parse(enumType, value, true);
            }
            catch (Exception) {
                return null;
            }
        }

        /*
         * Converts a numeric enumerated value into its persisted form, which is the
         * code name with underscores replaced by hyphens.
         */
        /// <include file='doc\PropertyConverter.uex' path='docs/doc[@for="PropertyConverter.EnumToString"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static string EnumToString(Type enumType, object enumValue) {
            string value = Enum.Format(enumType, enumValue, "G");

            // CONSIDER: nikhilko: This is needed only for rendering purposes. Move this
            //    conversion out of here.
            return value.Replace('_','-');
        }

        /*
         * Converts the persisted string into an object using the object's
         * FromString method.
         */
        /// <include file='doc\PropertyConverter.uex' path='docs/doc[@for="PropertyConverter.ObjectFromString"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static object ObjectFromString(Type objType, MemberInfo propertyInfo, string value) {
            if (value == null)
                return null;

            // Blank valued bools don't map with FromString. Return null to allow
            // caller to interpret.
            if (objType.Equals(typeof(bool)) && value.Length == 0) {
                return null;
            }
            if (objType.IsEnum) {
                return EnumFromString(objType, value);
            }
            else if (objType.Equals(typeof(string))) {
                return value;
            }
            else {
                PropertyDescriptor pd = null;
                if (propertyInfo != null)
                    pd = TypeDescriptor.GetProperties(propertyInfo.ReflectedType)[propertyInfo.Name];
                if (pd != null) {
                    TypeConverter converter = pd.Converter;
                    if (converter != null && converter.CanConvertFrom(typeof(string))) {
                        return converter.ConvertFromInvariantString(value);
                    }
                }
            }

            // resort to Parse static method on the type

            // First try Parse(string, IServiceProvider);
            MethodInfo methodInfo = objType.GetMethod("Parse", s_parseMethodTypesWithSOP);

            object ret = null;

            if (methodInfo != null) {
                object[] parameters = new object[2];

                parameters[0] = value;
                parameters[1] = CultureInfo.InvariantCulture;
                try {
                    ret = Util.InvokeMethod(methodInfo, null, parameters);
                }
                catch {}
            }
            else {
                // Try the simpler: Parse(string);
                methodInfo = objType.GetMethod("Parse", s_parseMethodTypes);

                if (methodInfo != null) {
                    object[] parameters = new object[1];

                    parameters[0] = value;
                    try {
                        ret = Util.InvokeMethod(methodInfo, null, parameters);
                    }
                    catch {}
                }
            }

            if (ret == null) {
                // unhandled... throw an exception, so user sees an error at parse time
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Type_not_creatable_from_string,
                    objType.FullName, value, propertyInfo.Name));
            }

            return ret;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\stateitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="StateItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;
    using System.Security.Permissions;

    /*
     * The StateItem class * by the StateBag class.
     * The StateItem has an object value, a dirty flag.
     */
    /// <include file='doc\StateItem.uex' path='docs/doc[@for="StateItem"]/*' />
    /// <devdoc>
    /// <para>Represents an item that is saved in the <see cref='System.Web.UI.StateBag'/> class when view state 
    ///    information is persisted between Web requests.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class StateItem {
        private object      value;
        private bool        isDirty;

        /*
         * Constructs a StateItem with an initial value.
         */
        internal StateItem(object initialValue) {
            value = initialValue;
            isDirty = false;
        }

        /*
         * Property to indicate StateItem has been modified.
         */
        /// <include file='doc\StateItem.uex' path='docs/doc[@for="StateItem.IsDirty"]/*' />
        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Web.UI.StateItem'/> object has been modified.</para>
        /// </devdoc>
        public bool IsDirty {
            get {
                return isDirty;
            }
            set {
                isDirty = value;
            }
        }

        /*
         * Property to access the StateItem value.
         */
        /// <include file='doc\StateItem.uex' path='docs/doc[@for="StateItem.Value"]/*' />
        /// <devdoc>
        /// <para>Indicates the value of the item that is stored in the <see cref='System.Web.UI.StateBag'/> 
        /// object.</para>
        /// </devdoc>
        public object Value {
            get {
                return value;
            }
            set {
                this.value = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\statebag.cs ===
//------------------------------------------------------------------------------
// <copyright file="StateBag.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {
    using System.Text;
    using System.IO;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Reflection;
    using System.Web.Util;
    using System.Security.Permissions;

    /*
     * The StateBag class is a helper class used to manage state of properties.
     * The class stores name/value pairs as string/object and tracks modifications of
     * properties after being 'marked'.  This class is used as the primary storage
     * mechanism for all HtmlControls and WebControls.
     */
    /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag"]/*' />
    /// <devdoc>
    ///    <para>Manages the state of Web Forms control properties. This 
    ///       class stores attribute/value pairs as string/object and tracks changes to these
    ///       attributes, which are treated as properties, after the Page.Init
    ///       method is executed for a
    ///       page request. </para>
    ///    <note type="note">
    ///       Only values changed after Page.Init
    ///       has executed are persisted to the page's view state.
    ///    </note>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class StateBag : IStateManager, IDictionary {
        private IDictionary bag;
        private bool        marked;
        private bool        ignoreCase;

        /*
         * Constructs an StateBag
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.StateBag"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.StateBag'/> class.</para>
        /// </devdoc>
        public StateBag() : this(false) {
        }

        /*
         * Constructs an StateBag
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.StateBag1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.StateBag'/> class that allows stored state 
        ///    values to be case-insensitive.</para>
        /// </devdoc>
        public StateBag(bool ignoreCase) {
            marked = false;
            this.ignoreCase = ignoreCase;
            bag = CreateBag();
        }


        /*
         * Return count of number of StateItems in the bag.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.Count"]/*' />
        /// <devdoc>
        /// <para>Indicates the number of items in the <see cref='System.Web.UI.StateBag'/> object. This property is 
        ///    read-only.</para>
        /// </devdoc>
        public int Count {
            get {
                return bag.Count;
            }
        }

        /*
         * Returns a collection of keys.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.Keys"]/*' />
        /// <devdoc>
        /// <para>Indicates a collection of keys representing the items in the <see cref='System.Web.UI.StateBag'/> object. 
        ///    This property is read-only.</para>
        /// </devdoc>
        public ICollection Keys {
            get {
                return bag.Keys;
            }
        }

        /*
         * Returns a collection of values.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.Values"]/*' />
        /// <devdoc>
        /// <para>Indicates a collection of view state values in the <see cref='System.Web.UI.StateBag'/> object. 
        ///    This property is read-only.</para>
        /// </devdoc>
        public ICollection Values {
            get {
                return bag.Values;
            }
        }

        /*
         * Get or set value of a StateItem.
         * A set will automatically add a new StateItem for a
         * key which is not already in the bag.  A set to null
         * will remove the item if set before mark, otherwise
         * a null set will be saved to allow tracking of state
         * removed after mark.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.this"]/*' />
        /// <devdoc>
        ///    <para> Indicates the value of an item stored in the 
        ///    <see langword='StateBag'/> 
        ///    object. Setting this property with a key not already stored in the StateBag will
        ///    add an item to the bag. If you set this property to <see langword='null'/> before
        ///    the TrackState method is called on an item will remove it from the bag. Otherwise,
        ///    when you set this property to <see langword='null'/>
        ///    the key will be saved to allow tracking of the item's state.</para>
        /// </devdoc>
        public object this[string key] {
            get {
                if (key == null || key.Length == 0)
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Key_Cannot_Be_Null));
              
                StateItem item = bag[key] as StateItem;
                if (item != null)
                    return item.Value;
                return null;
            }
            set {
                Add(key,value);
            }
        }

        /*
         * Private implementation of IDictionary item accessor
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.IDictionary.this"]/*' />
        /// <internalonly/>
        object IDictionary.this[object key] {
            get { return this[(string) key]; }
            set { this[(string) key] = value; }
        }

        private IDictionary CreateBag() {
            return new HybridDictionary(ignoreCase);
        }

        /*
         * Add a new StateItem or update an existing StateItem in the bag.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public StateItem Add(string key,object value) {

            if (key == null || key.Length == 0)
                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Key_Cannot_Be_Null));
              
            StateItem item = bag[key] as StateItem;

            if (item == null) {
                if (value != null || marked) {
                    item = new StateItem(value);
                    bag.Add(key,item);
                }
            }
            else {
                if (value == null && !marked) {
                    bag.Remove(key);
                }
                else {
                    item.Value = value;
                }
            }
            if (item != null && marked) {
                item.IsDirty = true;
            }
            return item;
        }

        /*
         * Private implementation of IDictionary Add
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.IDictionary.Add"]/*' />
        /// <internalonly/>
        void IDictionary.Add(object key,object value) {
            Add((string) key, value);
        }

        /*
         * Clear all StateItems from the bag.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.Clear"]/*' />
        /// <devdoc>
        /// <para>Removes all controls from the <see cref='System.Web.UI.StateBag'/> object.</para>
        /// </devdoc>
        public void Clear() {
            bag.Clear();
        }

        /*
         * Get an enumerator for the StateItems.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>Returns an enumerator that iterates over the key/value pairs stored in 
        ///       the <see langword='StateBag'/>.</para>
        /// </devdoc>
        public IDictionaryEnumerator GetEnumerator() {
            return bag.GetEnumerator();
        }

        /*
         * Return the dirty flag of the state item.
         * Returns false if there is not an item for given key.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.IsItemDirty"]/*' />
        /// <devdoc>
        /// <para>Checks an item stored in the <see langword='StateBag'/> to see if it has been 
        ///    modified.</para>
        /// </devdoc>
        public bool IsItemDirty(string key) {
            StateItem item = bag[key] as StateItem;
            if (item != null)
                return item.IsDirty;

            return false;
        }

        /*
         * Return true if 'marked' and state changes are being tracked.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.IsTrackingViewState"]/*' />
        /// <devdoc>
        ///    <para>Determines if state changes in the StateBag object's store are being tracked.</para>
        /// </devdoc>
        internal bool IsTrackingViewState {
            get {
                return marked;
            }
        }

        /*
         * Restore state that was previously saved via SaveViewState.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.LoadViewState"]/*' />
        /// <devdoc>
        ///    <para>Loads the specified previously saved state information</para>
        /// </devdoc>
        internal void LoadViewState(object state) {
            if (state != null) {
                Pair p = (Pair) state;
                ArrayList changedKeys = (ArrayList) p.First;
                ArrayList changedValues = (ArrayList) p.Second;

                int keycount = changedKeys.Count;
                for (int i=0; i<keycount; i++) {
                    Add((string)changedKeys[i], changedValues[i]);
                }
            }
        }

        /*
         * Start tracking state changes after "mark".
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.TrackViewState"]/*' />
        /// <devdoc>
        ///    <para>Initiates the tracking of state changes for items stored in the 
        ///    <see langword='StateBag'/> object.</para>
        /// </devdoc>
        internal void TrackViewState() {
            marked = true;
        }

        /*
         * Remove a StateItem from the bag altogether regardless of marked.
         * Used internally by controls.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.Remove"]/*' />
        /// <devdoc>
        /// <para>Removes the specified item from the <see cref='System.Web.UI.StateBag'/> object.</para>
        /// </devdoc>
        public void Remove(string key) {
            bag.Remove(key);
        }

        /*
         * Private implementation of IDictionary Remove
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.IDictionary.Remove"]/*' />
        /// <internalonly/>
        void IDictionary.Remove(object key) {
            Remove((string) key);
        }


        /*
         * Return object containing state that has been modified since "mark".
         * Returns null if there is no modified state.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.SaveViewState"]/*' />
        /// <devdoc>
        ///    <para>Returns an object that contains all state changes for items stored in the 
        ///    <see langword='StateBag'/> object.</para>
        /// </devdoc>
        internal object SaveViewState() {
            ArrayList changedKeys = null;
            ArrayList changedValues = null;

            if (bag.Count != 0) {
                IDictionaryEnumerator e = bag.GetEnumerator();
                while (e.MoveNext()) {
                    StateItem item = (StateItem)(e.Value);
                    if (item.IsDirty) {
                        if (changedKeys == null) {
                            changedKeys = new ArrayList(5);
                            changedValues = new ArrayList(5);
                        }
                        
                        changedKeys.Add(e.Key);
                        changedValues.Add(item.Value);
                    }
                }

                if (changedKeys != null)
                    return new Pair(changedKeys, changedValues);
            }

            return null;
        }

        /*
         * Internal method for setting dirty flag on a state item.
         * Used internallly to prevent state management of certain properties.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.SetItemDirty"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public void SetItemDirty(string key,bool dirty) {
            StateItem item = bag[key] as StateItem;
            if (item != null)
                item.IsDirty = dirty;
        }


        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.IDictionary.IsFixedSize"]/*' />
        /// <internalonly/>
        bool IDictionary.IsFixedSize {
            get { return false; }
        }

        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.IDictionary.IsReadOnly"]/*' />
        /// <internalonly/>
        bool IDictionary.IsReadOnly {
            get { return false; }
        }

        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized { 
            get { return false;}
        }

        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {return this; }
        }

        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.IDictionary.Contains"]/*' />
        /// <internalonly/>
        bool IDictionary.Contains(object key) {
            return bag.Contains((string) key);
        }

        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return ((IDictionary)this).GetEnumerator();
        }

        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int index) {
            Values.CopyTo(array, index);
        }


        /*
         * Return true if tracking state changes.
         * Method of private interface, IStateManager.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.IStateManager.IsTrackingViewState"]/*' />
        /// <internalonly/>
        bool IStateManager.IsTrackingViewState {
            get {
                return IsTrackingViewState;
            }
        }

        /*
         * Load previously saved state.
         * Method of private interface, IStateManager.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.IStateManager.LoadViewState"]/*' />
        /// <internalonly/>
        void IStateManager.LoadViewState(object state) {
            LoadViewState(state);
        }

        /*
         * Start tracking state changes.
         * Method of private interface, IStateManager.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.IStateManager.TrackViewState"]/*' />
        /// <internalonly/>
        void IStateManager.TrackViewState() {
            TrackViewState();
        }

        /*
         * Return object containing state changes.
         * Method of private interface, IStateManager.
         */
        /// <include file='doc\StateBag.uex' path='docs/doc[@for="StateBag.IStateManager.SaveViewState"]/*' />
        /// <internalonly/>
        object IStateManager.SaveViewState() {
            return SaveViewState();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\simplewebhandlerparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="SimpleWebHandlerParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Implements the parser for simple web handler files
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI {

using System.Runtime.Serialization.Formatters;
using System.Text;
using System.Runtime.Serialization;

using System;
using System.Reflection;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Text.RegularExpressions;
using System.CodeDom.Compiler;
using System.Web;
using System.Web.Caching;
using System.Web.Compilation;
using System.CodeDom;
using System.Web.Util;
using Debug=System.Web.Util.Debug;
using System.Web.RegularExpressions;
using System.Globalization;
using System.Security.Permissions;

/// <include file='doc\SimpleWebHandlerParser.uex' path='docs/doc[@for="SimpleWebHandlerParser"]/*' />
/// <internalonly/>
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public abstract class SimpleWebHandlerParser {
    private readonly static Regex directiveRegex = new SimpleDirectiveRegex();

    private TextReader _reader;

    private HttpContext _context;
    private string _virtualPath;
    private string _inputFile;

    // The line number in file currently being parsed
    private int _lineNumber;

    private bool _fFoundMainDirective;

    private string _className;

    private SourceCompiler _sourceCompiler;

    private CompilerParameters _compilParams;

    private Type _compilerType;

    // The string containing the code to be compiled
    private string _sourceString;

    // The type obtained from compiling the code
    private Type _compiledType;

    // Assemblies to be linked with
    private Hashtable _linkedAssemblies;


    /// <include file='doc\SimpleWebHandlerParser.uex' path='docs/doc[@for="SimpleWebHandlerParser.SimpleWebHandlerParser"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected SimpleWebHandlerParser(HttpContext context, string virtualPath, string physicalPath) {

        // Only allowed in full trust (ASURT 124397)
        InternalSecurityPermissions.UnmanagedCode.Demand();

        _context = context;
        if (virtualPath == null)
            _virtualPath = context.Request.FilePath;
        else
            _virtualPath = virtualPath;
        
        _inputFile = physicalPath;
    }

    /*
     * Compile a web handler file into a Type.  Result is cached.
     */
    /// <include file='doc\SimpleWebHandlerParser.uex' path='docs/doc[@for="SimpleWebHandlerParser.GetCompiledTypeFromCache"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected Type GetCompiledTypeFromCache() {

        _sourceCompiler = new SourceCompiler(_context, _virtualPath);

        // First, see if it's cached
        Type t = _sourceCompiler.GetTypeFromCache();
        if (t != null)
            return t;

        CompilationLock.GetLock();

        try {
            // Try the cache again
            t = _sourceCompiler.GetTypeFromCache();
            if (t != null)
                return t;

            return GetCompiledType();
        }
        finally {
            CompilationLock.ReleaseLock();
        }
    }

    /*
     * Compile a web handler file into a Type.
     */
    private Type GetCompiledType() {
        // Create a reader on the file.
        // Generates an exception if the file can't be opened.
        _reader = Util.ReaderFromFile(_inputFile, _context, null);

        try {
            return GetCompiledTypeInternal();
        }
        finally {
            // Make sure we always close the reader
            if (_reader != null)
                _reader.Close();
        }
    }

    /*
     * Compile a web handler file into a Type.
     */
    private Type GetCompiledTypeInternal() {
        DateTime utcStart = DateTime.UtcNow;

        // Add all the assemblies specified in the config files
        AppendConfigAssemblies();

        ParseReader();

        // Compile the inline source code in the file, if any
        CompileSourceCode();

        if (_compiledType == null) {
            _compiledType = GetType(_className);

            // Even though we didn't compile anything, cache the type to avoid
            // having to reparse the file every time (ASURT 67802)
            _sourceCompiler.CacheType(_compiledType, utcStart);
        }

        if (_compiledType == null) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Could_not_create_type, _className));
        }

        return _compiledType;
    }

    /*
     * Parse the contents of the TextReader
     */
    private void ParseReader() {
        string s = _reader.ReadToEnd();

        try {
            ParseString(s);
        }
        catch (Exception e) {
            throw new HttpParseException(null, e, _inputFile, s, _lineNumber);
        }
    }

    /*
     * Parse the contents of the string
     */
    private void ParseString(string text) {
        int textPos = 0;
        Match match;
        _lineNumber = 1;

        // First, parse all the <%@ ... %> directives
        for (;;) {
            match = directiveRegex.Match(text, textPos);

            // Done with the directives?
            if (!match.Success)
                break;

            _lineNumber += Util.LineCount(text, textPos, match.Index);
            textPos = match.Index;

            // Get all the directives into a bag
            IDictionary directive = CollectionsUtil.CreateCaseInsensitiveSortedList();
            string directiveName = ProcessAttributes(match, directive);

            ProcessDirective(directiveName, directive);

            _lineNumber += Util.LineCount(text, textPos, match.Index + match.Length);
            textPos = match.Index + match.Length;
        }

        if (!_fFoundMainDirective) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Missing_directive, DefaultDirectiveName));
        }

        // skip the directive
        string remainingText = text.Substring(textPos);

        // If there is something else in the file, it needs to be compiled
        if (!Util.IsWhiteSpaceString(remainingText))
            _sourceString = remainingText;
    }

    private string ProcessAttributes(Match match, IDictionary attribs) {
        string ret = "";
        CaptureCollection attrnames = match.Groups["attrname"].Captures;
        CaptureCollection attrvalues = match.Groups["attrval"].Captures;
        CaptureCollection equalsign = null;
        equalsign = match.Groups["equal"].Captures;

        for (int i = 0; i < attrnames.Count; i++) {
            string attribName = attrnames[i].ToString();
            string attribValue = attrvalues[i].ToString();

            // Check if there is an equal sign.
            bool fHasEqual = (equalsign[i].ToString().Length > 0);

            if (attribName != null) {
                // A <%@ %> block can have two formats:
                // <%@ directive foo=1 bar=hello %>
                // <%@ foo=1 bar=hello %>
                // Check if we have the first format
                if (!fHasEqual && i==0) {
                    ret = attribName;
                    continue;
                }

                try {
                    if (attribs != null)
                        attribs.Add(attribName, attribValue);
                }
                catch (ArgumentException) {
                    throw new HttpException(
                        HttpRuntime.FormatResourceString(SR.Duplicate_attr_in_tag, attribName));
                }
            }
        }

        return ret;
    }

    /// <include file='doc\SimpleWebHandlerParser.uex' path='docs/doc[@for="SimpleWebHandlerParser.DefaultDirectiveName"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected abstract string DefaultDirectiveName { get; }

    private static void ProcessCompilationParams(IDictionary directive, CompilerParameters compilParams) {
        bool fDebug = false;
        if (Util.GetAndRemoveBooleanAttribute(directive, "debug", ref fDebug))
            compilParams.IncludeDebugInformation = fDebug;

        if (compilParams.IncludeDebugInformation &&
            !HttpRuntime.HasAspNetHostingPermission(AspNetHostingPermissionLevel.Medium)) {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Insufficient_trust_for_attribute, "debug"));
        }

        int warningLevel=0;
        if (Util.GetAndRemoveNonNegativeIntegerAttribute(directive, "warninglevel", ref warningLevel)) {
            compilParams.WarningLevel = warningLevel;
            if (warningLevel > 0)
                compilParams.TreatWarningsAsErrors = true;
        }
        
        string compilerOptions = Util.GetAndRemoveNonEmptyAttribute(
            directive, "compileroptions");
        if (compilerOptions != null) {

            // Only allow the use of compilerOptions when we have UnmanagedCode access (ASURT 73678)
            if (!HttpRuntime.HasUnmanagedPermission()) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Insufficient_trust_for_attribute, "CompilerOptions"));
            }

            compilParams.CompilerOptions = compilerOptions;
        }
    }

    /*
     * Process a <%@ %> block
     */
    private void ProcessDirective(string directiveName, IDictionary directive) {

        // Empty means default
        if (directiveName == "")
            directiveName = DefaultDirectiveName;

        // Check for the main directive
        if (string.Compare(directiveName, DefaultDirectiveName, true, CultureInfo.InvariantCulture) == 0) {

            // Make sure the main directive was not already specified
            if (_fFoundMainDirective) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Only_one_directive_allowed, DefaultDirectiveName));
            }

            _fFoundMainDirective = true;

            // Since description is a no op, just remove it if it's there
            directive.Remove("description");

            // Similarily, ignore 'codebehind' attribute (ASURT 4591)
            directive.Remove("codebehind");

            string language = Util.GetAndRemoveNonEmptyAttribute(directive, "language");

            CompilerInfo compilerInfo;

            // Get the compiler for the specified language (if any)
            if (language != null) {
                compilerInfo = CompilationConfiguration.GetCompilerInfoFromLanguage(
                    _context, language);
            }
            else {
                // Get a default from config
                compilerInfo = CompilationConfiguration.GetDefaultLanguageCompilerInfo(_context);
            }

            _compilerType = compilerInfo.CompilerType;
            _compilParams = compilerInfo.CompilParams;

            _className = Util.GetAndRemoveRequiredAttribute(directive, "class");

            if (_compilParams != null)
                ProcessCompilationParams(directive, _compilParams);
        }
        else if (string.Compare(directiveName, "assembly", true) == 0) {
            // Assembly directive

            // Remove the attributes as we get them from the dictionary
            string assemblyName = Util.GetAndRemoveNonEmptyAttribute(directive, "name");
            string src = Util.GetAndRemoveNonEmptyAttribute(directive, "src");

            if (assemblyName != null && src != null) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Attributes_mutually_exclusive, "Name", "Src"));
            }

            if (assemblyName != null) {
                AddAssemblyDependency(assemblyName);
            }
            // Is it a source file that needs to be compiled on the fly
            else if (src != null) {
                ImportSourceFile(src);
            }
            else {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Missing_attr, "name"));
            }
        }
        else {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Unknown_directive, directiveName));
        }

        // If there are some attributes left, fail
        Util.CheckUnknownDirectiveAttributes(directiveName, directive);
    }

    private void CompileSourceCode() {
        // Return if there is nothing to compile
        if (_sourceString == null)
            return;

        // Put in some context so that the file can be debugged.
        CodeLinePragma linePragma = new CodeLinePragma(_inputFile, _lineNumber);

        try {
            // Compile the string, and get a type
            _compiledType = _sourceCompiler.CompileSourceStringIntoType(_sourceString,
                _className, linePragma, _linkedAssemblies, _compilerType, _compilParams);
        }
        catch {
            // Throw a specific error if the type was not found
            if (_sourceCompiler.TypeNotFoundInAssembly) {
                throw new HttpParseException(
                    HttpRuntime.FormatResourceString(SR.Type_not_found_in_src, _className),
                    null, _inputFile, _sourceString, _lineNumber);
            }
            else {
                // Just rethrow
                throw;
            }
        }
    }

    /*
     * Compile a source file into an assembly, and import it
     */
    private void ImportSourceFile(string virtualPath) {

        // Get a full path to the source file
        string baseVirtualDir = UrlPath.GetDirectory(_virtualPath);
        string fullVirtualPath = UrlPath.Combine(baseVirtualDir, virtualPath);
        string physicalPath = _context.Request.MapPath(fullVirtualPath, null, false /*allowCrossAppMapping*/);

        // Add the source file to the list of files we depend on
        AddSourceDependency(physicalPath);

        CompilerInfo compilerInfo = CompilationConfiguration.GetCompilerInfoFromFileName(
            _context, physicalPath);

        CompilerParameters compilParams = compilerInfo.CompilParams;

        // Compile it into an assembly

        Assembly a = SourceCompiler.GetAssemblyFromSourceFile(_context, fullVirtualPath,
            null /*assemblies*/, compilerInfo.CompilerType, compilParams);

        // Add a dependency to the assembly
        AddAssemblyDependency(a);
    }

    /*
     * Add a file as a dependency for the DLL we're building
     */
    internal void AddSourceDependency(string fileName) {
        _sourceCompiler.AddSourceDependency(fileName);
    }

    /*
     * Add all the assemblies specified in the config files
     */
    private void AppendConfigAssemblies() {

        // Always add dependencies to System.Web.dll and System.dll (ASURT 78531)
        AddAssemblyDependency(typeof(Page).Assembly);
        AddAssemblyDependency(typeof(Uri).Assembly);

        // Get the set of config assemblies for our context
        IDictionary configAssemblies = CompilationConfiguration.GetAssembliesFromContext(_context);

        if (configAssemblies == null)
            return;

        // Add dependencies to all the config assemblies
        foreach (Assembly a in configAssemblies.Values)
            AddAssemblyDependency(a);

        // Also, link in the global.asax assembly
        AddAssemblyDependency(HttpApplicationFactory.ApplicationType.Assembly);
    }

    private void AddAssemblyDependency(string assemblyName) {

        // Load and keep track of the assembly
        Assembly a = Assembly.Load(assemblyName);

        AddAssemblyDependency(a);
    }

    private void AddAssemblyDependency(Assembly assembly) {

        if (_linkedAssemblies == null)
            _linkedAssemblies = new Hashtable();
        _linkedAssemblies[assembly] = null;
    }

    /*
     * Look for a type by name in the assemblies available to this page
     */
    private Type GetType(string typeName) {

        // If it contains an assembly name, just call Type.GetType (ASURT 53589)
        if (Util.TypeNameIncludesAssembly(typeName)) {
            Type t;
            try {
                t = Type.GetType(typeName, true);
            }
            catch (Exception e) {
                throw new HttpParseException(null, e, _inputFile, _sourceString, _lineNumber);
            }

            return t;
        }

        if (_linkedAssemblies == null)
            return null;

        IDictionaryEnumerator en = _linkedAssemblies.GetEnumerator();
        for (int i=0; en.MoveNext(); i++) {
            Assembly a = (Assembly) en.Key;

            Type t = a.GetType(typeName);

#if DBG
            if (t == null)
                Debug.Trace("SimpleWebHandlerParser_GetType", "Failed to find type '" + typeName + "' in assembly " + a.GetName().FullName);
            else
                Debug.Trace("SimpleWebHandlerParser_GetType", "Successfully found type '" + typeName + "' in assembly " + a.GetName().FullName);
#endif

            if (t != null)
                return t;
        }

        throw new HttpParseException(
            HttpRuntime.FormatResourceString(SR.Could_not_create_type, typeName),
            null, _inputFile, _sourceString, _lineNumber);
    }
}

/// <include file='doc\SimpleWebHandlerParser.uex' path='docs/doc[@for="WebHandlerParser"]/*' />
/// <internalonly/>
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
internal class WebHandlerParser: SimpleWebHandlerParser {

    /// <include file='doc\SimpleWebHandlerParser.uex' path='docs/doc[@for="WebHandlerParser.GetCompiledType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal static Type GetCompiledType(string virtualPath, string physicalPath, HttpContext context) {
        WebHandlerParser parser = new WebHandlerParser(context, virtualPath, physicalPath);

        return parser.GetCompiledTypeFromCache();
    }

    private WebHandlerParser(HttpContext context, string virtualPath, string physicalPath)
        : base(context, virtualPath, physicalPath) {}

    /// <include file='doc\SimpleWebHandlerParser.uex' path='docs/doc[@for="WebHandlerParser.DefaultDirectiveName"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected override string DefaultDirectiveName {
        get { return "webhandler"; }
    }
}

/// <include file='doc\SimpleWebHandlerParser.uex' path='docs/doc[@for="WebServiceParser"]/*' />
/// <internalonly/>
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public class WebServiceParser: SimpleWebHandlerParser {

    /// <include file='doc\SimpleWebHandlerParser.uex' path='docs/doc[@for="WebServiceParser.GetCompiledType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public static Type GetCompiledType(string inputFile, HttpContext context) {

        // Only allowed in full trust (ASURT 123890)
        InternalSecurityPermissions.UnmanagedCode.Demand();

        WebServiceParser parser = new WebServiceParser(context, null /*virtualPath*/, inputFile);

        return parser.GetCompiledTypeFromCache();
    }

    private WebServiceParser(HttpContext context, string virtualPath, string physicalPath)
        : base(context, virtualPath, physicalPath) {}

    /// <include file='doc\SimpleWebHandlerParser.uex' path='docs/doc[@for="WebServiceParser.DefaultDirectiveName"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected override string DefaultDirectiveName {
        get { return "webservice"; }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\tagprefixattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="TagPrefixAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI {

    using System;
    using System.ComponentModel;
    using System.Security.Permissions;

    /// <include file='doc\TagPrefixAttribute.uex' path='docs/doc[@for="TagPrefixAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple=true)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class TagPrefixAttribute : Attribute {

        private string namespaceName;
        private string tagPrefix;

        /// <include file='doc\TagPrefixAttribute.uex' path='docs/doc[@for="TagPrefixAttribute.TagPrefixAttribute"]/*' />
        public TagPrefixAttribute(string namespaceName, string tagPrefix) {
            if ((namespaceName == null) || (namespaceName.Length == 0)) {
                throw new ArgumentNullException("namespaceName");
            }
            if ((tagPrefix == null) || (tagPrefix.Length == 0)) {
                throw new ArgumentNullException("tagPrefix");
            }

            this.namespaceName = namespaceName;
            this.tagPrefix = tagPrefix;
        }

        /// <include file='doc\TagPrefixAttribute.uex' path='docs/doc[@for="TagPrefixAttribute.NamespaceName"]/*' />
        public string NamespaceName {
            get {
                return namespaceName;
            }
        }

        /// <include file='doc\TagPrefixAttribute.uex' path='docs/doc[@for="TagPrefixAttribute.TagPrefix"]/*' />
        public string TagPrefix {
            get {
                return tagPrefix;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\tagnametotypemapper.cs ===
//------------------------------------------------------------------------------
// <copyright file="TagNameToTypeMapper.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Base Control factory implementation
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web.UI {

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Reflection;
    using System.Web.Util;
    using Debug=System.Diagnostics.Debug;

// REVIEW: TagNameToTypeMapper should be renamed to something more generic,
// like StringToTypeMapper, since it is used whenever we need to get a type
// from a string that comes from the .aspx file.

    /// <include file='doc\TagNameToTypeMapper.uex' path='docs/doc[@for="ITagNameToTypeMapper"]/*' />
    /// <devdoc>
    ///    <para>Maps a sequence of text characters to a .NET Framework 
    ///       type when an .aspx file is processed on the server.</para>
    /// </devdoc>
    internal interface ITagNameToTypeMapper {
        /*
         * Return the Type of the control that should handle a tag with the
         * passed in properties.
         */
        /// <include file='doc\TagNameToTypeMapper.uex' path='docs/doc[@for="ITagNameToTypeMapper.GetControlType"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the .NET Framework type that should process 
        ///       the control declared in the .aspx file.</para>
        ///    </devdoc>
        Type GetControlType(
                           string tagName,
                           IDictionary attribs);
    }


    internal class NamespaceTagNameToTypeMapper : ITagNameToTypeMapper {
        private string _ns;
        private Assembly _assembly;
        internal string NS { get { return _ns; } }

        internal NamespaceTagNameToTypeMapper(string ns, Assembly assembly) {
            _ns = ns;
            _assembly = assembly;
        }

        // ITagNameToTypeMapper::GetControlType
        /*public*/ Type ITagNameToTypeMapper.GetControlType(string tagName, IDictionary attribs) {

            Debug.Assert(_assembly != null, "_assembly != null");

            string typeName = _ns + "." + tagName;

            // Look up the type name (case insensitive)
            return _assembly.GetType(typeName, true /*throwOnError*/, true /*ignoreCase*/);
        }
    }


    internal class MainTagNameToTypeMapper {

        // Mapping from a tag prefix to an ITagNameToTypeMapper for that prefix
        private IDictionary _prefixedMappers;

        // Mapping from a tag name (possibly with a prefix) to a Type
        private IDictionary _mappedTags;

        // Create the Html tag mapper
        private ITagNameToTypeMapper _htmlMapper = new HtmlTagNameToTypeMapper();

        internal MainTagNameToTypeMapper() {
        }

        internal void AddSubMapper(string prefix, string ns, Assembly assembly) {
            NamespaceTagNameToTypeMapper mapper = new NamespaceTagNameToTypeMapper(ns, assembly);
 
            if (_prefixedMappers == null)
                _prefixedMappers = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

            // Check if this prefix has already been registered
            NamespaceTagNameToTypeMapper oldMapper = (NamespaceTagNameToTypeMapper) _prefixedMappers[prefix];
            if (oldMapper != null) {
                // If it has, complain if the namespace is different (ASURT 55164)
                if (!oldMapper.NS.Equals(mapper.NS)) {
                    throw new HttpException(
                        HttpRuntime.FormatResourceString(SR.Duplicate_prefix_map, prefix, oldMapper.NS));
                }
            }

            _prefixedMappers[prefix] = mapper;
        }

        internal void RegisterTag(string tagName, Type type) {
            if (_mappedTags == null)
                _mappedTags = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

            try {
                _mappedTags.Add(tagName, type);
            }
            catch (ArgumentException) {
                // Duplicate mapping
                throw new HttpException(HttpRuntime.FormatResourceString(
                    SR.Duplicate_registered_tag, tagName));
            }
        }

        internal /*public*/ Type GetControlType(
                                  string tagName,
                                  IDictionary attribs,
                                  bool fAllowHtmlTags) {
            ITagNameToTypeMapper mapper;
            Type type;

            // First, check it the tag name has been mapped
            if (_mappedTags != null) {
                type = (Type) _mappedTags[tagName];
                if (type != null)
                    return type;
            }

            // Check if there is a prefix
            int colonIndex = tagName.IndexOf(':');
            if (colonIndex >= 0) {
                // If ends with : don't try to match (88398)
                if (colonIndex == tagName.Length-1)
                    return null;

                // If so, parse the prefix and tagname
                string prefix = tagName.Substring(0, colonIndex);
                tagName = tagName.Substring(colonIndex+1);

                // If we have no prefix mappers, return null
                if (_prefixedMappers == null)
                    return null;

                // Look for a mapper for the prefix
                mapper = (ITagNameToTypeMapper) _prefixedMappers[prefix];
                if (mapper == null)
                    return null;

                // Try to get the type from the prefix mapper
                return mapper.GetControlType(tagName, attribs);
            }
            else {
                // There is no prefix.

                // Try the Html mapper if allowed
                if (fAllowHtmlTags)
                    return _htmlMapper.GetControlType(tagName, attribs);
            }

            return null;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\propertysetter.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertySetter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Sets multiple properties on an object through reflection
 *
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.UI {
    using System.Collections;
    using System.ComponentModel;
    using System.Reflection;
    using Debug=System.Diagnostics.Debug;
    using System.Globalization;
    
    /*
     * A PropertySetter stores information about a number of properties for a Type,
     * and can then set those properties on an instance of the Type.
     * If the Type implements IAttributeAccessor, the properties can also be set via SetAttribute.
     */
    /// <include file='doc\PropertySetter.uex' path='docs/doc[@for="PropertySetter"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    internal sealed class PropertySetter {
        private bool _fInDesigner;          // running in the designer
        private bool _fDataBound;           // Is the setter used for databound props
        private bool _fSupportsAttributes;  // object supports IAttributeAccessor
        private Type _objType;              // Type of the object properties are set on

        private EventDescriptorCollection _eventDescs; // event descriptors for the current type
        private PropertyDescriptorCollection _descriptors; // Property descriptors for the current type
        private bool _checkPersistable;     // whether to look for peristable attribute
        private bool _isHtmlControl;

        internal ArrayList _entries;        // list of PropertySetterEntries
        internal ArrayList _events;         // list of PropertySetterEventEntry

        internal PropertySetter(Type objType, bool fInDesigner) {
            // _objType can be null in the case of a template,
            // since the Type is not known until ITemplate::Initialize is called
            _objType = objType;
            _fInDesigner = fInDesigner;

            // does Type support generic attributes
            if (_objType != null && typeof(IAttributeAccessor).IsAssignableFrom(_objType))
                _fSupportsAttributes = true;


            // HTML controls treal Persistable.None differently, so don't check them
            if (_objType != null) {
                _isHtmlControl = typeof(HtmlControls.HtmlControl).IsAssignableFrom(_objType);
                _checkPersistable = !_isHtmlControl;
            }
            else { 
                _isHtmlControl = false;
                _checkPersistable = false;
            }

            //_checkPersistable = (_objType != null) && !typeof(HtmlControls.HtmlControl).IsAssignableFrom(_objType);
            if (_checkPersistable || _isHtmlControl) {
                _descriptors = TypeDescriptor.GetProperties(_objType);
            }
        }

        internal void SetDataBound() {
            _fDataBound = true;
        }

        private void AddPropertyInternal(string name, string value,
                                         ControlBuilder builder, bool fItemProp) {
            PropertySetterEntry entry = new PropertySetterEntry();
            bool fTemplate = false;
            string nameForCodeGen = null;

            entry._value = value;
            entry._builder = builder;
            entry._fItemProp = fItemProp;

            MemberInfo memberInfo = null;
            PropertyInfo propInfo = null;
            FieldInfo fieldInfo = null;

            // Is the property a template?
            if (builder != null && builder is TemplateBuilder)
                fTemplate = true;

            if (_objType != null && name != null) {   // attempt to locate a public property or field
                                                      // of given name on this type of object
                memberInfo = PropertyMapper.GetMemberInfo(_objType,name,out nameForCodeGen);
            }

            if (memberInfo != null) {   // memberInfo may be a PropertyInfo or FieldInfo
                if (memberInfo is PropertyInfo) {   // public property
                    propInfo = (PropertyInfo)memberInfo;
                    entry._propType = propInfo.PropertyType;

                    if (propInfo.GetSetMethod() == null) {   // property is readonly
                        if (builder == null && !_fSupportsAttributes) {   // only complex property is allowed to be readonly
                            throw new HttpException(
                                                   HttpRuntime.FormatResourceString(SR.Property_readonly, name));
                        }

                        if (builder != null) {   // complex property is allowed to be readonly
                                                 // set a flag to note that property is readonly
                            entry._fReadOnlyProp = true;
                        }
                        else if (_fSupportsAttributes) {   // allow attribute to be set via SetAttribute
                            entry._propType = null;
                            entry._name = name;
                        }
                    }

                }
                else {   // public field
                    fieldInfo = (FieldInfo)memberInfo;
                    entry._propType = fieldInfo.FieldType;
                }

                if (entry._propType != null) {
                    entry._propInfo = propInfo;
                    entry._fieldInfo = fieldInfo;
                    entry._name = nameForCodeGen;

                    // If it's a databound prop, we don't want to mess with the value,
                    // since it's a piece of code.
                    if (!_fDataBound) {
                        // check that the property is persistable, i.e., it makes sense to have it in
                        // the aspx template
                        if (_checkPersistable && nameForCodeGen != null) {
                            PropertyDescriptor propDesc = _descriptors[nameForCodeGen];
                            if (propDesc != null) {
                                if (propDesc.Attributes.Contains(DesignerSerializationVisibilityAttribute.Hidden)) {
                                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Property_Not_Persistable, name));
                                }
                            }
                        } else { 
                            if (_isHtmlControl) {
                                PropertyDescriptor propDesc = _descriptors[nameForCodeGen];
                                if (propDesc != null) {
                                    if (propDesc.Attributes.Contains(HtmlControlPersistableAttribute.No)) {
                                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Property_Not_Persistable, name));
                                    }
                                }
                            }
                        }

                        entry._propValue = PropertyConverter.ObjectFromString(entry._propType,
                                                                              memberInfo, entry._value);

                        // use actual property value to get the proper case-sensitive name for enum types
                        if (entry._propType.IsEnum) {
                            if (entry._propValue == null) {
                                throw new HttpException(
                                                       HttpRuntime.FormatResourceString(SR.Invalid_enum_value, 
                                                                                        entry._value, name, entry._propType.FullName));
                            }

                            entry._value = Enum.Format(entry._propType, entry._propValue, "G");
                        }
                        else if (entry._propType == typeof(Boolean)) {
                            // get the proper case-sensitive value for boolean
                            if (entry._value != null && entry._value.Length > 0)
                                entry._value = entry._value.ToLower(CultureInfo.InvariantCulture);
                            else
                                entry._propValue = true;
                        }

                        if (fTemplate) {
                            // Check if the property has a TemplateContainerAttribute, and if
                            // it does, get the type out of it.
                            TemplateContainerAttribute templateAttrib =
                                (TemplateContainerAttribute)Attribute.GetCustomAttribute(propInfo, typeof(TemplateContainerAttribute), false);
                            if (templateAttrib != null) {
                                if (!typeof(INamingContainer).IsAssignableFrom(templateAttrib.ContainerType)) {
                                    throw new HttpException(HttpRuntime.FormatResourceString(
                                        SR.Invalid_template_container, name, templateAttrib.ContainerType.FullName));
                                }
                                builder._ctrlType = templateAttrib.ContainerType;
                            }
                        }
                    }
                }
            }
            else if (fItemProp) {
            }
            else {   // could not locate a public property or field

                // determine if there is an event of this name.
                // do not look for events when running in designer
                if (!_fInDesigner 
                    && _objType != null
                    && name.Length >= 2 && string.Compare(name.Substring(0, 2), "on", true, CultureInfo.InvariantCulture) == 0) {
                    string eventName = name.Substring(2);
                    if (_eventDescs == null) {
                        _eventDescs = TypeDescriptor.GetEvents(_objType);
                    }
                    EventDescriptor eventFound = _eventDescs.Find(eventName, true);
                    if (eventFound != null) {   // an Add method has been located

                        PropertySetterEventEntry eventEntry = new PropertySetterEventEntry();
                        eventEntry._eventName = eventFound.Name;
                        eventEntry._handlerType = eventFound.EventType;

                        if (value == null || value.Length == 0) {
                            throw new HttpException(
                                                   HttpRuntime.FormatResourceString(SR.Event_handler_cant_be_empty, name));
                        }

                        eventEntry._handlerMethodName = value;

                        if (_events == null)
                            _events = new ArrayList(3);

                        // add to the list of events
                        _events.Add(eventEntry);

                        return;
                    }
                }

                // If attributes are not supported, or the property is a template or a
                // complex property (which cannot be set through SetAttribute), fail.
                if (!_fInDesigner && (!_fSupportsAttributes || builder != null)) {
                    if (_objType != null)
                        throw new HttpException(
                                               HttpRuntime.FormatResourceString(SR.Type_doesnt_have_property, _objType.FullName, name));

                    if (String.Compare(name,"name",true, CultureInfo.InvariantCulture) != 0)
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Templates_cannot_have_properties));
                    else
                        return;
                }

                // use the original property name for generic SetAttribute
                entry._name = name;
            }

            if (_entries == null)
                _entries = new ArrayList(3);

            // add entry to the list
            _entries.Add(entry);
        }

        /*
         * Add a property to the setter.
         */
        internal void AddProperty(string name, string value) {
            AddPropertyInternal(name, value, null, false /*fItemProp*/);
        }

        /*
         * Add a complex property to the setter.
         */
        internal void AddComplexProperty(string name, ControlBuilder builder) {
            AddPropertyInternal(name, null /*value*/, builder, false /*fItemProp*/);
        }

        /*
         * Add a complex <item> property to the setter.
         */
        internal void AddCollectionItem(ControlBuilder builder) {
            AddPropertyInternal(null /*name*/, null /*value*/, builder,
                                true /*fItemProp*/);
        }

        /*
         * Add a template property to the setter
         */
        internal void AddTemplateProperty(string name, TemplateBuilder builder) {
            AddPropertyInternal(name, null /*value*/, builder, false /*fItemProp*/);
        }

        /*
         * Set all the properties we have on the passed in object
         * This is not called when generating code for compiling... it is
         * used in design-mode, and at runtime when the user calls Page.ParseControl
         */
        internal void SetProperties(object obj) {
            Debug.Assert(_fInDesigner, "Expected to be running in design mode.");

            object[] parameters = new object[1];

            IAttributeAccessor attributeAccessor = null;
            DataBindingCollection dataBindings = null;

            if (_fDataBound && (_entries.Count != 0)) {
                Debug.Assert(obj is Control, "SetProperties on databindings PropertySetter should only be called for controls.");
                dataBindings = ((IDataBindingsAccessor)obj).DataBindings;
            }

            // Get the supported attribute interfaces
            if (_fSupportsAttributes)
                attributeAccessor = (IAttributeAccessor) obj;

            IEnumerator en = _entries.GetEnumerator();
            while (en.MoveNext()) {
                PropertySetterEntry entry = (PropertySetterEntry) en.Current;

                if (entry._propType == null) {
                    if (entry._fItemProp) {
                        try {
                            object objValue = entry._builder.BuildObject();
                            parameters[0] = objValue;

                            MethodInfo methodInfo = _objType.GetMethod("Add", BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static,
                                null /*binder*/, new Type[] { objValue.GetType() }, null /*modifiers*/);
                            Util.InvokeMethod(methodInfo, obj, parameters);
                        }
                        catch (Exception) {
                            throw new HttpException(
                                                   HttpRuntime.FormatResourceString(SR.Cannot_add_value_not_collection, entry._value));
                        }
                    }
                    else {
                        // If there is no property, use SetAttribute
                        if (attributeAccessor != null) {
                            attributeAccessor.SetAttribute(entry._name, entry._value);
                        }
                    }
                }
                else {
                    // Use the propinfo to set the prop
                    // Use either _propValue or _builder, whichever is set
                    if (entry._propValue != null) {
                        try {
                            PropertyMapper.SetMappedPropertyValue(obj, entry._name, entry._propValue);
                        }
                        catch (Exception e) {
                            throw new HttpException(
                                                   HttpRuntime.FormatResourceString(SR.Cannot_set_property,
                                                                                    entry._value, entry._name), e);
                        }

                    }
                    else if (entry._builder != null) {
                        if (entry._fReadOnlyProp) {
                            // a complex property is allowed to be readonly
                            try {
                                object objValue;

                                // Get the property since its readonly
                                MethodInfo methodInfo = entry._propInfo.GetGetMethod();
                                objValue = Util.InvokeMethod(methodInfo, obj, null);

                                // now we need to initialize this property
                                entry._builder.InitObject(objValue);
                            }
                            catch (Exception e) {
                                throw new HttpException(
                                                       HttpRuntime.FormatResourceString(SR.Cannot_init, entry._name), e);
                            }
                        }
                        else {
                            try {
                                object objValue = entry._builder.BuildObject();
                                parameters[0] = objValue;

                                // Set the property
                                MethodInfo methodInfo = entry._propInfo.GetSetMethod();
                                Util.InvokeMethod(methodInfo, obj, parameters);
                            }
                            catch (Exception e) {
                                throw new HttpException(
                                                       HttpRuntime.FormatResourceString(SR.Cannot_set_property,
                                                                                        entry._value, entry._name), e);
                            }
                        }
                    }
                    else if (dataBindings != null) {
                        DataBinding binding = new DataBinding(entry._name, entry._propType, entry._value.Trim());

                        dataBindings.Add(binding);
                    }
                    else {
                        Debug.Assert(false, "'" + entry._value + "' failed to be set on property '" + entry._name + "'.");
                    }
                }
            }
        }
    }


    /*
     * Element of the PropertySetter's _entries list are of this type.
     */
    internal class PropertySetterEntry {
        // The following fields are accessed through reflection

        // Name of the property
        internal string _name;

        // Value of the property
        internal string _value;

        // Value in case it's a complex property or a template
        internal ControlBuilder _builder;

        // True for complex properties that are readonly
        internal bool _fReadOnlyProp;

        // Is it an <item> complex property
        internal bool _fItemProp;

        // The PropertyInfo that this property maps to
        internal PropertyInfo _propInfo;

        // The FieldInfo that this property maps to
        internal FieldInfo _fieldInfo;

        // Type of the property
        internal Type _propType;

        // The instance variable representing the value
        internal object _propValue;

        internal PropertySetterEntry() {
        }

    }

    /*
     * Element of the PropertySetter's _events list are of this type.
     */
    internal class PropertySetterEventEntry {
        // The following fields are accessed through reflection

        // Name of the event.  e.g. "Click"
        internal string _eventName;

        // Type of the handler.  e.g. "ClickHandler"
        internal Type _handlerType;

        // Name of the handler method.  e.g. "ButtonClicked"
        internal string _handlerMethodName;

        internal PropertySetterEventEntry() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\templatebuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Classes related to templated control support
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.UI {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Security.Permissions;

    /*
     * This class defines the TemplateAttribute attribute that can be placed on
     * properties of type ITemplate.  It allows the parser to strongly type the
     * container, which makes it easier to write render code in a template
     */
    /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="TemplateContainerAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Property)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class TemplateContainerAttribute : Attribute {
        private Type _containerType;
        /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="TemplateContainerAttribute.ContainerType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type ContainerType { get { return _containerType;}}

        /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="TemplateContainerAttribute.TemplateContainerAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TemplateContainerAttribute(Type containerType) {
            _containerType = containerType;
        }
    }

    /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="TemplateBuilder"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TemplateBuilder : ControlBuilder, ITemplate {
        internal string _tagInnerText;

        /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="TemplateBuilder.Init"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Init(TemplateParser parser, ControlBuilder parentBuilder,
                                  Type type, string tagName,
                                  string ID, IDictionary attribs) {

            base.Init(parser, parentBuilder, type, tagName, ID, attribs);
        }

        // This code is only executed when used from the designer
        /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="TemplateBuilder.BuildObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal override object BuildObject() {
            return this;
        }

        /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="TemplateBuilder.NeedsTagInnerText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool NeedsTagInnerText() {
            // We want SetTagInnerText() to be called if we're running in the
            // designer.
            return InDesigner;
        }

        /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="TemplateBuilder.SetTagInnerText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void SetTagInnerText(string text) {
            // Save the inner text of the template tag
            _tagInnerText = text;
        }

        /*
         * ITemplate implementation
         * This implementation of ITemplate is only used in the designer
         */

        /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="TemplateBuilder.InstantiateIn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void InstantiateIn(Control container) {
            BuildChildren(container);
        }

        /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="TemplateBuilder.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual string Text {
            get { return _tagInnerText;}
            set { _tagInnerText = value;}
        }
    }


    // Delegates used for the compiled template
    /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="BuildTemplateMethod"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void BuildTemplateMethod(Control control);

    /*
     * This class is the ITemplate implementation that is called from the
     * generated page class code.  It just passes the Initialize call on to a
     * delegate.
     */
    /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="CompiledTemplateBuilder"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class CompiledTemplateBuilder : ITemplate {
        private BuildTemplateMethod _buildTemplateMethod;

        /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="CompiledTemplateBuilder.CompiledTemplateBuilder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CompiledTemplateBuilder(BuildTemplateMethod buildTemplateMethod) {
            _buildTemplateMethod = buildTemplateMethod;
        }

        // ITemplate::InstantiateIn
        /// <include file='doc\TemplateBuilder.uex' path='docs/doc[@for="CompiledTemplateBuilder.InstantiateIn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void InstantiateIn(Control container) {
            _buildTemplateMethod(container);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\toolboxdataattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolboxDataAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Web.UI {

    using System;
    using System.ComponentModel;
    using System.Globalization;
    using System.Security.Permissions;
    
    /// <include file='doc\ToolboxDataAttribute.uex' path='docs/doc[@for="ToolboxDataAttribute"]/*' />
    /// <devdoc>
    ///     ToolboxDataAttribute 
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class ToolboxDataAttribute : Attribute {

        /// <include file='doc\ToolboxDataAttribute.uex' path='docs/doc[@for="ToolboxDataAttribute.Default"]/*' />
        /// <devdoc>
        ///     
        /// </devdoc>
        public static readonly ToolboxDataAttribute Default = new ToolboxDataAttribute("");

        private string data = String.Empty;

        /// <include file='doc\ToolboxDataAttribute.uex' path='docs/doc[@for="ToolboxDataAttribute.Data"]/*' />
        /// <devdoc>
        /// </devdoc>
        public string Data {
            get {
                return this.data;
            }
        }

        /// <include file='doc\ToolboxDataAttribute.uex' path='docs/doc[@for="ToolboxDataAttribute.ToolboxDataAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public ToolboxDataAttribute(string data) {
            this.data = data;
        }

        /// <include file='doc\ToolboxDataAttribute.uex' path='docs/doc[@for="ToolboxDataAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\ToolboxDataAttribute.uex' path='docs/doc[@for="ToolboxDataAttribute.Equals"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }
            if ((obj != null) && (obj is ToolboxDataAttribute)) {
                return(String.Compare(((ToolboxDataAttribute)obj).Data, data, true, CultureInfo.InvariantCulture) == 0);
            }

            return false;
        }

        /// <include file='doc\ToolboxDataAttribute.uex' path='docs/doc[@for="ToolboxDataAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override bool IsDefaultAttribute() {
            return this.Equals(Default);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\tracemodeenum.cs ===
//------------------------------------------------------------------------------
// <copyright file="TraceModeEnum.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The different styles of trace output.
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {

using System;

    /// <include file='doc\TraceModeEnum.uex' path='docs/doc[@for="TraceMode"]/*' />
    /// <devdoc>
    ///    <para>Specifies how trace messages are emitted into the HTML output of a page.</para>
    /// </devdoc>
    public enum TraceMode {

        /// <include file='doc\TraceModeEnum.uex' path='docs/doc[@for="TraceMode.SortByTime"]/*' />
        /// <devdoc>
        ///    <para>Specifies that trace messages should be emitted in the order they were 
        ///       processed.</para>
        /// </devdoc>
        SortByTime = 0,

        /// <include file='doc\TraceModeEnum.uex' path='docs/doc[@for="TraceMode.SortByCategory"]/*' />
        /// <devdoc>
        ///    <para>Specifies that trace messages should be emitted 
        ///       alphabetically by category. </para>
        /// </devdoc>
        SortByCategory = 1,

        /// <include file='doc\TraceModeEnum.uex' path='docs/doc[@for="TraceMode.Default"]/*' />
        /// <devdoc>
        /// <para>Specifies the default value, which is <see langword='SortByTime'/>.</para>
        /// </devdoc>
        Default = 2,
    }

    /// <include file='doc\TraceModeEnum.uex' path='docs/doc[@for="TraceEnable"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal enum TraceEnable {

        /// <include file='doc\TraceModeEnum.uex' path='docs/doc[@for="TraceEnable.Default"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Default,

        /// <include file='doc\TraceModeEnum.uex' path='docs/doc[@for="TraceEnable.Enable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Enable,

        /// <include file='doc\TraceModeEnum.uex' path='docs/doc[@for="TraceEnable.Disable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Disable,

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\tracecontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="TraceContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The context for outputting trace information in the page.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web {
    using System;
// REVIEW: temporary: System.Web should not depend on System.Web.UI
// Also, this file should be moved down to System.Web.
    using System.Web;
    using System.Web.UI;
    using System.Web.Handlers;
    using System.Web.Util;
    using System.Web.SessionState;
    using System.Text;
    using System.Data;
    using System.Globalization;
    using System.Collections;    
    using System.Collections.Specialized;
    using System.Diagnostics;
    using System.Security.Permissions;

    /// <include file='doc\TraceContext.uex' path='docs/doc[@for="TraceContext"]/*' />
    /// <devdoc>
    ///    <para>Captures and presents execution details about a Web request.</para>
    ///    <para>Use the TraceContext
    ///       class by appending trace messages to specific trace categories. For example, a
    ///       calendar class might append the message ?Calendar1-&gt;Starting
    ///       To Render? within the Render category, and append the message ?Calendar1-&gt;Firing OnChange Event? within
    ///       the Events category. Tracing is enabled by setting the <see topic='cpdirSystem.Web.UI.PageDirectives'/>
    ///       Trace attribute or the System.Web.UI.TraceContext.IsEnabled
    ///       property.</para>
    ///    <para>When tracing is enabled, In addition to showing 
    ///       user-provided trace content, the <see cref='System.Web.UI.Page'/> class not only shows user-provided trace content, it automatically includes
    ///       performance data, tree-structure information, and state management content.</para>
    /// </devdoc>

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed
        class TraceContext {

        private static DataSet  _masterRequest;

        private TraceMode       _traceMode;
        private TraceEnable     _isEnabled;
        private HttpContext     _context;
        private DataSet         _requestData;
        private long            _firstTime;
        private long            _lastTime;
        private const string PAGEKEYNAME = "__PAGE";
        private const string NULLSTRING = "<null>"; // this will get HtmlEncoded later...

        private bool            _endDataCollected;

        /// <include file='doc\TraceContext.uex' path='docs/doc[@for="TraceContext.TraceContext"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.TraceContext'/> class.</para>
        /// </devdoc>
        public TraceContext(HttpContext context) {
            _traceMode = TraceMode.Default;
            _isEnabled = TraceEnable.Default;
            _context = context;
            _firstTime = -1;
            _lastTime = -1;
            _endDataCollected = false;
        }


        /// <include file='doc\TraceContext.uex' path='docs/doc[@for="TraceContext.TraceMode"]/*' />
        /// <devdoc>
        ///    <para>Indicates the order in which trace messages should be 
        ///       output to a requesting browser. Trace messages can be sorted in the order they
        ///       were processed, or alphabetically by user-defined category.</para>
        /// </devdoc>
        public TraceMode TraceMode {
            get {
                if (_traceMode == TraceMode.Default)
                    return HttpRuntime.Profile.OutputMode;

                return _traceMode;
            }
            set {
                if (value < TraceMode.SortByTime || value > TraceMode.Default) {
                    throw new ArgumentOutOfRangeException("value");
                }
                _traceMode = value;

                if (IsEnabled)
                    ApplyTraceMode();
            }
        }

        /// <include file='doc\TraceContext.uex' path='docs/doc[@for="TraceContext.IsEnabled"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether tracing is enabled for the current Web request.
        ///       Use this flag to check whether you should output tracing information before
        ///       writing anything to the trace log.</para>
        /// </devdoc>
        public bool IsEnabled {
            get {
                if (_isEnabled == TraceEnable.Default) 
                    return HttpRuntime.Profile.IsEnabled;
                else {
                    return (_isEnabled == TraceEnable.Enable) ? true : false;
                }
            }
            set {
                if (value) 
                    _isEnabled = TraceEnable.Enable;
                else
                    _isEnabled = TraceEnable.Disable;
            }
        }

        /// <include file='doc\TraceContext.uex' path='docs/doc[@for="TraceContext.PageOutput"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether trace information should be output to a Web Forms 
        ///       page. This property is used only in application-level tracing situations. You
        ///       can set this property in your application's config.web configuration file which
        ///       resides in the root directory of the application. </para>
        /// </devdoc>
        internal bool PageOutput {
            get {
                if (_isEnabled == TraceEnable.Default) 
                    return HttpRuntime.Profile.PageOutput;
                else {
                    return (_isEnabled == TraceEnable.Enable) ? true : false;
                }

            }
        }

        // this is used only for error pages, called from Page.HandleError.    
        internal int StatusCode { 
            set { 
                VerifyStart();
                DataRow row = _requestData.Tables[SR.Trace_Request].Rows[0];
                row[SR.Trace_Status_Code] = value;
            }
        }

        private void ApplyTraceMode() {
            VerifyStart();
            if (TraceMode == TraceMode.SortByCategory) 
                _requestData.Tables[SR.Trace_Trace_Information].DefaultView.Sort = SR.Trace_Category;
            else
                _requestData.Tables[SR.Trace_Trace_Information].DefaultView.Sort = SR.Trace_From_First;
        }


        internal void CopySettingsTo(TraceContext tc) {
            tc._traceMode = this._traceMode;
            tc._isEnabled = this._isEnabled;
        }

        /// <include file='doc\TraceContext.uex' path='docs/doc[@for="TraceContext.Write"]/*' />
        /// <devdoc>
        ///    <para>Writes trace information to the trace log including any 
        ///       user defined categories and trace messages.</para>
        /// </devdoc>
        public void Write(string message) {
            Write(String.Empty, message, null, false);
        }

        /// <include file='doc\TraceContext.uex' path='docs/doc[@for="TraceContext.Write1"]/*' />
        /// <devdoc>
        ///    <para>Writes trace information to the trace log including any 
        ///       user defined categories and trace messages.</para>
        /// </devdoc>
        public void Write(string category, string message) {
            Write(category, message, null, false);
        }

        /// <include file='doc\TraceContext.uex' path='docs/doc[@for="TraceContext.Write2"]/*' />
        /// <devdoc>
        ///    <para>Writes trace information to the trace log including any user defined 
        ///       categories,trace messages and error information.</para>
        /// </devdoc>
        public void Write(string category, string message, Exception errorInfo) {
            Write(category, message, errorInfo, false);
        }

        /// <include file='doc\TraceContext.uex' path='docs/doc[@for="TraceContext.Warn"]/*' />
        /// <devdoc>
        ///    <para>Writes trace information to the trace log including any 
        ///       user defined categories and trace messages. All warnings appear as red text.</para>
        /// </devdoc>
        public void Warn(string message) {
            Write(String.Empty, message, null, true);
        }

        /// <include file='doc\TraceContext.uex' path='docs/doc[@for="TraceContext.Warn1"]/*' />
        /// <devdoc>
        ///    <para>Writes trace information to the trace log including any 
        ///       user defined categories and trace messages. All warnings appear as red text.</para>
        /// </devdoc>
        public void Warn(string category, string message) {
            Write(category, message, null, true);
        }

        /// <include file='doc\TraceContext.uex' path='docs/doc[@for="TraceContext.Warn2"]/*' />
        /// <devdoc>
        ///    <para>Writes trace information to the trace log including any user defined categories,trace messages and error information. All 
        ///       warnings appear as red text. </para>
        /// </devdoc>
        public void Warn(string category, string message, Exception errorInfo) {
            Write(category, message, errorInfo, true);
        }


        void Write(string category, string message, Exception errorInfo, bool isWarning) {
            if (!IsEnabled)
                return;

            VerifyStart();

            if (category == null)
                category = String.Empty;

            if (message == null)
                message = String.Empty;

            long messagetime = Counter.Value;

            DataRow row = NewRow(_requestData, SR.Trace_Trace_Information);
            row[SR.Trace_Category] = category;
            row[SR.Trace_Message] = message;
            row[SR.Trace_Warning] = isWarning ? "yes" : "no";
            if (errorInfo != null) {
                row["ErrorInfoMessage"] = errorInfo.Message;
                row["ErrorInfoStack"] = errorInfo.StackTrace;
            }

            if (_firstTime != -1) {
                row[SR.Trace_From_First] = (( (double) (messagetime - _firstTime))/Counter.Frequency).ToString("0.000000");
            }
            else 
                _firstTime = messagetime;
                
            if (_lastTime != -1) {
                row[SR.Trace_From_Last] = (((double) (messagetime - _lastTime))/Counter.Frequency).ToString("0.000000");
            }
            _lastTime = messagetime;
            AddRow(_requestData, SR.Trace_Trace_Information, row);
        }

        internal void AddNewControl(string id, string parentId, string type, int viewStateSize) {
            VerifyStart();

            DataRow row = NewRow(_requestData, SR.Trace_Control_Tree);

            if (id == null)
                id = PAGEKEYNAME;
            row[SR.Trace_Control_Id] = id;

            if (parentId == null)
                parentId = PAGEKEYNAME;
            row[SR.Trace_Parent_Id] = parentId;
            
            row[SR.Trace_Type] = type;
            row[SR.Trace_Viewstate_Size] = viewStateSize;
            row[SR.Trace_Render_Size] = 0;
            try {
                AddRow(_requestData, SR.Trace_Control_Tree, row);
            }
            catch (ConstraintException) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Duplicate_id_used, id, "Trace"));
            }
                
        }

        /*
         *   Add the render size to the control
         */
        internal void AddControlSize(String controlId, int renderSize) {
            VerifyStart();

            DataTable dt = _requestData.Tables[SR.Trace_Control_Tree];

            // find the row for this control
            if (controlId == null)
                controlId = PAGEKEYNAME;
            DataRow row = dt.Rows.Find((object) controlId);
            // if the row is null, we couldn't find it, so we'll just skip this control
            if (row != null)
                row[SR.Trace_Render_Size] = renderSize;
        }

        internal void AddControlViewstateSize(String controlId, int viewstateSize) {
            VerifyStart();

            DataTable dt = _requestData.Tables[SR.Trace_Control_Tree];

            // find the row for this control
            if (controlId == null)
                controlId = PAGEKEYNAME;
            DataRow row = dt.Rows.Find((object) controlId);
            // if the row is null, we couldn't find it, so we'll just skip this control
            if (row != null)
                row[SR.Trace_Viewstate_Size] = viewstateSize;
        }

        internal void Render(HtmlTextWriter output) {
            if (PageOutput && _requestData != null) {

                TraceEnable oldEnabled = _isEnabled;

                _isEnabled = TraceEnable.Disable;

                Control table;

                output.Write("<div id=\"__asptrace\">\r\n");
                output.Write(TraceHandler.StyleSheet);
                output.Write("<span class=\"tracecontent\">\r\n");

                table = TraceHandler.CreateDetailsTable(_requestData.Tables[SR.Trace_Request]);
                if (table != null)
                    table.RenderControl(output);
    
                table = TraceHandler.CreateTraceTable(_requestData.Tables[SR.Trace_Trace_Information]);
                if (table != null)
                    table.RenderControl(output);

                table = TraceHandler.CreateControlTable(_requestData.Tables[SR.Trace_Control_Tree]);
                if (table != null)
                    table.RenderControl(output);

                table = TraceHandler.CreateTable(_requestData.Tables[SR.Trace_Session_State]);
                if (table != null)
                    table.RenderControl(output);

                table = TraceHandler.CreateTable(_requestData.Tables[SR.Trace_Application_State]);
                if (table != null)
                    table.RenderControl(output);

                table = TraceHandler.CreateTable(_requestData.Tables[SR.Trace_Cookies_Collection]);
                if (table != null)
                    table.RenderControl(output);

                table = TraceHandler.CreateTable(_requestData.Tables[SR.Trace_Headers_Collection]);
                if (table != null)
                    table.RenderControl(output);

                table = TraceHandler.CreateTable(_requestData.Tables[SR.Trace_Form_Collection]);
                if (table != null)
                    table.RenderControl(output);

                table = TraceHandler.CreateTable(_requestData.Tables[SR.Trace_Querystring_Collection]);
                if (table != null)
                    table.RenderControl(output);

                table = TraceHandler.CreateTable(_requestData.Tables[SR.Trace_Server_Variables]);
                if (table != null)
                    table.RenderControl(output);

                output.Write("</span>\r\n</div>\r\n");

                _isEnabled = oldEnabled;
            }
        }

        internal DataSet GetData() {
            return _requestData;
        }

        internal void VerifyStart() {
            // if we have already started, we can skip the lock
            if (_masterRequest == null) {
                // otherwise we need to make sure two 
                // requests don't try to call InitMaster at the same time
                lock(this) {
                    if (_masterRequest == null)
                        InitMaster();
                }
            }

            if (_requestData == null) {
                _requestData = _masterRequest.Clone();
                InitRequest();
            }
        }


        /*
         *   Finalize the request
         */
        internal void EndRequest() {
            VerifyStart();

            if (_endDataCollected)
                return;
            
            _endDataCollected = true;

            // add some more information about the reponse
            DataRow row = _requestData.Tables[SR.Trace_Request].Rows[0];
            row[SR.Trace_Status_Code] = _context.Response.StatusCode;
            row[SR.Trace_Response_Encoding] = _context.Response.ContentEncoding.EncodingName;

            IEnumerator en;
            string temp;
            object obj;
            int i;
            

            // Application State info
            _context.Application.Lock();
            try { 
                en = _context.Application.GetEnumerator();
                while (en.MoveNext()) {
                    row = NewRow(_requestData, SR.Trace_Application_State);
                    temp = (string) en.Current;

                    //the key might be null
                    row[SR.Trace_Application_Key] = (temp != null) ? temp : NULLSTRING;

                    obj = _context.Application[temp];

                    // the value could also be null
                    if (obj != null) {
                        row[SR.Trace_Type] = obj.GetType();
                        row[SR.Trace_Value] = obj.ToString();
                    }
                    else { 
                        row[SR.Trace_Type] = NULLSTRING;
                        row[SR.Trace_Value] = NULLSTRING;
                    }

                    AddRow(_requestData, SR.Trace_Application_State, row);
                }
            }
            finally { 
                _context.Application.UnLock();
            }

            // cookie info
            HttpCookie[] cookies = new HttpCookie[_context.Request.Cookies.Count];
            _context.Request.Cookies.CopyTo(cookies, 0);
            for (i = 0; i<cookies.Length; i++) {
                row = NewRow(_requestData, SR.Trace_Cookies_Collection);
                row[SR.Trace_Name] = cookies[i].Name;
                if (cookies[i].Values.HasKeys()) {
                    NameValueCollection subvalues = cookies[i].Values;
                    StringBuilder sb = new StringBuilder();

                    en = subvalues.GetEnumerator();
                    while (en.MoveNext()) {
                        temp = (string) en.Current;
                        sb.Append("(");
                        sb.Append(temp + "=");

                        sb.Append(cookies[i][temp] + ")  ");
                    }
                    row[SR.Trace_Value] = sb.ToString();
                }
                else
                    row[SR.Trace_Value] = cookies[i].Value;

                int size =  (cookies[i].Name  == null) ? 0 : cookies[i].Name.Length;
                size += (cookies[i].Value == null) ? 0 : cookies[i].Value.Length;
        
                row[SR.Trace_Size] = size + 1; // plus 1 for =
                AddRow(_requestData, SR.Trace_Cookies_Collection, row);
            }

            HttpSessionState session = _context.Session;
            // session state info 
            if (session != null) {
                row = _requestData.Tables[SR.Trace_Request].Rows[0];
                row[SR.Trace_Session_Id] = session.SessionID;

                en = session.GetEnumerator();
                while (en.MoveNext()) {
                    row = NewRow(_requestData, SR.Trace_Session_State);
                    
                    temp = (string) en.Current;

                    // the key could be null
                    row[SR.Trace_Session_Key] = (temp != null) ? temp : NULLSTRING;

                    obj = session[temp];

                    // the value could also be null
                    if (obj != null) {
                        row[SR.Trace_Type] = obj.GetType();
                        row[SR.Trace_Value] = obj.ToString();
                    }
                    else { 
                        row[SR.Trace_Type] = NULLSTRING;
                        row[SR.Trace_Value] = NULLSTRING;
                    }

                    AddRow(_requestData, SR.Trace_Session_State, row);
                }
            }

            ApplyTraceMode();
        }

        /*  InitMaster
         *  Initialize the _masterRequest dataset with the schema we use
         *  to store profiling information
         */
        private void InitMaster() {
            DataSet tempset = new DataSet();
            tempset.Locale = CultureInfo.InvariantCulture;

            // populate the _masterRequest's schema
            DataTable tab; 
            Type strtype = typeof(string);
            Type inttype = typeof(int);

            // request table
            tab = tempset.Tables.Add(SR.Trace_Request);
            tab.Columns.Add(SR.Trace_No, inttype);
            tab.Columns.Add(SR.Trace_Time_of_Request, strtype);
            tab.Columns.Add(SR.Trace_Url, strtype);
            tab.Columns.Add(SR.Trace_Request_Type, strtype);
            tab.Columns.Add(SR.Trace_Status_Code, inttype);
            tab.Columns.Add(SR.Trace_Session_Id, strtype);
            tab.Columns.Add(SR.Trace_Request_Encoding, strtype);
            tab.Columns.Add(SR.Trace_Response_Encoding, strtype);

            // control heirarchy table
            tab = tempset.Tables.Add(SR.Trace_Control_Tree);
            tab.Columns.Add(SR.Trace_Parent_Id, strtype);

            DataColumn[] col = new DataColumn[1];
            col[0] = new DataColumn(SR.Trace_Control_Id, strtype);
            tab.Columns.Add(col[0]);
            tab.PrimaryKey = col;   // set the control id to be the primary key

            tab.Columns.Add(SR.Trace_Type, strtype);
            tab.Columns.Add(SR.Trace_Render_Size, inttype);
            tab.Columns.Add(SR.Trace_Viewstate_Size, inttype);

            // session state table
            tab = tempset.Tables.Add(SR.Trace_Session_State);
            tab.Columns.Add(SR.Trace_Session_Key, strtype);
            tab.Columns.Add(SR.Trace_Type, strtype);
            tab.Columns.Add(SR.Trace_Value, strtype);

            // application state table
            tab = tempset.Tables.Add(SR.Trace_Application_State);
            tab.Columns.Add(SR.Trace_Application_Key, strtype);
            tab.Columns.Add(SR.Trace_Type, strtype);
            tab.Columns.Add(SR.Trace_Value, strtype);

            // cookies table
            tab = tempset.Tables.Add(SR.Trace_Cookies_Collection);
            tab.Columns.Add(SR.Trace_Name, strtype);
            tab.Columns.Add(SR.Trace_Value, strtype);
            tab.Columns.Add(SR.Trace_Size, inttype);

            // header table
            tab = tempset.Tables.Add(SR.Trace_Headers_Collection);
            tab.Columns.Add(SR.Trace_Name, strtype);
            tab.Columns.Add(SR.Trace_Value, strtype);

            // form variables table
            tab = tempset.Tables.Add(SR.Trace_Form_Collection);
            tab.Columns.Add(SR.Trace_Name, strtype);
            tab.Columns.Add(SR.Trace_Value, strtype);

            // querystring table
            tab = tempset.Tables.Add(SR.Trace_Querystring_Collection);
            tab.Columns.Add(SR.Trace_Name, strtype);
            tab.Columns.Add(SR.Trace_Value, strtype);

            // trace info
            tab = tempset.Tables.Add(SR.Trace_Trace_Information);
            tab.Columns.Add(SR.Trace_Category, strtype);
            tab.Columns.Add(SR.Trace_Warning, strtype);
            tab.Columns.Add(SR.Trace_Message, strtype);
            tab.Columns.Add(SR.Trace_From_First, strtype);
            tab.Columns.Add(SR.Trace_From_Last, strtype);
            tab.Columns.Add("ErrorInfoMessage", strtype);
            tab.Columns.Add("ErrorInfoStack", strtype);

            // server variables
            tab = tempset.Tables.Add(SR.Trace_Server_Variables);
            tab.Columns.Add(SR.Trace_Name, strtype);
            tab.Columns.Add(SR.Trace_Value, strtype);

            _masterRequest = tempset;
        }

        private DataRow NewRow(DataSet ds, string table) {
            return ds.Tables[table].NewRow();
        }
        
        private void AddRow(DataSet ds, string table, DataRow row) {
            ds.Tables[table].Rows.Add(row);
        }

        /*  InitRequest
         *  Initialize the given dataset with basic 
         *  request information
         */
        private void InitRequest() {

            // request info
            DataRow row = NewRow(_requestData, SR.Trace_Request);
            row[SR.Trace_Time_of_Request] = _context.Timestamp.ToString("G");

            string url = _context.Request.RawUrl;
            int loc = url.IndexOf("?");
            if (loc != -1)
                url = url.Substring(0, loc);
            row[SR.Trace_Url] = url;

            row[SR.Trace_Request_Type] = _context.Request.HttpMethod;
            try {
                row[SR.Trace_Request_Encoding] = _context.Request.ContentEncoding.EncodingName;
            }
            catch { 
                // if we get an exception getting the ContentEncoding, most likely 
                // there's an error in the config file.  Just ignore it so we can finish InitRequest.
            }
                
            if (TraceMode == TraceMode.SortByCategory) 
                _requestData.Tables[SR.Trace_Trace_Information].DefaultView.Sort = SR.Trace_Category;
            AddRow(_requestData, SR.Trace_Request, row);

            // header info
            int i;
            String[] keys = _context.Request.Headers.AllKeys;
            for (i=0; i<keys.Length; i++) {
                row = NewRow(_requestData, SR.Trace_Headers_Collection);
                row[SR.Trace_Name] = keys[i];
                row[SR.Trace_Value] = _context.Request.Headers[keys[i]];
                AddRow(_requestData, SR.Trace_Headers_Collection, row);
            }

            //form info
            keys = _context.Request.Form.AllKeys;
            for (i=0; i<keys.Length; i++) {
                row = NewRow(_requestData, SR.Trace_Form_Collection);
                row[SR.Trace_Name] = keys[i];
                row[SR.Trace_Value] = _context.Request.Form[keys[i]];
                AddRow(_requestData, SR.Trace_Form_Collection, row);
            }

            //QueryString info
            keys = _context.Request.QueryString.AllKeys;
            for (i=0; i<keys.Length; i++) {
                row = NewRow(_requestData, SR.Trace_Querystring_Collection);
                row[SR.Trace_Name] = keys[i];
                row[SR.Trace_Value] = _context.Request.QueryString[keys[i]];
                AddRow(_requestData, SR.Trace_Querystring_Collection, row);
            }

            //Server Variable info
            if (HttpRuntime.HasAppPathDiscoveryPermission()) {
                keys = _context.Request.ServerVariables.AllKeys;
                for (i=0; i<keys.Length; i++) {
                    row = NewRow(_requestData, SR.Trace_Server_Variables);
                    row[SR.Trace_Name] = keys[i];
                    row[SR.Trace_Value] = _context.Request.ServerVariables.Get(keys[i]);
                    AddRow(_requestData, SR.Trace_Server_Variables, row);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\trivialpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="TrivialPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Page used for trivial .aspx pages (that don't require compilation)
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.UI {
using System;
using System.Reflection;
using System.Globalization;
using System.Web;

/*
 * The purpose of this class is to avoid having to perform compilation when
 * we're handling a trivial .aspx file, that is a file that is essentially
 * plain HTML.
 */

internal class TrivialPage : IHttpHandler {
    // The contents
    private string _content;

    internal TrivialPage(string content) {
        _content = content;
    }

    public void ProcessRequest(HttpContext context) {
        context.Response.Write(_content);
    }

    public bool IsReusable {
        get { return true; }
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\templatecontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Page class definition
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web.UI {

using System.Text;
using System.Reflection;
using System;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.ComponentModel;
using System.Web;
using System.Web.Util;
using Debug=System.Diagnostics.Debug;
using System.Security.Permissions;

/*
 * Base class for Pages and UserControls
 */
/// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl"]/*' />
/// <devdoc>
/// <para>Provides the <see cref='System.Web.UI.Page'/> class and the <see cref='System.Web.UI.UserControl'/> class with a base set of functionality.</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public abstract class TemplateControl : Control, INamingContainer {

    // Used for the literal string optimization (reading strings from resource)
    private IntPtr _stringResourcePointer;
    private int _maxResourceOffset;


    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.TemplateControl"]/*' />
    protected TemplateControl() {
        Construct();
    }

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.Construct"]/*' />
    /// <devdoc>
    /// <para>Do construction time logic (ASURT 66166)</para>
    /// </devdoc>
    protected virtual void Construct() {}


    private static readonly object EventCommitTransaction = new object();

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.CommitTransaction"]/*' />
    /// <devdoc>
    ///    <para>Occurs when a user initiates a transaction.</para>
    /// </devdoc>
    [
    WebSysDescription(SR.Page_OnCommitTransaction)
    ]
    public event EventHandler CommitTransaction {
        add {
            Events.AddHandler(EventCommitTransaction, value);
        }
        remove {
            Events.RemoveHandler(EventCommitTransaction, value);
        }
    }

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.OnCommitTransaction"]/*' />
    /// <devdoc>
    /// <para>Raises the <see langword='CommitTransaction'/> event. You can use this method 
    ///    for any transaction processing logic in which your page or user control
    ///    participates.</para>
    /// </devdoc>
    protected virtual void OnCommitTransaction(EventArgs e) {
        EventHandler handler = (EventHandler)Events[EventCommitTransaction];
        if (handler != null) handler(this, e);
    }

    private static readonly object EventAbortTransaction = new object();

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.AbortTransaction"]/*' />
    /// <devdoc>
    ///    <para>Occurs when a user aborts a transaction.</para>
    /// </devdoc>
    [
    WebSysDescription(SR.Page_OnAbortTransaction)
    ]
    public event EventHandler AbortTransaction {
        add {
            Events.AddHandler(EventAbortTransaction, value);
        }
        remove {
            Events.RemoveHandler(EventAbortTransaction, value);
        }
    }

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.OnAbortTransaction"]/*' />
    /// <devdoc>
    /// <para>Raises the <see langword='AbortTransaction'/> event.</para>
    /// </devdoc>
    protected virtual void OnAbortTransaction(EventArgs e) {
        EventHandler handler = (EventHandler)Events[EventAbortTransaction];
        if (handler != null) handler(this, e);
    }

    // Page_Error related events/methods

    private static readonly object EventError = new object();

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.Error"]/*' />
    /// <devdoc>
    ///    <para>Occurs when an uncaught exception is thrown.</para>
    /// </devdoc>
    [
    WebSysDescription(SR.Page_Error)
    ]
    public event EventHandler Error {
        add {
            Events.AddHandler(EventError, value);
        }
        remove {
            Events.RemoveHandler(EventError, value);
        }
    }

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.OnError"]/*' />
    /// <devdoc>
    /// <para>Raises the <see langword='Error'/> event. 
    ///    </para>
    /// </devdoc>
    protected virtual void OnError(EventArgs e) {
        EventHandler handler = (EventHandler)Events[EventError];
        if (handler != null) handler(this, e);
    }

    /*
     * Method sometime overidden by the generated sub classes.  Users
     * should not override.
     */
    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.FrameworkInitialize"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>Initializes the requested page. While this is sometimes 
    ///       overridden when the page is generated at runtime, you should not explicitly override this method.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected virtual void FrameworkInitialize() {
    }

    /*
     * This property is overriden by the generated classes (hence it cannot be internal)
     * If false, we don't do the HookUpAutomaticHandlers() magic.
     */
    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.SupportAutoEvents"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected virtual bool SupportAutoEvents  {
        get { return true; }
    }

    /*
     * Returns a pointer to the resource buffer, and the largest valid offset
     * in the buffer (for security reason)
     */
    internal IntPtr StringResourcePointer { get { return _stringResourcePointer; } }
    internal int MaxResourceOffset { get { return _maxResourceOffset; } }

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.ReadStringResource"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>This method is called by the generated classes (hence it cannot be internal)</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static object ReadStringResource(Type t) {
        return StringResourceManager.ReadSafeStringResource(t);
    }

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.CreateResourceBasedLiteralControl"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>This method is called by the generated classes (hence it cannot be internal)</para>
    /// </devdoc>
    protected LiteralControl CreateResourceBasedLiteralControl(int offset, int size, bool fAsciiOnly) {
        return new ResourceBasedLiteralControl(this, offset, size, fAsciiOnly);
    }

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.SetStringResourcePointer"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>This method is called by the generated classes (hence it cannot be internal)</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected void SetStringResourcePointer(object stringResourcePointer, int maxResourceOffset) {

        // Ignore the passed in maxResourceOffset, which cannot be trusted.  Instead, use
        // the resource size that we obtained from the resource (ASURT 122759)
        SafeStringResource ssr = (SafeStringResource) stringResourcePointer;
        _stringResourcePointer = ssr.StringResourcePointer;
        _maxResourceOffset = ssr.ResourceSize;

        Debug.Assert(_maxResourceOffset == maxResourceOffset);
    }

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.WriteUTF8ResourceString"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>This method is called by the generated classes (hence it cannot be internal)</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected void WriteUTF8ResourceString(HtmlTextWriter output, int offset, int size, bool fAsciiOnly) {

        // Make sure we don't access invalid data
        if (offset < 0 || offset+size > _maxResourceOffset)
            throw new ArgumentOutOfRangeException("offset");

        output.WriteUTF8ResourceString(StringResourcePointer, offset, size, fAsciiOnly);
    }

    /*
     * This method is overriden by the generated classes (hence it cannot be internal)
     */
    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.AutoHandlers"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Never)]
    protected virtual int AutoHandlers {
        get { return 0;}
        set {}
    }

    // const masks into the SimpleBitVector32
    private const int attempted                     = 0x000001;
    private const int hasInitHandler                = 0x000002;
    private const int isInitArgless                 = 0x000004;
    private const int hasLoadHandler                = 0x000008;
    private const int isLoadArgless                 = 0x000010;
    private const int hasDataBindHandler            = 0x000020;
    private const int isDataBindArgless             = 0x000040;
    private const int hasPreRenderHandler           = 0x000080;
    private const int isPreRenderArgless            = 0x000100;
    private const int hasUnloadHandler              = 0x000200;
    private const int isUnloadArgless               = 0x000400;
    private const int hasErrorHandler               = 0x000800;
    private const int isErrorArgless                = 0x001000;
    private const int hasAbortTransactionHandler    = 0x002000;
    private const int isAbortTransactionArgless     = 0x004000;
    private const int hasOnTransactionAbortHandler  = 0x008000;
    private const int isOnTransactionAbortArgless   = 0x010000;
    private const int hasCommitTransactionHandler   = 0x020000;
    private const int isCommitTransactionArgless    = 0x040000;
    private const int hasOnTransactionCommitHandler = 0x080000;
    private const int isOnTransactionCommitArgless  = 0x100000;

    internal void HookUpAutomaticHandlers() {

        // Do nothing if auto-events are not supported
        if (!SupportAutoEvents)
            return;

        // Get the generated class's __autoHandler static
        SimpleBitVector32 flags = new SimpleBitVector32(AutoHandlers);

        // Make sure we have reflection permission to discover the handlers (ASURT 105965)
        InternalSecurityPermissions.Reflection.Assert();

        // Try to find what handlers are implemented if not tried before
        if (!flags[attempted]) {
            flags[attempted] = true;

            GetDelegateInformation("Page_Init", ref flags, hasInitHandler, isInitArgless);
            GetDelegateInformation("Page_Load", ref flags, hasLoadHandler, isLoadArgless);
            GetDelegateInformation("Page_DataBind", ref flags, hasDataBindHandler, isDataBindArgless);
            GetDelegateInformation("Page_PreRender", ref flags, hasPreRenderHandler, isPreRenderArgless);
            GetDelegateInformation("Page_Unload", ref flags, hasUnloadHandler, isUnloadArgless);
            GetDelegateInformation("Page_Error", ref flags, hasErrorHandler, isErrorArgless);
            GetDelegateInformation("Page_AbortTransaction", ref flags, hasAbortTransactionHandler, isAbortTransactionArgless);
            GetDelegateInformation("OnTransactionAbort", ref flags, hasOnTransactionAbortHandler, isOnTransactionAbortArgless);
            GetDelegateInformation("Page_CommitTransaction", ref flags, hasCommitTransactionHandler, isCommitTransactionArgless);
            GetDelegateInformation("OnTransactionCommit", ref flags, hasOnTransactionCommitHandler, isOnTransactionCommitArgless);

            // Store it back into the generated class's __autoHandler static
            AutoHandlers = flags.Data;

            Debug.Assert(AutoHandlers != 0, "AutoHandlers != 0");
        }

        if (flags[hasInitHandler])
            Init += GetDelegateFromMethodName("Page_Init", flags[isInitArgless]);

        if (flags[hasLoadHandler])
            Load += GetDelegateFromMethodName("Page_Load", flags[isLoadArgless]);

        if (flags[hasDataBindHandler])
            DataBinding += GetDelegateFromMethodName("Page_DataBind", flags[isDataBindArgless]);

        if (flags[hasPreRenderHandler])
            PreRender += GetDelegateFromMethodName("Page_PreRender", flags[isPreRenderArgless]);

        if (flags[hasUnloadHandler])
            Unload += GetDelegateFromMethodName("Page_Unload", flags[isUnloadArgless]);

        if (flags[hasErrorHandler])
            Error += GetDelegateFromMethodName("Page_Error", flags[isErrorArgless]);

        // Only one transaction event should be hooked up per ASURT 99474

        if (flags[hasAbortTransactionHandler])
            AbortTransaction += GetDelegateFromMethodName("Page_AbortTransaction", flags[isAbortTransactionArgless]);
        else if (flags[hasOnTransactionAbortHandler])
            AbortTransaction += GetDelegateFromMethodName("OnTransactionAbort", flags[isOnTransactionAbortArgless]);

        if (flags[hasCommitTransactionHandler])
            CommitTransaction += GetDelegateFromMethodName("Page_CommitTransaction", flags[isCommitTransactionArgless]);
        else if (flags[hasOnTransactionCommitHandler])
            CommitTransaction += GetDelegateFromMethodName("OnTransactionCommit", flags[isOnTransactionCommitArgless]);
    }

    private void GetDelegateInformation(string methodName, ref SimpleBitVector32 flags,
        int hasHandlerBit, int isArglessBit) {

        // First, try to get a delegate to the two parameter handler
        EventHandler e = null;
        try {
            e = (EventHandler)Delegate.CreateDelegate(typeof(EventHandler), this,
                methodName, true /*ignoreCase*/);
        }
        catch {
        }

        // If there isn't one, try the argless one
        if (e == null) {
            try {
                VoidMethod vm = (VoidMethod)Delegate.CreateDelegate(typeof(VoidMethod), this,
                    methodName, true /*ignoreCase*/);
                e = new ArglessEventHandlerDelegateProxy(vm).Handler;
                flags[isArglessBit] = true;
            }
            catch {
            }
        }

        flags[hasHandlerBit] = (e != null);
    }

    private EventHandler GetDelegateFromMethodName(string methodName, bool isArgless) {
        if (isArgless) {
            VoidMethod vm = (VoidMethod)Delegate.CreateDelegate(typeof(VoidMethod), this,
                methodName, true /*ignoreCase*/);
            return new ArglessEventHandlerDelegateProxy(vm).Handler;
        }

        return (EventHandler)Delegate.CreateDelegate(typeof(EventHandler), this,
            methodName, true /*ignoreCase*/);
    }

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.LoadControl"]/*' />
    /// <devdoc>
    /// <para>Obtains a <see cref='System.Web.UI.UserControl'/> object from a user control file.</para>
    /// </devdoc>
    public Control LoadControl(string virtualPath) {

        // If it's relative, make it absolute.  Treat is as relative to this
        // user control (ASURT 55513)
        virtualPath = UrlPath.Combine(TemplateSourceDirectory, virtualPath);

        // Compile the declarative control and get its Type
        Type t = UserControlParser.GetCompiledUserControlType(virtualPath,
            null, Context);

        return LoadControl(t);
    }

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.LoadControl2"]/*' />
    /// <devdoc>
    /// <para>Obtains a <see cref='System.Web.UI.UserControl'/> object from a control type.</para>
    /// </devdoc>
    internal Control LoadControl(Type t) {

        // Make sure the type has the correct base class (ASURT 123677)
        Util.CheckAssignableType(typeof(Control), t);

        // Check if the user control type has a PartialCachingAttribute attribute
        PartialCachingAttribute cacheAttrib = (PartialCachingAttribute)
            TypeDescriptor.GetAttributes(t)[typeof(PartialCachingAttribute)];

        if (cacheAttrib == null) {
            // The control is not cached.  Just create it.
            Control c = (Control) HttpRuntime.CreatePublicInstance(t);
            UserControl uc = c as UserControl;
            if (uc != null)
                uc.InitializeAsUserControl(Page);
            return c;
        }

        string cacheKey;

        if (cacheAttrib.Shared) {
            // If the caching is shared, use the type of the control as the key
            cacheKey = t.GetHashCode().ToString();
        }
        else {
            // Make sure we have reflection permission to use GetMethod below (ASURT 106196)
            InternalSecurityPermissions.Reflection.Assert();

            HashCodeCombiner combinedHashCode = new HashCodeCombiner();
            // Get a cache key based on the top two items of the caller's stack.
            // It's not guaranteed unique, but for all common cases, it will be
            StackTrace st = new StackTrace();

            for (int i = 1; i < 3; i++) {
                StackFrame f = st.GetFrame(i);
                combinedHashCode.AddObject(f.GetMethod());
                combinedHashCode.AddObject(f.GetNativeOffset());
            }

            cacheKey = combinedHashCode.CombinedHashString;
        }

        // Wrap it to allow it to be cached
        return new PartialCachingControl(t, cacheAttrib, "_" + cacheKey);
    }

    // Class that implements the templates returned by LoadTemplate (ASURT 94138)
    internal class SimpleTemplate : ITemplate {
        private Type _ctrlType;

        internal SimpleTemplate(Type ctrlType) { _ctrlType = ctrlType; }

        public virtual void InstantiateIn(Control control) {
            UserControl uc = (UserControl) HttpRuntime.CreatePublicInstance(_ctrlType);

            // Make sure that the user control is not used as the binding container,
            // since we want its *parent* to be the binding container.
            uc.SetNonBindingContainer();

            uc.InitializeAsUserControl(control.Page);

            control.Controls.Add(uc);
        }
    }

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.LoadTemplate"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Obtains an instance of the <see langword='ITemplate'/> interface from an
    ///       external file.
    ///    </para>
    /// </devdoc>
    public ITemplate LoadTemplate(string virtualPath) {

        // If it's relative, make it absolute.  Treat is as relative to this
        // user control (ASURT 55513)
        virtualPath = UrlPath.Combine(TemplateSourceDirectory, virtualPath);

        // Compile the declarative template and get its Type
        Type t = UserControlParser.GetCompiledUserControlType(virtualPath,
            null, Context);

        return new SimpleTemplate(t);
    }

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.ParseControl"]/*' />
    /// <devdoc>
    ///    <para> Parse the input string into a Control.  Looks for the first control
    ///    in the input.  Returns null if none is found.</para>
    /// </devdoc>
    public Control ParseControl(string content) {
        return TemplateParser.ParseControl(content, Context, TemplateSourceDirectory);
    }

    /// <include file='doc\TemplateControl.uex' path='docs/doc[@for="TemplateControl.ParseTemplate"]/*' />
    /// <devdoc>
    ///    <para> Parse the input string into an ITemplate.</para>
    /// </devdoc>
    internal ITemplate ParseTemplate(string content) {
        return TemplateParser.ParseTemplate(content, Context, TemplateSourceDirectory);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\templatecontrolparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateControlParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Implements the ASP.NET template parser
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

// Turn this on to do regex profiling
//#define PROFILE_REGEX

// Turn this on to run regex's in interpreted (non-compiled) mode
//#define INTERPRETED_REGEX

namespace System.Web.UI {

using System.Text;
using System;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Reflection;
using System.Web.Caching;
using System.Web.Util;
using HttpException = System.Web.HttpException;
using System.Text.RegularExpressions;
using Debug=System.Diagnostics.Debug;
using System.Globalization;
using System.Security.Permissions;


/*
 * Parser for TemplateControl's (UserControls and Pages)
 */
/// <include file='doc\TemplateControlParser.uex' path='docs/doc[@for="TemplateControlParser"]/*' />
/// <internalonly/>
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public abstract class TemplateControlParser : TemplateParser {

    // Attributes in <%@ outputcache ... %> directive
    private IDictionary _outputCacheDirective;

    // Unit is second
    private int _duration;
    internal int Duration { get { return _duration; } }

    private string _varyByParams;
    internal string VaryByParams { get { return _varyByParams; } }

    private string _varyByCustom;
    internal string VaryByCustom { get { return _varyByCustom; } }

    private bool _fEnableViewState = true;
    internal bool FEnableViewState { get { return _fEnableViewState ; } }

    private bool _fAutoEventWireup = true;
    internal bool FAutoEventWireup { get { return _fAutoEventWireup ; } }


    internal object GetCompiledInstance(string virtualPath,
        string inputFile, HttpContext context) {

        ParserCacheItem cacheItem = CompileAndGetParserCacheItem(virtualPath,
            inputFile, context);

        // Instantiate the object
        object ob = null;
        try {
            if (cacheItem.trivialPageContent != null) {
                Debug.Assert(cacheItem.type == null);
                ob = new TrivialPage(cacheItem.trivialPageContent);
            }
            else {
                // impersonate client while executing page ctor (see 89712)
                // (compilation is done while not impersonating client)
                context.Impersonation.ReimpersonateIfSuspended();

                try {
                    ob = HttpRuntime.CreatePublicInstance(cacheItem.type);
                }
                finally {
                    context.Impersonation.StopReimpersonation();
                }
            }
        }
        catch (Exception e) {
            throw new HttpException(HttpRuntime.FormatResourceString(
                SR.Failed_to_create_page_of_type, cacheItem.type.FullName), e);
        }

        return ob;
    }

    internal Type GetCompiledType(string virtualPath,
        string inputFile, HttpContext context) {

        ParserCacheItem cacheItem = CompileAndGetParserCacheItem(virtualPath,
            inputFile, context);

        return cacheItem.type;
    }

    private ParserCacheItem CompileAndGetParserCacheItem(string virtualPath,
        string inputFile, HttpContext context) {

        Context = context;

        // Use the specified virtual path
        Debug.Assert(virtualPath != null);
        CurrentVirtualPath = UrlPath.Combine(context.Request.BaseDir, virtualPath);

        // Get the physical path if it wasn't specified
        if (inputFile == null)
            inputFile = MapPath(CurrentVirtualPath, false /*allowCrossAppMapping*/);

        InputFile = inputFile;

        return GetParserCacheItem();
    }

    /*
     * Do some initialization before the parsing
     */
    internal override void PrepareParse() {
        base.PrepareParse();

        // Register the "mobile" tag prefix (ASURT 112895), but not when running in the designer (ASURT 128928)
        RegisterMobileControlTagPrefix();
    }

    // ASURT 112895: hard code AUI support until we implement a more generic mechanism
    static Assembly _mobileAssembly;
    static bool _fTriedToLoadMobileAssembly;
    static Type _mobilePageType, _mobileUserControlType;
    private void RegisterMobileControlTagPrefix() {

        // Try to load the Mobile assembly if not already done
        if (!_fTriedToLoadMobileAssembly) {
            _mobileAssembly = LoadAssembly(AssemblyRef.SystemWebMobile, false /*throwOnFail*/);

            if (_mobileAssembly != null) {
                _mobilePageType = _mobileAssembly.GetType("System.Web.UI.MobileControls.MobilePage");
                Debug.Assert(_mobilePageType != null);
                _mobileUserControlType = _mobileAssembly.GetType("System.Web.UI.MobileControls.MobileUserControl");
                Debug.Assert(_mobileUserControlType != null);
            }

            _fTriedToLoadMobileAssembly = true;
        }

        if (_mobileAssembly == null)
            return;

        RootBuilder.RegisterTagPrefix("Mobile", "System.Web.UI.MobileControls", _mobileAssembly);
    }

    // Get default settings from config
    internal override void ProcessConfigSettings() {
        base.ProcessConfigSettings();

        if (PagesConfig != null) {
            _fAutoEventWireup = PagesConfig.FAutoEventWireup;
            _fEnableViewState = PagesConfig.FEnableViewState;
        }
    }

    /*
     * Compile a template control (aspx or ascx) file and return its Type
     */
    private Type GetReferencedType(TemplateControlParser parser, string virtualPath) {

        // Make sure the page is never treated as a Trivial Page (ASURT bugs 8903,42166,73887)
        parser._fAlwaysCompile = true;

        string fullVirtualPath = UrlPath.Combine(BaseVirtualDir, virtualPath);
        parser.InputFile = MapPath(fullVirtualPath, false /*allowCrossAppMapping*/);

        parser.CurrentVirtualPath = fullVirtualPath;    // To get correct config settings

        parser.Context = Context;
        parser._circularReferenceChecker = _circularReferenceChecker; // To fix ASURT 30990

        // Perform the compilation
        ParserCacheItem cacheItem = parser.GetParserCacheItemWithNewConfigPath();
        Debug.Assert(cacheItem.type != null);

        // Add a dependency on the created Type
        AddTypeDependency(cacheItem.type);

        // Add a dependency on the cache sources used to cache the created Type
        AddSourceDependencies(parser.SourceDependencies);

        return cacheItem.type;
    }

    /*
     * Compile a nested .ascx file (a User Control) and return its Type
     */
    private Type GetUserControlType(string virtualPath) {
        UserControlParser.CheckUserControlFileExtension(virtualPath);

        if (FInDesigner) {
            return typeof(UserControl);
        }
        return GetReferencedType(new UserControlParser(), virtualPath);
    }

    /*
     * Compile a .aspx file and return its Type
     */
    private Type GetReferencedPageType(string virtualPath) {
        return GetReferencedType(new PageParser(), virtualPath);
    }

    internal override void ProcessDirective(string directiveName, IDictionary directive) {

        if (string.Compare(directiveName, "outputcache", true, CultureInfo.InvariantCulture) == 0) {

            // Make sure the outputcache directive was not already specified
            if (_outputCacheDirective != null) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Only_one_directive_allowed, directiveName));
            }

            ProcessOutputCacheDirective(directiveName, directive);

            _outputCacheDirective = directive;
        }
        else if (string.Compare(directiveName, "register", true, CultureInfo.InvariantCulture) == 0) {
            // Register directive

            // Optionally, allow an assembly, which is used by the designer
            string assemblyName = Util.GetAndRemoveNonEmptyAttribute(directive, "assembly");
            Assembly assembly = null;
            if (assemblyName != null) {
                assembly = AddAssemblyDependency(assemblyName);

                if (assembly == null) {
                    // It should never be null at runtime, since it throws
                    Debug.Assert(FInDesigner, "FInDesigner");

                    // Just ignore the directive (ASURT 100454)
                    return;
                }
            }

            // Get the tagprefix, which is required
            string prefix = Util.GetAndRemoveNonEmptyIdentifierAttribute(directive, "tagprefix");
            if (prefix == null) {
                throw new HttpException(HttpRuntime.FormatResourceString(
                    SR.Missing_attr, "tagprefix"));
            }

            string tagName = Util.GetAndRemoveNonEmptyIdentifierAttribute(directive, "tagname");
            string src = Util.GetAndRemoveNonEmptyAttribute(directive, "src");
            string ns = Util.GetAndRemoveNonEmptyNoSpaceAttribute(directive, "namespace");

            if (tagName != null) {
                // If tagname was specified, 'src' is required
                if (src == null) {
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Missing_attr, "src"));
                }

                EnsureNullAttribute("namespace", ns);
            }
            else {
                // If tagname was NOT specified, 'namespace' is required    
                if (ns == null) {
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Missing_attr, "namespace"));
                }

                // Assembly is also required (ASURT 61326)
                if (assembly == null) {
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Missing_attr, "assembly"));
                }

                EnsureNullAttribute("src", src);
            }

            // If there are some attributes left, fail
            Util.CheckUnknownDirectiveAttributes(directiveName, directive);

            // Is it a single tag to .aspx file mapping?
            if (tagName != null) {
                // Compile it into a Type
                Type type = GetUserControlType(src);

                // Register the new tag, including its prefix
                RootBuilder.RegisterTag(prefix + ":" + tagName, type);

                return;
            }

            AddImportEntry(ns);

            // If there is a prefix, register the namespace to allow tags with
            // that prefix to be created.
            RootBuilder.RegisterTagPrefix(prefix, ns, assembly);
        }
        else if (string.Compare(directiveName, "reference", true, CultureInfo.InvariantCulture) == 0) {

            string page = Util.GetAndRemoveNonEmptyNoSpaceAttribute(directive, "page");
            string control = Util.GetAndRemoveNonEmptyNoSpaceAttribute(directive, "control");

            // If neither or both are specified, fail
            if ((page == null) == (control == null)) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_reference_directive));
            }

            if (page != null)
                GetReferencedPageType(page);

            if (control != null)
                GetUserControlType(control);

            // If there are some attributes left, fail
            Util.CheckUnknownDirectiveAttributes(directiveName, directive);
        }
        else {
            base.ProcessDirective(directiveName, directive);
        }
    }

    internal override void ProcessMainDirective(IDictionary mainDirective) {

        // Ignore 'targetschema' attribute (ASURT 85670)
        mainDirective.Remove("targetschema");

        Util.GetAndRemoveBooleanAttribute(mainDirective, "enableviewstate",
            ref _fEnableViewState);

        Util.GetAndRemoveBooleanAttribute(mainDirective, "autoeventwireup",
            ref _fAutoEventWireup);

        base.ProcessMainDirective(mainDirective);
    }

    /*
     * Add assembly dependencies for a collection of static objects
     */
    private void AddStaticObjectAssemblyDependencies(HttpStaticObjectsCollection staticObjects) {
        if (staticObjects == null || staticObjects.Objects == null) return;

        IDictionaryEnumerator en = staticObjects.Objects.GetEnumerator();
        while (en.MoveNext()) {
            HttpStaticObjectsEntry entry = (HttpStaticObjectsEntry)en.Value;

            AddTypeDependency(entry.ObjectType);
        }
    }

    internal override void HandlePostParse() {
        base.HandlePostParse();

        if (!FInDesigner) {
            // Omit AutoEventWireup if there can't possibly be any events defined (ASURT 97772)
            if (ScriptList.Count == 0 && BaseType == DefaultBaseType)
                _fAutoEventWireup = false;

            _applicationObjects = Context.Application.StaticObjects;
            AddStaticObjectAssemblyDependencies(_applicationObjects);

            _sessionObjects = Context.Application.SessionStaticObjects;
            AddStaticObjectAssemblyDependencies(_sessionObjects);

            // If using a mobile base class, add the namespace (ASURT 121598)
            if (_mobileAssembly != null) {
                if (_mobilePageType.IsAssignableFrom(BaseType) || _mobileUserControlType.IsAssignableFrom(BaseType)) {
                    AddImportEntry("System.Web.UI.MobileControls");
                }
            }
        }
    }

    /*
     * Process the contents of the <%@ OutputCache ... %> directive
     */
    internal virtual void ProcessOutputCacheDirective(string directiveName, IDictionary directive) {

        bool fHasDuration = Util.GetAndRemovePositiveIntegerAttribute(directive, "duration", ref _duration);

        if (!fHasDuration && FDurationRequiredOnOutputCache)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Missing_attr, "duration"));

        _varyByCustom = Util.GetAndRemoveNonEmptyAttribute(directive, "varybycustom");

        _varyByParams = Util.GetAndRemoveNonEmptyAttribute(directive, "varybyparam");

        // VaryByParams is required (ASURT 76763)
        if (_varyByParams == null && FVaryByParamsRequiredOnOutputCache)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Missing_varybyparam_attr));

        // If it's "none", set it to null
        if (string.Compare(_varyByParams, "none", true, CultureInfo.InvariantCulture) == 0)
            _varyByParams = null;

        // If there are some attributes left, fail
        Util.CheckUnknownDirectiveAttributes(directiveName, directive);
    }

    internal virtual bool FDurationRequiredOnOutputCache {
        get { return true; }
    }

    internal virtual bool FVaryByParamsRequiredOnOutputCache {
        get { return true; }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\usercontrolparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="UserControlParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Implements the ASP.NET template parser
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

// Turn this on to do regex profiling
//#define PROFILE_REGEX

// Turn this on to run regex's in interpreted (non-compiled) mode
//#define INTERPRETED_REGEX

namespace System.Web.UI {

using System;
using System.Collections;
using System.IO;
using System.Security;
using System.Security.Permissions;
using System.Web.Compilation;
using System.Globalization;


/*
 * Parser for declarative controls
 */
internal sealed class UserControlParser : TemplateControlParser {

    private string _varyByControls;
    internal string VaryByControls { get { return _varyByControls; } }

    private bool _fSharedPartialCaching;
    internal bool FSharedPartialCaching { get { return _fSharedPartialCaching ; } }

    /*
     * Make sure a user control file name has the required extension
     */
    internal static void CheckUserControlFileExtension(string fileName) {

        string extension = Path.GetExtension(fileName);

        if (string.Compare(extension, ".ascx", true, CultureInfo.InvariantCulture) != 0) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Bad_usercontrol_ext));
        }
    }

    /*
     * Compile an .ascx file into a UserControl derived Type
     */
    internal static Type GetCompiledUserControlType(string virtualPath,
        string inputFile, HttpContext context) {

        CheckUserControlFileExtension(virtualPath);

        // We need unrestricted permission to process the UserControl file
        InternalSecurityPermissions.Unrestricted.Assert();

        UserControlParser parser = new UserControlParser();

        Type t = null;

        // Suspend client impersonation (for compilation)
        HttpContext.ImpersonationSuspendContext ictx = context.Impersonation.SuspendIfClient();

        try {
            try {
                t = parser.GetCompiledType(virtualPath, inputFile, context);
            }
            finally {
                // Resume client impersonation
                ictx.Resume();
            }
        }
        catch { throw; }    // Prevent Exception Filter Security Issue (ASURT 122835)

        return t;
    }

    internal UserControlParser() {
        // Make sure UserControls are never treated as TrivialPages (bugs 8903, 42166)
        _fAlwaysCompile = true;
    }

    // Get default settings from config
    internal override void ProcessConfigSettings() {
        base.ProcessConfigSettings();

        if (PagesConfig != null) {
            if (PagesConfig.UserControlBaseType != null)
                BaseType = PagesConfig.UserControlBaseType;
        }
    }

    protected override Type CompileIntoType() {
        return UserControlCompiler.CompileUserControlType(this);
    }

    internal override Type DefaultBaseType { get { return typeof(System.Web.UI.UserControl); } }

    internal const string defaultDirectiveName = "control";
    internal override string DefaultDirectiveName {
        get { return defaultDirectiveName; }
    }

    /*
     * Process the contents of the <%@ OutputCache ... %> directive
     */
    internal override void ProcessOutputCacheDirective(string directiveName, IDictionary directive) {

        _varyByControls = Util.GetAndRemoveNonEmptyAttribute(directive, "varybycontrol");

        Util.GetAndRemoveBooleanAttribute(directive, "shared", ref _fSharedPartialCaching);

        base.ProcessOutputCacheDirective(directiveName, directive);
    }

    internal override bool FVaryByParamsRequiredOnOutputCache {
        get { return _varyByControls == null; }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\validationpropertyattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidationPropertyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Security.Permissions;


    /// <include file='doc\ValidationPropertyAttribute.uex' path='docs/doc[@for="ValidationPropertyAttribute"]/*' />
    /// <devdoc>
    ///    <para>Identifies the validation property for a component.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class ValidationPropertyAttribute : Attribute {
        /// <include file='doc\ValidationPropertyAttribute.uex' path='docs/doc[@for="ValidationPropertyAttribute.name"]/*' />
        /// <devdoc>
        ///  This is the validation event name.
        /// </devdoc>
        private readonly string name;

        /// <include file='doc\ValidationPropertyAttribute.uex' path='docs/doc[@for="ValidationPropertyAttribute.ValidationPropertyAttribute"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.ValidationPropertyAttribute'/> class.</para>
        /// </devdoc>
        public ValidationPropertyAttribute(string name) {
            this.name = name;
        }

        /// <include file='doc\ValidationPropertyAttribute.uex' path='docs/doc[@for="ValidationPropertyAttribute.Name"]/*' />
        /// <devdoc>
        ///    <para>Indicates the name the specified validation attribute. This property is 
        ///       read-only.</para>
        /// </devdoc>
        public string Name {
           get {
                return name;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\usercontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="UserControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Page class definition
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web.UI {

using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.ComponentModel.Design.Serialization;
using System.Web.SessionState;
using System.Web.Caching;

using Debug = System.Diagnostics.Debug;
using System.Security.Permissions;

/// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControlControlBuilder"]/*' />
/// <devdoc>
///   <para>The ControlBuilder associated with a UserControl. If you want a custom ControlBuilder for your
///     derived UserControl, you should derive it from UserControlControlBuilder.
///   </para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public class UserControlControlBuilder : ControlBuilder {

    private string _innerText;

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControlControlBuilder.BuildObject"]/*' />
    /// <internalonly/>
    internal override object BuildObject() {
        object o = base.BuildObject();

        if (InDesigner) {
            IUserControlDesignerAccessor designerAccessor = (IUserControlDesignerAccessor)o;
            
            designerAccessor.TagName = TagName;
            if (_innerText != null) {
                designerAccessor.InnerText = _innerText;
            }
        }
        return o;
    }

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControlControlBuilder.NeedsTagInnerText"]/*' />
    /// <internalonly/>
    public override bool NeedsTagInnerText() {
        // in design-mode, we need to hang on to the inner text
        return InDesigner;
    }

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControlControlBuilder.SetTagInnerText"]/*' />
    /// <internalonly/>
    public override void SetTagInnerText(string text) {
        Debug.Assert(InDesigner == true, "Should only be called in design-mode!");
        _innerText = text;
    }
}

/// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl"]/*' />
/// <devdoc>
///    <para>This class is not marked as abstract, because the VS designer
///          needs to instantiate it when opening .ascx files</para> 
/// </devdoc>
[
ControlBuilder(typeof(UserControlControlBuilder)),
DefaultEvent("Load"),
Designer("System.Web.UI.Design.UserControlDesigner, " + AssemblyRef.SystemDesign, typeof(IDesigner)),
Designer("Microsoft.VSDesigner.WebForms.WebFormDesigner, " + AssemblyRef.MicrosoftVSDesigner, typeof(IRootDesigner)),
DesignerCategory("ASPXCodeBehind"),
ParseChildren(true),
RootDesignerSerializer("Microsoft.VSDesigner.WebForms.RootCodeDomSerializer, " + AssemblyRef.MicrosoftVSDesigner, "System.ComponentModel.Design.Serialization.CodeDomSerializer, " + AssemblyRef.SystemDesign, true),
ToolboxItem(false)
]
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public class UserControl : TemplateControl, IAttributeAccessor, IUserControlDesignerAccessor {

    private StateBag attributeStorage;
    private AttributeCollection attributes;

    private bool _fUserControlInitialized;

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.Attributes"]/*' />
    /// <devdoc>
    ///    <para>Gets the collection of attribute name/value pairs expressed on a UserControl but
    ///       not supported by the control's strongly typed properties.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public AttributeCollection Attributes {
        get {
            if (attributes == null) {
                if (attributeStorage == null) {
                    attributeStorage = new StateBag(true);
                    if (IsTrackingViewState) {
                        attributeStorage.TrackViewState();
                    }
                }
                attributes = new AttributeCollection(attributeStorage);
            }
            return attributes;
        }
    }

    // Delegate most things to the Page

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.Application"]/*' />
    /// <devdoc>
    /// <para>Gets the <see langword='Application'/> object provided by 
    ///    the HTTP Runtime.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public HttpApplicationState Application { get { return Page.Application;} }

    /*
     * Trace context for output of useful information to page during development
     */
    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.Trace"]/*' />
    /// <devdoc>
    /// <para>Indicates the <see cref='System.Web.TraceContext'/> object for the current Web 
    ///    request. Tracing tracks and presents the execution details about a Web request.
    ///    For trace data to be visible in a rendered page, you must turn tracing on for
    ///    that page. This property is read-only.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public TraceContext Trace { get { return Page.Trace; } }

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.Request"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Gets the <see langword='Request'/> object provided by the HTTP Runtime, which
    ///       allows developers to access data from incoming HTTP requests.
    ///    </para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public HttpRequest Request { get { return Page.Request; } }

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.Response"]/*' />
    /// <devdoc>
    /// <para>Gets the <see langword='Response '/>object provided by the HTTP Runtime, which
    ///    allows developers to send HTTP response data to a client browser.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public HttpResponse Response { get { return Page.Response; } }

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.Server"]/*' />
    /// <devdoc>
    /// <para>Gets the ASP-compatible <see langword='Server'/> object.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public HttpServerUtility Server { get { return Page.Server; } }

    /*
     * Cache intrinsic
     */
    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.Cache"]/*' />
    /// <devdoc>
    /// <para>Retrieves a <see langword='Cache'/> 
    /// object in which to store the user control's data for
    /// subsequent requests. This property is read-only.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public Cache Cache { get { return Page.Cache; } }

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.IsPostBack"]/*' />
    /// <devdoc>
    ///    <para>Gets a value indicating whether the user control is being loaded in response to a
    ///       client postback, or if it is being loaded and accessed for the first time.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public bool IsPostBack { get { return Page.IsPostBack; } }

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.Session"]/*' />
    /// <devdoc>
    /// <para>Gets the <see langword='Session '/> object provided by the HTTP Runtime.</para>
    /// </devdoc>
    [
    Browsable(false),
    DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
    ]
    public HttpSessionState Session { get { return Page.Session; } }

    /*
     * Performs intialization of the control required by the designer.
     */
    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.DesignerInitialize"]/*' />
    /// <devdoc>
    ///    <para>Performs any initialization of the control that is required by RAD designers.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public void DesignerInitialize() {
        InitRecursive(null);
    }

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.OnInit"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected override void OnInit(EventArgs e) {

        // We want to avoid calling this when the user control is being used in the designer,
        // regardless of whether it is a top-level control (Site.DesignMode == true),
        // or if its inside another control in design-mode (Page.Site.DesignMode == true)

        bool designTime = ((Site != null) && Site.DesignMode);
        if (designTime == false) {
            if ((Page != null) && (Page.Site != null)) {
                designTime = Page.Site.DesignMode;
            }
        }

        if (designTime == false) {
            InitializeAsUserControlInternal();
        }

        base.OnInit(e);
    }

    /*
     * Called on declarative controls to initialize them correctly
     */
    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.InitializeAsUserControl"]/*' />
    /// <devdoc>
    /// <para>Initializes the <see langword='UserControl'/> object. Since there are some 
    ///    differences between pages and user controls, this method makes sure that the
    ///    user control is initialized properly.</para>
    /// </devdoc>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public void InitializeAsUserControl(Page page) {

        _page = page;

        InitializeAsUserControlInternal();
    }

    private void InitializeAsUserControlInternal() {

        // Make sure we only do this once
        if (_fUserControlInitialized)
            return;
        _fUserControlInitialized = true;

        // Hook up any automatic handler we may find (e.g. Page_Load)
        HookUpAutomaticHandlers();

        // Initialize the object and instantiate all the controls defined in the ascx file
        FrameworkInitialize();
    }

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.LoadViewState"]/*' />
    protected override void LoadViewState(object savedState) {
        if (savedState != null) {
            Pair myState = (Pair)savedState;
            base.LoadViewState(myState.First);

            if (myState.Second != null) {
                if (attributeStorage == null) {
                    attributeStorage = new StateBag(true);
                    attributeStorage.TrackViewState();
                }
                attributeStorage.LoadViewState(myState.Second);
            }
        }
    }

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.SaveViewState"]/*' />
    protected override object SaveViewState() {
        Pair myState = null;

        object baseState = base.SaveViewState();
        object attrState = null;
        if (attributeStorage != null) {
            attrState = attributeStorage.SaveViewState();
        }

        if (baseState != null || attrState != null) {
            myState = new Pair(baseState, attrState);
        }
        return myState;
    }


    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.IAttributeAccessor.GetAttribute"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// Returns the attribute value of the UserControl having
    /// the specified attribute name.
    /// </devdoc>
    string IAttributeAccessor.GetAttribute(string name) {
        return ((attributeStorage != null) ? (string)attributeStorage[name] : null);
    }

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.IAttributeAccessor.SetAttribute"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// <para>Sets an attribute of the UserControl with the specified
    /// name and value.</para>
    /// </devdoc>
    void IAttributeAccessor.SetAttribute(string name, string value) {
        Attributes[name] = value;
    }

    /*
     * Map virtual path (absolute or relative) to physical path
     */
    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.MapPath"]/*' />
    /// <devdoc>
    ///    <para>Assigns a virtual path, either absolute or relative, to a physical path.</para>
    /// </devdoc>
    public string MapPath(string virtualPath) {
        return Request.MapPath(virtualPath, TemplateSourceDirectory,
            true/*allowCrossAppMapping*/);
    }

    string IUserControlDesignerAccessor.TagName {
        get {
            string text = (string)ViewState["!DesignTimeTagName"];
            if (text == null) {
                return String.Empty;
            }
            return text;
        }
        set {
            ViewState["!DesignTimeTagName"] = value;
        }
    }

    string IUserControlDesignerAccessor.InnerText {
        get {
            string text = (string)ViewState["!DesignTimeInnerText"];
            if (text == null) {
                return String.Empty;
            }
            return text;
        }
        set {
            ViewState["!DesignTimeInnerText"] = value;
        }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\validatorcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidatorCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI {
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Security.Permissions;

    /// <include file='doc\ValidatorCollection.uex' path='docs/doc[@for="ValidatorCollection"]/*' />
    /// <devdoc>
    ///    <para> Exposes a 
    ///       read-only array of <see cref='System.Web.UI.IValidator'/>
    ///       references.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class ValidatorCollection : ICollection {
        private ArrayList data;


        /// <include file='doc\ValidatorCollection.uex' path='docs/doc[@for="ValidatorCollection.ValidatorCollection"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.ValidatorCollection'/> class.</para>
        /// </devdoc>
        public ValidatorCollection() {
            data = new ArrayList();
        }

        /// <include file='doc\ValidatorCollection.uex' path='docs/doc[@for="ValidatorCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Indicates the number of references in the collection. 
        ///       This property is read-only.</para>
        /// </devdoc>
        public int Count {
            get {
                return data.Count;
            }
        }

        /// <include file='doc\ValidatorCollection.uex' path='docs/doc[@for="ValidatorCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Indicates the validator at the specified index. This 
        ///       property is read-only.</para>
        /// </devdoc>
        public IValidator this[int index] {
            get { 
                return(IValidator) data[index];
            }
        }

        /// <include file='doc\ValidatorCollection.uex' path='docs/doc[@for="ValidatorCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds the specified validator to the collection.</para>
        /// </devdoc>
        public void Add(IValidator validator) {
            data.Add(validator);
        }

        /// <include file='doc\ValidatorCollection.uex' path='docs/doc[@for="ValidatorCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>Returns whether the specified validator exists in the collection.</para>
        /// </devdoc>
        public bool Contains(IValidator validator) {
            return data.Contains(validator);
        }

        /// <include file='doc\ValidatorCollection.uex' path='docs/doc[@for="ValidatorCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>Removes the specified validator from the collection.</para>
        /// </devdoc>
        public void Remove(IValidator validator) {
            data.Remove(validator);
        }

        /// <include file='doc\ValidatorCollection.uex' path='docs/doc[@for="ValidatorCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>Gets an enumerator that iterates over the collection.</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return data.GetEnumerator();
        }        


        /// <include file='doc\ValidatorCollection.uex' path='docs/doc[@for="ValidatorCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>Copies a validator to the specified collection and location.</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\ValidatorCollection.uex' path='docs/doc[@for="ValidatorCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>Indicates an object that can be used to synchronize the 
        ///    <see cref='System.Web.UI.ValidatorCollection'/> . 
        ///       This property is read-only.</para>
        /// </devdoc>
        public Object SyncRoot {
            get { return this;}
        }

        /// <include file='doc\ValidatorCollection.uex' path='docs/doc[@for="ValidatorCollection.IsReadOnly"]/*' />
        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Web.UI.ValidatorCollection'/> is read-only. This property is 
        ///    read-only.</para>
        /// </devdoc>
        public bool IsReadOnly {
            get { return false;}
        }

        /// <include file='doc\ValidatorCollection.uex' path='docs/doc[@for="ValidatorCollection.IsSynchronized"]/*' />
        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Web.UI.ValidatorCollection'/> is synchronized 
        ///    (thread-safe). This property is read-only.</para>
        /// </devdoc>
        public bool IsSynchronized {
            get { return false;}
        }

    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlanchor.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlAnchor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlAnchor.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {
    using System.ComponentModel;
    using System;
    using System.Collections;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\HtmlAnchor.uex' path='docs/doc[@for="HtmlAnchor"]/*' />
    /// <devdoc>
    /// <para>The <see langword='HtmlAnchor'/>
    /// class defines the methods, properties, and
    /// events for the HtmlAnchor control.
    /// This
    /// class
    /// allows programmatic access to the
    /// HTML &lt;a&gt; element on the server.</para>
    /// </devdoc>
    [
    DefaultEvent("ServerClick")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlAnchor : HtmlContainerControl, IPostBackEventHandler {

        private static readonly object EventServerClick = new object();

        /*
         *  Creates an intrinsic Html A control.
         */
        /// <include file='doc\HtmlAnchor.uex' path='docs/doc[@for="HtmlAnchor.HtmlAnchor"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.HtmlControls.HtmlAnchor'/> class.</para>
        /// </devdoc>
        public HtmlAnchor() : base("a") {
        }

        /*
         * Href property.
         */
        /// <include file='doc\HtmlAnchor.uex' path='docs/doc[@for="HtmlAnchor.HRef"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the URL target of the link specified in the 
        ///    <see cref='System.Web.UI.HtmlControls.HtmlAnchor'/>
        ///    server control.</para>
        /// </devdoc>
        [
        WebCategory("Navigation"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string HRef {
            get {
                string s = Attributes["href"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["href"] = MapStringAttributeToString(value);
            }
        }

        /*
         * Name of group this radio is in.
         */
        /// <include file='doc\HtmlAnchor.uex' path='docs/doc[@for="HtmlAnchor.Name"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the bookmark name defined in the <see cref='System.Web.UI.HtmlControls.HtmlAnchor'/>
        /// server
        /// control.</para>
        /// </devdoc>
        [
        WebCategory("Navigation"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Name {
            get {
                string s = Attributes["name"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["name"] = MapStringAttributeToString(value);
            }
        }

        /*
         * Target window property.
         */
        /// <include file='doc\HtmlAnchor.uex' path='docs/doc[@for="HtmlAnchor.Target"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the target window or frame
        ///       to load linked Web page content into.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Navigation"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Target {
            get {
                string s = Attributes["target"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["target"] = MapStringAttributeToString(value);
            }
        }

        /*
         * Title property.
         */
        /// <include file='doc\HtmlAnchor.uex' path='docs/doc[@for="HtmlAnchor.Title"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the title that
        ///       the browser displays when identifying linked content.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Title {
            get {
                string s = Attributes["title"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["title"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlAnchor.uex' path='docs/doc[@for="HtmlAnchor.ServerClick"]/*' />
        /// <devdoc>
        /// <para>Occurs on the server when a user clicks the <see cref='System.Web.UI.HtmlControls.HtmlAnchor'/> control on the
        ///    browser.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.HtmlAnchor_OnServerClick)
        ]
        public event EventHandler ServerClick {
            add {
                Events.AddHandler(EventServerClick, value);
            }
            remove {
                Events.RemoveHandler(EventServerClick, value);
            }
        }

        /// <include file='doc\HtmlAnchor.uex' path='docs/doc[@for="HtmlAnchor.OnPreRender"]/*' />
        /// <internalonly/>
        protected override void OnPreRender(EventArgs e) {
            base.OnPreRender(e);
            if (Page != null && Events[EventServerClick] != null)
                Page.RegisterPostBackScript();
        }

        /*
         * Override to generate postback code for onclick.
         */
        /// <include file='doc\HtmlAnchor.uex' path='docs/doc[@for="HtmlAnchor.RenderAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderAttributes(HtmlTextWriter writer) {
            if (Events[EventServerClick] != null) {
                Attributes.Remove("href");
                base.RenderAttributes(writer);
                writer.WriteAttribute("href", Page.GetPostBackClientHyperlink(this, ""));
            }
            else {
                PreProcessRelativeReferenceAttribute(writer, "href");
                base.RenderAttributes(writer);
            }
        }

        /*
         * Method used to raise the OnServerClick event.
         */
        /// <include file='doc\HtmlAnchor.uex' path='docs/doc[@for="HtmlAnchor.OnServerClick"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='ServerClick'/>
        /// event.</para>
        /// </devdoc>
        protected virtual void OnServerClick(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventServerClick];
            if (handler != null) handler(this, e);
        }

        /*
         * Method of IPostBackDataHandler interface to raise events on post back.
         * Button fires an OnServerClick event.
         */
        /// <include file='doc\HtmlAnchor.uex' path='docs/doc[@for="HtmlAnchor.IPostBackEventHandler.RaisePostBackEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        void IPostBackEventHandler.RaisePostBackEvent(string eventArgument) {
            OnServerClick(EventArgs.Empty);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\util.cs ===
//------------------------------------------------------------------------------
// <copyright file="Util.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Implements various utility functions used by the template code
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web.UI {
using System.Text;
using System.Runtime.Serialization.Formatters;

using System;
using System.IO;
using System.Collections;
using System.Reflection;
using System.Globalization;
using System.Text.RegularExpressions;
using System.Web.Util;
using System.Web.Configuration;

internal class Util {

    private Util() {
    }

#if UNUSED
    /*
     *  Return a String which holds the contents of a TextReader
     */
    public static String StringFromReader(TextReader input) {
        char[] buffer = new char[4096];
        int bufferpos = 0;
        int delta;

        for (;;) {
            delta = input.Read(buffer, bufferpos, buffer.Length - bufferpos);

            if (delta == 0)
                break;

            bufferpos += delta;

            if (bufferpos == buffer.Length) {
                char[] newbuf = new char[buffer.Length * 2];
                System.Array.Copy(buffer, 0, newbuf, 0, buffer.Length);
                buffer = newbuf;
            }
        }

        return new String(buffer, 0, bufferpos);
    }
#endif

    /*
     * Return a reader which holds the contents of a file.  If a context is passed
     * in, try to get a config encoding from it (use the configPath if provided)
     */
    internal /*public*/ static TextReader ReaderFromFile(string filename, HttpContext context,
        string configPath) {

        TextReader reader;

        // Check if a file encoding is specified in the config
        Encoding fileEncoding = null;
        if (context != null) {
            GlobalizationConfig globConfig;
            if (configPath == null)
                globConfig = (GlobalizationConfig)context.GetConfig("system.web/globalization");
            else
                globConfig = (GlobalizationConfig)context.GetConfig("system.web/globalization", configPath);
            if (globConfig != null)
                fileEncoding = globConfig.FileEncoding;
        }

        // If not, use the default encoding
        if (fileEncoding == null)
            fileEncoding = Encoding.Default;

        try {
            // Create a reader on the file, using the encoding
            // Throws an exception if the file can't be opened.
            reader = new StreamReader(filename, fileEncoding, true /*detectEncodingFromByteOrderMarks*/, 4096);
        }
        catch (UnauthorizedAccessException) {
            // AccessException might mean two very different things: it could be a real
            // access problem, or it could be that it's actually a directory.

            // It's a directory: give a specific error.
            if (FileUtil.DirectoryExists(filename)) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Unexpected_Directory, HttpRuntime.GetSafePath(filename)));
            }

            // It's a real access problem, so just rethrow it
            throw;
        }

        return reader;
    }


    internal static string GetScriptLocation(HttpContext context) {
        // prepare script include
        string location = null;
        IDictionary webControlsConfig = (IDictionary)context.GetConfig("system.web/webControls");
        if (webControlsConfig != null) {
            location = (string)webControlsConfig["clientScriptsLocation"];
        }

        if (location == null)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Missing_clientScriptsLocation));

        // If there is a formatter, as there will be for the default machine.config, insert the assembly name and version.
        if (location.IndexOf("{0}") >= 0) {
            string assembly = "system_web";
            string version = VersionInfo.IsapiVersion.Substring(0, VersionInfo.IsapiVersion.LastIndexOf('.')).Replace('.', '_');
            location = String.Format(location, assembly, version);
        }
        return location;
    }


    /*
     * Return a String which holds the contents of a file.  If a context is passed
     * in, try to get a config encoding from it.
     */
    internal /*public*/ static String StringFromFile(string path, HttpContext context) {
        // Create a reader on the file.
        // Generates an exception if the file can't be opened.
        TextReader reader = ReaderFromFile(path, context, null);

        try {
            return reader.ReadToEnd();
        }
        finally {
            // Make sure we always close the stream
            if (reader != null)
                reader.Close();
        }
    }

    /*
     * Return a String which holds the contents of a file
     */
    internal /*public*/ static String StringFromFile(string path) {
        // Create a reader on the file.
        // Generates an exception if the file can't be opened.
        StreamReader reader = new StreamReader(path);

        try {
            return reader.ReadToEnd();
        }
        finally {
            // Make sure we always close the stream
            if (reader != null)
                reader.Close();
        }
    }

    /*
     * Check if a file exists, and if it does, return its name with the correct
     * case (ASURT 59179)
     */
    internal /*public*/ static string CheckExistsAndGetCorrectCaseFileName(string filename) {
        FileInfo fi = new FileInfo(filename);

        // Get the directory containing the file
        DirectoryInfo di = new DirectoryInfo(fi.DirectoryName);

        // Find our file in the directory
        FileInfo[] fis;
        try {
            fis = di.GetFiles(fi.Name);
        }
        catch (Exception) {
            // Directory doesn't exist
            return null;
        }

        // File doesn't exist
        if (fis.Length != 1)
            return null;

        // Get its 'correct' name
        return fis[0].FullName;
    }

    internal static void CheckAssignableType(Type baseType, Type type) {
        if (!baseType.IsAssignableFrom(type)) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Type_doesnt_inherit_from_type,
                    type.FullName, baseType.FullName));
        }
    }

    internal /*public*/ static int LineCount(string text, int offset, int newoffset) {
        int linecount = 0;

        if (newoffset < offset) {
            while (newoffset < offset) {
                offset--;

                if (text[offset] == '\r' || (text[offset] == '\n' && (offset == 0 || text[offset - 1] != '\r')))
                    linecount--;
            }

            return linecount;
        }

        while (offset < newoffset) {
            if (text[offset] == '\r' || (text[offset] == '\n' && (offset == 0 || text[offset - 1] != '\r')))
                linecount++;
            offset++;
        }

        return linecount;
    }

    internal /*public*/ static string QuoteXMLValue(string unquoted) {
        StringBuilder result;

        if (unquoted.IndexOf("&<>\"") >= 0) {
            result = new StringBuilder(unquoted);
            result.Replace("&", "&amp;");
            result.Replace("<", "&lt;");
            result.Replace(">", "&gt;");
            result.Replace("'", "&apos;");
            result.Replace("\"", "&quot;");
            
            return "\"" + result.ToString() + "\"";
        }

        return "\"" + unquoted + "\"";
    }

    /*
     * Calls Invoke on a MethodInfo.  If an exception happens during the
     * method call, catch it and throw it back.
     */
    internal static object InvokeMethod(
                                       MethodInfo methodInfo,
                                       object obj,
                                       object[] parameters) {
        try {
            return methodInfo.Invoke(obj, parameters);
        }
        catch (TargetInvocationException e) {
            throw e.InnerException;
        }
    }

    /*
     * If the passed in Type has a non-private field with the passed in name,
     * return the field's Type.
     */
    internal static Type GetNonPrivateFieldType(Type classType, string fieldName) {
        FieldInfo fieldInfo = classType.GetField(fieldName,
            BindingFlags.IgnoreCase | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);

        if (fieldInfo == null || fieldInfo.IsPrivate)
            return null;
        
        return fieldInfo.FieldType;
    }

    /*
     * If the passed in Type has a non-private property with the passed in name,
     * return the property's Type.
     */
    internal static Type GetNonPrivatePropertyType(Type classType, string propName) {
        PropertyInfo propInfo = classType.GetProperty(propName,
            BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static
            | BindingFlags.IgnoreCase 
            | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);

        if (propInfo == null)
            return null;

        // If it doesn't have a setter, ot if it's private, fail
        MethodInfo methodInfo = propInfo.GetSetMethod(true /*nonPublic*/);
        if (methodInfo == null || methodInfo.IsPrivate)
            return null;

        return propInfo.PropertyType;
    }

    /*
     * Return the first key of the dictionary as a string.  Throws if it's
     * empty or if the key is not a string.
     */
    internal static string FirstDictionaryKey(IDictionary dict) {
        IDictionaryEnumerator e = dict.GetEnumerator();
        e.MoveNext();
        return (string)e.Key;
    }

    /*
     * Get a value from a dictionary, and remove it from the dictionary if
     * it exists.
     */
    internal static string GetAndRemove(IDictionary dict, string key) {
        string val = (string) dict[key];
        if (val != null)
            dict.Remove(key);
        return val;
    }

    /*
     * Get a value from a dictionary, and remove it from the dictionary if
     * it exists.  Throw an exception if the value is a whitespace string.
     * However, don't complain about null, which simply means the value is not
     * in the dictionary.
     */
    internal static string GetAndRemoveNonEmptyAttribute(IDictionary directives, string key) {
        string val = Util.GetAndRemove(directives, key);

        if (val == null)
            return null;

        val = val.Trim();

        if (val.Length == 0) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Empty_attribute, key));
        }

        return val;
    }

    internal static string GetAndRemoveRequiredAttribute(IDictionary directives, string key) {
        string val = GetAndRemoveNonEmptyAttribute(directives, key);

        if (val == null)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Missing_attr, key));

        return val;
    }

    /*
     * Same as GetAndRemoveNonEmptyAttribute, but make sure the value does not
     * contain any whitespace characters.
     */
    internal static string GetAndRemoveNonEmptyNoSpaceAttribute(IDictionary directives, string key) {
        string val = Util.GetAndRemoveNonEmptyAttribute(directives, key);

        if (val == null)
            return null;

        if (Util.ContainsWhiteSpace(val)) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Space_attribute, key));
        }

        return val;
    }

    /*
     * Same as GetAndRemoveNonEmptyNoSpaceAttribute, but make sure the value is a
     * valid language identifier
     */
    internal static string GetAndRemoveNonEmptyIdentifierAttribute(IDictionary directives, string key) {
        string val = Util.GetAndRemoveNonEmptyNoSpaceAttribute(directives, key);

        if (val == null)
            return null;

        if (!System.CodeDom.Compiler.CodeGenerator.IsValidLanguageIndependentIdentifier(val)) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Invalid_attribute_value, val, key));
        }

        return val;
    }

    internal static void CheckUnknownDirectiveAttributes(string directiveName, IDictionary directive) {

        // If there are some attributes left, fail
        if (directive.Count > 0) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Attr_not_supported_in_directive,
                    Util.FirstDictionaryKey(directive), directiveName));
        }
    }

    /*
     * Get a string value from a dictionary, and convert it to bool.  Throw an
     * exception if it's not a valid bool string.
     * However, don't complain about null, which simply means the value is not
     * in the dictionary.
     * The value is returned through a REF param (unchanged if null)
     * Return value: true if attrib exists, false otherwise
     */
    internal static bool GetAndRemoveBooleanAttribute(IDictionary directives,
                                                      string key, ref bool val) {
        string s = Util.GetAndRemove(directives, key);

        if (s == null)
            return false;

        try {
            val = bool.Parse(s);
        }
        catch (Exception) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Invalid_boolean_attribute, key));
        }

        return true;
    }

    /*
     * Get a string value from a dictionary, and convert it to integer.  Throw an
     * exception if it's not a valid positive integer string.
     * However, don't complain about null, which simply means the value is not
     * in the dictionary.
     * The value is returned through a REF param (unchanged if null)
     * Return value: true if attrib exists, false otherwise
     */
    internal static bool GetAndRemoveNonNegativeIntegerAttribute(IDictionary directives,
                                                              string key, ref int val) {
        string s = Util.GetAndRemove(directives, key);

        if (s == null)
            return false;

        try {
            val = int.Parse(s);
        }
        catch (Exception) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Invalid_nonnegative_integer_attribute, key));
        }

        // Make sure it's not negative
        if (val < 0) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Invalid_nonnegative_integer_attribute, key));
        }

        return true;
    }

    internal static bool GetAndRemovePositiveIntegerAttribute(IDictionary directives,
                                                              string key, ref int val) {
        string s = Util.GetAndRemove(directives, key);

        if (s == null)
            return false;

        try {
            val = int.Parse(s);
        }
        catch (Exception) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Invalid_positive_integer_attribute, key));
        }

        // Make sure it's positive
        if (val <= 0) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Invalid_positive_integer_attribute, key));
        }

        return true;
    }

    internal static object GetAndRemoveEnumAttribute(IDictionary directives, Type enumType,
                                                   string key) {
        string s = Util.GetAndRemove(directives, key);

        if (s == null)
            return null;

        object val;

        try {
            // Don't allow numbers to be specified (ASURT 71851)
            // Also, don't allow several values (e.g. "red,blue")
            if (Char.IsDigit(s[0]) || s[0] == '-' || s.IndexOf(',') >= 0)
                throw new FormatException(SR.GetString(SR.EnumAttributeInvalidString, s, key, enumType.FullName));

            val = Enum.Parse(enumType, s, true /*ignoreCase*/);
        }
        catch {
            string names = null;
            foreach (string name in Enum.GetNames(enumType)) {
                if (names == null)
                    names = name;
                else
                    names += ", " + name;
            }
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Invalid_enum_attribute, key, names));
        }

        return val;
    }

    /*
     * Return a string array from a Hashtable that only contains string values
     */
    internal static string[] StringArrayFromHashtable(Hashtable h)
    {
        if (h == null) return null;
        string[] ret = new string[h.Count];
        h.Values.CopyTo(ret, 0);
        return ret;
    }

#if UNUSED
    /*
     * Return a ArrayList which contains all the strings from a string array
     */
    internal static ArrayList ArrayListFromStringArray(string[] arr)
    {
        ArrayList al = new ArrayList();
        for (int i=0; i<arr.Length; i++)
            al.Add(arr[i]);

        return al;
    }
#endif

    /*
     * Return true iff the string is made of all white space characters
     */
    internal static bool IsWhiteSpaceString(string s) {
        return (s.Trim().Length == 0);
    }

    /*
     * Return true iff the string contains some white space characters
     */
    internal static bool ContainsWhiteSpace(string s) {
        for (int i=s.Length-1; i>=0; i--) {
            if (Char.IsWhiteSpace(s[i]))
                return true;
        }

        return false;
    }

    /*
     * Return the index of the first non whitespace char.  -1 if none found.
     */
    internal static int FirstNonWhiteSpaceIndex(string s) {
        for (int i=0; i<s.Length; i++) {
            if (!Char.IsWhiteSpace(s[i]))
                return i;
        }

        return -1;
    }

    /*
     * Return true iff the string holds the value "true" (case insensitive).
     * Checks for null.
     */
    internal static bool IsTrueString(string s) {
        return s != null && (string.Compare(s, "true", true, CultureInfo.InvariantCulture) == 0);
    }

    /*
     * Return true iff the string holds the value "false" (case insensitive)
     * Checks for null.
     */
    internal static bool IsFalseString(string s) {
        return s != null && (string.Compare(s, "false", true, CultureInfo.InvariantCulture) == 0);
    }

    /*
     * Return a valid type name from a string by changing any character
     * that's not a letter or a digit to an '_'.
     */
    internal static string MakeValidTypeNameFromString(string s) {
        StringBuilder sb = new StringBuilder();

        for (int i=0; i<s.Length; i++) {
            // Make sure it doesn't start with a digit (ASURT 31134)
            if (i == 0 && Char.IsDigit(s[0]))
                sb.Append('_');

            if (Char.IsLetterOrDigit(s[i]))
                sb.Append(s[i]);
            else
                sb.Append('_');
        }

        return sb.ToString();
    }

    /*
     * Return a standard path from a file:// url
     */
    internal static string FilePathFromFileUrl(string url) {

        // REVIEW: there really should be an easier way to do this!
        Uri uri=new Uri(url);
        string path = uri.LocalPath;
        return HttpUtility.UrlDecode(path);
    }

    /*
     * Check if the passed in type is for a late bound COM object.  This
     * is what we would get when calling Type.GetTypeFromProgID() on a progid
     * that has not been tlbimp'ed.
     */
    internal static bool IsLateBoundComClassicType(Type t) {
        // REVIEW: we should be able to check in a less hacky way
        return (String.Compare(t.FullName, "System.__ComObject", false, CultureInfo.InvariantCulture) == 0);
    }

    /*
     * Get the path to the (shadow copied) DLL behind an assembly
     */
    internal static string GetAssemblyCodeBase(Assembly assembly) {
        // Get the path to the assembly (from the cache if it got shadow copied)
        return assembly.GetLoadedModules()[0].FullyQualifiedName;

        // This would give the non-shadow copied path (with forward slashes)
        //return assembly.Location; 
    }

    /*
     * Return a hashtable which contains (as keys) all the assemblies that
     * are referenced by the input assembly
     */
    internal static Hashtable GetReferencedAssembliesHashtable(Assembly a) {

        Hashtable referencedAssemblies = new Hashtable();
        AssemblyName[] refs = a.GetReferencedAssemblies();

        foreach (AssemblyName aname in refs) {
            Assembly referencedAssembly = Assembly.Load(aname);

            // Ignore mscorlib
            if (referencedAssembly == typeof(string).Assembly)
                continue;

            referencedAssemblies[referencedAssembly] = null;
        }

        return referencedAssemblies;
    }

    /*
     * Return an assembly name from the name of an assembly dll.
     * Basically, it strips the extension.
     */
    internal static string GetAssemblyNameFromFileName(string fileName) {
        // Strip the .dll extension if any
        if (string.Compare(Path.GetExtension(fileName), ".dll", true, CultureInfo.InvariantCulture) == 0)
            return fileName.Substring(0, fileName.Length-4);

        return fileName;
    }

    /*
     * Return whether the type name contains an assembly (e.g. "MyType,MyAssemblyName")
     */
    internal static bool TypeNameIncludesAssembly(string typeName) {
        return (typeName.IndexOf(",") >= 0);
    }


    internal static string QuoteJScriptString(string value) {
        StringBuilder b = new StringBuilder(value.Length+5);

        for (int i=0; i<value.Length; i++) {
            switch (value[i]) {
                case '\r':
                    b.Append("\\r");
                    break;
                case '\t':
                    b.Append("\\t");
                    break;
                case '\"':
                    b.Append("\\\"");
                    break;
                case '\'':
                    b.Append("\\\'");
                    break;
                case '\\':
                    b.Append("\\\\");
                    break;
                case '\n':
                    b.Append("\\n");
                    break;
                default:
                    b.Append(value[i]);
                    break;
            }
        }

        return b.ToString();
    }

    private static ArrayList GetSpecificCultures(string shortName) {
        CultureInfo[] cultures = CultureInfo.GetCultures(CultureTypes.SpecificCultures);
        ArrayList list = new ArrayList();
        
        for (int i=0; i<cultures.Length; i++) {
            if (cultures[i].Name.StartsWith(shortName))
                list.Add(cultures[i]);
        }
        
        return list;
    }

    internal static string GetSpecificCulturesFormattedList(CultureInfo cultureInfo) {
        ArrayList myCultures = GetSpecificCultures(cultureInfo.Name);

        string s = null;
        foreach (CultureInfo culture in myCultures) {
            if (s == null)
                s = culture.Name;
            else
                s += ", " + culture.Name;
        }

        return s;
    }

    // Client Validation Utility Functions

    internal static string GetClientValidateEvent(Page page) {
        return "if (typeof(Page_ClientValidate) == 'function') Page_ClientValidate(); ";
    }

    internal static string GetClientValidatedPostback(Control control) {
        string postbackReference = control.Page.GetPostBackEventReference(control);
        return "{if (typeof(Page_ClientValidate) != 'function' ||  Page_ClientValidate()) " + postbackReference + "} ";
    }

    internal static void WriteOnClickAttribute(HtmlTextWriter writer, HtmlControls.HtmlControl control, bool submitsAutomatically, bool submitsProgramatically, bool causesValidation) {
        AttributeCollection attributes = control.Attributes;
        string injectedOnClick = null;
        if (submitsAutomatically) {
            if (causesValidation) {
                injectedOnClick = Util.GetClientValidateEvent(control.Page);
            }
        }
        else if (submitsProgramatically) {
            if (causesValidation) {
                injectedOnClick = Util.GetClientValidatedPostback(control);
            } 
            else {
                injectedOnClick = control.Page.GetPostBackClientEvent(control, "");
            }
        }
        if (injectedOnClick != null) {
            string existingLanguage = attributes["language"];
            if (existingLanguage != null) {
                attributes.Remove("language");
            }
            writer.WriteAttribute("language", "javascript");

            string existingOnClick = attributes["onclick"];
            if (existingOnClick != null) {
                attributes.Remove("onclick");
                writer.WriteAttribute("onclick", existingOnClick + " " + injectedOnClick);
            }
            else {
                writer.WriteAttribute("onclick", injectedOnClick);
            }
        }
    }



#if DBG
    internal static void DumpDictionary(string tag, IDictionary d) {
        if (d == null) return;

        Debug.Trace(tag, "Dumping IDictionary with " + d.Count + " entries:");

        for (IDictionaryEnumerator en = (IDictionaryEnumerator)d.GetEnumerator(); en.MoveNext();) {
            if (en.Value == null)
                Debug.Trace(tag, "Key='" + en.Key.ToString() + "' value=null");
            else
                Debug.Trace(tag, "Key='" + en.Key.ToString() + "' value='" + en.Value.ToString() + "'");
        }
    }

    internal static void DumpArrayList(string tag, ArrayList al) {
        if (al == null) return;

        Debug.Trace(tag, "Dumping ArrayList with " + al.Count + " entries:");

        foreach (object o in al) {
            if (o == null)
                Debug.Trace(tag, "value=null");
            else
                Debug.Trace(tag, "value='" + o.ToString() + "'");
        }
    }

    internal static void DumpString(string tag, string s) {
        Debug.Trace(tag, "Dumping string  '" + s + "':");

        StringBuilder sb = new StringBuilder();
        foreach (char c in s) {
            sb.Append(((int)c).ToString("x"));
            sb.Append(" ");
        }
        Debug.Trace(tag, sb.ToString());
    }

    internal static void DumpExceptionStack(Exception e) {
        Exception subExcep = e.InnerException;
        if (subExcep != null)
            DumpExceptionStack(subExcep);

        string title = "[" + e.GetType().Name + "]";
        if (e.Message != null && e.Message.Length > 0)
            title += ": " + e.Message;
        Debug.Trace("internal", title);
        if (e.StackTrace != null)
            Debug.Trace("internal", e.StackTrace);
    }
#endif // DBG

}

/*
 * Class used to combine several hashcodes into a single hashcode
 */
internal class HashCodeCombiner {

    // Start with a seed (obtained from JRoxe's implementation of String.GetHashCode)
    private long _combinedHash = 5381;

    internal HashCodeCombiner() {
    }

    internal void AddInt(int n) {
        _combinedHash = ((_combinedHash << 5) + _combinedHash) ^ n;
        Debug.Trace("DateTimeCombiner", "Combined hashcode: " + _combinedHash.ToString("x"));
    }

    internal void AddObject(object o) {
        if (o != null)
            AddInt(o.GetHashCode());
    }

    internal void AddCaseInsensitiveString(string s) {
        if (s != null)
            AddInt((new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture)).GetHashCode(s));
    }

    internal long CombinedHash { get { return _combinedHash; } }
    internal int CombinedHash32 { get { return _combinedHash.GetHashCode(); } }

    internal string CombinedHashString { get { return _combinedHash.ToString("x"); } }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlbutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlButton.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {
    using System.ComponentModel;
    using System;
    using System.Collections;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\HtmlButton.uex' path='docs/doc[@for="HtmlButton"]/*' />
    /// <devdoc>
    /// <para>The <see langword='HtmlButton'/> 
    /// class defines the methods, properties and events for the
    /// <see langword='HtmlButton'/>
    /// control. This
    /// class allows programmatic access to the HTML &lt;button&gt; element
    /// on the server.</para>
    /// </devdoc>
    [
    DefaultEvent("ServerClick")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlButton : HtmlContainerControl, IPostBackEventHandler {

        private static readonly object EventServerClick = new object();


        /*
         *  Creates an intrinsic Html BUTTON control.
         */
        /// <include file='doc\HtmlButton.uex' path='docs/doc[@for="HtmlButton.HtmlButton"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of a <see cref='System.Web.UI.HtmlControls.HtmlButton'/> class.</para>
        /// </devdoc>
        public HtmlButton() : base("button") {
        }

        /// <include file='doc\HtmlButton.uex' path='docs/doc[@for="HtmlButton.CausesValidation"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets whether pressing the button causes page validation to fire. This defaults to True so that when
        ///          using validation controls, the validation state of all controls are updated when the button is clicked, both
        ///          on the client and the server. Setting this to False is useful when defining a cancel or reset button on a page
        ///          that has validators.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(true),
        ]
        public bool CausesValidation {
            get {
                object b = ViewState["CausesValidation"];
                return((b == null) ? true : (bool)b);
            }
            set {
                ViewState["CausesValidation"] = value;
            }
        }

        /// <include file='doc\HtmlButton.uex' path='docs/doc[@for="HtmlButton.ServerClick"]/*' />
        /// <devdoc>
        /// <para>Occurs when the user clicks an <see cref='System.Web.UI.HtmlControls.HtmlButton'/> control on the
        ///    browser.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.HtmlButton_OnServerClick)
        ]
        public event EventHandler ServerClick {
            add {
                Events.AddHandler(EventServerClick, value);
            }
            remove {
                Events.RemoveHandler(EventServerClick, value);
            }
        }

        /// <include file='doc\HtmlButton.uex' path='docs/doc[@for="HtmlButton.OnPreRender"]/*' />
        /// <internalonly/>
        protected override void OnPreRender(EventArgs e) {
            base.OnPreRender(e);
            if (Page != null && Events[EventServerClick] != null)
                Page.RegisterPostBackScript();
        }

        /*
         * Override to generate postback code for onclick.
         */
        /// <include file='doc\HtmlButton.uex' path='docs/doc[@for="HtmlButton.RenderAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderAttributes(HtmlTextWriter writer) {

            bool submitsProgramatically = (Events[EventServerClick] != null);
            if (Page != null && submitsProgramatically) {
                Util.WriteOnClickAttribute(writer, this, false, true, (CausesValidation && Page.Validators.Count > 0));
            }

            base.RenderAttributes(writer);
        }

        /// <include file='doc\HtmlButton.uex' path='docs/doc[@for="HtmlButton.OnServerClick"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='ServerClick'/>
        /// event.</para>
        /// </devdoc>
        protected virtual void OnServerClick(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventServerClick];
            if (handler != null) handler(this, e);
        }

        /*
         * Method of IPostBackDataHandler interface to raise events on post back.
         * Button fires an OnServerClick event.
         */
        /// <include file='doc\HtmlButton.uex' path='docs/doc[@for="HtmlButton.IPostBackEventHandler.RaisePostBackEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        void IPostBackEventHandler.RaisePostBackEvent(string eventArgument) {
            if (CausesValidation) {
                Page.Validate();
            }
            OnServerClick(EventArgs.Empty);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\templateparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Implements the ASP.NET template parser
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

// Turn this on to do regex profiling
//#define PROFILE_REGEX

namespace System.Web.UI {
using System.Runtime.Serialization.Formatters;
using System.Text;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Threading;
using System.Reflection;
using System.Globalization;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Web.Caching;
using System.Web.Util;
using System.Web.Compilation;
using System.Web.Configuration;
using HttpException = System.Web.HttpException;
using Debug=System.Diagnostics.Debug;
using System.Text.RegularExpressions;
using System.Security.Permissions;


/// <include file='doc\TemplateParser.uex' path='docs/doc[@for="TemplateParser"]/*' />
/// <internalonly/>
/// <devdoc>
///    <para>[To be supplied.]</para>
/// </devdoc>
[AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
public abstract class TemplateParser : BaseParser {
    
    // The <compilation> config section
    private CompilationConfiguration _compConfig;

    // The <pages> config section
    private PagesConfiguration _pagesConfig;
    internal PagesConfiguration PagesConfig {
        get { return _pagesConfig; }
    }

    private Stack _builderStack; // Stack of BuilderStackEntry's
    private string _id;
    private Hashtable _idList;
    private Stack _idListStack;
    private bool _fIsServerTag;
    private bool _fInScriptTag;
    private bool _fIgnoreScriptTag;
    private bool _fIgnoreNextSpaceString;
    private ScriptBlockData _currentScript;
    private StringBuilder _literalBuilder;

    // The file currently being parsed
    private string _currentFile;

    // Same as _currentFile, except when running under VS debugger, in which case
    // this is a URL
    private string _currentPragmaFile;

    // The line number in file currently being parsed
    private int _lineNumber;

    // The line number at which the current script block started
    private int _scriptStartLineNumber;

    // Does the page contain anything that requires compilation (as opposed
    // to being basically a plain HTML file renamed to .aspx)
    private bool _fNonTrivialPage;


    // File that contains the data to be parsed
    private string _inputFile;
    internal string InputFile {
        get { return _inputFile; }
        set { _inputFile = value; }
    }

    // String that contains the data to be parsed, as an alternative to
    // _inputFile
    private string _text;
    internal string Text {
        get { return _text; }
        set { _text = value; }
    }

    // The class from which to inherit if we are compiling a class
    private Type _baseType;
    internal Type BaseType {
        get { return _baseType; }
        set { _baseType = value; }
    }

    // The interfaces that we implement (ArrayList of Type objects)
    private ArrayList _implementedInterfaces;
    internal ArrayList ImplementedInterfaces { get { return _implementedInterfaces; } }

    private bool _hasCodeBehind;
    internal bool HasCodeBehind { get { return _hasCodeBehind; } }

    internal abstract Type DefaultBaseType { get; }

    // The FInDesigner property gets used by control builders so that
    // they can behave differently if needed.
    private bool _fInDesigner;
    internal virtual bool FInDesigner {
        get { return _fInDesigner; }
        set { _fInDesigner = value; }
    }

    private bool _fNonCompiledPage;
    internal virtual bool FNonCompiledPage{
        get { return _fNonCompiledPage; }
        set { _fNonCompiledPage = value; }
    }

    private void EnsureCodeAllowed() {
        // If it's a non compiled page, fail if there is code on it
        if (FNonCompiledPage) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Code_not_supported_on_non_compiled_page));
        }
    }

    private IDesignerHost _designerHost;
    private ITypeResolutionService _typeResolutionService;
    internal IDesignerHost DesignerHost {
        get {
            Debug.Assert(FInDesigner, "DesignerHost should be accessed only when FInDesigner == true");
            return _designerHost;
        }
        set {
            Debug.Assert(FInDesigner, "DesignerHost should be accessed only when FInDesigner == true");
            _designerHost = value;

            _typeResolutionService = null;
            if (_designerHost != null) {
                _typeResolutionService = (ITypeResolutionService)_designerHost.GetService(typeof(ITypeResolutionService));
                if (_typeResolutionService == null) {
                    throw new ArgumentException(SR.GetString(SR.TypeResService_Needed));
                }
            }
        }
    }

    // true if we're parsing global.asax
    internal virtual bool FApplicationFile { get { return false; } }

    // If true, we compile the page even if it is trivial.  This is to fix ASURT 9028.
    internal bool _fAlwaysCompile;

    // The global delegate to use for the DataBind event on controls when
    // the parser is run in design-mode.
    private EventHandler _designTimeDataBindHandler;
    internal EventHandler DesignTimeDataBindHandler {
        get { return _designTimeDataBindHandler; }
        set { _designTimeDataBindHandler = value; }
    }

    // Used to detect circular references
    internal Hashtable _circularReferenceChecker;


    // The list of assemblies that the compiled DLL is dependent on
    private Hashtable _assemblyDependencies;
    internal Hashtable AssemblyDependencies {
        get { return _assemblyDependencies; }
        set { _assemblyDependencies = value; }
    }

    // The list of cache items that the compiled DLL is dependent on
    private Hashtable _sourceDependencies;
    internal Hashtable SourceDependencies {
        get { return _sourceDependencies; }
    }

    // The cache key used to cache the created Type
    private string _cacheKey;

    // The collection of <object> tags with scope=session
    internal HttpStaticObjectsCollection _sessionObjects;
    internal HttpStaticObjectsCollection SessionObjects {
        get { return _sessionObjects; }
    }

    // The collection of <object> tags with scope=application
    internal HttpStaticObjectsCollection _applicationObjects;
    internal HttpStaticObjectsCollection ApplicationObjects {
        get { return _applicationObjects; }
    }

    // data that was obtained from parsing the input file

    private RootBuilder _rootBuilder;
    internal RootBuilder RootBuilder { get { return _rootBuilder; } }

    // Attributes in <%@ page ... %> block in case of an .aspx file, and in
    // <%@ application ... %> block for global.asax
    private IDictionary _mainDirective;

    // List of NamespaceEntry elements
    private ArrayList _namespaceEntries;
    internal ArrayList NamespaceEntries { get { return _namespaceEntries; } }

    private CompilerInfo _compilerInfo;
    internal CompilerInfo CompilerInfo { get { return _compilerInfo; } }

    // the server side scripts (list of ScriptBlockData's)
    private ArrayList _scriptList;
    internal ArrayList ScriptList { get { return _scriptList; } }

    // The complete (recursive) list of file dependencies
    internal string[] _fileDependencies;
    internal string[] FileDependencies { get { return _fileDependencies; } }

    // the hash code which determines the set of controls on the page
    private HashCodeCombiner _typeHashCode = new HashCodeCombiner();
    internal int TypeHashCode { get { return _typeHashCode.CombinedHash32; } }

    // The <object> tags local to the page.  Entries are ObjectTagBuilder's.
    private ArrayList _pageObjectList;
    internal ArrayList PageObjectList { get { return _pageObjectList; } }


    // Data parsed from the directives

    internal CompilerParameters CompilParams { get { return _compilerInfo.CompilParams; } }
    internal bool DebuggingEnabled { get { return CompilParams.IncludeDebugInformation; } }

    private bool _fExplicit;
    internal bool FExplicit { get { return _fExplicit; } }

    private bool _fHasDebugAttribute;
    private bool _fDebug;

    private bool _fLinePragmas=true;
    internal bool FLinePragmas { get { return _fLinePragmas; } }

    private int _warningLevel=-1;
    private string _compilerOptions;

    private bool _fStrict;
    internal bool FStrict { get { return _fStrict; } }

    // Name that the user wants to give to the generated class
    private string _generatedClassName;
    internal string GeneratedClassName { get { return _generatedClassName; } }

    // If the page is trivial, we don't need to compile.  Compile anyway if
    // _fAlwaysCompile is true (to fix ASURT 9028)
    internal bool FRequiresCompilation {
        get { return _fNonTrivialPage || _fAlwaysCompile; }
    }

    /// <include file='doc\TemplateParser.uex' path='docs/doc[@for="TemplateParser.ParseControl"]/*' />
    /// <devdoc>
    /// Parse the input into a Control. This is used to parse in a control dynamically from some
    /// textual content.
    /// </devdoc>
    internal static Control ParseControl(string content, HttpContext context, string baseVirtualDir) {

        ITemplate t = ParseTemplate(content, context, baseVirtualDir);

        // Create a parent control to hold the controls we parsed
        Control c = new Control();
        t.InstantiateIn(c);

        return c;
    }

    internal static ITemplate ParseTemplate(string content, HttpContext context, string baseVirtualDir) {
        TemplateParser parser = new UserControlParser();
        return parser.ParseTemplateInternal(content, context, baseVirtualDir);
    }

    private ITemplate ParseTemplateInternal(string content, HttpContext context, string baseVirtualDir) {
        Context = context;

        // Use a dummy file name since we don't really have one
        CurrentVirtualPath = baseVirtualDir + "/current.aspx";
        _basePhysicalDir = MapPath(BaseVirtualDir);
        FNonCompiledPage = true;
        _text = content;

        Parse();

        return _rootBuilder;
    }

    /*
     * Compile the input into a Page class,
     */
    internal ParserCacheItem GetParserCacheItem() {

        // To avoid lock contention, first try to get it from the cache without
        // taking the lock (ASURT 14500)
        ParserCacheItem item = GetParserCacheItemInternal(false /*fCreateIfNotFound*/);

        // If it's there, we're done
        if (item != null)
            return item;

        // Before grabbing the lock, make sure the file at least exists (ASURT 46465)
        if (!FileUtil.FileExists(_inputFile))
            throw new FileNotFoundException(_inputFile);

        try {
            // Grab the lock to make sure no other thread/process does any compilation
            System.Web.Util.Debug.Trace("Template", "Waiting to acquire lock for (" + _inputFile + ")");
            CompilationLock.GetLock();

            System.Web.Util.Debug.Trace("Template", "Aquiring lock for (" + _inputFile + ")");
            return GetParserCacheItemWithNewConfigPath();
        }
        finally {
            // Make sure we always release the lock
            System.Web.Util.Debug.Trace("Template", "Releasing lock for (" + _inputFile + ")");
            CompilationLock.ReleaseLock();
        }
    }

    /*
     * Update Context.ConfigPath and compile the input into a Page class.
     */
    internal ParserCacheItem GetParserCacheItemWithNewConfigPath() {

        if (CurrentVirtualPath == null)
            CurrentVirtualPath = Context.Request.FilePath;

        string prevConfigPath = Context.ConfigPath;

        try {
            // Set the config path to the virtual path that we're handling
            Context.ConfigPath = CurrentVirtualPath;

            return GetParserCacheItemInternal(true);
        }
        finally {
            // Restore the config path to its previous value
            Context.ConfigPath = prevConfigPath;
        }
    }

    /*
     * Compile a declarative input file or string into a Type object.
     * It may be coming from the cache.
     * If fCreateIfNotFound is false, only look in the cache and return
     * null if it's not there (ASURT 14500).
     */
    internal ParserCacheItem GetParserCacheItemInternal(bool fCreateIfNotFound) {

        // We must have either a file name or the text of the input
        Debug.Assert(_inputFile != null || _text != null);

        CompilationLock.SetMutexState(1);   // See ASURT 99521

        CacheInternal cacheInternal = System.Web.HttpRuntime.CacheInternal;

        string key = "System.Web.UI.TemplateParser:" + _inputFile;

        ParserCacheItem cacheItem = (ParserCacheItem) cacheInternal.Get(key);

        // If this was only a cache lookup, just fail
        if (cacheItem == null && !fCreateIfNotFound)
            return null;

        // Compile the page

        if (cacheItem == null) {
            System.Web.Util.Debug.Trace("Template", "Compiled page not found in cache (" + _inputFile + ")");

            DateTime utcStart = DateTime.UtcNow;

            // First, try to find a preserved compilation
            cacheItem = GetParserCacheItemFromPreservedCompilation();

            CompilationLock.SetMutexState(2);   // See ASURT 99521

            // If we couldn't find one, do all the work now
            if (cacheItem == null) {
                cacheItem = GetParserCacheItemThroughCompilation();

                CompilationLock.SetMutexState(3);   // See ASURT 99521

                // Preserve it for next time if it was successful
                if (cacheItem.exception == null)
                    PersistCompilationData(cacheItem);
            }
            else if (FApplicationFile) {
                // In case of global.asax, we need to call Parse even if we found the
                // preserved dll.  We need this to take care of the application/session
                // objects tags.
                Parse();
            }
            
            CompilationLock.SetMutexState(4);   // See ASURT 99521

            string[] sourceDependencies = Util.StringArrayFromHashtable(cacheItem.sourceDependencies);

            if (cacheItem.trivialPageContent != null) {
                // Allow trvial page entries to expire
                cacheInternal.UtcInsert(key, cacheItem, new CacheDependency(false, sourceDependencies, utcStart));
                System.Web.Util.Debug.Trace("Template", "Caching trvial page (" + _inputFile + ")");
            }
            else if (cacheItem.exception == null) {
                // Cache it forever, since assemblies can never be unloaded anyway
                cacheInternal.UtcInsert(key, cacheItem, new CacheDependency(false, sourceDependencies, utcStart), Cache.NoAbsoluteExpiration, Cache.NoSlidingExpiration,
                             CacheItemPriority.NotRemovable, null);

                System.Web.Util.Debug.Trace("Template", "Caching compiled page (" + _inputFile + ")");
            }
            else if (cacheItem.exception is HttpException) {
                // Allow exception entries to expire
                cacheInternal.UtcInsert(key, cacheItem, new CacheDependency(false, sourceDependencies, utcStart));
                System.Web.Util.Debug.Trace("Template", "Caching exception (" + _inputFile + ")");
            }
        }
        else {
            System.Web.Util.Debug.Trace("Template", "Compiled page found in cache (" + _inputFile + ")");

            // Get the Type and source dependencies from the cache item
            _assemblyDependencies = cacheItem.assemblyDependencies;
            _sourceDependencies = cacheItem.sourceDependencies;
        }

        // If an exception happened during parsing/compilation, throw it
        if (cacheItem.exception != null)
            throw new HttpException(cacheItem.exception.Message, cacheItem.exception);

        // Return the cache key used to cache the Type
        _cacheKey = key;

        return cacheItem;
    }

    /*
     * Check if the compilation has been cached from a previous run and is still
     * up to date.  If so, return it.
     */
    private ParserCacheItem GetParserCacheItemFromPreservedCompilation() {

        // We need the input to be in a file
        if (_inputFile == null)
            return null;

        // could be calling via user code so need to assert here (ASURT 105864)
        InternalSecurityPermissions.Unrestricted.Assert();

        PreservedAssemblyEntry entry = PreservedAssemblyEntry.GetPreservedAssemblyEntry(
            Context, CurrentVirtualPath, FApplicationFile);

        if (entry == null)
            return null;

#if DBG
        System.Web.Util.Debug.Trace("Template", "Found preserved entry for " + _inputFile + " with dependencies:");
        Util.DumpDictionary("Template", entry.SourceDependencies);
        Util.DumpDictionary("Template", entry.AssemblyDependencies);
#endif // DBG

        ParserCacheItem cacheItem = new ParserCacheItem();
        cacheItem.type = entry.ObjectType;
        cacheItem.sourceDependencies = entry.SourceDependencies;
        _sourceDependencies = entry.SourceDependencies;
        cacheItem.assemblyDependencies = entry.AssemblyDependencies;
        _assemblyDependencies = entry.AssemblyDependencies;

        return cacheItem;
    }

    /*
     * Preserve the result of the compilation to disk, to speed up future
     * appdomain restart
     */
    private void PersistCompilationData(ParserCacheItem cacheItem) {

        // We need the input to be in a file
        if (_inputFile == null)
            return;

        // Don't save anything if we don't have a compiled Type
        if (cacheItem.type == null)
            return;

        // Assert permissions to compile (in case of server.execute user code could be on the stack)
        InternalSecurityPermissions.Unrestricted.Assert();

        PreservedAssemblyEntry entry = new PreservedAssemblyEntry(Context, CurrentVirtualPath,
            FApplicationFile, null /*assembly*/, cacheItem.type, cacheItem.sourceDependencies);

        entry.SaveDataToFile(false /*fBatched*/);
    }

    /// <include file='doc\TemplateParser.uex' path='docs/doc[@for="TemplateParser.CompileIntoType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    protected abstract Type CompileIntoType();

    /*
     * Compile a declarative input file or string and return a filled in
     * ParserCacheItem structure.
     */
    private ParserCacheItem GetParserCacheItemThroughCompilation() {
        // Assert permissions to compile (in case of server.execute user code could be on the stack)
        InternalSecurityPermissions.Unrestricted.Assert();

        // Create the cache item structure
        ParserCacheItem cacheItem = new ParserCacheItem();

        // Parse the input
        System.Web.Util.Debug.Trace("Template", "Beginning parsing of " +
            (_inputFile != null ? _inputFile : "unknown"));
        Parse();

        // Get an array of source file dependencies
        string[] sourceDependencies = Util.StringArrayFromHashtable(_sourceDependencies);

#if DBG
        System.Web.Util.Debug.Trace("Template", "Source dependencies for " + _inputFile);
        foreach (string s in sourceDependencies)
            System.Web.Util.Debug.Trace("Template", "--> \"" + s + "\"");
#endif // DBG

        _fileDependencies = sourceDependencies;

        if (FRequiresCompilation) {
            // If _text is non null, then the string we parsed did not have
            // any aspx, and we don't need to compile.  Compile anyway if
            // _fAlwaysCompile is true (to fix ASURT 9028)
        
            // Compile the page class from the parsed data
            System.Web.Util.Debug.Trace("Template", "Calling TemplateCompiler.CreatePageClass");

            try {
                // Compile the parse data into a type
                cacheItem.type = CompileIntoType();
            }
            catch (Exception e) {
                // Increment the compilation counter
                PerfCounters.IncrementCounter(AppPerfCounter.ERRORS_COMPILING);
                PerfCounters.IncrementCounter(AppPerfCounter.ERRORS_TOTAL);

                // If an error occurs during compilation, we cache the
                // exception object, so that we can rethrow it any time
                // this page is re-accessed.  This is to fix ASURT 4854.
                cacheItem.exception = e;
            }
        }
        else {
            // It's a trivial Page.  Just remember the content
            cacheItem.trivialPageContent = _text;
        }

        // Save the Type and Source dependencies in the cache items, so that they
        // will be available when the item is found in the cache
        cacheItem.assemblyDependencies = _assemblyDependencies;
        cacheItem.sourceDependencies = _sourceDependencies;

        return cacheItem;
    }

    /*
     * Do some initialization before the parsing
     */
    internal virtual void PrepareParse() {

        _rootBuilder = new RootBuilder(this);
        _rootBuilder._line = 1;
        _rootBuilder.Init(this, null, null, null, null, null);

        // If running under the VS debugger, generate URL's for the line pragmas
        // instead of local paths.
        if (HttpRuntime.VSDebugAttach)
            _rootBuilder._sourceFileName = (new Uri(Context.Request.Url, CurrentVirtualPath)).ToString();
        else
            _rootBuilder._sourceFileName = _inputFile;

        if (_circularReferenceChecker == null)
            _circularReferenceChecker = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

        _baseType = DefaultBaseType;

        // In the designer, Context in null
        if (Context != null) {
            // Get the config sections we care about
            _compConfig = (CompilationConfiguration)Context.GetConfig(CompilationConfiguration.sectionName);
            _pagesConfig = (PagesConfiguration)Context.GetConfig(PagesConfiguration.sectionName);

            // Link in all the assemblies specified in the config files
            AppendConfigAssemblies();

            // Get default settings from config
            ProcessConfigSettings();
        }

        // Create and seed the stack of builders.
        _builderStack = new Stack();
        _builderStack.Push(new BuilderStackEntry(_rootBuilder, null, null, 0, null, 0));

        _sourceDependencies = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

        // Create and seed the stack of ID lists.
        _idListStack = new Stack();
        _idList = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

        _scriptList = new ArrayList();
    }

    // Get default settings from config
    internal virtual void ProcessConfigSettings() {
        if (_compConfig != null) {
            _fExplicit = _compConfig.Explicit;
            _fStrict = _compConfig.Strict;
        }
    }

    /*
     * Parse the input
     */
    internal void Parse() {

        // Always set the culture to Invariant when parsing (ASURT 99071)
        Thread currentThread = Thread.CurrentThread;
        CultureInfo prevCulture = currentThread.CurrentCulture;
        System.Web.Util.Debug.Trace("Culture", "Before parsing, culture is " + prevCulture.DisplayName);
        currentThread.CurrentCulture = CultureInfo.InvariantCulture;

        try {
            try {
                // Do some initialization before the parsing
                PrepareParse();

                // Parse either the file or string
                if (_inputFile != null) {
                    AddSourceDependency(_inputFile);
                    ParseFile(_inputFile, CurrentVirtualPath);
                }
                else {
                    ParseString(_text, CurrentVirtualPath, _basePhysicalDir);
                }

                HandlePostParse();
            }
            finally {
                // Restore the previous culture
                System.Web.Util.Debug.Trace("Culture", "After parsing, culture is " + currentThread.CurrentCulture.DisplayName);
                currentThread.CurrentCulture = prevCulture;
                System.Web.Util.Debug.Trace("Culture", "Restored culture to " + prevCulture.DisplayName);
            }
        }
        catch { throw; }    // Prevent Exception Filter Security Issue (ASURT 122835)
    }

    internal TemplateParser() {
    }

    /*
     * Parse the contents of the input file
     */
    private void ParseFile(string filename, string virtualPath) {
        string prevFile;
        string prevPragmaFile;

        string basePhysicalDir = Path.GetDirectoryName(filename);

        TextReader reader = Util.ReaderFromFile(filename, Context, CurrentVirtualPath);


       // Save the current file name and set the new one
        prevFile = _currentFile;
        prevPragmaFile = _currentPragmaFile;

        _currentFile = filename;

        // If running under the VS debugger, generate URL's for the line pragmas
        // instead of local paths (ASURT 60085, VS 158437)
        if (HttpRuntime.VSDebugAttach)
            _currentPragmaFile = (new Uri(Context.Request.Url, virtualPath)).ToString();
        else
            _currentPragmaFile = filename;

        try {
            // Check for circular references of include files
            if (_circularReferenceChecker.ContainsKey(filename)) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Circular_include));
            }

            // Add the current file to the circular references checker
            _circularReferenceChecker[filename] = null;

            ParseReader(reader, virtualPath, basePhysicalDir);
        }
        finally {
            // Make sure we always close the reader
            if (reader != null)
                reader.Close();

            // Restore the current file name
            _currentFile = prevFile;
            _currentPragmaFile = prevPragmaFile;

            // Remove the current file from the circular references checker
            _circularReferenceChecker.Remove(filename);
        }
    }

    /*
     * Parse the contents of the TextReader
     */
    private void ParseReader(TextReader input, string virtualPath, string basePhysicalDir) {
        string s = input.ReadToEnd();

        // Save the text of the input file in case it's trivial
        _text = s;

        ParseString(s, virtualPath, basePhysicalDir);
    }

    private void AddLiteral(string literal) {

        if (_literalBuilder == null)
            _literalBuilder = new StringBuilder();

        _literalBuilder.Append(literal);
    }

    private string GetLiteral() {
        if (_literalBuilder == null)
            return null;

        return _literalBuilder.ToString();
    }

    /*
     * Update the hash code of the Type we're creating by xor'ing it with
     * a string.
     */
    private void UpdateTypeHashCode(string text) {
        _typeHashCode.AddObject(text);
    }

    /*
     * Parse the contents of the string, and catch exceptions
     */
    private void ParseString(string text, string virtualPath, string basePhysicalDir) {

        System.Web.Util.Debug.Trace("Template", "Starting parse at " + DateTime.Now);

        // Save the previous base dirs and line number
        string prevVirtualPath = CurrentVirtualPath;
        string prevBasePhysicalDir = _basePhysicalDir;
        int prevLineNumber = _lineNumber;

        // Set the new current base dirs and line number
        CurrentVirtualPath = virtualPath;
        _basePhysicalDir = basePhysicalDir;
        _lineNumber = 1;

        // Always ignore the spaces at the beginning of a string
        _fIgnoreNextSpaceString = true;

        try {
            ParseStringInternal(text);
        }
        catch (Exception e) {
            ErrorFormatter errorFormatter = null;

            PerfCounters.IncrementCounter(AppPerfCounter.ERRORS_PRE_PROCESSING);
            PerfCounters.IncrementCounter(AppPerfCounter.ERRORS_TOTAL);

            // Check if the exception has a formatter
            errorFormatter = HttpException.GetErrorFormatter(e);

            // If it doesn't, throw a parse exception
            if (errorFormatter == null) {

                throw new HttpParseException(SR.GetString(SR.Parser_Error) + ": " + e.Message, e,
                    _currentFile, text, _lineNumber);
            }
            else {
                // Otherwise, throw a basic Http exception to avoid overriding the
                // most nested formatter
                throw new HttpException(SR.GetString(SR.Parser_Error) + ": " + e.Message, e);
            }
        }
        finally {
            // Restore the previous base dirs and line number
            CurrentVirtualPath = prevVirtualPath;
            _basePhysicalDir = prevBasePhysicalDir;
            _lineNumber = prevLineNumber;
        }

        System.Web.Util.Debug.Trace("Template", "Ending parse at " + DateTime.Now);
    }

#if PROFILE_REGEX
    private Match RunTagRegex(string text, int textPos) {
        int i=1;
        if (i==0)
            throw new HttpException("Bogus exception just to prevent method inlining");

        return tagRegex.Match(text, textPos);
    }

    private Match RunDirectiveRegex(string text, int textPos) {
        int i=1;
        if (i==0)
            throw new HttpException("Bogus exception just to prevent method inlining");

        return directiveRegex.Match(text, textPos);
    }

    private Match RunEndTagRegex(string text, int textPos) {
        int i=1;
        if (i==0)
            throw new HttpException("Bogus exception just to prevent method inlining");

        return endtagRegex.Match(text, textPos);
    }

    private Match RunCodeBlockRegex(string text, int textPos) {
        int i=1;
        if (i==0)
            throw new HttpException("Bogus exception just to prevent method inlining");

        return aspCodeRegex.Match(text, textPos);
    }

    private Match RunExprCodeBlockRegex(string text, int textPos) {
        int i=1;
        if (i==0)
            throw new HttpException("Bogus exception just to prevent method inlining");

        return aspExprRegex.Match(text, textPos);
    }

    private Match RunCommentRegex(string text, int textPos) {
        int i=1;
        if (i==0)
            throw new HttpException("Bogus exception just to prevent method inlining");

        return commentRegex.Match(text, textPos);
    }

    private Match RunIncludeRegex(string text, int textPos) {
        int i=1;
        if (i==0)
            throw new HttpException("Bogus exception just to prevent method inlining");

        return includeRegex.Match(text, textPos);
    }

    private Match RunTextRegex(string text, int textPos) {
        int i=1;
        if (i==0)
            throw new HttpException("Bogus exception just to prevent method inlining");

        return textRegex.Match(text, textPos);
    }
#endif // PROFILE_REGEX

    /*
     * Parse the contents of the string
     */
    private void ParseStringInternal(string text) {
        int textPos = 0;

        StringBuilder literalBuilder = new StringBuilder();

        for (;;) {
            Match match;

            // 1: scan for text up to the next tag.

#if PROFILE_REGEX
            if ((match = RunTextRegex(text, textPos)).Success)
#else
            if ((match = textRegex.Match(text, textPos)).Success)
#endif
            {
                // Append the text to the literal builder
                AddLiteral(match.ToString());

                _lineNumber += Util.LineCount(text, textPos,
                                         match.Index + match.Length);
                textPos = match.Index + match.Length;
            }

            // we might be done now

            if (textPos == text.Length)
                break;

            // 2: handle constructs that start with <

            // This later gets set to true if we match a regex, but do not
            // process the match
            bool fMatchedButNotProcessed = false;

            // Check to see if it's a directive (i.e. <%@ %> block)

            if (!_fInScriptTag &&
#if PROFILE_REGEX
                (match = RunDirectiveRegex(text, textPos)).Success)
#else
                (match = directiveRegex.Match(text, textPos)).Success)
#endif 
            {
                ProcessLiteral();

                // Get all the directives into a bag
                IDictionary directive = CollectionsUtil.CreateCaseInsensitiveSortedList();
                string duplicateAttribute;
                string directiveName = ProcessAttributes(match, directive, true, out duplicateAttribute);

                ProcessDirective(directiveName, directive);

                // Always ignore the spaces after a directive
                _fIgnoreNextSpaceString = true;
            }

            // Check to see if it's a server side include
            // e.g. <!-- #include file="foo.inc" -->

#if PROFILE_REGEX
            else if ((match = RunIncludeRegex(text, textPos)).Success)
#else
            else if ((match = includeRegex.Match(text, textPos)).Success)
#endif 
            {
                ProcessServerInclude(match);
            }

            // Check to see if it's a comment (<%-- --%> block
            // e.g. <!-- Blah! -->

#if PROFILE_REGEX
            else if ((match = RunCommentRegex(text, textPos)).Success)
#else
            else if ((match = commentRegex.Match(text, textPos)).Success)
#endif 
            {
                // Just skip it
            }

            // Check to see if it's an expression code block (i.e. <%= ... %> block)

            else if (!_fInScriptTag &&
#if PROFILE_REGEX
                     (match = RunExprCodeBlockRegex(text, textPos)).Success)
#else
                     (match = aspExprRegex.Match(text, textPos)).Success)
#endif 
            {
                ProcessCodeBlock(match, CodeBlockType.Expression);
            }

            // Check to see if it's a databinding expression block (i.e. <%# ... %> block)
            // This does not include <%# %> blocks used as values for
            // attributes of server tags.

            else if (!_fInScriptTag &&
                     (match = databindExprRegex.Match(text, textPos)).Success) {
                ProcessCodeBlock(match, CodeBlockType.DataBinding);
            }

            // Check to see if it's a code block (<% ... %>)

            else if (!_fInScriptTag &&
#if PROFILE_REGEX
                     (match = RunCodeBlockRegex(text, textPos)).Success)
#else
                     (match = aspCodeRegex.Match(text, textPos)).Success)
#endif 
            {
                ProcessCodeBlock(match, CodeBlockType.Code);
            }

            // Check to see if it's a tag

            else if (!_fInScriptTag &&
#if PROFILE_REGEX
                     (match = RunTagRegex(text, textPos)).Success)
#else
                     (match = tagRegex.Match(text, textPos)).Success)
#endif 
            {
                if (!ProcessBeginTag(match, text))
                    fMatchedButNotProcessed = true;
            }

            // Check to see if it's an end tag

#if PROFILE_REGEX
            else if ((match = RunEndTagRegex(text, textPos)).Success)
#else
            else if ((match = endtagRegex.Match(text, textPos)).Success)
#endif 
            {
                if (!ProcessEndTag(match))
                    fMatchedButNotProcessed = true;
            }

            // Did we process the block that started with a '<'?
            if (match == null || !match.Success || fMatchedButNotProcessed) {
                // If we could not match the '<' at all, check for some
                // specific syntax errors
                if (!fMatchedButNotProcessed && !_fInScriptTag)
                    DetectSpecialServerTagError(text, textPos);

                // Skip the '<'
                textPos++;
                AddLiteral("<");
            }
            else {
                _lineNumber += Util.LineCount(text, textPos,
                                         match.Index + match.Length);
                textPos = match.Index + match.Length;

                // We processed a special block, so the page is more than a
                // plain HTML.
                _fNonTrivialPage = true;
            }

            // we might be done now
            if (textPos == text.Length)
                break;
        }

        if (_fInScriptTag) {
            // Change the line number to where the script tag started to get
            // the correct error message (ASURT 13698).
            _lineNumber = _scriptStartLineNumber;
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Unexpected_eof_looking_for_tag, "script"));
        }

        // Process the final literal (if any)
        ProcessLiteral();
    }

    /*
     * Do what needs to be done before returning after the parsing is complete
     */
    internal virtual void HandlePostParse() {

        // If there is more than one builder on the stack, some tag was
        // not correctly closed, which is an error.
        if (_builderStack.Count > 1) {
            BuilderStackEntry entry = (BuilderStackEntry) _builderStack.Peek();

            string message = HttpRuntime.FormatResourceString(SR.Unexpected_eof_looking_for_tag, entry._tagName);
            throw new HttpParseException(message, null, entry._fileName, entry._inputText, entry._line);
        }

        // If no language was specified in the page
        if (_compilerInfo == null) {

            // Get a default from config
            _compilerInfo = CompilationConfiguration.GetDefaultLanguageCompilerInfo(Context);
        }

        CompilerParameters compilParams = _compilerInfo.CompilParams;

        // Override certain settings if they were specified on the page
        if (_fHasDebugAttribute)
            compilParams.IncludeDebugInformation = _fDebug;

        // Debugging requires medium trust level
        if (compilParams.IncludeDebugInformation)
            HttpRuntime.CheckAspNetHostingPermission(AspNetHostingPermissionLevel.Medium, SR.Debugging_not_supported_in_low_trust);

        // If warningLevel was specified in the page, use it
        if (_warningLevel >= 0) {
            compilParams.WarningLevel = _warningLevel;
            compilParams.TreatWarningsAsErrors = (_warningLevel>0);
        }
        if (_compilerOptions != null)
            compilParams.CompilerOptions = _compilerOptions;
    }

    /*
     * Process all the text in the literal StringBuilder, and reset it
     */
    private void ProcessLiteral() {
        // Debug.Trace("Template", "Literal text: \"" + _literalBuilder.ToString() + "\"");

        // Get the current literal string
        string literal = GetLiteral();

        // Nothing to do if it's empty
        if (literal == null || literal.Length == 0) {
            _fIgnoreNextSpaceString = false;
            return;
        }

        // In global.asax, we don't allow random rendering content
        if (FApplicationFile) {
            // Make sure the literal is just white spaces
            int iFirstNonWhiteSpace = Util.FirstNonWhiteSpaceIndex(literal);

            if (iFirstNonWhiteSpace >= 0) {
                // Move the line number back to the first non-whitespace
                _lineNumber -= Util.LineCount(literal, iFirstNonWhiteSpace, literal.Length);

                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Invalid_app_file_content));
            }
        }
        else {
            // Check if we should ignore the string (ASURT 8186)
            bool fIgnoreThisLiteral = false;
            if (_fIgnoreNextSpaceString) {
                _fIgnoreNextSpaceString = false;

                if (Util.IsWhiteSpaceString(literal))
                    fIgnoreThisLiteral = true;
            }

            if (!fIgnoreThisLiteral) {
                // Add it to the top builder
                ControlBuilder builder = ((BuilderStackEntry) _builderStack.Peek())._builder;
                try {
                    builder.AppendLiteralString(literal);
                }
                catch (Exception) {
                    // If there was an error during the parsing of the literal, move
                    // the line number back to the beginning of the literal
                    int iFirstNonWhiteSpace = Util.FirstNonWhiteSpaceIndex(literal);
                    if (iFirstNonWhiteSpace < 0) iFirstNonWhiteSpace = 0;
                    _lineNumber -= Util.LineCount(literal, iFirstNonWhiteSpace, literal.Length);
                    throw;
                }

                // Update the hash code with a fixed string, to mark that there is
                // a literal, but allow it to change without affecting the hash.
                UpdateTypeHashCode("string");
            }
        }

        // Reset the StringBuilder for the next literal
        _literalBuilder = null;
    }

    /*
     * Process a server side SCRIPT tag
     */
    private void ProcessServerScript() {
        // Get the contents of the script tag
        string script = GetLiteral();

        // Nothing to do if it's empty
        if (script == null || script.Length == 0)
            return;

        // Add this script to the script builder, unless we're
        // supposed to ignore it
        if (!_fIgnoreScriptTag) {
            _currentScript.Script = script;
            _scriptList.Add(_currentScript);
            _currentScript = null;
        }
        // Reset the StringBuilder for the next literal
        _literalBuilder = null;
    }

    internal virtual void CheckObjectTagScope(ref ObjectTagScope scope) {

        // Map the default scope to Page
        if (scope == ObjectTagScope.Default)
            scope = ObjectTagScope.Page;

        // Check for invalid scopes
        if (scope != ObjectTagScope.Page) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.App_session_only_valid_in_global_asax));
        }
    }

    /*
     * Process an Object tag, depending on its scope
     */
    private void ProcessObjectTag(ObjectTagBuilder objectBuilder) {

        ObjectTagScope scope = objectBuilder.Scope;
        CheckObjectTagScope(ref scope);

        // Page and AppInstance are treated identically
        if (scope == ObjectTagScope.Page ||
            scope == ObjectTagScope.AppInstance) {
            if (_pageObjectList == null)
                _pageObjectList = new ArrayList();

            _pageObjectList.Add(objectBuilder);
        }
        else if (scope == ObjectTagScope.Session) {
            if (_sessionObjects == null)
                _sessionObjects = new HttpStaticObjectsCollection();

            _sessionObjects.Add(objectBuilder.ID,
                objectBuilder.ObjectType,
                objectBuilder.LateBound);
        }
        else if (scope == ObjectTagScope.Application) {
            if (_applicationObjects == null)
                _applicationObjects = new HttpStaticObjectsCollection();

            _applicationObjects.Add(objectBuilder.ID,
                objectBuilder.ObjectType,
                objectBuilder.LateBound);
        }
        else {
            Debug.Assert(false, "Unexpected scope!");
        }
    }

    /*
     * Add a child builder to a builder
     */
    private void AppendSubBuilder(ControlBuilder builder, ControlBuilder subBuilder) {
        // Check if it's an object tag
        if (subBuilder is ObjectTagBuilder) {
            ProcessObjectTag((ObjectTagBuilder) subBuilder);
            return;
        }

        builder.AppendSubBuilder(subBuilder);
    }

    /*
     * Process an opening tag (possibly self-closed)
     */
    // Used to generate unique id's
    private int _controlCount;
    private bool ProcessBeginTag(Match match, string inputText) {
        string tagName = match.Groups["tagname"].Value;

        // Get all the attributes into a bag
        IDictionary attribs = new ListDictionary(new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
        string duplicateAttribute;
        ProcessAttributes(match, attribs, false /*fDirective*/, out duplicateAttribute);

        // Check if the tag is self closed
        bool fSelfClosed = match.Groups["empty"].Success;

        // Is it a server side script tag?
        if (string.Compare(tagName, "script", true, CultureInfo.InvariantCulture) == 0 && _fIsServerTag) {
            ProcessLiteral();

            // Make sure it's legal to have code in this page
            EnsureCodeAllowed();

            // Always ignore the spaces after a script tag
            _fIgnoreNextSpaceString = true;

            // Check if there is a 'src' attribute
            string src = Util.GetAndRemoveNonEmptyAttribute(attribs, "src");
            if (src != null) {
                // Get the script from the specified file
                src = MapPath(src);

                // Make sure that access to the file is permitted (ASURT 105933)
                HttpRuntime.CheckFilePermission(src);

                AddSourceDependency(src);

                ProcessLanguageAttribute((string)attribs["language"]);
                _currentScript = new ScriptBlockData(1, src);

                _currentScript.Script = Util.StringFromFile(src, Context);

                // Add this script to the script builder
                _scriptList.Add(_currentScript);
                _currentScript = null;

                // If the script tag is not self closed (even though it has a
                // src attribute), continue processing it, but eventually
                // ignore the content (ASURT 8883)
                if (!fSelfClosed) {
                    _fInScriptTag = true;
                    _scriptStartLineNumber = _lineNumber;
                    _fIgnoreScriptTag = true;
                }

                return true;
            }

            ProcessLanguageAttribute((string)attribs["language"]);
            _currentScript = new ScriptBlockData(_lineNumber, _currentPragmaFile);

            // No 'src' attribute.  Make sure tag is not self closed.
            if (fSelfClosed) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Script_tag_without_src_must_have_content));
            }

            _fInScriptTag = true;
            _scriptStartLineNumber = _lineNumber;
            return true;
        }

        ControlBuilder parentBuilder = null;
        ControlBuilder subBuilder = null;
        Type childType = null;

        // Check if the parent builder wants to create a subcontrol for this tag.
        if (_builderStack.Count > 1) {
            
            parentBuilder = ((BuilderStackEntry) _builderStack.Peek())._builder;

            subBuilder = parentBuilder.CreateChildBuilder(tagName, attribs,
                this, parentBuilder, _id, _lineNumber, _currentPragmaFile, ref childType);
        }

        // If not, use the root builder if runat=server is there.
        if (subBuilder == null && _fIsServerTag) {
            subBuilder = _rootBuilder.CreateChildBuilder(tagName, attribs,
                this, parentBuilder, _id, _lineNumber, _currentPragmaFile, ref childType);
        }

        // In case we find that the top stack item has the same name as the
        // current tag, we increase a count on the stack item.  This way, we
        // know that we need to ignore the corresponding closing tag (ASURT 50795)
        if (subBuilder == null && _builderStack.Count > 1 && !fSelfClosed) {
            BuilderStackEntry stackEntry = (BuilderStackEntry) _builderStack.Peek();
            if (string.Compare(tagName, stackEntry._tagName, true, CultureInfo.InvariantCulture) == 0)
                stackEntry._repeatCount++;
        }

        // We could not get the type of a server control from that tag
        if (subBuilder == null) {
            // If it wasn't marked as runat=server, ignore
            if (!_fIsServerTag)
                return false;

            // If it was marked as runat=server, fail
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Unknown_server_tag, tagName));
        }

        // We have a server control

        // Make sure it doesn't have duplicated attributes
        if (duplicateAttribute != null) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Duplicate_attr_in_tag, duplicateAttribute));
        }

        // If it has an id, enforce validity and uniqueness
        if (_id != null) {

            if (!System.CodeDom.Compiler.CodeGenerator.IsValidLanguageIndependentIdentifier(_id)) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Invalid_identifier, _id));
            }

            if (_idList.ContainsKey(_id)) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Id_already_used, _id));
            }

            _idList[_id] = null;
        }
        else if (_fIsServerTag) {
            // Make sure that cached controls always have a fixed id to prevent
            // unpredictable behavior (ASURT 83402)
            PartialCachingAttribute cacheAttrib = (PartialCachingAttribute)
                TypeDescriptor.GetAttributes(childType)[typeof(PartialCachingAttribute)];

            if (cacheAttrib != null) {
                _id = "_ctrl_" + _controlCount.ToString(NumberFormatInfo.InvariantInfo);
                subBuilder.ID = _id;
                _controlCount++;
                subBuilder.PreprocessAttribute("id", _id);
            }
        }


        // Take care of the previous literal string
        ProcessLiteral();

        // Update the hash code with the name of the control's type
        UpdateTypeHashCode(childType.FullName);

        // If the server control has a body, and if it didn't self-close
        // (i.e. wasn't terminated with "/>"), put it on the stack of controls.
        if (!fSelfClosed && subBuilder.HasBody()) {

            // If it's a template, push a new ID list (ASURT 72773)
            if (subBuilder is TemplateBuilder) {
                _idListStack.Push(_idList);
                _idList = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
            }

            _builderStack.Push(new BuilderStackEntry(subBuilder, tagName,
                               _currentPragmaFile, _lineNumber,
                               inputText, match.Index + match.Length));
        }
        else {
            // Append the sub builder to the current builder
            parentBuilder = ((BuilderStackEntry) _builderStack.Peek())._builder;
            AppendSubBuilder(parentBuilder, subBuilder);

            // Tell the builder that we're done parsing its control
            subBuilder.CloseControl();
        }

        return true;
    }

    /*
     * Called when a '</' sequence is seen. This means we can start closing
     * tags.
     */
    private bool ProcessEndTag(Match match) {
        string tagName = match.Groups["tagname"].Value;

        // If we are in the middle of a server side SCRIPT tag
        if (_fInScriptTag) {
            // Ignore anything that's not a </script>
            if (string.Compare(tagName, "script", true, CultureInfo.InvariantCulture) != 0)
                return false;

            ProcessServerScript();

            _fInScriptTag = false;
            _fIgnoreScriptTag = false;

            return true;
        }

        // See if anyone on the stack cares about termination.
        return MaybeTerminateControl(tagName, match.Index);
    }

    internal abstract string DefaultDirectiveName { get; }

    /*
     * Process a <%@ %> block
     */
    internal virtual void ProcessDirective(string directiveName, IDictionary directive) {

        // Check for the main directive, which is "page" for an aspx,
        // and "application" for global.asax
        if (directiveName == "" ||
            string.Compare(directiveName, DefaultDirectiveName, true, CultureInfo.InvariantCulture) == 0) {

            // Make sure the main directive was not already specified
            if (_mainDirective != null) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Only_one_directive_allowed, DefaultDirectiveName));
            }

            ProcessMainDirective(directive);

            // Keep track of it to make sure it's not specified again
            _mainDirective = directive;
        }
        else if (string.Compare(directiveName, "assembly", true, CultureInfo.InvariantCulture) == 0) {
            // Assembly directive

            // Remove the attributes as we get them from the dictionary
            string assemblyName = Util.GetAndRemoveNonEmptyAttribute(directive, "name");
            string src = Util.GetAndRemoveNonEmptyAttribute(directive, "src");

            // If there are some attributes left, fail
            Util.CheckUnknownDirectiveAttributes(directiveName, directive);

            if (assemblyName != null && src != null) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Attributes_mutually_exclusive, "Name", "Src"));
            }

            if (assemblyName != null) {
                AddAssemblyDependency(assemblyName);
            }
            // Is it a source file that needs to be compiled on the fly
            else if (src != null) {
                ImportSourceFile(src);
            }
            else {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Missing_attr, "name"));
            }
        }
        else if (string.Compare(directiveName, "import", true, CultureInfo.InvariantCulture) == 0) {

            // Import directive

            ProcessImportDirective(directiveName, directive);
        }
        else if (string.Compare(directiveName, "implements", true, CultureInfo.InvariantCulture) == 0) {
            // 'implements' directive

            // Remove the attributes as we get them from the dictionary
            string interfaceName = Util.GetAndRemoveRequiredAttribute(directive, "interface");

            // If there are some attributes left, fail
            Util.CheckUnknownDirectiveAttributes(directiveName, directive);

            Type interfaceType = GetType(interfaceName);

            // Make sure that it's an interface
            if (!interfaceType.IsInterface) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Invalid_type_to_implement, interfaceName));
            }

            // Add the interface type to the list
            if (_implementedInterfaces == null)
                _implementedInterfaces = new ArrayList();
            _implementedInterfaces.Add(interfaceType);
        }
        else {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Unknown_directive, directiveName));
        }
    }

    internal virtual void ProcessMainDirective(IDictionary mainDirective) {

        // Since description is a no op, just remove it if it's there
        mainDirective.Remove("description");

        // Similarily, ignore 'codebehind' attribute (ASURT 4591)
        mainDirective.Remove("codebehind");

        if (Util.GetAndRemoveBooleanAttribute(mainDirective, "debug", ref _fDebug)) {

            if (_fDebug && !HttpRuntime.HasAspNetHostingPermission(AspNetHostingPermissionLevel.Medium)) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Insufficient_trust_for_attribute, "debug"));
            }

            _fHasDebugAttribute = true;
        }

        Util.GetAndRemoveBooleanAttribute(mainDirective, "linepragmas", ref _fLinePragmas);

        Util.GetAndRemoveNonNegativeIntegerAttribute(mainDirective, "warninglevel", ref _warningLevel);
        _compilerOptions = Util.GetAndRemoveNonEmptyAttribute(mainDirective, "compileroptions");

        if (_compilerOptions != null) {
            // Only allow the use of compilerOptions when we have UnmanagedCode access (ASURT 73678)
            if (!HttpRuntime.HasUnmanagedPermission()) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Insufficient_trust_for_attribute, "CompilerOptions"));
            }
        }

        // These two really only make sense in VB
        Util.GetAndRemoveBooleanAttribute(mainDirective, "explicit", ref _fExplicit);
        Util.GetAndRemoveBooleanAttribute(mainDirective, "strict", ref _fStrict);

        ProcessLanguageAttribute(Util.GetAndRemoveNonEmptyAttribute(mainDirective, "language"));

        // A "src" attribute is equivalent to an imported source file
        string src = Util.GetAndRemoveNonEmptyAttribute(mainDirective, "src");
        Assembly assembly = null;
        if (src != null)
            assembly = ImportSourceFile(src);

        // Was a base type specified in the directive
        string baseTypeName = Util.GetAndRemoveNonEmptyAttribute(mainDirective, "inherits");
        if (baseTypeName != null) {
            Type baseType;
            if (assembly != null)
                baseType = assembly.GetType(baseTypeName);
            else
                baseType = GetType(baseTypeName);

            // Make sure we successfully got the Type of the base class
            if (baseType == null) {
                Debug.Assert(src != null, "src != null");
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Non_existent_base_type, baseTypeName, src));
            }

            // Make sure the base type extends the DefaultBaseType (Page or UserControl)
            if (!DefaultBaseType.IsAssignableFrom(baseType)) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Invalid_type_to_inherit_from, baseTypeName,
                        _baseType.FullName));
            }

            _baseType = baseType;

            // Make sure we link with the assembly of the base type (ASURT 101778)
            AddTypeDependency(_baseType);

            // Remember the fact that the page uses codebehind
            _hasCodeBehind = true;
        }

        // Get the name that the user wants to give to the generated class
        _generatedClassName = Util.GetAndRemoveNonEmptyIdentifierAttribute(mainDirective, "classname");

        // If there are some attributes left, fail
        Util.CheckUnknownDirectiveAttributes(DefaultDirectiveName, mainDirective);
    }

    internal virtual void ProcessImportDirective(string directiveName, IDictionary directive) {

        // Remove the attributes as we get them from the dictionary
        string ns = Util.GetAndRemoveNonEmptyNoSpaceAttribute(directive, "namespace");

        if (ns != null)
            AddImportEntry(ns);

        // If there are some attributes left, fail
        Util.CheckUnknownDirectiveAttributes(directiveName, directive);
    }

    /*
     * Process a language attribute, as can appear in the Page directive and in
     * <script runat=server> tags.
     */
    private void ProcessLanguageAttribute(string language) {
        if (language == null)
            return;

        CompilerInfo compilerInfo = CompilationConfiguration.GetCompilerInfoFromLanguage(Context, language);

        // Make sure we don't get conflicting languages
        if (_compilerInfo != null && _compilerInfo.CompilerType != compilerInfo.CompilerType) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Mixed_lang_not_supported, language));
        }

        _compilerInfo = compilerInfo;
    }

    /*
     * Compile a source file into an assembly, and import it
     */
    private Assembly ImportSourceFile(string virtualPath) {

        // Get a full path to the source file
        string fullVirtualPath = UrlPath.Combine(BaseVirtualDir, virtualPath);
        string physicalPath = MapPath(fullVirtualPath, false /*allowCrossAppMapping*/);

        // Add the source file to the list of files we depend on
        AddSourceDependency(physicalPath);

        CompilerInfo compilerInfo = CompilationConfiguration.GetCompilerInfoFromFileName(
            Context, physicalPath);

        CompilerParameters compilParams = compilerInfo.CompilParams;

        // If the debug attrib was specified, copy it in.
        if (_fHasDebugAttribute)
            compilParams.IncludeDebugInformation = _fDebug;

        // Compile it into an assembly

        Assembly a = SourceCompiler.GetAssemblyFromSourceFile(Context, fullVirtualPath,
            null /*assemblies*/, compilerInfo.CompilerType, compilParams);

        // Add a dependency to the assembly and its dependencies
        AddAssemblyDependency(a, true /*addDependentAssemblies*/);

        return a;
    }

    /*
     * If we could not match the '<' at all, check for some specific syntax
     * errors.
     */
    private void DetectSpecialServerTagError(string text, int textPos) {

        // If it started with <%, it's probably not closed (ASURT 13661)
        if (text.Length > textPos+1 && text[textPos+1] == '%') {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Malformed_server_block));
        }

        // Search for the end of the tag ('>')
        Match match = gtRegex.Match(text, textPos);

        // No match, return
        if (!match.Success)
            return;

        // Get the complete potential tag
        string tag = text.Substring(textPos, match.Index-textPos+2);

        // Check if it's a case of nested <% %> block in a server tag (ASURT 8714)

        // If the tag does not contain runat=server, do nothing
        match = runatServerRegex.Match(tag);
        if (!match.Success)
            return;

        // If it has runat=server, but there is a '<' before it, don't fail, since
        // this '<' is probably the true tag start, and it will be processed later (ASURT 39531)
        // But ignore "<%" (ASURT 77554)
        Match matchLessThan = ltRegex.Match(tag, 1);
        if (matchLessThan.Success && matchLessThan.Index < match.Index)
            return;

        System.Web.Util.Debug.Trace("Template", "Found malformed server tag: " + tag);

        // Remove all <% %> constructs from within it.
        string tag2 = serverTagsRegex.Replace(tag, "");

        // If there were some <% %> constructs in the tag
        if ((object)tag2 != (object)tag) {
            // If it can be parsed as a tag after we removed the <% %> constructs, fail
            if (tagRegex.Match(tag2).Success) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Server_tags_cant_contain_percent_constructs));
            }
        }

        // Give a more generic error (fixed 18969, 30312)
        throw new HttpException(
            HttpRuntime.FormatResourceString(SR.Malformed_server_tag));
    }

    /*
     * Add all the assemblies specified in the config files
     */
    private void AppendConfigAssemblies() {

        // Always add dependencies to System.Web.dll and System.dll (ASURT 78531)
        AddAssemblyDependency(typeof(Page).Assembly);
        AddAssemblyDependency(typeof(Uri).Assembly);

        // Get the set of config assemblies for our context
        IDictionary configAssemblies = _compConfig.Assemblies;

        if (configAssemblies == null)
            return;

        // Add dependencies to all the config assemblies
        foreach (Assembly a in configAssemblies.Values)
            AddAssemblyDependency(a);

        // Also, link in global.asax if available
        AddTypeDependency(HttpApplicationFactory.ApplicationType);
    }

    /*
     * Add an entry to our list of NamespaceEntry's
     */
    internal void AddImportEntry(string ns) {
        if (_namespaceEntries == null)
            _namespaceEntries = new ArrayList();

        NamespaceEntry namespaceEntry = new NamespaceEntry();
        namespaceEntry.Namespace = ns;

        namespaceEntry.Line = _lineNumber;
        namespaceEntry.SourceFileName = _currentPragmaFile;

        _namespaceEntries.Add(namespaceEntry);
    }

    internal Assembly LoadAssembly(string assemblyName, bool throwOnFail) {

        if (_typeResolutionService != null) {
            AssemblyName asmName = new AssemblyName();
            asmName.Name = assemblyName;

            return _typeResolutionService.GetAssembly(asmName, throwOnFail);
        }

        return _compConfig.LoadAssembly(assemblyName, throwOnFail);
    }

    /*
     * Look for a type by name in the assemblies that this page links with
     */
    internal Type GetType(string typeName, bool ignoreCase) {

        // If it contains an assembly name, parse it out and load the assembly (ASURT 53589)
        Assembly a = null;
        int comaIndex = typeName.IndexOf(",");
        if (comaIndex > 0) {
            string assemblyName = typeName.Substring(comaIndex+1).Trim();
            typeName = typeName.Substring(0, comaIndex).Trim();

            try {
                a = LoadAssembly(assemblyName, !FInDesigner /*throwOnFail*/);
            }
            catch {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Assembly_not_compiled, assemblyName));
            }
        }

        // If we got an assembly, load the type from it
        if (a != null)
            return a.GetType(typeName, true /*throwOnFail*/, ignoreCase);

        if (AssemblyDependencies == null)
            return null;

        // Otherwise, look for the type in the dependent assemblies
        foreach (Assembly assembly in AssemblyDependencies.Keys) {
            Type t = assembly.GetType(typeName, false /*throwOnError*/, ignoreCase);

#if DBG
            if (t == null)
                System.Web.Util.Debug.Trace("Page_GetType", "Failed to find type '" + typeName + "' in assembly " + assembly.GetName().FullName);
            else
                System.Web.Util.Debug.Trace("Page_GetType", "Successfully found type '" + typeName + "' in assembly " + assembly.GetName().FullName);
#endif

            if (t != null)
                return t;
        }

        throw new HttpException(
            HttpRuntime.FormatResourceString(SR.Invalid_type, typeName));
    }

    /*
     * Look for a type by name in the assemblies that this page links with
     */
    internal Type GetType(string typeName) {
        return GetType(typeName, false /*ignoreCase*/);
    }

    /*
     * Throw an exception if the value is not null
     */
    internal void EnsureNullAttribute(string name, string value) {
        if (value != null) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Unexpected_attr, name));
        }
    }

    /*
     * Process a server side include.  e.g. <!-- #include file="foo.inc" -->
     */
    private void ProcessServerInclude(Match match) {
        if (_fInScriptTag) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Include_not_allowed_in_server_script_tag));
        }

        ProcessLiteral();

        string pathType = match.Groups["pathtype"].Value;
        string filename = match.Groups["filename"].Value;
        //System.Web.Util.Debug.Trace("Template", "#Include " + pathType + "=" + filename);

        if (filename.Length == 0) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Empty_file_name));
        }

        string newVirtualPath = CurrentVirtualPath;

        // We distinguish file from virtual paths by putting vpaths through
        // MapPath and file paths through PhysicalPath

        if (string.Compare(pathType, "file", true, CultureInfo.InvariantCulture) == 0) {
            filename = PhysicalPath(filename);
        }
        else if (string.Compare(pathType, "virtual", true, CultureInfo.InvariantCulture) == 0) {
            newVirtualPath = UrlPath.Combine(BaseVirtualDir, filename);
            filename = MapPath(newVirtualPath);
            if (filename == null) {
                throw new HttpException(HttpRuntime.FormatResourceString(
                    SR.Cannot_map_path, newVirtualPath));
            }
        }
        else {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Only_file_virtual_supported_on_server_include));
        }

        // Make sure that access to the file is permitted (ASURT 73792,85467)
        HttpRuntime.CheckFilePermission(filename);

        // Add it to the list of files we depend on
        AddSourceDependency(filename);

        // Parse the included file recursively
        ParseFile(filename, newVirtualPath);

        // Always ignore the spaces after an include directive
        _fIgnoreNextSpaceString = true;
    }

    /*
     *  Handle <%= ... %>, <%# ... %> and <% ... %> blocks
     */
    private void ProcessCodeBlock(Match match, CodeBlockType blockType) {

        // Make sure it's legal to have code in this page
        EnsureCodeAllowed();

        // Take care of the previous literal string
        ProcessLiteral();

        // Get the piece of code
        string code = match.Groups["code"].Value;

        // Replace "%\>" with "%>" (ASURT 7175)
        code = code.Replace(@"%\>", "%>");

        // If it's a <%= %> or <%# %> expression, get rid of the spaces at the
        // beginning and end of the string since some compilers (like VB) don't
        // support multiline expression (ASURT 13662)
        if (blockType != CodeBlockType.Code) {
            code = code.Trim();

            // Disallow empty expressions (ASURT 40124)
            if (Util.IsWhiteSpaceString(code)) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Empty_expression));
            }
        }

        ControlBuilder builder = ((BuilderStackEntry) _builderStack.Peek())._builder;
        ControlBuilder subBuilder;

        // Add the code block to the top builder
        subBuilder = new CodeBlockBuilder(blockType, code, _lineNumber, _currentPragmaFile);
        AppendSubBuilder(builder, subBuilder);

        // Always ignore the spaces after a <% ... %> block
        if (blockType == CodeBlockType.Code)
            _fIgnoreNextSpaceString = true;
    }

    /*
     * Adds attributes and their values to the attribs
     * Sets the _id and _fIsServerTag data members as appropriate.
     * If fDirective is true, we are being called for a <%@ %> block, in
     * which case the name of the directive is returned (e.g. "page")
     */
    private string ProcessAttributes(Match match, IDictionary attribs,
                                     bool fDirective, out string duplicateAttribute) {
        string ret = "";
        CaptureCollection attrnames = match.Groups["attrname"].Captures;
        CaptureCollection attrvalues = match.Groups["attrval"].Captures;
        CaptureCollection equalsign = null;
        if (fDirective)
            equalsign = match.Groups["equal"].Captures;

        _fIsServerTag = false;
        _id = null;

        duplicateAttribute = null;

        for (int i = 0; i < attrnames.Count; i++) {
            string attribName = attrnames[i].ToString();
            string attribValue = attrvalues[i].ToString();

            // Always HTML decode all attributes (ASURT 54544)
            attribValue = HttpUtility.HtmlDecode(attribValue);

            // If we're parsing a directive, check if there is an equal sign.
            bool fHasEqual = false;
            if (fDirective)
                fHasEqual = (equalsign[i].ToString().Length > 0);

            // If this is a server ID, remember it
            // CONSIDER: if the user puts several ID attributes on a
            // tag, only the last one is returned. Problem? probably not.
            if (string.Compare(attribName, "id", true, CultureInfo.InvariantCulture) == 0) {
                _id = attribValue;
            }
            else if (string.Compare(attribName, "runat", true, CultureInfo.InvariantCulture) == 0) {
                // Only runat=server is valid
                if (string.Compare(attribValue, "server", true, CultureInfo.InvariantCulture) != 0) {
                    throw new HttpException(
                        HttpRuntime.FormatResourceString(SR.Runat_can_only_be_server));
                }

                // Set a flag if we see runat=server
                _fIsServerTag = true;
                attribName = null;       // Don't put it in attribute bag
            }

            if (attribName != null) {
                // A <%@ %> block can have two formats:
                // <%@ directive foo=1 bar=hello %>
                // <%@ foo=1 bar=hello %>
                // Check if we have the first format
                if (fDirective && !fHasEqual && i==0) {
                    ret = attribName;
                    continue;
                }

                try {
                    if (attribs != null)
                        attribs.Add(attribName, attribValue);
                }
                catch (ArgumentException) {
                    // Duplicate attribute.  We can't throw until we find out if
                    // it's a server side tag (ASURT 51273)
                    duplicateAttribute = attribName;
                }
            }
        }

        if (duplicateAttribute != null && fDirective) {
            throw new HttpException(
                HttpRuntime.FormatResourceString(SR.Duplicate_attr_in_directive, duplicateAttribute));
        }

        return ret;
    }

    private bool MaybeTerminateControl(string tagName, int textPos) {

        BuilderStackEntry stackEntry = (BuilderStackEntry) _builderStack.Peek();
        ControlBuilder builder = stackEntry._builder;

        // If the tag doesn't match, return false
        if (stackEntry._tagName == null || string.Compare(stackEntry._tagName, tagName, true, CultureInfo.InvariantCulture)!=0) {
            return false;
        }

        // If the repeat count is non-zero, just decrease it
        if (stackEntry._repeatCount > 0) {
            stackEntry._repeatCount--;
            return false;
        }

        // Take care of the previous literal string
        ProcessLiteral();

        // If the builder wants the raw text of the tag, give it to it
        if (builder.NeedsTagInnerText()) {
            try {
                builder.SetTagInnerText(stackEntry._inputText.Substring(
                      stackEntry._textPos,
                      textPos-stackEntry._textPos));
            }
            catch (Exception) {
                // Reset the line number to the beginning of the tag if there is an error
                _lineNumber = builder.Line;
                throw;
            }
        }

        // If it's ending a template, pop the idList (ASURT 72773)
        if (builder is TemplateBuilder)
            _idList = (Hashtable) _idListStack.Pop();

        // Pop the top entry from the stack
        _builderStack.Pop();

        // Give the builder to its parent
        AppendSubBuilder(((BuilderStackEntry) _builderStack.Peek())._builder, builder);

        // Tell the builder that we're done parsing its control
        builder.CloseControl();

        return true;
    }

    /*
     * Map a type name to a Type.
     */
    internal Type MapStringToType(string typeName) {
        return _rootBuilder.GetChildControlType(typeName, null /*attribs*/);
    }

    /*
     * Add a file as a dependency for the DLL we're building
     */
    internal void AddSourceDependency(string fileName) {
        if (_sourceDependencies == null)
            _sourceDependencies = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

        _sourceDependencies[fileName] = fileName;
    }

    /*
     * Add a a dependency on a cache entry (via its key)
     */
    internal void AddSourceDependencies(IDictionary sourceDependencies) {
        if (sourceDependencies == null)
            return;

        IDictionaryEnumerator en = sourceDependencies.GetEnumerator();
        for (int i=0; en.MoveNext(); i++)
            AddSourceDependency((string)en.Value);
    }

    /*
     * Add a type that we must 'link' with in order to build
     */
    internal void AddTypeDependency(Type type) {
        // We must link with all the types in the inheritance hierarchy (ASURT 83509)
        AddBaseTypeDependencies(type);

        // Add an import for the namespace of the type (if any)
        // Per ASURT 83942, only do this for namespaces we generate (e.g. ASP & _ASP)
        if (type.Namespace != null && BaseCompiler.IsAspNetNamespace(type.Namespace))
            AddImportEntry(type.Namespace);
    }

    /*
     * Add as dependencies all the assembly in the inheritance chain of a Type,
     * including interfaces.
     */
    private void AddBaseTypeDependencies(Type type) {
        Assembly a = type.Module.Assembly;

        // If the type is in a standard assembly, don't bother
        if (a == typeof(string).Assembly || a == typeof(Page).Assembly || a == typeof(Uri).Assembly)
            return;

        AddAssemblyDependency(a);

        // Recurse on the base Type
        if (type.BaseType != null)
            AddBaseTypeDependencies(type.BaseType);

        // Recurse on all the implemented interfaces
        Type[] interfaceTypes = type.GetInterfaces();
        foreach (Type interfaceType in interfaceTypes)
            AddBaseTypeDependencies(interfaceType);
    }

    /*
     * Add an assembly that we must 'link' with in order to build
     */
    internal Assembly AddAssemblyDependency(string assemblyName, bool addDependentAssemblies) {

        Assembly assembly = LoadAssembly(assemblyName, !FInDesigner /*throwOnFail*/);

        if (assembly != null)
            AddAssemblyDependency(assembly, addDependentAssemblies);

        return assembly;
    }
    internal Assembly AddAssemblyDependency(string assemblyName) {
        return AddAssemblyDependency(assemblyName, false /*addDependentAssemblies*/);
    }

    /*
     * Add an assembly that we must 'link' with in order to build
     */
    internal void AddAssemblyDependency(Assembly assembly, bool addDependentAssemblies) {
        if (_assemblyDependencies == null)
            _assemblyDependencies = new Hashtable();

        if (_typeResolutionService != null)
            _typeResolutionService.ReferenceAssembly(assembly.GetName());

        _assemblyDependencies[assembly] = null;

        // If addDependentAssemblies is true, add its dependent assemblies as well
        if (addDependentAssemblies) {
            Hashtable assemblyDependencies = Util.GetReferencedAssembliesHashtable(assembly);
            AddAssemblyDependencies(assemblyDependencies);
        }
    }
    internal void AddAssemblyDependency(Assembly assembly) {
        AddAssemblyDependency(assembly, false /*addDependentAssemblies*/);
    }

    /*
     * Add a set of assemblies that we must 'link' with in order to build
     */
    private void AddAssemblyDependencies(Hashtable assemblyDependencies) {
        if (assemblyDependencies == null)
            return;

        foreach (Assembly a in assemblyDependencies.Keys)
            AddAssemblyDependency(a);
    }
}

/*
 * Objects that are placed on the BuilderStack
 */
internal class BuilderStackEntry {
    internal BuilderStackEntry (ControlBuilder builder,
                       string tagName, string fileName, int line,
                       string inputText, int textPos) {
        
        _builder = builder;
        _tagName = tagName;
        _fileName = fileName;
        _line = line;
        _inputText = inputText;
        _textPos = textPos;
    }

    internal ControlBuilder _builder;
    internal string _tagName;

    // The file and line number where the tag starts
    internal string _fileName;
    internal int _line;

    // the input string that contains the tag
    internal string _inputText;

    // Offset in the input string of the beginning of the tag's contents
    internal int _textPos;

    // Used to deal with non server tags nested in server tag with the same name
    internal int _repeatCount;
}


/*
 * Entry representing an import directive.
 * e.g. <%@ import namespace="System.Web.UI" %>
 */
internal class NamespaceEntry {
    private string _namespace;
    
    internal NamespaceEntry() {
    }

    internal string Namespace {
        get { return _namespace;}
        set { _namespace = value;}
    }

    private int _line;
    internal int Line {
        get { return _line;}
        set { _line = value;}
    }

    private string _sourceFileName;
    internal string SourceFileName {
        get { return _sourceFileName;}
        set { _sourceFileName = value;}
    }
}


/*
 * Type of the items that we put in the cache
 */
internal class ParserCacheItem {
    // The compiled Type
    internal Type type;

    // The text in case of a trivial page
    internal string trivialPageContent;

    // The exception in case we cached the result of a failed compilation
    internal Exception exception;

    // The list of assemblies it depends on
    internal Hashtable assemblyDependencies;

    // The list of Files it depends on
    internal Hashtable sourceDependencies;

    internal ParserCacheItem() {
    }
}

internal class ScriptBlockData {
    protected string _script;
    protected int _line;
    protected string _sourceFileName;

    internal ScriptBlockData(int line, string sourceFileName) {
        _line = line;
        _sourceFileName = sourceFileName;
    }

    internal string Script {
        get { return _script;}
        set { _script = value;}
    }

    internal int Line {
        get { return _line;}
    }

    internal string SourceFileName {
        get { return _sourceFileName;}
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlcontainercontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlContainerControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.HtmlControls {
    using System.Runtime.Serialization.Formatters;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.IO;
    using System.Web.UI;
    using System.Security.Permissions;

/*
 *  A control representing an intrinsic Html tag.
 */
    /// <include file='doc\HtmlContainerControl.uex' path='docs/doc[@for="HtmlContainerControl"]/*' />
    /// <devdoc>
    /// <para>The <see langword='HtmlContainerControl'/> 
    /// class defines the methods,
    /// properties and events
    /// available to all Html Server controls that must have a
    /// closing tag.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    abstract public class HtmlContainerControl : HtmlControl {
        /*
         * Creates a new WebControl
         */
        /// <include file='doc\HtmlContainerControl.uex' path='docs/doc[@for="HtmlContainerControl.HtmlContainerControl"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of a <see cref='System.Web.UI.HtmlControls.HtmlContainerControl'/> class using 
        ///    default values.</para>
        /// </devdoc>
        public HtmlContainerControl() : this("span") {
        }

        /*
         *  Creates a new HtmlContainerControl
         */
        /// <include file='doc\HtmlContainerControl.uex' path='docs/doc[@for="HtmlContainerControl.HtmlContainerControl1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of a <see cref='System.Web.UI.HtmlControls.HtmlContainerControl'/> class using the 
        ///    specified string.</para>
        /// </devdoc>
        public HtmlContainerControl(string tag) : base(tag) {
        }

        /*
         * The inner html content between the begin and end tag.
         * A set will replace any existing child controls with a single literal.
         * A get will return the text of a single literal child OR
         * will throw an exception if there are no children, more than one
         * child, or the single child is not a literal.
         */
        /// <include file='doc\HtmlContainerControl.uex' path='docs/doc[@for="HtmlContainerControl.InnerHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the
        ///       content found between the opening and closing tags of the specified HTML server control.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        HtmlControlPersistable(false),
        ]
        public virtual string InnerHtml {
            get {
                if (IsLiteralContent())
                    return((LiteralControl) Controls[0]).Text;
                else if (HasControls() && (Controls.Count == 1) && Controls[0] is DataBoundLiteralControl) 
                    return ((DataBoundLiteralControl) Controls[0]).Text;
                else {
                    if (Controls.Count == 0)
                        return String.Empty;

                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Inner_Content_not_literal, ID));
                }
            }

            set {
                Controls.Clear();
                Controls.Add(new LiteralControl(value));
                ViewState["innerhtml"] = value;
            }
        }

        /*
         * The inner text content between the begin and end tag.
         * A set will replace any existing child controls with a single literal.
         * A get will return the text of a single literal child OR
         * will throw an exception if there are no children, more than one child, or
         * the single child is not a literal.
         */
        /// <include file='doc\HtmlContainerControl.uex' path='docs/doc[@for="HtmlContainerControl.InnerText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets all text between the opening and closing tags
        ///       of the specified HTML server control.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        HtmlControlPersistable(false),
        ]
        public virtual string InnerText {
            get {   
                return HttpUtility.HtmlDecode(InnerHtml); 
            }

            set {   
                InnerHtml = HttpUtility.HtmlEncode(value); 
            }
        }


        /// <include file='doc\HtmlContainerControl.uex' path='docs/doc[@for="HtmlContainerControl.CreateControlCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override ControlCollection CreateControlCollection() {
            return new ControlCollection(this);
        }

        /// <include file='doc\HtmlContainerControl.uex' path='docs/doc[@for="HtmlContainerControl.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void LoadViewState(object savedState) {
            if (savedState != null) {
                base.LoadViewState(savedState);
                string s = (string)ViewState["innerhtml"];
                if (s != null)
                    InnerHtml = s;
            }
        }


        /*
         * Render the control into the given writer.
         */
        /// <include file='doc\HtmlContainerControl.uex' path='docs/doc[@for="HtmlContainerControl.Render"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void Render(HtmlTextWriter writer) {
            RenderBeginTag(writer);
            RenderChildren(writer);
            RenderEndTag(writer);
        }

        /*
         * Override to prevent InnerHtml from being rendered as an attribute.
         */
        /// <include file='doc\HtmlContainerControl.uex' path='docs/doc[@for="HtmlContainerControl.RenderAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderAttributes(HtmlTextWriter writer) {
            ViewState.Remove("innerhtml");
            base.RenderAttributes(writer);
        }

        /*
         * Render the end tag, &lt;/TAGNAME&gt;.
         */
        /// <include file='doc\HtmlContainerControl.uex' path='docs/doc[@for="HtmlContainerControl.RenderEndTag"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual void RenderEndTag(HtmlTextWriter writer) {
            writer.WriteEndTag(TagName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlimage.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlImage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlImage.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {

    using System;
    using System.Globalization;
    using System.Collections;
    using System.ComponentModel;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

/// <include file='doc\HtmlImage.uex' path='docs/doc[@for="HtmlImage"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlImage'/>
///       class defines the methods, properties, and events
///       for the HtmlImage server control.
///       This class provides programmatic access on the server to
///       the HTML &lt;img&gt; element.
///    </para>
/// </devdoc>
    [
    ControlBuilderAttribute(typeof(HtmlControlBuilder))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlImage : HtmlControl {

        /*
         *  Creates an intrinsic Html IMG control.
         */
        /// <include file='doc\HtmlImage.uex' path='docs/doc[@for="HtmlImage.HtmlImage"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.HtmlControls.HtmlImage'/> class.</para>
        /// </devdoc>
        public HtmlImage() : base("img") {
        }

        /*
         * Alt property
         */
        /// <include file='doc\HtmlImage.uex' path='docs/doc[@for="HtmlImage.Alt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the alternative caption that the
        ///       browser displays if image is either unavailable or has not been downloaded yet.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Alt {
            get {
                string s = Attributes["alt"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["alt"] = MapStringAttributeToString(value);
            }
        }

        /*
         * Align property
         */
        /// <include file='doc\HtmlImage.uex' path='docs/doc[@for="HtmlImage.Align"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the alignment of the image with
        ///       surrounding text.</para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Align {
            get {
                string s = Attributes["align"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["align"] = MapStringAttributeToString(value);
            }
        }

        /*
         * Border property, size of border in pixels.
         */
        /// <include file='doc\HtmlImage.uex' path='docs/doc[@for="HtmlImage.Border"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the width of image border, in pixels.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(0),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Border {
            get {
                string s = Attributes["border"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }
            set {
                Attributes["border"] = MapIntegerAttributeToString(value);
            }
        }

        /*
         * Height property
         */
        /// <include file='doc\HtmlImage.uex' path='docs/doc[@for="HtmlImage.Height"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the height of the image. By default, this is expressed in
        ///       pixels,
        ///       but can be a expressed as a percentage.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(100),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Height {
            get {
                string s = Attributes["height"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }
            set {
                Attributes["height"] = MapIntegerAttributeToString(value);
            }
        }

        /*
         * Src property.
         */
        /// <include file='doc\HtmlImage.uex' path='docs/doc[@for="HtmlImage.Src"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the name of and path to the
        ///       image file to be displayed. This can be an absolute or
        ///       relative path.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Src {
            get {
                string s = Attributes["src"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["src"] = MapStringAttributeToString(value);
            }
        }

        /*
         * Width property
         */
        /// <include file='doc\HtmlImage.uex' path='docs/doc[@for="HtmlImage.Width"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the width of the image. By default, this is
        ///       expressed in pixels,
        ///       but can be a expressed as a percentage.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(100),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Width {
            get {
                string s = Attributes["width"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }
            set {
                Attributes["width"] = MapIntegerAttributeToString(value);
            }
        }

        /*
         * Override to render unique name attribute.
         * The name attribute is owned by the framework.
         */
        /// <include file='doc\HtmlImage.uex' path='docs/doc[@for="HtmlImage.RenderAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderAttributes(HtmlTextWriter writer) {
            PreProcessRelativeReferenceAttribute(writer, "src");

            base.RenderAttributes(writer);
            writer.Write(" /");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlgenericcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlGenericControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlGenericControl.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.IO;
    using System.Web.UI;
    using System.Security.Permissions;

/*
 *  A control representing an unknown Html tag.
 */
/// <include file='doc\HtmlGenericControl.uex' path='docs/doc[@for="HtmlGenericControl"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlGenericControl'/> class defines the methods,
///       properties, and events for all HTML Server control tags not represented by a
///       specific class.
///    </para>
/// </devdoc>
    [ConstructorNeedsTag(true)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlGenericControl : HtmlContainerControl {
        /*
         * Creates a new WebControl
         */
        /// <include file='doc\HtmlGenericControl.uex' path='docs/doc[@for="HtmlGenericControl.HtmlGenericControl"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.HtmlControls.HtmlGenericControl'/> class with default 
        ///    values.</para>
        /// </devdoc>
        public HtmlGenericControl() : this("span") {
        }

        /*
         *  Creates a new HtmlGenericControl
         */
        /// <include file='doc\HtmlGenericControl.uex' path='docs/doc[@for="HtmlGenericControl.HtmlGenericControl1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.HtmlControls.HtmlGenericControl'/> class using the specified 
        ///    string.</para>
        /// </devdoc>
        public HtmlGenericControl(string tag) {
            if (tag == null)
                tag = String.Empty;
 
            _tagName = tag;
        }

        /*
        * Property to get name of tag.
        */
        /// <include file='doc\HtmlGenericControl.uex' path='docs/doc[@for="HtmlGenericControl.TagName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the element name of a tag that contains a
        ///       runat="server" attribute/value pair.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        new public string TagName {
            get { return _tagName;}

            set {_tagName = value;}
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlinputcheckbox.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlInputCheckBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlInputCheckBox.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {
    using System.ComponentModel;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

/// <include file='doc\HtmlInputCheckBox.uex' path='docs/doc[@for="HtmlInputCheckBox"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlInputCheckBox'/> class defines the methods,
///       properties, and events for the HtmlInputCheckBox control. This class allows
///       programmatic access to the HTML &lt;input type=
///       checkbox&gt;
///       element on the server.
///    </para>
/// </devdoc>
    [
    DefaultEvent("ServerChange")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlInputCheckBox : HtmlInputControl, IPostBackDataHandler {

        private static readonly object EventServerChange = new object();

        /*
         *  Creates an intrinsic Html INPUT type=checkbox control.
         */
        /// <include file='doc\HtmlInputCheckBox.uex' path='docs/doc[@for="HtmlInputCheckBox.HtmlInputCheckBox"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of a <see cref='System.Web.UI.HtmlControls.HtmlInputCheckBox'/> class.</para>
        /// </devdoc>
        public HtmlInputCheckBox() : base("checkbox") {
        }

        /*
         * Checked property.
         */
        /// <include file='doc\HtmlInputCheckBox.uex' path='docs/doc[@for="HtmlInputCheckBox.Checked"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the checkbox is
        ///       currently selected.</para>
        /// </devdoc>
        [
        WebCategory("Default"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public bool Checked {
            get {
                string s = Attributes["checked"];
                return((s != null) ? (s.Equals("checked")) : false);
            }
            set {
                if (value)
                    Attributes["checked"] = "checked";
                else
                    Attributes["checked"] = null;
            }
        }

        /*
        * Adds an event handler for the OnServerChange event.
        *  value: New handler to install for this event.
        */
        /// <include file='doc\HtmlInputCheckBox.uex' path='docs/doc[@for="HtmlInputCheckBox.ServerChange"]/*' />
        /// <devdoc>
        ///    <para>Occurs when </para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.HtmlInputCheck_OnServerChange)
        ]
        public event EventHandler ServerChange {
            add {
                Events.AddHandler(EventServerChange, value);
            }
            remove {
                Events.RemoveHandler(EventServerChange, value);
            }
        }

        /*
         * This method is invoked just prior to rendering.
         */
        /// <include file='doc\HtmlInputCheckBox.uex' path='docs/doc[@for="HtmlInputCheckBox.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {
            if (Page != null && !Disabled)
                Page.RegisterRequiresPostBack(this);

            // if no change handler, no need to save posted property unless
            // we are disabled
            if (Events[EventServerChange] == null && !Disabled) {
                ViewState.SetItemDirty("checked",false);
            }
        }

        /*
         * Method used to raise the OnServerChange event.
         */
        /// <include file='doc\HtmlInputCheckBox.uex' path='docs/doc[@for="HtmlInputCheckBox.OnServerChange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnServerChange(EventArgs e) {
            // invoke delegates AFTER binding
            EventHandler handler = (EventHandler)Events[EventServerChange];
            if (handler != null) handler(this, e);
        }

        /*
         * Method of IPostBackDataHandler interface to process posted data.
         * Checkbox determines the posted Checked state.
         */
        /// <include file='doc\HtmlInputCheckBox.uex' path='docs/doc[@for="HtmlInputCheckBox.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        bool IPostBackDataHandler.LoadPostData(string postDataKey, NameValueCollection postCollection) {
            string post = postCollection[postDataKey];
            bool newValue = (post != null && post.Length > 0);
            bool valueChanged = (newValue != Checked);
            Checked = newValue;
            return valueChanged;
        }

        /*
         * Method of IPostBackDataHandler interface which is invoked whenever
         * posted data for a control has changed.  RadioButton fires an
         * OnServerChange event.
         */
        /// <include file='doc\HtmlInputCheckBox.uex' path='docs/doc[@for="HtmlInputCheckBox.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            OnServerChange(EventArgs.Empty);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlinputbutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlInputButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlInputButton.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Web;
    using System.Web.UI;
    using System.Globalization;
    using System.Security.Permissions;
    
/// <include file='doc\HtmlInputButton.uex' path='docs/doc[@for="HtmlInputButton"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlInputButton'/> class defines the methods,
///       properties, and events for the HTML Input Button control. This class allows
///       programmatic access to the HTML &lt;input type=
///       button&gt;, &lt;input type=
///       submit&gt;,and &lt;input
///       type=
///       reset&gt; elements on
///       the server.
///    </para>
/// </devdoc>
    [
    DefaultEvent("ServerClick")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlInputButton : HtmlInputControl, IPostBackEventHandler {

        private static readonly object EventServerClick = new object();

        /*
         *  Creates an intrinsic Html INPUT type=button control.
         */
        /// <include file='doc\HtmlInputButton.uex' path='docs/doc[@for="HtmlInputButton.HtmlInputButton"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of a <see cref='System.Web.UI.HtmlControls.HtmlInputButton'/> class using 
        ///    default values.</para>
        /// </devdoc>
        public HtmlInputButton() : base("button") {
        }

        /*
         *  Creates an intrinsic Html INPUT type=button,submit,reset control.
         */
        /// <include file='doc\HtmlInputButton.uex' path='docs/doc[@for="HtmlInputButton.HtmlInputButton1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of a <see cref='System.Web.UI.HtmlControls.HtmlInputButton'/> class using the 
        ///    specified string.</para>
        /// </devdoc>
        public HtmlInputButton(string type) : base(type) {
        }

        /// <include file='doc\HtmlInputButton.uex' path='docs/doc[@for="HtmlInputButton.CausesValidation"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets whether pressing the button causes page validation to fire. This defaults to True so that when
        ///          using validation controls, the validation state of all controls are updated when the button is clicked, both
        ///          on the client and the server. Setting this to False is useful when defining a cancel or reset button on a page
        ///          that has validators.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(true),
        ]
        public bool CausesValidation {
            get {
                object b = ViewState["CausesValidation"];
                return((b == null) ? true : (bool)b);
            }
            set {
                ViewState["CausesValidation"] = value;
            }
        }

        /// <include file='doc\HtmlInputButton.uex' path='docs/doc[@for="HtmlInputButton.ServerClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when an HTML Input Button control is clicked on the browser.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.HtmlInputButton_OnServerClick)
        ]
        public event EventHandler ServerClick {
            add {
                Events.AddHandler(EventServerClick, value);
            }
            remove {
                Events.RemoveHandler(EventServerClick, value);
            }
        }

        /// <include file='doc\HtmlInputButton.uex' path='docs/doc[@for="HtmlInputButton.OnPreRender"]/*' />
        /// <internalonly/>
        protected override void OnPreRender(EventArgs e) {
            base.OnPreRender(e);
            if (Page != null && Events[EventServerClick] != null && String.Compare(Type, "submit", true, CultureInfo.InvariantCulture) != 0)
                Page.RegisterPostBackScript();
        }

        /*
         * Override to generate postback code for onclick.
         */
        /// <include file='doc\HtmlInputButton.uex' path='docs/doc[@for="HtmlInputButton.RenderAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderAttributes(HtmlTextWriter writer) {
            string type = Type;
            
            bool submitsAutomatically = (String.Compare(type, "submit", true, CultureInfo.InvariantCulture) == 0);
            bool submitsProgramatically = (!submitsAutomatically) && (Events[EventServerClick] != null);
            if (Page != null) {
                if (submitsAutomatically)
                    Util.WriteOnClickAttribute(writer, this, submitsAutomatically, submitsProgramatically, (CausesValidation && Page.Validators.Count > 0));
                else {
                    if (submitsProgramatically && String.Compare(type, "button", true, CultureInfo.InvariantCulture) == 0) 
                        Util.WriteOnClickAttribute(writer, this, submitsAutomatically, submitsProgramatically, (CausesValidation && Page.Validators.Count > 0));
                }
            }

            base.RenderAttributes(writer);  // this must come last because of the self-closing /
        }

        /// <include file='doc\HtmlInputButton.uex' path='docs/doc[@for="HtmlInputButton.OnServerClick"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='ServerClick '/> event.</para>
        /// </devdoc>
        protected virtual void OnServerClick(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventServerClick];
            if (handler != null) handler(this, e);
        }

        /*
         * Method of IPostBackEventHandler interface to raise events on post back.
         * Button fires an OnServerClick event.
         */
        /// <include file='doc\HtmlInputButton.uex' path='docs/doc[@for="HtmlInputButton.IPostBackEventHandler.RaisePostBackEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        void IPostBackEventHandler.RaisePostBackEvent(string eventArgument) {
            if (CausesValidation) {
                Page.Validate();
            }
            OnServerClick(EventArgs.Empty);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlControl.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {
    using System;
    using System.Globalization;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.IO;
    using System.Web.Util;
    using System.Web.UI;
    using AttributeCollection = System.Web.UI.AttributeCollection;
    using System.Security.Permissions;

    internal class HtmlControlBuilder : ControlBuilder {
        internal HtmlControlBuilder() {}

        // HtmlControls do not have a body or end tag.
        // For example, INPUT or IMG tags.
        public override bool HasBody() {
            return false;
        }
    }

/*
 * An abstract base class representing an intrinsic Html tag that
 * is not represented by both a begin and end tag, for example
 * INPUT or IMG.
 */
/// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlControl'/>
///       class defines the methods, properties, and events
///       common to all HTML Server controls in the Web Forms page framework.
///    </para>
/// </devdoc>
    [
    Designer("System.Web.UI.Design.HtmlIntrinsicControlDesigner, " + AssemblyRef.SystemDesign),
    ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    abstract public class HtmlControl : Control, IAttributeAccessor {
        internal string             _tagName;
        private AttributeCollection _attributes;


        /// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl.HtmlControl"]/*' />
        /// <devdoc>
        /// </devdoc>
        public HtmlControl() : this("span") {
        }

        /// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl.HtmlControl1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public HtmlControl(string tag) {
            _tagName = tag;
        }


        /*
         *  Access to collection of Attributes.
         */
        /// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl.Attributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets all attribute name/value pairs expressed on a
        ///       server control tag within a selected ASP.NET page.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public AttributeCollection Attributes {
            get {
                if (_attributes == null)
                    _attributes = new AttributeCollection(ViewState);

                return _attributes;
            }
        }


        /*
         *  Access to collection of styles.
         */
        /// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl.Style"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets all
        ///       cascading style sheet (CSS) properties that
        ///       are applied
        ///       to a specified HTML Server control in an .aspx
        ///       file.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public CssStyleCollection Style {
            get {
                return Attributes.CssStyle;
            }
        }

        /*
         * Property to get name of tag.
         */
        /// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl.TagName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the element name of a tag that contains a runat=server
        ///       attribute/value pair.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public virtual  string TagName {
            get { return _tagName;}
        }

        /*
         * Disabled property.
         */
        /// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl.Disabled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       a value indicating whether the Disabled attribute is included when a server
        ///       control is rendered.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public bool Disabled {
            get {
                string s = Attributes["disabled"];
                return((s != null) ? (s.Equals("disabled")) : false);
            }

            set {
                if (value)
                    Attributes["disabled"] = "disabled";
                else
                    Attributes["disabled"] = null;

            }
        }

        /// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl.ViewStateIgnoresCase"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override bool ViewStateIgnoresCase {
            get {
                return true;
            }
        }

        /// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl.CreateControlCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override ControlCollection CreateControlCollection() {
            return new EmptyControlCollection(this);
        }

        /*
         * Render the control into the given writer.
         */
        /// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl.Render"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void Render(HtmlTextWriter writer) {
            RenderBeginTag(writer);
        }

        /*
         * Render only the attributes, attr1=value1 attr2=value2 ...
         */
        /// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl.RenderAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual void RenderAttributes(HtmlTextWriter writer) {
            if (ID != null)
                writer.WriteAttribute("id", ClientID);

            Attributes.Render(writer);
        }

        /*
         * Render the begin tag and its attributes, &lt;TAGNAME attr1=value1 attr2=value2&gt;.
         */
        /// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl.RenderBeginTag"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual void RenderBeginTag(HtmlTextWriter writer) {
            writer.WriteBeginTag(TagName);
            RenderAttributes(writer);
            writer.Write(HtmlTextWriter.TagRightChar);
        }

        /*
         * HtmlControls support generic access to Attributes.
         */
        /// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl.IAttributeAccessor.GetAttribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        string IAttributeAccessor.GetAttribute(string name) {
            return Attributes[name];
        }

        /*
         * HtmlControls support generic access to Attributes.
         */
        /// <include file='doc\HtmlControl.uex' path='docs/doc[@for="HtmlControl.IAttributeAccessor.SetAttribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        void IAttributeAccessor.SetAttribute(string name, string value) {
            Attributes[name] = value;
        }

        internal void PreProcessRelativeReferenceAttribute(HtmlTextWriter writer,
            string attribName) {

            string url = Attributes[attribName];

            // Don't do anything if it's not specified
            if ((url == null) || (url.Length == 0))
                return;

            try { 
                url = ResolveClientUrl(url);
            } 
            catch (Exception e) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Property_Had_Malformed_Url, attribName, e.Message));
            }

            writer.WriteAttribute(attribName, url);
            Attributes.Remove(attribName);
        }

        internal static string MapStringAttributeToString(string s) {

            // If it's an empty string, change it to null
            if (s != null && s.Length == 0)
                return null;

            // Otherwise, just return the input
            return s;
        }

        internal static string MapIntegerAttributeToString(int n) {

            // If it's -1, change it to null
            if (n == -1)
                return null;

            // Otherwise, convert the integer to a string
            return n.ToString(NumberFormatInfo.InvariantInfo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlinputhidden.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlInputHidden.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlInputHidden.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {
    using System.ComponentModel;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

/// <include file='doc\HtmlInputHidden.uex' path='docs/doc[@for="HtmlInputHidden"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlInputHidden'/> class defines the methods, properties,
///       and events of the HtmlInputHidden control. This class allows programmatic access
///       to the HTML &lt;input type=hidden&gt; element on the server.
///    </para>
/// </devdoc>
    [
    DefaultEvent("ServerChange")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlInputHidden : HtmlInputControl, IPostBackDataHandler {

        private static readonly object EventServerChange = new object();

        /*
         * Creates an intrinsic Html INPUT type=hidden control.
         */
        /// <include file='doc\HtmlInputHidden.uex' path='docs/doc[@for="HtmlInputHidden.HtmlInputHidden"]/*' />
        public HtmlInputHidden() : base("hidden") {
        }

        /// <include file='doc\HtmlInputHidden.uex' path='docs/doc[@for="HtmlInputHidden.ServerChange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the <see langword='HtmlInputHidden'/> control
        ///       is changed on the server.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.HtmlInputHidden_OnServerChange)
        ]
        public event EventHandler ServerChange {
            add {
                Events.AddHandler(EventServerChange, value);
            }
            remove {
                Events.RemoveHandler(EventServerChange, value);
            }
        }

        /*
         * Method used to raise the OnServerChange event.
         */
        /// <include file='doc\HtmlInputHidden.uex' path='docs/doc[@for="HtmlInputHidden.OnServerChange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raised on the server when the <see langword='HtmlInputHidden'/> control
        ///       changes between postback requests.
        ///    </para>
        /// </devdoc>
        protected virtual void OnServerChange(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventServerChange];
            if (handler != null) handler(this, e);
        }

        /*
         *
         */
        /// <include file='doc\HtmlInputHidden.uex' path='docs/doc[@for="HtmlInputHidden.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {
            // if no change handler, no need to save posted property
            if (Events[EventServerChange] == null && !Disabled) {
                ViewState.SetItemDirty("value",false);
            }
        }

        /*
         * Method of IPostBackDataHandler interface to process posted data.
         * InputText process a newly posted value.
         */
        /// <include file='doc\HtmlInputHidden.uex' path='docs/doc[@for="HtmlInputHidden.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IPostBackDataHandler.LoadPostData(string postDataKey, NameValueCollection postCollection) {
            string current = Value;
            string text = postCollection.GetValues(postDataKey)[0]; 

            if (!current.Equals(text)) {
                Value = text;
                return true;
            }

            return false;
        }

        /*
         * Method of IPostBackDataHandler interface which is invoked whenever posted data
         * for a control has changed.  TextBox fires an OnTextChanged event.
         */
        /// <include file='doc\HtmlInputHidden.uex' path='docs/doc[@for="HtmlInputHidden.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            OnServerChange(EventArgs.Empty);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlinputradiobutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlInputRadioButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlInputRadioButton.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {
    using System.ComponentModel;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

/// <include file='doc\HtmlInputRadioButton.uex' path='docs/doc[@for="HtmlInputRadioButton"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlInputRadioButton'/> class defines the methods,
///       properties, and events for the HtmlInputRadio control. This class allows
///       programmatic access to the HTML &lt;input type=
///       radio&gt;
///       element on the server.
///    </para>
/// </devdoc>
    [
    DefaultEvent("ServerChange")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlInputRadioButton : HtmlInputControl, IPostBackDataHandler {

        private static readonly object EventServerChange = new object();

        /*
         * Creates an intrinsic Html INPUT type=radio control.
         */
        /// <include file='doc\HtmlInputRadioButton.uex' path='docs/doc[@for="HtmlInputRadioButton.HtmlInputRadioButton"]/*' />
        public HtmlInputRadioButton() : base("radio") {
        }

        /*
         * Checked property.
         */
        /// <include file='doc\HtmlInputRadioButton.uex' path='docs/doc[@for="HtmlInputRadioButton.Checked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether a radio button is
        ///       currently selected or not.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Default"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public bool Checked {
            get {
                string s = Attributes["checked"];
                return((s != null) ? (s.Equals("checked")) : false);
            }
            set {
                if (value)
                    Attributes["checked"] = "checked";
                else
                    Attributes["checked"] = null;
            }
        }

        /// <include file='doc\HtmlInputRadioButton.uex' path='docs/doc[@for="HtmlInputRadioButton.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the value of the HTML
        ///       Name attribute that will be rendered to the browser.
        ///    </para>
        /// </devdoc>
        public override string Name {
            get { 
                string s = Attributes["name"];
                return ((s != null) ? s : "");
            }
            set { 
                Attributes["name"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlInputRadioButton.uex' path='docs/doc[@for="HtmlInputRadioButton.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the contents of a text box.
        ///    </para>
        /// </devdoc>
        public override string Value {
            get {
                string val = base.Value;
                
                if (val.Length != 0) 
                    return val;

                val = ID;
                if (ID != null)
                    return val;
                
                // if specific value is not provided, use the UniqueID
                return UniqueID;
            }
            set {
                base.Value = value;
            }
        }

        // Value that gets rendered for the Name attribute
        internal override string RenderedNameAttribute {
            get {
                // For radio buttons, we must make the name unique, but can't just use the
                // UniqueID because all buttons in a group must have the same name.  So
                // we replace the last part of the UniqueID with the group Name.
                string name = base.RenderedNameAttribute;
                string uid = UniqueID;
                int lastColon = uid.LastIndexOf(Control.ID_SEPARATOR);
                if (lastColon >= 0)
                    name = uid.Substring(0, lastColon+1) + name;
                return name;
            }
        }

        /// <include file='doc\HtmlInputRadioButton.uex' path='docs/doc[@for="HtmlInputRadioButton.ServerChange"]/*' />
        [
        WebCategory("Action"),
        WebSysDescription(SR.HtmlInputRadioButton_OnServerChange)
        ]
        public event EventHandler ServerChange {
            add {
                Events.AddHandler(EventServerChange, value);
            }
            remove {
                Events.RemoveHandler(EventServerChange, value);
            }
        }

        /*
         * This method is invoked just prior to rendering.
         */
        /// <include file='doc\HtmlInputRadioButton.uex' path='docs/doc[@for="HtmlInputRadioButton.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {
            if (Page != null && !Disabled)
                Page.RegisterRequiresPostBack(this);

            // if no change handler, no need to save posted property
            if (Events[EventServerChange] == null && !Disabled) {
                ViewState.SetItemDirty("checked",false);
            }
        }

        /*
         * Method used to raise the OnServerChange event.
         */
        /// <include file='doc\HtmlInputRadioButton.uex' path='docs/doc[@for="HtmlInputRadioButton.OnServerChange"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected virtual void OnServerChange(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventServerChange];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\HtmlInputRadioButton.uex' path='docs/doc[@for="HtmlInputRadioButton.RenderAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderAttributes(HtmlTextWriter writer) {
            writer.WriteAttribute("value", Value);
            Attributes.Remove("value");
            base.RenderAttributes(writer);
        }

        /*
         * Method of IPostBackDataHandler interface to process posted data.
         * RadioButton determines the posted radio group state.
         */
        /// <include file='doc\HtmlInputRadioButton.uex' path='docs/doc[@for="HtmlInputRadioButton.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IPostBackDataHandler.LoadPostData(string postDataKey, NameValueCollection postCollection) {
            string postValue = postCollection[RenderedNameAttribute];
            bool valueChanged = false;
            if ((postValue != null) && postValue.Equals(Value)) {
                if (Checked == false) {
                    Checked = true;
                    // only fire change event for RadioButton that is being checked
                    valueChanged = true;
                }
            }
            else {
                if (Checked == true) {
                    Checked = false;
                }
            }

            return valueChanged;
        }

        /*
         * Method of IPostBackDataHandler interface which is invoked whenever posted data
         * for a control has changed.  RadioButton fires an OnServerChange event.
         */
        /// <include file='doc\HtmlInputRadioButton.uex' path='docs/doc[@for="HtmlInputRadioButton.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            OnServerChange(EventArgs.Empty);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlinputcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlInputControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlInputControl.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {

    using System;
    using System.ComponentModel;
    using System.Web;
    using System.Web.UI;
    using Debug=System.Web.Util.Debug;
    using System.Security.Permissions;

/*
 * An abstract base class representing an intrinsic INPUT tag.
 */
/// <include file='doc\HtmlInputControl.uex' path='docs/doc[@for="HtmlInputControl"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlInputControl'/> abstract class defines
///       the methods, properties, and events common to all HTML input controls.
///       These include controls for the &lt;input type=text&gt;, &lt;input
///       type=submit&gt;, and &lt;input type=file&gt; elements.
///    </para>
/// </devdoc>
    [
    ControlBuilderAttribute(typeof(HtmlControlBuilder))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    abstract public class HtmlInputControl : HtmlControl {
        /*
         *  Creates a new Input
         */
        /// <include file='doc\HtmlInputControl.uex' path='docs/doc[@for="HtmlInputControl.HtmlInputControl"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.HtmlControls.HtmlInputControl'/> class.</para>
        /// </devdoc>
        public HtmlInputControl(string type) : base("input") {
            Attributes["type"] = type;
        }

        /*
         * Name property
         */
        /// <include file='doc\HtmlInputControl.uex' path='docs/doc[@for="HtmlInputControl.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the value of the HTML
        ///       Name attribute that will be rendered to the browser.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public virtual string Name {
            get { 
                return UniqueID;
                //string s = Attributes["name"];
                //return ((s != null) ? s : "");
            }
            set { 
                //Attributes["name"] = MapStringAttributeToString(value);
            }
        }

        // Value that gets rendered for the Name attribute
        internal virtual string RenderedNameAttribute {
            get {
                return Name;
                //string name = Name;
                //if (name.Length == 0)
                //    return UniqueID;
                
                //return name;
            }
        }

        /*
         * Value property.
         */
        /// <include file='doc\HtmlInputControl.uex' path='docs/doc[@for="HtmlInputControl.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the contents of a text box.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public virtual string Value {
            get {
                string s = Attributes["value"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["value"] = MapStringAttributeToString(value);
            }
        }

        /*
         * Type of input
         */
        /// <include file='doc\HtmlInputControl.uex' path='docs/doc[@for="HtmlInputControl.Type"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the Type attribute for a particular HTML input control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Type {
            get {
                string s = Attributes["type"];
                return((s != null) ? s : "");
            }
        }

        /*
         * Override to render unique name attribute.
         * The name attribute is owned by the framework.
         */
        /// <include file='doc\HtmlInputControl.uex' path='docs/doc[@for="HtmlInputControl.RenderAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderAttributes(HtmlTextWriter writer) {
        
            writer.WriteAttribute("name", RenderedNameAttribute);
            Attributes.Remove("name");

            base.RenderAttributes(writer);
            writer.Write(" /");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlinputimage.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlInputImage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlInputImage.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Globalization;
    using System.ComponentModel;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

/// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlInputImage'/> class defines the
///       methods, properties and events for the HtmlInputImage control. This class allows
///       programmatic access to the HTML &lt;input type=
///       image&gt; element on the server.
///    </para>
/// </devdoc>
    [
    DefaultEvent("ServerClick")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlInputImage : HtmlInputControl,
    IPostBackDataHandler, IPostBackEventHandler {

        private static readonly object EventServerClick = new object();
        private int _x;
        private int _y;


        /*
         * Creates an intrinsic Html INPUT type=image control.
         */
        /// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage.HtmlInputImage"]/*' />
        public HtmlInputImage() : base("image") {
        }

        /// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage.Align"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the image
        ///       alignment within the form's content flow.
        ///    </para>
        /// </devdoc>
        /*
         * Align property.
         */
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Align {
            get {
                string s = Attributes["align"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["align"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage.Alt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the alternative text
        ///       that the browser should display if the image is either unavailable or has not
        ///       been downloaded yet.
        ///    </para>
        /// </devdoc>
        /*
         * Alt property.
         */
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Alt {
            get {
                string s = Attributes["alt"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["alt"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage.Border"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the
        ///       border width, in pixels, around the image.
        ///    </para>
        /// </devdoc>
        /*
         * Border property, size of border in pixels.
         */
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Border {
            get {
                string s = Attributes["border"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }
            set {
                Attributes["border"] = MapIntegerAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage.Src"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the location of
        ///       the image file relative to the page on which it is displayed.
        ///    </para>
        /// </devdoc>
        /*
         * Src property.
         */
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Src {
            get {
                string s = Attributes["src"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["src"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage.CausesValidation"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets whether pressing the button causes page validation to fire. This defaults to True so that when
        ///          using validation controls, the validation state of all controls are updated when the button is clicked, both
        ///          on the client and the server. Setting this to False is useful when defining a cancel or reset button on a page
        ///          that has validators.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(true),
        ]
        public bool CausesValidation {
            get {
                object b = ViewState["CausesValidation"];
                return((b == null) ? true : (bool)b);
            }
            set {
                ViewState["CausesValidation"] = value;
            }
        }

        /// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage.ServerClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs on the server when a user clicks an <see langword='HtmlInputImage'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.HtmlInputImage_OnServerClick)
        ]
        public event ImageClickEventHandler ServerClick {
            add {
                Events.AddHandler(EventServerClick, value);
            }
            remove {
                Events.RemoveHandler(EventServerClick, value);
            }
        }

        /// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        /*
         * This method is invoked just prior to rendering.
         * Register requires handling postback to determine if image has been clicked.
         */
        protected override void OnPreRender(EventArgs e) {
            if (Page != null) {
                if (!Disabled)
                    Page.RegisterRequiresPostBack(this);
                if (CausesValidation)
                    Page.RegisterPostBackScript();
            }
        }


        /// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage.OnServerClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raised on the server when a user clicks an <see langword='HtmlInputImage'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        /*
         * Method used to raise the OnServerClick event.
         */
        protected virtual void OnServerClick(ImageClickEventArgs e) {
            ImageClickEventHandler handler = (ImageClickEventHandler)Events[EventServerClick];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage.IPostBackEventHandler.RaisePostBackEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        /*
         * Method of IPostBackEventHandler interface to raise events on post back.
         * HtmlInputImage fires an OnServerClick event.
         */
        void IPostBackEventHandler.RaisePostBackEvent(string eventArgument) {
            if (CausesValidation) {
                Page.Validate();
            }
            OnServerClick(new ImageClickEventArgs(_x, _y));
        }

        /// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        /*
         * Method of IPostBackDataHandler interface to process posted data.
         * The image control will check to see if the x and y values were posted,
         * which indicates that the image was clicked by the user.  The image
         * control will then register with the Page that it wants to raise an event
         * during the event processing phase.
         */
        bool IPostBackDataHandler.LoadPostData(string postDataKey, NameValueCollection postCollection) {
            string postX = postCollection[RenderedNameAttribute + ".x"];
            string postY = postCollection[RenderedNameAttribute + ".y"];

            if (postX != null && postY != null && 
                postX.Length > 0 && postY.Length > 0) {
                _x = Int32.Parse(postX, CultureInfo.InvariantCulture);
                _y = Int32.Parse(postY, CultureInfo.InvariantCulture);

                Page.RegisterRequiresRaiseEvent(this);
            }

            return false;
        }

        /// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        /*
         * Method of IPostBackDataHandler interface which is invoked whenever posted data
         * for a control has changed.
         */
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
        }

        /*
         * Override to render unique name attribute.
         * The name attribute is owned by the framework.
         */
        /// <include file='doc\HtmlInputImage.uex' path='docs/doc[@for="HtmlInputImage.RenderAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderAttributes(HtmlTextWriter writer) {
            PreProcessRelativeReferenceAttribute(writer, "src");

            if (Page != null && CausesValidation) {
                Util.WriteOnClickAttribute(writer, this, true, false, (CausesValidation && Page.Validators.Count > 0));
            }

            base.RenderAttributes(writer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlinputfile.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlInputFile.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

/*
 * HtmlInputFile.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Globalization;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

/// <include file='doc\HtmlInputFile.uex' path='docs/doc[@for="HtmlInputFile"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlInputFile'/> class defines the
///       methods, properties, and events for the <see langword='HtmlInputFile'/> control. This class allows
///       programmatic access to the HTML &lt;input type= file&gt; element on the server.
///       It provides access to the stream, as well as a useful SaveAs functionality
///       provided by the <see cref='System.Web.UI.HtmlControls.HtmlInputFile.PostedFile'/>
///       property.
///    </para>
///    <note type="caution">
///       This class only works if the
///       HtmlForm.Enctype property is set to "multipart/form-data".
///       Also, it does not maintain its
///       state across multiple round trips between browser and server. If the user sets
///       this value after a round trip, the value is lost.
///    </note>
/// </devdoc>
    [
    ValidationProperty("Value")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlInputFile : HtmlInputControl, IPostBackDataHandler {

        /*
         * Creates an intrinsic Html INPUT type=file control.
         */
        /// <include file='doc\HtmlInputFile.uex' path='docs/doc[@for="HtmlInputFile.HtmlInputFile"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.HtmlControls.HtmlInputFile'/> class.</para>
        /// </devdoc>
        public HtmlInputFile() : base("file") {
        }

        /*
         * Accept type property.
         */
        /// <include file='doc\HtmlInputFile.uex' path='docs/doc[@for="HtmlInputFile.Accept"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets a comma-separated list of MIME encodings that
        ///       can be used to constrain the file types that the browser lets the user
        ///       select. For example, to restrict the
        ///       selection to images, the accept value image/* should be specified.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Accept {
            get {
                string s = Attributes["accept"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["accept"] = MapStringAttributeToString(value);
            }
        }

        /*
         * The property for the maximum characters allowed.
         */
        /// <include file='doc\HtmlInputFile.uex' path='docs/doc[@for="HtmlInputFile.MaxLength"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the
        ///       maximum length of the file path of the file to upload
        ///       from the client machine.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int MaxLength {
            get {
                string s = Attributes["maxlength"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }
            set {
                Attributes["maxlength"] = MapIntegerAttributeToString(value);
            }
        }

        /*
         * PostedFile property.
         */
        /// <include file='doc\HtmlInputFile.uex' path='docs/doc[@for="HtmlInputFile.PostedFile"]/*' />
        /// <devdoc>
        ///    <para>Gets access to the uploaded file specified by a client.</para>
        /// </devdoc>
        [
        WebCategory("Default"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public HttpPostedFile PostedFile {
            get { return Context.Request.Files[RenderedNameAttribute];}
        }

        /*
         * The property for the width in characters.
         */
        /// <include file='doc\HtmlInputFile.uex' path='docs/doc[@for="HtmlInputFile.Size"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the width of the file-path text box that the
        ///       browser displays when the <see cref='System.Web.UI.HtmlControls.HtmlInputFile'/>
        ///       control is used on a page.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Size {
            get {
                string s = Attributes["size"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }
            set {
                Attributes["size"] = MapIntegerAttributeToString(value);
            }
        }

        // ASURT 122262 : The value property isn't submitted back to us when the a page
        // containing this control postsback, so required field validators are broken
        // (value would contain the empty string).  To fix this, we return the filename.
        /// <include file='doc\HtmlInputFile.uex' path='docs/doc[@for="HtmlInputFile.Value"]/*' />
        [
        Browsable(false)
        ]
        public override string Value {
            get {
                HttpPostedFile postedFile = PostedFile;
                if (postedFile != null) {
                    return postedFile.FileName;
                }

                return String.Empty;
            }
            set {
                // Throw here because setting the value on this tag has no effect on the
                // rendering behavior and since we're always returning the posted file's
                // filename, we don't want to get into a situation where the user
                // sets a value and does not get back that value.
                throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.Value_Set_Not_Supported, this.GetType().Name));
            }
        }

        /*
         * Method of IPostBackDataHandler interface to process posted data.
         */
        /// <include file='doc\HtmlInputFile.uex' path='docs/doc[@for="HtmlInputFile.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        bool IPostBackDataHandler.LoadPostData(string postDataKey, NameValueCollection postCollection) {
            return false;
        }

        /*
         * Method of IPostBackDataHandler interface which is invoked whenever
         * posted data for a control has changed.  RadioButton fires an
         * OnServerChange event.
         */
        /// <include file='doc\HtmlInputFile.uex' path='docs/doc[@for="HtmlInputFile.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            // REVIEW: do we want a change handler?
            //OnServerChange(EventArgs.Empty);
        }

        /// <include file='doc\HtmlInputFile.uex' path='docs/doc[@for="HtmlInputFile.OnPreRender"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='PreRender'/> event. This method uses event arguments
        ///    to pass the event data to the control.</para>
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {
            base.OnPreRender(e);

            // ASURT 35328: use multipart encoding if no encoding is currently specified
            HtmlForm form = Page.Form;
            if (form != null && form.Enctype.Length == 0) {
                form.Enctype = "multipart/form-data";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlinputtext.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlInputText.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlInputText.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {
    using System.ComponentModel;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Globalization;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

/// <include file='doc\HtmlInputText.uex' path='docs/doc[@for="HtmlInputText"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlInputText'/>
///       class defines the methods, properties, and events for the HtmlInputText server
///       control. This class allows programmatic access to the HTML &lt;input type=
///       text&gt;
///       and &lt;input type=
///       password&gt; elements on the server.
///    </para>
/// </devdoc>
    [
    DefaultEvent("ServerChange"),
    ValidationProperty("Value")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlInputText : HtmlInputControl, IPostBackDataHandler {

        private static readonly object EventServerChange = new object();

        /*
         * Creates an intrinsic Html INPUT type=text control.
         */
        /// <include file='doc\HtmlInputText.uex' path='docs/doc[@for="HtmlInputText.HtmlInputText"]/*' />
        public HtmlInputText() : base("text") {
        }

        /*
         * Creates an intrinsic Html INPUT type=text,password control.
         */
        /// <include file='doc\HtmlInputText.uex' path='docs/doc[@for="HtmlInputText.HtmlInputText1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public HtmlInputText(string type) : base(type) {
        }

        /*
         * The property for the maximum characters allowed.
         */
        /// <include file='doc\HtmlInputText.uex' path='docs/doc[@for="HtmlInputText.MaxLength"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the maximum number of characters that
        ///       can be typed into the text box.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int MaxLength {
            get {
                string s = (string)ViewState["maxlength"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }

            set {
                Attributes["maxlength"] = MapIntegerAttributeToString(value);
            }
        }

        // CONSIDER: PostbackOnChange prop

        /*
         * The property for the width of the TextBox in characters.
         */
        /// <include file='doc\HtmlInputText.uex' path='docs/doc[@for="HtmlInputText.Size"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the width of a text box, in characters.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Size {
            get {
                string s = Attributes["size"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }
            set {
                Attributes["size"] = MapIntegerAttributeToString(value);
            }
        }

        /*
         * Value property.
         */
        /// <include file='doc\HtmlInputText.uex' path='docs/doc[@for="HtmlInputText.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the
        ///       contents of a text box.
        ///    </para>
        /// </devdoc>
        public override string Value {
            get {
                string s = Attributes["value"];
                return((s != null) ? s : "");
            }
            set {
                Attributes["value"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlInputText.uex' path='docs/doc[@for="HtmlInputText.ServerChange"]/*' />
        [
        WebCategory("Action"),
        WebSysDescription(SR.HtmlInputText)
        ]
        public event EventHandler ServerChange {
            add {
                Events.AddHandler(EventServerChange, value);
            }
            remove {
                Events.RemoveHandler(EventServerChange, value);
            }
        }

        /*
         * Method used to raise the OnServerChange event.
         */
        /// <include file='doc\HtmlInputText.uex' path='docs/doc[@for="HtmlInputText.OnServerChange"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected virtual void OnServerChange(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventServerChange];
            if (handler != null) handler(this, e);
        }

        /*
         *
         */
        /// <include file='doc\HtmlInputText.uex' path='docs/doc[@for="HtmlInputText.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {
            // if no change handler, no need to save posted property unless we are disabled
            if (Events[EventServerChange] == null && !Disabled) {
                ViewState.SetItemDirty("value", false);
            }
        }

        /*
         * Method of IPostBackDataHandler interface to process posted data.
         * InputText process a newly posted value.
         */
        /// <include file='doc\HtmlInputText.uex' path='docs/doc[@for="HtmlInputText.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IPostBackDataHandler.LoadPostData(string postDataKey, NameValueCollection postCollection) {
            string current = Value;
            string inputString = postCollection.GetValues(postDataKey)[0]; 

            if (!current.Equals(inputString)) {
                Value = inputString;
                return true;
            }

            return false;
        }

        /*
         * Method of IPostBackDataHandler interface which is invoked whenever posted data
         * for a control has changed.  InputText fires an OnServerChange event.
         */
        /// <include file='doc\HtmlInputText.uex' path='docs/doc[@for="HtmlInputText.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            OnServerChange(EventArgs.Empty);
        }

        /// <include file='doc\HtmlInputText.uex' path='docs/doc[@for="HtmlInputText.RenderAttributes"]/*' />
        protected override void RenderAttributes(HtmlTextWriter writer) {
            if (String.Compare(Type, "password", true, CultureInfo.InvariantCulture) == 0)
                ViewState.Remove("value");

            base.RenderAttributes(writer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmltablecell.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlTableCell.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlTableCell.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

/// <include file='doc\HtmlTableCell.uex' path='docs/doc[@for="HtmlTableCell"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlTableCell'/>
///       class defines the properties, methods, and events for the HtmlTableCell control.
///       This class allows programmatic access on the server to individual HTML
///       &lt;td&gt; and &lt;th&gt; elements enclosed within an
///    <see langword='HtmlTableRow'/>
///    control.
/// </para>
/// </devdoc>
    [ConstructorNeedsTag(true)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlTableCell : HtmlContainerControl {
        /// <include file='doc\HtmlTableCell.uex' path='docs/doc[@for="HtmlTableCell.HtmlTableCell"]/*' />
        /// <devdoc>
        /// </devdoc>
        public HtmlTableCell() : base("td") {
        }

        /// <include file='doc\HtmlTableCell.uex' path='docs/doc[@for="HtmlTableCell.HtmlTableCell1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public HtmlTableCell(string tagName) : base(tagName) {
        }

        /// <include file='doc\HtmlTableCell.uex' path='docs/doc[@for="HtmlTableCell.Align"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the horizontal alignment of content within an
        ///    <see langword='HtmlTableCell'/> control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Align {
            get {
                string s = Attributes["align"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["align"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTableCell.uex' path='docs/doc[@for="HtmlTableCell.BgColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the background color of an <see langword='HtmlTableCell'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string BgColor {
            get {
                string s = Attributes["bgcolor"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["bgcolor"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTableCell.uex' path='docs/doc[@for="HtmlTableCell.BorderColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the border color of an <see langword='HtmlTableCell'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string BorderColor {
            get {
                string s = Attributes["bordercolor"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["bordercolor"] = MapStringAttributeToString(value);
            }
        }

        /*
         * Number of columns that this cell spans.
         */
        /// <include file='doc\HtmlTableCell.uex' path='docs/doc[@for="HtmlTableCell.ColSpan"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of columns that the HtmlTableCell control spans.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int ColSpan {
            get {
                string s = Attributes["colspan"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }
            set {
                Attributes["colspan"] = MapIntegerAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTableCell.uex' path='docs/doc[@for="HtmlTableCell.Height"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the height, in pixels, of an <see langword='HtmlTableCell'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Height {
            get {
                string s = Attributes["height"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["height"] = MapStringAttributeToString(value);
            }
        }

        /*
         * Suppresses wrapping.
         */
        /// <include file='doc\HtmlTableCell.uex' path='docs/doc[@for="HtmlTableCell.NoWrap"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether text within an
        ///    <see langword='HtmlTableCell'/> control
        ///       should be wrapped.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public bool NoWrap {
            get {
                string s = Attributes["nowrap"];
                return((s != null) ? (s.Equals("nowrap")) : false);
            }

            set {
                if (value) 
                    Attributes["nowrap"] = "nowrap";
                else 
                    Attributes["nowrap"] = null;
            }
        }

        /*
         * Number of rows that this cell spans.
         */
        /// <include file='doc\HtmlTableCell.uex' path='docs/doc[@for="HtmlTableCell.RowSpan"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of rows an <see langword='HtmlTableCell'/> control
        ///       spans.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int RowSpan {
            get {
                string s = Attributes["rowspan"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }
            set {
                Attributes["rowspan"] = MapIntegerAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTableCell.uex' path='docs/doc[@for="HtmlTableCell.VAlign"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the vertical alignment for text within an
        ///    <see langword='HtmlTableCell'/> control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string VAlign {
            get {
                string s = Attributes["valign"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["valign"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTableCell.uex' path='docs/doc[@for="HtmlTableCell.Width"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the width, in pixels, of an <see langword='HtmlTableCell'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Width {
            get {
                string s = Attributes["width"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["width"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTableCell.uex' path='docs/doc[@for="HtmlTableCell.RenderEndTag"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderEndTag(HtmlTextWriter writer) {
            base.RenderEndTag(writer);
            writer.WriteLine();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmltablerowcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlTableRowCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlTableRowCollection.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {
    using System.Runtime.InteropServices;

    using System;
    using System.Collections;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

/// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlTableRowCollection'/> contains all
///       of the table rows found within an <see langword='HtmlTable'/>
///       server control.
///    </para>
/// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HtmlTableRowCollection : ICollection {
        /// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection.owner"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        private HtmlTable owner;

        internal HtmlTableRowCollection(HtmlTable owner) {
            this.owner = owner;
        }

        /*
         * The number of cells in the row.
         */
        /// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of items in the
        ///    <see langword='HtmlTableRow'/>
        ///    collection.
        /// </para>
        /// </devdoc>
        public int Count {
            get {
                if (owner.HasControls())
                    return owner.Controls.Count;

                return 0;
            }
        }

        /// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an <see langword='HtmlTableRow'/> control from an <see langword='HtmlTable'/>
        ///       control thorugh the row's ordinal index value.
        ///    </para>
        /// </devdoc>
        public HtmlTableRow this[int index]
        {
            get {
                return(HtmlTableRow)owner.Controls[index];
            }
        }

        /// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the specified HtmlTableRow control to the end of the collection.
        ///    </para>
        /// </devdoc>
        public void Add(HtmlTableRow row) {
            Insert(-1, row);
        }

        /// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an <see langword='HtmlTableRow'/> control to a specified
        ///       location in the collection.
        ///    </para>
        /// </devdoc>
        public void Insert(int index, HtmlTableRow row) {
            owner.Controls.AddAt(index, row);
        }

        /// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Deletes all <see langword='HtmlTableRow'/> controls from the collection.
        ///    </para>
        /// </devdoc>
        public void Clear() {
            if (owner.HasControls())
                owner.Controls.Clear();
        }

        /// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection.SyncRoot"]/*' />
        /// <devdoc>
        /// </devdoc>
        public Object SyncRoot {
            get { return this;}
        }

        /// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection.IsReadOnly"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsReadOnly {
            get { return false;}
        }

        /// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection.IsSynchronized"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsSynchronized {
            get { return false;}
        }

        /// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection.GetEnumerator"]/*' />
        /// <devdoc>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return owner.Controls.GetEnumerator();
        }

        /// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Deletes the specified <see langword='HtmlTableRow'/>
        ///       control
        ///       from the collection.
        ///    </para>
        /// </devdoc>
        public void Remove(HtmlTableRow row) {
            owner.Controls.Remove(row);
        }

        /// <include file='doc\HtmlTableRowCollection.uex' path='docs/doc[@for="HtmlTableRowCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Deletes the <see langword='HtmlTableRow'/> control at the specified index
        ///       location from the collection.
        ///    </para>
        /// </devdoc>
        public void RemoveAt(int index) {
            owner.Controls.RemoveAt(index);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmltextarea.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlTextArea.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlTextArea.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {
    using System.ComponentModel;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Web;
    using System.Web.UI;
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\HtmlTextArea.uex' path='docs/doc[@for="HtmlTextArea"]/*' />
    /// <devdoc>
    ///    <para>Defines the methods, properties, and events for the 
    ///    <see cref='System.Web.UI.HtmlControls.HtmlTextArea'/> 
    ///    class that
    ///    allows programmatic access to the HTML &lt;textarea&gt;.</para>
    /// </devdoc>
    [
    DefaultEvent("ServerChange"),
    ValidationProperty("Value")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlTextArea : HtmlContainerControl, IPostBackDataHandler {

        private static readonly object EventServerChange = new object();

        /*
         *  Creates an intrinsic Html TEXTAREA control.
         */
        /// <include file='doc\HtmlTextArea.uex' path='docs/doc[@for="HtmlTextArea.HtmlTextArea"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Web.UI.HtmlControls.HtmlTextArea'/> class.
        /// </devdoc>
        public HtmlTextArea() : base("textarea") {
        }

        /*
         * The property for the number of columns to display.
         */
        /// <include file='doc\HtmlTextArea.uex' path='docs/doc[@for="HtmlTextArea.Cols"]/*' />
        /// <devdoc>
        ///    <para> Indicates the display width (in characters) of the
        ///       text area.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Cols {
            get {
                string s = Attributes["cols"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }
            set {
                Attributes["cols"] = MapIntegerAttributeToString(value);
            }
        }

        /*
         * Name property.
         */
        /// <include file='doc\HtmlTextArea.uex' path='docs/doc[@for="HtmlTextArea.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the value of the HTML
        ///       Name attribute that will be rendered to the browser.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public virtual string Name {
            get { 
                return UniqueID;
                //string s = Attributes["name"];
                //return ((s != null) ? s : "");
            }
            set { 
                //Attributes["name"] = MapStringAttributeToString(value);
            }
        }

        // Value that gets rendered for the Name attribute
        internal string RenderedNameAttribute {
            get {
                return Name;
                //string name = Name;
                //if (name.Length == 0)
                //    return UniqueID;
                
                //return name;
            }
        }
        
        /*
         * The property for the number of rows to display.
         */
        /// <include file='doc\HtmlTextArea.uex' path='docs/doc[@for="HtmlTextArea.Rows"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the display height (in rows) of the text area.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Rows {
            get {
                string s = Attributes["rows"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }
            set {
                Attributes["rows"] = MapIntegerAttributeToString(value);
            }
        }

        /*
         * Value property.  Equivalent to InnerHtml for HtmlTextArea.
         */
        /// <include file='doc\HtmlTextArea.uex' path='docs/doc[@for="HtmlTextArea.Value"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the content of the text area.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Value {
            get { return InnerHtml;}
            set { InnerHtml = value;}
        }

        /// <include file='doc\HtmlTextArea.uex' path='docs/doc[@for="HtmlTextArea.ServerChange"]/*' />
        /// <devdoc>
        /// <para>Occurs when the content of the <see langword='HtmlTextArea'/> control is changed upon server
        ///    postback.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.HtmlTextArea_OnServerChange)
        ]
        public event EventHandler ServerChange {
            add {
                Events.AddHandler(EventServerChange, value);
            }
            remove {
                Events.RemoveHandler(EventServerChange, value);
            }
        }

        /// <include file='doc\HtmlTextArea.uex' path='docs/doc[@for="HtmlTextArea.AddParsedSubObject"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Overridden to only allow literal controls to be added as Text property.
        /// </devdoc>
        protected override void AddParsedSubObject(object obj) {
            if (obj is LiteralControl || obj is DataBoundLiteralControl)
                base.AddParsedSubObject(obj);
            else 
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "HtmlTextArea", obj.GetType().Name.ToString()));
        }

        /// <include file='doc\HtmlTextArea.uex' path='docs/doc[@for="HtmlTextArea.RenderAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderAttributes(HtmlTextWriter writer) {
            writer.WriteAttribute("name", RenderedNameAttribute);
            Attributes.Remove("name");

            base.RenderAttributes(writer);
        }

        /// <include file='doc\HtmlTextArea.uex' path='docs/doc[@for="HtmlTextArea.OnServerChange"]/*' />
        /// <devdoc>
        /// <para>Raised the <see langword='ServerChange'/> 
        /// event.</para>
        /// </devdoc>
        protected virtual void OnServerChange(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventServerChange];
            if (handler != null) handler(this, e);
        }

        /*
         *
         */
        /// <include file='doc\HtmlTextArea.uex' path='docs/doc[@for="HtmlTextArea.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {
            // if no change handler, no need to save posted property
            if (Events[EventServerChange] == null && !Disabled) {
                ViewState.SetItemDirty("value",false);
            }
        }

        /*
         * Method of IPostBackDataHandler interface to process posted data.
         * TextArea process a newly posted value.
         */
        /// <include file='doc\HtmlTextArea.uex' path='docs/doc[@for="HtmlTextArea.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IPostBackDataHandler.LoadPostData(string postDataKey, NameValueCollection postCollection) {
            string current = Value;
            string text = postCollection.GetValues(postDataKey)[0]; 

            if (current == null || !current.Equals(text)) {
                Value = HttpUtility.HtmlEncode(text);
                return true;
            }

            return false;
        }

        /*
         * Method of IPostBackDataHandler interface which is invoked whenever posted data
         * for a control has changed.  TextArea fires an OnServerChange event.
         */
        /// <include file='doc\HtmlTextArea.uex' path='docs/doc[@for="HtmlTextArea.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            OnServerChange(EventArgs.Empty);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmltable.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.HtmlControls {
    using System;
    using System.Reflection;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;


    /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable"]/*' />
    /// <devdoc>
    ///    <para>Defines the properties, methods, and events for the 
    ///    <see cref='System.Web.UI.HtmlControls.HtmlTable'/> 
    ///    control that allows programmatic access on the
    ///    server to the HTML &lt;table&gt; element.</para>
    /// </devdoc>
    [
    ParseChildren(true, "Rows")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlTable : HtmlContainerControl {
        HtmlTableRowCollection rows;

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.HtmlTable"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Web.UI.HtmlControls.HtmlTable'/> class.
        /// </devdoc>
        public HtmlTable() : base("table") {
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.Align"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the alignment of content within the <see cref='System.Web.UI.HtmlControls.HtmlTable'/> 
        /// control.</para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Align {
            get {
                string s = Attributes["align"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["align"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.BgColor"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the background color of an <see cref='System.Web.UI.HtmlControls.HtmlTable'/>
        /// control.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string BgColor {
            get {
                string s = Attributes["bgcolor"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["bgcolor"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.Border"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the width of the border, in pixels, of an 
        ///    <see cref='System.Web.UI.HtmlControls.HtmlTable'/> control.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(-1),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Border {
            get {
                string s = Attributes["border"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }

            set {
                Attributes["border"] = MapIntegerAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.BorderColor"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the border color of an <see cref='System.Web.UI.HtmlControls.HtmlTable'/> control.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string BorderColor {
            get {
                string s = Attributes["bordercolor"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["bordercolor"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.CellPadding"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the cell padding, in pixels, for an <see langword='HtmlTable'/> control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int CellPadding {
            get {
                string s = Attributes["cellpadding"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }
            set {
                Attributes["cellpadding"] = MapIntegerAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.CellSpacing"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the cell spacing, in pixels, for an <see langword='HtmlTable'/> control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int CellSpacing {
            get {
                string s = Attributes["cellspacing"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }
            set {
                Attributes["cellspacing"] = MapIntegerAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.InnerHtml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string InnerHtml {
            get {
                throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.InnerHtml_not_supported, this.GetType().Name));
            }
            set {
                throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.InnerHtml_not_supported, this.GetType().Name));
            }
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.InnerText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string InnerText {
            get {
                throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.InnerText_not_supported, this.GetType().Name));
            }
            set {
                throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.InnerText_not_supported, this.GetType().Name));
            }
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.Height"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the height of an <see langword='HtmlTable'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Height {
            get {
                string s = Attributes["height"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["height"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.Width"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the width of an <see langword='HtmlTable'/> control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Width {
            get {
                string s = Attributes["width"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["width"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.Rows"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection that contains all of the rows in an
        ///    <see langword='HtmlTable'/> control. An empty collection is returned if no 
        ///       &lt;tr&gt; elements are contained within the control.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        IgnoreUnknownContent()
        ]
        public virtual HtmlTableRowCollection Rows {
            get {
                if (rows == null)
                    rows = new HtmlTableRowCollection(this);

                return rows;
            }
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.RenderChildren"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderChildren(HtmlTextWriter writer) {
            writer.WriteLine();
            writer.Indent++;
            base.RenderChildren(writer);

            writer.Indent--;
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.RenderEndTag"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderEndTag(HtmlTextWriter writer) {
            base.RenderEndTag(writer);
            writer.WriteLine();
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.CreateControlCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override ControlCollection CreateControlCollection() {
            return new HtmlTableRowControlCollection(this);
        }

        /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.HtmlTableRowControlCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected class HtmlTableRowControlCollection : ControlCollection {

            internal HtmlTableRowControlCollection (Control owner) : base(owner) {
            }

            /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.HtmlTableRowControlCollection.Add"]/*' />
            /// <devdoc>
            /// <para>Adds the specified <see cref='System.Web.UI.Control'/> object to the collection. The new control is added
            ///    to the end of the array.</para>
            /// </devdoc>
            public override void Add(Control child) {
                if (child is HtmlTableRow)
                    base.Add(child);
                else
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "HtmlTable", child.GetType().Name.ToString())); // throw an exception here
            }

            /// <include file='doc\HtmlTable.uex' path='docs/doc[@for="HtmlTable.HtmlTableRowControlCollection.AddAt"]/*' />
            /// <devdoc>
            /// <para>Adds the specified <see cref='System.Web.UI.Control'/> object to the collection. The new control is added
            ///    to the array at the specified index location.</para>
            /// </devdoc>
            public override void AddAt(int index, Control child) {
                if (child is HtmlTableRow)
                    base.AddAt(index, child);
                else
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "HtmlTable", child.GetType().Name.ToString())); // throw an exception here
            }
        } // class HtmlTableRowControlCollection 

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmltablecellcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlTableCellCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HtmlTableCellCollection.cs
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web.UI.HtmlControls {
    using System.Runtime.InteropServices;

    using System;
    using System.Collections;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

/// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection"]/*' />
/// <devdoc>
///    <para>
///       The <see langword='HtmlTableCellCollection'/> contains all of the table
///       cells, both &lt;td&gt; and &lt;th&gt; elements, found within an <see langword='HtmlTable'/>
///       server control.
///    </para>
/// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HtmlTableCellCollection : ICollection {
        /// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection.owner"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        private HtmlTableRow owner;

        internal HtmlTableCellCollection(HtmlTableRow owner) {
            this.owner = owner;
        }

        /*
         * The number of cells in the row.
         */
        /// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of items in the <see langword='HtmlTableCell'/>
        ///       collection.
        ///    </para>
        /// </devdoc>
        public int Count {
            get {
                if (owner.HasControls())
                    return owner.Controls.Count;

                return 0;
            }
        }

        /// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an <see langword='HtmlTableCell'/> control from an
        ///    <see langword='HtmlTable'/> control thorugh the cell's ordinal index value. 
        ///    </para>
        /// </devdoc>
        public HtmlTableCell this[int index]
        {
            get {
                return(HtmlTableCell)owner.Controls[index];
            }
        }

        /// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the specified <see langword='HtmlTableCell'/> control to the end of the
        ///       collection.
        ///    </para>
        /// </devdoc>
        public void Add(HtmlTableCell cell) {
            Insert(-1, cell);
        }

        /// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an <see langword='HtmlTableCell'/> control to a specified location in the
        ///       collection.
        ///    </para>
        /// </devdoc>
        public void Insert(int index, HtmlTableCell cell) {
            owner.Controls.AddAt(index, cell);
        }

        /// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Deletes all <see langword='HtmlTableCell'/>
        ///       controls from the collection.
        ///    </para>
        /// </devdoc>
        public void Clear() {
            if (owner.HasControls())
                owner.Controls.Clear();
        }

        /*
         * Returns an enumerator that enumerates over the cells in a table row in order.
         */
        /// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection.GetEnumerator"]/*' />
        /// <devdoc>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return owner.Controls.GetEnumerator();
        }

        /// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection.CopyTo"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection.SyncRoot"]/*' />
        /// <devdoc>
        /// </devdoc>
        public Object SyncRoot {
            get { return this;}
        }

        /// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection.IsReadOnly"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsReadOnly {
            get { return false;}
        }

        /// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection.IsSynchronized"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsSynchronized {
            get { return false;}
        }

        /// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Deletes the specified <see langword='HtmlTableCell'/> control from the
        ///       collection.
        ///    </para>
        /// </devdoc>
        public void Remove(HtmlTableCell cell) {
            owner.Controls.Remove(cell);
        }

        /// <include file='doc\HtmlTableCellCollection.uex' path='docs/doc[@for="HtmlTableCellCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Deletes the <see langword='HtmlTableCell'/> control at the specified index
        ///       location from the collection.
        ///    </para>
        /// </devdoc>
        public void RemoveAt(int index) {
            owner.Controls.RemoveAt(index);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmlselect.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlSelect.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.HtmlControls {
    using System.Runtime.Serialization.Formatters;
    using System.Text;
    using System.ComponentModel;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Data;
    using System.Web;
    using System.Web.UI;
    using System.Web.UI.WebControls;
    using System.Globalization;
    using Debug=System.Web.Util.Debug;
    using System.Security.Permissions;


    internal class HtmlSelectBuilder : ControlBuilder {
        internal HtmlSelectBuilder() {
        }

        public override Type GetChildControlType(string tagName, IDictionary attribs) {
            if (string.Compare(tagName, "option", true, CultureInfo.InvariantCulture) == 0)
                return typeof(ListItem);

            return null;
        }

        public override bool AllowWhitespaceLiterals() {
            return false;
        }
    }

    /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The <see langword='HtmlSelect'/>
    ///       class defines the methods, properties, and events for the
    ///       HtmlSelect control. This class allows programmatic access to the HTML
    ///       &lt;select&gt; element on the server.
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("ServerChange"),
    ValidationProperty("Value"),
    ControlBuilderAttribute(typeof(HtmlSelectBuilder))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlSelect : HtmlContainerControl, IPostBackDataHandler, IParserAccessor {

        private static readonly object EventServerChange = new object();
        private static readonly char [] SPLIT_CHARS = new char[] { ','};
        private object dataSource;
        private ListItemCollection items;
        private int cachedSelectedIndex;

        /*
         * Creates an intrinsic Html SELECT control.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.HtmlSelect"]/*' />
        public HtmlSelect() : base("select") {
            cachedSelectedIndex = -1;
        }

        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.DataMember"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebCategory("Data"),
        WebSysDescription(SR.HtmlSelect_DataMember)
        ]
        public virtual string DataMember {
            get {
                object o = ViewState["DataMember"];
                if (o != null)
                    return (string)o;
                return String.Empty;
            }
            set {
                Attributes["DataMember"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.DataSource"]/*' />
        /// <devdoc>
        ///    Gets or sets the data source to databind the list values
        ///    in the <see langword='HtmlSelect'/> control against. This provides data to
        ///    populate the select list with items.
        /// </devdoc>
        [
        WebCategory("Data"),
        DefaultValue(null),
        WebSysDescription(SR.HtmlSelect_DataSource),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public virtual object DataSource {
            get {
                return dataSource;
            }
            set {
                if ((value == null) || (value is IListSource) || (value is IEnumerable)) {
                    dataSource = value;
                }
                else {
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Invalid_DataSource_Type, ID));
                }
            }
        }

        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.DataTextField"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the field in the data source that provides
        ///       the text for an option entry in the HtmlSelect control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Data"),
        DefaultValue(""),
        WebSysDescription(SR.HtmlSelect_DataTextField)
        ]
        public virtual string DataTextField {
            get {
                string s = Attributes["DataTextField"];
                return((s == null) ? String.Empty : s);
            }
            set {
                Attributes["DataTextField"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.DataValueField"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the field in the data source that provides
        ///       the option item value for the <see langword='HtmlSelect'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Data"),
        DefaultValue(""),
        WebSysDescription(SR.HtmlSelect_DataValueField)
        ]
        public virtual string DataValueField {
            get {
                string s = Attributes["DataValueField"];
                return((s == null) ? String.Empty : s);
            }
            set {
                Attributes["DataValueField"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.InnerHtml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string InnerHtml {
            get {
                throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.InnerHtml_not_supported, this.GetType().Name));
            }
            set {
                throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.InnerHtml_not_supported, this.GetType().Name));
            }
        }

        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.InnerText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string InnerText {
            get {
                throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.InnerText_not_supported, this.GetType().Name));
            }
            set {
                throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.InnerText_not_supported, this.GetType().Name));
            }
        }

        /*
         * A collection containing the list of items.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.Items"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the list of option items in an <see langword='HtmlSelect'/> control.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public ListItemCollection Items {
            get {
                if (items == null) {
                    items = new ListItemCollection();
                    if (IsTrackingViewState)
                        ((IStateManager)items).TrackViewState();
                }
                return items;
            }
        }

        /*
         * Multi-select property.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.Multiple"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether multiple option items can be selected
        ///       from the list.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public bool Multiple {
            get {
                string s = Attributes["multiple"];
                return((s != null) ? (s.Equals("multiple")) : false);
            }

            set {
                if (value)
                    Attributes["multiple"] = "multiple";
                else
                    Attributes["multiple"] = null;
            }
        }

        /*
         * Name property.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.Name"]/*' />
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Name {
            get { 
                return UniqueID;
                //string s = Attributes["name"];
                //return ((s != null) ? s : "");
            }
            set { 
                //Attributes["name"] = MapStringAttributeToString(value);
            }
        }

        // Value that gets rendered for the Name attribute
        internal string RenderedNameAttribute {
            get {
                return Name;
                //string name = Name;
                //if (name.Length == 0)
                //    return UniqueID;
                
                //return name;
            }
        }
        
        /*
         * The index of the selected item.
         * Returns the first selected item if list is multi-select.
         * Returns -1 if there is no selected item.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.SelectedIndex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the ordinal index of the selected option item in an
        ///    <see langword='HtmlSelect'/> control. If multiple items are selected, this 
        ///       property holds the index of the first item selected in the list.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        HtmlControlPersistable(false),
        ]
        public virtual int SelectedIndex {
            get {
                for (int i=0; i < Items.Count; i++) {
                    if (Items[i].Selected)
                        return i;
                }
                if (Size <= 1 && !Multiple) {
                    // SELECT as a dropdown must have a selection
                    if (Items.Count > 0)
                        Items[0].Selected = true;
                    return 0;
                }
                return -1;
            }
            set {
                // if we have no items, save the selectedindex
                // for later databinding
                if (Items.Count == 0) {
                    cachedSelectedIndex = value;
                }
                else {
                    if (value < -1 || value >= Items.Count) {
                        throw new ArgumentOutOfRangeException("value");
                    }
                    ClearSelection();
                    if (value >= 0)
                        Items[value].Selected = true;
                }
            }
        }

        /*
         *  SelectedIndices property.
         *  Protected property for getting array of selected indices.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.SelectedIndices"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual int[] SelectedIndices {
            get {
                int n = 0;
                int[] temp = new int[3];
                for (int i=0; i < Items.Count; i++) {
                    if (Items[i].Selected == true) {
                        if (n == temp.Length) {
                            int[] t = new int[n+n];
                            temp.CopyTo(t,0);
                            temp = t;
                        }
                        temp[n++] = i;
                    }
                }
                int[] selectedIndices = new int[n];
                Array.Copy(temp,0,selectedIndices,0,n);
                return selectedIndices;
            }
        }

        /*
         * The size of the list.
         * A size of 1 displays a dropdown list.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.Size"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of option items visible in the browser at a time. A
        ///       value greater that one will typically cause browsers to display a scrolling
        ///       list.
        ///    </para>
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Size {
            get {
                string s = Attributes["size"];
                return((s != null) ? Int32.Parse(s, CultureInfo.InvariantCulture) : -1);
            }

            set {
                Attributes["size"] = MapIntegerAttributeToString(value);
            }
        }

        /*
         * Value property.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the current item selected in the <see langword='HtmlSelect'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Value {
            get {
                int i = SelectedIndex;
                return(i < 0 || i >= Items.Count) ? String.Empty : Items[i].Value;
            }

            set {
                int i = Items.FindByValueInternal(value);
                if (i >= 0)
                    SelectedIndex = i;
            }
        }

        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.ServerChange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when an <see langword='HtmlSelect'/> control is changed on the
        ///       server.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.HtmlSelect_OnServerChange)
        ]
        public event EventHandler ServerChange {
            add {
                Events.AddHandler(EventServerChange, value);
            }
            remove {
                Events.RemoveHandler(EventServerChange, value);
            }
        }

        /*
         * TrackState 
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.TrackViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void TrackViewState() {
            base.TrackViewState();
            ((IStateManager)Items).TrackViewState();
        }

        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.AddParsedSubObject"]/*' />
        /// <internalonly/>
        protected override void AddParsedSubObject(object obj) {
            if (obj is ListItem)
                Items.Add((ListItem)obj);
            else
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "HtmlSelect", obj.GetType().Name));
        }

        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.ClearSelection"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual void ClearSelection() {
            for (int i=0; i < Items.Count; i++)
                Items[i].Selected = false;
        }

        /*
         * Override to load items and selected indices.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void LoadViewState(object savedState) {
            if (savedState != null) {
                Triplet statetriplet = (Triplet)savedState;
                base.LoadViewState(statetriplet.First);

                // restore state of items
                ((IStateManager)Items).LoadViewState(statetriplet.Second);

                // restore selected indices
                object selectedIndices = statetriplet.Third;
                if (selectedIndices != null)
                    Select((int[])selectedIndices);
            }
        }

        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.OnDataBinding"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void OnDataBinding(EventArgs e) {
            base.OnDataBinding(e);

            // create items using the datasource
            IEnumerable dataSource = DataSourceHelper.GetResolvedDataSource(this.DataSource, this.DataMember);

            // create items using the datasource
            if (dataSource != null) {
                bool fieldsSpecified = false;
                string textField = DataTextField;
                string valueField = DataValueField;

                Items.Clear();
                ICollection collection = dataSource as ICollection;
                if (collection != null) {
                    Items.Capacity = collection.Count;
                }

                if ((textField.Length != 0) || (valueField.Length != 0))
                    fieldsSpecified = true;

                foreach (object dataItem in dataSource) {
                    ListItem item = new ListItem();

                    if (fieldsSpecified) {
                        if (textField.Length > 0) {
                            item.Text = DataBinder.GetPropertyValue(dataItem,textField,null);
                        }
                        if (valueField.Length > 0) {
                            item.Value = DataBinder.GetPropertyValue(dataItem,valueField,null);
                        }
                    }
                    else {
                        item.Text = item.Value = dataItem.ToString();
                    }

                    Items.Add(item);
                }
            }
            // try to apply the cached SelectedIndex now
            if (cachedSelectedIndex != -1) {
                SelectedIndex = cachedSelectedIndex;
                cachedSelectedIndex = -1;
            }
        }

        /*
         * Save selected indices and modified Items.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.SaveViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override object SaveViewState() {
            
            object baseState = base.SaveViewState();
            object items = ((IStateManager)Items).SaveViewState();
            object selectedindices = null;

            // only save selection if handler is registered,
            // we are disabled, or we are not visible
            // since selection is always posted back otherwise
            if (Events[EventServerChange] != null || Disabled || !Visible)
                selectedindices = SelectedIndices;

            if (selectedindices  != null || items != null || baseState != null)
                return new Triplet(baseState, items, selectedindices);
            
            return null;
        }

        /*
         * This method is invoked just prior to rendering.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {
            // An Html SELECT does not post when nothing is selected.
            if (Page != null && Size > 1 && !Disabled)
                Page.RegisterRequiresPostBack(this);
        }

        /*
         * Override to prevent SelectedIndex from being rendered as an attribute.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.RenderAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderAttributes(HtmlTextWriter writer) {
            writer.WriteAttribute("name", RenderedNameAttribute);
            Attributes.Remove("name");

            Attributes.Remove("DataValueField");
            Attributes.Remove("DataTextField");
            Attributes.Remove("DataMember");
            base.RenderAttributes(writer);
        }

        /*
         * Render the Items in the list.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.RenderChildren"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderChildren(HtmlTextWriter writer) {
            bool selected = false;
            bool isSingle = !Multiple;
            
            writer.WriteLine();
            writer.Indent++;
            ListItemCollection liCollection = Items;
            int n = liCollection.Count;
            if (n > 0) {
                for (int i=0; i < n; i++) {
                    ListItem li = liCollection[i];
                    writer.WriteBeginTag("option");
                    if (li.Selected) {
                        if (isSingle)
                        {
                            if (selected)
                                throw new HttpException(HttpRuntime.FormatResourceString(SR.HtmlSelect_Cant_Multiselect_In_Single_Mode));
                            selected=true;
                        }
                        writer.WriteAttribute("selected", "selected");
                    }

                    writer.WriteAttribute("value", li.Value, true /*fEncode*/);

                    // This is to fix the case where the user puts one of these
                    // three values in the AttributeCollection.  Removing them 
                    // at least is better than rendering them twice. 
                    li.Attributes.Remove("text");
                    li.Attributes.Remove("value");
                    li.Attributes.Remove("selected");
                    
                    li.Attributes.Render(writer);
                    writer.Write(HtmlTextWriter.TagRightChar);
                    HttpUtility.HtmlEncode(li.Text, writer);
                    writer.WriteEndTag("option");
                    writer.WriteLine();
                }
            }
            writer.Indent--;
        }

        /*
         * Method used to raise the OnServerChange event.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.OnServerChange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raised
        ///       on the server when the <see langword='HtmlSelect'/> control list values
        ///       change between postback requests.
        ///    </para>
        /// </devdoc>
        protected virtual void OnServerChange(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventServerChange];
            if (handler != null) handler(this, e);
        }

        /*
         * Method of IPostBackDataHandler interface to process posted data.
         * SelectList processes a newly posted value.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IPostBackDataHandler.LoadPostData(string postDataKey, NameValueCollection postCollection) {
            string[] selectedItems = postCollection.GetValues(postDataKey);
            bool selectionChanged = false;

            if (selectedItems != null) {
                if (!Multiple) {
                    int n = Items.FindByValueInternal(selectedItems[0]);
                    if (SelectedIndex != n) {
                        SelectedIndex = n;
                        selectionChanged = true;
                    }
                }
                else { // multiple selection
                    int count = selectedItems.Length;
                    int[] oldSelectedIndices = SelectedIndices;
                    int[] newSelectedIndices = new int[count];
                    for (int i=0; i < count; i++) {
                        // create array of new indices from posted values
                        newSelectedIndices[i] = Items.FindByValueInternal(selectedItems[i]);
                    }

                    if (oldSelectedIndices.Length == count) {
                        // check new indices against old indices
                        // assumes selected values are posted in order
                        for (int i=0; i < count; i++) {
                            if (newSelectedIndices[i] != oldSelectedIndices[i]) {
                                selectionChanged = true;
                                break;
                            }
                        }
                    }
                    else {
                        // indices must have changed if count is different
                        selectionChanged = true;
                    }

                    if (selectionChanged) {
                        // select new indices
                        Select(newSelectedIndices);
                    }
                }
            }
            else { // no items selected
                if (SelectedIndex != -1) {
                    SelectedIndex = -1;
                    selectionChanged = true;
                }
            }
            return selectionChanged;

        }

        /*
         * Method of IPostBackDataHandler interface which is invoked whenever posted data
         * for a control has changed.  SelectList fires an OnServerChange event.
         */
        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            OnServerChange(EventArgs.Empty);
        }

        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.CreateControlCollection"]/*' />
        protected override ControlCollection CreateControlCollection() {
            return new EmptyControlCollection(this);
        }

        /// <include file='doc\HtmlSelect.uex' path='docs/doc[@for="HtmlSelect.Select"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual void Select(int[] selectedIndices) {
            ClearSelection();
            for (int i=0; i < selectedIndices.Length; i++) {
                int n = selectedIndices[i];
                if (n >= 0 && n < Items.Count)
                    Items[n].Selected = true;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\htmlcontrols\htmltablerow.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlTableRow.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.HtmlControls {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The <see langword='HtmlTableRow'/>
    ///       class defines the properties, methods, and events for the HtmlTableRow control.
    ///       This class allows programmatic access on the server to individual HTML
    ///       &lt;tr&gt; elements enclosed within an <see cref='System.Web.UI.HtmlControls.HtmlTable'/> control.
    ///    </para>
    /// </devdoc>
    [
    ParseChildren(true, "Cells")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlTableRow : HtmlContainerControl {
        HtmlTableCellCollection cells;

        /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.HtmlTableRow"]/*' />
        public HtmlTableRow() : base("tr") {
        }


        /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.Align"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the horizontal alignment of the cells contained in an
        ///    <see langword='HtmlTableRow'/> control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Align {
            get {
                string s = Attributes["align"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["align"] = MapStringAttributeToString(value);
            }
        }

        /*
         * Collection of child TableCells.
         */
        /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.Cells"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the group of table cells contained within an
        ///    <see langword='HtmlTableRow'/> control.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public virtual HtmlTableCellCollection Cells {
            get {
                if (cells == null)
                    cells = new HtmlTableCellCollection(this);

                return cells;
            }
        }

        /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.BgColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the background color of an <see langword='HtmlTableRow'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string BgColor {
            get {
                string s = Attributes["bgcolor"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["bgcolor"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.BorderColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the border color of an <see langword='HtmlTableRow'/> control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string BorderColor {
            get {
                string s = Attributes["bordercolor"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["bordercolor"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.Height"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the height of an <see langword='HtmlTableRow'/> control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Height {
            get {
                string s = Attributes["height"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["height"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.InnerHtml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string InnerHtml {
            get {
                throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.InnerHtml_not_supported, this.GetType().Name));
            }
            set {
                throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.InnerHtml_not_supported, this.GetType().Name));
            }
        }

        /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.InnerText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string InnerText {
            get {
                throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.InnerText_not_supported, this.GetType().Name));
            }
            set {
                throw new NotSupportedException(HttpRuntime.FormatResourceString(SR.InnerText_not_supported, this.GetType().Name));
            }
        }

        /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.VAlign"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the vertical alignment of of the cells contained in an
        ///    <see langword='HtmlTableRow'/> control.
        ///    </para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(""),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string VAlign {
            get {
                string s = Attributes["valign"];
                return((s != null) ? s : "");
            }

            set {
                Attributes["valign"] = MapStringAttributeToString(value);
            }
        }

        /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.RenderChildren"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderChildren(HtmlTextWriter writer) {
            writer.WriteLine();
            writer.Indent++;
            base.RenderChildren(writer);

            writer.Indent--;
        }

        /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.RenderEndTag"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderEndTag(HtmlTextWriter writer) {
            base.RenderEndTag(writer);
            writer.WriteLine();
        }

        /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.CreateControlCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override ControlCollection CreateControlCollection() {
            return new HtmlTableCellControlCollection(this);
        }

        /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.HtmlTableCellControlCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected class HtmlTableCellControlCollection : ControlCollection {

            internal HtmlTableCellControlCollection (Control owner) : base(owner) {
            }

            /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.HtmlTableCellControlCollection.Add"]/*' />
            /// <devdoc>
            /// <para>Adds the specified <see cref='System.Web.UI.Control'/> object to the collection. The new control is added
            ///    to the end of the array.</para>
            /// </devdoc>
            public override void Add(Control child) {
                if (child is HtmlTableCell)
                    base.Add(child);
                else
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "HtmlTableRow", child.GetType().Name.ToString())); // throw an exception here
            }
            
            /// <include file='doc\HtmlTableRow.uex' path='docs/doc[@for="HtmlTableRow.HtmlTableCellControlCollection.AddAt"]/*' />
            /// <devdoc>
            /// <para>Adds the specified <see cref='System.Web.UI.Control'/> object to the collection. The new control is added
            ///    to the array at the specified index location.</para>
            /// </devdoc>
            public override void AddAt(int index, Control child) {
                if (child is HtmlTableCell)
                    base.AddAt(index, child);
                else
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Cannot_Have_Children_Of_Type, "HtmlTableRow", child.GetType().Name.ToString())); // throw an exception here
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\adcreatedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdCreatedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    /// <include file='doc\AdCreatedEventHandler.uex' path='docs/doc[@for="AdCreatedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle the 
    ///    <see langword='AdCreated '/> event of an <see cref='System.Web.UI.WebControls.AdRotator'/>.</para>
    /// </devdoc>
    public delegate void AdCreatedEventHandler(object sender, AdCreatedEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\adrotator.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdRotator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {
    using System.IO;
    using System.Diagnostics;
    using System.Web.UI.WebControls;
    using System.Web.UI;
    using System.Web.Caching;
    using System.Web;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing.Design;
    using System.Xml;
    using System.Globalization;
    using System.Web.Util;
    using System.Security.Permissions;

    /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator"]/*' />
    /// <devdoc>
    ///    <para>Displays a randomly selected ad banner on a page.</para>
    /// </devdoc>
    [
    DefaultEvent("AdCreated"),
    DefaultProperty("AdvertisementFile"),
    Designer("System.Web.UI.Design.WebControls.AdRotatorDesigner, " + AssemblyRef.SystemDesign),
    ToolboxData("<{0}:AdRotator runat=\"server\" Height=\"60px\" Width=\"468px\"></{0}:AdRotator>")
    ]    
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class AdRotator : WebControl {

        private static readonly object EventAdCreated = new object();

        private const string XmlDocumentTag = "Advertisements";
        private const string XmlAdTag = "Ad";

        private const string KeywordProperty = "Keyword";
        private const string ImpressionsProperty = "Impressions";

        private const string ApplicationCachePrefix = "AdRotatorCache: ";

        private string imageUrl;
        private string navigateUrl;
        private string alternateText;
        private string advertisementFile;
        private string fileDirectory;

        // static copy of the Random object. This is a pretty hefty object to initialize, so you don't
        // want to create one each time.
        private static Random random;


        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.AdRotator"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.AdRotator'/> class.</para>
        /// </devdoc>
        public AdRotator() {
        }

        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.AdvertisementFile"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the path to the XML file that contains advertisement data.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(""),
        Editor("System.Web.UI.Design.XmlUrlEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        WebSysDescription(SR.AdRotator_AdvertisementFile)
        ]
        public string AdvertisementFile {
            get {
                return((advertisementFile == null) ? String.Empty : advertisementFile);
            }
            set {
                advertisementFile = value;
            }
        }

        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.Font"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Font property. Has no effect on this control, so hide it.
        /// </devdoc>
        [
        Browsable(false),
        EditorBrowsableAttribute(EditorBrowsableState.Never),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public override FontInfo Font {
            get {
                return base.Font;
            }
        }


        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.KeywordFilter"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a category keyword used for matching related advertisements in the advertisement file.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.AdRotator_KeywordFilter)
        ]
        public string KeywordFilter {
            get {
                string s = (string)ViewState["KeywordFilter"];
                return((s == null) ? String.Empty : s);
            }
            set {
                // trim the filter value
                if (value == null || value.Length == 0) {
                    ViewState.Remove("KeywordFilter");
                }
                else {
                    ViewState["KeywordFilter"] = value.Trim();
                }
            }
        }

        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.Target"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or sets the name of the browser window or frame to display the advertisement.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue("_top"),
        WebSysDescription(SR.AdRotator_Target),
        TypeConverter(typeof(TargetConverter))
        ]
        public string Target {
            get {
                string s = (string)ViewState["Target"];
                return((s == null) ? "_top" : s);
            }
            set {
                ViewState["Target"] = value;
            }
        }


        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.AdCreated"]/*' />
        /// <devdoc>
        ///    <para>Occurs once per round trip after the creation of the 
        ///       control before the page is rendered. </para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.AdRotator_OnAdCreated)
        ]
        public event AdCreatedEventHandler AdCreated {
            add {
                Events.AddHandler(EventAdCreated, value);
            }
            remove {
                Events.RemoveHandler(EventAdCreated, value);
            }
        }

        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.CreateControlCollection"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override ControlCollection CreateControlCollection() {
            return new EmptyControlCollection(this);
        }

        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.GetFileData"]/*' />
        /// <devdoc>
        ///   Gets the ad data for the given file by loading the file, or reading from the 
        ///   application-level cache.
        /// </devdoc>
        private AdRec [] GetFileData(string fileName) {

            // Get the physical path along with security checks
            string physicalPath = MapPathSecure(fileName);

            // Remember the directory corresponding for mapping of Urls later.
            string absoluteFile = UrlPath.Combine(TemplateSourceDirectory, fileName);
            fileDirectory = UrlPath.GetDirectory(absoluteFile);


            AdRec [] adRecs = null;

            // try to get it from the ASP.NET cache
            string fileKey = ApplicationCachePrefix + physicalPath;
            CacheInternal cacheInternal = System.Web.HttpRuntime.CacheInternal;
            adRecs = cacheInternal[fileKey] as AdRec[];

            if (adRecs == null) {
                // Otherwise load it
                adRecs = LoadFile(physicalPath);
                if (adRecs == null) {
                    return null;
                }

                using (CacheDependency dependency = new CacheDependency(false, physicalPath)) {
                    // and store it in the cache, dependent on the file name
                    cacheInternal.UtcInsert(fileKey, adRecs, dependency);
                }
            }
            return adRecs;
        }

        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.LoadFile"]/*' />
        /// <devdoc>
        ///   Loads the give XML file into an array of AdRec structures 
        /// </devdoc>
        private AdRec [] LoadFile(string fileName) {

            Stream stream = null;
            AdRec [] adRecs = null;

            try {
                stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
            }
            catch (Exception e) {
                // We want to catch the error message, but not propage the inner exception. Otherwise we can throw up
                // logon prompts through IE;
                throw new HttpException(HttpRuntime.FormatResourceString(SR.AdRotator_cant_open_file, ID, e.Message));
            }

            try {

                // Read the XML file into an array of dictionaries
                ArrayList adDicts = new ArrayList();
                XmlReader reader = new XmlTextReader(stream);
                XmlDocument doc = new XmlDocument();

                doc.Load( reader );

                if ( doc.DocumentElement != null && doc.DocumentElement.LocalName == XmlDocumentTag ) {
                    XmlNode elem = doc.DocumentElement.FirstChild;
                    while (elem != null) {
                        IDictionary dict = null;
                        if (elem.LocalName.Equals(XmlAdTag)) {
                            XmlNode prop = elem.FirstChild;
                            while (prop != null) {
                                if (prop.NodeType == XmlNodeType.Element) {
                                    if (dict == null) {
                                        dict = new HybridDictionary();
                                    }
                                    dict.Add(prop.LocalName, prop.InnerText);
                                }
                                prop = prop.NextSibling;
                            }
                        }
                        if (dict != null) {
                            adDicts.Add(dict);
                        }
                        elem = elem.NextSibling;
                    }
                }

                if (adDicts.Count != 0) {

                    // Create an array of AdRec structures from the dictionaries, removing blanks
                    adRecs = new AdRec[adDicts.Count];
                    int iRec = 0;
                    for (int i = 0; i < adDicts.Count; i++) {
                        if (adDicts[i] != null) {
                            adRecs[iRec].Initialize((IDictionary) adDicts[i]);
                            iRec++;
                        }
                    }
                    Diagnostics.Debug.Assert(iRec == adDicts.Count, "Record count did not match non-null entries");
                }

            }
            catch (Exception e) {
                throw new HttpException(
                                       HttpRuntime.FormatResourceString(SR.AdRotator_parse_error, ID, e.Message), e);
            }
            finally {
                if (stream != null) {
                    stream.Close();
                }
            }

            if (adRecs == null) {
                throw new HttpException(
                                       HttpRuntime.FormatResourceString(SR.AdRotator_no_advertisements, ID, AdvertisementFile));
            }

            return adRecs;
        }

        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.MatchingAd"]/*' />
        /// <devdoc>
        ///   Used to determine if the advertisement meets current criteria. Does a comparison with
        ///   KeywordFilter if it is set.
        /// </devdoc>
        private bool MatchingAd(AdRec ad) {
            // do a lower case comparison
            return(KeywordFilter == string.Empty 
                   || (KeywordFilter.ToLower(CultureInfo.InvariantCulture) == ad.keyword.ToLower(CultureInfo.InvariantCulture)));
        }

        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.OnAdCreated"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Web.UI.WebControls.AdRotator.AdCreated'/> event for an <see cref='System.Web.UI.WebControls.AdRotator'/>.</para>
        /// </devdoc>
        protected virtual void OnAdCreated(AdCreatedEventArgs e) {
            AdCreatedEventHandler handler = (AdCreatedEventHandler)Events[EventAdCreated];
            if (handler != null) handler(this, e);
        }

        private string ResolveAdRotatorUrl(string relativeUrl) {

            Diagnostics.Debug.Assert(relativeUrl != null);

            // check if its empty or already absolute
            if ((relativeUrl.Length == 0) || (UrlPath.IsRelativeUrl(relativeUrl) == false)) {
                return relativeUrl;
            }

            // For the AdRotator, use the AdvertisementFile directory as the base, and fall back to the
            // page/user control location as the base.
            string baseUrl = string.Empty;
            if (fileDirectory != null) {
                baseUrl = fileDirectory;
            }
            if (baseUrl.Length == 0) {
                baseUrl = TemplateSourceDirectory;
            }
            if (baseUrl.Length == 0) {
                return relativeUrl;
            }

            // make it absolute
            return UrlPath.Combine(baseUrl, relativeUrl);
        }

        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.Render"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Displays the <see cref='System.Web.UI.WebControls.AdRotator'/> on the client.</para>
        /// </devdoc>
        protected override void Render(HtmlTextWriter writer) {
            HyperLink bannerLink = new HyperLink();

            foreach(string key in Attributes.Keys) {
                bannerLink.Attributes[key] = Attributes[key];
            }

            if (this.ID != null && this.ID.Length > 0) {
                bannerLink.ID = this.ClientID;
            }
            if (this.navigateUrl != null && this.navigateUrl.Length > 0) {
                bannerLink.NavigateUrl = ResolveAdRotatorUrl(this.navigateUrl);
            }
            bannerLink.Target = this.Target;
            bannerLink.AccessKey = this.AccessKey;
            bannerLink.Enabled = this.Enabled;
            bannerLink.TabIndex = this.TabIndex;
            bannerLink.RenderBeginTag(writer);

            // create inner Image
            Image bannerImage = new Image();
            // apply styles to image
            if (ControlStyleCreated) {
                bannerImage.ApplyStyle(this.ControlStyle);
            }
            bannerImage.AlternateText = this.alternateText;
            if (imageUrl != null && imageUrl.Length > 0) {
                bannerImage.ImageUrl = ResolveAdRotatorUrl(this.imageUrl);
            }
            bannerImage.ToolTip = this.ToolTip;
            bannerImage.RenderControl(writer);
            bannerLink.RenderEndTag(writer);;
        }

        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets the advertisement information for rendering by looking up the file data and/or calling the
        ///       user event.</para>
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {

            IDictionary dict = null;

            // If there is a file, get an ad from it
            if (AdvertisementFile != String.Empty ) {
                dict = SelectAdFromFile();
            }

            // fire the user event either way;
            AdCreatedEventArgs adCreatedEvent = new AdCreatedEventArgs(dict);
            OnAdCreated(adCreatedEvent);

            // Remember for values for rendering
            imageUrl = adCreatedEvent.ImageUrl;
            navigateUrl = adCreatedEvent.NavigateUrl;
            alternateText = adCreatedEvent.AlternateText;

        }

        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.SelectAdFromFile"]/*' />
        /// <devdoc>
        ///   Selects an avertisement from the advertisement file. Gets the list of ads in
        ///   memory and chooses an ad from it  
        /// </devdoc>
        private IDictionary SelectAdFromFile() {
            Diagnostics.Debug.Assert(AdvertisementFile != String.Empty, "No advertisement file");

            // get the adds from the file or app cache
            AdRec [] adRecs = GetFileData(AdvertisementFile);

            if (adRecs == null || adRecs.Length == 0) {
                return null;
            }

            // sum the matching impressions
            int totalImpressions = 0;
            for (int i = 0; i < adRecs.Length; i++) {
                if (MatchingAd(adRecs[i])) {
                    totalImpressions += adRecs[i].impressions;
                }
            }

            if (totalImpressions == 0) {
                return null;
            }

            // select one using a random number between 1 and totalImpressions
            if (random == null) {
                random = new Random();
            }
            int selectedImpression = random.Next(totalImpressions) + 1;
            int impressionCounter = 0;
            int selectedIndex = -1;
            for (int i = 0; i < adRecs.Length; i++) {
                // Is this the ad?
                if (MatchingAd(adRecs[i])) {
                    if (selectedImpression <= impressionCounter + adRecs[i].impressions) {
                        selectedIndex = i;
                        break;
                    }
                    impressionCounter += adRecs[i].impressions;
                }
            }
            Diagnostics.Debug.Assert(selectedIndex >= 0 && selectedIndex < adRecs.Length, "Index not found");

            return adRecs[selectedIndex].adProperties;
        }


        /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.AdRec"]/*' />
        /// <devdoc>
        ///   Structure to store ads in memory for fast selection by multiple instances of adrotator
        ///   Stores the dictionary and caches some values for easier selection.
        /// </devdoc>
        private struct AdRec { 
            public string keyword;
            public int impressions;
            public IDictionary adProperties;

            /// <include file='doc\AdRotator.uex' path='docs/doc[@for="AdRotator.AdRec.Initialize"]/*' />
            /// <devdoc>
            ///   Initialize the stuct based on a dictionary containing the advertisement properties
            /// </devdoc>
            public void Initialize(IDictionary adProperties) {

                // Initialize the values we need to keep for ad selection
                Diagnostics.Debug.Assert(adProperties != null, "Required here");
                this.adProperties = adProperties;

                // remove null and trim keyword for easier comparisons.
                this.keyword = (string) adProperties[KeywordProperty];
                keyword = (keyword == null) ? string.Empty : keyword.Trim();

                // get the impressions, but be defensive: let the schema enforce the rules. Default to 1.
                try {
                    impressions = int.Parse((string) adProperties[ImpressionsProperty], CultureInfo.InvariantCulture);
                }
                catch (Exception) {
                    impressions = 1;
                }
                if (impressions < 0) {
                    impressions = 1;
                }
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\assemblyattributes.cs ===
//------------------------------------------------------------------------------
// <copyright file="AssemblyAttributes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Web.UI;

[assembly:TagPrefix("System.Web.UI.WebControls", "asp")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\basecomparevalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="basecomparevalidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Globalization;
    using System.Web;
    using System.Web.UI.HtmlControls;
    using System.Text.RegularExpressions;
    using System.Text;
    using System.Security.Permissions;

    /// <include file='doc\basecomparevalidator.uex' path='docs/doc[@for="BaseCompareValidator"]/*' />
    /// <devdoc>
    ///    <para> Serves as the abstract base
    ///       class for validators that do typed comparisons.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public abstract class BaseCompareValidator : BaseValidator {

        /// <include file='doc\basecomparevalidator.uex' path='docs/doc[@for="BaseCompareValidator.Type"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the data type that specifies how the values
        ///       being compared should be interpreted.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(ValidationDataType.String),
        WebSysDescription(SR.RangeValidator_Type)
        ]                                         
        public ValidationDataType Type {
            get { 
                object o = ViewState["Type"];
                return((o == null) ? ValidationDataType.String : (ValidationDataType)o);
            }
            set {
                if (value < ValidationDataType.String || value > ValidationDataType.Currency) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["Type"] = value;
            }
        }

        /// <include file='doc\basecomparevalidator.uex' path='docs/doc[@for="BaseCompareValidator.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    AddAttributesToRender method
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {
            base.AddAttributesToRender(writer);
            if (RenderUplevel) {
                ValidationDataType type = Type;
                if (type != ValidationDataType.String) {
                    writer.AddAttribute("type", PropertyConverter.EnumToString(typeof(ValidationDataType), type));

                    NumberFormatInfo info = NumberFormatInfo.CurrentInfo;
                    if (type == ValidationDataType.Double) {    
                        string decimalChar = NumberFormatInfo.CurrentInfo.NumberDecimalSeparator;
                        writer.AddAttribute("decimalchar", decimalChar);
                    }
                    else if (type == ValidationDataType.Currency) {
                        string decimalChar = info.CurrencyDecimalSeparator;
                        writer.AddAttribute("decimalchar", decimalChar);
                        string groupChar = info.CurrencyGroupSeparator;
                        // Map non-break space onto regular space for parsing
                        if (groupChar[0] == 160)
                            groupChar = " ";
                        writer.AddAttribute("groupchar", groupChar);
                        int digits = info.CurrencyDecimalDigits;
                        writer.AddAttribute("digits", digits.ToString(NumberFormatInfo.InvariantInfo));
                    }
                    else if (type == ValidationDataType.Date) {
                        writer.AddAttribute("dateorder", GetDateElementOrder());
                        writer.AddAttribute("cutoffyear", CutoffYear.ToString());
                        int currentYear = DateTime.Today.Year;
                        int century = currentYear - (currentYear % 100);
                        writer.AddAttribute("century", century.ToString());
                    }
                }
            }
        }        


        /// <include file='doc\basecomparevalidator.uex' path='docs/doc[@for="BaseCompareValidator.CanConvert"]/*' />
        /// <devdoc>
        ///    Check if the text can be converted to the type
        /// </devdoc>
        public static bool CanConvert(string text, ValidationDataType type) {
            object value = null;
            return Convert(text, type, out value);
        }

        /// <include file='doc\basecomparevalidator.uex' path='docs/doc[@for="BaseCompareValidator.GetDateElementOrder"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Return the order of date elements for the current culture
        /// </devdoc>
        protected static string GetDateElementOrder() {
            DateTimeFormatInfo info = DateTimeFormatInfo.CurrentInfo;
            string shortPattern = info.ShortDatePattern;
            if (shortPattern.IndexOf('y') < shortPattern.IndexOf('M')) {
                return "ymd";
            }
            else if (shortPattern.IndexOf('M') < shortPattern.IndexOf('d')) {
                return "mdy";
            }
            else {
                return "dmy";
            }
        }

        /// <include file='doc\basecomparevalidator.uex' path='docs/doc[@for="BaseCompareValidator.CutoffYear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected static int CutoffYear {
            get {
                return DateTimeFormatInfo.CurrentInfo.Calendar.TwoDigitYearMax;
            }
        }

        /// <include file='doc\basecomparevalidator.uex' path='docs/doc[@for="BaseCompareValidator.GetFullYear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected static int GetFullYear(int shortYear) {
            Debug.Assert(shortYear >= 0 && shortYear < 100);
            int currentYear = DateTime.Today.Year;
            int century = currentYear - (currentYear % 100);
            if (shortYear < CutoffYear) {
                return shortYear + century;
            }
            else {
                return shortYear + century - 100;
            }
        }

        /// <include file='doc\basecomparevalidator.uex' path='docs/doc[@for="BaseCompareValidator.Convert"]/*' />
        /// <devdoc>
        ///    Try to convert the test into the validation data type
        /// </devdoc>
        protected static bool Convert(string text, ValidationDataType type, out object value) {

            value = null;
            try {
                switch (type) {
                    case ValidationDataType.String:
                        value = text;
                        break;

                    case ValidationDataType.Integer:
                        value = Int32.Parse(text, CultureInfo.InvariantCulture);
                        break;

                    case ValidationDataType.Double: {
                        string decimalChar = NumberFormatInfo.CurrentInfo.NumberDecimalSeparator;
                        string doubleExpression = "^\\s*([-\\+])?(\\d+)?(\\" + decimalChar + "(\\d+))?\\s*$";
                        Match m = Regex.Match(text, doubleExpression);
                        if (!m.Success)
                            break;
                        string cleanInput = m.Groups[1].Value
                                            + (m.Groups[2].Success ? m.Groups[2].Value : "0")
                                            + ((m.Groups[4].Success) ? "." + m.Groups[4].Value: string.Empty);
                        value = Double.Parse(cleanInput, CultureInfo.InvariantCulture);
                        break;
                    }

                    case ValidationDataType.Date: {
                        // if the calendar is not gregorian, we should not enable client-side, so just parse it directly:
                        if (!(DateTimeFormatInfo.CurrentInfo.Calendar.GetType() == typeof(GregorianCalendar))) {
                            value = DateTime.Parse(text);
                            break;
                        }
                        // always allow the YMD format, if they specify 4 digits
                        string elementOrder = GetDateElementOrder();
                        string dateYearFirstExpression = "^\\s*((\\d{4})|(\\d{2}))([-./])(\\d{1,2})\\4(\\d{1,2})\\s*$";
                        Match m = Regex.Match(text, dateYearFirstExpression);
                        int day, month, year;
                        if (m.Success && (m.Groups[2].Success || elementOrder == "ymd")) {
                            day = Int32.Parse(m.Groups[6].Value, CultureInfo.InvariantCulture);
                            month = Int32.Parse(m.Groups[5].Value, CultureInfo.InvariantCulture);
                            if (m.Groups[2].Success) {
                                year = Int32.Parse(m.Groups[2].Value, CultureInfo.InvariantCulture);
                            }
                            else {
                                year = GetFullYear(Int32.Parse(m.Groups[3].Value, CultureInfo.InvariantCulture));
                            }
                        }
                        else {
                            if (elementOrder == "ymd") {
                                break;								
                            }
                            
                            // also check for the year last format
                            string dateYearLastExpression = "^\\s*(\\d{1,2})([-./])(\\d{1,2})\\2((\\d{4})|(\\d{2}))\\s*$";
                            m = Regex.Match(text, dateYearLastExpression);
                            if (!m.Success) {
                                break;
                            }
                            if (elementOrder == "mdy") {
                                day = Int32.Parse(m.Groups[3].Value, CultureInfo.InvariantCulture);
                                month = Int32.Parse(m.Groups[1].Value, CultureInfo.InvariantCulture);
                            }
                            else {
                                day = Int32.Parse(m.Groups[1].Value, CultureInfo.InvariantCulture);
                                month = Int32.Parse(m.Groups[3].Value, CultureInfo.InvariantCulture);
                            }
                            if (m.Groups[5].Success) {
                                year = Int32.Parse(m.Groups[5].Value, CultureInfo.InvariantCulture);
                            } else {
                                year = GetFullYear(Int32.Parse(m.Groups[6].Value, CultureInfo.InvariantCulture));
                            }
                        }
                        DateTime date = new DateTime(year, month, day);
                        if (date != DateTime.MinValue) 
                            value = date;
                        break;
                    }

                    case ValidationDataType.Currency: {
                        NumberFormatInfo info = NumberFormatInfo.CurrentInfo;
                        string decimalChar = info.CurrencyDecimalSeparator;
                        string groupChar = info.CurrencyGroupSeparator;
                        // Map non-break space onto regular space for parsing
                        if (groupChar[0] == 160)
                            groupChar = " ";
                        int digits = info.CurrencyDecimalDigits;
                        string currencyExpression = 
                            "^\\s*([-\\+])?(((\\d+)\\" + groupChar + ")*)(\\d+)"
                            + ((digits > 0) ? "(\\" + decimalChar + "(\\d{1," + digits.ToString(NumberFormatInfo.InvariantInfo) + "}))" : string.Empty)
                             + "?\\s*$";
                        Match m = Regex.Match(text, currencyExpression);
                        if (!m.Success)
                            break;
                        StringBuilder sb = new StringBuilder();
                        sb.Append(m.Groups[1]);
                        foreach (Capture cap in m.Groups[4].Captures) {
                            sb.Append(cap);
                        }
                        sb.Append(m.Groups[5]);
                        if (digits > 0) {
                            sb.Append(".");
                            sb.Append(m.Groups[7]);
                        }
                        value = Decimal.Parse(sb.ToString(), CultureInfo.InvariantCulture);
                        break;
                    }
                }
            } 
            catch {                
                value = null;
            }
            return (value != null);
        }


        /// <include file='doc\basecomparevalidator.uex' path='docs/doc[@for="BaseCompareValidator.Compare"]/*' />
        /// <devdoc>
        ///    Compare two strings using the type and operator
        /// </devdoc>
        protected static bool Compare(string leftText, string rightText, ValidationCompareOperator op, ValidationDataType type) {

            object leftObject;
            if (!Convert(leftText, type, out leftObject))
                return false;    

            if (op == ValidationCompareOperator.DataTypeCheck)
                return true;

            object rightObject;
            if (!Convert(rightText, type, out rightObject))
                return true;

            int compareResult;
            switch (type) {
                case ValidationDataType.String:
                    compareResult = String.Compare((string)leftObject, (string) rightObject, false, CultureInfo.CurrentCulture);
                    break;

                case ValidationDataType.Integer:
                    compareResult = ((int)leftObject).CompareTo(rightObject);
                    break;

                case ValidationDataType.Double:
                    compareResult = ((double)leftObject).CompareTo(rightObject);
                    break;

                case ValidationDataType.Date:
                    compareResult = ((DateTime)leftObject).CompareTo(rightObject);
                    break;

                case ValidationDataType.Currency:
                    compareResult = ((Decimal)leftObject).CompareTo(rightObject);
                    break;

                default: 
                    Debug.Fail("Unknown Type");
                    return true;
            }            

            switch (op) {
                case ValidationCompareOperator.Equal:
                    return compareResult == 0;
                case ValidationCompareOperator.NotEqual:
                    return compareResult != 0;
                case ValidationCompareOperator.GreaterThan:
                    return compareResult > 0 ;
                case ValidationCompareOperator.GreaterThanEqual:
                    return compareResult >= 0 ;
                case ValidationCompareOperator.LessThan:
                    return compareResult < 0 ;
                case ValidationCompareOperator.LessThanEqual:
                    return compareResult <= 0 ;
                default:
                    Debug.Fail("Unknown Operator");
                    return true;                      
            }                
        }                


        /// <include file='doc\basecomparevalidator.uex' path='docs/doc[@for="BaseCompareValidator.DetermineRenderUplevel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override bool DetermineRenderUplevel() {
            // We don't do client-side validation for dates with non gregorian calendars
            if (Type == ValidationDataType.Date && DateTimeFormatInfo.CurrentInfo.Calendar.GetType() != typeof(GregorianCalendar)) {
                return false;
            }
            return base.DetermineRenderUplevel();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\adcreatedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdCreatedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System.Collections;
    using System.Collections.Specialized;
    using System.Security.Permissions;

    /// <include file='doc\AdCreatedEventArgs.uex' path='docs/doc[@for="AdCreatedEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see langword='AdCreated'/> event.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class AdCreatedEventArgs : EventArgs {

        private const string ImageUrlProperty = "ImageUrl";
        private const string NavigateUrlProperty = "NavigateUrl";
        private const string AlternateTextProperty = "AlternateText";

        private string imageUrl;
        private string navigateUrl;
        private string alternateText;
        private IDictionary adProperties;

        /// <include file='doc\AdCreatedEventArgs.uex' path='docs/doc[@for="AdCreatedEventArgs.AdCreatedEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.AdCreatedEventArgs'/> 
        /// class.</para>
        /// </devdoc>
        public AdCreatedEventArgs(IDictionary adProperties) {

            imageUrl = String.Empty;   
            navigateUrl = String.Empty;
            alternateText = String.Empty;

            if (adProperties != null) {
                // Initialize the other properties from the dictionary
                this.adProperties = adProperties;
                this.imageUrl = (string) adProperties[ImageUrlProperty];
                this.navigateUrl = (string) adProperties[NavigateUrlProperty];
                this.alternateText = (string) adProperties [AlternateTextProperty];
            }
            else {
                // creat an empty dictionary so the value is not null
                adProperties = new HybridDictionary();
            }
        }

        /// <include file='doc\AdCreatedEventArgs.uex' path='docs/doc[@for="AdCreatedEventArgs.AdProperties"]/*' />
        /// <devdoc>
        ///    <para>Gets the dictionary containing all the advertisement 
        ///       properties extracted from the XML file after the <see langword='AdCreated '/>
        ///       event is raised.</para>
        /// </devdoc>
        public IDictionary AdProperties {
            get {
                return adProperties;
            }
        }

        /// <include file='doc\AdCreatedEventArgs.uex' path='docs/doc[@for="AdCreatedEventArgs.AlternateText"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Specifies the alternate text and tooltip (if browser supported) that will be
        ///       rendered in the <see cref='System.Web.UI.WebControls.AdRotator'/>.</para>
        /// </devdoc>
        public string AlternateText {
            get { 
                return alternateText;
            }
            set {
                alternateText = value;
            }
        }

        /// <include file='doc\AdCreatedEventArgs.uex' path='docs/doc[@for="AdCreatedEventArgs.ImageUrl"]/*' />
        /// <devdoc>
        /// <para> Specifies the image that will be rendered in the <see cref='System.Web.UI.WebControls.AdRotator'/>.</para>
        /// </devdoc>
        public string ImageUrl {
            get {
                return imageUrl;
            }
            set {
                imageUrl = value;
            }
        }

        /// <include file='doc\AdCreatedEventArgs.uex' path='docs/doc[@for="AdCreatedEventArgs.NavigateUrl"]/*' />
        /// <devdoc>
        ///    <para> Specifies the target URL that will be rendered in the
        ///    <see cref='System.Web.UI.WebControls.AdRotator'/>.</para>
        /// </devdoc>
        public string NavigateUrl {
            get {
                return navigateUrl;
            }
            set {
                navigateUrl = value;
            }
        }
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\borderstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="BorderStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {
    
    using System;

    /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the basic border style of a control.
    ///    </para>
    /// </devdoc>
    public enum BorderStyle {

        /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle.NotSet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No border style set.
        ///    </para>
        /// </devdoc>
        NotSet = 0,
        
        /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No border on the control.
        ///    </para>
        /// </devdoc>
        None = 1,

        /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle.Dotted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A dotted line border.
        ///    </para>
        /// </devdoc>
        Dotted = 2,

        /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle.Dashed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A dashed line border.
        ///    </para>
        /// </devdoc>
        Dashed = 3,

        /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle.Solid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A solid line border.
        ///    </para>
        /// </devdoc>
        Solid = 4,

        /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle.Double"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A double line border.
        ///    </para>
        /// </devdoc>
        Double = 5,

        /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle.Groove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A grooved line border.
        ///    </para>
        /// </devdoc>
        Groove = 6,

        /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle.Ridge"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A ridge line border.
        ///    </para>
        /// </devdoc>
        Ridge = 7,

        /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle.Inset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An inset line border.
        ///    </para>
        /// </devdoc>
        Inset = 8,

        /// <include file='doc\BorderStyle.uex' path='docs/doc[@for="BorderStyle.Outset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An outset line border.
        ///    </para>
        /// </devdoc>
        Outset = 9
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\basevalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseValidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Globalization;
    using System.Web;
    using System.Web.UI.HtmlControls;
    using System.Text.RegularExpressions;
    using System.Text;
    using System.Security.Permissions;

    /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator"]/*' />
    /// <devdoc>
    ///    <para> Serves as the abstract base
    ///       class for validator objects.</para>
    /// </devdoc>
    [
    DefaultProperty("ErrorMessage"),
    Designer("System.Web.UI.Design.WebControls.BaseValidatorDesigner, " + AssemblyRef.SystemDesign),
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public abstract class BaseValidator : Label, IValidator {

        // constants for Validation script library
        private const string ValidatorFileName = "WebUIValidation.js";
        private const string ValidatorScriptVersion = "125";
        private const string ValidatorIncludeScriptKey = "ValidatorIncludeScript";
        private const string ValidatorLocalStartupScript = @"
<script language=""javascript"">
<!--
var Page_ValidationActive = false;
if (typeof(clientInformation) != ""undefined"" && clientInformation.appName.indexOf(""Explorer"") != -1) {{
    if (typeof(Page_ValidationVer) == ""undefined"")
        alert(""{0}"");
    else if (Page_ValidationVer != ""{1}"")
        alert(""{2}"");
    else
        ValidatorOnLoad();
}}

function ValidatorOnSubmit() {{
    if (Page_ValidationActive) {{
        ValidatorCommonOnSubmit();
    }}
}}
// -->
</script>
        ";

        private const string ValidatorStartupScript = @"
<script language=""javascript"">
<!--
var Page_ValidationActive = false;
if (typeof(clientInformation) != ""undefined"" && clientInformation.appName.indexOf(""Explorer"") != -1) {{
    if ((typeof(Page_ValidationVer) != ""undefined"") && (Page_ValidationVer == ""{0}""))
        ValidatorOnLoad();
}}

function ValidatorOnSubmit() {{
    if (Page_ValidationActive) {{
        ValidatorCommonOnSubmit();
    }}
}}
// -->
</script>
        ";

        private bool preRenderCalled;
        private bool isValid;
        private bool propertiesChecked;
        private bool propertiesValid;
        private bool renderUplevel;

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.BaseValidator"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.BaseValidator'/> class.</para>
        /// </devdoc>
        protected BaseValidator() {
            isValid = true;
            propertiesChecked = false;
            propertiesValid = true;
            renderUplevel = false;

            // Default validators to Red
            ForeColor = Color.Red;
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       the text color of validation messages.</para>
        /// </devdoc>
        [
        DefaultValue(typeof(Color), "Red")
        ]
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }
            set {
                base.ForeColor = value;
            }
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.ControlToValidate"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the control to validate.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.BaseValidator_ControlToValidate),
        TypeConverter(typeof(ValidatedControlConverter))
        ]
        public string ControlToValidate {
            get {
                object o = ViewState["ControlToValidate"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                ViewState["ControlToValidate"] = value;
            }
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.ErrorMessage"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the text for the error message.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.BaseValidator_ErrorMessage)
        ]
        public string ErrorMessage {
            get {
                object o = ViewState["ErrorMessage"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                ViewState["ErrorMessage"] = value;
            }
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.EnableClientScript"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(true),
        WebSysDescription(SR.BaseValidator_EnableClientScript)
        ]
        public bool EnableClientScript {
            get {
                object o = ViewState["EnableClientScript"];
                return((o == null) ? true : (bool)o);
            }
            set {
                ViewState["EnableClientScript"] = value;
            }
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.Enabled"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that indicates whether the validation for the control is
        ///       enabled.</para>
        /// </devdoc>
        public override bool Enabled {
            get {
                return base.Enabled;
            }
            set {
                base.Enabled= value;
                // When disabling a validator, it would almost always be intended for that validator
                // to not make the page invalid for that round-trip.
                if (!value) {
                    isValid = true;
                }
            }
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.IsValid"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or sets a flag to indicate if the referenced control passed
        ///       validation.</para>
        /// </devdoc>
        [
        Browsable(false),
        WebCategory("Behavior"),
        DefaultValue(true),
        WebSysDescription(SR.BaseValidator_IsValid),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public bool IsValid {
            get {
                return isValid;
            }
            set {
                isValid = value;
            }
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.PropertiesValid"]/*' />
        /// <devdoc>
        ///    <para>Gets a value that indicates whether the property of the control is valid. This property is read-only.</para>
        /// </devdoc>
        protected bool PropertiesValid {
            get {
                if (!propertiesChecked) {
                    propertiesValid = ControlPropertiesValid();
                    propertiesChecked = true;
                }
                return propertiesValid;
            }
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.RenderUplevel"]/*' />
        /// <devdoc>
        ///    <para>Gets a value that indicates whether the client's browser supports uplevel rendering. This
        ///       property is read-only.</para>
        /// </devdoc>
        protected bool RenderUplevel {
            get {
                return renderUplevel;
            }
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.Display"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the display behavior of the
        ///       validator control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(ValidatorDisplay.Static),
        WebSysDescription(SR.BaseValidator_Display)
        ]
        public ValidatorDisplay Display {
            get {
                object o = ViewState["Display"];
                return((o == null) ? ValidatorDisplay.Static : (ValidatorDisplay)o);
            }
            set {
                if (value < ValidatorDisplay.None || value > ValidatorDisplay.Dynamic) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["Display"] = value;
            }
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Adds the attributes of this control to the output stream for rendering on the
        ///       client.</para>
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {
            // Validators do not render the "disabled" attribute, instead they are invisible when disabled.
            bool disabled = !Enabled;
            if (disabled) {
                Enabled = true;
            }
            base.AddAttributesToRender(writer);

            if (RenderUplevel) {
                // We always want validators to have an id on the client, so if it's null, write it here.
                // Otherwise, base.RenderAttributes takes care of it.
                // REVIEW: this is a bit hacky.
                if (ID == null) {
                    writer.AddAttribute("id", ClientID);
                }

                if (ControlToValidate.Length > 0) {
                    writer.AddAttribute("controltovalidate", GetControlRenderID(ControlToValidate));
                }
                if (ErrorMessage.Length > 0) {
                    writer.AddAttribute("errormessage", ErrorMessage, true);
                }
                ValidatorDisplay display = Display;
                if (display != ValidatorDisplay.Static) {
                    writer.AddAttribute("display", PropertyConverter.EnumToString(typeof(ValidatorDisplay), display));
                }
                if (!IsValid) {
                    writer.AddAttribute("isvalid", "False");
                }
                if (disabled) {
                    writer.AddAttribute("enabled", "False");
                }
            }
            if (disabled) {
                Enabled = false;
            }
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.CheckControlValidationProperty"]/*' />
        /// <devdoc>
        ///    <para> Determines if the referenced control
        ///       has a validation property.</para>
        /// </devdoc>
        protected void CheckControlValidationProperty(string name, string propertyName) {
            // get the control using the relative name
            Control c = NamingContainer.FindControl(name);
            if (c == null) {
                throw new HttpException(
                                       HttpRuntime.FormatResourceString(SR.Validator_control_not_found, name, propertyName, ID));
            }

            // get its validation property
            PropertyDescriptor prop = GetValidationProperty(c);
            if (prop == null) {
                throw new HttpException(
                                       HttpRuntime.FormatResourceString(SR.Validator_bad_control_type, name, propertyName, ID));
            }

        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.ControlPropertiesValid"]/*' />
        /// <devdoc>
        ///    <para>Determines if the properties are valid so that validation
        ///       is meaningful.</para>
        /// </devdoc>
        protected virtual bool ControlPropertiesValid() {
            // Check for blank control to validate
            string controlToValidate = ControlToValidate;
            if (controlToValidate.Length == 0) {
                throw new HttpException(
                                       HttpRuntime.FormatResourceString(SR.Validator_control_blank, ID));
            }

            // Check that the property points to a valid control. Will throw and exception if not found
            CheckControlValidationProperty(controlToValidate, "ControlToValidate");

            return true;
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.EvaluateIsValid"]/*' />
        /// <devdoc>
        ///    <para> TDB. Not
        ///       coded yet.</para>
        /// </devdoc>
        protected abstract bool EvaluateIsValid();

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.GetControlRenderID"]/*' />
        /// <devdoc>
        ///    Gets the control indicated by the relative name and
        ///    returns an ID that can be used on the client.
        /// </devdoc>
        protected string GetControlRenderID(string name) {

            // get the control using the relative name
            Control c = FindControl(name);
            if (c == null) {
                Debug.Fail("We should have already checked for the presence of this");
                return "";
            }
            return c.ClientID;
        }


        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.GetControlValidationValue"]/*' />
        /// <devdoc>
        ///    <para> Gets the validation value of the control
        ///       named relative to the validator.</para>
        /// </devdoc>
        protected string GetControlValidationValue(string name) {

            // get the control using the relative name
            Control c = NamingContainer.FindControl(name);
            if (c == null) {
                return null;
            }

            // get its validation property
            PropertyDescriptor prop = GetValidationProperty(c);
            if (prop == null) {
                return null;
            }

            // get its value as a string
            object value = prop.GetValue(c);
            if (value is ListItem) {
                return((ListItem) value).Value;
            }
            else if (value != null) {
                return value.ToString();
            }
            else {
                return string.Empty;
            }
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.GetValidationProperty"]/*' />
        /// <devdoc>
        ///    <para>Helper function to get the validation
        ///       property of a control if it exists.</para>
        /// </devdoc>
        public static PropertyDescriptor GetValidationProperty(object component) {
            ValidationPropertyAttribute valProp = (ValidationPropertyAttribute)TypeDescriptor.GetAttributes(component)[typeof(ValidationPropertyAttribute)];
            if (valProp != null && valProp.Name != null) {
                return TypeDescriptor.GetProperties(component, null)[valProp.Name];
            }
            return null;
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.OnInit"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para> Registers the validator on the page.</para>
        /// </devdoc>
        protected override void OnInit(EventArgs e) {
            base.OnInit(e);
            Page.Validators.Add(this);
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.OnUnload"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para> Un-registers the validator on the page.</para>
        /// </devdoc>
        protected override void OnUnload(EventArgs e) {
            if (Page != null) {
                Page.Validators.Remove(this);
            }
            base.OnUnload(e);
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Checks the client brower and configures the
        ///       validator for compatibility prior to rendering. </para>
        /// </devdoc>

        protected override void OnPreRender(EventArgs e) {
            base.OnPreRender(e);
            preRenderCalled = true;

            // force a requery of properties for render
            propertiesChecked = false;

            // work out uplevelness now
            renderUplevel = DetermineRenderUplevel();

            if (renderUplevel) {
                RegisterValidatorCommonScript();
            }
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.DetermineRenderUplevel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool DetermineRenderUplevel() {

            // must be on a page
            Page page = Page;
            if (page == null || page.Request == null) {
                return false;
            }

            // Check the browser capabilities
            return (EnableClientScript
                        && page.Request.Browser.MSDomVersion.Major >= 4
                        && page.Request.Browser.EcmaScriptVersion.CompareTo(new Version(1, 2)) >= 0);
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.RegisterValidatorCommonScript"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Registers code on the page for client-side validation.
        ///    </para>
        /// </devdoc>
        protected void RegisterValidatorCommonScript() {

            if (Page.IsClientScriptBlockRegistered(ValidatorIncludeScriptKey)) {
                return;
            }

            // prepare script include
            string location = Util.GetScriptLocation(Context);

            // prepare error messages, which are localized
            string missingScriptMessage = HttpRuntime.FormatResourceString(SR.Validator_missing_script, location + ValidatorFileName);
            string wrongScriptMessage = HttpRuntime.FormatResourceString(SR.Validator_wrong_script,
                                                                         ValidatorFileName,
                                                                         ValidatorScriptVersion,
                                                                         "\" + Page_ValidationVer + \"");

            // prepare script
            string startupScript = String.Empty;
            if (Page.Request.IsLocal) {
                startupScript = String.Format(ValidatorLocalStartupScript, new object [] {
                                              missingScriptMessage,
                                              ValidatorScriptVersion,
                                              wrongScriptMessage
                                          });
            }
            else {
                startupScript = String.Format(ValidatorStartupScript, ValidatorScriptVersion);
            }

            Page.RegisterClientScriptFileInternal(ValidatorIncludeScriptKey, "javascript", location, ValidatorFileName);
            Page.RegisterStartupScript(ValidatorIncludeScriptKey, startupScript);
            Page.RegisterOnSubmitStatement("ValidatorOnSubmit", "ValidatorOnSubmit();");
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.RegisterValidatorDeclaration"]/*' />
        /// <devdoc>
        /// <para>Registers array declarations using the default array, <see langword='Page_Validators'/> .</para>
        /// </devdoc>
        protected virtual void RegisterValidatorDeclaration() {
            string element = "document.all[\"" + ClientID + "\"]";
            Page.RegisterArrayDeclaration("Page_Validators", element);
        }

        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.Render"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Displays the control on the client.</para>
        /// </devdoc>
        protected override void Render(HtmlTextWriter writer) {
            bool shouldBeVisible;

            if (preRenderCalled == false) {
                // This is for design time. In this case we don't want any expandos
                // created, don't want property checks and always want to be visible.
                propertiesChecked = true;
                propertiesValid = true;
                renderUplevel = false;
                shouldBeVisible = true;
            }
            else {
                shouldBeVisible = Enabled && !IsValid;
            }

            // No point rendering if we have errors
            if (!PropertiesValid) {
                return;
            }

            // Make sure we are in a form tag with runat=server.
            if (Page != null) {
                Page.VerifyRenderingInServerForm(this);
            }

            // work out what we are displaying
            ValidatorDisplay display = Display;
            bool displayContents;
            bool displayTags;
            if (RenderUplevel) {
                displayTags = true;
                displayContents = (display != ValidatorDisplay.None);
            }
            else {
                displayContents = (display != ValidatorDisplay.None && shouldBeVisible);
                displayTags = displayContents;
            }

            if (displayTags && RenderUplevel) {

                // Put ourselves in the array
                RegisterValidatorDeclaration();

                // Set extra uplevel styles
                if (display == ValidatorDisplay.None
                    || (!shouldBeVisible && display == ValidatorDisplay.Dynamic)) {
                    Style["display"] = "none";
                }
                else if (!shouldBeVisible) {
                    Debug.Assert(display == ValidatorDisplay.Static, "Unknown Display Type");
                    Style["visibility"] = "hidden";
                }
            }

            // Display it
            if (displayTags) {
                RenderBeginTag(writer);
            }
            if (displayContents) {
                if (Text.Trim().Length > 0) {
                    RenderContents(writer);
                }
                else if (HasControls()) {
                    base.RenderContents(writer);
                }
                else {
                    writer.Write(ErrorMessage);
                }
            }
            else if (!RenderUplevel && display == ValidatorDisplay.Static) {
                // For downlevel in static mode, render a space so that table cells do not render as empty
                writer.Write("&nbsp;");
            }
            if (displayTags) {
                RenderEndTag(writer);
            }
        }


        /// <include file='doc\BaseValidator.uex' path='docs/doc[@for="BaseValidator.Validate"]/*' />
        /// <devdoc>
        /// <para>Evaluates validity and updates the <see cref='System.Web.UI.WebControls.BaseValidator.IsValid'/> property.</para>
        /// </devdoc>
        public void Validate() {
            if (!Visible || !Enabled) {
                IsValid = true;
                return;
            }
            // See if we are in an invisible container
            Control parent = Parent;
            while (parent != null) {
                if (!parent.Visible) {
                    IsValid = true;
                    return;
                }
                parent = parent.Parent;
            }
            propertiesChecked = false;
            if (!PropertiesValid) {
                IsValid = true;
                return;
            }
            IsValid = EvaluateIsValid();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\button.cs ===
//------------------------------------------------------------------------------
// <copyright file="Button.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\Button.uex' path='docs/doc[@for="Button"]/*' />
    /// <devdoc>
    ///    <para>Represents a Windows button control.</para>
    /// </devdoc>
    [
    DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
    DefaultEvent("Click"),
    DefaultProperty("Text"),
    Designer("System.Web.UI.Design.WebControls.ButtonDesigner, " + AssemblyRef.SystemDesign),
    ToolboxData("<{0}:Button runat=server Text=\"Button\"></{0}:Button>")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Button : WebControl, IPostBackEventHandler {

        private static readonly object EventClick = new object();
        private static readonly object EventCommand = new object();

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.Button"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.Button'/> class.</para>
        /// </devdoc>
        public Button() : base(HtmlTextWriterTag.Input) {
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.CommandName"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the command associated with a <see cref='System.Web.UI.WebControls.Button'/> propogated in the <see langword='Command'/> event along with the <see cref='System.Web.UI.WebControls.Button.CommandArgument'/>
        /// property.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.Button_Command)
        ]
        public string CommandName {
            get {
                string s = (string)ViewState["CommandName"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["CommandName"] = value;
            }
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.CommandArgument"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the property propogated in
        ///       the <see langword='Command'/> event with the associated <see cref='System.Web.UI.WebControls.Button.CommandName'/>
        ///       property.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.Button_CommandArgument)
        ]
        public string CommandArgument {
            get {
                string s = (string)ViewState["CommandArgument"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["CommandArgument"] = value;
            }
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.CausesValidation"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets whether pressing the button causes page validation to fire. This defaults to True so that when
        ///          using validation controls, the validation state of all controls are updated when the button is clicked, both
        ///          on the client and the server. Setting this to False is useful when defining a cancel or reset button on a page
        ///          that has validators.</para>
        /// </devdoc>
        [
        Bindable(false),
        WebCategory("Behavior"),
        DefaultValue(true),
        WebSysDescription(SR.Button_CausesValidation)
        ]
        public bool CausesValidation {
            get {
                object b = ViewState["CausesValidation"];
                return((b == null) ? true : (bool)b);
            }
            set {
                ViewState["CausesValidation"] = value;
            }
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.Text"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the text caption displayed on the <see cref='System.Web.UI.WebControls.Button'/> .</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.Button_Text)
        ]
        public string Text {
            get {
                string s = (string)ViewState["Text"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["Text"] = value;
            }
        }



        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.Click"]/*' />
        /// <devdoc>
        /// <para>Occurs when the <see cref='System.Web.UI.WebControls.Button'/> is clicked.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.Button_OnClick)
        ]
        public event EventHandler Click {
            add {
                Events.AddHandler(EventClick, value);
            }
            remove {
                Events.RemoveHandler(EventClick, value);
            }
        }


        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.Command"]/*' />
        /// <devdoc>
        /// <para>Occurs when the <see cref='System.Web.UI.WebControls.Button'/> is clicked.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.Button_OnCommand)
        ]
        public event CommandEventHandler Command {
            add {
                Events.AddHandler(EventCommand, value);
            }
            remove {
                Events.RemoveHandler(EventCommand, value);
            }
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Adds the attributes of the <see cref='System.Web.UI.WebControls.Button'/> control to the output stream for rendering
        ///    on the client.</para>
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {

            // Make sure we are in a form tag with runat=server.
            if (Page != null) {
                Page.VerifyRenderingInServerForm(this);
            }

            writer.AddAttribute(HtmlTextWriterAttribute.Type, "submit");
            writer.AddAttribute(HtmlTextWriterAttribute.Name, UniqueID);
            writer.AddAttribute(HtmlTextWriterAttribute.Value, Text);

            if (Page != null && CausesValidation && Page.Validators.Count > 0) {
                // ASURT 98368
                // Need to merge the validation script with the user script
                string onClick = Util.GetClientValidateEvent(Page);
                if (HasAttributes) {
                    string userOnClick = Attributes["onclick"];
                    if (userOnClick != null) {
                        onClick = userOnClick + onClick;
                        Attributes.Remove("onclick");
                    }
                }
                writer.AddAttribute(HtmlTextWriterAttribute.Onclick, onClick);
                writer.AddAttribute("language", "javascript");
            }

            base.AddAttributesToRender(writer);
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.OnClick"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='Click '/>event of a <see cref='System.Web.UI.WebControls.Button'/>
        /// .</para>
        /// </devdoc>
        protected virtual void OnClick(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventClick];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.OnCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='Command '/>event of a <see cref='System.Web.UI.WebControls.Button'/>
        /// .</para>
        /// </devdoc>
        protected virtual void OnCommand(CommandEventArgs e) {
            CommandEventHandler handler = (CommandEventHandler)Events[EventCommand];
            if (handler != null)
                handler(this,e);

            // Command events are bubbled up the control heirarchy
            RaiseBubbleEvent(this, e);
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.IPostBackEventHandler.RaisePostBackEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Raises events for the <see cref='System.Web.UI.WebControls.Button'/>
        /// control on post back.</para>
        /// </devdoc>
        void IPostBackEventHandler.RaisePostBackEvent(string eventArgument) {
            if (CausesValidation) {
                Page.Validate();
            }
            OnClick(new EventArgs());
            OnCommand(new CommandEventArgs(CommandName, CommandArgument));
        }

        /// <include file='doc\Button.uex' path='docs/doc[@for="Button.RenderContents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderContents(HtmlTextWriter writer) {
            // Do not render the children of a button since it does not
            // make sense to have children of an <input> tag.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\buttoncolumntype.cs ===
//------------------------------------------------------------------------------
// <copyright file="ButtonColumnType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\ButtonColumnType.uex' path='docs/doc[@for="ButtonColumnType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the values for the <see cref='System.Web.UI.WebControls.ButtonColumn.ButtonType'/> property on a <see cref='System.Web.UI.WebControls.ButtonColumn'/>
    ///       column.
    ///    </para>
    /// </devdoc>
    public enum ButtonColumnType {

        /// <include file='doc\ButtonColumnType.uex' path='docs/doc[@for="ButtonColumnType.LinkButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A
        ///       column of link buttons.
        ///    </para>
        /// </devdoc>
        LinkButton = 0,

        /// <include file='doc\ButtonColumnType.uex' path='docs/doc[@for="ButtonColumnType.PushButton"]/*' />
        /// <devdoc>
        ///    <para> A column of push buttons.</para>
        /// </devdoc>
        PushButton = 1
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\boundcolumn.cs ===
//------------------------------------------------------------------------------
// <copyright file="BoundColumn.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;    
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\BoundColumn.uex' path='docs/doc[@for="BoundColumn"]/*' />
    /// <devdoc>
    /// <para>Creates a column bounded to a data field in a <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class BoundColumn : DataGridColumn {
        
        /// <include file='doc\BoundColumn.uex' path='docs/doc[@for="BoundColumn.thisExpr"]/*' />
        /// <devdoc>
        ///    <para>Specifies a string that represents "this". This field is read-only. </para>
        /// </devdoc>
        public static readonly string thisExpr = "!";

        private PropertyDescriptor boundFieldDesc;
        private bool boundFieldDescValid;
        private string boundField;
        private string formatting;

        /// <include file='doc\BoundColumn.uex' path='docs/doc[@for="BoundColumn.BoundColumn"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of a <see cref='System.Web.UI.WebControls.BoundColumn'/> class.</para>
        /// </devdoc>
        public BoundColumn() {
        }
        
        
        /// <include file='doc\BoundColumn.uex' path='docs/doc[@for="BoundColumn.DataField"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the field name from the data model bound to this column.</para>
        /// </devdoc>
        [
            WebCategory("Data"),
            DefaultValue(""),
            WebSysDescription(SR.BoundColumn_DataField)
        ]
        public virtual string DataField {
            get {
                object o = ViewState["DataField"];
                if (o != null)
                    return (string)o;
                return String.Empty;
            }
            set {
                ViewState["DataField"] = value;
                OnColumnChanged();
            }
        }
        
        /// <include file='doc\BoundColumn.uex' path='docs/doc[@for="BoundColumn.DataFormatString"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the display format of data in this
        ///       column.</para>
        /// </devdoc>
        [
            WebCategory("Behavior"),
            DefaultValue(""),
            WebSysDescription(SR.BoundColumn_DataFormatString)
        ]
        public virtual string DataFormatString {
            get {
                object o = ViewState["DataFormatString"];
                if (o != null)
                    return (string)o;
                return String.Empty;
            }
            set {
                ViewState["DataFormatString"] = value;
                OnColumnChanged();
            }
        }
        
        /// <include file='doc\BoundColumn.uex' path='docs/doc[@for="BoundColumn.ReadOnly"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the property that prevents modification to data
        ///       in this column.</para>
        /// </devdoc>
        [
            WebCategory("Behavior"),
            DefaultValue(false),
            WebSysDescription(SR.BoundColumn_ReadOnly)
        ]
        public virtual bool ReadOnly {
            get {
                object o = ViewState["ReadOnly"];
                if (o != null)
                    return (bool)o;
                return false;
            }
            set {
                ViewState["ReadOnly"] = value;
                OnColumnChanged();
            }
        }
        
        
        /// <include file='doc\BoundColumn.uex' path='docs/doc[@for="BoundColumn.FormatDataValue"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected virtual string FormatDataValue(object dataValue) {
            string formattedValue = String.Empty;

            if ((dataValue != null) && (dataValue != System.DBNull.Value)) {
                if (formatting.Length == 0) {
                    formattedValue = dataValue.ToString();
                }
                else {
                    formattedValue = String.Format(formatting, dataValue);
                }
            }

            return formattedValue;
        }

        /// <include file='doc\BoundColumn.uex' path='docs/doc[@for="BoundColumn.Initialize"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override void Initialize() {
            base.Initialize();

            boundFieldDesc = null;
            boundFieldDescValid = false;

            boundField = DataField;
            formatting = DataFormatString;
        }

        /// <include file='doc\BoundColumn.uex' path='docs/doc[@for="BoundColumn.InitializeCell"]/*' />
        /// <devdoc>
        /// <para>Initializes a cell in the DataGridColumn.</para>
        /// </devdoc>
        public override void InitializeCell(TableCell cell, int columnIndex, ListItemType itemType) {
            base.InitializeCell(cell, columnIndex, itemType);
            
            Control childControl = null;
            Control boundControl = null;
            
            switch (itemType) {
                case ListItemType.Header:
                case ListItemType.Footer:
                    break;

                case ListItemType.Item:
                case ListItemType.AlternatingItem:
                case ListItemType.SelectedItem:
                    if (DataField.Length != 0) {
                        boundControl = cell;
                    }
                    break;
                    
                case ListItemType.EditItem:
                    if (ReadOnly == true) {
                        goto case ListItemType.Item;
                    }
                    else {
                        // CONSIDER, nikhilko: Use a control map here
                        TextBox editor = new TextBox();
                        childControl = editor;
                        
                        if (boundField.Length != 0) {
                            boundControl = editor;
                        }
                    }
                    break;
            }
            
            if (childControl != null) {
                cell.Controls.Add(childControl);
            }

            if (boundControl != null) {
                boundControl.DataBinding += new EventHandler(this.OnDataBindColumn);
            }
        }

        /// <include file='doc\BoundColumn.uex' path='docs/doc[@for="BoundColumn.OnDataBindColumn"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnDataBindColumn(object sender, EventArgs e) {
            Debug.Assert(DataField.Length != 0, "Shouldn't be DataBinding without a DataField");

            Control boundControl = (Control)sender;
            DataGridItem item = (DataGridItem)boundControl.NamingContainer;
            object dataItem = item.DataItem;

            if (boundFieldDescValid == false) {
                if (!boundField.Equals(thisExpr)) {
                    boundFieldDesc = TypeDescriptor.GetProperties(dataItem).Find(boundField, true);
                    if ((boundFieldDesc == null) && !DesignMode) {
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Field_Not_Found, boundField));
                    }
                }
                boundFieldDescValid = true;
            }
            
            object data = dataItem;
            string dataValue;

            if ((boundFieldDesc == null) && DesignMode) {
                dataValue = SR.GetString(SR.Sample_Databound_Text);
            }
            else {
                if (boundFieldDesc != null) {
                    data = boundFieldDesc.GetValue(dataItem);
                }
                dataValue = FormatDataValue(data);
            }

            if (boundControl is TableCell) {
                if (dataValue.Length == 0) {
                    dataValue = "&nbsp;";
                }
                ((TableCell)boundControl).Text = dataValue;
            }
            else {
                Debug.Assert(boundControl is TextBox, "Expected the bound control to be a TextBox");
                ((TextBox)boundControl).Text = dataValue;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\basedatalist.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseDataList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList"]/*' />
    /// <devdoc>
    /// <para>Serves as the abstract base class for the <see cref='System.Web.UI.WebControls.DataList'/> and <see cref='System.Web.UI.WebControls.DataGrid'/> 
    /// controls and implements the selection semantics which are common to both
    /// controls.</para>
    /// </devdoc>
    [
    DefaultEvent("SelectedIndexChanged"),
    DefaultProperty("DataSource"),
    Designer("System.Web.UI.Design.WebControls.BaseDataListDesigner, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public abstract class BaseDataList : WebControl {

        private static readonly object EventSelectedIndexChanged = new object();

        internal const string ItemCountViewStateKey = "_!ItemCount";

        private object dataSource;
        private DataKeyCollection dataKeysCollection;

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.BaseDataList"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.BaseDataList'/> class.</para>
        /// </devdoc>
        public BaseDataList() {
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.CellPadding"]/*' />
        /// <devdoc>
        ///    <para>Indicates the amount of space between cells.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(-1),
        WebSysDescription(SR.BaseDataList_CellPadding)
        ]
        public virtual int CellPadding {
            get {
                if (ControlStyleCreated == false) {
                    return -1;
                }
                return ((TableStyle)ControlStyle).CellPadding;
            }
            set {
                ((TableStyle)ControlStyle).CellPadding = value;
            }
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.CellSpacing"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the amount of space between the contents of 
        ///       a cell and the cell's border.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(0),
        WebSysDescription(SR.BaseDataList_CellSpacing)
        ]
        public virtual int CellSpacing {
            get {
                if (ControlStyleCreated == false) {
                    return 0;
                }
                return ((TableStyle)ControlStyle).CellSpacing;
            }
            set {
                ((TableStyle)ControlStyle).CellSpacing = value;
            }
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.Controls"]/*' />
        public override ControlCollection Controls {
            get {
                EnsureChildControls();
                return base.Controls;
            }
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.DataKeys"]/*' />
        /// <devdoc>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.BaseDataList_DataKeys)
        ]
        public DataKeyCollection DataKeys {
            get {
                if (dataKeysCollection == null) {
                    dataKeysCollection = new DataKeyCollection(this.DataKeysArray);
                }
                return dataKeysCollection;
            }
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.DataKeysArray"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected ArrayList DataKeysArray {
            get {
                object o = ViewState["DataKeys"];
                if (o == null) {
                    o = new ArrayList();
                    ViewState["DataKeys"] = o;
                }
                return(ArrayList)o;
            }
        }


        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.DataKeyField"]/*' />
        /// <devdoc>
        /// <para>Indicatesthe primary key field in the data source referenced by <see cref='System.Web.UI.WebControls.BaseDataList.DataSource'/>.</para>
        /// </devdoc>
        [
        WebCategory("Data"),
        DefaultValue(""),
        WebSysDescription(SR.BaseDataList_DataKeyField)
        ]
        public virtual string DataKeyField {
            get {
                object o = ViewState["DataKeyField"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["DataKeyField"] = value;
            }
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.DataMember"]/*' />
        /// <devdoc>
        /// </devdoc>
        [
        DefaultValue(""),
        WebCategory("Data"),
        WebSysDescription(SR.BaseDataList_DataMember)
        ]
        public string DataMember {
            get {
                object o = ViewState["DataMember"];
                if (o != null)
                    return (string)o;
                return String.Empty;
            }
            set {
                ViewState["DataMember"] = value;
            }
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.DataSource"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or sets the source to a list of values used to populate
        ///       the items within the control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Data"),
        DefaultValue(null),
        WebSysDescription(SR.BaseDataList_DataSource),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public virtual object DataSource {
            get {
                return dataSource;
            }
            set {
                if ((value == null) || (value is IListSource) || (value is IEnumerable)) {
                    dataSource = value;
                }
                else {
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Invalid_DataSource_Type, ID));
                }
            }
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.GridLines"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that specifies the grid line style.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(GridLines.Both),
        WebSysDescription(SR.BaseDataList_GridLines)
        ]
        public virtual GridLines GridLines {
            get {
                if (ControlStyleCreated == false) {
                    return GridLines.Both;
                }
                return ((TableStyle)ControlStyle).GridLines;
            }
            set {
                ((TableStyle)ControlStyle).GridLines = value;
            }
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.HorizontalAlign"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that specifies the alignment of a rows with respect 
        ///       surrounding text.</para>
        /// </devdoc>
        [
        Bindable(true),
        Category("Layout"),
        DefaultValue(HorizontalAlign.NotSet),
        WebSysDescription(SR.BaseDataList_HorizontalAlign)
        ]
        public virtual HorizontalAlign HorizontalAlign {
            get {
                if (ControlStyleCreated == false) {
                    return HorizontalAlign.NotSet;
                }
                return ((TableStyle)ControlStyle).HorizontalAlign;
            }
            set {
                ((TableStyle)ControlStyle).HorizontalAlign = value;
            }
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.SelectedIndexChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when an item on the list is selected.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.BaseDataList_OnSelectedIndexChanged)
        ]
        public event EventHandler SelectedIndexChanged {
            add {
                Events.AddHandler(EventSelectedIndexChanged, value);
            }
            remove {
                Events.RemoveHandler(EventSelectedIndexChanged, value);
            }
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.AddParsedSubObject"]/*' />
        /// <devdoc>
        ///    <para> Not coded yet.</para>
        /// </devdoc>
        protected override void AddParsedSubObject(object obj) {
            return;
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.CreateChildControls"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Creates a child control using the view state.</para>
        /// </devdoc>
        protected override void CreateChildControls() {
            Controls.Clear();

            if (ViewState[ItemCountViewStateKey] != null) {
                // create the control hierarchy using the view state (and
                // not the datasource)
                CreateControlHierarchy(false);
                ClearChildViewState();
            }
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.CreateControlHierarchy"]/*' />
        protected abstract void CreateControlHierarchy(bool useDataSource);

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.DataBind"]/*' />
        public override void DataBind() {
            // do our own databinding
            OnDataBinding(EventArgs.Empty);

            // contained items will be databound after they have been created,
            // so we don't want to walk the hierarchy here.
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.IsBindableType"]/*' />
        /// <devdoc>
        ///    <para>Determines if the specified data type can be bound to.</para>
        /// </devdoc>
        public static bool IsBindableType(Type type) {
            return(type.IsPrimitive ||
                   (type == typeof(string)) ||
                   (type == typeof(DateTime)) ||
                   (type == typeof(Decimal)));
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.OnDataBinding"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Raises the <see langword='DataBinding '/>event of a <see cref='System.Web.UI.WebControls.BaseDataList'/> 
        /// .</para>
        /// </devdoc>
        protected override void OnDataBinding(EventArgs e) {
            base.OnDataBinding(e);

            // reset the control state
            Controls.Clear();
            ClearChildViewState();

            // and create the control hierarchy using the datasource
            CreateControlHierarchy(true);
            ChildControlsCreated = true;

            TrackViewState();
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.OnSelectedIndexChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Web.UI.WebControls.BaseDataList.SelectedIndexChanged'/>event of a <see cref='System.Web.UI.WebControls.BaseDataList'/>.</para>
        /// </devdoc>
        protected virtual void OnSelectedIndexChanged(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventSelectedIndexChanged];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.PrepareControlHierarchy"]/*' />
        protected abstract void PrepareControlHierarchy();

        /// <include file='doc\BaseDataList.uex' path='docs/doc[@for="BaseDataList.Render"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Displays the control on the client.</para>
        /// </devdoc>
        protected override void Render(HtmlTextWriter writer) {
            PrepareControlHierarchy();
            RenderContents(writer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\buttoncolumn.cs ===
//------------------------------------------------------------------------------
// <copyright file="ButtonColumn.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;   
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\ButtonColumn.uex' path='docs/doc[@for="ButtonColumn"]/*' />
    /// <devdoc>
    /// <para>Creates a column with a set of <see cref='System.Web.UI.WebControls.Button'/>
    /// controls.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ButtonColumn : DataGridColumn {

        private PropertyDescriptor textFieldDesc;

        /// <include file='doc\ButtonColumn.uex' path='docs/doc[@for="ButtonColumn.ButtonColumn"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.ButtonColumn'/> class.</para>
        /// </devdoc>
        public ButtonColumn() {
        }


        /// <include file='doc\ButtonColumn.uex' path='docs/doc[@for="ButtonColumn.ButtonType"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the type of button to render in the
        ///       column.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(ButtonColumnType.LinkButton),
        DescriptionAttribute("The type of button contained within the column.")
        ]
        public virtual ButtonColumnType ButtonType {
            get {
                object o = ViewState["ButtonType"];
                if (o != null)
                    return(ButtonColumnType)o;
                return ButtonColumnType.LinkButton;
            }
            set {
                if (value < ButtonColumnType.LinkButton || value > ButtonColumnType.PushButton) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["ButtonType"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\ButtonColumn.uex' path='docs/doc[@for="ButtonColumn.CommandName"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the command to perform when this <see cref='System.Web.UI.WebControls.Button'/>
        /// is clicked.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        DescriptionAttribute("The command associated with the button.")
        ]
        public virtual string CommandName {
            get {
                object o = ViewState["CommandName"];
                if (o != null)
                    return(string)o;
                return string.Empty;
            }
            set {
                ViewState["CommandName"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\ButtonColumn.uex' path='docs/doc[@for="ButtonColumn.DataTextField"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the field name from the data model that is 
        ///       bound to the <see cref='System.Web.UI.WebControls.ButtonColumn.Text'/> property of the button in this column.</para>
        /// </devdoc>
        [
        WebCategory("Data"),
        DefaultValue(""),
        DescriptionAttribute("The field bound to the text property of the button.")
        ]
        public virtual string DataTextField {
            get {
                object o = ViewState["DataTextField"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["DataTextField"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\ButtonColumn.uex' path='docs/doc[@for="ButtonColumn.DataTextFormatString"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the string used to format the data bound to 
        ///       the <see cref='System.Web.UI.WebControls.ButtonColumn.Text'/> property of the button.</para>
        /// </devdoc>
        [
        WebCategory("Data"),
        DefaultValue(""),
        DescriptionAttribute("The formatting applied to the value bound to the Text property.")
        ]
        public virtual string DataTextFormatString {
            get {
                object o = ViewState["DataTextFormatString"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["DataTextFormatString"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\ButtonColumn.uex' path='docs/doc[@for="ButtonColumn.Text"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the caption text displayed on the <see cref='System.Web.UI.WebControls.Button'/>
        /// in this column.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        DescriptionAttribute("The text used for the button.")
        ]
        public virtual string Text {
            get {
                object o = ViewState["Text"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["Text"] = value;
                OnColumnChanged();
            }
        }


        /// <include file='doc\ButtonColumn.uex' path='docs/doc[@for="ButtonColumn.FormatDataTextValue"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected virtual string FormatDataTextValue(object dataTextValue) {
            string formattedTextValue = String.Empty;

            if ((dataTextValue != null) && (dataTextValue != System.DBNull.Value)) {
                string formatting = DataTextFormatString;
                if (formatting.Length == 0) {
                    formattedTextValue = dataTextValue.ToString();
                }
                else {
                    formattedTextValue = String.Format(formatting, dataTextValue);
                }
            }

            return formattedTextValue;
        }

        /// <include file='doc\ButtonColumn.uex' path='docs/doc[@for="ButtonColumn.Initialize"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override void Initialize() {
            base.Initialize();
            textFieldDesc = null;
        }
        
        /// <include file='doc\ButtonColumn.uex' path='docs/doc[@for="ButtonColumn.InitializeCell"]/*' />
        /// <devdoc>
        /// <para>Initializes a cell in the <see cref='System.Web.UI.WebControls.ButtonColumn'/> .</para>
        /// </devdoc>
        public override void InitializeCell(TableCell cell, int columnIndex, ListItemType itemType) {
            base.InitializeCell(cell, columnIndex, itemType);

            if ((itemType != ListItemType.Header) &&
                (itemType != ListItemType.Footer)) {
                WebControl buttonControl = null;

                if (ButtonType == ButtonColumnType.LinkButton) {
                    LinkButton button = new DataGridLinkButton();

                    button.Text = Text;
                    button.CommandName = CommandName;
                    button.CausesValidation = false;
                    buttonControl = button;
                }
                else {
                    Button button = new Button();

                    button.Text = Text;
                    button.CommandName = CommandName;
                    button.CausesValidation = false;
                    buttonControl = button;
                }

                if (DataTextField.Length != 0) {
                    buttonControl.DataBinding += new EventHandler(this.OnDataBindColumn);
                }

                cell.Controls.Add(buttonControl);
            }
        }

        /// <include file='doc\ButtonColumn.uex' path='docs/doc[@for="ButtonColumn.OnDataBindColumn"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnDataBindColumn(object sender, EventArgs e) {
            Debug.Assert(DataTextField.Length != 0, "Shouldn't be DataBinding without a DataTextField");

            Control boundControl = (Control)sender;
            DataGridItem item = (DataGridItem)boundControl.NamingContainer;
            object dataItem = item.DataItem;

            if (textFieldDesc == null) {
                string dataField = DataTextField;

                textFieldDesc = TypeDescriptor.GetProperties(dataItem).Find(dataField, true);
                if ((textFieldDesc == null) && !DesignMode) {
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Field_Not_Found, dataField));
                }
            }

            string dataValue;

            if (textFieldDesc != null) {
                object data = textFieldDesc.GetValue(dataItem);
                dataValue = FormatDataTextValue(data);
            }
            else {
                Debug.Assert(DesignMode == true);
                dataValue = SR.GetString(SR.Sample_Databound_Text);
            }

            if (boundControl is LinkButton) {
                ((LinkButton)boundControl).Text = dataValue;
            }
            else {
                Debug.Assert(boundControl is Button, "Expected the bound control to be a Button");
                ((Button)boundControl).Text = dataValue;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\calendarday.cs ===
//------------------------------------------------------------------------------
// <copyright file="CalendarDay.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {
    using System.ComponentModel;

    using System;
    using System.Security.Permissions;

    /// <include file='doc\CalendarDay.uex' path='docs/doc[@for="CalendarDay"]/*' />
    /// <devdoc>
    ///    <para> Represents a calendar day.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class CalendarDay {
        private DateTime date;
        private bool isSelectable;
        private bool isToday;
        private bool isWeekend;
        private bool isOtherMonth;
        private bool isSelected;
        private string dayNumberText;

        /// <include file='doc\CalendarDay.uex' path='docs/doc[@for="CalendarDay.CalendarDay"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CalendarDay(DateTime date, bool isWeekend, bool isToday, bool isSelected, bool isOtherMonth, string dayNumberText) {
            this.date = date;
            this.isWeekend = isWeekend;
            this.isToday = isToday;
            this.isOtherMonth  = isOtherMonth;
            this.isSelected = isSelected;
            this.dayNumberText = dayNumberText;
        }

        /// <include file='doc\CalendarDay.uex' path='docs/doc[@for="CalendarDay.Date"]/*' />
        /// <devdoc>
        ///    <para> Gets the date represented by an instance of this class. This
        ///       property is read-only.</para>
        /// </devdoc>
        public DateTime Date {
            get {
                return date;
            }
        }

        /// <include file='doc\CalendarDay.uex' path='docs/doc[@for="CalendarDay.DayNumberText"]/*' />
        /// <devdoc>
        ///    <para>Gets the string equivilent of the date represented by an instance of this class. This property is read-only.</para>
        /// </devdoc>
        public string DayNumberText {
            get {
                return dayNumberText;
            }
        }

        /// <include file='doc\CalendarDay.uex' path='docs/doc[@for="CalendarDay.IsOtherMonth"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the date represented by an instance of
        ///       this class is in a different month from the month currently being displayed. This
        ///       property is read-only.</para>
        /// </devdoc>
        public bool IsOtherMonth {
            get {
                return isOtherMonth;
            }
        }

        /// <include file='doc\CalendarDay.uex' path='docs/doc[@for="CalendarDay.IsSelectable"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the date represented
        ///       by an instance of
        ///       this class can be selected.</para>
        /// </devdoc>
        public bool IsSelectable {
            get {
                return isSelectable;
            }
            set {
                isSelectable = value;
            }
        }

        /// <include file='doc\CalendarDay.uex' path='docs/doc[@for="CalendarDay.IsSelected"]/*' />
        /// <devdoc>
        ///    <para> Gets a value indicating whether date represented by an instance of this class is selected. This property is read-only.</para>
        /// </devdoc>
        public bool IsSelected {
            get {
                return isSelected;
            }
        }

        /// <include file='doc\CalendarDay.uex' path='docs/doc[@for="CalendarDay.IsToday"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the date represented by an instance of this class is today's date. This property is read-only.</para>
        /// </devdoc>
        public bool IsToday {
            get {
                return isToday;
            }
        }

        /// <include file='doc\CalendarDay.uex' path='docs/doc[@for="CalendarDay.IsWeekend"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the date represented by an instance of
        ///       this class is on a weekend day. This property is read-only.</para>
        /// </devdoc>
        public bool IsWeekend {
            get {
                return isWeekend;
            }
        }

    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\checkbox.cs ===
//------------------------------------------------------------------------------
// <copyright file="CheckBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Globalization;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox"]/*' />
    /// <devdoc>
    ///    <para>Represents a Windows checkbox control.</para>
    /// </devdoc>
    [
    DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
    DefaultEvent("CheckedChanged"),
    Designer("System.Web.UI.Design.WebControls.CheckBoxDesigner, " + AssemblyRef.SystemDesign),
    DefaultProperty("Text")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class CheckBox : WebControl, IPostBackDataHandler {

        private static readonly object EventCheckedChanged = new object();

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CheckBox"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.CheckBox'/> class.</para>
        /// </devdoc>
        public CheckBox() : base(HtmlTextWriterTag.Input) {
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.AutoPostBack"]/*' />
        /// <devdoc>
        /// <para>Gets or sets a value indicating that the <see cref='System.Web.UI.WebControls.CheckBox'/> state is automatically posted back to
        ///    the
        ///    server.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(false),
        WebSysDescription(SR.CheckBox_AutoPostBack)
        ]
        public virtual bool AutoPostBack {
            get {
                object b = ViewState["AutoPostBack"];
                return((b == null) ? false : (bool)b);
            }
            set {
                ViewState["AutoPostBack"] = value;
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.Checked"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating the checked state of the
        ///    <see cref='System.Web.UI.WebControls.CheckBox'/>.</para>
        /// </devdoc>
        [
        Bindable(true),
        DefaultValue(false),
        WebSysDescription(SR.CheckBox_Checked)
        ]
        public virtual bool Checked {
            get {
                object b = ViewState["Checked"];
                return((b == null) ? false : (bool)b);
            }
            set {
                ViewState["Checked"] = value;
            }
        }

        /// <devdoc>
        ///   Controls whether the Checked property is saved in ViewState.
        ///   This is used for optimizing the size of the view state.
        /// </devdoc>
        private bool SaveCheckedViewState {
            get {
                // Checked must be saved when:
                // 1. When there is a event handler for the CheckedChanged event
                // 2. Checkbox is not Enabled - The browser does not post data for disabled input controls
                // 3. Instance type is not CheckBox or RadioButton, i.e., we have to save when the user
                //    might have written a derived control which overrides OnCheckedChanged

                if ((Events[EventCheckedChanged] != null) ||
                    (Enabled == false)) {
                    return true;
                }

                Type t = this.GetType();
                if ((t == typeof(CheckBox)) || (t == typeof(RadioButton))) {
                    return false;
                }

                return true;
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.Text"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the text label associated with the <see cref='System.Web.UI.WebControls.CheckBox'/>.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.CheckBox_Text)
        ]
        public virtual string Text {
            get {
                string s = (string)ViewState["Text"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["Text"] = value;
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.TextAlign"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the alignment of the <see langword='Text'/> associated with the <see cref='System.Web.UI.WebControls.CheckBox'/>.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(TextAlign.Right),
        WebSysDescription(SR.CheckBox_TextAlign)
        ]
        public virtual TextAlign TextAlign {
            get {
                object align = ViewState["TextAlign"];
                return((align == null) ? TextAlign.Right : (TextAlign)align);
            }
            set {
                if (value < TextAlign.Left || value > TextAlign.Right) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["TextAlign"] = value;
            }
        }


        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.CheckedChanged"]/*' />
        /// <devdoc>
        /// <para>Occurs when the <see cref='System.Web.UI.WebControls.CheckBox'/> is clicked.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.CheckBox_OnCheckChanged)
        ]
        public event EventHandler CheckedChanged {
            add {
                Events.AddHandler(EventCheckedChanged, value);
            }
            remove {
                Events.RemoveHandler(EventCheckedChanged, value);
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.OnCheckedChanged"]/*' />
        /// <devdoc>
        ///    <para> Raises the
        ///    <see langword='CheckedChanged'/> event of the <see cref='System.Web.UI.WebControls.CheckBox'/>
        ///    controls.</para>
        /// </devdoc>
        protected virtual void OnCheckedChanged(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventCheckedChanged];
            if (handler != null) {
                handler(this, e);
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Processes posted data for the <see cref='System.Web.UI.WebControls.CheckBox'/>
        /// control.</para>
        /// </devdoc>
        bool IPostBackDataHandler.LoadPostData(string postDataKey, NameValueCollection postCollection) {
            string post = postCollection[postDataKey];
            bool newValue = (post != null && post.Length > 0);
            bool valueChanged = (newValue != Checked);
            Checked = newValue;
            return valueChanged;
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Registers client script for generating postback prior to
        ///       rendering on the client if <see cref='System.Web.UI.WebControls.CheckBox.AutoPostBack'/> is
        ///    <see langword='true'/>.</para>
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {
            if (Page != null && Enabled) {
                // we always need to get post back data
                Page.RegisterRequiresPostBack(this);
                if (AutoPostBack)
                    Page.RegisterPostBackScript();
            }

            if (SaveCheckedViewState == false) {
                ViewState.SetItemDirty("Checked", false);
            }
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Raises when posted data for a control has changed.
        /// </devdoc>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            OnCheckedChanged(EventArgs.Empty);
        }

        /// <include file='doc\CheckBox.uex' path='docs/doc[@for="CheckBox.Render"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Displays the <see cref='System.Web.UI.WebControls.CheckBox'/> on the client.</para>
        /// </devdoc>
        protected override void Render(HtmlTextWriter writer) {
            // Render the wrapper span

            // Make sure we are in a form tag with runat=server.
            if (Page != null) {
                Page.VerifyRenderingInServerForm(this);
            }

            bool renderWrapper = false;

            // On wrapper, render the style,
            if (ControlStyleCreated) {
                Style controlStyle = ControlStyle;
                if (!controlStyle.IsEmpty) {
                    controlStyle.AddAttributesToRender(writer, this);
                    renderWrapper = true;
                }
            }
            // And Enabled
            if (!Enabled) {
                writer.AddAttribute(HtmlTextWriterAttribute.Disabled, "disabled");
                renderWrapper = true;
            }
            // And ToolTip
            string toolTip = ToolTip;
            if (toolTip.Length > 0) {
                writer.AddAttribute(HtmlTextWriterAttribute.Title, toolTip);
                renderWrapper = true;
            }

            string onClick = null;
            // And other attributes
            if (HasAttributes) {
                System.Web.UI.AttributeCollection attribs = Attributes;

                // remove value from the attribute collection so it's not on the wrapper
                string val = attribs["value"];
                if (val != null)
                    attribs.Remove("value");

                // remove and save onclick from the attribute collection so we can move it to the input tag
                onClick = attribs["onclick"];
                if (onClick != null) {
                    attribs.Remove("onclick");
                }

                if (attribs.Count != 0)
                {
                    attribs.AddAttributes(writer);
                    renderWrapper = true;
                }

                if (val != null)
                    attribs["value"] = val;
            }

            // render begin tag of wrapper SPAN
            if (renderWrapper) {
                writer.RenderBeginTag(HtmlTextWriterTag.Span);
            }

            string text = Text;
            string clientID = ClientID;
            if (text.Length != 0) {
                if (TextAlign == TextAlign.Left) {
                    // render label to left of checkbox
                    RenderLabel(writer, text, clientID);
                    RenderInputTag(writer, clientID, onClick);
                }
                else {
                    // render label to right of checkbox
                    RenderInputTag(writer, clientID, onClick);
                    RenderLabel(writer, text, clientID);
                }
            }
            else
                RenderInputTag(writer, clientID, onClick);

            // render end tag of wrapper SPAN
            if (renderWrapper) {
                writer.RenderEndTag();
            }
        }

        private void RenderLabel(HtmlTextWriter writer, string text, string clientID) {
            writer.AddAttribute(HtmlTextWriterAttribute.For, clientID);

            writer.RenderBeginTag(HtmlTextWriterTag.Label);
            writer.Write(text);
            writer.RenderEndTag();
        }

        internal virtual void RenderInputTag(HtmlTextWriter writer, string clientID, string onClick) {
            writer.AddAttribute(HtmlTextWriterAttribute.Id, clientID);
            writer.AddAttribute(HtmlTextWriterAttribute.Type, "checkbox");
            writer.AddAttribute(HtmlTextWriterAttribute.Name, UniqueID);

            if (Checked)
                writer.AddAttribute(HtmlTextWriterAttribute.Checked, "checked");

            // ASURT 119141: Render the disabled attribute on the INPUT tag (instead of the SPAN) so the checkbox actually gets disabled when Enabled=false
            if (!Enabled) {
                writer.AddAttribute(HtmlTextWriterAttribute.Disabled, "disabled");
            }

            if (AutoPostBack) {
                // ASURT 98368
                // Need to merge the autopostback script with the user script
                if (onClick != null) {
                    onClick += Page.GetPostBackClientEvent(this, "");
                }
                else {
                    onClick = Page.GetPostBackClientEvent(this, "");
                }
                writer.AddAttribute(HtmlTextWriterAttribute.Onclick, onClick);
                writer.AddAttribute("language", "javascript");
            }
            else {
                if (onClick != null) {
                    writer.AddAttribute(HtmlTextWriterAttribute.Onclick, onClick);
                }
            }

            string s = AccessKey;
            if (s.Length > 0)
                writer.AddAttribute(HtmlTextWriterAttribute.Accesskey, s);

            int i = TabIndex;
            if (i != 0)
                writer.AddAttribute(HtmlTextWriterAttribute.Tabindex, i.ToString(NumberFormatInfo.InvariantInfo));

            writer.RenderBeginTag(HtmlTextWriterTag.Input);
            writer.RenderEndTag();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\calendarselectionmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="CalendarSelectionMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {
    
    /// <include file='doc\CalendarSelectionMode.uex' path='docs/doc[@for="CalendarSelectionMode"]/*' />
    /// <devdoc>
    /// <para>Specifies the selection method for dates on the System.Web.UI.WebControls.Calender.</para>
    /// </devdoc>
    public enum CalendarSelectionMode {
        /// <include file='doc\CalendarSelectionMode.uex' path='docs/doc[@for="CalendarSelectionMode.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No
        ///       dates can be selectioned.
        ///    </para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\CalendarSelectionMode.uex' path='docs/doc[@for="CalendarSelectionMode.Day"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Dates
        ///       selected by individual days.
        ///    </para>
        /// </devdoc>
        Day = 1,
        /// <include file='doc\CalendarSelectionMode.uex' path='docs/doc[@for="CalendarSelectionMode.DayWeek"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Dates
        ///       selected by individual
        ///       days or entire weeks.
        ///    </para>
        /// </devdoc>
        DayWeek = 2,
        /// <include file='doc\CalendarSelectionMode.uex' path='docs/doc[@for="CalendarSelectionMode.DayWeekMonth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Dates
        ///       selected by individual days, entire
        ///       weeks, or entire months.
        ///    </para>
        /// </devdoc>
        DayWeekMonth = 3
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\columncollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColumnCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection"]/*' />
    /// <devdoc>
    ///    <para>Represents the collection of columns to be displayed in 
    ///       a <see cref='System.Web.UI.WebControls.DataGrid'/>
    ///       control.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DataGridColumnCollection : ICollection, IStateManager {

        private DataGrid owner;
        private ArrayList columns;
        private bool marked;

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.DataGridColumnCollection"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of <see cref='System.Web.UI.WebControls.DataGridColumnCollection'/> class.</para>
        /// </devdoc>
        public DataGridColumnCollection(DataGrid owner, ArrayList columns) {
            this.owner = owner;
            this.columns = columns;
        }
        
        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of columns in the collection. This property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false)
        ]
        public int Count {
            get {
                return columns.Count;
            }
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.IsReadOnly"]/*' />
        /// <devdoc>
        /// <para>Gets a value that specifies whether items in the <see cref='System.Web.UI.WebControls.DataGridColumnCollection'/> can be 
        ///    modified. This property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false)
        ]
        public bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.IsSynchronized"]/*' />
        /// <devdoc>
        /// <para>Gets a value that indicates whether the <see cref='System.Web.UI.WebControls.DataGridColumnCollection'/> is thread-safe. This property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false)
        ]
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>Gets the object used to synchronize access to the collection. This property is read-only. </para>
        /// </devdoc>
        [
        Browsable(false)
        ]
        public Object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.this"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='System.Web.UI.WebControls.DataGridColumn'/> at the specified index in the 
        ///    collection.</para>
        /// </devdoc>
        [
        Browsable(false)
        ]
        public DataGridColumn this[int index] {
            get {
                return (DataGridColumn)columns[index];
            }
        }


        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.Add"]/*' />
        /// <devdoc>
        /// <para>Appends a <see cref='System.Web.UI.WebControls.DataGridColumn'/> to the collection.</para>
        /// </devdoc>
        public void Add(DataGridColumn column) {
            AddAt(-1, column);
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.AddAt"]/*' />
        /// <devdoc>
        /// <para>Inserts a <see cref='System.Web.UI.WebControls.DataGridColumn'/> to the collection 
        ///    at the specified index.</para>
        /// </devdoc>
        public void AddAt(int index, DataGridColumn column) {
            if (index == -1) {
                columns.Add(column);
            }
            else {
                columns.Insert(index, column);
            }
            column.SetOwner(owner);
            if (marked)
                ((IStateManager)column).TrackViewState();
            OnColumnsChanged();
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.Clear"]/*' />
        /// <devdoc>
        /// <para>Empties the collection of all <see cref='System.Web.UI.WebControls.DataGridColumn'/> objects.</para>
        /// </devdoc>
        public void Clear() {
            columns.Clear();
            OnColumnsChanged();
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the contents of the entire collection into an <see cref='System.Array' qualify='true'/> appending at 
        ///    the specified index of the <see cref='System.Array' qualify='true'/>.</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.GetEnumerator"]/*' />
        /// <devdoc>
        /// <para>Creates an enumerator for the <see cref='System.Web.UI.WebControls.DataGridColumnCollection'/> used to iterate through the collection.</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return columns.GetEnumerator();
        }


        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.IndexOf"]/*' />
        /// <devdoc>
        /// <para>Returns the index of the first occurrence of a value in a <see cref='System.Web.UI.WebControls.DataGridColumn'/>.</para>
        /// </devdoc>
        public int IndexOf(DataGridColumn column) {
            if (column != null) {
                return columns.IndexOf(column);
            }
            return -1;
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.OnColumnsChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnColumnsChanged() {
            if (owner != null) {
                owner.OnColumnsChanged();
            }
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.RemoveAt"]/*' />
        /// <devdoc>
        /// <para>Removes a <see cref='System.Web.UI.WebControls.DataGridColumn'/> from the collection at the specified 
        ///    index.</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            if ((index >= 0) && (index < Count)) {
                columns.RemoveAt(index);
                OnColumnsChanged();
            }
            else {
                throw new ArgumentOutOfRangeException("index");
            }
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.Remove"]/*' />
        /// <devdoc>
        /// <para>Removes the specified <see cref='System.Web.UI.WebControls.DataGridColumn'/> from the collection.</para>
        /// </devdoc>
        public void Remove(DataGridColumn column) {
            int index = IndexOf(column);
            if (index >= 0) {
                RemoveAt(index);
            }
        }


        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.IStateManager.IsTrackingViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return true if tracking state changes.
        /// </devdoc>
        bool IStateManager.IsTrackingViewState {
            get {
                return marked;
            }
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.IStateManager.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Load previously saved state.
        /// </devdoc>
        void IStateManager.LoadViewState(object savedState) {
            if (savedState != null) {
                object[] columnsState = (object[])savedState;

                if (columnsState.Length == columns.Count) {
                    for (int i = 0; i < columnsState.Length; i++) {
                        if (columnsState[i] != null) {
                            ((IStateManager)columns[i]).LoadViewState(columnsState[i]);
                        }
                    }
                }
            }
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.IStateManager.TrackViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Start tracking state changes.
        /// </devdoc>
        void IStateManager.TrackViewState() {
            marked = true;

            int columnCount = columns.Count;
            for (int i = 0; i < columnCount; i++) {
                ((IStateManager)columns[i]).TrackViewState();
            }
        }

        /// <include file='doc\ColumnCollection.uex' path='docs/doc[@for="DataGridColumnCollection.IStateManager.SaveViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return object containing state changes.
        /// </devdoc>
        object IStateManager.SaveViewState() {
            int columnCount = columns.Count;
            object[] columnsState = new object[columnCount];
            bool savedState = false;

            for (int i = 0; i < columnCount; i++) {
                columnsState[i] = ((IStateManager)columns[i]).SaveViewState();
                if (columnsState[i] != null)
                    savedState = true;
            }

            return savedState ? columnsState : null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\commandeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="CommandEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;
    using System.Security.Permissions;

    /// <include file='doc\CommandEventArgs.uex' path='docs/doc[@for="CommandEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see langword='Command'/> event.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class CommandEventArgs : EventArgs {

        private string commandName;
        private object argument;

        /// <include file='doc\CommandEventArgs.uex' path='docs/doc[@for="CommandEventArgs.CommandEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.CommandEventArgs'/> class with another <see cref='System.Web.UI.WebControls.CommandEventArgs'/>.</para>
        /// </devdoc>
        public CommandEventArgs(CommandEventArgs e) : this(e.CommandName, e.CommandArgument) {
        }

        /// <include file='doc\CommandEventArgs.uex' path='docs/doc[@for="CommandEventArgs.CommandEventArgs1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.CommandEventArgs'/> class with the specified command name 
        ///    and argument.</para>
        /// </devdoc>
        public CommandEventArgs(string commandName, object argument) {
            this.commandName = commandName;
            this.argument = argument;
        }


        /// <include file='doc\CommandEventArgs.uex' path='docs/doc[@for="CommandEventArgs.CommandName"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the command. This property is read-only.</para>
        /// </devdoc>
        public string CommandName {
            get {
                return commandName;
            }
        }

        /// <include file='doc\CommandEventArgs.uex' path='docs/doc[@for="CommandEventArgs.CommandArgument"]/*' />
        /// <devdoc>
        ///    <para>Gets the argument for the command. This property is read-only.</para>
        /// </devdoc>
        public object CommandArgument {
            get {
                return argument;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\calendar.cs ===
//------------------------------------------------------------------------------
// <copyright file="Calendar.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {
    using System.Threading;
    using System.Globalization;
    using System.ComponentModel;   
    using System;
    using System.Web;
    using System.Web.UI;
    using System.Collections;
    using System.Diagnostics;    
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Text;

    using System.IO;
    using System.Reflection;
    using System.Security.Permissions;


    /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar"]/*' />
    /// <devdoc>
    ///    <para>Displays a one-month calendar and allows the user to
    ///       view and select a specific day, week, or month.</para>
    /// </devdoc>
    [
    DataBindingHandler("System.Web.UI.Design.WebControls.CalendarDataBindingHandler, " + AssemblyRef.SystemDesign),
    DefaultEvent("SelectionChanged"),
    DefaultProperty("SelectedDate"),
    Designer("System.Web.UI.Design.WebControls.CalendarDesigner, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Calendar : WebControl, IPostBackEventHandler {

        private static readonly object EventDayRender = new object();
        private static readonly object EventSelectionChanged = new object();
        private static readonly object EventVisibleMonthChanged = new object();

        private TableItemStyle titleStyle;
        private TableItemStyle nextPrevStyle;
        private TableItemStyle dayHeaderStyle;
        private TableItemStyle selectorStyle;
        private TableItemStyle dayStyle;
        private TableItemStyle otherMonthDayStyle;
        private TableItemStyle todayDayStyle;
        private TableItemStyle selectedDayStyle;
        private TableItemStyle weekendDayStyle;
        private string defaultButtonColorText;

        private ArrayList dateList;
        private SelectedDatesCollection selectedDates;
        private Globalization.Calendar threadCalendar;

        private const string SELECT_RANGE_COMMAND = "R";
        private const string NAVIGATE_MONTH_COMMAND = "V";

        private static DateTime baseDate = new DateTime(2000, 1, 1);

        private const int STYLEMASK_DAY = 16;
        private const int STYLEMASK_UNIQUE = 15;
        private const int STYLEMASK_SELECTED = 8;
        private const int STYLEMASK_TODAY = 4;
        private const int STYLEMASK_OTHERMONTH = 2;
        private const int STYLEMASK_WEEKEND = 1;
        private const string ROWBEGINTAG = "<tr>";
        private const string ROWENDTAG = "</tr>";

        // Cache commonly used strings. This improves performance and memory usage.
        private const int cachedNumberMax = 31;
        private static readonly string[] cachedNumbers = new string [] {
                  "0",  "1",   "2",   "3",   "4",   "5",   "6", 
                  "7",  "8",   "9",  "10",  "11",  "12",  "13", 
                 "14", "15",  "16",  "17",  "18",  "19",  "20", 
                 "21", "22",  "23",  "24",  "25",  "26",  "27", 
                 "28", "29",  "30",  "31",
        };

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.Calendar"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.Calendar'/> class.</para>
        /// </devdoc>
        public Calendar() {
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.CellPadding"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the amount of space between cells.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(2),
        WebSysDescription(SR.Calendar_CellPadding)
        ]
        public int CellPadding {
            get {
                object o = ViewState["CellPadding"]; 
                return((o == null) ? 2 : (int)o);
            }
            set {
                if (value < - 1 ) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["CellPadding"] = value;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.CellSpacing"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the amount of space between the contents of a cell
        ///       and the cell's border.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(0),
        WebSysDescription(SR.Calendar_CellSpacing)
        ]
        public int CellSpacing {
            get {
                object o = ViewState["CellSpacing"]; 
                return((o == null) ?  0 : (int)o);
            }
            set {
                if (value < -1 ) {
                    throw new ArgumentOutOfRangeException("value");                    
                }
                ViewState["CellSpacing"] = (int)value;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.DayHeaderStyle"]/*' />
        /// <devdoc>
        ///    <para> Gets the style property of the day-of-the-week header. This property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        WebSysDescription(SR.Calendar_DayHeaderStyle),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty)
        ]
        public TableItemStyle DayHeaderStyle {
            get {
                if (dayHeaderStyle == null) {
                    dayHeaderStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)dayHeaderStyle).TrackViewState();
                }
                return dayHeaderStyle;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.DayNameFormat"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       the format for the names of days.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(DayNameFormat.Short),
        WebSysDescription(SR.Calendar_DayNameFormat)
        ]
        public DayNameFormat DayNameFormat {
            get {
                object dnf = ViewState["DayNameFormat"];
                return((dnf == null) ? DayNameFormat.Short : (DayNameFormat)dnf);
            }
            set {
                if (value < DayNameFormat.Full || value > DayNameFormat.FirstTwoLetters) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["DayNameFormat"] = value;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.DayStyle"]/*' />
        /// <devdoc>
        ///    <para> Gets the style properties for the days. This property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        WebSysDescription(SR.Calendar_DayStyle),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty)
        ]
        public TableItemStyle DayStyle {
            get {
                if (dayStyle == null) {
                    dayStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)dayStyle).TrackViewState();
                }
                return dayStyle;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.FirstDayOfWeek"]/*' />
        /// <devdoc>
        ///    <para> Gets
        ///       or sets the day of the week to display in the calendar's first
        ///       column.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(FirstDayOfWeek.Default),
        WebSysDescription(SR.Calendar_FirstDayOfWeek)
        ]
        public FirstDayOfWeek FirstDayOfWeek {
            get {               
                object o = ViewState["FirstDayOfWeek"];
                return((o == null) ? FirstDayOfWeek.Default : (FirstDayOfWeek)o);
            }
            set {
                if (value < FirstDayOfWeek.Sunday || value > FirstDayOfWeek.Default) {
                    throw new ArgumentOutOfRangeException("value");
                }

                ViewState["FirstDayOfWeek"] = value;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.NextMonthText"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the text shown for the next month 
        ///       navigation hyperlink if the <see cref='System.Web.UI.WebControls.Calendar.ShowNextPrevMonth'/> property is set to
        ///    <see langword='true'/>.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue("&gt;"),
        WebSysDescription(SR.Calendar_NextMonthText)
        ]
        public string NextMonthText {
            get {
                object s = ViewState["NextMonthText"];
                return((s == null) ? "&gt;" : (String) s);
            }
            set {
                ViewState["NextMonthText"] = value;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.NextPrevFormat"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the format of the next and previous month hyperlinks in the
        ///       title.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(NextPrevFormat.CustomText),
        WebSysDescription(SR.Calendar_NextPrevFormat)
        ]
        public NextPrevFormat NextPrevFormat {
            get {
                object npf = ViewState["NextPrevFormat"];
                return((npf == null) ? NextPrevFormat.CustomText : (NextPrevFormat)npf);
            }
            set {
                if (value < NextPrevFormat.CustomText || value > NextPrevFormat.FullMonth) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["NextPrevFormat"] = value;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.NextPrevStyle"]/*' />
        /// <devdoc>
        ///    <para> Gets the style properties for the next/previous month navigators. This property is
        ///       read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        WebSysDescription(SR.Calendar_NextPrevStyle),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty)
        ]
        public TableItemStyle NextPrevStyle {
            get {
                if (nextPrevStyle == null) {
                    nextPrevStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)nextPrevStyle).TrackViewState();
                }
                return nextPrevStyle;
            }
        }


        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.OtherMonthDayStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties for the days from the months preceding and following the current month.
        ///       This property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        WebSysDescription(SR.Calendar_OtherMonthDayStyle),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty)
        ]
        public TableItemStyle OtherMonthDayStyle {
            get {
                if (otherMonthDayStyle == null) {
                    otherMonthDayStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)otherMonthDayStyle).TrackViewState();

                }
                return otherMonthDayStyle;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.PrevMonthText"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the text shown for the previous month 
        ///       navigation hyperlink if the <see cref='System.Web.UI.WebControls.Calendar.ShowNextPrevMonth'/> property is set to
        ///    <see langword='true'/>
        ///    .</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue("&lt;"),
        WebSysDescription(SR.Calendar_PrevMonthText)
        ]
        public string PrevMonthText {
            get {
                object s = ViewState["PrevMonthText"];
                return((s == null) ? "&lt;" : (String) s);
            }
            set {
                ViewState["PrevMonthText"] = value;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.SelectedDate"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the date that is currently selected
        ///       date.</para>
        /// </devdoc>
        [
        Bindable(true),
        DefaultValue(typeof(DateTime), "1/1/0001"),
        WebSysDescription(SR.Calendar_SelectedDate)
        ]
        public DateTime SelectedDate {
            get {
                if (SelectedDates.Count == 0) {
                    return DateTime.MinValue;
                }
                return SelectedDates[0];
            }
            set {
                if (value == DateTime.MinValue) {
                    SelectedDates.Clear();
                }
                else {
                    SelectedDates.SelectRange(value, value);
                }
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.SelectedDates"]/*' />
        /// <devdoc>
        /// <para>Gets a collection of <see cref='System.DateTime' qualify='true'/> objects representing days selected on the <see cref='System.Web.UI.WebControls.Calendar'/>. This 
        ///    property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false),
        WebSysDescription(SR.Calendar_SelectedDates),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]   
        public SelectedDatesCollection SelectedDates {
            get {
                if (selectedDates == null) {
                    if (dateList == null) {
                        dateList = new ArrayList();
                    }
                    selectedDates = new SelectedDatesCollection(dateList);
                }
                return selectedDates;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.SelectedDayStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties for the selected date. This property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        WebSysDescription(SR.Calendar_SelectedDayStyle),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty)
        ]
        public TableItemStyle SelectedDayStyle {
            get {
                if (selectedDayStyle == null) {
                    selectedDayStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)selectedDayStyle).TrackViewState();
                }
                return selectedDayStyle;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.SelectionMode"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the date selection capabilities on the
        ///    <see cref='System.Web.UI.WebControls.Calendar'/>
        ///    to allow the user to select a day, week, or month.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(CalendarSelectionMode.Day),
        WebSysDescription(SR.Calendar_SelectionMode)
        ]
        public CalendarSelectionMode SelectionMode {
            get {
                object csm = ViewState["SelectionMode"];
                return((csm == null) ? CalendarSelectionMode.Day : (CalendarSelectionMode)csm);
            }
            set {
                if (value < CalendarSelectionMode.None || value > CalendarSelectionMode.DayWeekMonth) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["SelectionMode"] = value; 
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.SelectMonthText"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the text shown for the month selection in 
        ///       the selector column if <see cref='System.Web.UI.WebControls.Calendar.SelectionMode'/> is
        ///    <see langword='CalendarSelectionMode.DayWeekMonth'/>.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue("&gt;&gt;"),
        WebSysDescription(SR.Calendar_SelectMonthText)
        ]
        public string SelectMonthText {
            get {
                object s = ViewState["SelectMonthText"];
                return((s == null) ? "&gt;&gt;" : (String) s);
            }
            set {
                ViewState["SelectMonthText"] = value;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.SelectorStyle"]/*' />
        /// <devdoc>
        ///    <para> Gets the style properties for the week and month selectors. This property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        WebSysDescription(SR.Calendar_SelectorStyle),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty)
        ]
        public TableItemStyle SelectorStyle {
            get {
                if (selectorStyle == null) {
                    selectorStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)selectorStyle).TrackViewState();
                }
                return selectorStyle;
            }
        }
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.SelectWeekText"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the text shown for the week selection in 
        ///       the selector column if <see cref='System.Web.UI.WebControls.Calendar.SelectionMode'/> is
        ///    <see langword='CalendarSelectionMode.DayWeek '/>or 
        ///    <see langword='CalendarSelectionMode.DayWeekMonth'/>.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue("&gt;"),
        WebSysDescription(SR.Calendar_SelectWeekText)
        ]
        public string SelectWeekText {
            get {
                object s = ViewState["SelectWeekText"];
                return((s == null) ? "&gt;" : (String) s);
            }
            set {
                ViewState["SelectWeekText"] = value;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.ShowDayHeader"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       a value indicating whether the days of the week are displayed.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(true),
        WebSysDescription(SR.Calendar_ShowDayHeader)
        ]
        public bool ShowDayHeader {
            get {
                object b = ViewState["ShowDayHeader"];
                return((b == null) ? true : (bool)b);
            }
            set {
                ViewState["ShowDayHeader"] = value;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.ShowGridLines"]/*' />
        /// <devdoc>
        ///    <para>Gets or set
        ///       a value indicating whether days on the calendar are displayed with a border.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(false),
        WebSysDescription(SR.Calendar_ShowGridLines)
        ]
        public bool ShowGridLines {
            get {
                object b= ViewState["ShowGridLines"];
                return((b == null) ? false : (bool)b);
            }
            set {
                ViewState["ShowGridLines"] = value; 
            }
        } 

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.ShowNextPrevMonth"]/*' />
        /// <devdoc>
        /// <para>Gets or sets a value indicating whether the <see cref='System.Web.UI.WebControls.Calendar'/> 
        /// displays the next and pervious month
        /// hyperlinks in the title.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(true),
        WebSysDescription(SR.Calendar_ShowNextPrevMonth)
        ]
        public bool ShowNextPrevMonth {
            get {
                object b = ViewState["ShowNextPrevMonth"];
                return((b == null) ? true : (bool)b);
            }
            set {
                ViewState["ShowNextPrevMonth"] = value;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.ShowTitle"]/*' />
        /// <devdoc>
        ///    <para> Gets or
        ///       sets a value indicating whether the title is displayed.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(true),
        WebSysDescription(SR.Calendar_ShowTitle)
        ]
        public bool ShowTitle {
            get {
                object b = ViewState["ShowTitle"];
                return((b == null) ? true : (bool)b);
            }
            set {
                ViewState["ShowTitle"] = value;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.TitleFormat"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets how the month name is formatted in the title
        ///       bar.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(TitleFormat.MonthYear),
        WebSysDescription(SR.Calendar_TitleFormat)
        ]   
        public TitleFormat TitleFormat {
            get {
                object tf = ViewState["TitleFormat"];
                return((tf == null) ? TitleFormat.MonthYear : (TitleFormat)tf);
            }
            set {
                if (value < TitleFormat.Month || value > TitleFormat.MonthYear) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["TitleFormat"] = value;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.TitleStyle"]/*' />
        /// <devdoc>
        /// <para>Gets the style properties of the <see cref='System.Web.UI.WebControls.Calendar'/> title. This property is 
        ///    read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        WebSysDescription(SR.Calendar_TitleStyle),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        ]
        public TableItemStyle TitleStyle {
            get {
                if (titleStyle == null) {
                    titleStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)titleStyle).TrackViewState();
                }
                return titleStyle;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.TodayDayStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties for today's date on the 
        ///    <see cref='System.Web.UI.WebControls.Calendar'/>. This 
        ///       property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        WebSysDescription(SR.Calendar_TodayDayStyle),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty)
        ]
        public TableItemStyle TodayDayStyle {
            get {
                if (todayDayStyle == null) {
                    todayDayStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)todayDayStyle).TrackViewState();
                }
                return todayDayStyle;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.TodaysDate"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the value to use as today's date.</para>
        /// </devdoc>
        [
        Bindable(true),
        Browsable(false),
        WebSysDescription(SR.Calendar_TodaysDate),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public DateTime TodaysDate {
            get {
                object o = ViewState["TodaysDate"]; 
                return((o == null) ? DateTime.Today : (DateTime)o);
            }
            set {
                ViewState["TodaysDate"] = value.Date;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.VisibleDate"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the date that specifies what month to display. The date can be
        ///       be any date within the month.</para>
        /// </devdoc>
        [
        Bindable(true),
        DefaultValue(typeof(DateTime), "1/1/0001"),
        WebSysDescription(SR.Calendar_VisibleDate)
        ]
        public DateTime VisibleDate {
            get {
                object o = ViewState["VisibleDate"]; 
                return((o == null) ? DateTime.MinValue : (DateTime)o);
            }
            set {
                ViewState["VisibleDate"] = value.Date;
            }
        } 

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.WeekendDayStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties for the displaying weekend dates. This property is
        ///       read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        WebSysDescription(SR.Calendar_WeekendDayStyle),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty)
        ]
        public TableItemStyle WeekendDayStyle {
            get {
                if (weekendDayStyle == null) {
                    weekendDayStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)weekendDayStyle).TrackViewState();
                }
                return weekendDayStyle;
            }
        }        



        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.DayRender"]/*' />
        /// <devdoc>
        /// <para>Occurs when each day is created in teh control hierarchy for the <see cref='System.Web.UI.WebControls.Calendar'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.Calendar_OnDayRender)
        ]
        public event DayRenderEventHandler DayRender {
            add {
                Events.AddHandler(EventDayRender, value);
            }
            remove {
                Events.RemoveHandler(EventDayRender, value);
            }
        }



        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.SelectionChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the user clicks on a day, week, or month 
        ///       selector and changes the <see cref='System.Web.UI.WebControls.Calendar.SelectedDate'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.Calendar_OnSelectionChanged)
        ]
        public event EventHandler SelectionChanged {
            add {
                Events.AddHandler(EventSelectionChanged, value);
            }
            remove {
                Events.RemoveHandler(EventSelectionChanged, value);
            }
        }


        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.VisibleMonthChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the
        ///       user clicks on the next or previous month <see cref='System.Web.UI.WebControls.Button'/> controls on the title.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.Calendar_OnVisibleMonthChanged)
        ]
        public event MonthChangedEventHandler VisibleMonthChanged {
            add {
                Events.AddHandler(EventVisibleMonthChanged, value);
            }
            remove {
                Events.RemoveHandler(EventVisibleMonthChanged, value);
            }
        }

        // Methods

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.ApplyTitleStyle"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void ApplyTitleStyle(TableCell titleCell, Table titleTable, TableItemStyle titleStyle) {
            // apply affects that affect the whole background to the cell
            if (titleStyle.BackColor != Color.Empty) {
                titleCell.BackColor = titleStyle.BackColor;
            }
            if (titleStyle.BorderColor != Color.Empty) {
                titleCell.BorderColor = titleStyle.BorderColor;
            }
            if (titleStyle.BorderWidth != Unit.Empty) {
                titleCell.BorderWidth= titleStyle.BorderWidth;
            }
            if (titleStyle.BorderStyle != BorderStyle.NotSet) {
                titleCell.BorderStyle = titleStyle.BorderStyle;
            }
            if (titleStyle.Height != Unit.Empty) {
                titleCell.Height = titleStyle.Height;
            }
            if (titleStyle.VerticalAlign != VerticalAlign.NotSet) {
                titleCell.VerticalAlign = titleStyle.VerticalAlign;
            }

            // apply affects that affect everything else to the table
            if (titleStyle.CssClass != String.Empty) {
                titleTable.CssClass = titleStyle.CssClass;
            }
            else if (CssClass != String.Empty) {
                titleTable.CssClass = CssClass;
            }
            
            if (titleStyle.ForeColor != Color.Empty) {
                titleTable.ForeColor = titleStyle.ForeColor;
            }
            else if (ForeColor != Color.Empty) {
                titleTable.ForeColor = ForeColor;
            }
            titleTable.Font.CopyFrom(titleStyle.Font);
            titleTable.Font.MergeWith(this.Font);

        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.CreateControlCollection"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override ControlCollection CreateControlCollection() {
            return new EmptyControlCollection(this);
        }


        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.EffectiveVisibleDate"]/*' />
        /// <devdoc>
        /// </devdoc>
        private DateTime EffectiveVisibleDate() {
            DateTime visDate = VisibleDate;
            if (visDate.Equals(DateTime.MinValue)) {
                visDate = TodaysDate;
            }
            return threadCalendar.AddDays(visDate, -(threadCalendar.GetDayOfMonth(visDate) - 1));
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.FirstCalendarDay"]/*' />
        /// <devdoc>
        /// </devdoc>
        private DateTime FirstCalendarDay(DateTime visibleDate) {
            DateTime firstDayOfMonth = visibleDate;
            int daysFromLastMonth = ((int)threadCalendar.GetDayOfWeek(firstDayOfMonth)) - NumericFirstDayOfWeek();
            // Always display at least one day from the previous month
            if (daysFromLastMonth <= 0) {
                daysFromLastMonth += 7;
            }
            return threadCalendar.AddDays(firstDayOfMonth, -daysFromLastMonth);
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetCalendarButtonText"]/*' />
        /// <devdoc>
        /// </devdoc>
        private string GetCalendarButtonText(string eventArgument, string buttonText, bool showLink, Color foreColor) {
            if (showLink) {
                StringBuilder sb = new StringBuilder();
                sb.Append("<a href=\"");
                sb.Append(Page.GetPostBackClientHyperlink(this, eventArgument));

                // ForeColor needs to go on the actual link. This breaks the uplevel/downlevel rules a little bit,
                // but it is worth doing so the day links do not change color when they go in the history on 
                // downlevel browsers. Otherwise, people get it confused with the selection mechanism.
                sb.Append("\" style=\"color:");
                sb.Append(foreColor.IsEmpty ? defaultButtonColorText : ColorTranslator.ToHtml(foreColor));
                sb.Append("\">");
                sb.Append(buttonText);
                sb.Append("</a>");
                return sb.ToString();
            }
            else {
                return buttonText;
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetDefinedStyleMask"]/*' />
        /// <devdoc>
        /// </devdoc>
        private int GetDefinedStyleMask() {

            // Selected is always defined because it has default effects
            int styleMask = STYLEMASK_SELECTED;

            if (dayStyle != null && !dayStyle.IsEmpty)
                styleMask |= STYLEMASK_DAY;
            if (todayDayStyle != null && !todayDayStyle.IsEmpty)
                styleMask |= STYLEMASK_TODAY;
            if (otherMonthDayStyle != null && !otherMonthDayStyle.IsEmpty)
                styleMask |= STYLEMASK_OTHERMONTH;
            if (weekendDayStyle != null && !weekendDayStyle.IsEmpty)
                styleMask |= STYLEMASK_WEEKEND;
            return styleMask;
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetMonthName"]/*' />
        /// <devdoc>
        /// </devdoc>
        private string GetMonthName(int m, bool bFull) {
            if (bFull) {
                return DateTimeFormatInfo.CurrentInfo.GetMonthName(m);
            }
            else {
                return DateTimeFormatInfo.CurrentInfo.GetAbbreviatedMonthName(m);
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.HasWeekSelectors"]/*' />
        /// <devdoc>
        /// <para>Determines if a <see cref='System.Web.UI.WebControls.CalendarSelectionMode'/>
        /// contains week selectors.</para>
        /// </devdoc>
        protected bool HasWeekSelectors(CalendarSelectionMode selectionMode) {
            return(selectionMode == CalendarSelectionMode.DayWeek 
                   || selectionMode == CalendarSelectionMode.DayWeekMonth);   
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Loads a saved state of the <see cref='System.Web.UI.WebControls.Calendar'/>. </para>
        /// </devdoc>
        protected override void LoadViewState(object savedState) {
            if (savedState != null) {
                object[] myState = (object[])savedState;

                if (myState[0] != null)
                    base.LoadViewState(myState[0]);
                if (myState[1] != null)
                    ((IStateManager)TitleStyle).LoadViewState(myState[1]);
                if (myState[2] != null)
                    ((IStateManager)NextPrevStyle).LoadViewState(myState[2]);
                if (myState[3] != null)
                    ((IStateManager)DayStyle).LoadViewState(myState[3]);
                if (myState[4] != null)
                    ((IStateManager)DayHeaderStyle).LoadViewState(myState[4]);
                if (myState[5] != null)
                    ((IStateManager)TodayDayStyle).LoadViewState(myState[5]);
                if (myState[6] != null)
                    ((IStateManager)WeekendDayStyle).LoadViewState(myState[6]);
                if (myState[7] != null)
                    ((IStateManager)OtherMonthDayStyle).LoadViewState(myState[7]);
                if (myState[8] != null)
                    ((IStateManager)SelectedDayStyle).LoadViewState(myState[8]);
                if (myState[9] != null)
                    ((IStateManager)SelectorStyle).LoadViewState(myState[9]);

                ArrayList selDates = (ArrayList)ViewState["SD"];
                if (selDates != null) {
                    dateList = selDates;
                    selectedDates = null;   // reset wrapper collection
                }

            }
        }                

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.TrackViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Marks the starting point to begin tracking and saving changes to the 
        ///       control as part of the control viewstate.</para>
        /// </devdoc>
        protected override void TrackViewState() {
            base.TrackViewState();

            if (titleStyle != null)
                ((IStateManager)titleStyle).TrackViewState();
            if (nextPrevStyle != null)
                ((IStateManager)nextPrevStyle).TrackViewState();
            if (dayStyle != null)
                ((IStateManager)dayStyle).TrackViewState();
            if (dayHeaderStyle != null)
                ((IStateManager)dayHeaderStyle).TrackViewState();
            if (todayDayStyle != null)
                ((IStateManager)todayDayStyle).TrackViewState();
            if (weekendDayStyle != null)
                ((IStateManager)weekendDayStyle).TrackViewState();
            if (otherMonthDayStyle != null)
                ((IStateManager)otherMonthDayStyle).TrackViewState();
            if (selectedDayStyle != null)
                ((IStateManager)selectedDayStyle).TrackViewState();
            if (selectorStyle != null)
                ((IStateManager)selectorStyle).TrackViewState();
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.NumericFirstDayOfWeek"]/*' />
        /// <devdoc>
        /// </devdoc>
        private int NumericFirstDayOfWeek() {
            // Used globalized value by default
            return(FirstDayOfWeek == FirstDayOfWeek.Default) 
            ? (int) DateTimeFormatInfo.CurrentInfo.FirstDayOfWeek
            : (int) FirstDayOfWeek;
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.OnDayRender"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='DayRender '/>event for a <see cref='System.Web.UI.WebControls.Calendar'/>.</para>
        /// </devdoc>
        protected virtual void OnDayRender(TableCell cell, CalendarDay day) {
            DayRenderEventHandler handler = (DayRenderEventHandler)Events[EventDayRender];
            if (handler != null) {
                handler(this, new DayRenderEventArgs(cell, day));
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.OnSelectionChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='SelectionChanged '/>event for a <see cref='System.Web.UI.WebControls.Calendar'/>.</para>
        /// </devdoc>
        protected virtual void OnSelectionChanged() {
            EventHandler handler = (EventHandler)Events[EventSelectionChanged];
            if (handler != null) {
                handler(this, new EventArgs());
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.OnVisibleMonthChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='VisibleMonthChanged '/>event for a <see cref='System.Web.UI.WebControls.Calendar'/>.</para>
        /// </devdoc>
        protected virtual void OnVisibleMonthChanged(DateTime newDate, DateTime previousDate) {
            MonthChangedEventHandler handler = (MonthChangedEventHandler)Events[EventVisibleMonthChanged];
            if (handler != null) {
                handler(this, new MonthChangedEventArgs(newDate, previousDate));
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.IPostBackEventHandler.RaisePostBackEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Raises events on post back for the <see cref='System.Web.UI.WebControls.Calendar'/> control.</para>
        /// </devdoc>
        void IPostBackEventHandler.RaisePostBackEvent(string eventArgument) {

            if (String.Compare(eventArgument, 0, NAVIGATE_MONTH_COMMAND, 0, NAVIGATE_MONTH_COMMAND.Length, false, CultureInfo.InvariantCulture) == 0) {
                // Month navigation. The command starts with a "V" and the remainder is day difference from the
                // base date.
                DateTime oldDate = VisibleDate;
                if (oldDate.Equals(DateTime.MinValue)) {
                    oldDate = TodaysDate;
                }
                int newDateDiff = Int32.Parse(eventArgument.Substring(NAVIGATE_MONTH_COMMAND.Length));
                VisibleDate = baseDate.AddDays(newDateDiff);
                OnVisibleMonthChanged(VisibleDate, oldDate);
            }
            else if (String.Compare(eventArgument, 0, SELECT_RANGE_COMMAND, 0, SELECT_RANGE_COMMAND.Length, false, CultureInfo.InvariantCulture) == 0) {
                // Range selection. The command starts with an "R". The remainder is an integer. When divided by 100
                // the result is the day difference from the base date of the first day, and the remainder is the
                // number of days to select.
                int rangeValue = Int32.Parse(eventArgument.Substring(SELECT_RANGE_COMMAND.Length));
                int dayDiff = rangeValue / 100;
                int dayRange = rangeValue % 100;
                if (dayRange < 1) {
                    dayRange = 100 + dayRange;
                    dayDiff -= 1;
                }
                DateTime dt = baseDate.AddDays(dayDiff);
                SelectRange(dt, dt.AddDays(dayRange - 1));
            }
            else {
                // Single day selection. This is just a number which is the day difference from the base date.
                int dayDiff = Int32.Parse(eventArgument);
                DateTime dt = baseDate.AddDays(dayDiff);
                SelectRange(dt, dt);
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.OnPreRender"]/*' />
        /// <internalonly/>
        protected override void OnPreRender(EventArgs e) {
            base.OnPreRender(e);
            if (Page != null) {
                Page.RegisterPostBackScript();
            }
        }
        
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.Render"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Displays the <see cref='System.Web.UI.WebControls.Calendar'/> control on the client.</para>
        /// </devdoc>
        protected override void Render(HtmlTextWriter writer) {
            threadCalendar = DateTimeFormatInfo.CurrentInfo.Calendar;
            DateTime visibleDate = EffectiveVisibleDate();
            DateTime firstDay = FirstCalendarDay(visibleDate);
            CalendarSelectionMode selectionMode = SelectionMode;

            // Make sure we are in a form tag with runat=server.
            if (Page != null) {
                Page.VerifyRenderingInServerForm(this);
            }

            // We only want to display the link if we have a page, or if we are on the design surface
            // If we can stops links being active on the Autoformat dialog, then we can remove this these checks.
            Page page = Page;
            bool buttonsActive;
            if (page == null || (Site != null && Site.DesignMode)) {
                buttonsActive = false;
            } 
            else {
                buttonsActive = Enabled;
            }

            Color defaultColor = ForeColor;
            if (defaultColor == Color.Empty) {
                defaultColor = Color.Black;
            }
            defaultButtonColorText = ColorTranslator.ToHtml(defaultColor);

            Table table = new Table();

            table.ID = ID;
            table.CopyBaseAttributes(this);
            if (ControlStyleCreated) {
                table.ApplyStyle(ControlStyle);
            }
            table.Width = Width;
            table.Height = Height;
            table.CellPadding = CellPadding;
            table.CellSpacing = CellSpacing;     

            // default look
            if ((ControlStyleCreated == false) ||
                (ControlStyle.IsSet(System.Web.UI.WebControls.Style.PROP_BORDERWIDTH) == false) ||
                BorderWidth.Equals(Unit.Empty)) {
                table.BorderWidth = Unit.Pixel(1);
            }

            if (ShowGridLines) {
                table.GridLines = GridLines.Both;
            }
            else {
                table.GridLines = GridLines.None;
            }

            table.RenderBeginTag(writer);

            if (ShowTitle) {
                RenderTitle(writer, visibleDate, selectionMode, buttonsActive);
            }

            if (ShowDayHeader) {
                RenderDayHeader(writer, firstDay, visibleDate, selectionMode, buttonsActive);
            }

            RenderDays(writer, firstDay, visibleDate, selectionMode, buttonsActive);

            table.RenderEndTag(writer);            
        }        

        private void RenderCalendarCell(HtmlTextWriter writer, TableItemStyle style, string text, bool hasButton, string eventArgument) {
            style.AddAttributesToRender(writer, this);
            writer.RenderBeginTag(HtmlTextWriterTag.Td);
    
            if (hasButton) {

                // render the button
                Color foreColor = style.ForeColor;
                writer.Write("<a href=\"");
                writer.Write(Page.GetPostBackClientHyperlink(this, eventArgument));

                // ForeColor needs to go on the actual link. This breaks the uplevel/downlevel rules a little bit,
                // but it is worth doing so the day links do not change color when they go in the history on 
                // downlevel browsers. Otherwise, people get it confused with the selection mechanism.
                writer.Write("\" style=\"color:");
                writer.Write(foreColor.IsEmpty ? defaultButtonColorText : ColorTranslator.ToHtml(foreColor));
                writer.Write("\">");
                writer.Write(text);
                writer.Write("</a>");
            }
            else {
                writer.Write(text);
            }

            writer.RenderEndTag();
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.RenderDayHeader"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void RenderDayHeader(HtmlTextWriter writer, DateTime firstDay, DateTime visibleDate, CalendarSelectionMode selectionMode, bool buttonsActive) {

            writer.Write(ROWBEGINTAG);

            DateTimeFormatInfo dtf = DateTimeFormatInfo.CurrentInfo;

            if (HasWeekSelectors(selectionMode)) {
                TableItemStyle monthSelectorStyle = new TableItemStyle();
                monthSelectorStyle.HorizontalAlign = HorizontalAlign.Center;
                // add the month selector button if required;
                if (selectionMode == CalendarSelectionMode.DayWeekMonth) {

                    // Range selection. The command starts with an "R". The remainder is an integer. When divided by 100
                    // the result is the day difference from the base date of the first day, and the remainder is the
                    // number of days to select.
                    int startOffset = visibleDate.Subtract(baseDate).Days;
                    int monthLength = threadCalendar.GetDaysInMonth(threadCalendar.GetYear(visibleDate), threadCalendar.GetMonth(visibleDate));
                    string monthSelectKey = SELECT_RANGE_COMMAND + ((startOffset * 100) + monthLength).ToString(CultureInfo.InvariantCulture);

                    monthSelectorStyle.CopyFrom(SelectorStyle);
                    RenderCalendarCell(writer, monthSelectorStyle, SelectMonthText, buttonsActive, monthSelectKey);
                }
                else {
                    // otherwise make it look like the header row
                    monthSelectorStyle.CopyFrom(DayHeaderStyle);
                    RenderCalendarCell(writer, monthSelectorStyle, string.Empty, false, null);
                }
            }

            TableItemStyle dayNameStyle = new TableItemStyle();
            dayNameStyle.HorizontalAlign = HorizontalAlign.Center;
            dayNameStyle.CopyFrom(DayHeaderStyle);
            DayNameFormat dayNameFormat = DayNameFormat;

            int numericFirstDay = (int)threadCalendar.GetDayOfWeek(firstDay);
            for (int i = numericFirstDay; i < numericFirstDay + 7; i++) {
                string dayName;
                int dayOfWeek = i % 7;
                switch (dayNameFormat) {
                    case DayNameFormat.FirstLetter:
                        dayName = dtf.GetDayName((DayOfWeek)dayOfWeek).Substring(0, 1);
                        break;
                    case DayNameFormat.FirstTwoLetters:
                        dayName = dtf.GetDayName((DayOfWeek)dayOfWeek).Substring(0, 2);    
                        break;
                    case DayNameFormat.Full:
                        dayName = dtf.GetDayName((DayOfWeek)dayOfWeek);    
                        break;
                    case DayNameFormat.Short:
                        dayName = dtf.GetAbbreviatedDayName((DayOfWeek)dayOfWeek);    
                        break;
                    default:
                        Debug.Assert(false, "Unknown DayNameFormat value!");
                        goto
                    case DayNameFormat.Short;
                }
                RenderCalendarCell(writer, dayNameStyle, dayName, false, null);
            }
            writer.Write(ROWENDTAG);
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.RenderDays"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void RenderDays(HtmlTextWriter writer, DateTime firstDay, DateTime visibleDate, CalendarSelectionMode selectionMode, bool buttonsActive) {
            // Now add the rows for the actual days

            DateTime d = firstDay;
            TableItemStyle weekSelectorStyle = null;
            Unit defaultWidth;
            bool hasWeekSelectors = HasWeekSelectors(selectionMode);
            if (hasWeekSelectors) {
                weekSelectorStyle = new TableItemStyle();
                weekSelectorStyle.Width = Unit.Percentage(12);
                weekSelectorStyle.HorizontalAlign = HorizontalAlign.Center;
                weekSelectorStyle.CopyFrom(SelectorStyle);
                defaultWidth = Unit.Percentage(12);
            }
            else {
                defaultWidth = Unit.Percentage(14);
            }

            // This determines whether we need to call DateTime.ToString for each day. The only culture/calendar
            // that requires this for now is the HebrewCalendar.
            bool usesStandardDayDigits = !(threadCalendar is HebrewCalendar);

            // This determines whether we can write out cells directly, or whether we have to create whole
            // TableCell objects for each day.
            bool hasRenderEvent = (this.GetType() != typeof(Calendar) 
                                   || Events[EventDayRender] != null);
            
            TableItemStyle [] cellStyles = new TableItemStyle[16];
            int definedStyleMask = GetDefinedStyleMask();
            DateTime todaysDate = TodaysDate;
            string selectWeekText = SelectWeekText;
            bool daysSelectable = buttonsActive && (selectionMode != CalendarSelectionMode.None);
            int visibleDateMonth = threadCalendar.GetMonth(visibleDate);
            int absoluteDay = firstDay.Subtract(baseDate).Days;

            for (int iRow = 0; iRow < 6; iRow++) {
                writer.Write(ROWBEGINTAG);

                // add week selector column and button if required
                if (hasWeekSelectors) {
                    // Range selection. The command starts with an "R". The remainder is an integer. When divided by 100
                    // the result is the day difference from the base date of the first day, and the remainder is the
                    // number of days to select.
                    string weekSelectKey = SELECT_RANGE_COMMAND + ((absoluteDay * 100) + 7).ToString(CultureInfo.InvariantCulture);
                    RenderCalendarCell(writer, weekSelectorStyle, selectWeekText, buttonsActive, weekSelectKey);
                }

                for (int iDay = 0; iDay < 7; iDay++) {

                    int dayOfWeek = (int)threadCalendar.GetDayOfWeek(d);
                    int dayOfMonth = threadCalendar.GetDayOfMonth(d);
                    string dayNumberText;
                    if ((dayOfMonth <= cachedNumberMax) && usesStandardDayDigits) {
                        dayNumberText = cachedNumbers[dayOfMonth];
                    }
                    else {
                        dayNumberText = d.ToString("dd");
                    }

                    CalendarDay day = new CalendarDay(d, 
                                                      (dayOfWeek == 0 || dayOfWeek == 6), // IsWeekend
                                                      d.Equals(todaysDate), // IsToday
                                                      (selectedDates != null) && selectedDates.Contains(d), // IsSelected
                                                      threadCalendar.GetMonth(d) != visibleDateMonth, // IsOtherMonth
                                                      dayNumberText // Number Text
                                                      );

                    int styleMask = STYLEMASK_DAY;
                    if (day.IsSelected)
                        styleMask |= STYLEMASK_SELECTED;
                    if (day.IsOtherMonth)
                        styleMask |= STYLEMASK_OTHERMONTH;
                    if (day.IsToday)
                        styleMask |= STYLEMASK_TODAY;
                    if (day.IsWeekend)
                        styleMask |= STYLEMASK_WEEKEND;
                    int dayStyleMask = definedStyleMask  & styleMask;
                    // determine the unique portion of the mask for the current calendar,
                    // which will strip out the day style bit
                    int dayStyleID = dayStyleMask & STYLEMASK_UNIQUE;
                    
                    TableItemStyle cellStyle = cellStyles[dayStyleID];
                    if (cellStyle == null) {
                        cellStyle = new TableItemStyle();
                        SetDayStyles(cellStyle, dayStyleMask, defaultWidth);
                        cellStyles[dayStyleID] = cellStyle;
                    }


                    if (hasRenderEvent) {

                        TableCell cdc = new TableCell();
                        cdc.ApplyStyle(cellStyle);

                        LiteralControl dayContent = new LiteralControl(dayNumberText);
                        cdc.Controls.Add(dayContent);

                        day.IsSelectable = daysSelectable;

                        OnDayRender(cdc, day);

                        // refresh the day content
                        dayContent.Text = GetCalendarButtonText(absoluteDay.ToString(CultureInfo.InvariantCulture),
                                                                dayNumberText,
                                                                buttonsActive && day.IsSelectable,
                                                                cdc.ForeColor);
                        cdc.RenderControl(writer); 

                    }
                    else {
                        RenderCalendarCell(writer, cellStyle, dayNumberText, daysSelectable, absoluteDay.ToString(CultureInfo.InvariantCulture));
                    }

                    d = threadCalendar.AddDays(d, 1);
                    absoluteDay++;

                }
                writer.Write(ROWENDTAG);
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.RenderTitle"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void RenderTitle(HtmlTextWriter writer, DateTime visibleDate, CalendarSelectionMode selectionMode, bool buttonsActive) {
            writer.Write(ROWBEGINTAG);

            TableCell titleCell = new TableCell();            
            Table titleTable = new Table();

            // default title table/cell styles            
            titleCell.ColumnSpan = HasWeekSelectors(selectionMode) ? 8 : 7;
            titleCell.BackColor = Color.Silver;
            titleTable.GridLines = GridLines.None;
            titleTable.Width = Unit.Percentage(100);
            titleTable.CellSpacing = 0;

            TableItemStyle titleStyle = TitleStyle;
            ApplyTitleStyle(titleCell, titleTable, titleStyle);

            titleCell.RenderBeginTag(writer);
            titleTable.RenderBeginTag(writer);
            writer.Write(ROWBEGINTAG);

            NextPrevFormat nextPrevFormat = NextPrevFormat;

            TableItemStyle nextPrevStyle = new TableItemStyle();
            nextPrevStyle.Width = Unit.Percentage(15);
            nextPrevStyle.CopyFrom(NextPrevStyle);
            if (ShowNextPrevMonth) {
                string prevMonthText;
                if (nextPrevFormat == NextPrevFormat.ShortMonth || nextPrevFormat == NextPrevFormat.FullMonth) {
                    int monthNo = threadCalendar.GetMonth(threadCalendar.AddMonths(visibleDate, - 1));
                    prevMonthText = GetMonthName(monthNo, (nextPrevFormat == NextPrevFormat.FullMonth));
                }
                else {
                    prevMonthText = PrevMonthText;
                }
                // Month navigation. The command starts with a "V" and the remainder is day difference from the
                // base date.
                DateTime prevMonthDate= threadCalendar.AddMonths(visibleDate, -1);
                string prevMonthKey = NAVIGATE_MONTH_COMMAND + (prevMonthDate.Subtract(baseDate)).Days.ToString(CultureInfo.InvariantCulture);
                RenderCalendarCell(writer, nextPrevStyle, prevMonthText, buttonsActive, prevMonthKey);
            }


            TableItemStyle cellMainStyle = new TableItemStyle();

            if (titleStyle.HorizontalAlign != HorizontalAlign.NotSet) {
                cellMainStyle.HorizontalAlign = titleStyle.HorizontalAlign;
            } 
            else {
                cellMainStyle.HorizontalAlign = HorizontalAlign.Center;
            }
            cellMainStyle.Wrap = titleStyle.Wrap;
            cellMainStyle.Width = Unit.Percentage(70);

            string titleText;

            switch (TitleFormat) {
                case TitleFormat.Month:
                    titleText = visibleDate.ToString("MMMM");;
                    break;
                case TitleFormat.MonthYear:
                    string titlePattern = DateTimeFormatInfo.CurrentInfo.YearMonthPattern;
                    // Some cultures have a comma in their YearMonthPattern, which does not look
                    // right in a calendar. Use a fixed pattern for those.
                    if (titlePattern.IndexOf(',') >= 0) {
                        titlePattern = "MMMM yyyy";
                    }
                    titleText = visibleDate.ToString(titlePattern);
                    break;
                default:
                    Debug.Assert(false, "Unknown TitleFormat value!");
                    goto
                case TitleFormat.MonthYear;
            }
            RenderCalendarCell(writer, cellMainStyle, titleText, false, null);

            if (ShowNextPrevMonth) {
                // Style for this one is identical bar
                nextPrevStyle.HorizontalAlign = HorizontalAlign.Right;
                string nextMonthText;
                if (nextPrevFormat == NextPrevFormat.ShortMonth || nextPrevFormat == NextPrevFormat.FullMonth) {
                    int monthNo = threadCalendar.GetMonth(threadCalendar.AddMonths(visibleDate, 1));
                    nextMonthText = GetMonthName(monthNo, (nextPrevFormat == NextPrevFormat.FullMonth));
                }
                else {
                    nextMonthText = NextMonthText;
                }
                // Month navigation. The command starts with a "V" and the remainder is day difference from the
                // base date.
                DateTime nextMonthDate = threadCalendar.AddMonths(visibleDate, 1);
                string nextMonthKey = NAVIGATE_MONTH_COMMAND + (nextMonthDate.Subtract(baseDate)).Days.ToString(CultureInfo.InvariantCulture);
                RenderCalendarCell(writer, nextPrevStyle, nextMonthText, buttonsActive, nextMonthKey);
            }
            writer.Write(ROWENDTAG);
            titleTable.RenderEndTag(writer);
            titleCell.RenderEndTag(writer);
            writer.Write(ROWENDTAG);

        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.SaveViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Stores the state of the System.Web.UI.WebControls.Calender.</para>
        /// </devdoc>
        protected override object SaveViewState() {
            if (SelectedDates.Count > 0)
                ViewState["SD"] = dateList;

            object[] myState = new object[10];

            myState[0] = base.SaveViewState();
            myState[1] = (titleStyle != null) ? ((IStateManager)titleStyle).SaveViewState() : null;
            myState[2] = (nextPrevStyle != null) ? ((IStateManager)nextPrevStyle).SaveViewState() : null;
            myState[3] = (dayStyle != null) ? ((IStateManager)dayStyle).SaveViewState() : null;
            myState[4] = (dayHeaderStyle != null) ? ((IStateManager)dayHeaderStyle).SaveViewState() : null;
            myState[5] = (todayDayStyle != null) ? ((IStateManager)todayDayStyle).SaveViewState() : null;
            myState[6] = (weekendDayStyle != null) ? ((IStateManager)weekendDayStyle).SaveViewState() : null;
            myState[7] = (otherMonthDayStyle != null) ? ((IStateManager)otherMonthDayStyle).SaveViewState() : null;
            myState[8] = (selectedDayStyle != null) ? ((IStateManager)selectedDayStyle).SaveViewState() : null;
            myState[9] = (selectorStyle != null) ? ((IStateManager)selectorStyle).SaveViewState() : null;

            for (int i = 0; i<myState.Length; i++) {
                if (myState[i] != null)
                    return myState;
            }

            return null;
        }

        private void SelectRange(DateTime dateFrom, DateTime dateTo) {

            Debug.Assert(dateFrom <= dateTo, "Bad Date Range");

            // see if this range differs in any way from the current range
            // these checks will determine this because the colleciton is sorted
            TimeSpan ts = dateTo - dateFrom;
            if (SelectedDates.Count != ts.Days + 1 
                || SelectedDates[0] != dateFrom
                || SelectedDates[SelectedDates.Count - 1] != dateTo) {
                SelectedDates.SelectRange(dateFrom, dateTo);
                OnSelectionChanged();
            }
        }

        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.SetDayStyles"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void SetDayStyles(TableItemStyle style, int styleMask, Unit defaultWidth) {

            // default day styles
            style.Width = defaultWidth;
            style.HorizontalAlign = HorizontalAlign.Center;

            if ((styleMask & STYLEMASK_DAY) != 0) {
                style.CopyFrom(DayStyle);
            }
            if ((styleMask & STYLEMASK_WEEKEND) != 0) {
                style.CopyFrom(WeekendDayStyle);
            }
            if ((styleMask & STYLEMASK_OTHERMONTH) != 0) {
                style.CopyFrom(OtherMonthDayStyle);
            }
            if ((styleMask & STYLEMASK_TODAY) != 0) {
                style.CopyFrom(TodayDayStyle);
            }

            if ((styleMask & STYLEMASK_SELECTED) != 0) {
                // default selected day style         
                style.ForeColor = Color.White;
                style.BackColor = Color.Silver;

                style.CopyFrom(SelectedDayStyle);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\checkboxlist.cs ===
//------------------------------------------------------------------------------
// <copyright file="CheckBoxList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Globalization;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList"]/*' />
    /// <devdoc>
    /// <para>Creates a group of <see cref='System.Web.UI.WebControls.CheckBox'/> controls.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class CheckBoxList : ListControl, IRepeatInfoUser, INamingContainer, IPostBackDataHandler {
        private bool hasNotifiedOfChange;
        private CheckBox controlToRepeat;

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.CheckBoxList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.WebControls.CheckBoxList'/> class.
        ///    </para>
        /// </devdoc>
        public CheckBoxList() {
            controlToRepeat = new CheckBox();
            controlToRepeat.ID = "0";
            controlToRepeat.EnableViewState = false;
            Controls.Add(controlToRepeat);
            hasNotifiedOfChange = false;
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.CellPadding"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the padding between each item.
        ///    </para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(-1),
        WebSysDescription(SR.CheckBoxList_CellPadding)
        ]
        public virtual int CellPadding {
            get {
                if (ControlStyleCreated == false) {
                    return -1;
                }
                return ((TableStyle)ControlStyle).CellPadding;
            }
            set {
                ((TableStyle)ControlStyle).CellPadding = value;
            }
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.CellSpacing"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the spacing between each item.
        ///    </para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(-1),
        WebSysDescription(SR.CheckBoxList_CellSpacing)
        ]
        public virtual int CellSpacing {
            get {
                if (ControlStyleCreated == false) {
                    return -1;
                }
                return ((TableStyle)ControlStyle).CellSpacing;
            }
            set {
                ((TableStyle)ControlStyle).CellSpacing = value;
            }
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.RepeatColumns"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the number of columns to repeat.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(0),
        WebSysDescription(SR.CheckBoxList_RepeatColumns)
        ]
        public virtual int RepeatColumns {
            get {
                object o = ViewState["RepeatColumns"];
                return((o == null) ? 0 : (int)o);
            }
            set {
                if (value < 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["RepeatColumns"] = value;
            }
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.RepeatDirection"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that indicates whether the control is displayed 
        ///       vertically or horizontally.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(RepeatDirection.Vertical),
        WebSysDescription(SR.CheckBoxList_RepeatDirection)
        ]
        public virtual RepeatDirection RepeatDirection {
            get {
                object o = ViewState["RepeatDirection"];
                return((o == null) ? RepeatDirection.Vertical : (RepeatDirection)o);
            }
            set {
                if (value < RepeatDirection.Horizontal || value > RepeatDirection.Vertical) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["RepeatDirection"] = value;
            }
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.RepeatLayout"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that indicates whether the control is displayed in 
        ///    <see langword='Table '/>or <see langword='Flow '/>layout.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(RepeatLayout.Table),
        WebSysDescription(SR.CheckBoxList_RepeatLayout)
        ]
        public virtual RepeatLayout RepeatLayout {
            get {
                object o = ViewState["RepeatLayout"];
                return((o == null) ? RepeatLayout.Table : (RepeatLayout)o);
            }
            set {
                if (value < RepeatLayout.Table || value > RepeatLayout.Flow) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["RepeatLayout"] = value;
            }
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.TextAlign"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       the alignment of the text label associated with each checkbox.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(TextAlign.Right),
        WebSysDescription(SR.CheckBoxList_TextAlign)
        ]
        public virtual TextAlign TextAlign {
            get {
                object align = ViewState["TextAlign"];
                return((align == null) ? TextAlign.Right : (TextAlign)align);
            }
            set {
                if (value < TextAlign.Left || value > TextAlign.Right) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["TextAlign"] = value;
            }
        }


        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.CreateControlStyle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Creates a new control style object.</para>
        /// </devdoc>
        protected override Style CreateControlStyle() {
            return new TableStyle(ViewState);
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.FindControl"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Catches post data for each <see cref='System.Web.UI.WebControls.CheckBox'/> in the list.</para>
        /// </devdoc>
        protected override Control FindControl(string id, int pathOffset) {
            return this;
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Processes posted data for the <see cref='System.Web.UI.WebControls.CheckBoxList'/> control.</para>
        /// </devdoc>
        bool IPostBackDataHandler.LoadPostData(String postDataKey, NameValueCollection postCollection) {
            string strIndex = postDataKey.Substring(UniqueID.Length + 1);
            int index = Int32.Parse(strIndex);

            if (index >= 0 && index < Items.Count) {
                bool newCheckState = (postCollection[postDataKey] != null);

                if (Items[index].Selected != newCheckState) {
                    Items[index].Selected = newCheckState;
                    // LoadPostData will be invoked for each CheckBox that changed
                    // Suppress multiple change notification and fire only ONE change event
                    if (!hasNotifiedOfChange) {
                        hasNotifiedOfChange = true;
                        return true;
                    }
                }
            }

            return false;
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Configures the <see cref='System.Web.UI.WebControls.CheckBoxList'/> prior to rendering on the client.</para>
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {
            controlToRepeat.AutoPostBack = AutoPostBack;

            if (Page != null) {
                // ensure postback data for those checkboxes which get unchecked or are different from their default value
                for (int i=0; i < Items.Count; i++) {
                    controlToRepeat.ID = i.ToString(NumberFormatInfo.InvariantInfo);
                    Page.RegisterRequiresPostBack(controlToRepeat);
                }
            }
        } 

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Raises when posted data for a control has changed.</para>
        /// </devdoc>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            OnSelectedIndexChanged(EventArgs.Empty);
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.Render"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Displays the <see cref='System.Web.UI.WebControls.CheckBoxList'/> on the client.
        ///    </para>
        /// </devdoc>
        protected override void Render(HtmlTextWriter writer) {
            RepeatInfo repeatInfo = new RepeatInfo();
            Style style = (ControlStyleCreated ? ControlStyle : null);
            short tabIndex = TabIndex;
            bool undirtyTabIndex = false;

            // TabIndex here is special... it needs to be applied to the individual
            // checkboxes and not the outer control itself

            // cache away the TabIndex property state
            controlToRepeat.TabIndex = tabIndex;
            if (tabIndex != 0) {
                if (ViewState.IsItemDirty("TabIndex") == false) {
                    undirtyTabIndex = true;
                }
                TabIndex = 0;
            }

            repeatInfo.RepeatColumns = RepeatColumns;
            repeatInfo.RepeatDirection = RepeatDirection;
            repeatInfo.RepeatLayout = RepeatLayout;
            repeatInfo.RenderRepeater(writer, (IRepeatInfoUser)this, style, this);

            // restore the state of the TabIndex property
            if (tabIndex != 0) {
                TabIndex = tabIndex;
            }
            if (undirtyTabIndex) {
                ViewState.SetItemDirty("TabIndex", false);
            }
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.IRepeatInfoUser.HasFooter"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IRepeatInfoUser.HasFooter {
            get {
                return false;
            }
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.IRepeatInfoUser.HasHeader"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IRepeatInfoUser.HasHeader {
            get {
                return false;
            }
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.IRepeatInfoUser.HasSeparators"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IRepeatInfoUser.HasSeparators {
            get {
                return false;
            }
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.IRepeatInfoUser.RepeatedItemCount"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        int IRepeatInfoUser.RepeatedItemCount {
            get {
                return Items.Count;
            }
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.IRepeatInfoUser.GetItemStyle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        Style IRepeatInfoUser.GetItemStyle(ListItemType itemType, int repeatIndex) {
            return null;
        }

        /// <include file='doc\CheckBoxList.uex' path='docs/doc[@for="CheckBoxList.IRepeatInfoUser.RenderItem"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Called by the RepeatInfo helper to render each item
        /// </devdoc>
        void IRepeatInfoUser.RenderItem(ListItemType itemType, int repeatIndex, RepeatInfo repeatInfo, HtmlTextWriter writer) {
            controlToRepeat.ID = repeatIndex.ToString(NumberFormatInfo.InvariantInfo);
            controlToRepeat.Text = Items[repeatIndex].Text;
            controlToRepeat.TextAlign = TextAlign;
            controlToRepeat.Checked = Items[repeatIndex].Selected;
            controlToRepeat.Enabled = this.Enabled;

            // CONSIDER: apply CheckBoxList style to RadioButtons?
            controlToRepeat.RenderControl(writer);
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\commandeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="CommandEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\CommandEventHandler.uex' path='docs/doc[@for="CommandEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle 
    ///       the <see langword='Command'/> event.</para>
    /// </devdoc>
    public delegate void CommandEventHandler(object sender, CommandEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\column.cs ===
//------------------------------------------------------------------------------
// <copyright file="Column.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;    
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn"]/*' />
    /// <devdoc>
    ///    Creates a column and is the base class for all <see cref='System.Web.UI.WebControls.DataGrid'/> column types.
    /// </devdoc>
    [
    TypeConverterAttribute(typeof(ExpandableObjectConverter))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public abstract class DataGridColumn : IStateManager {

        private DataGrid owner;
        private TableItemStyle itemStyle;
        private TableItemStyle headerStyle;
        private TableItemStyle footerStyle;
        private StateBag statebag;
        private bool marked;

        private bool designMode;


        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.DataGridColumn"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the System.Web.UI.WebControls.Column class.</para>
        /// </devdoc>
        public DataGridColumn() {
            statebag = new StateBag();
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.DesignMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool DesignMode {
            get {
                return designMode;
            }
        }
        
        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.FooterStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties for the footer item.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        WebSysDescription(SR.DataGridColumn_FooterStyle),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        PersistenceMode(PersistenceMode.InnerProperty)
        ]
        public virtual TableItemStyle FooterStyle {
            get {
                if (footerStyle == null) {
                    footerStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)footerStyle).TrackViewState();
                }
                return footerStyle;
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.FooterStyleInternal"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal TableItemStyle FooterStyleInternal {
            get {
                return footerStyle;
            }
            set {
                footerStyle = value;
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.FooterText"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the text displayed in the footer of the 
        ///    System.Web.UI.WebControls.Column.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.DataGridColumn_FooterText)
        ]
        public virtual string FooterText {
            get {
                object o = ViewState["FooterText"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["FooterText"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.HeaderImageUrl"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the URL reference to an image to display 
        ///       instead of text on the header of this System.Web.UI.WebControls.Column
        ///       .</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.DataGridColumn_HeaderImageUrl)
        ]
        public virtual string HeaderImageUrl {
            get {
                object o = ViewState["HeaderImageUrl"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["HeaderImageUrl"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.HeaderStyle"]/*' />
        /// <devdoc>
        /// <para>Gets the style properties for the header of the System.Web.UI.WebControls.Column. This property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        WebSysDescription(SR.DataGridColumn_HeaderStyle),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        PersistenceMode(PersistenceMode.InnerProperty)
        ]
        public virtual TableItemStyle HeaderStyle {
            get {
                if (headerStyle == null) {
                    headerStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)headerStyle).TrackViewState();
                }
                return headerStyle;
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.HeaderStyleInternal"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal TableItemStyle HeaderStyleInternal {
            get {
                return headerStyle;
            }
            set {
                headerStyle = value;
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.HeaderText"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the text displayed in the header of the 
        ///    System.Web.UI.WebControls.Column.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.DataGridColumn_HeaderText)
        ]
        public virtual string HeaderText {
            get {
                object o = ViewState["HeaderText"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["HeaderText"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.ItemStyle"]/*' />
        /// <devdoc>
        /// <para>Gets the style properties of an item within the System.Web.UI.WebControls.Column. This property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        WebSysDescription(SR.DataGridColumn_ItemStyle),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        PersistenceMode(PersistenceMode.InnerProperty)
        ]
        public virtual TableItemStyle ItemStyle {
            get {
                if (itemStyle == null) {
                    itemStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)itemStyle).TrackViewState();
                }
                return itemStyle;
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.ItemStyleInternal"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal TableItemStyle ItemStyleInternal {
            get {
                return itemStyle;
            }
            set {
                itemStyle = value;
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.Owner"]/*' />
        /// <devdoc>
        /// <para>Gets the System.Web.UI.WebControls.DataGrid that the System.Web.UI.WebControls.Column is a part of. This property is read-only.</para>
        /// </devdoc>
        protected DataGrid Owner {
            get {
                return owner;
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.SortExpression"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the expression used when this column is used to sort the data source> by.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.DataGridColumn_SortExpression)
        ]
        public virtual string SortExpression {
            get {
                object o = ViewState["SortExpression"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["SortExpression"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.ViewState"]/*' />
        /// <devdoc>
        /// <para>Gets the statebag for the System.Web.UI.WebControls.Column. This property is read-only.</para>
        /// </devdoc>
        protected StateBag ViewState {
            get {
                return statebag;
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.Visible"]/*' />
        /// <devdoc>
        /// <para>Gets or sets a value to indicate whether the System.Web.UI.WebControls.Column is visible.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(true),
        WebSysDescription(SR.DataGridColumn_Visible)
        ]
        public bool Visible {
            get {
                object o = ViewState["Visible"];
                if (o != null)
                    return(bool)o;
                return true;
            }
            set {
                ViewState["Visible"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.Initialize"]/*' />
        /// <devdoc>
        /// </devdoc>
        public virtual void Initialize() {
            if ((owner != null) && (owner.Site != null)) {
                designMode = owner.Site.DesignMode;
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.InitializeCell"]/*' />
        /// <devdoc>
        /// <para>Initializes a cell in the System.Web.UI.WebControls.Column.</para>
        /// </devdoc>
        public virtual void InitializeCell(TableCell cell, int columnIndex, ListItemType itemType) {
            switch (itemType) {
                case ListItemType.Header:
                    {
                        WebControl headerControl = null;
                        bool sortableHeader = true;
                        string sortExpression = null;

                        if ((owner != null) && (owner.AllowSorting == false)) {
                            sortableHeader = false;
                        }
                        if (sortableHeader) {
                            sortExpression = SortExpression;
                            if (sortExpression.Length == 0)
                                sortableHeader = false;
                        }

                        string headerImageUrl = HeaderImageUrl;
                        if (headerImageUrl.Length != 0) {
                            if (sortableHeader) {
                                ImageButton sortButton = new ImageButton();

                                sortButton.ImageUrl = HeaderImageUrl;
                                sortButton.CommandName = DataGrid.SortCommandName;
                                sortButton.CommandArgument = sortExpression;
                                sortButton.CausesValidation = false;
                                headerControl = sortButton;
                            }
                            else {
                                Image headerImage = new Image();

                                headerImage.ImageUrl = headerImageUrl;
                                headerControl = headerImage;
                            }
                        }
                        else {
                            string headerText = HeaderText;
                            if (sortableHeader) {
                                LinkButton sortButton = new DataGridLinkButton();

                                sortButton.Text = headerText;
                                sortButton.CommandName = DataGrid.SortCommandName;
                                sortButton.CommandArgument = sortExpression;
                                sortButton.CausesValidation = false;
                                headerControl = sortButton;
                            }
                            else {
                                if (headerText.Length == 0) {
                                    // the browser does not render table borders for cells with nothing
                                    // in their content, so we add a non-breaking space.
                                    headerText = "&nbsp;";
                                }
                                cell.Text = headerText;
                            }
                        }

                        if (headerControl != null) {
                            cell.Controls.Add(headerControl);
                        }
                    }
                    break;

                case ListItemType.Footer:
                    {
                        string footerText = FooterText;
                        if (footerText.Length == 0) {
                            // the browser does not render table borders for cells with nothing
                            // in their content, so we add a non-breaking space.
                            footerText = "&nbsp;";
                        }

                        cell.Text = footerText;
                    }
                    break;
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.IsTrackingViewState"]/*' />
        /// <devdoc>
        /// <para>Determines if the System.Web.UI.WebControls.Column is marked to save its state.</para>
        /// </devdoc>
        protected bool IsTrackingViewState {
            get {
                return marked;
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.LoadViewState"]/*' />
        /// <devdoc>
        /// <para>Loads the state of the System.Web.UI.WebControls.Column.</para>
        /// </devdoc>
        protected virtual void LoadViewState(object savedState) {
            if (savedState != null) {
                object[] myState = (object[])savedState;

                if (myState[0] != null)
                    ((IStateManager)ViewState).LoadViewState(myState[0]);
                if (myState[1] != null)
                    ((IStateManager)ItemStyle).LoadViewState(myState[1]);
                if (myState[2] != null)
                    ((IStateManager)HeaderStyle).LoadViewState(myState[2]);
                if (myState[3] != null)
                    ((IStateManager)FooterStyle).LoadViewState(myState[3]);
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.TrackViewState"]/*' />
        /// <devdoc>
        ///    <para>Marks the starting point to begin tracking and saving changes to the 
        ///       control as part of the control viewstate.</para>
        /// </devdoc>
        protected virtual void TrackViewState() {
            marked = true;
            ((IStateManager)ViewState).TrackViewState();
            if (itemStyle != null)
                ((IStateManager)itemStyle).TrackViewState();
            if (headerStyle != null)
                ((IStateManager)headerStyle).TrackViewState();
            if (footerStyle != null)
                ((IStateManager)footerStyle).TrackViewState();
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.OnColumnChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the ColumnChanged event for a System.Web.UI.WebControls.Column.</para>
        /// </devdoc>
        protected virtual void OnColumnChanged() {
            if (owner != null) {
                owner.OnColumnsChanged();
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.SaveViewState"]/*' />
        /// <devdoc>
        /// <para>Saves the current state of the System.Web.UI.WebControls.Column.</para>
        /// </devdoc>
        protected virtual object SaveViewState() {
            object propState = ((IStateManager)ViewState).SaveViewState();
            object itemStyleState = (itemStyle != null) ? ((IStateManager)itemStyle).SaveViewState() : null;
            object headerStyleState = (headerStyle != null) ? ((IStateManager)headerStyle).SaveViewState() : null;
            object footerStyleState = (footerStyle != null) ? ((IStateManager)footerStyle).SaveViewState() : null;

            if ((propState != null) ||
                (itemStyleState != null) ||
                (headerStyleState != null) ||
                (footerStyleState != null)) {
                return new object[4] {
                    propState,
                    itemStyleState,
                    headerStyleState,
                    footerStyleState
                };
            }

            return null;
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.SetOwner"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal void SetOwner(DataGrid owner) {
            this.owner = owner;
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.ToString"]/*' />
        /// <devdoc>
        /// <para>Converts the System.Web.UI.WebControls.Column to string.</para>
        /// </devdoc>
        public override string ToString() {
            return String.Empty;
        }


        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.IStateManager.IsTrackingViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return true if tracking state changes.
        /// </devdoc>
        bool IStateManager.IsTrackingViewState {
            get {
                return IsTrackingViewState;
            }
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.IStateManager.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Load previously saved state.
        /// </devdoc>
        void IStateManager.LoadViewState(object state) {
            LoadViewState(state);
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.IStateManager.TrackViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Start tracking state changes.
        /// </devdoc>
        void IStateManager.TrackViewState() {
            TrackViewState();
        }

        /// <include file='doc\Column.uex' path='docs/doc[@for="DataGridColumn.IStateManager.SaveViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Return object containing state changes.
        /// </devdoc>
        object IStateManager.SaveViewState() {
            return SaveViewState();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\comparevalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompareValidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web;
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\CompareValidator.uex' path='docs/doc[@for="CompareValidator"]/*' />
    /// <devdoc>
    ///    <para> Compares the value of an input control to another input control or
    ///       a constant value using a variety of operators and types.</para>
    /// </devdoc>
    [
    ToolboxData("<{0}:CompareValidator runat=server ErrorMessage=\"CompareValidator\"></{0}:CompareValidator>")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class CompareValidator : BaseCompareValidator {

        /// <include file='doc\CompareValidator.uex' path='docs/doc[@for="CompareValidator.ControlToCompare"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the ID of the input control to compare with.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.CompareValidator_ControlToCompare),
        TypeConverter(typeof(ValidatedControlConverter))
        ]                                         
        public string ControlToCompare {
            get { 
                object o = ViewState["ControlToCompare"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                ViewState["ControlToCompare"] = value;
            }
        }

        /// <include file='doc\CompareValidator.uex' path='docs/doc[@for="CompareValidator.Operator"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the comparison operation to perform.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(ValidationCompareOperator.Equal),
        WebSysDescription(SR.CompareValidator_Operator)
        ]                                         
        public ValidationCompareOperator Operator {
            get { 
                object o = ViewState["Operator"];
                return((o == null) ? ValidationCompareOperator.Equal : (ValidationCompareOperator)o);
            }
            set {
                if (value < ValidationCompareOperator.Equal || value > ValidationCompareOperator.DataTypeCheck) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["Operator"] = value;
            }
        }

        /// <include file='doc\CompareValidator.uex' path='docs/doc[@for="CompareValidator.ValueToCompare"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the specific value to compare with.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.CompareValidator_ValueToCompare)
        ]                                         
        public string ValueToCompare {
            get { 
                object o = ViewState["ValueToCompare"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                ViewState["ValueToCompare"] = value;
            }        
        }

        // <summary>
        //  AddAttributesToRender method
        // </summary>
        /// <include file='doc\CompareValidator.uex' path='docs/doc[@for="CompareValidator.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Adds the attributes of this control to the output stream for rendering on the 
        ///       client.</para>
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {
            base.AddAttributesToRender(writer);
            if (RenderUplevel) {
                writer.AddAttribute("evaluationfunction", "CompareValidatorEvaluateIsValid");
                if (ControlToCompare.Length > 0) {
                    writer.AddAttribute("controltocompare", GetControlRenderID(ControlToCompare));
                    writer.AddAttribute("controlhookup", GetControlRenderID(ControlToCompare));
                }
                if (ValueToCompare.Length > 0) {
                    writer.AddAttribute("valuetocompare", ValueToCompare);
                }
                if (Operator != ValidationCompareOperator.Equal) {
                    writer.AddAttribute("operator", PropertyConverter.EnumToString(typeof(ValidationCompareOperator), Operator));
                }
            }
        }        

        /// <include file='doc\CompareValidator.uex' path='docs/doc[@for="CompareValidator.ControlPropertiesValid"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para> Checks the properties of a the control for valid values.</para>
        /// </devdoc>
        protected override bool ControlPropertiesValid() {

            // Check the control id references 
            if (ControlToCompare.Length > 0) {
                CheckControlValidationProperty(ControlToCompare, "ControlToCompare");

                if (string.Compare(ControlToValidate, ControlToCompare, true, CultureInfo.InvariantCulture) == 0) {
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Validator_bad_compare_control, 
                                                                             ID, 
                                                                             ControlToCompare));
                }
            }   
            else {
                // Check Values
                if (Operator != ValidationCompareOperator.DataTypeCheck && 
                    !CanConvert(ValueToCompare, Type)) {
                    throw new HttpException(
                                           HttpRuntime.FormatResourceString(
                                                                           SR.Validator_value_bad_type, 
                                                                           new string [] {
                                                                               ValueToCompare,
                                                                               "ValueToCompare",
                                                                               ID, 
                                                                               PropertyConverter.EnumToString(typeof(ValidationDataType), Type),
                                                                           }));
                }
            }
            return base.ControlPropertiesValid();
        }

        /// <include file='doc\CompareValidator.uex' path='docs/doc[@for="CompareValidator.EvaluateIsValid"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    EvaluateIsValid method
        /// </devdoc>
        protected override bool EvaluateIsValid() {

            Debug.Assert(PropertiesValid, "Properties should have already been checked");

            // Get the peices of text from the control.
            string leftText = GetControlValidationValue(ControlToValidate);
            Debug.Assert(leftText != null, "Should have already caught this!");

            // Special case: if the string is blank, we don't try to validate it. The input should be
            // trimmed for coordination with the RequiredFieldValidator.
            if (leftText.Trim().Length == 0) {
                return true;
            }

            // The control has precedence over the fixed value
            string rightText = string.Empty;
            if (ControlToCompare.Length > 0) {
                rightText = GetControlValidationValue(ControlToCompare);
                Debug.Assert(rightText != null, "Should have already caught this!");
            }
            else {
                rightText = ValueToCompare;
            }

            return Compare(leftText, rightText, Operator, Type);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagridcommandeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridCommandEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;
    using System.Security.Permissions;

    /// <include file='doc\DataGridCommandEventArgs.uex' path='docs/doc[@for="DataGridCommandEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for some <see cref='System.Web.UI.WebControls.DataGrid'/> events.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DataGridCommandEventArgs : CommandEventArgs {

        private DataGridItem item;
        private object commandSource;

        /// <include file='doc\DataGridCommandEventArgs.uex' path='docs/doc[@for="DataGridCommandEventArgs.DataGridCommandEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.DataGridCommandEventArgs'/>
        /// class.</para>
        /// </devdoc>
        public DataGridCommandEventArgs(DataGridItem item, object commandSource, CommandEventArgs originalArgs) : base(originalArgs) {
            this.item = item;
            this.commandSource = commandSource;
        }


        /// <include file='doc\DataGridCommandEventArgs.uex' path='docs/doc[@for="DataGridCommandEventArgs.CommandSource"]/*' />
        /// <devdoc>
        ///    <para>Gets the source of the command. This property is read-only.</para>
        /// </devdoc>
        public object CommandSource {
            get {
                return commandSource;
            }
        }

        /// <include file='doc\DataGridCommandEventArgs.uex' path='docs/doc[@for="DataGridCommandEventArgs.Item"]/*' />
        /// <devdoc>
        /// <para>Gets the item in the <see cref='System.Web.UI.WebControls.DataGrid'/> that was clicked. This property is read-only.</para>
        /// </devdoc>
        public DataGridItem Item {
            get {
                return item;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagridcommandeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridCommandEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\DataGridCommandEventHandler.uex' path='docs/doc[@for="DataGridCommandEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see langword='DataGridCommand'/>
    /// event for the <see cref='System.Web.UI.WebControls.DataGrid'/> class.</para>
    /// </devdoc>
    public delegate void DataGridCommandEventHandler(object source, DataGridCommandEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\customvalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="CustomValidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web;
    using System.Security.Permissions;

    /// <include file='doc\CustomValidator.uex' path='docs/doc[@for="CustomValidator"]/*' />
    /// <devdoc>
    ///    <para> Allows custom code to perform
    ///       validation on the client and/or server.</para>
    /// </devdoc>
    [
    DefaultEvent("ServerValidate"),
    ToolboxData("<{0}:CustomValidator runat=server ErrorMessage=\"CustomValidator\"></{0}:CustomValidator>")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class CustomValidator : BaseValidator {

        private static readonly object EventServerValidate= new object();

        /// <include file='doc\CustomValidator.uex' path='docs/doc[@for="CustomValidator.ClientValidationFunction"]/*' />
        /// <devdoc>
        ///    <para>Gets and sets the custom client Javascript function used 
        ///       for validation.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.CustomValidator_ClientValidationFunction)
        ]                                         
        public string ClientValidationFunction {
            get { 
                object o = ViewState["ClientValidationFunction"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                ViewState["ClientValidationFunction"] = value;
            }
        }

        /// <include file='doc\CustomValidator.uex' path='docs/doc[@for="CustomValidator.ServerValidate"]/*' />
        /// <devdoc>
        ///    <para>Represents the method that will handle the 
        ///    <see langword='ServerValidate'/> event of a 
        ///    <see cref='System.Web.UI.WebControls.CustomValidator'/>.</para>
        /// </devdoc>
        [
        WebSysDescription(SR.CustomValidator_ServerValidate)
        ]                                         
        public event ServerValidateEventHandler ServerValidate {
            add {
                Events.AddHandler(EventServerValidate, value);
            }
            remove {
                Events.RemoveHandler(EventServerValidate, value);
            }
        }

        /// <include file='doc\CustomValidator.uex' path='docs/doc[@for="CustomValidator.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Adds the properties of the <see cref='System.Web.UI.WebControls.CustomValidator'/> control to the 
        ///    output stream for rendering on the client.</para>
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {
            base.AddAttributesToRender(writer);
            if (RenderUplevel) {
                writer.AddAttribute("evaluationfunction", "CustomValidatorEvaluateIsValid");
                if (ClientValidationFunction.Length > 0) {
                    writer.AddAttribute("clientvalidationfunction", ClientValidationFunction);
                }
            }
        }

        /// <include file='doc\CustomValidator.uex' path='docs/doc[@for="CustomValidator.ControlPropertiesValid"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Checks the properties of the control for valid values.</para>
        /// </devdoc>
        protected override bool ControlPropertiesValid() {
            // Need to override the BaseValidator implementation, because for CustomValidator, it is fine
            // for the ControlToValidate to be blank.
            string controlToValidate = ControlToValidate;
            if (controlToValidate.Length > 0) {
                // Check that the property points to a valid control. Will throw and exception if not found
                CheckControlValidationProperty(controlToValidate, "ControlToValidate");
            }
            return true;
        }                     

        /// <include file='doc\CustomValidator.uex' path='docs/doc[@for="CustomValidator.EvaluateIsValid"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    EvaluateIsValid method
        /// </devdoc>
        protected override bool EvaluateIsValid() {

            // If no control is specified, we always fire the event. If they have specified a control, we
            // only fire the event if the input is non-blank.
            string controlValue = "";
            string controlToValidate = ControlToValidate;
            if (controlToValidate.Length > 0) {
                controlValue = GetControlValidationValue(controlToValidate);
                Debug.Assert(controlValue != null, "Should have been caught be property check");
                // If the text is empty, we return true. Whitespace is ignored for coordination wiht
                // RequiredFieldValidator.
                if (controlValue == null || controlValue.Trim().Length == 0) {
                    return true;
                }
            }

            return OnServerValidate(controlValue);
        }            

        /// <include file='doc\CustomValidator.uex' path='docs/doc[@for="CustomValidator.OnServerValidate"]/*' />
        /// <devdoc>
        ///    <para>Raises the 
        ///    <see langword='ServerValidate'/> event for the <see cref='System.Web.UI.WebControls.CustomValidator'/>.</para>
        /// </devdoc>
        protected virtual bool OnServerValidate(string value) {
            ServerValidateEventHandler handler = (ServerValidateEventHandler)Events[EventServerValidate];
            ServerValidateEventArgs args = new ServerValidateEventArgs(value, true);
            if (handler != null) {
                handler(this, args);
                return args.IsValid;
            }
            else {
                return true;
            }
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagriditem.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.ComponentModel;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\DataGridItem.uex' path='docs/doc[@for="DataGridItem"]/*' />
    /// <devdoc>
    /// <para>Represents an individual item in the <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DataGridItem : TableRow, INamingContainer {

        private int itemIndex;
        private int dataSetIndex;
        private ListItemType itemType;
        private object dataItem;


        /// <include file='doc\DataGridItem.uex' path='docs/doc[@for="DataGridItem.DataGridItem"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.DataGridItem'/> class.</para>
        /// </devdoc>
        public DataGridItem(int itemIndex, int dataSetIndex, ListItemType itemType) {
            this.itemIndex = itemIndex;
            this.dataSetIndex = dataSetIndex;
            this.itemType = itemType;
        }


        /// <include file='doc\DataGridItem.uex' path='docs/doc[@for="DataGridItem.DataItem"]/*' />
        /// <devdoc>
        /// <para>Represents an item in the <see cref='System.Web.UI.WebControls.DataGrid'/>. </para>
        /// </devdoc>
        public virtual object DataItem {
            get {
                return dataItem;
            }
            set {
                dataItem = value;
            }
        }

        /// <include file='doc\DataGridItem.uex' path='docs/doc[@for="DataGridItem.DataSetIndex"]/*' />
        /// <devdoc>
        ///    <para>Indicates the data set index number. This property is read-only.</para>
        /// </devdoc>
        public virtual int DataSetIndex {
            get {
                return dataSetIndex;
            }
        }

        /// <include file='doc\DataGridItem.uex' path='docs/doc[@for="DataGridItem.ItemIndex"]/*' />
        /// <devdoc>
        /// <para>Indicates the index of the item in the <see cref='System.Web.UI.WebControls.DataGrid'/>. This property is 
        ///    read-only.</para>
        /// </devdoc>
        public virtual int ItemIndex {
            get {
                return itemIndex;
            }
        }

        /// <include file='doc\DataGridItem.uex' path='docs/doc[@for="DataGridItem.ItemType"]/*' />
        /// <devdoc>
        /// <para>Indicates the type of the item in the <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
        /// </devdoc>
        public virtual ListItemType ItemType {
            get {
                return itemType;
            }
        }


        /// <include file='doc\DataGridItem.uex' path='docs/doc[@for="DataGridItem.OnBubbleEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override bool OnBubbleEvent(object source, EventArgs e) {
            if (e is CommandEventArgs) {
                DataGridCommandEventArgs args = new DataGridCommandEventArgs(this, source, (CommandEventArgs)e);

                RaiseBubbleEvent(this, args);
                return true;
            }
            return false;
        }

        /// <include file='doc\DataGridItem.uex' path='docs/doc[@for="DataGridItem.SetItemType"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected internal virtual void SetItemType(ListItemType itemType) {
            this.itemType = itemType;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagriditemeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridItemEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Security.Permissions;

    /// <include file='doc\DataGridItemEventArgs.uex' path='docs/doc[@for="DataGridItemEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see langword='DataGridItem'/> event.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DataGridItemEventArgs : EventArgs {

        private DataGridItem item;

        /// <include file='doc\DataGridItemEventArgs.uex' path='docs/doc[@for="DataGridItemEventArgs.DataGridItemEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of <see cref='System.Web.UI.WebControls.DataGridItemEventArgs'/> class.</para>
        /// </devdoc>
        public DataGridItemEventArgs(DataGridItem item) {
            this.item = item;
        }


        /// <include file='doc\DataGridItemEventArgs.uex' path='docs/doc[@for="DataGridItemEventArgs.Item"]/*' />
        /// <devdoc>
        /// <para>Gets an item in the <see cref='System.Web.UI.WebControls.DataGrid'/>. This property is read-only.</para>
        /// </devdoc>
        public DataGridItem Item {
            get {
                return item;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagriditemcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridItemCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.Security.Permissions;

    /// <include file='doc\DataGridItemCollection.uex' path='docs/doc[@for="DataGridItemCollection"]/*' />
    /// <devdoc>
    /// <para>Represents the collection of <see cref='System.Web.UI.WebControls.DataGridItem'/> objects.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DataGridItemCollection : ICollection {

        private ArrayList items;
        /// <include file='doc\DataGridItemCollection.uex' path='docs/doc[@for="DataGridItemCollection.DataGridItemCollection"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.DataGridItemCollection'/> class.</para>
        /// </devdoc>
        public DataGridItemCollection(ArrayList items) {
            this.items = items;
        }
        
        /// <include file='doc\DataGridItemCollection.uex' path='docs/doc[@for="DataGridItemCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of items in the collection. This property is read-only.</para>
        /// </devdoc>
        public int Count {
            get {
                return items.Count;
            }
        }

        /// <include file='doc\DataGridItemCollection.uex' path='docs/doc[@for="DataGridItemCollection.IsReadOnly"]/*' />
        /// <devdoc>
        /// <para>Gets a value that specifies whether items in the <see cref='System.Web.UI.WebControls.DataGridItemCollection'/> can be 
        ///    modified. This property is read-only.</para>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\DataGridItemCollection.uex' path='docs/doc[@for="DataGridItemCollection.IsSynchronized"]/*' />
        /// <devdoc>
        /// <para>Gets a value that indicates whether the <see cref='System.Web.UI.WebControls.DataGridItemCollection'/> is 
        ///    thread-safe. This property is read-only.</para>
        /// </devdoc>
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\DataGridItemCollection.uex' path='docs/doc[@for="DataGridItemCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>Gets the object used to synchronize access to the collection. This property is read-only. </para>
        /// </devdoc>
        public object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\DataGridItemCollection.uex' path='docs/doc[@for="DataGridItemCollection.this"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='System.Web.UI.WebControls.DataGridItem'/> at the specified index in the 
        ///    collection.</para>
        /// </devdoc>
        public DataGridItem this[int index] {
            get {
                return(DataGridItem)items[index];
            }
        }


        /// <include file='doc\DataGridItemCollection.uex' path='docs/doc[@for="DataGridItemCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the contents of the entire collection into an <see cref='System.Array' qualify='true'/> appending 
        ///    at the specified index of the <see cref='System.Array' qualify='true'/>.</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\DataGridItemCollection.uex' path='docs/doc[@for="DataGridItemCollection.GetEnumerator"]/*' />
        /// <devdoc>
        /// <para>Creates an enumerator for the <see cref='System.Web.UI.WebControls.DataGridItemCollection'/> used to 
        ///    iterate through the collection.</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return items.GetEnumerator(); 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagrid.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGrid.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;    
    using System.Globalization;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Reflection;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Displays data from a data source in a tabular grid. The data source
    ///       is any object that implements IEnumerable, which includes ADO.NET data,
    ///       arrays, ArrayLists etc.
    ///    </para>
    /// </devdoc>
    [
    Editor("System.Web.UI.Design.WebControls.DataGridComponentEditor, " + AssemblyRef.SystemDesign, typeof(ComponentEditor)),
    Designer("System.Web.UI.Design.WebControls.DataGridDesigner, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DataGrid : BaseDataList, INamingContainer {

        private static readonly object EventCancelCommand = new object();
        private static readonly object EventDeleteCommand = new object();
        private static readonly object EventEditCommand = new object();
        private static readonly object EventItemCommand = new object();
        private static readonly object EventItemCreated = new object();
        private static readonly object EventItemDataBound = new object();
        private static readonly object EventPageIndexChanged = new object();
        private static readonly object EventSortCommand = new object();
        private static readonly object EventUpdateCommand = new object();


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.SortCommandName"]/*' />
        /// <devdoc>
        /// <para> Specifies the <see langword='Sort'/> command. This field is constant.</para>
        /// </devdoc>
        public const string SortCommandName = "Sort";
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.SelectCommandName"]/*' />
        /// <devdoc>
        /// <para> Specifies the <see langword='Select '/> command. This field is constant.</para>
        /// </devdoc>
        public const string SelectCommandName = "Select";
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.EditCommandName"]/*' />
        /// <devdoc>
        /// <para> Specifies the <see langword='Edit'/> command. This field is constant.</para>
        /// </devdoc>
        public const string EditCommandName = "Edit";
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.DeleteCommandName"]/*' />
        /// <devdoc>
        /// <para> Specifies the <see langword='Delete'/> command. This field is constant.</para>
        /// </devdoc>
        public const string DeleteCommandName = "Delete";
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.UpdateCommandName"]/*' />
        /// <devdoc>
        /// <para> Specifies the <see langword='Update'/> command. This field is constant.</para>
        /// </devdoc>
        public const string UpdateCommandName = "Update";
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CancelCommandName"]/*' />
        /// <devdoc>
        /// <para> Specifies the <see langword='Cancel'/> command. This field is constant.</para>
        /// </devdoc>
        public const string CancelCommandName = "Cancel";
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.PageCommandName"]/*' />
        /// <devdoc>
        /// <para> Specifies the <see langword='Page '/> command. This field is constant.</para>
        /// </devdoc>
        public const string PageCommandName = "Page";
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.NextPageCommandArgument"]/*' />
        /// <devdoc>
        /// <para> Specifies the <see langword='Next Page'/> argument. This field is constant.</para>
        /// </devdoc>
        public const string NextPageCommandArgument = "Next";
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.PrevPageCommandArgument"]/*' />
        /// <devdoc>
        /// <para> Specifies the <see langword='Previous Page'/> argument. This field is constant.</para>
        /// </devdoc>
        public const string PrevPageCommandArgument = "Prev";

        internal const string DataSourceItemCountViewStateKey = "_!DataSourceItemCount";

        private IEnumerator storedData;
        private object firstDataItem;
        private bool storedDataValid;
        private PagedDataSource pagedDataSource;

        private ArrayList columns;
        private DataGridColumnCollection columnCollection;

        private TableItemStyle headerStyle;
        private TableItemStyle footerStyle;
        private TableItemStyle itemStyle;
        private TableItemStyle alternatingItemStyle;
        private TableItemStyle selectedItemStyle;
        private TableItemStyle editItemStyle;
        private DataGridPagerStyle pagerStyle;

        private ArrayList itemsArray;
        private DataGridItemCollection itemsCollection;

        private ArrayList autoGenColumnsArray;

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.DataGrid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.WebControls.DataGrid'/> class.
        ///    </para>
        /// </devdoc>
        public DataGrid() {
        }


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.AllowCustomPaging"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that indicates whether custom paging is allowed.</para>
        /// </devdoc>
        [
        WebCategory("Paging"),
        DefaultValue(false),
        WebSysDescription(SR.DataGrid_AllowCustomPaging)
        ]
        public virtual bool AllowCustomPaging {
            get {
                object o = ViewState["AllowCustomPaging"];
                if (o != null)
                    return(bool)o;
                return false;
            }
            set {
                ViewState["AllowCustomPaging"] = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.AllowPaging"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that indicates whether paging is allowed.</para>
        /// </devdoc>
        [
        WebCategory("Paging"),
        DefaultValue(false),
        WebSysDescription(SR.DataGrid_AllowPaging)
        ]
        public virtual bool AllowPaging {
            get {
                object o = ViewState["AllowPaging"];
                if (o != null)
                    return(bool)o;
                return false;
            }
            set {
                ViewState["AllowPaging"] = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.AllowSorting"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that indicates whether sorting is allowed.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(false),
        WebSysDescription(SR.DataGrid_AllowSorting)
        ]
        public virtual bool AllowSorting {
            get {
                object o = ViewState["AllowSorting"];
                if (o != null)
                    return(bool)o;
                return false;
            }
            set {
                ViewState["AllowSorting"] = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.AlternatingItemStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties for alternating items in the 
        ///    <see cref='System.Web.UI.WebControls.DataGrid'/>. This 
        ///       property is read-only. </para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataGrid_AlternatingItemStyle)
        ]
        public virtual TableItemStyle AlternatingItemStyle {
            get {
                if (alternatingItemStyle == null) {
                    alternatingItemStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)alternatingItemStyle).TrackViewState();
                }
                return alternatingItemStyle;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.AutoGenerateColumns"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that indicates whether columns will automatically 
        ///       be created for each bound data field.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(true),
        WebSysDescription(SR.DataGrid_AutoGenerateColumns)
        ]
        public virtual bool AutoGenerateColumns {
            get {
                object o = ViewState["AutoGenerateColumns"];
                if (o != null)
                    return(bool)o;
                return true;
            }
            set {
                ViewState["AutoGenerateColumns"] = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.BackImageUrl"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the URL of an image to display in the 
        ///       background of the <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        Editor("System.Web.UI.Design.ImageUrlEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        WebSysDescription(SR.DataGrid_BackImageUrl)
        ]
        public virtual string BackImageUrl {
            get {
                if (ControlStyleCreated == false) {
                    return String.Empty;
                }
                return ((TableStyle)ControlStyle).BackImageUrl;
            }
            set {
                ((TableStyle)ControlStyle).BackImageUrl = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CurrentPageIndex"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the ordinal index of the currently displayed page. </para>
        /// </devdoc>
        [
        Bindable(true),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.DataGrid_CurrentPageIndex)
        ]
        public int CurrentPageIndex {
            get {
                object o = ViewState["CurrentPageIndex"];
                if (o != null)
                    return(int)o;
                return 0;
            }
            set {
                if (value < 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["CurrentPageIndex"] = value;
            }
        }


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.Columns"]/*' />
        /// <devdoc>
        /// <para>Gets a collection of <see cref='System.Web.UI.WebControls.DataGridColumn'/> controls in the <see cref='System.Web.UI.WebControls.DataGrid'/>. This property is read-only.</para>
        /// </devdoc>
        [
        DefaultValue(null),
        Editor("System.Web.UI.Design.WebControls.DataGridColumnCollectionEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        MergableProperty(false),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebCategory("Default"),
        WebSysDescription(SR.DataGrid_Columns)
        ]
        public virtual DataGridColumnCollection Columns {
            get {
                if (columnCollection == null) {
                    columns = new ArrayList();
                    columnCollection = new DataGridColumnCollection(this, columns);
                    if (IsTrackingViewState)
                        ((IStateManager)columnCollection).TrackViewState();
                }
                return columnCollection;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.EditItemIndex"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the ordinal index of the item to be edited.</para>
        /// </devdoc>
        [
        WebCategory("Default"),
        DefaultValue(-1),
        WebSysDescription(SR.DataGrid_EditItemIndex)
        ]
        public virtual int EditItemIndex {
            get {
                object o = ViewState["EditItemIndex"];
                if (o != null)
                    return(int)o;
                return -1;
            }
            set {
                if (value < -1) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["EditItemIndex"] = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.EditItemStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties of the item to be edited. This property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataGrid_EditItemStyle)
        ]
        public virtual TableItemStyle EditItemStyle {
            get {
                if (editItemStyle == null) {
                    editItemStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)editItemStyle).TrackViewState();
                }
                return editItemStyle;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.FooterStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties of the footer item. This property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataGrid_FooterStyle),
        ]
        public virtual TableItemStyle FooterStyle {
            get {
                if (footerStyle == null) {
                    footerStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)footerStyle).TrackViewState();
                }
                return footerStyle;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HeaderStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties of the header item. This property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataGrid_HeaderStyle)
        ]
        public virtual TableItemStyle HeaderStyle {
            get {
                if (headerStyle == null) {
                    headerStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)headerStyle).TrackViewState();
                }
                return headerStyle;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.Items"]/*' />
        /// <devdoc>
        /// <para>Gets a collection of <see cref='System.Web.UI.WebControls.DataGridItem'/> objects representing the individual 
        ///    items within the control.
        ///    This property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.DataGrid_Items)
        ]
        public virtual DataGridItemCollection Items {
            get {
                if (itemsCollection == null) {
                    if (itemsArray == null) {
                        EnsureChildControls();
                    }
                    if (itemsArray == null) {
                        itemsArray = new ArrayList();
                    }
                    itemsCollection = new DataGridItemCollection(itemsArray);
                }
                return itemsCollection;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ItemStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties of the individual items. This property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataGrid_ItemStyle),
        ]
        public virtual TableItemStyle ItemStyle {
            get {
                if (itemStyle == null) {
                    itemStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)itemStyle).TrackViewState();
                }
                return itemStyle;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.PageCount"]/*' />
        /// <devdoc>
        ///    <para>Gets the total number of pages to be displayed. This property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.DataGrid_PageCount)
        ]
        public int PageCount {
            get {
                if (pagedDataSource != null) {
                    return pagedDataSource.PageCount;
                }
                else {
                    object o = ViewState["PageCount"];
                    return (o != null) ? (int)o : 0;
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.PagerStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties of the pager buttons for the 
        ///    <see cref='System.Web.UI.WebControls.DataGrid'/>. This 
        ///       property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataGrid_PagerStyle)
        ]
        public virtual DataGridPagerStyle PagerStyle {
            get {
                if (pagerStyle == null) {
                    pagerStyle = new DataGridPagerStyle(this);
                    if (IsTrackingViewState)
                        ((IStateManager)pagerStyle).TrackViewState();
                }
                return pagerStyle;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.PageSize"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the number of items to display on a single page.</para>
        /// </devdoc>
        [
        WebCategory("Paging"),
        DefaultValue(10),
        WebSysDescription(SR.DataGrid_PageSize),
        ]
        public virtual int PageSize {
            get {
                object o = ViewState["PageSize"];
                if (o != null)
                    return(int)o;
                return 10;
            }
            set {
                if (value < 1) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["PageSize"] = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.SelectedIndex"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the index of the currently selected item.</para>
        /// </devdoc>
        [
        Bindable(true),
        DefaultValue(-1),
        WebSysDescription(SR.DataGrid_SelectedIndex)
        ]
        public virtual int SelectedIndex {
            get {
                object o = ViewState["SelectedIndex"];
                if (o != null)
                    return(int)o;
                return -1;
            }
            set {
                if (value < -1) {
                    throw new ArgumentOutOfRangeException("value");
                }
                int oldSelectedIndex = SelectedIndex;
                ViewState["SelectedIndex"] = value;

                if (itemsArray != null) {
                    DataGridItem item;

                    if ((oldSelectedIndex != -1) && (itemsArray.Count > oldSelectedIndex)) {
                        item = (DataGridItem)itemsArray[oldSelectedIndex];

                        if (item.ItemType != ListItemType.EditItem) {
                            ListItemType itemType = ListItemType.Item;
                            if (oldSelectedIndex % 2 != 0)
                                itemType = ListItemType.AlternatingItem;
                            item.SetItemType(itemType);
                        }
                    }
                    if ((value != -1) && (itemsArray.Count > value)) {
                        item = (DataGridItem)itemsArray[value];
                        if (item.ItemType != ListItemType.EditItem)
                            item.SetItemType(ListItemType.SelectedItem);
                    }
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.SelectedItem"]/*' />
        /// <devdoc>
        /// <para>Gets the selected item in the <see cref='System.Web.UI.WebControls.DataGrid'/>. This property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.DataGrid_SelectedItem)
        ]
        public virtual DataGridItem SelectedItem {
            get {
                int index = SelectedIndex;
                DataGridItem item = null;

                if (index != -1) {
                    item = Items[index];
                }
                return item;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.SelectedItemStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties of the currently selected item. This property is read-only.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataGrid_SelectedItemStyle)
        ]
        public virtual TableItemStyle SelectedItemStyle {
            get {
                if (selectedItemStyle == null) {
                    selectedItemStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)selectedItemStyle).TrackViewState();
                }
                return selectedItemStyle;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShowFooter"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that specifies whether the footer is displayed in the 
        ///    <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(false),
        WebSysDescription(SR.DataGrid_ShowFooter)
        ]
        public virtual bool ShowFooter {
            get {
                object o = ViewState["ShowFooter"];
                if (o != null)
                    return(bool)o;
                return false;
            }
            set {
                ViewState["ShowFooter"] = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShowHeader"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that specifies whether the header is displayed in the 
        ///    <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(true),
        WebSysDescription(SR.DataGrid_ShowHeader)
        ]
        public virtual bool ShowHeader {
            get {
                object o = ViewState["ShowHeader"];
                if (o != null)
                    return(bool)o;
                return true;
            }
            set {
                ViewState["ShowHeader"] = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.VirtualItemCount"]/*' />
        /// <devdoc>
        ///    Gets or sets the number of rows to display in the
        /// <see cref='System.Web.UI.WebControls.DataGrid'/>.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.DataGrid_VisibleItemCount)
        ]
        public virtual int VirtualItemCount {
            get {
                object o = ViewState["VirtualItemCount"];
                if (o != null)
                    return(int)o;
                return 0;
            }
            set {
                if (value < 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["VirtualItemCount"] = value;
            }
        }



        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CancelCommand"]/*' />
        /// <devdoc>
        /// <para>Occurs when a control bubbles an event to the <see cref='System.Web.UI.WebControls.DataGrid'/> with a 
        /// <see langword='Command'/> property of 
        /// <see langword='cancel'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.DataGrid_OnCancelCommand)
        ]
        public event DataGridCommandEventHandler CancelCommand {
            add {
                Events.AddHandler(EventCancelCommand, value);
            }
            remove {
                Events.RemoveHandler(EventCancelCommand, value);
            }
        }


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.DeleteCommand"]/*' />
        /// <devdoc>
        /// <para>Occurs when a control bubbles an event to the <see cref='System.Web.UI.WebControls.DataGrid'/> with a 
        /// <see langword='Command'/> property of <see langword='delete'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.DataGrid_OnDeleteCommand)
        ]
        public event DataGridCommandEventHandler DeleteCommand {
            add {
                Events.AddHandler(EventDeleteCommand, value);
            }
            remove {
                Events.RemoveHandler(EventDeleteCommand, value);
            }
        }


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.EditCommand"]/*' />
        /// <devdoc>
        /// <para>Occurs when a control bubbles an event to the <see cref='System.Web.UI.WebControls.DataGrid'/> with a 
        /// <see langword='Command'/> property of 
        /// <see langword='edit'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.DataGrid_OnEditCommand)
        ]
        public event DataGridCommandEventHandler EditCommand {
            add {
                Events.AddHandler(EventEditCommand, value);
            }
            remove {
                Events.RemoveHandler(EventEditCommand, value);
            }
        }


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ItemCommand"]/*' />
        /// <devdoc>
        /// <para>Occurs when a control bubbles an event to the <see cref='System.Web.UI.WebControls.DataGrid'/> not covered by 
        /// <see langword='edit'/>, <see langword='cancel'/>, <see langword='delete'/> or 
        /// <see langword='update'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.DataGrid_OnItemCommand)
        ]
        public event DataGridCommandEventHandler ItemCommand {
            add {
                Events.AddHandler(EventItemCommand, value);
            }
            remove {
                Events.RemoveHandler(EventItemCommand, value);
            }
        }


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ItemCreated"]/*' />
        /// <devdoc>
        ///    <para>Occurs on the server when a control a created.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        WebSysDescription(SR.DataGrid_OnItemCreated)
        ]
        public event DataGridItemEventHandler ItemCreated {
            add {
                Events.AddHandler(EventItemCreated, value);
            }
            remove {
                Events.RemoveHandler(EventItemCreated, value);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ItemDataBound"]/*' />
        /// <devdoc>
        ///    <para>Occurs when an item is data bound to the control.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        WebSysDescription(SR.DataGrid_OnItemDataBound)
        ]
        public event DataGridItemEventHandler ItemDataBound {
            add {
                Events.AddHandler(EventItemDataBound, value);
            }
            remove {
                Events.RemoveHandler(EventItemDataBound, value);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.PageIndexChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs the one of the pager buttons is clicked.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.DataGrid_OnPageIndexChanged)
        ]
        public event DataGridPageChangedEventHandler PageIndexChanged {
            add {
                Events.AddHandler(EventPageIndexChanged, value);
            }
            remove {
                Events.RemoveHandler(EventPageIndexChanged, value);
            }
        }



        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.SortCommand"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a column is sorted.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.DataGrid_OnSortCommand)
        ]
        public event DataGridSortCommandEventHandler SortCommand {
            add {
                Events.AddHandler(EventSortCommand, value);
            }
            remove {
                Events.RemoveHandler(EventSortCommand, value);
            }
        }


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.UpdateCommand"]/*' />
        /// <devdoc>
        /// <para>Occurs when a control bubbles an event to the <see cref='System.Web.UI.WebControls.DataGrid'/> with a 
        /// <see langword='Command'/> property of <see langword='update'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.DataGrid_OnUpdateCommand)
        ]
        public event DataGridCommandEventHandler UpdateCommand {
            add {
                Events.AddHandler(EventUpdateCommand, value);
            }
            remove {
                Events.RemoveHandler(EventUpdateCommand, value);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.StoreEnumerator"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///  Caches the fact that we have already consumed the first item from the enumeration
        ///  and must use it first during our item creation.
        /// </devdoc>
        internal void StoreEnumerator(IEnumerator dataSource, object firstDataItem) {
            this.storedData = dataSource;
            this.firstDataItem = firstDataItem;

            this.storedDataValid = true;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CreateAutoGeneratedColumns"]/*' />
        /// <devdoc>
        /// </devdoc>
        private ArrayList CreateAutoGeneratedColumns(PagedDataSource dataSource) {
            if (dataSource == null) {
                // note that we're not throwing an exception in this case, and the calling
                // code should be able to handle a null arraylist being returned
                return null;
            }
            
            ArrayList generatedColumns = new ArrayList();
            PropertyDescriptorCollection propDescs = null;
            bool throwException = true;

            // try ITypedList first
            // A PagedDataSource implements this, but returns null, if the underlying data source
            // does not implement it.
            propDescs = ((ITypedList)dataSource).GetItemProperties(new PropertyDescriptor[0]);

            if (propDescs == null) {
                Type sampleItemType = null;
                object sampleItem = null;

                IEnumerable realDataSource = dataSource.DataSource;
                Debug.Assert(realDataSource != null, "Must have a real data source when calling CreateAutoGeneratedColumns");

                Type dataSourceType = realDataSource.GetType();

                // try for a typed Item property, which should be present on strongly typed collections
                PropertyInfo itemProp = dataSourceType.GetProperty("Item", BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static, null, null, new Type[] { typeof(int) }, null);
                if (itemProp != null) {
                    sampleItemType = itemProp.PropertyType;
                }

                if ((sampleItemType == null) || (sampleItemType == typeof(object))) {
                    // last resort... try to get ahold of the first item by beginning the
                    // enumeration

                    IEnumerator e = dataSource.GetEnumerator();

                    if (e.MoveNext()) {
                        sampleItem = e.Current;
                    }
                    else {
                        // we don't want to throw an exception if we're bound to an IEnumerable
                        // data source with no records... we'll simply bail and not show any data
                        throwException = false;
                    }
                    if (sampleItem != null) {
                        sampleItemType = sampleItem.GetType();
                    }

                    // We must store the enumerator regardless of whether we got back an item from it
                    // because we cannot start the enumeration again, in the case of a DataReader.
                    // Code in CreateControlHierarchy must deal appropriately for the case where
                    // there is a stored enumerator, but a null object as the first item.
                    StoreEnumerator(e, sampleItem);
                }

                if ((sampleItem != null) && (sampleItem is ICustomTypeDescriptor)) {
                    // Get the custom properties of the object
                    propDescs = TypeDescriptor.GetProperties(sampleItem);
                }
                else if (sampleItemType != null) {
                    // directly bindable types: strings, ints etc. get treated special, since we
                    // don't care about their properties, but rather we care about them directly
                    if (BaseDataList.IsBindableType(sampleItemType)) {
                        BoundColumn column = new BoundColumn();

                        ((IStateManager)column).TrackViewState();
                        column.HeaderText = "Item";
                        column.DataField = BoundColumn.thisExpr;
                        column.SortExpression = "Item";

                        column.SetOwner(this);
                        generatedColumns.Add(column);
                    }
                    else {
                        // complex type... we get its properties
                        propDescs = TypeDescriptor.GetProperties(sampleItemType);
                    }
                }
            }

            if ((propDescs != null) && (propDescs.Count != 0)) {
                foreach (PropertyDescriptor pd in propDescs) {
                    Type propType = pd.PropertyType;

                    if (BaseDataList.IsBindableType(propType)) {
                        BoundColumn column = new BoundColumn();

                        ((IStateManager)column).TrackViewState();
                        column.HeaderText = pd.Name;
                        column.DataField = pd.Name;
                        column.SortExpression = pd.Name;
                        column.ReadOnly = pd.IsReadOnly;

                        column.SetOwner(this);
                        generatedColumns.Add(column);
                    }
                }
            }

            if ((generatedColumns.Count == 0) && throwException) {
                // this handles the case where we got back something that either had no
                // properties, or all properties were not bindable.
                throw new HttpException(HttpRuntime.FormatResourceString(SR.DataGrid_NoAutoGenColumns, ID));
            }

            return generatedColumns;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CreateColumnSet"]/*' />
        /// <devdoc>
        ///   Creates the set of columns to be used to build up the control
        ///   hierarchy.
        ///   When AutoGenerateColumns is true, the columns are created to match the
        ///   datasource and are appended to the set of columns defined in the Columns
        ///   collection.
        /// </devdoc>
        protected virtual ArrayList CreateColumnSet(PagedDataSource dataSource, bool useDataSource) {
            ArrayList columnsArray = new ArrayList();
            
            DataGridColumn[] definedColumns = new DataGridColumn[Columns.Count];
            Columns.CopyTo(definedColumns, 0);
            
            int i;

            for (i = 0; i < definedColumns.Length; i++)
                columnsArray.Add(definedColumns[i]);

            if (AutoGenerateColumns == true) {
                ArrayList autoColumns = null;
                if (useDataSource) {
                    autoColumns = CreateAutoGeneratedColumns(dataSource);
                    autoGenColumnsArray = autoColumns;
                }
                else {
                    autoColumns = autoGenColumnsArray;
                }

                if (autoColumns != null) {
                    int autoColumnCount = autoColumns.Count;

                    for (i = 0; i < autoColumnCount; i++)
                        columnsArray.Add(autoColumns[i]);
                }
            }

            return columnsArray;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CreateControlHierarchy"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Creates the control hierarchy that is used to render the DataGrid.
        ///       This is called whenever a control hierarchy is needed and the
        ///       ChildControlsCreated property is false.
        ///       The implementation assumes that all the children in the controls
        ///       collection have already been cleared.</para>
        /// </devdoc>
        protected override void CreateControlHierarchy(bool useDataSource) {
            pagedDataSource = CreatePagedDataSource();

            IEnumerator dataSource = null;
            int count = -1;
            int totalCount = -1;
            ArrayList keysArray = DataKeysArray;
            ArrayList columnsArray = null;

            if (itemsArray != null) {
                itemsArray.Clear();
            }
            else {
                itemsArray = new ArrayList();
            }

            if (useDataSource == false) {
                // ViewState must have a non-null value for ItemCount because we check for
                // this in CreateChildControls
                count = (int)ViewState[BaseDataList.ItemCountViewStateKey];
                totalCount = (int)ViewState[DataSourceItemCountViewStateKey];

                if (count != -1) {
                    if (pagedDataSource.IsCustomPagingEnabled) {
                        pagedDataSource.DataSource = new DummyDataSource(count);
                    }
                    else {
                        pagedDataSource.DataSource = new DummyDataSource(totalCount);
                    }
                    dataSource = pagedDataSource.GetEnumerator();
                    columnsArray = CreateColumnSet(null, false);

                    itemsArray.Capacity = count;
                }
            }
            else {
                keysArray.Clear();

                IEnumerable realDataSource = DataSourceHelper.GetResolvedDataSource(this.DataSource, this.DataMember);

                if (realDataSource != null) {
                    ICollection collection = realDataSource as ICollection;

                    if ((collection == null) &&
                        pagedDataSource.IsPagingEnabled && !pagedDataSource.IsCustomPagingEnabled) {
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.DataGrid_Missing_VirtualItemCount, ID));
                    }

                    pagedDataSource.DataSource = realDataSource;
                    if (pagedDataSource.IsPagingEnabled) {
                        if ((pagedDataSource.CurrentPageIndex < 0) || (pagedDataSource.CurrentPageIndex >= pagedDataSource.PageCount)) {
                            throw new HttpException(SR.GetString(SR.Invalid_CurrentPageIndex));
                        }
                    }
                    columnsArray = CreateColumnSet(pagedDataSource, useDataSource);

                    if (storedDataValid) {
                        dataSource = storedData;
                    }
                    else {
                        dataSource = pagedDataSource.GetEnumerator();
                    }

                    if (collection != null) {
                        int initialCapacity = pagedDataSource.Count;
                        keysArray.Capacity = initialCapacity;
                        itemsArray.Capacity = initialCapacity;
                    }
                }
            }

            int columnCount = 0;
            if (columnsArray != null)
                columnCount = columnsArray.Count;

            if (columnCount > 0) {
                DataGridColumn[] displayColumns = new DataGridColumn[columnCount];
                columnsArray.CopyTo(displayColumns, 0);

                for (int c = 0; c < displayColumns.Length; c++) {
                    displayColumns[c].Initialize();
                }
                
                Table table = new DataGridTable();
                Controls.Add(table);

                TableRowCollection rows = table.Rows;
                DataGridItem item;
                ListItemType itemType;
                int index = 0;
                int dataSetIndex = 0;

                string keyField = DataKeyField;
                bool storeKeys = (useDataSource && (keyField.Length != 0));
                bool createPager = pagedDataSource.IsPagingEnabled;
                int editItemIndex = EditItemIndex;
                int selectedItemIndex = SelectedIndex;

                if (pagedDataSource.IsPagingEnabled)
                    dataSetIndex = pagedDataSource.FirstIndexInPage;

                count = 0;

                if (createPager) {
                    // top pager
                    CreateItem(-1, -1, ListItemType.Pager, false, null, displayColumns, rows, pagedDataSource);
                }

                CreateItem(-1, -1, ListItemType.Header, useDataSource, null, displayColumns, rows, null);

                if (storedDataValid && (firstDataItem != null)) {
                    if (storeKeys) {
                        object keyValue = DataBinder.GetPropertyValue(firstDataItem, keyField);
                        keysArray.Add(keyValue);
                    }

                    itemType = ListItemType.Item;
                    if (index == editItemIndex)
                        itemType = ListItemType.EditItem;
                    else if (index == selectedItemIndex)
                        itemType = ListItemType.SelectedItem;

                    item = CreateItem(0, dataSetIndex, itemType, useDataSource, firstDataItem, displayColumns, rows, null);
                    itemsArray.Add(item);

                    count++;
                    index++;
                    dataSetIndex++;

                    storedDataValid = false;
                    firstDataItem = null;
                }

                while (dataSource.MoveNext()) {
                    object dataItem = dataSource.Current;

                    if (storeKeys) {
                        object keyValue = DataBinder.GetPropertyValue(dataItem, keyField);
                        keysArray.Add(keyValue);
                    }

                    itemType = ListItemType.Item;

                    if (index == editItemIndex)
                        itemType = ListItemType.EditItem;
                    else if (index == selectedItemIndex)
                        itemType = ListItemType.SelectedItem;
                    else if (index % 2 != 0) {
                        itemType = ListItemType.AlternatingItem;
                    }

                    item = CreateItem(index, dataSetIndex, itemType, useDataSource, dataItem, displayColumns, rows, null);
                    itemsArray.Add(item);

                    count++;
                    dataSetIndex++;
                    index++;
                }

                CreateItem(-1, -1, ListItemType.Footer, useDataSource, null, displayColumns, rows, null);

                if (createPager) {
                    // bottom pager
                    CreateItem(-1, -1, ListItemType.Pager, false, null, displayColumns, rows, pagedDataSource);
                }
            }

            if (useDataSource) {
                // save the number of items and pages contained in the DataGrid for use in round-trips
                if (dataSource != null) {
                    ViewState[BaseDataList.ItemCountViewStateKey] = count;
                    if (pagedDataSource.IsPagingEnabled) {
                        ViewState["PageCount"] = pagedDataSource.PageCount;
                        ViewState[DataSourceItemCountViewStateKey] = pagedDataSource.DataSourceCount;
                    }
                    else {
                        ViewState["PageCount"] = 1;
                        ViewState[DataSourceItemCountViewStateKey] = count;
                    }
                }
                else {
                    ViewState[BaseDataList.ItemCountViewStateKey] = -1;
                    ViewState[DataSourceItemCountViewStateKey] = -1;
                    ViewState["PageCount"] = 0;
                }
            }

            pagedDataSource = null;
        }
        
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CreateControlStyle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Creates new control style.</para>
        /// </devdoc>
        protected override Style CreateControlStyle() {
            TableStyle style = new TableStyle(ViewState);

            // initialize defaults that are different from TableStyle
            style.GridLines = GridLines.Both;
            style.CellSpacing = 0;

            return style;
        }

        private DataGridItem CreateItem(int itemIndex, int dataSourceIndex, ListItemType itemType, bool dataBind, object dataItem, DataGridColumn[] columns, TableRowCollection rows, PagedDataSource pagedDataSource) {
            DataGridItem item = CreateItem(itemIndex, dataSourceIndex, itemType);
            DataGridItemEventArgs e = new DataGridItemEventArgs(item);

            if (itemType != ListItemType.Pager) {
                InitializeItem(item, columns);
                if (dataBind) {
                    item.DataItem = dataItem;
                }
                OnItemCreated(e);
                rows.Add(item);

                if (dataBind) {
                    item.DataBind();
                    OnItemDataBound(e);

                    item.DataItem = null;
                }
            }
            else {
                InitializePager(item, columns.Length, pagedDataSource);
                OnItemCreated(e);
                rows.Add(item);
            }

            return item;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CreateItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual DataGridItem CreateItem(int itemIndex, int dataSourceIndex, ListItemType itemType) {
            return new DataGridItem(itemIndex, dataSourceIndex, itemType);
        }

        private PagedDataSource CreatePagedDataSource() {
            PagedDataSource pagedDataSource = new PagedDataSource();

            pagedDataSource.CurrentPageIndex = CurrentPageIndex;
            pagedDataSource.PageSize = PageSize;
            pagedDataSource.AllowPaging = AllowPaging;
            pagedDataSource.AllowCustomPaging = AllowCustomPaging;
            pagedDataSource.VirtualCount = VirtualItemCount;

            return pagedDataSource;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.InitializeItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void InitializeItem(DataGridItem item, DataGridColumn[] columns) {
            TableCellCollection cells = item.Cells;

            for (int i = 0; i < columns.Length; i++) {
                TableCell cell = new TableCell();

                columns[i].InitializeCell(cell, i, item.ItemType);
                cells.Add(cell);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.InitializePager"]/*' />
        /// <devdoc>
        ///    <para>
        ///   Creates a DataGridItem that contains the paging UI.
        ///   The paging UI is a navigation bar that is a built into a single TableCell that
        ///   spans across all columns of the DataGrid.
        ///    </para>
        /// </devdoc>
        protected virtual void InitializePager(DataGridItem item, int columnSpan, PagedDataSource pagedDataSource) {
            TableCell cell = new TableCell();
            cell.ColumnSpan = columnSpan;

            DataGridPagerStyle pagerStyle = PagerStyle;

            if (pagerStyle.Mode == PagerMode.NextPrev) {
                if (pagedDataSource.IsFirstPage == false) {
                    LinkButton prevButton = new DataGridLinkButton();
                    prevButton.Text = pagerStyle.PrevPageText;
                    prevButton.CommandName = DataGrid.PageCommandName;
                    prevButton.CommandArgument = DataGrid.PrevPageCommandArgument;
                    prevButton.CausesValidation = false;
                    cell.Controls.Add(prevButton);
                }
                else {
                    Label prevLabel = new Label();
                    prevLabel.Text = pagerStyle.PrevPageText;
                    cell.Controls.Add(prevLabel);
                }

                cell.Controls.Add(new LiteralControl("&nbsp;"));

                if (pagedDataSource.IsLastPage == false) {
                    LinkButton nextButton = new DataGridLinkButton();
                    nextButton.Text = pagerStyle.NextPageText;
                    nextButton.CommandName = DataGrid.PageCommandName;
                    nextButton.CommandArgument = DataGrid.NextPageCommandArgument;
                    nextButton.CausesValidation = false;
                    cell.Controls.Add(nextButton);
                }
                else {
                    Label nextLabel = new Label();
                    nextLabel.Text = pagerStyle.NextPageText;
                    cell.Controls.Add(nextLabel);
                }
            }
            else {
                int pages = pagedDataSource.PageCount;
                int currentPage = pagedDataSource.CurrentPageIndex + 1;
                int pageSetSize = pagerStyle.PageButtonCount;
                int pagesShown = pageSetSize;

                // ensure the number of pages we show isn't more than the number of pages that do exist
                if (pages < pagesShown)
                    pagesShown = pages;

                // initialze to the first page set, i.e., pages 1 through number of pages shown
                int firstPage = 1;
                int lastPage = pagesShown;

                if (currentPage > lastPage) {
                    // The current page is not in the first page set, then we need to slide the
                    // range of pages shown by adjusting firstPage and lastPage
                    int currentPageSet = pagedDataSource.CurrentPageIndex / pageSetSize;
                    firstPage = currentPageSet * pageSetSize + 1;
                    lastPage = firstPage + pageSetSize - 1;

                    // now bring back lastPage into the range if its exceeded the number of pages
                    if (lastPage > pages)
                        lastPage = pages;

                    // if theres room to show more pages from the previous page set, then adjust
                    // the first page accordingly
                    if (lastPage - firstPage + 1 < pageSetSize) {
                        firstPage = Math.Max(1, lastPage - pageSetSize + 1);
                    }
                }

                LinkButton button;

                if (firstPage != 1) {
                    button = new DataGridLinkButton();

                    button.Text = "...";
                    button.CommandName = DataGrid.PageCommandName;
                    button.CommandArgument = (firstPage - 1).ToString(NumberFormatInfo.InvariantInfo);
                    button.CausesValidation = false;
                    cell.Controls.Add(button);

                    cell.Controls.Add(new LiteralControl("&nbsp;"));
                }

                for (int i = firstPage; i <= lastPage; i++) {
                    string pageString = (i).ToString(NumberFormatInfo.InvariantInfo);
                    if (i == currentPage) {
                        Label label = new Label();

                        label.Text = pageString;
                        cell.Controls.Add(label);
                    }
                    else {
                        button = new DataGridLinkButton();

                        button.Text = pageString;
                        button.CommandName = DataGrid.PageCommandName;
                        button.CommandArgument = pageString;
                        button.CausesValidation = false;
                        cell.Controls.Add(button);
                    }

                    if (i < lastPage) {
                        cell.Controls.Add(new LiteralControl("&nbsp;"));
                    }
                }

                if (pages > lastPage) {
                    cell.Controls.Add(new LiteralControl("&nbsp;"));

                    button = new DataGridLinkButton();

                    button.Text = "...";
                    button.CommandName = DataGrid.PageCommandName;
                    button.CommandArgument = (lastPage + 1).ToString(NumberFormatInfo.InvariantInfo);
                    button.CausesValidation = false;
                    cell.Controls.Add(button);
                }
            }

            item.Cells.Add(cell);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Loads a saved state of the <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
        /// </devdoc>
        protected override void LoadViewState(object savedState) {
            if (savedState != null) {
                object[] myState = (object[])savedState;

                if (myState[0] != null)
                    base.LoadViewState(myState[0]);
                if (myState[1] != null)
                    ((IStateManager)Columns).LoadViewState(myState[1]);
                if (myState[2] != null)
                    ((IStateManager)PagerStyle).LoadViewState(myState[2]);
                if (myState[3] != null)
                    ((IStateManager)HeaderStyle).LoadViewState(myState[3]);
                if (myState[4] != null)
                    ((IStateManager)FooterStyle).LoadViewState(myState[4]);
                if (myState[5] != null)
                    ((IStateManager)ItemStyle).LoadViewState(myState[5]);
                if (myState[6] != null)
                    ((IStateManager)AlternatingItemStyle).LoadViewState(myState[6]);
                if (myState[7] != null)
                    ((IStateManager)SelectedItemStyle).LoadViewState(myState[7]);
                if (myState[8] != null)
                    ((IStateManager)EditItemStyle).LoadViewState(myState[8]);

                if (myState[9] != null) {
                    object[] autoGenColumnState = (object[])myState[9];
                    int columnCount = autoGenColumnState.Length;

                    if (columnCount != 0)
                        autoGenColumnsArray = new ArrayList();
                    else
                        autoGenColumnsArray = null;

                    for (int i = 0; i < columnCount; i++) {
                        BoundColumn column = new BoundColumn();

                        ((IStateManager)column).TrackViewState();
                        ((IStateManager)column).LoadViewState(autoGenColumnState[i]);

                        column.SetOwner(this);
                        autoGenColumnsArray.Add(column);
                    }
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.TrackViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Marks the starting point to begin tracking and saving changes to the 
        ///       control as part of the control viewstate.</para>
        /// </devdoc>
        protected override void TrackViewState() {
            base.TrackViewState();

            if (columnCollection != null)
                ((IStateManager)columnCollection).TrackViewState();
            if (pagerStyle != null)
                ((IStateManager)pagerStyle).TrackViewState();
            if (headerStyle != null)
                ((IStateManager)headerStyle).TrackViewState();
            if (footerStyle != null)
                ((IStateManager)footerStyle).TrackViewState();
            if (itemStyle != null)
                ((IStateManager)itemStyle).TrackViewState();
            if (alternatingItemStyle != null)
                ((IStateManager)alternatingItemStyle).TrackViewState();
            if (selectedItemStyle != null)
                ((IStateManager)selectedItemStyle).TrackViewState();
            if (editItemStyle != null)
                ((IStateManager)editItemStyle).TrackViewState();
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnBubbleEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override bool OnBubbleEvent(object source, EventArgs e) {
            bool handled = false;

            if (e is DataGridCommandEventArgs) {
                DataGridCommandEventArgs dce = (DataGridCommandEventArgs)e;

                OnItemCommand(dce);
                handled = true;

                string command = dce.CommandName;

                if (String.Compare(command, DataGrid.SelectCommandName, true, CultureInfo.InvariantCulture) == 0) {
                    SelectedIndex = dce.Item.ItemIndex;
                    OnSelectedIndexChanged(EventArgs.Empty);
                }
                else if (String.Compare(command, DataGrid.PageCommandName, true, CultureInfo.InvariantCulture) == 0) {
                    string pageNumberArg = (string)dce.CommandArgument;

                    int newPage = CurrentPageIndex;

                    if (String.Compare(pageNumberArg, DataGrid.NextPageCommandArgument, true, CultureInfo.InvariantCulture) == 0) {
                        newPage++;
                    }
                    else if (String.Compare(pageNumberArg, DataGrid.PrevPageCommandArgument, true, CultureInfo.InvariantCulture) == 0) {
                        newPage--;
                    }
                    else {
                        // argument is page number, and page index is 1 less than that
                        newPage = Int32.Parse(pageNumberArg) - 1;
                    }

                    DataGridPageChangedEventArgs args = new DataGridPageChangedEventArgs(source, newPage);
                    OnPageIndexChanged(args);
                }
                else if (String.Compare(command, DataGrid.SortCommandName, true, CultureInfo.InvariantCulture) == 0) {
                    DataGridSortCommandEventArgs args = new DataGridSortCommandEventArgs(source, dce);
                    OnSortCommand(args);
                }
                else if (String.Compare(command, DataGrid.EditCommandName, true, CultureInfo.InvariantCulture) == 0) {
                    OnEditCommand(dce);
                }
                else if (String.Compare(command, DataGrid.UpdateCommandName, true, CultureInfo.InvariantCulture) == 0) {
                    OnUpdateCommand(dce);
                }
                else if (String.Compare(command, DataGrid.CancelCommandName, true, CultureInfo.InvariantCulture) == 0) {
                    OnCancelCommand(dce);
                }
                else if (String.Compare(command, DataGrid.DeleteCommandName, true, CultureInfo.InvariantCulture) == 0) {
                    OnDeleteCommand(dce);
                }
            }

            return handled;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnColumnsChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal void OnColumnsChanged() {
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnCancelCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='CancelCommand '/>event.</para>
        /// </devdoc>
        protected virtual void OnCancelCommand(DataGridCommandEventArgs e) {
            DataGridCommandEventHandler handler = (DataGridCommandEventHandler)Events[EventCancelCommand];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnDeleteCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='DeleteCommand'/> event.</para>
        /// </devdoc>
        protected virtual void OnDeleteCommand(DataGridCommandEventArgs e) {
            DataGridCommandEventHandler handler = (DataGridCommandEventHandler)Events[EventDeleteCommand];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnEditCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='EditCommand'/> event.</para>
        /// </devdoc>
        protected virtual void OnEditCommand(DataGridCommandEventArgs e) {
            DataGridCommandEventHandler handler = (DataGridCommandEventHandler)Events[EventEditCommand];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnItemCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='ItemCommand'/> event.</para>
        /// </devdoc>
        protected virtual void OnItemCommand(DataGridCommandEventArgs e) {
            DataGridCommandEventHandler handler = (DataGridCommandEventHandler)Events[EventItemCommand];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnItemCreated"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='ItemCreated'/> event.</para>
        /// </devdoc>
        protected virtual void OnItemCreated(DataGridItemEventArgs e) {
            DataGridItemEventHandler handler = (DataGridItemEventHandler)Events[EventItemCreated];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnItemDataBound"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='ItemDataBound'/> event.</para>
        /// </devdoc>
        protected virtual void OnItemDataBound(DataGridItemEventArgs e) {
            DataGridItemEventHandler handler = (DataGridItemEventHandler)Events[EventItemDataBound];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnPageIndexChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='PageIndexChanged'/> event.</para>
        /// </devdoc>
        protected virtual void OnPageIndexChanged(DataGridPageChangedEventArgs e) {
            DataGridPageChangedEventHandler handler = (DataGridPageChangedEventHandler)Events[EventPageIndexChanged];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnPagerChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal void OnPagerChanged() {
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnSortCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='SortCommand'/> event.</para>
        /// </devdoc>
        protected virtual void OnSortCommand(DataGridSortCommandEventArgs e) {
            DataGridSortCommandEventHandler handler = (DataGridSortCommandEventHandler)Events[EventSortCommand];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnUpdateCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='UpdateCommand'/> event.</para>
        /// </devdoc>
        protected virtual void OnUpdateCommand(DataGridCommandEventArgs e) {
            DataGridCommandEventHandler handler = (DataGridCommandEventHandler)Events[EventUpdateCommand];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.PrepareControlHierarchy"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void PrepareControlHierarchy() {
            if (Controls.Count == 0)
                return;

            Table childTable = (Table)Controls[0];
            childTable.CopyBaseAttributes(this);
            if (ControlStyleCreated) {
                childTable.ApplyStyle(ControlStyle);
            }
            else {
                // Since we didn't create a ControlStyle yet, the default
                // settings for the default style of the control need to be applied
                // to the child table control directly
                // REVIEW: if there are more properties that fall in this bucket, it might
                //         make sense to have a function that both this and CreateControlStyle call
                childTable.GridLines = GridLines.Both;
                childTable.CellSpacing = 0;
            }

            TableRowCollection rows = childTable.Rows;
            int rowCount = rows.Count;

            if (rowCount == 0)
                return;


            int columnCount = Columns.Count;
            DataGridColumn[] definedColumns = new DataGridColumn[columnCount];
            if (columnCount > 0)
                Columns.CopyTo(definedColumns, 0);

            // the composite alternating item style, so we need to do just one
            // merge style on the actual item
            Style altItemStyle = null;
            if (alternatingItemStyle != null) {
                altItemStyle = new TableItemStyle();
                altItemStyle.CopyFrom(itemStyle);
                altItemStyle.CopyFrom(alternatingItemStyle);
            }
            else {
                altItemStyle = itemStyle;
            }

            for (int i = 0; i < rowCount; i++) {
                DataGridItem item = (DataGridItem)rows[i];

                switch (item.ItemType) {
                    case ListItemType.Header:
                        if (ShowHeader == false) {
                            item.Visible = false;
                            continue;   // with the next row
                        }
                        else {
                            if (headerStyle != null) {
                                item.MergeStyle(headerStyle);
                            }
                        }
                        break;

                    case ListItemType.Footer:
                        if (ShowFooter == false) {
                            item.Visible = false;
                            continue;   // with the next row
                        }
                        else {
                            item.MergeStyle(footerStyle);
                        }
                        break;

                    case ListItemType.Pager:
                        if (pagerStyle.Visible == false) {
                            item.Visible = false;
                            continue;   // with the next row
                        }
                        else {
                            if (i == 0) {
                                // top pager
                                if (pagerStyle.IsPagerOnTop == false) {
                                    item.Visible = false;
                                    continue;
                                }
                            }
                            else {
                                // bottom pager
                                if (pagerStyle.IsPagerOnBottom == false) {
                                    item.Visible = false;
                                    continue;
                                }
                            }
                            
                            item.MergeStyle(pagerStyle);
                        }
                        break;

                    case ListItemType.Item:
                        item.MergeStyle(itemStyle);
                        break;

                    case ListItemType.AlternatingItem:
                        item.MergeStyle(altItemStyle);
                        break;

                    case ListItemType.SelectedItem:
                        // When creating the control hierarchy we first check if the
                        // item is in edit mode, so we know this item cannot be in edit
                        // mode. The only special characteristic of this item is that
                        // it is selected.
                        {
                            Style s = new TableItemStyle();

                            if (item.ItemIndex % 2 != 0)
                                s.CopyFrom(altItemStyle);
                            else
                                s.CopyFrom(itemStyle);
                            s.CopyFrom(selectedItemStyle);
                            item.MergeStyle(s);
                        }
                        break;

                    case ListItemType.EditItem:
                        // When creating the control hierarchy, we first check if the
                        // item is in edit mode. So an item may be selected too, and
                        // so both editItemStyle (more specific) and selectedItemStyle
                        // are applied.
                        {
                            Style s = new TableItemStyle();

                            if (item.ItemIndex % 2 != 0)
                                s.CopyFrom(altItemStyle);
                            else
                                s.CopyFrom(itemStyle);
                            if (item.ItemIndex == SelectedIndex)
                                s.CopyFrom(selectedItemStyle);
                            s.CopyFrom(editItemStyle);
                            item.MergeStyle(s);
                        }
                        break;
                }

                TableCellCollection cells = item.Cells;
                int cellCount = cells.Count;

                if ((columnCount > 0) && (item.ItemType != ListItemType.Pager)) {
                    int definedCells = cellCount;

                    if (columnCount < cellCount)
                        definedCells = columnCount;

                    for (int j = 0; j < definedCells; j++) {
                        if (definedColumns[j].Visible == false) {
                            cells[j].Visible = false;
                        }
                        else {
                            Style cellStyle = null;

                            switch (item.ItemType) {
                                case ListItemType.Header:
                                    cellStyle = definedColumns[j].HeaderStyleInternal;
                                    break;
                                case ListItemType.Footer:
                                    cellStyle = definedColumns[j].FooterStyleInternal;
                                    break;
                                default:
                                    cellStyle = definedColumns[j].ItemStyleInternal;
                                    break;
                            }
                            cells[j].MergeStyle(cellStyle);
                        }
                    }
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.SaveViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Saves the current state of the <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
        /// </devdoc>
        protected override object SaveViewState() {
            object baseState = base.SaveViewState();
            object columnState = (columnCollection != null) ? ((IStateManager)columnCollection).SaveViewState() : null;
            object pagerStyleState = (pagerStyle != null) ? ((IStateManager)pagerStyle).SaveViewState() : null;
            object headerStyleState = (headerStyle != null) ? ((IStateManager)headerStyle).SaveViewState() : null;
            object footerStyleState = (footerStyle != null) ? ((IStateManager)footerStyle).SaveViewState() : null;
            object itemStyleState = (itemStyle != null) ? ((IStateManager)itemStyle).SaveViewState() : null;
            object alternatingItemStyleState = (alternatingItemStyle != null) ? ((IStateManager)alternatingItemStyle).SaveViewState() : null;
            object selectedItemStyleState = (selectedItemStyle != null) ? ((IStateManager)selectedItemStyle).SaveViewState() : null;
            object editItemStyleState = (editItemStyle != null) ? ((IStateManager)editItemStyle).SaveViewState() : null;
            object[] autoGenColumnState = null;

            if ((autoGenColumnsArray != null) && (autoGenColumnsArray.Count != 0)) {
                autoGenColumnState = new object[autoGenColumnsArray.Count];

                for (int i = 0; i < autoGenColumnState.Length; i++) {
                    autoGenColumnState[i] = ((IStateManager)autoGenColumnsArray[i]).SaveViewState();
                }
            }

            object[] myState = new object[10];
            myState[0] = baseState;
            myState[1] = columnState;
            myState[2] = pagerStyleState;
            myState[3] = headerStyleState;
            myState[4] = footerStyleState;
            myState[5] = itemStyleState;
            myState[6] = alternatingItemStyleState;
            myState[7] = selectedItemStyleState;
            myState[8] = editItemStyleState;
            myState[9] = autoGenColumnState;

            // note that we always have some state, atleast the ItemCount
            return myState;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagriditemeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridItemEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\DataGridItemEventHandler.uex' path='docs/doc[@for="DataGridItemEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle the 
    ///    <see langword='DataGridItem'/> event of a <see cref='System.Web.UI.WebControls.DataGrid'/> .</para>
    /// </devdoc>
    public delegate void DataGridItemEventHandler(object sender, DataGridItemEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagridsortcommandeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridSortCommandEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\DataGridSortCommandEventHandler.uex' path='docs/doc[@for="DataGridSortCommandEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle the 
    ///    <see langword='DataGridSortCommand'/> event of a <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
    /// </devdoc>
    public delegate void DataGridSortCommandEventHandler(object source, DataGridSortCommandEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagridlinkbutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridLinkButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Diagnostics;
    using System.Drawing;

    /// <include file='doc\DataGridLinkButton.uex' path='docs/doc[@for="DataGridLinkButton"]/*' />
    /// <devdoc>
    ///  Derived version of LinkButton used within a DataGrid.
    /// </devdoc>
    internal sealed class DataGridLinkButton : LinkButton {
        
        internal DataGridLinkButton() {}
        
        protected override void Render(HtmlTextWriter writer) {
            SetForeColor();
            base.Render(writer);
        }

        /// <include file='doc\DataGridLinkButton.uex' path='docs/doc[@for="DataGridLinkButton.SetForeColor"]/*' />
        /// <devdoc>
        ///  In HTML hyperlinks always use the browser's link color.
        ///  For the DataGrid, we want all LinkButtons to honor the ForeColor setting.
        ///  This requires looking up into the control hierarchy to see if either the cell
        ///  or the containing row or table define a ForeColor.
        /// </devdoc>
        private void SetForeColor() {
            if (ControlStyle.IsSet(System.Web.UI.WebControls.Style.PROP_FORECOLOR) == false) {
                Color hyperLinkForeColor;
                Control control = this;

                for (int i = 0; i < 3; i++) {
                    control = control.Parent;

                    Debug.Assert(((i == 0) && (control is TableCell)) ||
                                 ((i == 1) && (control is TableRow)) ||
                                 ((i == 2) && (control is Table)));
                    hyperLinkForeColor = ((WebControl)control).ForeColor;
                    if (hyperLinkForeColor != Color.Empty) {
                        ForeColor = hyperLinkForeColor;
                        break;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagridpagechangedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridPageChangedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;
    using System.Security.Permissions;

    /// <include file='doc\DataGridPageChangedEventArgs.uex' path='docs/doc[@for="DataGridPageChangedEventArgs"]/*' />
    /// <devdoc>
    ///    <para>Provides data for 
    ///       the <see langword='DataGridPageChanged'/>
    ///       event.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DataGridPageChangedEventArgs : EventArgs {

        private object commandSource;
        private int newPageIndex;

        /// <include file='doc\DataGridPageChangedEventArgs.uex' path='docs/doc[@for="DataGridPageChangedEventArgs.DataGridPageChangedEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.DataGridPageChangedEventArgs'/> class.</para>
        /// </devdoc>
        public DataGridPageChangedEventArgs(object commandSource, int newPageIndex) {
            this.commandSource = commandSource;
            this.newPageIndex = newPageIndex;
        }



        /// <include file='doc\DataGridPageChangedEventArgs.uex' path='docs/doc[@for="DataGridPageChangedEventArgs.CommandSource"]/*' />
        /// <devdoc>
        ///    <para>Gets the source of the command. This property is read-only.</para>
        /// </devdoc>
        public object CommandSource {
            get {
                return commandSource;
            }
        }

        /// <include file='doc\DataGridPageChangedEventArgs.uex' path='docs/doc[@for="DataGridPageChangedEventArgs.NewPageIndex"]/*' />
        /// <devdoc>
        /// <para>Gets the index of the first new page to be displayed in the <see cref='System.Web.UI.WebControls.DataGrid'/>. 
        ///    This property is read-only.</para>
        /// </devdoc>
        public int NewPageIndex {
            get {
                return newPageIndex;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagridpagerstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridPagerStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle"]/*' />
    /// <devdoc>
    /// <para>Specifies the <see cref='System.Web.UI.WebControls.DataGrid'/> pager style for the control. This class cannot be inherited.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DataGridPagerStyle : TableItemStyle {

        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.PROP_MODE"]/*' />
        /// <devdoc>
        ///    <para>Represents the Mode property.</para>
        /// </devdoc>
        const int PROP_MODE = 0x00080000;
        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.PROP_NEXTPAGETEXT"]/*' />
        /// <devdoc>
        ///    <para>Represents the Next Page Text property.</para>
        /// </devdoc>
        const int PROP_NEXTPAGETEXT = 0x00100000;
        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.PROP_PREVPAGETEXT"]/*' />
        /// <devdoc>
        ///    <para>Represents the Previous Page Text property.</para>
        /// </devdoc>
        const int PROP_PREVPAGETEXT = 0x00200000;
        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.PROP_PAGEBUTTONCOUNT"]/*' />
        /// <devdoc>
        ///    <para>Represents the Page Button Count property.</para>
        /// </devdoc>
        const int PROP_PAGEBUTTONCOUNT = 0x00400000;
        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.PROP_POSITION"]/*' />
        /// <devdoc>
        ///    <para>Represents the Position property.</para>
        /// </devdoc>
        const int PROP_POSITION = 0x00800000;
        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.PROP_VISIBLE"]/*' />
        /// <devdoc>
        ///    <para>Represents the Visible property.</para>
        /// </devdoc>
        const int PROP_VISIBLE = 0x01000000;

        private DataGrid owner;

        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.DataGridPagerStyle"]/*' />
        /// <devdoc>
        ///   Creates a new instance of DataGridPagerStyle.
        /// </devdoc>
        internal DataGridPagerStyle(DataGrid owner) {
            this.owner = owner;
        }


        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.IsPagerOnBottom"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal bool IsPagerOnBottom {
            get {
                PagerPosition position = Position;

                return(position == PagerPosition.Bottom) ||
                (position == PagerPosition.TopAndBottom);
            }
        }

        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.IsPagerOnTop"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal bool IsPagerOnTop {
            get {
                PagerPosition position = Position;

                return(position == PagerPosition.Top) ||
                (position == PagerPosition.TopAndBottom);
            }
        }

        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.Mode"]/*' />
        /// <devdoc>
        ///    Gets or sets the type of Paging UI to use.
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(PagerMode.NextPrev),
        NotifyParentProperty(true),
        WebSysDescription(SR.DataGridPagerStyle_Mode)
        ]
        public PagerMode Mode {
            get {
                if (IsSet(PROP_MODE)) {
                    return(PagerMode)(ViewState["Mode"]);
                }
                return PagerMode.NextPrev;
            }
            set {
                if (value < PagerMode.NextPrev || value > PagerMode.NumericPages) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["Mode"] = value;
                SetBit(PROP_MODE);
                owner.OnPagerChanged();
            }
        }

        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.NextPageText"]/*' />
        /// <devdoc>
        ///    Gets or sets the text to be used for the Next page
        ///    button.
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue("&gt;"),
        NotifyParentProperty(true),
        WebSysDescription(SR.DataGridPagerStyle_NextPageText)
        ]
        public string NextPageText {
            get {
                if (IsSet(PROP_NEXTPAGETEXT)) {
                    return(string)(ViewState["NextPageText"]);
                }
                return "&gt;";
            }
            set {
                ViewState["NextPageText"] = value;
                SetBit(PROP_NEXTPAGETEXT);
                owner.OnPagerChanged();
            }
        }

        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.PageButtonCount"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the number of pages to show in the 
        ///       paging UI when the mode is <see langword='PagerMode.NumericPages'/>
        ///       .</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(10),
        NotifyParentProperty(true),
        WebSysDescription(SR.DataGridPagerStyle_PageButtonCount)
        ]
        public int PageButtonCount {
            get {
                if (IsSet(PROP_PAGEBUTTONCOUNT)) {
                    return(int)(ViewState["PageButtonCount"]);
                }
                return 10;
            }
            set {
                if (value < 1) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["PageButtonCount"] = value;
                SetBit(PROP_PAGEBUTTONCOUNT);
                owner.OnPagerChanged();
            }
        }

        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.Position"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the vertical
        ///       position of the paging UI bar with
        ///       respect to its associated control.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(PagerPosition.Bottom),
        NotifyParentProperty(true),
        WebSysDescription(SR.DataGridPagerStyle_Position)
        ]
        public PagerPosition Position {
            get {
                if (IsSet(PROP_POSITION)) {
                    return(PagerPosition)(ViewState["Position"]);
                }
                return PagerPosition.Bottom;
            }
            set {
                if (value < PagerPosition.Bottom || value > PagerPosition.TopAndBottom) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["Position"] = value;
                SetBit(PROP_POSITION);
                owner.OnPagerChanged();
            }
        }

        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.PrevPageText"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the text to be used for the Previous
        ///       page button.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue("&lt;"),
        NotifyParentProperty(true),
        WebSysDescription(SR.DataGridPagerStyle_PrevPageText)
        ]
        public string PrevPageText {
            get {
                if (IsSet(PROP_PREVPAGETEXT)) {
                    return(string)(ViewState["PrevPageText"]);
                }
                return "&lt;";
            }
            set {
                ViewState["PrevPageText"] = value;
                SetBit(PROP_PREVPAGETEXT);
                owner.OnPagerChanged();
            }
        }

        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.Visible"]/*' />
        /// <devdoc>
        ///    <para> Gets or set whether the paging
        ///       UI is to be shown.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(true),
        NotifyParentProperty(true),
        WebSysDescription(SR.DataGridPagerStyle_Visible)
        ]
        public bool Visible {
            get {
                if (IsSet(PROP_VISIBLE)) {
                    return(bool)(ViewState["PagerVisible"]);
                }
                return true;
            }
            set {
                ViewState["PagerVisible"] = value;
                SetBit(PROP_VISIBLE);
                owner.OnPagerChanged();
            }
        }

        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.CopyFrom"]/*' />
        /// <devdoc>
        /// <para>Copies the data grid pager style from the specified <see cref='System.Web.UI.WebControls.Style'/>.</para>
        /// </devdoc>
        public override void CopyFrom(Style s) {

            if (s != null && !s.IsEmpty) {
                base.CopyFrom(s);

                if (s is DataGridPagerStyle) {
                    DataGridPagerStyle ps = (DataGridPagerStyle)s;

                    if (ps.IsSet(PROP_MODE))
                        this.Mode = ps.Mode;
                    if (ps.IsSet(PROP_NEXTPAGETEXT))
                        this.NextPageText = ps.NextPageText;
                    if (ps.IsSet(PROP_PREVPAGETEXT))
                        this.PrevPageText = ps.PrevPageText;
                    if (ps.IsSet(PROP_PAGEBUTTONCOUNT))
                        this.PageButtonCount = ps.PageButtonCount;
                    if (ps.IsSet(PROP_POSITION))
                        this.Position = ps.Position;
                    if (ps.IsSet(PROP_VISIBLE))
                        this.Visible = ps.Visible;

                }
            }
        }

        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.MergeWith"]/*' />
        /// <devdoc>
        /// <para>Merges the data grid pager style from the specified <see cref='System.Web.UI.WebControls.Style'/>.</para>
        /// </devdoc>
        public override void MergeWith(Style s) {
            if (s != null && !s.IsEmpty) {

                if (IsEmpty) {
                    // merge into an empty style is equivalent to a copy, which
                    // is more efficient
                    CopyFrom(s);
                    return;
                }

                base.MergeWith(s);

                if (s is DataGridPagerStyle) {
                    DataGridPagerStyle ps = (DataGridPagerStyle)s;

                    if (ps.IsSet(PROP_MODE) && !this.IsSet(PROP_MODE))
                        this.Mode = ps.Mode;
                    if (ps.IsSet(PROP_NEXTPAGETEXT) && !this.IsSet(PROP_NEXTPAGETEXT))
                        this.NextPageText = ps.NextPageText;
                    if (ps.IsSet(PROP_PREVPAGETEXT) && !this.IsSet(PROP_PREVPAGETEXT))
                        this.PrevPageText = ps.PrevPageText;
                    if (ps.IsSet(PROP_PAGEBUTTONCOUNT) && !this.IsSet(PROP_PAGEBUTTONCOUNT))
                        this.PageButtonCount = ps.PageButtonCount;
                    if (ps.IsSet(PROP_POSITION) && !this.IsSet(PROP_POSITION))
                        this.Position = ps.Position;
                    if (ps.IsSet(PROP_VISIBLE) && !this.IsSet(PROP_VISIBLE))
                        this.Visible = ps.Visible;

                }
            }
        }

        /// <include file='doc\DataGridPagerStyle.uex' path='docs/doc[@for="DataGridPagerStyle.Reset"]/*' />
        /// <devdoc>
        ///    <para>Restores the data grip pager style to the default values.</para>
        /// </devdoc>
        public override void Reset() {
            if (IsSet(PROP_MODE))
                ViewState.Remove("Mode");
            if (IsSet(PROP_NEXTPAGETEXT))
                ViewState.Remove("NextPageText");
            if (IsSet(PROP_PREVPAGETEXT))
                ViewState.Remove("PrevPageText");
            if (IsSet(PROP_PAGEBUTTONCOUNT))
                ViewState.Remove("PageButtonCount");
            if (IsSet(PROP_POSITION))
                ViewState.Remove("Position");
            if (IsSet(PROP_VISIBLE))
                ViewState.Remove("PagerVisible");

            base.Reset();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagridpagechangedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridPageChangedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\DataGridPageChangedEventHandler.uex' path='docs/doc[@for="DataGridPageChangedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle the 
    ///    <see langword='DataGridPageChanged'/> event of a <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
    /// </devdoc>
    public delegate void DataGridPageChangedEventHandler(object source, DataGridPageChangedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagridsortcommandeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridSortCommandEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;
    using System.Security.Permissions;

    /// <include file='doc\DataGridSortCommandEventArgs.uex' path='docs/doc[@for="DataGridSortCommandEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see langword='DataGridSortCommand'/> event of a <see cref='System.Web.UI.WebControls.DataGrid'/>.
    /// </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DataGridSortCommandEventArgs : EventArgs {

        private string sortExpression;
        private object commandSource;

        /// <include file='doc\DataGridSortCommandEventArgs.uex' path='docs/doc[@for="DataGridSortCommandEventArgs.DataGridSortCommandEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.DataGridSortCommandEventArgs'/> class.</para>
        /// </devdoc>
        public DataGridSortCommandEventArgs(object commandSource, DataGridCommandEventArgs dce) {
            this.commandSource = commandSource;
            this.sortExpression = (string)dce.CommandArgument;
        }


        /// <include file='doc\DataGridSortCommandEventArgs.uex' path='docs/doc[@for="DataGridSortCommandEventArgs.CommandSource"]/*' />
        /// <devdoc>
        ///    <para>Gets the source of the command. This property is read-only. </para>
        /// </devdoc>
        public object CommandSource {
            get {
                return commandSource;
            }
        }

        /// <include file='doc\DataGridSortCommandEventArgs.uex' path='docs/doc[@for="DataGridSortCommandEventArgs.SortExpression"]/*' />
        /// <devdoc>
        ///    <para>Gets the expression used to sort. This property is read-only.</para>
        /// </devdoc>
        public string SortExpression {
            get {
                return sortExpression;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datalistcommandeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataListCommandEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;
    using System.Security.Permissions;

    /// <include file='doc\DataListCommandEventArgs.uex' path='docs/doc[@for="DataListCommandEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see langword='DataListCommand'/> event of a <see cref='System.Web.UI.WebControls.DataList'/>.
    /// </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DataListCommandEventArgs : CommandEventArgs {

        private DataListItem item;
        private object commandSource;

        /// <include file='doc\DataListCommandEventArgs.uex' path='docs/doc[@for="DataListCommandEventArgs.DataListCommandEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.DataListCommandEventArgs'/> class.</para>
        /// </devdoc>
        public DataListCommandEventArgs(DataListItem item, object commandSource, CommandEventArgs originalArgs) : base(originalArgs) {
            this.item = item;
            this.commandSource = commandSource;
        }


        /// <include file='doc\DataListCommandEventArgs.uex' path='docs/doc[@for="DataListCommandEventArgs.Item"]/*' />
        /// <devdoc>
        /// <para>Gets the selected item in the <see cref='System.Web.UI.WebControls.DataList'/>.</para>
        /// </devdoc>
        public DataListItem Item {
            get {
                return item;
            }
        }

        /// <include file='doc\DataListCommandEventArgs.uex' path='docs/doc[@for="DataListCommandEventArgs.CommandSource"]/*' />
        /// <devdoc>
        ///    <para>Gets the source of the command.</para>
        /// </devdoc>
        public object CommandSource {
            get {
                return commandSource;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datalistitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataListItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\DataListItem.uex' path='docs/doc[@for="DataListItem"]/*' />
    /// <devdoc>
    /// <para>Represents an item in the <see cref='System.Web.UI.WebControls.DataList'/>. </para>
    /// </devdoc>
    [
    ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DataListItem : WebControl, INamingContainer {

        private int itemIndex;
        private ListItemType itemType;
        private object dataItem;


        /// <include file='doc\DataListItem.uex' path='docs/doc[@for="DataListItem.DataListItem"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.DataListItem'/> class.</para>
        /// </devdoc>
        public DataListItem(int itemIndex, ListItemType itemType) {
            this.itemIndex = itemIndex;
            this.itemType = itemType;
        }


        /// <include file='doc\DataListItem.uex' path='docs/doc[@for="DataListItem.DataItem"]/*' />
        /// <devdoc>
        /// <para>Represents an item in the <see cref='System.Web.UI.WebControls.DataList'/>. </para>
        /// </devdoc>
        public virtual object DataItem {
            get {
                return dataItem;
            }
            set {
                dataItem = value;
            }
        }

        /// <include file='doc\DataListItem.uex' path='docs/doc[@for="DataListItem.ItemIndex"]/*' />
        /// <devdoc>
        /// <para>Indicates the index of the item in the <see cref='System.Web.UI.WebControls.DataList'/>. This property is 
        ///    read-only.</para>
        /// </devdoc>
        public virtual int ItemIndex {
            get {
                return itemIndex;
            }
        }

        /// <include file='doc\DataListItem.uex' path='docs/doc[@for="DataListItem.ItemType"]/*' />
        /// <devdoc>
        /// <para>Indicates the type of the item in the <see cref='System.Web.UI.WebControls.DataList'/>.</para>
        /// </devdoc>
        public virtual ListItemType ItemType {
            get {
                return itemType;
            }
        }


        /// <include file='doc\DataListItem.uex' path='docs/doc[@for="DataListItem.CreateControlStyle"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override Style CreateControlStyle() {
            return new TableItemStyle();
        }
        
        /// <include file='doc\DataListItem.uex' path='docs/doc[@for="DataListItem.OnBubbleEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override bool OnBubbleEvent(object source, EventArgs e) {
            if (e is CommandEventArgs) {
                DataListCommandEventArgs args = new DataListCommandEventArgs(this, source, (CommandEventArgs)e);

                RaiseBubbleEvent(this, args);
                return true;
            }
            return false;
        }

        /// <include file='doc\DataListItem.uex' path='docs/doc[@for="DataListItem.RenderItem"]/*' />
        /// <devdoc>
        /// <para>Displays a <see cref='System.Web.UI.WebControls.DataListItem'/> on the client.</para>
        /// </devdoc>
        public virtual void RenderItem(HtmlTextWriter writer, bool extractRows, bool tableLayout) {
            HttpContext con = Context;
            if ((con != null) && con.TraceIsEnabled) {
                int presize = con.Response.GetBufferedLength();
            
                RenderItemInternal(writer, extractRows, tableLayout);
                
                int postsize = con.Response.GetBufferedLength();
                con.Trace.AddControlSize(UniqueID, postsize - presize);
            }
            else
                RenderItemInternal(writer, extractRows, tableLayout);
        }

        private void RenderItemInternal(HtmlTextWriter writer, bool extractRows, bool tableLayout) {
            if (extractRows == false) {
                if (tableLayout) {
                    // in table mode, style information has gone on the containing TD
                    RenderContents(writer);
                }
                else {
                    // in non-table mode, the item itself is responsible for putting
                    // out the style information
                    RenderControl(writer);
                }
            }
            else {
                IEnumerator controlEnum = this.Controls.GetEnumerator();
                Table templateTable = null;
                bool hasControls = false;

                while (controlEnum.MoveNext()) {
                    hasControls = true;
                    Control c = (Control)controlEnum.Current;
                    if (c is Table) {
                        templateTable = (Table)c;
                        break;
                    }
                }

                if (templateTable != null) {
                    IEnumerator rowEnum = templateTable.Rows.GetEnumerator();
                    while (rowEnum.MoveNext()) {
                        TableRow r = (TableRow)rowEnum.Current;
                        r.RenderControl(writer);
                    }
                }
                else if (hasControls) {
                    // there was a template, since there were controls but
                    // none of them was a table... so throw an exception here
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.DataList_TemplateTableNotFound,
                                                                         Parent.ID, itemType.ToString()));
                }
            }
        }

        /// <include file='doc\DataListItem.uex' path='docs/doc[@for="DataListItem.SetItemType"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected internal virtual void SetItemType(ListItemType itemType) {
            this.itemType = itemType;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datagridtable.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Diagnostics;
    using System.Web.UI;

    /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTable"]/*' />
    /// <devdoc>
    ///   <para>Only used by the DataGrid. Used to render out an ID attribute without an ID actually set.</para>
    /// </devdoc>
    internal class DataGridTable : Table {
        internal DataGridTable() {
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTable.AddAttributesToRender"]/*' />
        /// <internalonly/>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {
            base.AddAttributesToRender(writer);

            if (ID == null) {
                Debug.Assert((Parent != null) && (Parent is DataGrid));
                writer.AddAttribute(HtmlTextWriterAttribute.Id, Parent.ClientID);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datalistcommandeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataListCommandEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\DataListCommandEventHandler.uex' path='docs/doc[@for="DataListCommandEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle the 
    ///    <see langword='DataListCommand'/> event of a <see cref='System.Web.UI.WebControls.DataList'/>.</para>
    /// </devdoc>
    public delegate void DataListCommandEventHandler(object source, DataListCommandEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datakeycollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataKeyCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.Security.Permissions;

    /// <include file='doc\DataKeyCollection.uex' path='docs/doc[@for="DataKeyCollection"]/*' />
    /// <devdoc>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DataKeyCollection : ICollection {

        private ArrayList keys;

        /// <include file='doc\DataKeyCollection.uex' path='docs/doc[@for="DataKeyCollection.DataKeyCollection"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.DataKeyCollection'/> class.</para>
        /// </devdoc>
        public DataKeyCollection(ArrayList keys) {
            this.keys = keys;
        }
        
        /// <include file='doc\DataKeyCollection.uex' path='docs/doc[@for="DataKeyCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of objects in the collection. This property is read-only.</para>
        /// </devdoc>
        public int Count {
            get {
                return keys.Count;
            }
        }

        /// <include file='doc\DataKeyCollection.uex' path='docs/doc[@for="DataKeyCollection.IsReadOnly"]/*' />
        /// <devdoc>
        /// <para>Gets the value that specifies whether items in the <see cref='System.Web.UI.WebControls.DataKeyCollection'/> can be 
        ///    modified. This property is read-only.</para>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\DataKeyCollection.uex' path='docs/doc[@for="DataKeyCollection.IsSynchronized"]/*' />
        /// <devdoc>
        /// <para>Gets a value that indicates whether the <see cref='System.Web.UI.WebControls.DataKeyCollection'/> is 
        ///    thread-safe. This property is read-only.</para>
        /// </devdoc>
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\DataKeyCollection.uex' path='docs/doc[@for="DataKeyCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>Gets the object used to synchronize access to the collection. This property is read-only. </para>
        /// </devdoc>
        public object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\DataKeyCollection.uex' path='docs/doc[@for="DataKeyCollection.this"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='System.Data.DataKey' qualify='true'/> at the specified index in the collection. This property is read-only.</para>
        /// </devdoc>
        public object this[int index] {
            get {
                return keys[index];
            }
        }


        /// <include file='doc\DataKeyCollection.uex' path='docs/doc[@for="DataKeyCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the contents of the entire collection into an <see cref='System.Array' qualify='true'/> appending at 
        ///    the specified index of the <see cref='System.Array' qualify='true'/>.</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\DataKeyCollection.uex' path='docs/doc[@for="DataKeyCollection.GetEnumerator"]/*' />
        /// <devdoc>
        /// <para>Creates an enumerator for the <see cref='System.Web.UI.WebControls.DataKeyCollection'/> used to iterate 
        ///    through the collection.</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return keys.GetEnumerator();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datalist.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Web;
    using System.Web.UI;
    using System.Globalization;
    using System.Security.Permissions;
    
    /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Creates
    ///       a control to display a data-bound list.
    ///    </para>
    /// </devdoc>
    [
    Editor("System.Web.UI.Design.WebControls.DataListComponentEditor, " + AssemblyRef.SystemDesign, typeof(ComponentEditor)),
    Designer("System.Web.UI.Design.WebControls.DataListDesigner, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DataList : BaseDataList, INamingContainer, IRepeatInfoUser {

        private static readonly object EventItemCreated = new object();
        private static readonly object EventItemDataBound = new object();
        private static readonly object EventItemCommand = new object();
        private static readonly object EventEditCommand = new object();
        private static readonly object EventUpdateCommand = new object();
        private static readonly object EventCancelCommand = new object();
        private static readonly object EventDeleteCommand = new object();

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.SelectCommandName"]/*' />
        /// <devdoc>
        /// <para>Specifies the <see langword='Select'/> command. This field is constant.</para>
        /// </devdoc>
        public const string SelectCommandName = "Select";
        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.EditCommandName"]/*' />
        /// <devdoc>
        /// <para>Specifies the <see langword='Edit'/> command. This field is constant</para>
        /// </devdoc>
        public const string EditCommandName = "Edit";
        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.UpdateCommandName"]/*' />
        /// <devdoc>
        /// <para>Specifies the <see langword='Update'/> command. This field is constant</para>
        /// </devdoc>
        public const string UpdateCommandName = "Update";
        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.CancelCommandName"]/*' />
        /// <devdoc>
        /// <para>Specifies the <see langword='Cancel'/> command. This field is constant</para>
        /// </devdoc>
        public const string CancelCommandName = "Cancel";
        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.DeleteCommandName"]/*' />
        /// <devdoc>
        /// <para>Specifies the <see langword='Delete'/> command. This field is constant</para>
        /// </devdoc>
        public const string DeleteCommandName = "Delete";

        private TableItemStyle itemStyle;
        private TableItemStyle alternatingItemStyle;
        private TableItemStyle selectedItemStyle;
        private TableItemStyle editItemStyle;
        private TableItemStyle separatorStyle;
        private TableItemStyle headerStyle;
        private TableItemStyle footerStyle;

        private ITemplate itemTemplate;
        private ITemplate alternatingItemTemplate;
        private ITemplate selectedItemTemplate;
        private ITemplate editItemTemplate;
        private ITemplate separatorTemplate;
        private ITemplate headerTemplate;
        private ITemplate footerTemplate;

        private bool extractTemplateRows;

        private ArrayList itemsArray;
        private DataListItemCollection itemsCollection;

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.DataList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.WebControls.DataList'/> class.
        ///    </para>
        /// </devdoc>
        public DataList() {
        }


        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.AlternatingItemStyle"]/*' />
        /// <devdoc>
        /// <para>Gets the style properties for alternating items in the <see cref='System.Web.UI.WebControls.DataList'/>. This 
        ///    property is read-only. </para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataList_AlternatingItemStyle)
        ]
        public virtual TableItemStyle AlternatingItemStyle {
            get {
                if (alternatingItemStyle == null) {
                    alternatingItemStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)alternatingItemStyle).TrackViewState();
                }
                return alternatingItemStyle;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.AlternatingItemTemplate"]/*' />
        /// <devdoc>
        /// <para>Indicates the template to use for alternating items in the <see cref='System.Web.UI.WebControls.DataList'/>.</para>
        /// </devdoc>
        [
        Browsable(false),
        DefaultValue(null),
        PersistenceMode(PersistenceMode.InnerProperty),
        TemplateContainer(typeof(DataListItem)),
        WebSysDescription(SR.DataList_AlternatingItemTemplate)
        ]
        public virtual ITemplate AlternatingItemTemplate {
            get {
                return alternatingItemTemplate;
            }
            set {
                alternatingItemTemplate = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.EditItemIndex"]/*' />
        /// <devdoc>
        ///    <para>Indicates the ordinal index of the item to be edited.</para>
        /// </devdoc>
        [
        WebCategory("Default"),
        DefaultValue(-1),
        WebSysDescription(SR.DataList_EditItemIndex)
        ]
        public virtual int EditItemIndex {
            get {
                object o = ViewState["EditItemIndex"];
                if (o != null)
                    return(int)o;
                return -1;
            }
            set {
                if (value < -1) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["EditItemIndex"] = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.EditItemStyle"]/*' />
        /// <devdoc>
        ///    <para>Indicates the style properties of the item to be edited.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataList_EditItemStyle)
        ]
        public virtual TableItemStyle EditItemStyle {
            get {
                if (editItemStyle == null) {
                    editItemStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)editItemStyle).TrackViewState();
                }
                return editItemStyle;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.EditItemTemplate"]/*' />
        /// <devdoc>
        /// <para>Indicates the template to use for an item set in edit mode within the <see cref='System.Web.UI.WebControls.DataList'/>.</para>
        /// </devdoc>
        [
        Browsable(false),
        DefaultValue(null),
        PersistenceMode(PersistenceMode.InnerProperty),
        TemplateContainer(typeof(DataListItem)),
        WebSysDescription(SR.DataList_EditItemTemplate)
        ]
        public virtual ITemplate EditItemTemplate {
            get {
                return editItemTemplate;
            }
            set {
                editItemTemplate = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.ExtractTemplateRows"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether to extract template rows.</para>
        /// </devdoc>
        [
        WebCategory("Layout"),
        DefaultValue(false),
        WebSysDescription(SR.DataList_ExtractTemplateRows)
        ]
        public virtual bool ExtractTemplateRows {
            get {
                object o = ViewState["ExtractTemplateRows"];
                if (o != null)
                    return(bool)o;
                return false;
            }
            set {
                ViewState["ExtractTemplateRows"] = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.FooterStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties of the footer item.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataList_FooterStyle)
        ]
        public virtual TableItemStyle FooterStyle {
            get {
                if (footerStyle == null) {
                    footerStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)footerStyle).TrackViewState();
                }
                return footerStyle;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.FooterTemplate"]/*' />
        /// <devdoc>
        /// <para> Indicates the template to use for the footer in the <see cref='System.Web.UI.WebControls.DataList'/>.</para>
        /// </devdoc>
        [
        Browsable(false),
        DefaultValue(null),
        PersistenceMode(PersistenceMode.InnerProperty),
        TemplateContainer(typeof(DataListItem)),
        WebSysDescription(SR.DataList_FooterTemplate)
        ]
        public virtual ITemplate FooterTemplate {
            get {
                return footerTemplate;
            }
            set {
                footerTemplate = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.GridLines"]/*' />
        /// <devdoc>
        ///    <para>Indicates a value that specifies the grid line style.</para>
        /// </devdoc>
        [
        DefaultValue(GridLines.None)
        ]
        public override GridLines GridLines {
            get {
                return base.GridLines;
            }
            set {
                base.GridLines = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.HeaderStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the style properties of the header item.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataList_HeaderStyle)
        ]
        public virtual TableItemStyle HeaderStyle {
            get {
                if (headerStyle == null) {
                    headerStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)headerStyle).TrackViewState();
                }
                return headerStyle;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.HeaderTemplate"]/*' />
        /// <devdoc>
        /// <para>Indicates the template to use for the header in the <see cref='System.Web.UI.WebControls.DataList'/>.</para>
        /// </devdoc>
        [
        Browsable(false),
        DefaultValue(null),
        PersistenceMode(PersistenceMode.InnerProperty),
        TemplateContainer(typeof(DataListItem)),
        WebSysDescription(SR.DataList_HeaderTemplate)
        ]
        public virtual ITemplate HeaderTemplate {
            get {
                return headerTemplate;
            }
            set {
                headerTemplate = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.Items"]/*' />
        /// <devdoc>
        /// <para>Gets a collection of <see cref='System.Web.UI.WebControls.DataListItem'/> objects representing the individual 
        ///    items within the control.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.DataList_Items)
        ]
        public virtual DataListItemCollection Items {
            get {
                if (itemsCollection == null) {
                    if (itemsArray == null) {
                        EnsureChildControls();
                    }
                    if (itemsArray == null) {
                        itemsArray = new ArrayList();
                    }
                    itemsCollection = new DataListItemCollection(itemsArray);
                }
                return itemsCollection;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.ItemStyle"]/*' />
        /// <devdoc>
        ///    <para>Indicates the style properties of the individual items.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataList_ItemStyle)
        ]
        public virtual TableItemStyle ItemStyle {
            get {
                if (itemStyle == null) {
                    itemStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)itemStyle).TrackViewState();
                }
                return itemStyle;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.ItemTemplate"]/*' />
        /// <devdoc>
        /// <para>Indicates the template to use for an item in the <see cref='System.Web.UI.WebControls.DataList'/>.</para>
        /// </devdoc>
        [
        Browsable(false),
        DefaultValue(null),
        PersistenceMode(PersistenceMode.InnerProperty),
        TemplateContainer(typeof(DataListItem)),
        WebSysDescription(SR.DataList_ItemTemplate)
        ]
        public virtual ITemplate ItemTemplate {
            get {
                return itemTemplate;
            }
            set {
                itemTemplate = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.RepeatColumns"]/*' />
        /// <devdoc>
        ///    <para>Indicates the number of columns to repeat.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(0),
        WebSysDescription(SR.DataList_RepeatColumns)
        ]
        public virtual int RepeatColumns {
            get {
                object o = ViewState["RepeatColumns"];
                if (o != null)
                    return(int)o;
                return 0;
            }
            set {
                if (value < 0) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["RepeatColumns"] = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.RepeatDirection"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the control is displayed vertically or horizontally.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(RepeatDirection.Vertical),
        WebSysDescription(SR.DataList_RepeatDirection)
        ]
        public virtual RepeatDirection RepeatDirection {
            get {
                object o = ViewState["RepeatDirection"];
                if (o != null)
                    return(RepeatDirection)o;
                return RepeatDirection.Vertical;
            }
            set {
                if (value < RepeatDirection.Horizontal || value > RepeatDirection.Vertical) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["RepeatDirection"] = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.RepeatLayout"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that indicates whether the control is displayed in table 
        ///       or flow layout.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(RepeatLayout.Table),
        WebSysDescription(SR.DataList_RepeatLayout)
        ]
        public virtual RepeatLayout RepeatLayout {
            get {
                object o = ViewState["RepeatLayout"];
                if (o != null)
                    return(RepeatLayout)o;
                return RepeatLayout.Table;
            }
            set {
                if (value < RepeatLayout.Table || value > RepeatLayout.Flow) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["RepeatLayout"] = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.SelectedIndex"]/*' />
        /// <devdoc>
        ///    <para> Indicates the index of
        ///       the currently selected item.</para>
        /// </devdoc>
        [
        Bindable(true),
        DefaultValue(-1),
        WebSysDescription(SR.DataList_SelectedIndex)
        ]
        public virtual int SelectedIndex {
            get {
                object o = ViewState["SelectedIndex"];
                if (o != null)
                    return(int)o;
                return -1;
            }
            set {
                if (value < -1) {
                    throw new ArgumentOutOfRangeException("value");
                }
                int oldSelectedIndex = SelectedIndex;
                ViewState["SelectedIndex"] = value;

                if (itemsArray != null) {
                    DataListItem item;

                    if ((oldSelectedIndex != -1) && (itemsArray.Count > oldSelectedIndex)) {
                        item = (DataListItem)itemsArray[oldSelectedIndex];

                        if (item.ItemType != ListItemType.EditItem) {
                            ListItemType itemType = ListItemType.Item;
                            if (oldSelectedIndex % 2 != 0)
                                itemType = ListItemType.AlternatingItem;
                            item.SetItemType(itemType);
                        }
                    }
                    if ((value != -1) && (itemsArray.Count > value)) {
                        item = (DataListItem)itemsArray[value];
                        if (item.ItemType != ListItemType.EditItem)
                            item.SetItemType(ListItemType.SelectedItem);
                    }
                }
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.SelectedItem"]/*' />
        /// <devdoc>
        /// <para>Gets the selected item in the <see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        WebSysDescription(SR.DataList_SelectedItem)
        ]
        public virtual DataListItem SelectedItem {
            get {
                int index = SelectedIndex;
                DataListItem item = null;

                if (index != -1) {
                    item = Items[index];
                }
                return item;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.SelectedItemStyle"]/*' />
        /// <devdoc>
        ///    <para>Indicates the style properties of the currently 
        ///       selected item.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataList_SelectedItemStyle)
        ]
        public virtual TableItemStyle SelectedItemStyle {
            get {
                if (selectedItemStyle == null) {
                    selectedItemStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)selectedItemStyle).TrackViewState();
                }
                return selectedItemStyle;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.SelectedItemTemplate"]/*' />
        /// <devdoc>
        /// <para>Indicates the template to use for the currently selected item in the <see cref='System.Web.UI.WebControls.DataList'/>.</para>
        /// </devdoc>
        [
        Browsable(false),
        DefaultValue(null),
        PersistenceMode(PersistenceMode.InnerProperty),
        TemplateContainer(typeof(DataListItem)),
        WebSysDescription(SR.DataList_SelectedItemTemplate)
        ]
        public virtual ITemplate SelectedItemTemplate {
            get {
                return selectedItemTemplate;
            }
            set {
                selectedItemTemplate = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.SeparatorStyle"]/*' />
        /// <devdoc>
        ///    <para>Indicates the style properties of the separator between each item in the 
        ///    <see cref='System.Web.UI.WebControls.DataList'/>.</para>
        /// </devdoc>
        [
        WebCategory("Style"),
        DefaultValue(null),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        NotifyParentProperty(true),
        PersistenceMode(PersistenceMode.InnerProperty),
        WebSysDescription(SR.DataList_SeparatorStyle)
        ]
        public virtual TableItemStyle SeparatorStyle {
            get {
                if (separatorStyle == null) {
                    separatorStyle = new TableItemStyle();
                    if (IsTrackingViewState)
                        ((IStateManager)separatorStyle).TrackViewState();
                }
                return separatorStyle;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.SeparatorTemplate"]/*' />
        /// <devdoc>
        /// <para>Indicates the template to use for the separator in the <see cref='System.Web.UI.WebControls.DataList'/>.</para>
        /// </devdoc>
        [
        Browsable(false),
        DefaultValue(null),
        PersistenceMode(PersistenceMode.InnerProperty),
        TemplateContainer(typeof(DataListItem)),
        WebSysDescription(SR.DataList_SeparatorTemplate)
        ]
        public virtual ITemplate SeparatorTemplate {
            get {
                return separatorTemplate;
            }
            set {
                separatorTemplate = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.ShowFooter"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value that specifies whether the footer is displayed in the 
        ///    <see cref='System.Web.UI.WebControls.DataList'/>.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(true),
        WebSysDescription(SR.DataList_ShowFooter)
        ]
        public virtual bool ShowFooter {
            get {
                object o = ViewState["ShowFooter"];
                if (o != null)
                    return(bool)o;
                return true;
            }
            set {
                ViewState["ShowFooter"] = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.ShowHeader"]/*' />
        /// <devdoc>
        /// <para>Gets or sets a value that specifies whether the header is displayed in the<see cref='System.Web.UI.WebControls.DataGrid'/>.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(true),
        WebSysDescription(SR.DataList_ShowHeader)
        ]
        public virtual bool ShowHeader {
            get {
                object o = ViewState["ShowHeader"];
                if (o != null)
                    return(bool)o;
                return true;
            }
            set {
                ViewState["ShowHeader"] = value;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.CancelCommand"]/*' />
        /// <devdoc>
        /// <para>Occurs when a control bubbles an event to the <see cref='System.Web.UI.WebControls.DataList'/> with a 
        /// <see langword='Command'/> property of <see langword='cancel'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.DataList_OnCancelCommand)
        ]
        public event DataListCommandEventHandler CancelCommand {
            add {
                Events.AddHandler(EventCancelCommand, value);
            }
            remove {
                Events.RemoveHandler(EventCancelCommand, value);
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.DeleteCommand"]/*' />
        /// <devdoc>
        /// <para>Occurs when a control bubbles an event to the <see cref='System.Web.UI.WebControls.DataList'/> with a 
        /// <see langword='Command'/> property of <see langword='delete'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.DataList_OnDeleteCommand)
        ]
        public event DataListCommandEventHandler DeleteCommand {
            add {
                Events.AddHandler(EventDeleteCommand, value);
            }
            remove {
                Events.RemoveHandler(EventDeleteCommand, value);
            }
        }


        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.EditCommand"]/*' />
        /// <devdoc>
        /// <para>Occurs when a control bubbles an event to the <see cref='System.Web.UI.WebControls.DataList'/> with a 
        /// <see langword='Command'/> property of <see langword='edit'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.DataList_OnEditCommand)
        ]
        public event DataListCommandEventHandler EditCommand {
            add {
                Events.AddHandler(EventEditCommand, value);
            }
            remove {
                Events.RemoveHandler(EventEditCommand, value);
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.ItemCommand"]/*' />
        /// <devdoc>
        /// <para>Occurs when a control bubbles an event to the <see cref='System.Web.UI.WebControls.DataList'/> not covered by 
        /// <see langword='edit'/>, <see langword='cancel'/>, <see langword='delete'/> or 
        /// <see langword='update'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.DataList_OnItemCommand)
        ]
        public event DataListCommandEventHandler ItemCommand {
            add {
                Events.AddHandler(EventItemCommand, value);
            }
            remove {
                Events.RemoveHandler(EventItemCommand, value);
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.ItemCreated"]/*' />
        /// <devdoc>
        ///    <para>Occurs on the server when a control a created.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        WebSysDescription(SR.DataList_OnItemCreated)
        ]
        public event DataListItemEventHandler ItemCreated {
            add {
                Events.AddHandler(EventItemCreated, value);
            }
            remove {
                Events.RemoveHandler(EventItemCreated, value);
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.ItemDataBound"]/*' />
        /// <devdoc>
        ///    <para>Occurs when an item is data bound to the control.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        WebSysDescription(SR.DataList_OnItemDataBound)
        ]
        public event DataListItemEventHandler ItemDataBound {
            add {
                Events.AddHandler(EventItemDataBound, value);
            }
            remove {
                Events.RemoveHandler(EventItemDataBound, value);
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.UpdateCommand"]/*' />
        /// <devdoc>
        /// <para>Occurs when a control bubbles an event to the <see cref='System.Web.UI.WebControls.DataList'/> with a 
        /// <see langword='Command'/> property of <see langword='update'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.DataList_OnUpdateCommand)
        ]
        public event DataListCommandEventHandler UpdateCommand {
            add {
                Events.AddHandler(EventUpdateCommand, value);
            }
            remove {
                Events.RemoveHandler(EventUpdateCommand, value);
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.CreateControlHierarchy"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void CreateControlHierarchy(bool useDataSource) {
            IEnumerable dataSource = null;
            int count = -1;
            ArrayList keysArray = DataKeysArray;

            // cache this, so we don't need to go to the statebag each time
            extractTemplateRows = this.ExtractTemplateRows;

            if (itemsArray != null) {
                itemsArray.Clear();
            }
            else {
                itemsArray = new ArrayList();
            }

            if (useDataSource == false) {
                // ViewState must have a non-null value for ItemCount because we check for
                // this in CreateChildControls
                count = (int)ViewState[BaseDataList.ItemCountViewStateKey];
                if (count != -1) {
                    dataSource = new DummyDataSource(count);
                    itemsArray.Capacity = count;
                }
            }
            else {
                keysArray.Clear();
                dataSource = DataSourceHelper.GetResolvedDataSource(this.DataSource, this.DataMember);

                ICollection collection = dataSource as ICollection;
                if (collection != null) {
                    keysArray.Capacity = collection.Count;
                    itemsArray.Capacity = collection.Count;
                }
            }

            if (dataSource != null) {
                ControlCollection controls = Controls;
                DataListItem item;
                ListItemType itemType;
                int index = 0;

                bool hasSeparators = (separatorTemplate != null);
                int editItemIndex = EditItemIndex;
                int selectedItemIndex = SelectedIndex;
                string keyField = DataKeyField;
                bool storeKeys = (useDataSource && (keyField.Length != 0));

                count = 0;

                if (headerTemplate != null) {
                    CreateItem(-1, ListItemType.Header, useDataSource, null);
                }

                foreach (object dataItem in dataSource) {
                    if (storeKeys) {
                        object keyValue = DataBinder.GetPropertyValue(dataItem, keyField);
                        keysArray.Add(keyValue);
                    }

                    itemType = ListItemType.Item;
                    if (index == editItemIndex) {
                        itemType = ListItemType.EditItem;
                    }
                    else if (index == selectedItemIndex) {
                        itemType = ListItemType.SelectedItem;
                    }
                    else if (index % 2 != 0) {
                        itemType = ListItemType.AlternatingItem;
                    }

                    item = CreateItem(index, itemType, useDataSource, dataItem);
                    itemsArray.Add(item);

                    if (hasSeparators) {
                        CreateItem(index, ListItemType.Separator, useDataSource, null);
                    }

                    count++;
                    index++;
                }

                if (footerTemplate != null) {
                    CreateItem(-1, ListItemType.Footer, useDataSource, null);
                }
            }

            if (useDataSource) {
                // save the number of items contained in the DataList for use in round-trips
                ViewState[BaseDataList.ItemCountViewStateKey] = ((dataSource != null) ? count : -1);
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.CreateControlStyle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override Style CreateControlStyle() {
            TableStyle style = new TableStyle(ViewState);

            // initialize defaults that are different from TableStyle
            style.CellSpacing = 0;

            return style;
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.CreateItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        private DataListItem CreateItem(int itemIndex, ListItemType itemType, bool dataBind, object dataItem) {
            DataListItem item = CreateItem(itemIndex, itemType);
            DataListItemEventArgs e = new DataListItemEventArgs(item);

            InitializeItem(item);
            if (dataBind) {
                item.DataItem = dataItem;
            }
            OnItemCreated(e);
            Controls.Add(item);

            if (dataBind) {
                item.DataBind();
                OnItemDataBound(e);

                item.DataItem = null;
            }

            return item;
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.CreateItem1"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected virtual DataListItem CreateItem(int itemIndex, ListItemType itemType) {
            return new DataListItem(itemIndex, itemType);
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.GetItem"]/*' />
        private DataListItem GetItem(ListItemType itemType, int repeatIndex) {
            DataListItem item = null;

            switch (itemType) {
                case ListItemType.Header:
                    Debug.Assert(((IRepeatInfoUser)this).HasHeader);
                    item = (DataListItem)Controls[0];
                    break;
                case ListItemType.Footer:
                    Debug.Assert(((IRepeatInfoUser)this).HasFooter);
                    item = (DataListItem)Controls[Controls.Count - 1];
                    break;
                case ListItemType.Separator:
                    Debug.Assert(((IRepeatInfoUser)this).HasSeparators);
                    {
                        int controlIndex = repeatIndex * 2 + 1;
                        if (headerTemplate != null) {
                            controlIndex++;
                        }
                        item = (DataListItem)Controls[controlIndex];
                    }
                    break;
                case ListItemType.Item:
                case ListItemType.AlternatingItem:
                case ListItemType.SelectedItem:
                case ListItemType.EditItem:
                    item = (DataListItem)itemsArray[repeatIndex];
                    break;
            }

            return item;
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.InitializeItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected virtual void InitializeItem(DataListItem item) {
            ITemplate contentTemplate = itemTemplate;

            switch (item.ItemType) {
                case ListItemType.Header:
                    contentTemplate = headerTemplate;
                    break;

                case ListItemType.Footer:
                    contentTemplate = footerTemplate;
                    break;

                case ListItemType.AlternatingItem:
                    if (alternatingItemTemplate != null) {
                        contentTemplate = alternatingItemTemplate;
                    }
                    break;

                case ListItemType.SelectedItem:
                    if (selectedItemTemplate != null) {
                        contentTemplate = selectedItemTemplate;
                    }
                    else {
                        if (item.ItemIndex % 2 != 0)
                            goto case ListItemType.AlternatingItem;
                    }
                    break;

                case ListItemType.EditItem:
                    if (editItemTemplate != null) {
                        contentTemplate = editItemTemplate;
                    }
                    else {
                        if (item.ItemIndex == SelectedIndex)
                            goto case ListItemType.SelectedItem;
                        else if (item.ItemIndex % 2 != 0)
                            goto case ListItemType.AlternatingItem;
                    }
                    break;

                case ListItemType.Separator:
                    contentTemplate = separatorTemplate;
                    break;
            }

            if (contentTemplate != null)
                contentTemplate.InstantiateIn(item);
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void LoadViewState(object savedState) {
            if (savedState != null) {
                object[] myState = (object[])savedState;

                if (myState[0] != null)
                    base.LoadViewState(myState[0]);
                if (myState[1] != null)
                    ((IStateManager)ItemStyle).LoadViewState(myState[1]);
                if (myState[2] != null)
                    ((IStateManager)SelectedItemStyle).LoadViewState(myState[2]);
                if (myState[3] != null)
                    ((IStateManager)AlternatingItemStyle).LoadViewState(myState[3]);
                if (myState[4] != null)
                    ((IStateManager)EditItemStyle).LoadViewState(myState[4]);
                if (myState[5] != null)
                    ((IStateManager)SeparatorStyle).LoadViewState(myState[5]);
                if (myState[6] != null)
                    ((IStateManager)HeaderStyle).LoadViewState(myState[6]);
                if (myState[7] != null)
                    ((IStateManager)FooterStyle).LoadViewState(myState[7]);
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.TrackViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Marks the starting point to begin tracking and saving changes to the 
        ///       control as part of the control viewstate.</para>
        /// </devdoc>
        protected override void TrackViewState() {
            base.TrackViewState();

            if (itemStyle != null)
                ((IStateManager)itemStyle).TrackViewState();
            if (selectedItemStyle != null)
                ((IStateManager)selectedItemStyle).TrackViewState();
            if (alternatingItemStyle != null)
                ((IStateManager)alternatingItemStyle).TrackViewState();
            if (editItemStyle != null)
                ((IStateManager)editItemStyle).TrackViewState();
            if (separatorStyle != null)
                ((IStateManager)separatorStyle).TrackViewState();
            if (headerStyle != null)
                ((IStateManager)headerStyle).TrackViewState();
            if (footerStyle != null)
                ((IStateManager)footerStyle).TrackViewState();
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.OnBubbleEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override bool OnBubbleEvent(object source, EventArgs e) {
            bool handled = false;

            if (e is DataListCommandEventArgs) {
                DataListCommandEventArgs dce = (DataListCommandEventArgs)e;

                OnItemCommand(dce);
                handled = true;

                string command = dce.CommandName;

                if (String.Compare(command, DataList.SelectCommandName, true, CultureInfo.InvariantCulture) == 0) {
                    SelectedIndex = dce.Item.ItemIndex;
                    OnSelectedIndexChanged(EventArgs.Empty);
                }
                else if (String.Compare(command, DataList.EditCommandName, true, CultureInfo.InvariantCulture) == 0) {
                    OnEditCommand(dce);
                }
                else if (String.Compare(command, DataList.DeleteCommandName, true, CultureInfo.InvariantCulture) == 0) {
                    OnDeleteCommand(dce);
                }
                else if (String.Compare(command, DataList.UpdateCommandName, true, CultureInfo.InvariantCulture) == 0) {
                    OnUpdateCommand(dce);
                }
                else if (String.Compare(command, DataList.CancelCommandName, true, CultureInfo.InvariantCulture) == 0) {
                    OnCancelCommand(dce);
                }
            }

            return handled;
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.OnCancelCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='CancelCommand '/>event.</para>
        /// </devdoc>
        protected virtual void OnCancelCommand(DataListCommandEventArgs e) {
            DataListCommandEventHandler onCancelCommandHandler = (DataListCommandEventHandler)Events[EventCancelCommand];
            if (onCancelCommandHandler != null) onCancelCommandHandler(this, e);
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.OnDeleteCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='DeleteCommand '/>event.</para>
        /// </devdoc>
        protected virtual void OnDeleteCommand(DataListCommandEventArgs e) {
            DataListCommandEventHandler onDeleteCommandHandler = (DataListCommandEventHandler)Events[EventDeleteCommand];
            if (onDeleteCommandHandler != null) onDeleteCommandHandler(this, e);
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.OnEditCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='EditCommand '/>event.</para>
        /// </devdoc>
        protected virtual void OnEditCommand(DataListCommandEventArgs e) {
            DataListCommandEventHandler onEditCommandHandler = (DataListCommandEventHandler)Events[EventEditCommand];
            if (onEditCommandHandler != null) onEditCommandHandler(this, e);
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.OnItemCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='ItemCommand '/>event.</para>
        /// </devdoc>
        protected virtual void OnItemCommand(DataListCommandEventArgs e) {
            DataListCommandEventHandler onItemCommandHandler = (DataListCommandEventHandler)Events[EventItemCommand];
            if (onItemCommandHandler != null) onItemCommandHandler(this, e);
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.OnItemCreated"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='ItemCreated '/>event.</para>
        /// </devdoc>
        protected virtual void OnItemCreated(DataListItemEventArgs e) {
            DataListItemEventHandler onItemCreatedHandler = (DataListItemEventHandler)Events[EventItemCreated];
            if (onItemCreatedHandler != null) onItemCreatedHandler(this, e);
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.OnItemDataBound"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='ItemDataBound '/>event.</para>
        /// </devdoc>
        protected virtual void OnItemDataBound(DataListItemEventArgs e) {
            DataListItemEventHandler onItemDataBoundHandler = (DataListItemEventHandler)Events[EventItemDataBound];
            if (onItemDataBoundHandler != null) onItemDataBoundHandler(this, e);
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.OnUpdateCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='UpdateCommand '/>event.</para>
        /// </devdoc>
        protected virtual void OnUpdateCommand(DataListCommandEventArgs e) {
            DataListCommandEventHandler onUpdateCommandHandler = (DataListCommandEventHandler)Events[EventUpdateCommand];
            if (onUpdateCommandHandler != null) onUpdateCommandHandler(this, e);
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.PrepareControlHierarchy"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void PrepareControlHierarchy() {
            ControlCollection controls = Controls;
            int controlCount = controls.Count;

            if (controlCount == 0)
                return;

            // the composite alternating item style, so we need to do just one
            // merge style on the actual item
            Style altItemStyle = null;
            if (alternatingItemStyle != null) {
                altItemStyle = new TableItemStyle();
                altItemStyle.CopyFrom(itemStyle);
                altItemStyle.CopyFrom(alternatingItemStyle);
            }
            else {
                altItemStyle = itemStyle;
            }

            Style compositeStyle;

            for (int i = 0; i < controlCount; i++) {
                DataListItem item = (DataListItem)controls[i];
                compositeStyle = null;

                switch (item.ItemType) {
                    case ListItemType.Header:
                        if (ShowHeader)
                            compositeStyle = headerStyle;
                        break;

                    case ListItemType.Footer:
                        if (ShowFooter)
                            compositeStyle = footerStyle;
                        break;

                    case ListItemType.Separator:
                        compositeStyle = separatorStyle;
                        break;

                    case ListItemType.Item:
                        compositeStyle = itemStyle;
                        break;

                    case ListItemType.AlternatingItem:
                        compositeStyle = altItemStyle;
                        break;

                    case ListItemType.SelectedItem:
                        // When creating the control hierarchy we first check if the
                        // item is in edit mode, so we know this item cannot be in edit
                        // mode. The only special characteristic of this item is that
                        // it is selected.
                        {
                            compositeStyle = new TableItemStyle();

                            if (item.ItemIndex % 2 != 0)
                                compositeStyle.CopyFrom(altItemStyle);
                            else
                                compositeStyle.CopyFrom(itemStyle);
                            compositeStyle.CopyFrom(selectedItemStyle);
                        }
                        break;

                    case ListItemType.EditItem:
                        // When creating the control hierarchy, we first check if the
                        // item is in edit mode. So an item may be selected too, and
                        // so both editItemStyle (more specific) and selectedItemStyle
                        // are applied.
                        {
                            compositeStyle = new TableItemStyle();

                            if (item.ItemIndex % 2 != 0)
                                compositeStyle.CopyFrom(altItemStyle);
                            else
                                compositeStyle.CopyFrom(itemStyle);
                            if (item.ItemIndex == SelectedIndex)
                                compositeStyle.CopyFrom(selectedItemStyle);
                            compositeStyle.CopyFrom(editItemStyle);
                        }
                        break;
                }

                if (compositeStyle != null) {
                    // use the cached value of ExtractTemplateRows as it was at the time of
                    // control creation, so we don't do the wrong thing even if the
                    // user happened to change the property

                    if (extractTemplateRows == false) {
                        item.MergeStyle(compositeStyle);
                    }
                    else {
                        // apply the style on the TRs
                        IEnumerator controlEnum = item.Controls.GetEnumerator();

                        while (controlEnum.MoveNext()) {
                            Control c = (Control)controlEnum.Current;
                            if (c is Table) {
                                IEnumerator rowEnum = ((Table)c).Rows.GetEnumerator();

                                while (rowEnum.MoveNext()) {
                                    // REVIEW: Can this be an ApplyStyle... or could users
                                    //    have twiddled with styles on TRs in their OnItemCreated
                                    //    handlers... I guess they could have...
                                    ((TableRow)rowEnum.Current).MergeStyle(compositeStyle);
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.RenderContents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderContents(HtmlTextWriter writer) {
            if (Controls.Count == 0)
                return;

            RepeatInfo repeatInfo = new RepeatInfo();
            Table outerTable = null;

            // NOTE: This will end up creating the ControlStyle... Ideally we would
            //       not create the style just for rendering, but turns out our default
            //       style isn't empty, and does have an effect on rendering, and must
            //       therefore always be created
            Style style = ControlStyle;

            if (extractTemplateRows) {
                // The table tags in the templates are stripped out and only the
                // <tr>'s and <td>'s are assumed to come from the template itself.
                // This is equivalent to a flow layout of <tr>'s in a single
                // vertical column.

                repeatInfo.RepeatDirection = RepeatDirection.Vertical;
                repeatInfo.RepeatLayout = RepeatLayout.Flow;
                repeatInfo.RepeatColumns = 1;

                repeatInfo.OuterTableImplied = true;
                outerTable = new Table();

                // use ClientID (and not ID) since we want to render the fully qualified
                // ID even though the control will not be parented to the control hierarchy
                outerTable.ID = ClientID;

                outerTable.CopyBaseAttributes(this);
                outerTable.ApplyStyle(style);
                outerTable.RenderBeginTag(writer);
            }
            else {
                repeatInfo.RepeatDirection = RepeatDirection;
                repeatInfo.RepeatLayout = RepeatLayout;
                repeatInfo.RepeatColumns = RepeatColumns;
            }

            repeatInfo.RenderRepeater(writer, (IRepeatInfoUser)this, style, this);
            if (outerTable != null)
                outerTable.RenderEndTag(writer);
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.IRepeatInfoUser.HasFooter"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IRepeatInfoUser.HasFooter {
            get {
                return ShowFooter && (footerTemplate != null);
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.IRepeatInfoUser.HasHeader"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IRepeatInfoUser.HasHeader {
            get {
                return ShowHeader && (headerTemplate != null);
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.IRepeatInfoUser.HasSeparators"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        bool IRepeatInfoUser.HasSeparators {
            get {
                return (separatorTemplate != null);
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.IRepeatInfoUser.RepeatedItemCount"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        int IRepeatInfoUser.RepeatedItemCount {
            get {
                return (itemsArray != null) ? itemsArray.Count : 0;
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.IRepeatInfoUser.GetItemStyle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        Style IRepeatInfoUser.GetItemStyle(ListItemType itemType, int repeatIndex) {
            DataListItem item = GetItem(itemType, repeatIndex);

            if ((item != null) && item.ControlStyleCreated) {
                return item.ControlStyle;
            }
            return null;
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.IRepeatInfoUser.RenderItem"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        void IRepeatInfoUser.RenderItem(ListItemType itemType, int repeatIndex, RepeatInfo repeatInfo, HtmlTextWriter writer) {
            DataListItem item = GetItem(itemType, repeatIndex);

            if (item != null) {
                item.RenderItem(writer, extractTemplateRows, repeatInfo.RepeatLayout == RepeatLayout.Table);
            }
        }

        /// <include file='doc\DataList.uex' path='docs/doc[@for="DataList.SaveViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override object SaveViewState() {
            object baseState = base.SaveViewState();
            object itemStyleState = (itemStyle != null) ? ((IStateManager)itemStyle).SaveViewState() : null;
            object selectedItemStyleState = (selectedItemStyle != null) ? ((IStateManager)selectedItemStyle).SaveViewState() : null;
            object alternatingItemStyleState = (alternatingItemStyle != null) ? ((IStateManager)alternatingItemStyle).SaveViewState() : null;
            object editItemStyleState = (editItemStyle != null) ? ((IStateManager)editItemStyle).SaveViewState() : null;
            object separatorStyleState = (separatorStyle != null) ? ((IStateManager)separatorStyle).SaveViewState() : null;
            object headerStyleState = (headerStyle != null) ? ((IStateManager)headerStyle).SaveViewState() : null;
            object footerStyleState = (footerStyle != null) ? ((IStateManager)footerStyle).SaveViewState() : null;

            object[] myState = new object[8];
            myState[0] = baseState;
            myState[1] = itemStyleState;
            myState[2] = selectedItemStyleState;
            myState[3] = alternatingItemStyleState;
            myState[4] = editItemStyleState;
            myState[5] = separatorStyleState;
            myState[6] = headerStyleState;
            myState[7] = footerStyleState;

            // note that we always have some state, atleast the ItemCount
            return myState;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datalistitemcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataListItemCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.Security.Permissions;

    /// <include file='doc\DataListItemCollection.uex' path='docs/doc[@for="DataListItemCollection"]/*' />
    /// <devdoc>
    /// <para>Represents the collection of <see cref='System.Web.UI.WebControls.DataListItem'/> objects</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DataListItemCollection : ICollection {

        private ArrayList items;

        /// <include file='doc\DataListItemCollection.uex' path='docs/doc[@for="DataListItemCollection.DataListItemCollection"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.DataListItemCollection'/> class.</para>
        /// </devdoc>
        public DataListItemCollection(ArrayList items) {
            this.items = items;
        }

        /// <include file='doc\DataListItemCollection.uex' path='docs/doc[@for="DataListItemCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of items in the collection.</para>
        /// </devdoc>
        public int Count {
            get {
                return items.Count;
            }
        }
        /// <include file='doc\DataListItemCollection.uex' path='docs/doc[@for="DataListItemCollection.IsReadOnly"]/*' />
        /// <devdoc>
        /// <para>Gets a value that specifies whether items in the <see cref='System.Web.UI.WebControls.DataListItemCollection'/> can be modified.</para>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return false;
            }
        }
        /// <include file='doc\DataListItemCollection.uex' path='docs/doc[@for="DataListItemCollection.IsSynchronized"]/*' />
        /// <devdoc>
        /// <para>Gets a value that indicates whether the <see cref='System.Web.UI.WebControls.DataListItemCollection'/> is thread-safe.</para>
        /// </devdoc>
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\DataListItemCollection.uex' path='docs/doc[@for="DataListItemCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>Gets the object used to synchronize access to the collection. </para>
        /// </devdoc>
        public object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\DataListItemCollection.uex' path='docs/doc[@for="DataListItemCollection.this"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='System.Web.UI.WebControls.DataListItem'/> at the specified index in the 
        ///    collection.</para>
        /// </devdoc>
        public DataListItem this[int index] {
            get {
                return(DataListItem)items[index];
            }
        }


        /// <include file='doc\DataListItemCollection.uex' path='docs/doc[@for="DataListItemCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the contents of the entire collection into an <see cref='System.Array' qualify='true'/> appending at 
        ///    the specified index of the <see cref='System.Array' qualify='true'/>.</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\DataListItemCollection.uex' path='docs/doc[@for="DataListItemCollection.GetEnumerator"]/*' />
        /// <devdoc>
        /// <para>Creates an enumerator for the <see cref='System.Web.UI.WebControls.DataListItemCollection'/> used to iterate 
        ///    through the collection.</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return items.GetEnumerator(); 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datalistitemeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataListItemEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Security.Permissions;

    /// <include file='doc\DataListItemEventArgs.uex' path='docs/doc[@for="DataListItemEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see langword='DataListItem'/> event of a <see cref='System.Web.UI.WebControls.DataList'/> .</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DataListItemEventArgs : EventArgs {

        private DataListItem item;

        /// <include file='doc\DataListItemEventArgs.uex' path='docs/doc[@for="DataListItemEventArgs.DataListItemEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.DataListItemEventArgs'/> class.</para>
        /// </devdoc>
        public DataListItemEventArgs(DataListItem item) {
            this.item = item;
        }


        /// <include file='doc\DataListItemEventArgs.uex' path='docs/doc[@for="DataListItemEventArgs.Item"]/*' />
        /// <devdoc>
        /// <para>Gets the item form the <see cref='System.Web.UI.WebControls.DataList'/>.</para>
        /// </devdoc>
        public DataListItem Item {
            get {
                return item;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\dayrendereventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DayRenderEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Web.UI.WebControls {


    /// <include file='doc\DayRenderEventHandler.uex' path='docs/doc[@for="DayRenderEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle 
    ///       the <see langword='DayRender'/> event of a
    ///    <see cref='System.Web.UI.WebControls.Calendar'/>.</para>
    /// </devdoc>
    public delegate void DayRenderEventHandler(object sender, DayRenderEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\datalistitemeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataListItemEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\DataListItemEventHandler.uex' path='docs/doc[@for="DataListItemEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle the 
    ///    <see langword='DataListItem'/> event of a <see cref='System.Web.UI.WebControls.DataList'/> .</para>
    /// </devdoc>
    public delegate void DataListItemEventHandler(object sender, DataListItemEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\daynameformat.cs ===
//------------------------------------------------------------------------------
// <copyright file="DayNameFormat.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {
    
    /// <include file='doc\DayNameFormat.uex' path='docs/doc[@for="DayNameFormat"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the format for the name of days.
    ///    </para>
    /// </devdoc>
    public enum DayNameFormat {
        /// <include file='doc\DayNameFormat.uex' path='docs/doc[@for="DayNameFormat.Full"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The day name displayed in full.
        ///    </para>
        /// </devdoc>
        Full = 0,
        /// <include file='doc\DayNameFormat.uex' path='docs/doc[@for="DayNameFormat.Short"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The day name displayed in short format.
        ///    </para>
        /// </devdoc>
        Short = 1,
        /// <include file='doc\DayNameFormat.uex' path='docs/doc[@for="DayNameFormat.FirstLetter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The day name displayed with just the first letter.
        ///    </para>
        /// </devdoc>
        FirstLetter = 2,
        /// <include file='doc\DayNameFormat.uex' path='docs/doc[@for="DayNameFormat.FirstTwoLetters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The day name displayed with just the first two letters.
        ///    </para>
        /// </devdoc>
        FirstTwoLetters = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\dayrenderevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="DayRenderEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System.Security.Permissions;

    /// <include file='doc\DayRenderEvent.uex' path='docs/doc[@for="DayRenderEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see langword='DayRender'/> event of a <see cref='System.Web.UI.WebControls.Calendar'/>.
    /// </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DayRenderEventArgs {
        CalendarDay day;
        TableCell cell;

        /// <include file='doc\DayRenderEvent.uex' path='docs/doc[@for="DayRenderEventArgs.DayRenderEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.DayRenderEventArgs'/> class.</para>
        /// </devdoc>
        public DayRenderEventArgs(TableCell cell, CalendarDay day) {
            this.day = day;
            this.cell = cell;
        }

        /// <include file='doc\DayRenderEvent.uex' path='docs/doc[@for="DayRenderEventArgs.Cell"]/*' />
        /// <devdoc>
        ///    <para>Gets the cell that contains the day. This property is read-only.</para>
        /// </devdoc>
        public TableCell Cell {
            get {
                return cell;
            }
        } 

        /// <include file='doc\DayRenderEvent.uex' path='docs/doc[@for="DayRenderEventArgs.Day"]/*' />
        /// <devdoc>
        ///    <para>Gets the day to render. This property is read-only.</para>
        /// </devdoc>
        public CalendarDay Day {
            get {
                return day;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\dummydatasource.cs ===
//------------------------------------------------------------------------------
// <copyright file="DummyDataSource.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.Diagnostics;

    /// <include file='doc\DummyDataSource.uex' path='docs/doc[@for="DummyDataSource"]/*' />
    /// <devdoc>
    /// </devdoc>
    internal sealed class DummyDataSource : ICollection {

        private int dataItemCount;

        internal DummyDataSource(int dataItemCount) {
            this.dataItemCount = dataItemCount;
        }

        public int Count {
            get {
                return dataItemCount;
            }
        }

        internal bool IsReadOnly {
            get {
                return false;
            }
        }

        public bool IsSynchronized {
            get {
                return false;
            }
        }

        public Object SyncRoot {
            get {
                return this;
            }
        }

        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        public IEnumerator GetEnumerator() {
            return new DummyDataSourceEnumerator(dataItemCount);
        }


        private class DummyDataSourceEnumerator : IEnumerator {

            private int count;
            private int index;

            public DummyDataSourceEnumerator(int count) {
                this.count = count;
                this.index = -1;
            }

            public object Current {
                get {
                    return null;
                }
            }

            public bool MoveNext() {
                index++;
                return index < count;
            }

            public void Reset() {
                this.index = -1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\firstdayofweek.cs ===
//------------------------------------------------------------------------------
// <copyright file="FirstDayOfWeek.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {
    
    /// <include file='doc\FirstDayOfWeek.uex' path='docs/doc[@for="FirstDayOfWeek"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the first day of the week.
    ///    </para>
    /// </devdoc>
    public enum FirstDayOfWeek {
        /// <include file='doc\FirstDayOfWeek.uex' path='docs/doc[@for="FirstDayOfWeek.Sunday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The first day if the week is Sunday.
        ///    </para>
        /// </devdoc>
        Sunday = 0,
        /// <include file='doc\FirstDayOfWeek.uex' path='docs/doc[@for="FirstDayOfWeek.Monday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The first day if the week is Monday.
        ///    </para>
        /// </devdoc>
        Monday = 1,
        /// <include file='doc\FirstDayOfWeek.uex' path='docs/doc[@for="FirstDayOfWeek.Tuesday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The first day if the week is Tuesday.
        ///    </para>
        /// </devdoc>
        Tuesday = 2,
        /// <include file='doc\FirstDayOfWeek.uex' path='docs/doc[@for="FirstDayOfWeek.Wednesday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The first day if the week is Wednesday.
        ///    </para>
        /// </devdoc>
        Wednesday = 3,
        /// <include file='doc\FirstDayOfWeek.uex' path='docs/doc[@for="FirstDayOfWeek.Thursday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The first day if the week is Thursday.
        ///    </para>
        /// </devdoc>
        Thursday = 4,
        /// <include file='doc\FirstDayOfWeek.uex' path='docs/doc[@for="FirstDayOfWeek.Friday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The first day if the week is Friday.
        ///    </para>
        /// </devdoc>
        Friday = 5,
        /// <include file='doc\FirstDayOfWeek.uex' path='docs/doc[@for="FirstDayOfWeek.Saturday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The first day if the week is Saturday.
        ///    </para>
        /// </devdoc>
        Saturday = 6,
        /// <include file='doc\FirstDayOfWeek.uex' path='docs/doc[@for="FirstDayOfWeek.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The first day if the week is the system specified day.
        ///    </para>
        /// </devdoc>
        Default = 7
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\dropdownlist.cs ===
//------------------------------------------------------------------------------
// <copyright file="DropDownList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Collections.Specialized;
    using System.Drawing;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\DropDownList.uex' path='docs/doc[@for="DropDownList"]/*' />
    /// <devdoc>
    ///    <para>Creates a control that allows the user to select a single item from a
    ///       drop-down list.</para>
    /// </devdoc>
    [
    ValidationProperty("SelectedItem")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DropDownList : ListControl, IPostBackDataHandler {

        /// <include file='doc\DropDownList.uex' path='docs/doc[@for="DropDownList.DropDownList"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.DropDownList'/> class.</para>
        /// </devdoc>
        public DropDownList() {
        }

        /// <include file='doc\DropDownList.uex' path='docs/doc[@for="DropDownList.BorderColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false)
        ]
        public override Color BorderColor {
            get {
                return base.BorderColor;
            }
            set {
                base.BorderColor = value;
            }
        }

        /// <include file='doc\DropDownList.uex' path='docs/doc[@for="DropDownList.BorderStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false)
        ]
        public override BorderStyle BorderStyle {
            get {
                return base.BorderStyle;
            }
            set {
                base.BorderStyle = value;
            }
        }

        /// <include file='doc\DropDownList.uex' path='docs/doc[@for="DropDownList.BorderWidth"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false)
        ]
        public override Unit BorderWidth {
            get {
                return base.BorderWidth;
            }
            set {
                base.BorderWidth = value;
            }
        }

        /// <include file='doc\DropDownList.uex' path='docs/doc[@for="DropDownList.SelectedIndex"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the index of the item selected by the user
        ///       from the <see cref='System.Web.UI.WebControls.DropDownList'/>
        ///       control.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(0),
        WebSysDescription(SR.DropDownList_SelectedIndex),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public override int SelectedIndex {
            get {
                int selectedIndex = base.SelectedIndex;
                if (selectedIndex < 0 && Items.Count > 0) {
                    Items[0].Selected = true;
                    selectedIndex = 0;
                }
                return selectedIndex;
            }
            set {
                base.SelectedIndex = value;
            }
        }

        /// <include file='doc\DropDownList.uex' path='docs/doc[@for="DropDownList.ToolTip"]/*' />
        [
        Bindable(false),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        EditorBrowsableAttribute(EditorBrowsableState.Never)
        ]
        public override string ToolTip {
            get {
                return String.Empty;
            }
            set {
                // NOTE: do not throw a NotSupportedException here.
                //       In WebControl::CopyBaseAttributes we copy over attributes to a target control,
                //       including ToolTip. We should not throw in that case, but just ignore the setting.
            }
        }

        /// <include file='doc\DropDownList.uex' path='docs/doc[@for="DropDownList.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Adds the properties of the <see cref='System.Web.UI.WebControls.DropDownList'/> control to the
        ///    output stream for rendering on the client.</para>
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {

            // Make sure we are in a form tag with runat=server.
            if (Page != null) {
                Page.VerifyRenderingInServerForm(this);
            }

            writer.AddAttribute(HtmlTextWriterAttribute.Name,UniqueID);

            if (AutoPostBack && Page != null) {
                // ASURT 98368
                // Need to merge the autopostback script with the user script
                string onChange = Page.GetPostBackClientEvent(this, "");
                if (HasAttributes) {
                    string userOnChange = Attributes["onchange"];
                    if (userOnChange != null) {
                        onChange = userOnChange + onChange;
                        Attributes.Remove("onchange");
                    }
                }
                writer.AddAttribute(HtmlTextWriterAttribute.Onchange, onChange);
                writer.AddAttribute("language", "javascript");
            }

            base.AddAttributesToRender(writer);
        }

        /// <include file='doc\DropDownList.uex' path='docs/doc[@for="DropDownList.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Process posted data for the <see cref='System.Web.UI.WebControls.DropDownList'/> control.</para>
        /// </devdoc>
        bool IPostBackDataHandler.LoadPostData(String postDataKey, NameValueCollection postCollection) {
            string [] selectedItems = postCollection.GetValues(postDataKey);

            if (selectedItems != null) {
                int n = Items.FindByValueInternal(selectedItems[0]);
                if (SelectedIndex != n) {
                    SelectedIndex = n;
                    return true;
                }
            }

            return false;
        }

        /// <include file='doc\DropDownList.uex' path='docs/doc[@for="DropDownList.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Raises events for the <see cref='System.Web.UI.WebControls.DropDownList'/> control on post back.</para>
        /// </devdoc>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
            OnSelectedIndexChanged(EventArgs.Empty);
        }

        /// <include file='doc\DropDownList.uex' path='docs/doc[@for="DropDownList.CreateControlCollection"]/*' />
        protected override ControlCollection CreateControlCollection() {
            return new EmptyControlCollection(this);
        }

        /// <include file='doc\DropDownList.uex' path='docs/doc[@for="DropDownList.RenderContents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Displays the <see cref='System.Web.UI.WebControls.DropDownList'/> control on the client.</para>
        /// </devdoc>
        protected override void RenderContents(HtmlTextWriter writer) {
            ListItemCollection liCollection = Items;
            int n = Items.Count;
            bool selected = false;

            if (n > 0) {
                for (int i=0; i < n; i++) {
                    ListItem li = liCollection[i];
                    writer.WriteBeginTag("option");
                    if (li.Selected) {
                        if (selected) {
                            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cant_Multiselect_In_DropDownList));
                        }
                        selected = true;
                        writer.WriteAttribute("selected", "selected", false);
                    }

                    writer.WriteAttribute("value", li.Value, true /*fEncode*/);
                    writer.Write(HtmlTextWriter.TagRightChar);
                    HttpUtility.HtmlEncode(li.Text, writer);
                    writer.WriteEndTag("option");
                    writer.WriteLine();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\fontunit.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontUnit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.ComponentModel;
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit"]/*' />
    /// <devdoc>
    ///    <para>Respresent the font unit.</para>
    /// </devdoc>
    [
        TypeConverterAttribute(typeof(FontUnitConverter))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public struct FontUnit {

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.Empty"]/*' />
        /// <devdoc>
        /// <para>Specifies an empty <see cref='System.Web.UI.WebControls.FontUnit'/>. This field is read only. </para>
        /// </devdoc>
        public static readonly FontUnit Empty = new FontUnit();

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.Smaller"]/*' />
        /// <devdoc>
        /// <para>Specifies a <see cref='System.Web.UI.WebControls.FontUnit'/> with 
        /// <see langword='FontSize.Smaller'/> font. This field is read only. </para>
        /// </devdoc>
        public static readonly FontUnit Smaller = new FontUnit(FontSize.Smaller);
        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.Larger"]/*' />
        /// <devdoc>
        /// <para>Specifies a <see cref='System.Web.UI.WebControls.FontUnit'/> with <see langword='FontSize.Larger'/> 
        /// font. This field is read only.</para>
        /// </devdoc>
        public static readonly FontUnit Larger = new FontUnit(FontSize.Larger);
        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.XXSmall"]/*' />
        /// <devdoc>
        /// <para>Specifies a <see cref='System.Web.UI.WebControls.FontUnit'/> with 
        /// <see langword='FontSize.XXSmall'/> font. This field is read only.</para>
        /// </devdoc>
        public static readonly FontUnit XXSmall = new FontUnit(FontSize.XXSmall);
        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.XSmall"]/*' />
        /// <devdoc>
        /// <para>Specifies a <see cref='System.Web.UI.WebControls.FontUnit'/> with <see langword='FontSize.XSmall'/> 
        /// font. This field is read only.</para>
        /// </devdoc>
        public static readonly FontUnit XSmall = new FontUnit(FontSize.XSmall);
        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.Small"]/*' />
        /// <devdoc>
        /// <para>Specifies a <see cref='System.Web.UI.WebControls.FontUnit'/> with <see langword='FontSize.Small'/> 
        /// font. This field is read only.</para>
        /// </devdoc>
        public static readonly FontUnit Small = new FontUnit(FontSize.Small);
        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.Medium"]/*' />
        /// <devdoc>
        /// <para>Specifies a <see cref='System.Web.UI.WebControls.FontUnit'/> with <see langword='FontSize.Medium'/> 
        /// font. This field is read only.</para>
        /// </devdoc>
        public static readonly FontUnit Medium = new FontUnit(FontSize.Medium);
        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.Large"]/*' />
        /// <devdoc>
        /// <para>Specifies a <see cref='System.Web.UI.WebControls.FontUnit'/> with <see langword='FontSize.Large'/> 
        /// font. This field is read only.</para>
        /// </devdoc>
        public static readonly FontUnit Large = new FontUnit(FontSize.Large);
        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.XLarge"]/*' />
        /// <devdoc>
        /// <para>Specifies a <see cref='System.Web.UI.WebControls.FontUnit'/> with <see langword='FontSize.XLarge'/> 
        /// font. This field is read only.</para>
        /// </devdoc>
        public static readonly FontUnit XLarge = new FontUnit(FontSize.XLarge);
        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.XXLarge"]/*' />
        /// <devdoc>
        ///    Specifies a <see cref='System.Web.UI.WebControls.FontUnit'/> with
        /// <see langword='FontSize.XXLarge'/> font. This field is read only.
        /// </devdoc>
        public static readonly FontUnit XXLarge = new FontUnit(FontSize.XXLarge);


        private FontSize type;
        private Unit value;
        
        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.FontUnit"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.FontUnit'/> class with a <see cref='System.Web.UI.WebControls.FontSize'/>.</para>
        /// </devdoc>
        public FontUnit(FontSize type) {
            if (type < FontSize.NotSet || type > FontSize.XXLarge) {
                throw new ArgumentOutOfRangeException("type");
            }
            this.type = type;
            if (this.type == FontSize.AsUnit) {
                value = Unit.Point(10);
            }
            else {
                value = Unit.Empty;
            }
        }

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.FontUnit1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.FontUnit'/> class with a <see cref='System.Web.UI.WebControls.Unit'/>.</para>
        /// </devdoc>
        public FontUnit(Unit value) {
            this.type = FontSize.NotSet;
            if (value.IsEmpty == false) {
                this.type = FontSize.AsUnit;
                this.value = value;
            }
            else {
                this.value = Unit.Empty;
            }
        }

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.FontUnit2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.FontUnit'/> class with an integer value.</para>
        /// </devdoc>
        public FontUnit(int value) {
            this.type = FontSize.AsUnit;
            this.value = Unit.Point(value);
        }

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.FontUnit3"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.FontUnit'/> class with a string.</para>
        /// </devdoc>
        public FontUnit(string value) : this(value, CultureInfo.CurrentCulture) {
        }

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.FontUnit4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public FontUnit(string value, CultureInfo culture) {
            this.type = FontSize.NotSet;
            this.value = Unit.Empty;

            if ((value != null) && (value.Length > 0)) {
                // This is invariant because it acts like an enum with a number together. 
                // The enum part is invariant, but the number uses current culture. 
                char firstChar = Char.ToLower(value[0], CultureInfo.InvariantCulture);
                if (firstChar == 'x') {
                    string lcaseValue = value.ToLower(CultureInfo.InvariantCulture);

                    if (lcaseValue.Equals("xx-small") || lcaseValue.Equals("xxsmall")) {
                        this.type = FontSize.XXSmall;
                        return;
                    }
                    else if (lcaseValue.Equals("x-small") || lcaseValue.Equals("xsmall")) {
                        this.type = FontSize.XSmall;
                        return;
                    }
                    else if (lcaseValue.Equals("x-large") || lcaseValue.Equals("xlarge")) {
                        this.type = FontSize.XLarge;
                        return;
                    }
                    else if (lcaseValue.Equals("xx-large") || lcaseValue.Equals("xxlarge")) {
                        this.type = FontSize.XXLarge;
                        return;
                    }
                }
                else if (firstChar == 's') {
                    string lcaseValue = value.ToLower(CultureInfo.InvariantCulture);
                    if (lcaseValue.Equals("small")) {
                        this.type = FontSize.Small;
                        return;
                    }
                    else if (lcaseValue.Equals("smaller")) {
                        this.type = FontSize.Smaller;
                        return;
                    }
                }
                else if (firstChar == 'l') {
                    string lcaseValue = value.ToLower(CultureInfo.InvariantCulture);
                    if (lcaseValue.Equals("large")) {
                        this.type = FontSize.Large;
                        return;
                    }
                    if (lcaseValue.Equals("larger")) {
                        this.type = FontSize.Larger;
                        return;
                    }
                }
                else if ((firstChar == 'm') && (value.ToLower(CultureInfo.InvariantCulture).Equals("medium"))) {
                    this.type = FontSize.Medium;
                    return;
                }

                this.value = new Unit(value, culture, UnitType.Point);
                this.type = FontSize.AsUnit;
            }
        }
        

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.IsEmpty"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the font size has been set.</para>
        /// </devdoc>
        public bool IsEmpty {
            get {
                return type == FontSize.NotSet;
            }
        }

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.Type"]/*' />
        /// <devdoc>
        ///    <para>Indicates the font size by type.</para>
        /// </devdoc>
        public FontSize Type {
            get {
                return type;
            }
        }
        
        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.Unit"]/*' />
        /// <devdoc>
        /// <para>Indicates the font size by <see cref='System.Web.UI.WebControls.Unit'/>.</para>
        /// </devdoc>
        public Unit Unit {
            get {
                return value;
            }
        }

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return type.GetHashCode() << 2 ^ value.GetHashCode();
        }

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.Equals"]/*' />
        /// <devdoc>
        /// <para>Determines if the specified <see cref='System.Object' qualify='true'/> is equivilent to the <see cref='System.Web.UI.WebControls.FontUnit'/> represented by this instance.</para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj == null || !(obj is FontUnit))
                return false;

            FontUnit f = (FontUnit)obj;

            if ((f.type == type) && (f.value == value)) {
                return true;
            }
            return false;
        }

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.operator=="]/*' />
        /// <devdoc>
        /// <para>Compares two <see cref='System.Web.UI.WebControls.FontUnit'/> objects for equality.</para>
        /// </devdoc>
        public static bool operator ==(FontUnit left, FontUnit right) {
            return ((left.type == right.type) && (left.value == right.value));                
        }
        
        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.operator!="]/*' />
        /// <devdoc>
        /// <para>Compares two <see cref='System.Web.UI.WebControls.FontUnit'/> objects 
        ///    for inequality.</para>
        /// </devdoc>
        public static bool operator !=(FontUnit left, FontUnit right) {
            return ((left.type != right.type) || (left.value != right.value));                
        }

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.Parse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static FontUnit Parse(string s) {
            return new FontUnit(s);
        }

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.Parse1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static FontUnit Parse(string s, CultureInfo culture) {
            return new FontUnit(s, culture);
        }
        
        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.Point"]/*' />
        /// <devdoc>
        /// <para>Creates a <see cref='System.Web.UI.WebControls.FontUnit'/> of type Point from an integer value.</para>
        /// </devdoc>
        public static FontUnit Point(int n) {
            return new FontUnit(n);
        }

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.ToString"]/*' />
        /// <devdoc>
        /// <para>Convert a <see cref='System.Web.UI.WebControls.FontUnit'/> to a string.</para>
        /// </devdoc>
        public override string ToString() {
            return ToString(null);
        }

        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.ToString1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ToString(CultureInfo culture) {
            string s = String.Empty;

            if (IsEmpty)
                return s;

            switch (type) {
                case FontSize.AsUnit:
                    s = value.ToString(culture);
                    break;
                case FontSize.XXSmall:
                    s = "XX-Small";
                    break;
                case FontSize.XSmall:
                    s = "X-Small";
                    break;
                case FontSize.XLarge:
                    s = "X-Large";
                    break;
                case FontSize.XXLarge:
                    s = "XX-Large";
                    break;
                default:
                    s = PropertyConverter.EnumToString(typeof(FontSize), type);
                    break;
            }
            return s;
        }
        
        /// <include file='doc\FontUnit.uex' path='docs/doc[@for="FontUnit.operatorFontUnit"]/*' />
        /// <devdoc>
        /// <para>Implicitly creates a <see cref='System.Web.UI.WebControls.FontUnit'/> of type Point from an integer value.</para>
        /// </devdoc>
        public static implicit operator FontUnit(int n) {
            return FontUnit.Point(n);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\fontsize.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontSize.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// FontSize.cs
//

namespace System.Web.UI.WebControls {
    
    using System;

    /// <include file='doc\FontSize.uex' path='docs/doc[@for="FontSize"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the font size.
    ///    </para>
    /// </devdoc>
    public enum FontSize {

        /// <include file='doc\FontSize.uex' path='docs/doc[@for="FontSize.NotSet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The font size is not set.
        ///    </para>
        /// </devdoc>
        NotSet = 0,
        
        /// <include file='doc\FontSize.uex' path='docs/doc[@for="FontSize.AsUnit"]/*' />
        /// <devdoc>
        ///    <para>The font size is specified as point values.</para>
        /// </devdoc>
        AsUnit = 1,
        
        /// <include file='doc\FontSize.uex' path='docs/doc[@for="FontSize.Smaller"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The font size is smaller.
        ///    </para>
        /// </devdoc>
        Smaller = 2,

        /// <include file='doc\FontSize.uex' path='docs/doc[@for="FontSize.Larger"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The font size is larger.
        ///    </para>
        /// </devdoc>
        Larger = 3,

        /// <include file='doc\FontSize.uex' path='docs/doc[@for="FontSize.XXSmall"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The font size is extra extra small.
        ///    </para>
        /// </devdoc>
        XXSmall = 4,

        /// <include file='doc\FontSize.uex' path='docs/doc[@for="FontSize.XSmall"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The font size is extra small.
        ///    </para>
        /// </devdoc>
        XSmall = 5,

        /// <include file='doc\FontSize.uex' path='docs/doc[@for="FontSize.Small"]/*' />
        /// <devdoc>
        ///    <para> The font size is small.</para>
        /// </devdoc>
        Small = 6,

        /// <include file='doc\FontSize.uex' path='docs/doc[@for="FontSize.Medium"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The font size is medium.
        ///    </para>
        /// </devdoc>
        Medium = 7,

        /// <include file='doc\FontSize.uex' path='docs/doc[@for="FontSize.Large"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The font size is large.
        ///    </para>
        /// </devdoc>
        Large = 8,

        /// <include file='doc\FontSize.uex' path='docs/doc[@for="FontSize.XLarge"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The font size is extra large.
        ///    </para>
        /// </devdoc>
        XLarge = 9,

        /// <include file='doc\FontSize.uex' path='docs/doc[@for="FontSize.XXLarge"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The font size is extra extra large.
        ///    </para>
        /// </devdoc>
        XXLarge = 10
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\editcommandcolumn.cs ===
//------------------------------------------------------------------------------
// <copyright file="EditCommandColumn.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\EditCommandColumn.uex' path='docs/doc[@for="EditCommandColumn"]/*' />
    /// <devdoc>
    /// <para>Creates a special column with buttons for <see langword='Edit'/>, 
    /// <see langword='Update'/>, and <see langword='Cancel'/> commands to edit items 
    ///    within the selected row.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class EditCommandColumn : DataGridColumn {

        /// <include file='doc\EditCommandColumn.uex' path='docs/doc[@for="EditCommandColumn.EditCommandColumn"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of an <see cref='System.Web.UI.WebControls.EditCommandColumn'/> class.</para>
        /// </devdoc>
        public EditCommandColumn() {
        }


        /// <include file='doc\EditCommandColumn.uex' path='docs/doc[@for="EditCommandColumn.ButtonType"]/*' />
        /// <devdoc>
        ///    <para>Indicates the button type for the column.</para>
        /// </devdoc>
        public virtual ButtonColumnType ButtonType {
            get {
                object o = ViewState["ButtonType"];
                if (o != null)
                    return(ButtonColumnType)o;
                return ButtonColumnType.LinkButton;
            }
            set {
                if (value < ButtonColumnType.LinkButton || value > ButtonColumnType.PushButton) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["ButtonType"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\EditCommandColumn.uex' path='docs/doc[@for="EditCommandColumn.CancelText"]/*' />
        /// <devdoc>
        /// <para>Indicates the text to display for the <see langword='Cancel'/> command button 
        ///    in the column.</para>
        /// </devdoc>
        public virtual string CancelText {
            get {
                object o = ViewState["CancelText"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["CancelText"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\EditCommandColumn.uex' path='docs/doc[@for="EditCommandColumn.EditText"]/*' />
        /// <devdoc>
        /// <para>Indicates the text to display for the <see langword='Edit'/> command button in 
        ///    the column.</para>
        /// </devdoc>
        public virtual string EditText {
            get {
                object o = ViewState["EditText"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["EditText"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\EditCommandColumn.uex' path='docs/doc[@for="EditCommandColumn.UpdateText"]/*' />
        /// <devdoc>
        /// <para>Indicates the text to display for the <see langword='Update'/> command button 
        ///    in the column.</para>
        /// </devdoc>
        public virtual string UpdateText {
            get {
                object o = ViewState["UpdateText"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["UpdateText"] = value;
                OnColumnChanged();
            }
        }


        /// <include file='doc\EditCommandColumn.uex' path='docs/doc[@for="EditCommandColumn.InitializeCell"]/*' />
        /// <devdoc>
        ///    <para>Initializes a cell within the column.</para>
        /// </devdoc>
        public override void InitializeCell(TableCell cell, int columnIndex, ListItemType itemType) {
            base.InitializeCell(cell, columnIndex, itemType);

            if ((itemType != ListItemType.Header) &&
                (itemType != ListItemType.Footer)) {
                if (itemType == ListItemType.EditItem) {
                    ControlCollection controls = cell.Controls;
                    ButtonColumnType buttonType = ButtonType;
                    WebControl buttonControl = null;

                    if (buttonType == ButtonColumnType.LinkButton) {
                        LinkButton button = new DataGridLinkButton();

                        buttonControl = button;
                        button.CommandName = DataGrid.UpdateCommandName;
                        button.Text = UpdateText;
                    }
                    else {
                        Button button = new Button();

                        buttonControl = button;
                        button.CommandName = DataGrid.UpdateCommandName;
                        button.Text = UpdateText;
                    }

                    controls.Add(buttonControl);

                    LiteralControl spaceControl = new LiteralControl("&nbsp;");
                    controls.Add(spaceControl);

                    if (buttonType == ButtonColumnType.LinkButton) {
                        LinkButton button = new DataGridLinkButton();

                        buttonControl = button;
                        button.CommandName = DataGrid.CancelCommandName;
                        button.Text = CancelText;
                        button.CausesValidation = false;
                    }
                    else {
                        Button button = new Button();

                        buttonControl = button;
                        button.CommandName = DataGrid.CancelCommandName;
                        button.Text = CancelText;
                        button.CausesValidation = false;
                    }

                    controls.Add(buttonControl);
                }
                else {
                    ControlCollection controls = cell.Controls;
                    ButtonColumnType buttonType = ButtonType;
                    WebControl buttonControl = null;

                    if (buttonType == ButtonColumnType.LinkButton) {
                        LinkButton button = new DataGridLinkButton();

                        buttonControl = button;
                        button.CommandName = DataGrid.EditCommandName;
                        button.Text = EditText;
                        button.CausesValidation = false;
                    }
                    else {
                        Button button = new Button();

                        buttonControl = button;
                        button.CommandName = DataGrid.EditCommandName;
                        button.Text = EditText;
                        button.CausesValidation = false;
                    }

                    controls.Add(buttonControl);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\fontinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System.ComponentModel.Design;
    using System;
    using System.ComponentModel;
    using System.Collections; 
    using System.Drawing;   
    using System.Drawing.Design;
    using System.Web;
    using System.Security.Permissions;

    /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo"]/*' />
    /// <devdoc>
    ///    <para>Represents the font properties for text. This class cannot be inherited.</para>
    /// </devdoc>
    [
        TypeConverterAttribute(typeof(ExpandableObjectConverter))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class FontInfo {

        private Style owner;

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.FontInfo"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal FontInfo(Style owner) {
            this.owner = owner;
        }

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.Bold"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the text is bold.</para>
        /// </devdoc>
        [
            Bindable(true),
            WebCategory("Appearance"),
            DefaultValue(false),
            WebSysDescription(SR.FontInfo_Bold),
            NotifyParentProperty(true)
        ]
        public bool Bold {
            get {
                if (owner.IsSet(Style.PROP_FONT_BOLD)) {
                    return (bool)(owner.ViewState["Font_Bold"]);
                }
                return false;
            }
            set {
                owner.ViewState["Font_Bold"] = value;
                owner.SetBit(Style.PROP_FONT_BOLD);
            }
        }

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.Italic"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the text is italic.</para>
        /// </devdoc>
        [
            Bindable(true),
            WebCategory("Appearance"),
            DefaultValue(false),
            WebSysDescription(SR.FontInfo_Italic),
            NotifyParentProperty(true)
        ]
        public bool Italic {
            get {
                if (owner.IsSet(Style.PROP_FONT_ITALIC)) {
                    return (bool)(owner.ViewState["Font_Italic"]);
                }
                return false;
            }
            set {
                owner.ViewState["Font_Italic"] = value;
                owner.SetBit(Style.PROP_FONT_ITALIC);
            }
        }

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.Name"]/*' />
        /// <devdoc>
        ///    <para>Indicates the name of the font.</para>
        /// </devdoc>
        [
            Bindable(true),
            Editor("System.Drawing.Design.FontNameEditor, " + AssemblyRef.SystemDrawingDesign, typeof(UITypeEditor)),
            TypeConverterAttribute(typeof(FontConverter.FontNameConverter)),
            WebCategory("Appearance"),
            DefaultValue(""),
            WebSysDescription(SR.FontInfo_Name),
            NotifyParentProperty(true),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public string Name {
            get {
                string[] names = Names;
                if (names.Length > 0)
                    return names[0];
                return String.Empty;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("value");

                if (value.Length == 0) {
                    Names = null;
                }
                else {
                    Names = new string[1] { value };
                }
            }
        }

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.Names"]/*' />
        /// <devdoc>
        /// </devdoc>
        [
            TypeConverterAttribute(typeof(FontNamesConverter)),
            WebCategory("Appearance"),
            Editor("System.Windows.Forms.Design.StringArrayEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
            WebSysDescription(SR.FontInfo_Names),
            NotifyParentProperty(true)
        ]
        public string[] Names {
            get {
                if (owner.IsSet(Style.PROP_FONT_NAMES)) {
                    string[] names = (string[])owner.ViewState["Font_Names"];
                    if (names != null)
                        return names;
                }
                return new string[0];
            }
            set {
                owner.ViewState["Font_Names"] = value;
                owner.SetBit(Style.PROP_FONT_NAMES);
            }
        }

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.Overline"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the text is overline.</para>
        /// </devdoc>
        [
            Bindable(true),
            WebCategory("Appearance"),
            DefaultValue(false),
            WebSysDescription(SR.FontInfo_Overline),
            NotifyParentProperty(true)
        ]
        public bool Overline {
            get {
                if (owner.IsSet(Style.PROP_FONT_OVERLINE)) {
                    return (bool)(owner.ViewState["Font_Overline"]);
                }
                return false;
            }
            set {
                owner.ViewState["Font_Overline"] = value;
                owner.SetBit(Style.PROP_FONT_OVERLINE);
            }
        }

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.Owner"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal Style Owner {
            get {
                return owner;
            }
        }

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.Size"]/*' />
        /// <devdoc>
        ///    <para>Indicates the font size.</para>
        /// </devdoc>
        [
            Bindable(true),
            WebCategory("Appearance"),
            DefaultValue(typeof(FontUnit), ""),
            WebSysDescription(SR.FontInfo_Size),
            NotifyParentProperty(true)
        ]
        public FontUnit Size {
            get {
                if (owner.IsSet(Style.PROP_FONT_SIZE)) {
                    return (FontUnit)(owner.ViewState["Font_Size"]);
                }
                return FontUnit.Empty;
            }
            set {
                if ((value.Type == FontSize.AsUnit) && (value.Unit.Value < 0)) {
                    throw new ArgumentOutOfRangeException("value");
                }
                owner.ViewState["Font_Size"] = value;
                owner.SetBit(Style.PROP_FONT_SIZE);
            }
        }

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.Strikeout"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the text is striked out.</para>
        /// </devdoc>
        [
            Bindable(true),
            WebCategory("Appearance"),
            DefaultValue(false),
            WebSysDescription(SR.FontInfo_Strikeout),
            NotifyParentProperty(true)
        ]
        public bool Strikeout {
            get {
                if (owner.IsSet(Style.PROP_FONT_STRIKEOUT)) {
                    return (bool)(owner.ViewState["Font_Strikeout"]);
                }
                return false;
            }
            set {
                owner.ViewState["Font_Strikeout"] = value;
                owner.SetBit(Style.PROP_FONT_STRIKEOUT);
            }
        }

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.Underline"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the text is underlined.</para>
        /// </devdoc>
        [
            Bindable(true),
            WebCategory("Appearance"),
            DefaultValue(false),
            WebSysDescription(SR.FontInfo_Underline),
            NotifyParentProperty(true)
        ]
        public bool Underline {
            get {
                if (owner.IsSet(Style.PROP_FONT_UNDERLINE)) {
                    return (bool)(owner.ViewState["Font_Underline"]);
                }
                return false;
            }
            set {
                owner.ViewState["Font_Underline"] = value;
                owner.SetBit(Style.PROP_FONT_UNDERLINE);
            }
        }


        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.CopyFrom"]/*' />
        /// <devdoc>
        /// <para>Copies the font properties of another <see cref='System.Web.UI.WebControls.FontInfo'/> into this instance. </para>
        /// </devdoc>
        public void CopyFrom(FontInfo f) {
            if (f != null) {

                if (f.Owner.IsSet(Style.PROP_FONT_NAMES))
                    Names = f.Names;
                if (f.Owner.IsSet(Style.PROP_FONT_SIZE) && (f.Size != FontUnit.Empty))
                    Size = f.Size;

                // Only carry through true boolean values. Otherwise merging and copying
                // can do 3 different things for each property, but they are only persisted
                // as 2 state values.
                if (f.Owner.IsSet(Style.PROP_FONT_BOLD) && f.Bold == true)
                    Bold = true;
                if (f.Owner.IsSet(Style.PROP_FONT_ITALIC) && f.Italic == true)
                    Italic = true;
                if (f.Owner.IsSet(Style.PROP_FONT_OVERLINE) && f.Overline == true)
                    Overline = true;
                if (f.Owner.IsSet(Style.PROP_FONT_STRIKEOUT) && f.Strikeout == true)
                    Strikeout = true;
                if (f.Owner.IsSet(Style.PROP_FONT_UNDERLINE) && f.Underline == true)
                    Underline = true;

            }
        }

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.MergeWith"]/*' />
        /// <devdoc>
        /// <para>Combines the font properties of another <see cref='System.Web.UI.WebControls.FontInfo'/> with this 
        ///    instance. </para>
        /// </devdoc>
        public void MergeWith(FontInfo f) {
            if (f != null) {

                if (f.Owner.IsSet(Style.PROP_FONT_NAMES) && !owner.IsSet(Style.PROP_FONT_NAMES))
                    Names = f.Names;
                if (f.Owner.IsSet(Style.PROP_FONT_SIZE) && (!owner.IsSet(Style.PROP_FONT_SIZE) || (Size == FontUnit.Empty)))
                    Size = f.Size;
                if (f.Owner.IsSet(Style.PROP_FONT_BOLD) && !owner.IsSet(Style.PROP_FONT_BOLD))
                    Bold = f.Bold;
                if (f.Owner.IsSet(Style.PROP_FONT_ITALIC) && !owner.IsSet(Style.PROP_FONT_ITALIC))
                    Italic = f.Italic;
                if (f.Owner.IsSet(Style.PROP_FONT_OVERLINE) && !owner.IsSet(Style.PROP_FONT_OVERLINE))
                    Overline = f.Overline;
                if (f.Owner.IsSet(Style.PROP_FONT_STRIKEOUT) && !owner.IsSet(Style.PROP_FONT_STRIKEOUT))
                    Strikeout = f.Strikeout;
                if (f.Owner.IsSet(Style.PROP_FONT_UNDERLINE) && !owner.IsSet(Style.PROP_FONT_UNDERLINE))
                    Underline = f.Underline;

            }
        }

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.Reset"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal void Reset() {
            if (owner.IsSet(Style.PROP_FONT_NAMES))
                owner.ViewState.Remove("Font_Names");
            if (owner.IsSet(Style.PROP_FONT_SIZE))
                owner.ViewState.Remove("Font_Size");
            if (owner.IsSet(Style.PROP_FONT_BOLD))
                owner.ViewState.Remove("Font_Bold");
            if (owner.IsSet(Style.PROP_FONT_ITALIC))
                owner.ViewState.Remove("Font_Italic");
            if (owner.IsSet(Style.PROP_FONT_UNDERLINE))
                owner.ViewState.Remove("Font_Underline");
            if (owner.IsSet(Style.PROP_FONT_OVERLINE))
                owner.ViewState.Remove("Font_Overline");
            if (owner.IsSet(Style.PROP_FONT_STRIKEOUT))
                owner.ViewState.Remove("Font_Strikeout");
        }

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.ShouldSerializeNames"]/*' />
        /// <internalonly/>
        public bool ShouldSerializeNames() {
            string[] names = Names;
            return names.Length > 0;
        }

        /// <include file='doc\FontInfo.uex' path='docs/doc[@for="FontInfo.ToString"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override string ToString() {
            string size = this.Size.ToString();
            string s = this.Name;

            if (size.Length != 0) {
                if (s.Length != 0) {
                    s += ", " + size;
                }
                else {
                    s = size;
                }
            }
            return s;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\gridlines.cs ===
//------------------------------------------------------------------------------
// <copyright file="GridLines.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;

    /// <include file='doc\GridLines.uex' path='docs/doc[@for="GridLines"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the gridline style.
    ///    </para>
    /// </devdoc>
    public enum GridLines {

        /// <include file='doc\GridLines.uex' path='docs/doc[@for="GridLines.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A grid with no grid lines rendered.
        ///    </para>
        /// </devdoc>
        None = 0,

        /// <include file='doc\GridLines.uex' path='docs/doc[@for="GridLines.Horizontal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A grid with only horizontal grid lines rendered.
        ///    </para>
        /// </devdoc>
        Horizontal = 1,

        /// <include file='doc\GridLines.uex' path='docs/doc[@for="GridLines.Vertical"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A grid with only vertical grid lines rendered.
        ///    </para>
        /// </devdoc>
        Vertical = 2,

        /// <include file='doc\GridLines.uex' path='docs/doc[@for="GridLines.Both"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A grid woth both horizontal and vertical grid lines rendered.
        ///    </para>
        /// </devdoc>
        Both = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\fontnamesconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontNamesConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System.ComponentModel.Design;
    using System;
    using System.ComponentModel;
    using System.Collections;    
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\FontNamesConverter.uex' path='docs/doc[@for="FontNamesConverter"]/*' />
    /// <devdoc>
    ///    <para>Converts a string with font names separated by commas to and from 
    ///       an array of strings containing individual names.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class FontNamesConverter : TypeConverter {
        /// <include file='doc\FontNamesConverter.uex' path='docs/doc[@for="FontNamesConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Determines if the specified data type can be converted to an array of strings containing individual font names. </para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return false;
        }

        /// <include file='doc\FontNamesConverter.uex' path='docs/doc[@for="FontNamesConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Parses a string that represents a list of font names separated by 
        ///       commas into an array of strings containing individual font names. </para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                if (((string)value).Length == 0) {
                    return new string[0];
                }
                
                // hard code comma, since it is persisted to HTML
                // 
                string[] names = ((string)value).Split(new char[] {','});
                for (int i=0; i<names.Length; i++) {
                    names[i] = names[i].Trim();
                }
                return names;
            }
            throw GetConvertFromException(value);
        }

        /// <include file='doc\FontNamesConverter.uex' path='docs/doc[@for="FontNamesConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///    <para> Creates a string that represents a list of font names separated 
        ///       by commas from an array of strings containing individual font names.</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string)) {
                
                if (value == null) {
                    return "";
                }
                // hard code comma, since it is persisted to HTML
                // 
                return string.Join(",", ((string[])value));
            }
            throw GetConvertToException(value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\horizontalalign.cs ===
//------------------------------------------------------------------------------
// <copyright file="HorizontalAlign.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {
    
    using System;
    using System.ComponentModel;

    /// <include file='doc\HorizontalAlign.uex' path='docs/doc[@for="HorizontalAlign"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the horizonal alignment.
    ///    </para>
    /// </devdoc>
    [ TypeConverterAttribute(typeof(HorizontalAlignConverter)) ]
    public enum HorizontalAlign {

        /// <include file='doc\HorizontalAlign.uex' path='docs/doc[@for="HorizontalAlign.NotSet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that horizonal alignment is not set.
        ///    </para>
        /// </devdoc>
        NotSet = 0,
        
        /// <include file='doc\HorizontalAlign.uex' path='docs/doc[@for="HorizontalAlign.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that horizonal alignment is left justified.
        ///    </para>
        /// </devdoc>
        Left = 1,

        /// <include file='doc\HorizontalAlign.uex' path='docs/doc[@for="HorizontalAlign.Center"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that horizonal alignment is centered.
        ///    </para>
        /// </devdoc>
        Center = 2,

        /// <include file='doc\HorizontalAlign.uex' path='docs/doc[@for="HorizontalAlign.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that horizonal alignment is right justified.
        ///    </para>
        /// </devdoc>
        Right = 3,

        /// <include file='doc\HorizontalAlign.uex' path='docs/doc[@for="HorizontalAlign.Justify"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that horizonal alignment is justified.
        ///    </para>
        /// </devdoc>
        Justify = 4
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\fontunitconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontUnitConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;
    using System.Security.Permissions;

    /// <include file='doc\FontUnitConverter.uex' path='docs/doc[@for="FontUnitConverter"]/*' />
    /// <devdoc>
    /// <para>Converts a <see cref='System.Web.UI.WebControls.FontUnit'/> to and from a specified data type.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class FontUnitConverter : TypeConverter {
        private StandardValuesCollection values;

        /// <include file='doc\FontUnitConverter.uex' path='docs/doc[@for="FontUnitConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        /// <para>Determines if the specified data type can be converted to a <see cref='System.Web.UI.WebControls.FontUnit'/>.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            else {
                return base.CanConvertFrom(context, sourceType);
            }
        }

        /// <include file='doc\FontUnitConverter.uex' path='docs/doc[@for="FontUnitConverter.ConvertFrom"]/*' />
        /// <devdoc>
        /// <para>Converts the specified <see cref='System.Object' qualify='true'/> into a <see cref='System.Web.UI.WebControls.FontUnit'/>.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value == null)
                return null;

            if (value is string) {
                string textValue = ((string)value).Trim();
                if (textValue.Length == 0)
                    return FontUnit.Empty;
                return FontUnit.Parse(textValue, culture);
            }
            else {
                return base.ConvertFrom(context, culture, value);
            }
        }

        /// <include file='doc\FontUnitConverter.uex' path='docs/doc[@for="FontUnitConverter.ConvertTo"]/*' />
        /// <devdoc>
        /// <para>Converts the specified <see cref='System.Web.UI.WebControls.FontUnit'/> into the specified <see cref='System.Type' qualify='true'/>. </para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string)) {
                if ((value == null) || (((FontUnit)value).Type == FontSize.NotSet))
                    return String.Empty;
                else
                    return ((FontUnit)value).ToString(culture);
            }
            else {
                return base.ConvertTo(context, culture, value, destinationType);
            }
#if FIX_BUG_73027
            // NOTE: This piece of code is required for serialization of a FontUnit into code.
            //       To enable it you must also override ConvertTo and return true for
            //       converstion to InstanceDescriptor.
            else if ((destinationType == typeof(InstanceDescriptor)) && (value != null)) {
                FontUnit u = (FontUnit)value;
                MemberInfo member = null;
                object[] args = null;

                if (u.IsEmpty) {
                    member = typeof(Unit).GetField("Empty");
                }
                else if (u.Type != FontSize.AsUnit) {
                    string fieldName = null;
                    switch (u.Type) {
                        case FontSize.Smaller:
                            fieldName = "Smaller";
                            break;
                        case FontSize.Larger:
                            fieldName = "Larger";
                            break;
                        case FontSize.XXSmall:
                            fieldName = "XXSmall";
                            break;
                        case FontSize.XSmall:
                            fieldName = "XSmall";
                            break;
                        case FontSize.Small:
                            fieldName = "Small";
                            break;
                        case FontSize.Medium:
                            fieldName = "Medium";
                            break;
                        case FontSize.Large:
                            fieldName = "Large";
                            break;
                        case FontSize.XLarge:
                            fieldName = "XLarge";
                            break;
                        case FontSize.XXLarge:
                            fieldName = "XXLarge";
                            break;
                    }
                    Debug.Assert(fieldName != null, "Invalid FontSize type");
                    if (fieldName != null) {
                        member = typeof(FontUnit).GetField(fieldName);
                    }
                }
                else {
                    member = typeof(FontUnit).GetConstructor(new Type[] { typeof(Unit) });
                    args = new object[] { u.Unit };
                }

                Debug.Assert(member != null, "Looks like we're missing FontUnit static fields or FontUnit::ctor(Unit)");
                if (member != null) {
                    return new InstanceDescriptor(member, args);
                }
                else {
                    return null;
                }
            }
#endif // FIX_BUG_73027
        }

        /// <include file='doc\FontUnitConverter.uex' path='docs/doc[@for="FontUnitConverter.GetStandardValues"]/*' />
        /// <devdoc>
        /// <para>Returns a <see cref='System.ComponentModel.TypeConverter.StandardValuesCollection' qualify='true'/> 
        /// containing standard <see cref='System.Web.UI.WebControls.FontUnit'/> values.</para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (values == null) {
                object[] namedUnits = new object[] {
                    FontUnit.Smaller,
                    FontUnit.Larger,
                    FontUnit.XXSmall,
                    FontUnit.XSmall,
                    FontUnit.Small,
                    FontUnit.Medium,
                    FontUnit.Large,
                    FontUnit.XLarge,
                    FontUnit.XXLarge
                };

                values = new StandardValuesCollection(namedUnits);
            }
            return values;
        }

        /// <include file='doc\FontUnitConverter.uex' path='docs/doc[@for="FontUnitConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the specified context contains exclusive standard 
        ///       values.</para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }

        /// <include file='doc\FontUnitConverter.uex' path='docs/doc[@for="FontUnitConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the specified context contains suppurted standard 
        ///       values.</para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\hyperlinkcolumn.cs ===
//------------------------------------------------------------------------------
// <copyright file="HyperLinkColumn.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;    
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn"]/*' />
    /// <devdoc>
    /// <para>Creates a column within the <see cref='System.Web.UI.WebControls.DataGrid'/> containing hyperlinks that
    ///    navigate to specified URLs.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HyperLinkColumn : DataGridColumn {

        private PropertyDescriptor textFieldDesc;
        private PropertyDescriptor urlFieldDesc;

        /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn.HyperLinkColumn"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.HyperLinkColumn'/> class.</para>
        /// </devdoc>
        public HyperLinkColumn() {
        }


        /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn.DataNavigateUrlField"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the field in the DataSource that provides the URL of the page to navigate to.</para>
        /// </devdoc>
        [
        WebCategory("Data"),
        DefaultValue(""),
        WebSysDescription(SR.HyperLinkColumn_DataNavigateUrlField)
        ]
        public virtual string DataNavigateUrlField {
            get {
                object o = ViewState["DataNavigateUrlField"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["DataNavigateUrlField"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn.DataNavigateUrlFormatString"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the formatting applied to the <see cref='System.Web.UI.WebControls.HyperLinkColumn.NavigateUrl'/>
        /// property.</para>
        /// </devdoc>
        [
        WebCategory("Data"),
        DefaultValue(""),
        DescriptionAttribute("The formatting applied to the value bound to the NavigateUrl property.")
        ]
        public virtual string DataNavigateUrlFormatString {
            get {
                object o = ViewState["DataNavigateUrlFormatString"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["DataNavigateUrlFormatString"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn.DataTextField"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the field in the DataSource that will be used as the source of 
        ///    data for the <see cref='System.Web.UI.WebControls.HyperLinkColumn.Text'/> property.</para>
        /// </devdoc>
        [
        WebCategory("Data"),
        DefaultValue(""),
        WebSysDescription(SR.HyperLinkColumn_DataTextField)
        ]
        public virtual string DataTextField {
            get {
                object o = ViewState["DataTextField"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["DataTextField"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn.DataTextFormatString"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the formatting applied to the <see cref='System.Web.UI.WebControls.HyperLinkColumn.Text'/> 
        /// property.</para>
        /// </devdoc>
        [
        WebCategory("Data"),
        DefaultValue(""),
        DescriptionAttribute("The formatting applied to the value bound to the Text property.")
        ]
        public virtual string DataTextFormatString {
            get {
                object o = ViewState["DataTextFormatString"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["DataTextFormatString"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn.NavigateUrl"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the URL to navigate to when the hyperlink is clicked.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.HyperLinkColumn_NavigateUrl)
        ]
        public virtual string NavigateUrl {
            get {
                object o = ViewState["NavigateUrl"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["NavigateUrl"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn.Target"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the window or target frame that is 
        ///       used to display the contents resulting from the hyperlink.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.HyperLinkColumn_Target)
        ]
        public virtual string Target {
            get {
                object o = ViewState["Target"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["Target"] = value;
                OnColumnChanged();
            }
        }

        /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn.Text"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the text to display for the hyperlink.</para>
        /// </devdoc>
        [
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.HyperLinkColumn_Text)
        ]
        public virtual string Text {
            get {
                object o = ViewState["Text"];
                if (o != null)
                    return(string)o;
                return String.Empty;
            }
            set {
                ViewState["Text"] = value;
                OnColumnChanged();
            }
        }


        /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn.FormatDataNavigateUrlValue"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected virtual string FormatDataNavigateUrlValue(object dataUrlValue) {
            string formattedUrlValue = String.Empty;

            if ((dataUrlValue != null) && (dataUrlValue != System.DBNull.Value)) {
                string formatting = DataNavigateUrlFormatString;
                if (formatting.Length == 0) {
                    formattedUrlValue = dataUrlValue.ToString();
                }
                else {
                    formattedUrlValue = String.Format(formatting, dataUrlValue);
                }
            }

            return formattedUrlValue;
        }

        /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn.FormatDataTextValue"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected virtual string FormatDataTextValue(object dataTextValue) {
            string formattedTextValue = String.Empty;

            if ((dataTextValue != null) && (dataTextValue != System.DBNull.Value)) {
                string formatting = DataTextFormatString;
                if (formatting.Length == 0) {
                    formattedTextValue = dataTextValue.ToString();
                }
                else {
                    formattedTextValue = String.Format(formatting, dataTextValue);
                }
            }

            return formattedTextValue;
        }

        /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn.Initialize"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override void Initialize() {
            base.Initialize();
            textFieldDesc = null;
            urlFieldDesc = null;
        }
        
        /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn.InitializeCell"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Initializes the cell representing this column with the
        ///       contained hyperlink.</para>
        /// </devdoc>
        public override void InitializeCell(TableCell cell, int columnIndex, ListItemType itemType) {
            base.InitializeCell(cell, columnIndex, itemType);

            if ((itemType != ListItemType.Header) &&
                (itemType != ListItemType.Footer)) {
                HyperLink hyperLink = new HyperLink();

                hyperLink.Text = Text;
                hyperLink.NavigateUrl = NavigateUrl;
                hyperLink.Target = Target;

                if ((DataNavigateUrlField.Length != 0) ||
                    (DataTextField.Length != 0)) {
                    hyperLink.DataBinding += new EventHandler(this.OnDataBindColumn);
                }

                cell.Controls.Add(hyperLink);
            }
        }

        /// <include file='doc\HyperLinkColumn.uex' path='docs/doc[@for="HyperLinkColumn.OnDataBindColumn"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnDataBindColumn(object sender, EventArgs e) {
            Debug.Assert((DataTextField.Length != 0) || (DataNavigateUrlField.Length != 0),
                         "Shouldn't be DataBinding without a DataTextField and DataNavigateUrlField");

            HyperLink boundControl = (HyperLink)sender;
            DataGridItem item = (DataGridItem)boundControl.NamingContainer;
            object dataItem = item.DataItem;

            if ((textFieldDesc == null) && (urlFieldDesc == null)) {
                PropertyDescriptorCollection props = TypeDescriptor.GetProperties(dataItem);
                string fieldName;

                fieldName = DataTextField;
                if (fieldName.Length != 0) {
                    textFieldDesc = props.Find(fieldName, true);
                    if ((textFieldDesc == null) && !DesignMode) {
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Field_Not_Found, fieldName));
                    }
                }

                fieldName = DataNavigateUrlField;
                if (fieldName.Length != 0) {
                    urlFieldDesc = props.Find(fieldName, true);
                    if ((urlFieldDesc == null) && !DesignMode) {
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Field_Not_Found, fieldName));
                    }
                }
            }

            if (textFieldDesc != null) {
                object data = textFieldDesc.GetValue(dataItem);
                string dataValue = FormatDataTextValue(data);

                boundControl.Text = dataValue;
            }
            else if (DesignMode && (DataTextField.Length != 0)) {
                boundControl.Text = SR.GetString(SR.Sample_Databound_Text);
            }

            if (urlFieldDesc != null) {
                object data = urlFieldDesc.GetValue(dataItem);
                string dataValue = FormatDataNavigateUrlValue(data);

                boundControl.NavigateUrl = dataValue;
            }
            else if (DesignMode && (DataNavigateUrlField.Length != 0)) {
                boundControl.NavigateUrl = "url";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\irepeatinfouser.cs ===
//------------------------------------------------------------------------------
// <copyright file="IRepeatInfoUser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;
    using System.Web.UI;

    /// <include file='doc\IRepeatInfoUser.uex' path='docs/doc[@for="IRepeatInfoUser"]/*' />
    /// <devdoc>
    /// <para>Specifies a contract for implementing <see cref='System.Web.UI.WebControls.Repeater'/> objects in list controls.</para>
    /// </devdoc>
    public interface IRepeatInfoUser {

        /// <include file='doc\IRepeatInfoUser.uex' path='docs/doc[@for="IRepeatInfoUser.HasHeader"]/*' />
        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Web.UI.WebControls.Repeater'/> contains a
        ///    header item.</para>
        /// </devdoc>
        bool HasHeader {
            get;
        }

        /// <include file='doc\IRepeatInfoUser.uex' path='docs/doc[@for="IRepeatInfoUser.HasFooter"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the Repeater contains
        ///       a footer item.</para>
        /// </devdoc>
        bool HasFooter {
            get;
        }
        
        /// <include file='doc\IRepeatInfoUser.uex' path='docs/doc[@for="IRepeatInfoUser.HasSeparators"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the Repeater contains
        ///       separator items.</para>
        /// </devdoc>
        bool HasSeparators {
            get;
        }

        /// <include file='doc\IRepeatInfoUser.uex' path='docs/doc[@for="IRepeatInfoUser.RepeatedItemCount"]/*' />
        /// <devdoc>
        ///    Specifies the item count of the Repeater.
        /// </devdoc>
        int RepeatedItemCount {
            get;
        }

        /// <include file='doc\IRepeatInfoUser.uex' path='docs/doc[@for="IRepeatInfoUser.GetItemStyle"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the item style with the specified item type 
        ///       and location within the <see cref='System.Web.UI.WebControls.Repeater'/> .</para>
        /// </devdoc>
        Style GetItemStyle(ListItemType itemType, int repeatIndex);

        /// <include file='doc\IRepeatInfoUser.uex' path='docs/doc[@for="IRepeatInfoUser.RenderItem"]/*' />
        /// <devdoc>
        /// <para>Renders the <see cref='System.Web.UI.WebControls.Repeater'/> item with the specified information.</para>
        /// </devdoc>
        void RenderItem(ListItemType itemType, int repeatIndex, RepeatInfo repeatInfo, HtmlTextWriter writer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\horizontalalignconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HorizontalAlignConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;

    internal class HorizontalAlignConverter : EnumConverter {

        static string[] stringValues = new String[(int) HorizontalAlign.Justify + 1];

        static HorizontalAlignConverter () { 
            stringValues[(int) HorizontalAlign.NotSet] = "NotSet";
            stringValues[(int) HorizontalAlign.Left] = "Left";
            stringValues[(int) HorizontalAlign.Center] = "Center";
            stringValues[(int) HorizontalAlign.Right] = "Right";
            stringValues[(int) HorizontalAlign.Justify] = "Justify";
        }

        // this constructor needs to be public despite the fact that it's in an internal
        // class so it can be created by Activator.CreateInstance.
        public HorizontalAlignConverter () : base(typeof(HorizontalAlign)) {}
        
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            else {
                return base.CanConvertFrom(context, sourceType);
            }
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value == null)
                return null;

            if (value is string) {
                string textValue = ((string)value).Trim();
                if (textValue.Length == 0)
                    return HorizontalAlign.NotSet;

                switch (textValue) {
                    case "NotSet":
                        return HorizontalAlign.NotSet;
                    case "Left":
                        return HorizontalAlign.Left;
                    case "Center":
                        return HorizontalAlign.Center;
                    case "Right":
                        return HorizontalAlign.Right;
                    case "Justify":
                        return HorizontalAlign.Justify;
                }
            }
            return base.ConvertFrom(context, culture, value);
        }
        
        public override bool CanConvertTo(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }

            return base.CanConvertTo(context, sourceType);
        }
        
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string) && ((int) value <= (int)HorizontalAlign.Justify)) {
                return stringValues[(int) value];
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\hyperlink.cs ===
//------------------------------------------------------------------------------
// <copyright file="HyperLink.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.ComponentModel;
    using System.Web;
    using System.Web.UI;
    using System.Drawing.Design;
    using System.Text;
    using System.Security.Permissions;

    /// <include file='doc\HyperLink.uex' path='docs/doc[@for="HyperLinkControlBuilder"]/*' />
    /// <devdoc>
    /// <para>Interacts with the parser to build a <see cref='System.Web.UI.WebControls.HyperLink'/>.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HyperLinkControlBuilder : ControlBuilder {

        /// <include file='doc\HyperLink.uex' path='docs/doc[@for="HyperLinkControlBuilder.AllowWhitespaceLiterals"]/*' />
        /// <devdoc>
        ///    <para>Gets a value to indicate whether or not white spaces are allowed in literals for this control. This
        ///       property is read-only.</para>
        /// </devdoc>
        public override bool AllowWhitespaceLiterals() {
            return false;
        }
    }


    /// <include file='doc\HyperLink.uex' path='docs/doc[@for="HyperLink"]/*' />
    /// <devdoc>
    ///    <para>Creates a link for the browser to navigate to another page.</para>
    /// </devdoc>
    [
    ControlBuilderAttribute(typeof(HyperLinkControlBuilder)),
    DataBindingHandler("System.Web.UI.Design.HyperLinkDataBindingHandler, " + AssemblyRef.SystemDesign),
    DefaultProperty("Text"),
    Designer("System.Web.UI.Design.WebControls.HyperLinkDesigner, " + AssemblyRef.SystemDesign),
    ToolboxData("<{0}:HyperLink runat=server>HyperLink</{0}:HyperLink>"),
    ParseChildren(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HyperLink : WebControl {

        /// <include file='doc\HyperLink.uex' path='docs/doc[@for="HyperLink.HyperLink"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.HyperLink'/> class.</para>
        /// </devdoc>
        public HyperLink() : base(HtmlTextWriterTag.A) {
        }

        /// <include file='doc\HyperLink.uex' path='docs/doc[@for="HyperLink.ImageUrl"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the URL reference to an image to display as an alternative to plain text for the
        ///       hyperlink.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        Editor("System.Web.UI.Design.ImageUrlEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        WebSysDescription(SR.HyperLink_ImageUrl)
        ]
        public virtual string ImageUrl {
            get {
                string s = (string)ViewState["ImageUrl"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["ImageUrl"] = value;
            }
        }


        /// <include file='doc\HyperLink.uex' path='docs/doc[@for="HyperLink.NavigateUrl"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the URL reference to navigate to when the hyperlink is clicked.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Navigation"),
        DefaultValue(""),
        Editor("System.Web.UI.Design.UrlEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        WebSysDescription(SR.HyperLink_NavigateUrl)
        ]
        public string NavigateUrl {
            get {
                string s = (string)ViewState["NavigateUrl"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["NavigateUrl"] = value;
            }
        }

        /// <include file='doc\HyperLink.uex' path='docs/doc[@for="HyperLink.Target"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the target window or frame the contents of 
        ///       the <see cref='System.Web.UI.WebControls.HyperLink'/> will be displayed into when clicked.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Navigation"),
        DefaultValue(""),
        WebSysDescription(SR.HyperLink_Target),
        TypeConverter(typeof(TargetConverter))
        ]
        public string Target {
            get {
                string s = (string)ViewState["Target"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["Target"] = value;
            }
        }

        /// <include file='doc\HyperLink.uex' path='docs/doc[@for="HyperLink.Text"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Gets or sets the text displayed for the <see cref='System.Web.UI.WebControls.HyperLink'/>.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.HyperLink_Text),
        PersistenceMode(PersistenceMode.InnerDefaultProperty)
        ]
        public virtual string Text {
            get {
                object o = ViewState["Text"];
                return((o == null) ? String.Empty : (string)o);
            }
            set {
                if (HasControls()) {
                    Controls.Clear();
                }
                ViewState["Text"] = value;
            }
        }

        /// <include file='doc\HyperLink.uex' path='docs/doc[@for="HyperLink.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Adds the attribututes of the a <see cref='System.Web.UI.WebControls.HyperLink'/> to the output
        ///    stream for rendering.</para>
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {
            base.AddAttributesToRender(writer);

            string s = NavigateUrl;
            if ((s.Length > 0) && Enabled) {
                writer.AddAttribute(HtmlTextWriterAttribute.Href, ResolveClientUrl(s));
            }
            s = Target;
            if (s.Length > 0) {
                writer.AddAttribute(HtmlTextWriterAttribute.Target, s);
            }
        }

        /// <include file='doc\HyperLink.uex' path='docs/doc[@for="HyperLink.AddParsedSubObject"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override void AddParsedSubObject(object obj) {
            if (HasControls()) {
                base.AddParsedSubObject(obj);
            }
            else {
                if (obj is LiteralControl) {
                    Text = ((LiteralControl)obj).Text;
                }
                else {
                    string currentText = Text;
                    if (currentText.Length != 0) {
                        Text = String.Empty;
                        base.AddParsedSubObject(new LiteralControl(currentText));
                    }
                    base.AddParsedSubObject(obj);
                }
            }
        }

        /// <include file='doc\HyperLink.uex' path='docs/doc[@for="HyperLink.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Load previously saved state.
        ///    Overridden to synchronize Text property with LiteralContent.
        /// </devdoc>
        protected override void LoadViewState(object savedState) {
            if (savedState != null) {
                base.LoadViewState(savedState);
                string s = (string)ViewState["Text"];
                if (s != null)
                    Text = s;
            }
        }

        /// <include file='doc\HyperLink.uex' path='docs/doc[@for="HyperLink.RenderContents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Displays the <see cref='System.Web.UI.WebControls.HyperLink'/> on a page.</para>
        /// </devdoc>
        protected override void RenderContents(HtmlTextWriter writer) {
            string s = ImageUrl;
            if (s.Length > 0) {
                Image img = new Image();

                // NOTE: The Url resolution happens right here, because the image is not parented
                //       and will not be able to resolve when it tries to do so.
                img.ImageUrl = ResolveClientUrl(s);

                s = ToolTip;
                if (s.Length != 0) {
                    img.ToolTip = s;
                }

                s = Text;
                if (s.Length != 0) {
                    img.AlternateText = s;
                }
                img.RenderControl(writer);
            }
            else {
                if (HasControls()) {
                    base.RenderContents(writer);
                }
                else {
                    writer.Write(Text);
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\imagebutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Web;
    using System.Web.UI;
    using System.Security.Permissions;

    /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton"]/*' />
    /// <devdoc>
    ///    <para>Creates a control that displays an image, responds to mouse clicks,
    ///       and records the mouse pointer position.</para>
    /// </devdoc>
    [
    DefaultEvent("Click")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ImageButton : Image, IPostBackDataHandler, IPostBackEventHandler {

        private static readonly object EventClick = new object();
        private static readonly object EventCommand = new object();

        private int x;
        private int y;

        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.ImageButton"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.ImageButton'/> class.</para>
        /// </devdoc>
        public ImageButton() {
        }

        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.CommandName"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the command associated with the <see cref='System.Web.UI.WebControls.ImageButton'/> that is propogated in the <see langword='Command'/> event along with the <see cref='System.Web.UI.WebControls.ImageButton.CommandArgument'/>
        /// property.</para>
        /// </devdoc>
        [
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.ImageButton_Command)
        ]
        public string CommandName {
            get {
                string s = (string)ViewState["CommandName"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["CommandName"] = value;
            }
        }

        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.CommandArgument"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets an optional argument that is propogated in
        ///       the <see langword='Command'/> event with the associated
        ///    <see cref='System.Web.UI.WebControls.ImageButton.CommandName'/>
        ///    property.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Behavior"),
        DefaultValue(""),
        WebSysDescription(SR.ImageButton_CommandArgument)
        ]
        public string CommandArgument {
            get {
                string s = (string)ViewState["CommandArgument"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["CommandArgument"] = value;
            }
        }

        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.CausesValidation"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets whether pressing the button causes page validation to fire. This defaults to True so that when
        ///          using validation controls, the validation state of all controls are updated when the button is clicked, both
        ///          on the client and the server. Setting this to False is useful when defining a cancel or reset button on a page
        ///          that has validators.</para>
        /// </devdoc>
        [
        Bindable(false),
        WebCategory("Behavior"),
        DefaultValue(true),
        WebSysDescription(SR.ImageButton_CausesValidation)
        ]
        public bool CausesValidation {
            get {
                object b = ViewState["CausesValidation"];
                return((b == null) ? true : (bool)b);
            }
            set {
                ViewState["CausesValidation"] = value;
            }
        }

        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.TagKey"]/*' />
        /// <devdoc>
        ///    <para> Gets a value that represents the tag HtmlTextWriterTag.Input. This property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        protected override HtmlTextWriterTag TagKey {
            get {
                return HtmlTextWriterTag.Input;
            }
        }

        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.Click"]/*' />
        /// <devdoc>
        /// <para>Represents the method that will handle the <see langword='ImageClick'/> event of an <see cref='System.Web.UI.WebControls.ImageButton'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.ImageButton_OnClick)
        ]
        public event ImageClickEventHandler Click {
            add {
                Events.AddHandler(EventClick, value);
            }
            remove {
                Events.RemoveHandler(EventClick, value);
            }
        }


        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.Command"]/*' />
        /// <devdoc>
        /// <para>Represents the method that will handle the <see langword='Command'/> event of an <see cref='System.Web.UI.WebControls.ImageButton'/>.</para>
        /// </devdoc>
        [
        WebCategory("Action"),
        WebSysDescription(SR.ImageButton_OnCommand)
        ]
        public event CommandEventHandler Command {
            add {
                Events.AddHandler(EventCommand, value);
            }
            remove {
                Events.RemoveHandler(EventCommand, value);
            }
        }

        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Adds the attributes of an <see cref='System.Web.UI.WebControls.ImageButton'/> to the output
        ///    stream for rendering on the client.</para>
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {

            Page page = Page;

            // Make sure we are in a form tag with runat=server.
            if (page != null) {
                page.VerifyRenderingInServerForm(this);
            }

            writer.AddAttribute(HtmlTextWriterAttribute.Type,"image");
            writer.AddAttribute(HtmlTextWriterAttribute.Name,UniqueID);

            if (page != null && CausesValidation && page.Validators.Count > 0) {
                // ASURT 98368
                // Need to merge the autopostback script with the user script
                string onClick = Util.GetClientValidateEvent(Page);
                if (HasAttributes) {
                    string userOnClick = Attributes["onclick"];
                    if (userOnClick != null) {
                        onClick = userOnClick + onClick;
                        Attributes.Remove("onclick");
                    }
                }
                writer.AddAttribute(HtmlTextWriterAttribute.Onclick, onClick);
                writer.AddAttribute("language", "javascript");
            }

            base.AddAttributesToRender(writer);
        }

        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.IPostBackDataHandler.LoadPostData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Processes posted data for the <see cref='System.Web.UI.WebControls.ImageButton'/> control.</para>
        /// </devdoc>
        bool IPostBackDataHandler.LoadPostData(string postDataKey, NameValueCollection postCollection) {
            string name = UniqueID;
            string postX = postCollection[name + ".x"];
            string postY = postCollection[name + ".y"];
            if (postX != null && postY != null && postX.Length > 0 && postY.Length > 0) {
                x = Int32.Parse(postX);
                y = Int32.Parse(postY);
                Page.RegisterRequiresRaiseEvent(this);
            }
            return false;
        }

        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.OnClick"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='Click'/> event.</para>
        /// </devdoc>
        protected virtual void OnClick(ImageClickEventArgs e) {
            ImageClickEventHandler onClickHandler = (ImageClickEventHandler)Events[EventClick];
            if (onClickHandler != null) onClickHandler(this,e);
        }

        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.OnCommand"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='Command'/> event.</para>
        /// </devdoc>
        protected virtual void OnCommand(CommandEventArgs e) {
            CommandEventHandler onCommandHandler = (CommandEventHandler)Events[EventCommand];
            if (onCommandHandler != null)
                onCommandHandler(this,e);

            // Command events are bubbled up the control heirarchy
            RaiseBubbleEvent(this, e);
        }

        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.OnPreRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Determine
        ///       if the image has been clicked prior to rendering on the client. </para>
        /// </devdoc>
        protected override void OnPreRender(EventArgs e) {
            if (Page != null) {
                Page.RegisterRequiresPostBack(this);
            }
        }

        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.IPostBackEventHandler.RaisePostBackEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Raises events on post back for the <see cref='System.Web.UI.WebControls.ImageButton'/>
        /// control.</para>
        /// </devdoc>
        void IPostBackEventHandler.RaisePostBackEvent(string eventArgument) {
            if (CausesValidation) {
                Page.Validate();
            }
            OnClick(new ImageClickEventArgs(x,y));
            OnCommand(new CommandEventArgs(CommandName, CommandArgument));
        }

        /// <include file='doc\ImageButton.uex' path='docs/doc[@for="ImageButton.IPostBackDataHandler.RaisePostDataChangedEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Raised when posted data for a control has changed.
        /// </devdoc>
        void IPostBackDataHandler.RaisePostDataChangedEvent() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\image.cs ===
//------------------------------------------------------------------------------
// <copyright file="Image.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Text;
    using System.Web;
    using System.Web.UI;
    using System.Drawing.Design;
    using System.Security.Permissions;

    /// <include file='doc\Image.uex' path='docs/doc[@for="Image"]/*' />
    /// <devdoc>
    ///    <para>Displays an image on a page.</para>
    /// </devdoc>
    [
    DefaultProperty("ImageUrl")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Image : WebControl {

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Image"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.WebControls.Image'/> class.</para>
        /// </devdoc>
        public Image() : base(HtmlTextWriterTag.Img) {
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.AlternateText"]/*' />
        /// <devdoc>
        ///    <para>Specifies alternate text displayed when the image fails to load.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        WebSysDescription(SR.Image_AlternateText)
        ]
        public virtual string AlternateText {
            get {
                string s = (string)ViewState["AlternateText"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["AlternateText"] = value;
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Font"]/*' />
        /// <devdoc>
        ///    <para>Gets the font properties for the alternate text. This property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false),
        EditorBrowsableAttribute(EditorBrowsableState.Never),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public override FontInfo Font {
            // Font is meaningless for image, so hide it from the developer by
            // making it non-browsable.
            get {                
                return base.Font;
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Enabled"]/*' />
        [
        Browsable(false),
        EditorBrowsableAttribute(EditorBrowsableState.Never)
        ]
        public override bool Enabled {
            get {
                return base.Enabled;
            }
            set {
                base.Enabled = value;
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.ImageAlign"]/*' />
        /// <devdoc>
        ///    <para>Gets or
        ///       sets the alignment of the image within the text flow.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Layout"),
        DefaultValue(ImageAlign.NotSet),
        WebSysDescription(SR.Image_ImageAlign)
        ]
        public virtual ImageAlign ImageAlign {
            get {
                object o = ViewState["ImageAlign"];
                return((o == null) ? ImageAlign.NotSet : (ImageAlign)o);
            }
            set {
                if (value < ImageAlign.NotSet || value > ImageAlign.TextTop) {
                    throw new ArgumentOutOfRangeException("value");
                }
                ViewState["ImageAlign"] = value;
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.ImageUrl"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       the URL reference to the image to display.</para>
        /// </devdoc>
        [
        Bindable(true),
        WebCategory("Appearance"),
        DefaultValue(""),
        Editor("System.Web.UI.Design.ImageUrlEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        WebSysDescription(SR.Image_ImageUrl)
        ]
        public virtual string ImageUrl {
            get {
                string s = (string)ViewState["ImageUrl"];
                return((s == null) ? String.Empty : s);
            }
            set {
                ViewState["ImageUrl"] = value;
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.AddAttributesToRender"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Adds the attributes of an <see cref='System.Web.UI.WebControls.Image'/> to the output stream for rendering on
        ///    the client.</para>
        /// </devdoc>
        protected override void AddAttributesToRender(HtmlTextWriter writer) {
            base.AddAttributesToRender(writer);

            string s = ImageUrl;
            if (s.Length > 0)
                writer.AddAttribute(HtmlTextWriterAttribute.Src, ResolveClientUrl(s));
            s = AlternateText;
            if (s.Length > 0)
                writer.AddAttribute(HtmlTextWriterAttribute.Alt,s);

            ImageAlign align = ImageAlign;
            if (align != ImageAlign.NotSet)
                writer.AddAttribute(HtmlTextWriterAttribute.Align,Enum.Format(typeof(ImageAlign),align, "G"));

            if (BorderWidth.IsEmpty)
                writer.AddAttribute(HtmlTextWriterAttribute.Border,"0");
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.RenderContents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void RenderContents(HtmlTextWriter writer) {
            // Do not render the children of a button since it does not
            // make sense to have children of an <input> tag.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ui\webcontrols\imagealign.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageAlign.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.WebControls {
    
    using System;

    /// <include file='doc\ImageAlign.uex' path='docs/doc[@for="ImageAlign"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the alignment of
    ///       images within the text flow on the page.
    ///    </para>
    /// </devdoc>
    public enum ImageAlign {

        /// <include file='doc\ImageAlign.uex' path='docs/doc[@for="ImageAlign.NotSet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The alignment is not set.
        ///    </para>
        /// </devdoc>
        NotSet = 0,
        
        /// <include file='doc\ImageAlign.uex' path='docs/doc[@for="ImageAlign.Left"]/*' />
        /// <devdoc>
        ///    <para>The image is aligned to the left with
        ///       text wrapping on the right.</para>
        /// </devdoc>
        Left = 1,

        /// <include file='doc\ImageAlign.uex' path='docs/doc[@for="ImageAlign.Right"]/*' />
        /// <devdoc>
        ///    <para>The image is aligned to the right with
        ///       text wrapping on the left.</para>
        /// </devdoc>
        Right = 2,

        /// <include file='doc\ImageAlign.uex' path='docs/doc[@for="ImageAlign.Baseline"]/*' />
        /// <devdoc>
        ///    <para>The bottom of the image is aligned with the bottom of the first line of wrapping
        ///       text.</para>
        /// </devdoc>
        Baseline = 3,

        /// <include file='doc\ImageAlign.uex' path='docs/doc[@for="ImageAlign.Top"]/*' />
        /// <devdoc>
        ///    <para>The image is aligned with the top of the the highest element on the same line.</para>
        /// </devdoc>