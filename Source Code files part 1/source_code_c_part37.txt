							  LPDWORD lpType,
							  CAPITempBufferRef<TCHAR>& rgchBuf,
							  LPDWORD lpcbBuf)
{
	DWORD cbBuf = rgchBuf.GetSize() * sizeof(TCHAR);
	LONG lResult = RegQueryValueEx(hKey, lpValueName, 0,
		lpType, (LPBYTE)&rgchBuf[0], &cbBuf);

	if (ERROR_MORE_DATA == lResult)
	{
		rgchBuf.SetSize(cbBuf/sizeof(TCHAR));
		lResult = RegQueryValueEx(hKey, lpValueName, 0,
			lpType, (LPBYTE)&rgchBuf[0], &cbBuf);
	}

	if (lpcbBuf)
		*lpcbBuf = cbBuf;

	return lResult;
}


UINT MyMsiGetProperty(PFnMsiGetProperty pfn,
							 MSIHANDLE hProduct,
							 const TCHAR* szProperty,
							 CAPITempBufferRef<TCHAR>& rgchBuffer)
{
	DWORD cchBuf = rgchBuffer.GetSize();
	
	UINT uiRes = (pfn)(hProduct, szProperty, rgchBuffer, &cchBuf);

	if(uiRes == ERROR_MORE_DATA)
	{
		rgchBuffer.Resize(cchBuf);
		uiRes = (pfn)(hProduct, szProperty, rgchBuffer, &cchBuf);
	}

	return uiRes;
}


UINT MyMsiGetProductInfo(PFnMsiGetProductInfo pfn,
								 const TCHAR* szProductCode,
								 const TCHAR* szProperty,
								 CAPITempBufferRef<TCHAR>& rgchBuffer)
{
	DWORD cchBuf = rgchBuffer.GetSize();
	
	UINT uiRes = (pfn)(szProductCode, szProperty, rgchBuffer, &cchBuf);

	if(uiRes == ERROR_MORE_DATA)
	{
		rgchBuffer.Resize(cchBuf);
		uiRes = (pfn)(szProductCode, szProperty, rgchBuffer, &cchBuf);
	}

	return uiRes;
}

bool IsURL(const TCHAR* szPath)
{
	bool bResult = false;		// assume it's not a URL

	// if it starts with http:
	if (0 == _tcsnicmp(szPath, TEXT("http:"), 5))
		bResult = true;
	else if (0 == _tcsnicmp(szPath, TEXT("ftp:"), 4))
		bResult = true;
	else if (0 == _tcsnicmp(szPath, TEXT("file:"), 5))
		bResult = true;
	return bResult;
}

TCHAR ExtractDriveLetter(const TCHAR *szPath)
/*-------------------------------------------------------------------------
Given a path returns the valid drive letter if one exists in the path, 
otherwise returns 0.
---------------------------------------------------------------------------*/
{
	TCHAR *pchColon, chDrive;

	pchColon = CharNext(szPath);
	if (*pchColon != ':')
		return 0;

	chDrive = *szPath;
	if ( (chDrive >= 'A') && (chDrive <= 'Z') )
		0;
	else if ( (chDrive >= 'a') && (chDrive <= 'z'))
		chDrive = char(chDrive + ('A' - 'a'));
	else
		chDrive = 0;
	
	return chDrive;
}

bool IsNetworkPath(const TCHAR* szPath)
{
	TCHAR chDrive;
	unsigned int uiResult;
	
	// URL
	if (IsURL(szPath))
		return true;

	// UNC
	if (0 == _tcsncmp(szPath, TEXT("\\"), 2))
		return true;

	// Drive letter, that might be mapped
	if ((chDrive = ExtractDriveLetter(szPath)) != 0)    // Check for DRIVE:[\PATH]
	{
		TCHAR szPath[] = TEXT("A:\\");

		szPath[0] = chDrive;
		
		// first, try without impersonating
		uiResult = W32::GetDriveType(szPath);
		if (uiResult == DRIVE_UNKNOWN || uiResult == DRIVE_NO_ROOT_DIR)
		{
			// failure, just return remote
			return true;
		}
		return (DRIVE_REMOTE == uiResult) ? true : false;
	}

	// something we don't recognize at all - assume it's a wacky network type.  
	return true;
}

bool FFileExists(const TCHAR* szFullFilePath, DWORD& dwError)
{
	bool fExists = false;
	dwError = 0;

	DWORD iAttribs = W32::GetFileAttributes(szFullFilePath);
	if ((iAttribs == 0xFFFFFFFF))
	{
		dwError = W32::GetLastError();
		if (ERROR_FILE_NOT_FOUND == dwError)
		{
			dwError = 0;
		}
		// failure - don't know if file exists or not.  caller should check dwError
	}
	else if (!(iAttribs & FILE_ATTRIBUTE_DIRECTORY))
	{
		fExists = true;
	}

	return fExists;
}



UINT MyGetTempFileName(const TCHAR* szDir, const TCHAR* szPrefix, const TCHAR* szExtension,
							  CAPITempBufferRef<TCHAR>& rgchTempFilePath)
{
	// it is assumed szDir does not end with a '\\'
	
	int cchDir = lstrlen(szDir);
	
	int cchTempFilePath = cchDir + 15; // 13 for filename, 1 for '\\', 1 for NULL
	if(rgchTempFilePath.GetSize() < cchTempFilePath)
		rgchTempFilePath.SetSize(cchTempFilePath);

	// need a different extension - create our own name
	TCHAR rgchExtension[5] = {TEXT(".tmp")};

	if(szExtension && *szExtension)
		lstrcpyn(rgchExtension+1, szExtension, 4 /* 3 + null */);

	int cchPrefix = szPrefix ? lstrlen(szPrefix) : 0;
	
	if(cchPrefix > 8)
		cchPrefix = 8; // use only first 8 chars of prefix
	
	int cDigits = 8-cchPrefix; // number of hex digits to use in file name

	static bool fInitialized = false;
	static unsigned int uiUniqueStart;

	// Might be a chance for two threads to get in here, we're not going to be worried
	// about that. It would get intialized twice
	if (!fInitialized)
	{
		uiUniqueStart = W32::GetTickCount();
		fInitialized = true;
	}
	unsigned int uiUniqueId = uiUniqueStart++;
	
	if(cchPrefix)
		uiUniqueId &= ((1 << 4*cDigits) - 1);
	
	unsigned int cPerms = cDigits == 8 ? ~0 : (1 << 4*cDigits) -1; // number of possible file names to try ( minus 1 )
	
	bool fCreatedFile = false;
	DWORD dwError = ERROR_SUCCESS;

	for(unsigned int i = 0; i <= cPerms; i++)
	{
		TCHAR rgchFileName [9];
		if(szPrefix)
			lstrcpyn(rgchFileName, szPrefix, cchPrefix);
		if(cDigits)
			wsprintf(rgchFileName+cchPrefix,TEXT("%x"),uiUniqueId);

		lstrcpy(rgchTempFilePath, szDir);
		rgchTempFilePath[cchDir] = '\\';
		lstrcpy(&(rgchTempFilePath[cchDir+1]), rgchFileName);
		lstrcat(&(rgchTempFilePath[cchDir+1+lstrlen(rgchFileName)]), rgchExtension);

		DWORD dwTemp = ERROR_SUCCESS;
		if((FFileExists(rgchTempFilePath, dwTemp) == false) && dwTemp == ERROR_SUCCESS)
		{
			// found a name that isn't already taken - create file as a placeholder for name
			HANDLE hFile = W32::CreateFile(rgchTempFilePath, GENERIC_WRITE, FILE_SHARE_READ, 0,
													  CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);

			if(hFile == INVALID_HANDLE_VALUE)
				dwError = GetLastError();
			else
			{
				dwError = 0;
				fCreatedFile = true;
			}

			CloseHandle(hFile);

			if(dwError != ERROR_FILE_EXISTS) // could have failed because file was created under us
				break; // if file creation failed for any other reason,
						 // assume we can't create any file in this folder
		}

		// increment number portion of name - if it currently equals cPerms, it is time to
		// wrap number around to 0
		uiUniqueStart++;
		if(uiUniqueId == cPerms)
			uiUniqueId = 0;
		else
			uiUniqueId++;
	}

	if(fCreatedFile == false)
	{
		if(dwError == 0)
			dwError = ERROR_FILE_EXISTS; // default error - only used if we exhausted all file names
												 // and looped to the end
	}
	else
	{
		dwError = ERROR_SUCCESS;
	}

	return dwError;
}
int MsiError(INSTALLMESSAGE eMessageType, int iError)
{
	return MsiError(eMessageType, iError, NULL, 0);
}

int MsiError(INSTALLMESSAGE eMessageType, int iError, const TCHAR* szString, int iInt)
{
	int iStatus = 0;
	if (g_hInstall && g_recOutput)
	{			
		(g_pfnMsiRecordClearData)();
		(g_pfnMsiRecordSetString)(g_recOutput, 0, NULL);
		(g_pfnMsiRecordSetInteger)(g_recOutput, 1, iError);
		if (szString)
		{
			(g_pfnMsiRecordSetString)(g_recOutput, 2, szString);
			(g_pfnMsiRecordSetInteger)(g_recOutput, 3, iInt);
		}
		iStatus = (g_pfnMsiProcessMessage)(g_hInstall, eMessageType, g_recOutput);
	}

	return iStatus;

}

int OutputString(INSTALLMESSAGE eMessageType, const TCHAR *fmt, ...)
{
	int iStatus = 0;

	TCHAR szOutput[2048] = TEXT("");

	va_list va;
	va_start(va, fmt);
	
	if (!g_fQuiet)
	{
		_stprintf(szOutput, TEXT("MSIMIG: "));
		_vstprintf(szOutput+8, fmt, va);

		if (g_hInstall && g_recOutput)
		{
			(g_pfnMsiRecordSetString)(g_recOutput, 0, szOutput);
			iStatus = (g_pfnMsiProcessMessage)(g_hInstall, eMessageType, g_recOutput);
		}
		else
		{
		


			iStatus = _tprintf(szOutput);
		}
	}

	va_end(va);

	return iStatus;

}


DWORD GetUserSID(HANDLE hToken, char* rgSID)
// get the (binary form of the) SID for the user specified by hToken
{
	UCHAR TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
	ULONG ReturnLength;

	BOOL f = W32::GetTokenInformation(hToken,
												TokenUser,
												TokenInformation,
												sizeof(TokenInformation),
												&ReturnLength);

	if(f == FALSE)
	{
		DWORD dwRet = GetLastError();
		OutputString(INSTALLMESSAGE_INFO, TEXT("GetTokenInformation failed with error %d"), dwRet);
		MsiError(INSTALLMESSAGE_ERROR, 1708 /* install failed*/);
		return dwRet;
	}

	PISID iSid = (PISID)((PTOKEN_USER)TokenInformation)->User.Sid;
	if (W32::CopySid(cbMaxSID, rgSID, iSid))
		return ERROR_SUCCESS;
	else
		return GetLastError();
}

bool IsLocalSystemToken(HANDLE hToken)
{

	TCHAR szCurrentStringSID[cchMaxSID];
	char  rgchCurrentSID[cbMaxSID];
	if ((hToken == 0) || (ERROR_SUCCESS != GetUserSID(hToken, rgchCurrentSID)))
		return false;

	GetStringSID((PISID)rgchCurrentSID, szCurrentStringSID);
	return 0 == lstrcmp(szLocalSystemSID, szCurrentStringSID);
}


bool RunningAsLocalSystem()
{
	static int iRet = -1;

	if(iRet != -1)
		return (iRet != 0);
	{
		iRet = 0;
		HANDLE hTokenImpersonate = INVALID_HANDLE_VALUE;
		if(W32::OpenThreadToken(W32::GetCurrentThread(), TOKEN_IMPERSONATE , TRUE, &hTokenImpersonate))
			W32::SetThreadToken(0, 0); // stop impersonation

		HANDLE hToken;

		if (W32::OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
		{
			bool fIsLocalSystem = IsLocalSystemToken(hToken);
			W32::CloseHandle(hToken);

			if (fIsLocalSystem)
				iRet = 1;
		}
		if(hTokenImpersonate != INVALID_HANDLE_VALUE)
		{
			W32::SetThreadToken(0, hTokenImpersonate); // start impersonation
			W32::CloseHandle(hTokenImpersonate);
		}
		return (iRet != 0);
	}
}

BOOL MsiCanonicalizeUrl(
	LPCTSTR lpszUrl, 
	OUT LPTSTR lpszBuffer, 
	IN OUT LPDWORD lpdwBufferLength, 
	IN DWORD dwFlags)
{
	if (IsURL(lpszUrl))
	{
		int cchUrl = lstrlen(lpszUrl);

		// leave room for trailing null
		if ((cchUrl+1) * sizeof(TCHAR) > *lpdwBufferLength)
		{
			W32::SetLastError(ERROR_INSUFFICIENT_BUFFER);
			*lpdwBufferLength = ((cchUrl+1) * sizeof(TCHAR));
			return FALSE;
		}

		// don't include NULL in outbound length
		*lpdwBufferLength = cchUrl*sizeof(TCHAR);
		memcpy(lpszBuffer, lpszUrl, *lpdwBufferLength);

		// null terminate the string
		lpszBuffer[cchUrl] = 0; 
			 
		// swap all the back slashes to forward slashes.
		TCHAR* pchOutbound = lpszBuffer;
		while (*pchOutbound)
		{
			if (TCHAR('\\') == *pchOutbound)
				*pchOutbound = TCHAR('/');
			pchOutbound++;
		}

		W32::SetLastError(0);
		return TRUE;
	}
	else
	{
		W32::SetLastError(ERROR_INTERNET_INVALID_URL);
		return FALSE;
	}
}

DWORD DownloadUrlFile(const TCHAR* szPotentialURL, CAPITempBufferRef<TCHAR>& rgchPackagePath, bool& fURL)
{
	DWORD iStat = ERROR_SUCCESS;
	CAPITempBuffer<TCHAR, MAX_PATH + 1> rgchURL;
	DWORD cchURL = MAX_PATH + 1;
	fURL = true;

	if (!MsiCanonicalizeUrl(szPotentialURL, rgchURL, &cchURL, NULL))
	{
		DWORD dwLastError = W32::GetLastError();
		if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
		{
			rgchURL.SetSize(cchURL);
			if (MsiCanonicalizeUrl(szPotentialURL, rgchURL, &cchURL, NULL))
				dwLastError = 0;
		}
		else
		{
			fURL = false;
		}
	}

	if (fURL)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Package path is a URL. Downloading package.\r\n"));
		// Cache the database locally, and run from that.

		// The returned path is a local path.  Max path should adequately cover it.
		static HINSTANCE hURLMONLib = W32::LoadLibrary(TEXT("urlmon.dll"));

		if (!hURLMONLib) 
			return E_FAIL;

		// URLMON occasionally hangs during FreeLibrary, so make it static
		// and not unload it.

		static PFnURLDownloadToCacheFile pfnURLDownloadToCacheFile = 
			(PFnURLDownloadToCacheFile) W32::GetProcAddress(hURLMONLib, URLMONAPI_URLDownloadToCacheFile);
		if (!pfnURLDownloadToCacheFile)
			return E_FAIL;

		DWORD dwBufLength = rgchPackagePath.GetSize();

		HRESULT hResult = (pfnURLDownloadToCacheFile)(NULL, rgchURL, rgchPackagePath,  
																		 dwBufLength, 0, NULL);

		if (ERROR_SUCCESS != hResult)
		{
			rgchPackagePath[0] = NULL;

			if (E_ABORT == hResult)
				iStat = ERROR_INSTALL_USEREXIT;
			else
			{
				if (E_OUTOFMEMORY == hResult)
					W32::SetLastError(ERROR_INSUFFICIENT_BUFFER);
				iStat = ERROR_FILE_NOT_FOUND;
			}
		}
		
	}
	return iStat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimsg\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimsg\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimig\msimig.cpp ===
//LINKLIBS = shell32.lib msvcrt.lib
//#POSTBUILDSTEP = -1$(TOOLSBIN)\imagecfg.exe -h 1 $@ */

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       msimig.cpp
//
//--------------------------------------------------------------------------


#define WINDOWS_LEAN_AND_MEAN  // faster compile

#include "_msimig.h"

//________________________________________________________________________________
//
// Constants and globals
//________________________________________________________________________________

bool                      g_fWin9X                    = false;
bool                      g_fQuiet                    = false;
bool                      g_fRunningAsLocalSystem     = false; // can only be true in Custom Action.
BOOL                      g_fPackageElevated          = FALSE;
int                       g_iAssignmentType           = -1; // only set if fPackageElevated

MSIHANDLE                            g_hInstall                             = NULL;
MSIHANDLE                            g_recOutput                            = NULL;
HINSTANCE                            g_hLib                                 = NULL;
PFnMsiCreateRecord                   g_pfnMsiCreateRecord                   = NULL;
PFnMsiProcessMessage                 g_pfnMsiProcessMessage                 = NULL;
PFnMsiRecordSetString                g_pfnMsiRecordSetString                = NULL;
PFnMsiRecordSetInteger               g_pfnMsiRecordSetInteger               = NULL;
PFnMsiRecordClearData                g_pfnMsiRecordClearData                = NULL;
PFnMsiCloseHandle                    g_pfnMsiCloseHandle                    = NULL;
PFnMsiGetProperty                    g_pfnMsiGetProperty                    = NULL;
PFnMsiSourceListAddSource            g_pfnMsiSourceListAddSource            = NULL;
PFnMsiIsProductElevated              g_pfnMsiIsProductElevated              = NULL;
PFnMsiGetProductInfo                 g_pfnMsiGetProductInfo                 = NULL;
PFnMsiGetSummaryInformation          g_pfnMsiGetSummaryInformation          = NULL;
PFnMsiSummaryInfoGetProperty         g_pfnMsiSummaryInfoGetProperty         = NULL;
PFnMsiGetProductCodeFromPackageCode  g_pfnMsiGetProductCodeFromPackageCode  = NULL;



//_____________________________________________________________________________________________________
//
// command line parsing functions
//_____________________________________________________________________________________________________


TCHAR SkipWhiteSpace(TCHAR*& rpch)
{
	TCHAR ch;
	for (; (ch = *rpch) == TEXT(' ') || ch == TEXT('\t'); rpch++)
		;
	return ch;
}

BOOL SkipValue(TCHAR*& rpch)
{
	TCHAR ch = *rpch;
	if (ch == 0 || ch == TEXT('/') || ch == TEXT('-'))
		return FALSE;   // no value present

	TCHAR *pchSwitchInUnbalancedQuotes = NULL;

	for (; (ch = *rpch) != TEXT(' ') && ch != TEXT('\t') && ch != 0; rpch++)
	{       
		if (*rpch == TEXT('"'))
		{
			rpch++; // for '"'

			for (; (ch = *rpch) != TEXT('"') && ch != 0; rpch++)
			{
				if ((ch == TEXT('/') || ch == TEXT('-')) && (NULL == pchSwitchInUnbalancedQuotes))
				{
					pchSwitchInUnbalancedQuotes = rpch;
				}
			}
                    ;
            ch = *(++rpch);
            break;
		}
	}
	if (ch != 0)
	{
		*rpch++ = 0;
	}
	else
	{
		if (pchSwitchInUnbalancedQuotes)
			rpch=pchSwitchInUnbalancedQuotes;
	}
	return TRUE;
}

//______________________________________________________________________________________________
//
// RemoveQuotes function to strip surrounding quotation marks
//     "c:\temp\my files\testdb.msi" becomes c:\temp\my files\testdb.msi
//
//	Also acts as a string copy routine.
//______________________________________________________________________________________________

void RemoveQuotes(const TCHAR* szOriginal, TCHAR* sz)
{
	const TCHAR* pch = szOriginal;
	if (*pch == TEXT('"'))
		pch++;
	int iLen = _tcsclen(pch);
	for (int i = 0; i < iLen; i++, pch++)
		sz[i] = *pch;

	pch = szOriginal;
	if (*(pch + iLen) == TEXT('"'))
			sz[iLen-1] = TEXT('\0');
}


//________________________________________________________________________________
//
// Error handling and Display functions:
//________________________________________________________________________________

void DisplayErrorCore(const TCHAR* szError, int cb)
{
	cb;
	OutputString(INSTALLMESSAGE_INFO, szError);
	
/*	if (g_hStdOut)  // output redirected, suppress UI (unless output error)
	{
		// _stprintf returns char count, WriteFile wants byte count
		DWORD cbWritten;
		if (WriteFile(g_hStdOut, szError, cb*sizeof(TCHAR), &cbWritten, 0))
			return;
	}
//	::MessageBox(0, szError, TEXT("MsiMsp"), MB_OK);
*/
}

void DisplayUsage()
{
	TCHAR szMsgBuf[1024];
	// this will fail when called as a custom action
	if(0 == W32::LoadString(GetModuleHandle(0), IDS_Usage, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR)))
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Failed to load error string.\r\n"));
		return;
	}

	TCHAR szOutBuf[1124];
	int cbOut = 0;
	cbOut = _stprintf(szOutBuf, TEXT("%s\r\n"), szMsgBuf);

	DisplayErrorCore(szOutBuf, cbOut);

}

void DisplayError(UINT iErrorStringID, int iErrorParam)
{
	TCHAR szMsgBuf[1024];
	if(0 == W32::LoadString(0, iErrorStringID, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR)))
		return;

	TCHAR szOutBuf[1124];
	int cbOut = _stprintf(szOutBuf, TEXT("%s: 0x%X\r\n"), szMsgBuf, iErrorParam);

	DisplayErrorCore(szOutBuf, cbOut);
}

//_____________________________________________________________________________________________________
//
// Migration Actions
//_____________________________________________________________________________________________________


//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

int SharedEntry(const TCHAR* szCmdLine)
{

	OutputString(INSTALLMESSAGE_INFO, TEXT("Command line: %s\r\n"), szCmdLine);
	OSVERSIONINFO osviVersion;
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	W32::GetVersionEx(&osviVersion); // fails only if size set wrong
	if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
		g_fWin9X = true;


	TCHAR szUser[1024]         = {0};
	TCHAR szProductCode[1024]  = {0};
	TCHAR szPackagePath[2048]  = {0};
	migEnum migOptions = migEnum(0);

	// Parse command line
	TCHAR chCmdNext;
	TCHAR* pchCmdLine = (TCHAR*) szCmdLine;
	SkipValue(pchCmdLine);   // skip over module name

	// check for empty command line.  at least one option is required
	chCmdNext = SkipWhiteSpace(pchCmdLine);
	if(chCmdNext == 0)
	{
		DisplayUsage();
		return 1;
	}

	do
	{
		if (chCmdNext == TEXT('/') || chCmdNext == TEXT('-'))
		{
			TCHAR szBuffer[MAX_PATH] = {0};
			TCHAR* szCmdOption = pchCmdLine++;  // save for error msg
			TCHAR chOption = (TCHAR)(*pchCmdLine++ | 0x20);
			chCmdNext = SkipWhiteSpace(pchCmdLine);
			TCHAR* szCmdData = pchCmdLine;  // save start of data
			switch(chOption)
			{
			case TEXT('u'):
				if (!SkipValue(pchCmdLine))
				{
					DisplayUsage();
					return 1;
				}
				RemoveQuotes(szCmdData, szUser);
				break;
			case TEXT('p'):
				if (!SkipValue(pchCmdLine))
				{
					DisplayUsage();
					return 1;
				}
				RemoveQuotes(szCmdData, szProductCode);
				break;
			case TEXT('m'):
				if (!SkipValue(pchCmdLine))
					DisplayUsage();
				RemoveQuotes(szCmdData, szPackagePath);
				break;
			case TEXT('a'):
				break;
			case TEXT('f'):
				migOptions = migEnum(migOptions | migMsiTrust10PackagePolicyOverride);
				break;
			case TEXT('q'):
				migOptions = migEnum(migOptions | migQuiet);
				g_fQuiet = true;
				break;
			case TEXT('?'):
				DisplayUsage();
				return 0;
				break;
			default:
				DisplayUsage();
				return 1;
				break;
			};
		}
		else
		{
			DisplayUsage();
			return 1;
		}
	} while ((chCmdNext = SkipWhiteSpace(pchCmdLine)) != 0);

	
	if (!g_hLib)
		g_hLib = LoadLibrary(MSI_DLL);

	if (!g_hLib)
		return ERROR_INSTALL_FAILURE;

	g_pfnMsiSourceListAddSource           = (PFnMsiSourceListAddSource)            W32::GetProcAddress(g_hLib, MSIAPI_MSISOURCELISTADDSOURCE);
   g_pfnMsiIsProductElevated             = (PFnMsiIsProductElevated)              W32::GetProcAddress(g_hLib, MSIAPI_MSIISPRODUCTELEVATED);
   g_pfnMsiGetProductInfo                = (PFnMsiGetProductInfo)                 W32::GetProcAddress(g_hLib, MSIAPI_MSIGETPRODUCTINFO);
	g_pfnMsiGetProductCodeFromPackageCode = (PFnMsiGetProductCodeFromPackageCode)  W32::GetProcAddress(g_hLib, MSIAPI_MSIGETPRODUCTCODEFROMPACKAGECODE);
	g_pfnMsiSummaryInfoGetProperty        = (PFnMsiSummaryInfoGetProperty)         W32::GetProcAddress(g_hLib, MSIAPI_MSISUMMARYINFOGETPROPERTY);
	g_pfnMsiGetSummaryInformation         = (PFnMsiGetSummaryInformation)          W32::GetProcAddress(g_hLib, MSIAPI_MSIGETSUMMARYINFORMATION);
	g_pfnMsiCloseHandle                   = (PFnMsiCloseHandle)                    W32::GetProcAddress(g_hLib, MSIAPI_MSICLOSEHANDLE);


	if (!g_pfnMsiGetProperty)
		g_pfnMsiGetProperty                = (PFnMsiGetProperty)                    W32::GetProcAddress(g_hLib, MSIAPI_MSIGETPROPERTY);

	if (!(g_pfnMsiGetProperty &&
			g_pfnMsiSourceListAddSource &&
			g_pfnMsiIsProductElevated &&
			g_pfnMsiGetProductInfo &&
			g_pfnMsiGetProductCodeFromPackageCode &&
			g_pfnMsiGetSummaryInformation &&
			g_pfnMsiSummaryInfoGetProperty &&
			g_pfnMsiGetProperty)) 
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("This version of the MSI.DLL does not support migration.\r\n"));
		return ERROR_INSTALL_FAILURE;
	}
	
	int iReturn = Migrate10CachedPackages(szProductCode, szUser, szPackagePath, migOptions);



	if (g_hLib) 
		FreeLibrary(g_hLib);

	return iReturn;
}

extern "C" int __stdcall CustomActionEntry(MSIHANDLE hInstall)
{
	//MessageBox(NULL, TEXT("MsiMig"), TEXT("MsiMig"), MB_OK);

	g_hInstall = hInstall;

	// cannot run as local system except in custom action.
	g_fRunningAsLocalSystem = RunningAsLocalSystem();

	TCHAR szCommandLine[2048] = TEXT("");
	DWORD cchCommandLine = 2048;

	if (!g_hLib)
		g_hLib = LoadLibrary(MSI_DLL); // closed in SharedEntry
	if (!g_hLib)
		return ERROR_INSTALL_FAILURE;

	// custom action only entry points
	g_pfnMsiCreateRecord        = (PFnMsiCreateRecord)         W32::GetProcAddress(g_hLib, MSIAPI_MSICREATERECORD);
	g_pfnMsiProcessMessage      = (PFnMsiProcessMessage)       W32::GetProcAddress(g_hLib, MSIAPI_MSIPROCESSMESSAGE);
	g_pfnMsiRecordSetString     = (PFnMsiRecordSetString)      W32::GetProcAddress(g_hLib, MSIAPI_MSIRECORDSETSTRING);
	g_pfnMsiRecordSetInteger    = (PFnMsiRecordSetInteger)     W32::GetProcAddress(g_hLib, MSIAPI_MSIRECORDSETINTEGER);
	g_pfnMsiRecordClearData     = (PFnMsiRecordClearData)      W32::GetProcAddress(g_hLib, MSIAPI_MSIRECORDCLEARDATA);
	g_pfnMsiGetProperty         = (PFnMsiGetProperty)          W32::GetProcAddress(g_hLib, MSIAPI_MSIGETPROPERTY);

	if (!(g_pfnMsiCreateRecord && 
			g_pfnMsiProcessMessage && 
			g_pfnMsiRecordSetString &&
			g_pfnMsiRecordSetInteger &&
			g_pfnMsiRecordClearData))
		return ERROR_INSTALL_FAILURE;

	(g_pfnMsiGetProperty)(g_hInstall, TEXT("CustomActionData"), szCommandLine, &cchCommandLine);

	// create a record large enough for any error - but only in custom actions.
	g_recOutput = (g_pfnMsiCreateRecord)(5);
	if (!g_recOutput)
		return ERROR_INSTALL_FAILURE;
	
	int iReturn = SharedEntry(szCommandLine);
	
	if (g_recOutput)
		g_pfnMsiCloseHandle(g_recOutput);

	return iReturn;
}

extern "C" int __cdecl _tmain(int /*argc*/, TCHAR* /*argv[]*/)
{
		return SharedEntry(GetCommandLine());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimig\_msimig.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       _msimig.h
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <tchar.h>  

// resource string ids
#define IDS_Usage               1

#ifndef RC_INVOKED    // start of source code

#include "buffer.h"
#include "msi.h"
#include <wininet.h>
#include <urlmon.h>

extern bool g_fWin9X;
extern bool g_fQuiet;
extern BOOL g_fPackageElevated;
extern int  g_iAssignmentType;

#define W32

#define MSI_DLL TEXT("msi.dll")
extern HINSTANCE g_hLib;
extern MSIHANDLE g_hInstall;
extern MSIHANDLE g_recOutput;

#define PID_REVNUMBER 9

#define URLMON_DLL TEXT("urlmon.dll")

#define szMsiPolicyKey   TEXT("Software\\Policies\\Microsoft\\Windows\\Installer")
#define szMsiPolicyTrust10CachedPackages  TEXT("Trust1.0CachedPackages")

#define szLocalSystemSID TEXT("S-1-5-18")

#define szManagedText TEXT("(Managed)")

typedef enum migEnum
{
	
	
	migQuiet                                 = 1 << 0,
	migMsiTrust10PackagePolicyOverride       = 1 << 1,
	migCustomActionUserPass                  = 1 << 2,
	migCustomActionSecurePass                = 1 << 3,
};

DWORD Migrate10CachedPackages(const TCHAR* szProductCode,
									  const TCHAR* szUser,
									  const TCHAR* szAlternativePackage,
									  const migEnum migOptions);


#ifndef DLLVER_PLATFORM_NT
typedef struct _DllVersionInfo
{
        DWORD cbSize;
        DWORD dwMajorVersion;                   // Major version
        DWORD dwMinorVersion;                   // Minor version
        DWORD dwBuildNumber;                    // Build number
        DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;
#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT
typedef interface IBindStatusCallback IBindStatusCallback;
#endif

// assignment types - note that these do not follow iaaAppAssignment
enum eAppAssignment {
	AssignmentUser = 0,
	AssignmentMachine = 1
};

const int cchGUID                     = 38;
const int cchGUIDPacked               = 32;
const int cchGUIDCompressed           = 20;
const int cchMaxSID                   = 256;

enum ipgEnum
{
	ipgFull       = 0,  // no compression
	ipgPacked     = 1,  // remove punctuation and reorder low byte first
	ipgCompressed = 2,  // max text compression, can't use in reg keys or value names
	ipgPartial    = 3,  // partial translation, between ipgCompressed and ipgPacked
};

bool PackGUID(const TCHAR* szGUID, TCHAR* szSQUID, ipgEnum ipg);
bool UnpackGUID(const TCHAR* szSQUID, TCHAR* szGUID, ipgEnum ipg);


const int cbMaxSID                    = sizeof(SID) + SID_MAX_SUB_AUTHORITIES*sizeof(DWORD);
DWORD GetUserStringSID(const TCHAR* szUser, TCHAR* szSID, char* pbBinarySID /*can be NULL*/);
bool RunningAsLocalSystem();


LONG MyRegQueryValueEx(HKEY hKey,
							  const TCHAR* lpValueName,
							  LPDWORD /*lpReserved*/,
							  LPDWORD lpType,
							  CAPITempBufferRef<TCHAR>& rgchBuf,
							  LPDWORD lpcbBuf);

#ifdef UNICODE
#define W_A "W"
#else
#define W_A "A"
#endif

#define MSIAPI_DLLGETVERSION     "DllGetVersion"
typedef UINT (__stdcall *PFnDllGetVersion)(DLLVERSIONINFO *pdvi);

#define MSIAPI_MSISETINTERNALUI  "MsiSetInternalUI"
typedef INSTALLUILEVEL (__stdcall *PFnMsiSetInternalUI)(INSTALLUILEVEL dwUILevel, HWND* phWnd);

#define MSIAPI_MSIOPENPRODUCT    "MsiOpenProduct" ## W_A
typedef UINT (__stdcall *PFnMsiOpenProduct)(const TCHAR* szProductCode, MSIHANDLE *phProduct);

#define MSIAPI_MSIDOACTION       "MsiDoAction" ## W_A
typedef UINT (__stdcall *PFnMsiDoAction)(MSIHANDLE hProduct, const TCHAR* szAction);

#define MSIAPI_MSIGETPROPERTY    "MsiGetProperty" ## W_A
typedef UINT (__stdcall *PFnMsiGetProperty)(MSIHANDLE hProduct,
														  const TCHAR* szProperty,
														  TCHAR* szValueBuf,
														  DWORD* pcchValueBuf);

#define MSIAPI_MSICLOSEHANDLE    "MsiCloseHandle"
typedef UINT (__stdcall *PFnMsiCloseHandle)(MSIHANDLE hProduct);

#define MSIAPI_MSICREATERECORD   "MsiCreateRecord"
typedef MSIHANDLE (__stdcall *PFnMsiCreateRecord)(unsigned int cParams);

#define MSIAPI_MSIRECORDSETSTRING   "MsiRecordSetString" ## W_A
typedef MSIHANDLE (__stdcall *PFnMsiRecordSetString)(MSIHANDLE hRecord, unsigned int iField, LPCTSTR szValue);

#define MSIAPI_MSIRECORDSETINTEGER  "MsiRecordSetInteger"
typedef MSIHANDLE (__stdcall *PFnMsiRecordSetInteger)(MSIHANDLE hRecord, unsigned int iField, int iValue);

#define MSIAPI_MSIRECORDCLEARDATA  "MsiRecordClearData"
typedef MSIHANDLE (__stdcall *PFnMsiRecordClearData)();


#define MSIAPI_MSIPROCESSMESSAGE "MsiProcessMessage"
typedef UINT (__stdcall *PFnMsiProcessMessage)(MSIHANDLE hInstall,
																INSTALLMESSAGE eMessageType, 
																MSIHANDLE hRecord);

#define MSIAPI_MSISOURCELISTADDSOURCE "MsiSourceListAddSource" ## W_A
typedef UINT (__stdcall *PFnMsiSourceListAddSource)(LPCTSTR szProduct,		// product code
																	LPCTSTR szUserName,		// user name or NULL
																	DWORD dwReserved,			// reserved, must be 0
																	LPCTSTR szSource);			// pointer

#define MSIAPI_MSIGETPRODUCTINFO "MsiGetProductInfo" ## W_A
typedef UINT (__stdcall *PFnMsiGetProductInfo)(LPCTSTR szProduct,	// product code
															LPCTSTR szProperty,  // product property
															LPTSTR lpValueBuf,   // buffer to return property value
															DWORD *pcchValueBuf);// buffer character count,

#define MSIAPI_MSIGETSUMMARYINFORMATION "MsiGetSummaryInformation" ## W_A
typedef UINT (__stdcall *PFnMsiGetSummaryInformation)(MSIHANDLE hDatabase,       // database handle
															  LPCTSTR szDatabasePath,    // path to database
															  UINT uiUpdateCount,        // maximum number of updated values, 0
																								  //  to open read-only
															  MSIHANDLE *phSummaryInfo);   // location to return summary information
																								  //  handle

#define MSIAPI_MSISUMMARYINFOGETPROPERTY "MsiSummaryInfoGetProperty" ## W_A
typedef UINT (__stdcall *PFnMsiSummaryInfoGetProperty)(MSIHANDLE hSummaryInfo,   // summary info handle
																		UINT uiProperty,          // property
																		UINT *puiDataType,        // property type
																		INT *piValue,             // value
																		FILETIME *pftValue,       // file time
																		LPCTSTR szValueBuf,       // value buffer
																		DWORD *pcchValueBuf);       // buffer size

// private APIs
#define MSIAPI_MSIISPRODUCTELEVATED "MsiIsProductElevated" ## W_A
typedef UINT (__stdcall *PFnMsiIsProductElevated)(LPCTSTR szProduct,		// product code
																	BOOL *pfElevated);

#define MSIAPI_MSIGETPRODUCTCODEFROMPACKAGECODE "MsiGetProductCodeFromPackageCode" ## W_A
typedef UINT (__stdcall *PFnMsiGetProductCodeFromPackageCode)(LPCTSTR szPackageCode, // package code
																LPTSTR szProductCode);  // a buffer of size 39 to recieve product code

#define MSIAPI_MSIMIGRATE10CACHEDPACKAGES    "Migrate10CachedPackages" ## W_A
typedef UINT (__stdcall *PFnMsiMigrate10CachedPackages)(const TCHAR* szProductCode,
														const TCHAR* szUser,
														const TCHAR* szAlternativePackage,
														const migEnum migOptions);


// external APIs
#define URLMONAPI_URLDownloadToCacheFile    "URLDownloadToCacheFile" ## W_A
typedef HRESULT (__stdcall *PFnURLDownloadToCacheFile)(LPUNKNOWN lpUnkcaller,
											 LPCTSTR szURL,
											 LPTSTR szFileName,
											 DWORD dwBufLength,
											 DWORD dwReserved,
											 IBindStatusCallback *pBSC);



extern PFnMsiCreateRecord                     g_pfnMsiCreateRecord;
extern PFnMsiProcessMessage                   g_pfnMsiProcessMessage;
extern PFnMsiRecordSetString                  g_pfnMsiRecordSetString;
extern PFnMsiRecordSetInteger                 g_pfnMsiRecordSetInteger;
extern PFnMsiRecordClearData                  g_pfnMsiRecordClearData;
extern PFnMsiCloseHandle                      g_pfnMsiCloseHandle;
extern PFnMsiGetProperty                      g_pfnMsiGetProperty;
extern PFnMsiSourceListAddSource              g_pfnMsiSourceListAddSource;
extern PFnMsiIsProductElevated                g_pfnMsiIsProductElevated;
extern PFnMsiGetProductInfo                   g_pfnMsiGetProductInfo;
extern PFnMsiGetProductCodeFromPackageCode    g_pfnMsiGetProductCodeFromPackageCode;
extern PFnMsiGetSummaryInformation            g_pfnMsiGetSummaryInformation;
extern PFnMsiSummaryInfoGetProperty           g_pfnMsiSummaryInfoGetProperty;

extern bool                                   g_fRunningAsLocalSystem;


UINT MyMsiGetProperty(PFnMsiGetProperty pfn,
							 MSIHANDLE hProduct,
							 const TCHAR* szProperty,
							 CAPITempBufferRef<TCHAR>& rgchBuffer);

UINT MyMsiGetProductInfo(PFnMsiGetProductInfo pfn,
								 const TCHAR* szProductCode,
								 const TCHAR* szProperty,
								 CAPITempBufferRef<TCHAR>& rgchBuffer);

bool IsURL(const TCHAR* szPath);
bool IsNetworkPath(const TCHAR* szPath);

DWORD DownloadUrlFile(const TCHAR* szPotentialURL, CAPITempBufferRef<TCHAR>& rgchPackagePath, bool& fURL);

UINT MyGetTempFileName(const TCHAR* szDir, const TCHAR* szPrefix, const TCHAR* szExtension,
							  CAPITempBufferRef<TCHAR>& rgchTempFilePath);

int OutputString(INSTALLMESSAGE eMessageType, const TCHAR *fmt, ...);

int MsiError(INSTALLMESSAGE eMessageType, int iError);
int MsiError(INSTALLMESSAGE eMessageType, int iError, const TCHAR* szString, int iInt);


#ifdef DEBUG
#define DebugOutputString OutputString
#else
#define DebugOutputString
#endif


#endif //RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimsg\make.inc ===
!INCLUDE ..\..\..\MsiMake.inc


MSG_DIR=$(SRC_DIR)\MsiTools\MsiMsg
MSG_OBJDIR=$(MSG_DIR)\$(MSI_SUBDIR)\$(O)

MsiMsgAll:$(BUILD_DIR)\msimsg.dll \
        $(BUILD_DIR)\MsiError.msg


$(BUILD_DIR)\MsiError.msg : $(MSG_OBJDIR)\MsiError.mc
        mc -h $(BUILD_DIR) -r $(MSG_OBJDIR) $(MSG_OBJDIR)\MsiError.mc
        rc -Fo$(MSG_OBJDIR)\MsiError.res -i $(INC_DIR) $(MSG_OBJDIR)\MsiError.rc
        $(LINK_NAME) -out:$@ /machine:$(MACHINE_TYPE) /DLL /NOENTRY $(MSG_OBJDIR)\MsiError.res

$(MSG_OBJDIR)\MsiError.mc: $(MSI_BUILDTOOLS_DIR)\genmsier.prl
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsier.prl $(SDK_INC_PATH)\msi.h $@
        
$(BUILD_DIR)\msimsg.dll: $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.* $(MSI_INTLDATA_DIR)\ActionTe.* $(INC_DIR)\version.h $(RES_OBJDIR)\msi.rcv
        @if exist $(MSG_OBJDIR)\err???.rc del $(MSG_OBJDIR)\err???.rc
        @if exist $(MSG_OBJDIR)\act???.rc del $(MSG_OBJDIR)\act???.rc

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.ARA $(MSG_OBJDIR)\errara.rc 1 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.ARA $(MSG_OBJDIR)\actara.rc 1 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.CAT $(MSG_OBJDIR)\errcat.rc 3 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.CAT $(MSG_OBJDIR)\actcat.rc 3 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.CHS $(MSG_OBJDIR)\errchs.rc 4 2
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.CHS $(MSG_OBJDIR)\actchs.rc 4 2

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.CHT $(MSG_OBJDIR)\errcht.rc 4 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.CHT $(MSG_OBJDIR)\actcht.rc 4 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.CSY $(MSG_OBJDIR)\errcsy.rc 5 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.CSY $(MSG_OBJDIR)\actcsy.rc 5 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.DAN $(MSG_OBJDIR)\errdan.rc 6 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.DAN $(MSG_OBJDIR)\actdan.rc 6 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.DEU $(MSG_OBJDIR)\errdeu.rc 7 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.DEU $(MSG_OBJDIR)\actdeu.rc 7 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.ELL $(MSG_OBJDIR)\errell.rc 8 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.ELL $(MSG_OBJDIR)\actell.rc 8 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.ENU $(MSG_OBJDIR)\errenu.rc 9 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.ENU $(MSG_OBJDIR)\actenu.rc 9 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.ESN $(MSG_OBJDIR)\erresn.rc A 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.ESN $(MSG_OBJDIR)\actesn.rc A 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.EUQ $(MSG_OBJDIR)\erreuq.rc 2D 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.EUQ $(MSG_OBJDIR)\acteuq.rc 2D 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.FIN $(MSG_OBJDIR)\errfin.rc B 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.FIN $(MSG_OBJDIR)\actfin.rc B 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.FRA $(MSG_OBJDIR)\errfra.rc C 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.FRA $(MSG_OBJDIR)\actfra.rc C 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.HEB $(MSG_OBJDIR)\errheb.rc D 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.HEB $(MSG_OBJDIR)\actheb.rc D 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.HRV $(MSG_OBJDIR)\errhrv.rc 1A 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.HRV $(MSG_OBJDIR)\acthrv.rc 1A 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.HUN $(MSG_OBJDIR)\errhun.rc E 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.HUN $(MSG_OBJDIR)\acthun.rc E 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.ITA $(MSG_OBJDIR)\errita.rc 10 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.ITA $(MSG_OBJDIR)\actita.rc 10 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.JPN $(MSG_OBJDIR)\errjpn.rc 11 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.JPN $(MSG_OBJDIR)\actjpn.rc 11 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.KOR $(MSG_OBJDIR)\errkor.rc 12 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.KOR $(MSG_OBJDIR)\actkor.rc 12 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.NLD $(MSG_OBJDIR)\errnld.rc 13 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.NLD $(MSG_OBJDIR)\actnld.rc 13 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.NOR $(MSG_OBJDIR)\errnor.rc 14 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.NOR $(MSG_OBJDIR)\actnor.rc 14 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.PLK $(MSG_OBJDIR)\errplk.rc 15 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.PLK $(MSG_OBJDIR)\actplk.rc 15 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.PTB $(MSG_OBJDIR)\errptb.rc 16 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.PTB $(MSG_OBJDIR)\actptb.rc 16 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.PTG $(MSG_OBJDIR)\errptg.rc 16 2
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.PTG $(MSG_OBJDIR)\actptg.rc 16 2

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.ROM $(MSG_OBJDIR)\errrom.rc 18 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.ROM $(MSG_OBJDIR)\actrom.rc 18 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.RUS $(MSG_OBJDIR)\errrus.rc 19 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.RUS $(MSG_OBJDIR)\actrus.rc 19 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.SKY $(MSG_OBJDIR)\errsky.rc 1B 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.SKY $(MSG_OBJDIR)\actsky.rc 1B 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.SLV $(MSG_OBJDIR)\errslv.rc 24 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.SLV $(MSG_OBJDIR)\actslv.rc 24 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.SVE $(MSG_OBJDIR)\errsve.rc 1D 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.SVE $(MSG_OBJDIR)\actsve.rc 1D 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.THA $(MSG_OBJDIR)\errtha.rc 1E 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.THA $(MSG_OBJDIR)\acttha.rc 1E 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.TRK $(MSG_OBJDIR)\errtrk.rc 1F 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.TRK $(MSG_OBJDIR)\acttrk.rc 1F 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.VIT $(MSG_OBJDIR)\errvit.rc 2A 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.VIT $(MSG_OBJDIR)\actvit.rc 2A 1

        @if exist $(MSG_OBJDIR)\msimsg.rc del $(MSG_OBJDIR)\msimsg.rc
        copy $(MSG_DIR)\msimsg.rc + $(MSG_OBJDIR)\err???.rc + $(MSG_OBJDIR)\act???.rc $(MSG_OBJDIR)\msimsg.rc /b
        @del $(MSG_OBJDIR)\err???.rc
        @del $(MSG_OBJDIR)\act???.rc

        rc $(C_DEFINES) /I$(SDK_INC_PATH) /I$(INC_DIR) /I$(RES_OBJDIR) $(MSG_OBJDIR)\msimsg.rc

        $(LINK_NAME) $(MSG_OBJDIR)\msimsg.res /machine:$(MACHINE_TYPE) /DLL /NOENTRY /OUT:$(BUILD_DIR)\msimsg.dll
        @del $(MSG_OBJDIR)\msimsg.res
!if "$(MSI_BUILD_UNICODE)"=="1"      
        $(BINPLACE_CMD)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimsg\sources.inc ===
!INCLUDE ..\..\..\MsiMake.inc
TARGETNAME=
SOURCES=
TARGETTYPE=NOTARGET
NTTARGETFILE0=MsiMsgAll
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimsp\msimsp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msimsp.h
//
//--------------------------------------------------------------------------

#include <windows.h>

// resource string ids
#define IDS_Usage               1
#define IDS_CreatePatchError    2
#define IDS_Success             3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimsp\sources.inc ===
TARGETNAME=MsiMsp
SYNCHRONIZE_DRAIN=1
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_WINENTRY)

USE_LIBCMT=1

TARGETPATH=$(MSI_BUILD_TARGET)
TARGETLIBS=\
	$(SDK_LIB_PATH)\msi.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(BUILD_DIR)\patchwiz.lib

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(INCLUDES);..;$(INC_DIR);$(RES_OBJDIR);$(BUILD_COMMONDIR);..\..\patchwiz

SOURCES=..\msimsp.cpp \
	..\msimsp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msimsp\msimsp.cpp ===
//________________________________________________________________________________
//
// Required headers, #defines
//________________________________________________________________________________

#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>
#include "patchwiz.h"
#include "msimsp.h"

#include <stdio.h>
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE

#define W32
#define MSI
#define PATCHWIZ


//________________________________________________________________________________
//
// Constants and globals
//________________________________________________________________________________

HINSTANCE g_hInst;
HANDLE g_hStdOut;


//________________________________________________________________________________
//
// Function prototypes
//________________________________________________________________________________

void DisplayError(UINT iErrorStringID, const TCHAR* szErrorParam);
void DisplayError(UINT iErrorStringID, int iErrorParam);
void DisplayErrorCore(const TCHAR* szError, int cb);
void ErrorExit(UINT iError, UINT iErrorStringID, const TCHAR* szErrorParam);
void ErrorExit(UINT iError, UINT iErrorStringID, int iErrorParam);
void IfErrorExit(bool fError, UINT iErrorStringID, const TCHAR* szErrorParam);
BOOL SkipValue(TCHAR*& rpch);
TCHAR SkipWhiteSpace(TCHAR*& rpch);
void RemoveQuotes(const TCHAR* szOriginal, TCHAR* sz);

UINT CreatePatch(TCHAR* szPcpPath, TCHAR* szMspPath, TCHAR* szLogFile, TCHAR* szTempFolder,
					  BOOL fRemoveTempFolderIfPresent);


//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

extern "C" int __stdcall _tWinMain(HINSTANCE hInst, HINSTANCE/*hPrev*/, TCHAR* szCmdLine, int/*show*/)
{
	// set up globals
	g_hInst = hInst;
	
	g_hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
	if (g_hStdOut == INVALID_HANDLE_VALUE || ::GetFileType(g_hStdOut) == 0)
		g_hStdOut = 0;  // non-zero if stdout redirected or piped

	// Parse command line
	TCHAR szPcp[MAX_PATH]         = {0};
	TCHAR szMsp[MAX_PATH]         = {0};
	TCHAR szLog[MAX_PATH]         = {0};
	TCHAR szTempFolder[MAX_PATH]  = {0};
	BOOL  fCleanTempFolder        = TRUE;
	BOOL  fSuccessDialog          = FALSE;
	
	TCHAR chCmdNext;
	TCHAR* pchCmdLine = szCmdLine;
	SkipValue(pchCmdLine);   // skip over module name
	while ((chCmdNext = SkipWhiteSpace(pchCmdLine)) != 0)
	{
		if (chCmdNext == TEXT('/') || chCmdNext == TEXT('-'))
		{
			TCHAR szBuffer[MAX_PATH] = {0};
			TCHAR* szCmdOption = pchCmdLine++;  // save for error msg
			TCHAR chOption = (TCHAR)(*pchCmdLine++ | 0x20);
			chCmdNext = SkipWhiteSpace(pchCmdLine);
			TCHAR* szCmdData = pchCmdLine;  // save start of data
			switch(chOption)
			{
			case TEXT('s'):
				if (!SkipValue(pchCmdLine))
					ErrorExit(1, IDS_Usage, (const TCHAR*)0);
				RemoveQuotes(szCmdData, szPcp);
				break;
			case TEXT('p'):
				if (!SkipValue(pchCmdLine))
					ErrorExit(1, IDS_Usage, (const TCHAR*)0);
				RemoveQuotes(szCmdData, szMsp);
				break;
			case TEXT('l'):
				if (!SkipValue(pchCmdLine))
					ErrorExit(1, IDS_Usage, (const TCHAR*)0);
				RemoveQuotes(szCmdData, szLog);
				break;
			case TEXT('f'):
				if (!SkipValue(pchCmdLine))
					ErrorExit(1, IDS_Usage, (const TCHAR*)0);
				RemoveQuotes(szCmdData, szTempFolder);
				break;
			case TEXT('k'):
				fCleanTempFolder = FALSE;
				break;
			case TEXT('d'):
				fSuccessDialog = TRUE;
				break;
			case TEXT('?'):
				ErrorExit(0, IDS_Usage, (const TCHAR*)0);
				break;
			default:
				ErrorExit(1, IDS_Usage, (const TCHAR*)0);
				break;
			};
		}
		else
		{
			ErrorExit(1, IDS_Usage, (const TCHAR*)0);
		}
	} // while (command line tokens exist)

	// check for required arguments
	if(!*szPcp || !*szMsp)
		ErrorExit(1, IDS_Usage, (const TCHAR*)0);
	
	UINT uiRet = CreatePatch(szPcp, szMsp, szLog, szTempFolder, fCleanTempFolder);
	if(uiRet != ERROR_SUCCESS)
		ErrorExit(1, IDS_CreatePatchError, uiRet);
	else if(fSuccessDialog)
		DisplayError(IDS_Success, szMsp);

	return 0;
}

//_____________________________________________________________________________________________________
//
// command line parsing functions
//_____________________________________________________________________________________________________

TCHAR SkipWhiteSpace(TCHAR*& rpch)
{
	TCHAR ch;
	for (; (ch = *rpch) == TEXT(' ') || ch == TEXT('\t'); rpch++)
		;
	return ch;
}

BOOL SkipValue(TCHAR*& rpch)
{
	TCHAR ch = *rpch;
	if (ch == 0 || ch == TEXT('/') || ch == TEXT('-'))
		return FALSE;   // no value present

	TCHAR *pchSwitchInUnbalancedQuotes = NULL;

	for (; (ch = *rpch) != TEXT(' ') && ch != TEXT('\t') && ch != 0; rpch++)
	{       
		if (*rpch == TEXT('"'))
		{
			rpch++; // for '"'

			for (; (ch = *rpch) != TEXT('"') && ch != 0; rpch++)
			{
				if ((ch == TEXT('/') || ch == TEXT('-')) && (NULL == pchSwitchInUnbalancedQuotes))
				{
					pchSwitchInUnbalancedQuotes = rpch;
				}
			}
                    ;
            ch = *(++rpch);
            break;
		}
	}
	if (ch != 0)
	{
		*rpch++ = 0;
	}
	else
	{
		if (pchSwitchInUnbalancedQuotes)
			rpch=pchSwitchInUnbalancedQuotes;
	}
	return TRUE;
}

//______________________________________________________________________________________________
//
// RemoveQuotes function to strip surrounding quotation marks
//     "c:\temp\my files\testdb.msi" becomes c:\temp\my files\testdb.msi
//
//	Also acts as a string copy routine.
//______________________________________________________________________________________________

void RemoveQuotes(const TCHAR* szOriginal, TCHAR* sz)
{
	const TCHAR* pch = szOriginal;
	if (*pch == TEXT('"'))
		pch++;
	int iLen = _tcsclen(pch);
	for (int i = 0; i < iLen; i++, pch++)
		sz[i] = *pch;

	pch = szOriginal;
	if (*(pch + iLen) == TEXT('"'))
			sz[iLen-1] = TEXT('\0');
}


UINT CreatePatch(TCHAR* szPcpPath, TCHAR* szMspPath, TCHAR* szLogFile, TCHAR* szTempFolder,
					  BOOL fRemoveTempFolderIfPresent)
{
	return PATCHWIZ::UiCreatePatchPackage(szPcpPath, szMspPath, szLogFile, 0, szTempFolder, fRemoveTempFolderIfPresent);
}

//________________________________________________________________________________
//
// Error handling and Display functions:
//________________________________________________________________________________

void DisplayError(UINT iErrorStringID, const TCHAR* szErrorParam)
{
	TCHAR szMsgBuf[1024];
	if(0 == W32::LoadString(g_hInst, iErrorStringID, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR)))
		return;

	TCHAR szOutBuf[1124];
	int cbOut = 0;
	if(szErrorParam)
		cbOut = _stprintf(szOutBuf, TEXT("%s: %s\r\n"), szMsgBuf, szErrorParam);
	else
		cbOut = _stprintf(szOutBuf, TEXT("%s\r\n"), szMsgBuf);

	DisplayErrorCore(szOutBuf, cbOut);
}

void DisplayError(UINT iErrorStringID, int iErrorParam)
{
	TCHAR szMsgBuf[1024];
	if(0 == W32::LoadString(g_hInst, iErrorStringID, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR)))
		return;

	TCHAR szOutBuf[1124];
	int cbOut = _stprintf(szOutBuf, TEXT("%s: 0x%X\r\n"), szMsgBuf, iErrorParam);

	DisplayErrorCore(szOutBuf, cbOut);
}

void DisplayErrorCore(const TCHAR* szError, int cb)
{
	if (g_hStdOut)  // output redirected, suppress UI (unless output error)
	{
		// _stprintf returns char count, WriteFile wants byte count
		DWORD cbWritten;
		if (WriteFile(g_hStdOut, szError, cb*sizeof(TCHAR), &cbWritten, 0))
			return;
	}
	::MessageBox(0, szError, TEXT("MsiMsp"), MB_OK);
}


void ErrorExit(UINT iExitCode, UINT iErrorStringID, const TCHAR* szErrorParam)
{
	DisplayError(iErrorStringID, szErrorParam);
	W32::ExitProcess(iExitCode);
}

void ErrorExit(UINT iExitCode, UINT iErrorStringID, int iErrorParam)
{
	DisplayError(iErrorStringID, iErrorParam);
	W32::ExitProcess(iExitCode);
}

void IfErrorExit(bool fError, UINT iExitCode, UINT iErrorStringID, const TCHAR* szErrorParam)
{
	if(fError)
		ErrorExit(iExitCode, iErrorStringID, szErrorParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiregmv\cleanup.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cleanup.cpp
//
//--------------------------------------------------------------------------

#include "msiregmv.h"

const TCHAR szOldInstallerKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer");

const TCHAR szComponentsSubKey[] = TEXT("Components");
const TCHAR szFeaturesSubKey[] = TEXT("Features");
const TCHAR szLocalPackagesSubKey[] = TEXT("LocalPackages");
const TCHAR szPatchesSubKey[] = TEXT("Patches");
const TCHAR szProductsSubKey[] = TEXT("Products");
const TCHAR szUserDataSubKey[] = TEXT("UserData");

bool DeleteRegKeyAndSubKeys(HKEY hKey, const TCHAR *szSubKey)
{
	// open the subkey
	HKEY hSubKey;
	DWORD dwResult = ERROR_SUCCESS;
	dwResult = RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);
	if (dwResult == ERROR_ACCESS_DENIED)
	{
		AcquireTakeOwnershipPriv();

		if (ERROR_SUCCESS == RegOpenKeyEx(hKey, szSubKey, 0, WRITE_OWNER, &hSubKey))
		{
			char *pSD;
			GetSecureSecurityDescriptor(&pSD);
			dwResult = RegSetKeySecurity(hSubKey, OWNER_SECURITY_INFORMATION, pSD);
			RegCloseKey(hSubKey);
			if (ERROR_SUCCESS == (dwResult = RegOpenKeyEx(hKey, szSubKey, 0, WRITE_DAC, &hSubKey)))
			{
				dwResult = RegSetKeySecurity(hSubKey, DACL_SECURITY_INFORMATION, pSD);
				RegCloseKey(hSubKey);
			}
		}
		dwResult = RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);
	}
	if (ERROR_SUCCESS != dwResult)
	{
		if (dwResult == ERROR_FILE_NOT_FOUND)
			return true;
		DEBUGMSG2("Error: Unable to open %s subkey for delete. Error: %d", szSubKey, dwResult);
 		return false;
	}

   	DWORD cchMaxKeyLen = 0;
	DWORD cSubKeys = 0;
    if (ERROR_SUCCESS != (RegQueryInfoKey(hSubKey, NULL, NULL, 0, 
						  &cSubKeys, &cchMaxKeyLen, NULL, NULL, NULL, NULL, NULL, NULL)))
	{
		DEBUGMSG2("Error: Unable to query %s subkey for delete. Error: %d", szSubKey, dwResult);
		RegCloseKey(hSubKey);
		return false;
	}

	if (cSubKeys > 0)
	{
		// on NT, RegQueryInfoKey does not include terminating null when reporting subkey lingth.
		TCHAR *szKey = new TCHAR[++cchMaxKeyLen];
		if (!szKey) 
		{
			DEBUGMSG("Error: Out of memory.");
			RegCloseKey(hSubKey);
			return false;
		}

		DWORD dwIndex=0;
		while (1)
		{
			DWORD cchLen = cchMaxKeyLen;
			LONG lResult = RegEnumKeyEx(hSubKey, dwIndex++, szKey, 
										&cchLen, 0, NULL, NULL, NULL);
			if (lResult == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else if (lResult != ERROR_SUCCESS)
			{
				DEBUGMSG2("Error: Unable to enumerate subkeys of %s for delete. Error: %d", szSubKey, dwResult);
				RegCloseKey(hSubKey);
				delete[] szKey;
				return false;
			}
	 
			if (!DeleteRegKeyAndSubKeys(hSubKey, szKey))
			{
				RegCloseKey(hSubKey);
				delete[] szKey;
				return false;
			}
			else
			{
				// every time we delete a reg key, we're forced to restart the 
				// enumeration or we'll miss keys.
				dwIndex = 0;
			}
		}
		delete[] szKey;
	}
	RegCloseKey(hSubKey);
	dwResult = RegDeleteKey(hKey, szSubKey);

	return true;
}



/////////////////////////
// Read component information from the Installer\Components key and places the Product,
// Component, Path, and Permanent bit into the temporary table for later query.
// returns ERROR_SUCCESS, ERROR_OUTOFMEMORY or ERROR_FUNCTION_FAILED
void CleanupOnSuccess(MSIHANDLE hDatabase)
{
	// create query for files that should be cleaned up on success . If this fails
	// we'll just orphan the files
	PMSIHANDLE hCleanUpTable;
	if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT `File` FROM `CleanupFile` WHERE `OnSuccess`=1"), &hCleanUpTable) &&
		ERROR_SUCCESS == MsiViewExecute(hCleanUpTable, 0))
	{
		PMSIHANDLE hFileRec;
		while (ERROR_SUCCESS == MsiViewFetch(hCleanUpTable, &hFileRec))
		{
			TCHAR rgchFile[MAX_PATH];
			DWORD cchFile = MAX_PATH;
			if (ERROR_SUCCESS == MsiRecordGetString(hFileRec, 1, rgchFile, &cchFile))
			{
				DEBUGMSG1("Deleting File: %s", rgchFile);
				DeleteFile(rgchFile);
			}
		}
	}

	// create query for directories that should be cleaned up on success . If this fails
	// we'll just orphan the directory
    if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT `File` FROM `CleanupFile` WHERE `OnSuccess`>1 ORDER BY `OnSuccess`"), &hCleanUpTable) &&
		ERROR_SUCCESS == MsiViewExecute(hCleanUpTable, 0))
	{
		PMSIHANDLE hFileRec;
		while (ERROR_SUCCESS == MsiViewFetch(hCleanUpTable, &hFileRec))
		{
			TCHAR rgchFile[MAX_PATH];
			DWORD cchFile = MAX_PATH;
			if (ERROR_SUCCESS == MsiRecordGetString(hFileRec, 1, rgchFile, &cchFile))
			{
				DEBUGMSG1("Removing directory: %s", rgchFile);
				RemoveDirectory(rgchFile);
			}
		}
	}

	// delete data
	DWORD dwResult; 
	HKEY hKey;
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldInstallerKey, 0, KEY_ALL_ACCESS, &hKey))
	{
		DeleteRegKeyAndSubKeys(hKey, szComponentsSubKey);
		DeleteRegKeyAndSubKeys(hKey, szFeaturesSubKey);
		DeleteRegKeyAndSubKeys(hKey, szLocalPackagesSubKey);
		DeleteRegKeyAndSubKeys(hKey, szPatchesSubKey);

		// its unbelievable, but admins don't always have access to the feature usage key
		{
		}

		DeleteRegKeyAndSubKeys(hKey, szProductsSubKey);

		RegCloseKey(hKey);
	}
}


void CleanupOnFailure(MSIHANDLE hDatabase)
{
	// create query for files that should be cleaned up on failure . If this fails
	// we'll just orphan the files
	PMSIHANDLE hCleanUpTable;
	if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT `File` FROM `CleanupFile` WHERE `OnSuccess`=0"), &hCleanUpTable) &&
		ERROR_SUCCESS == MsiViewExecute(hCleanUpTable, 0))
	{
		PMSIHANDLE hFileRec;
		while (ERROR_SUCCESS == MsiViewFetch(hCleanUpTable, &hFileRec))
		{
			TCHAR rgchFile[MAX_PATH];
			DWORD cchFile = MAX_PATH;
			if (ERROR_SUCCESS == MsiRecordGetString(hFileRec, 1, rgchFile, &cchFile))
			{
				DeleteFile(rgchFile);
			}
		}
	}

	// delete data
	HKEY hKey;
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldInstallerKey, 0, KEY_ALL_ACCESS, &hKey))
	{
		DeleteRegKeyAndSubKeys(hKey, szUserDataSubKey);

		RegCloseKey(hKey);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiregmv\migsecur.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       migsecur.cpp
//
//--------------------------------------------------------------------------

#include "msiregmv.h"

PSID g_AdminSID = NULL;
PSID g_SystemSID = NULL;

DWORD GetAdminSID(PSID* pSID)
{
    SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
	
	if (!pSID)
		return ERROR_INVALID_PARAMETER;
	
    *pSID = NULL;
	if (!g_AdminSID)
	{
		if (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &g_AdminSID))
			return GetLastError();
	}
	*pSID = g_AdminSID;
    return ERROR_SUCCESS;
}

DWORD GetLocalSystemSID(PSID* pSID)
{
	*pSID = NULL;
    SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
	if (!g_SystemSID)
	{
        if (!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(g_SystemSID)))
            return GetLastError();
    }
    *pSID = g_SystemSID;
    return ERROR_SUCCESS;
}


////
// FIsOwnerSystemOrAdmin -- return whether owner sid is a LocalSystem
// sid or Admin sid
bool FIsOwnerSystemOrAdmin(PSECURITY_DESCRIPTOR rgchSD)
{
	if (g_fWin9X)
		return true;

    // grab owner SID from the security descriptor
    DWORD dwRet;
    PSID psidOwner;
    BOOL fDefaulted;
    if (!GetSecurityDescriptorOwner(rgchSD, &psidOwner, &fDefaulted))
    {
        // ** some form of error handling
        return false;
    }

    // if there is no SD owner, return false
    if (!psidOwner)
        return false;

    // compare SID to system & admin
    PSID psidLocalSystem;
    if (ERROR_SUCCESS != (dwRet = GetLocalSystemSID(&psidLocalSystem)))
    {
        // ** some form of error handling
		return false;    
	}

    if (!EqualSid(psidOwner, psidLocalSystem))
    {
        // not owned by system, (continue by checking Admin)
        PSID psidAdmin;
        if (ERROR_SUCCESS != (dwRet = GetAdminSID(&psidAdmin)))
        {
            // ** some form of error handling
			return false;
        }

        // check for admin ownership
        if (!EqualSid(psidOwner, psidAdmin))
		{
			// don't TRUST! neither admin or system
            return false; 
		}
    }
    return true;
}

bool FIsKeyLocalSystemOrAdminOwned(HKEY hKey)
{
	if (g_fWin9X)
		return true;

	// reading just the owner doesn't take very much space
	DWORD cbSD = 64;
    unsigned char *pchSD = new unsigned char[cbSD];
	if (!pchSD)
		return false;

    LONG dwRet = RegGetKeySecurity(hKey, OWNER_SECURITY_INFORMATION, (PSECURITY_DESCRIPTOR)pchSD, &cbSD);
    if (ERROR_SUCCESS != dwRet)
    {
        if (ERROR_INSUFFICIENT_BUFFER == dwRet)
        {
            delete[] pchSD;
			pchSD = new unsigned char[cbSD];
			if (!pchSD)
				return false;
            dwRet = RegGetKeySecurity(hKey, OWNER_SECURITY_INFORMATION, (PSECURITY_DESCRIPTOR)pchSD, &cbSD);
        }

        if (ERROR_SUCCESS != dwRet)
        {
			delete[] pchSD;
            return false;
        }
    }

    bool fRet = FIsOwnerSystemOrAdmin(pchSD);
	delete[] pchSD;
	return fRet;
}


void GetStringSID(PISID pSID, TCHAR* szSID)
// Converts a binary SID into its string form (S-n-...). 
// szSID should be of length cchMaxSID
{
	TCHAR Buffer[cchMaxSID];
	
	StringCchPrintf(Buffer, sizeof(Buffer)/sizeof(TCHAR), TEXT("S-%u-"), pSID->Revision);

	lstrcpy(szSID, Buffer);

	if ((pSID->IdentifierAuthority.Value[0] != 0) ||
		(pSID->IdentifierAuthority.Value[1] != 0))
	{
		StringCchPrintf(Buffer, sizeof(Buffer)/sizeof(TCHAR), TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
					(USHORT)pSID->IdentifierAuthority.Value[0],
					(USHORT)pSID->IdentifierAuthority.Value[1],
                    (USHORT)pSID->IdentifierAuthority.Value[2],
                    (USHORT)pSID->IdentifierAuthority.Value[3],
                    (USHORT)pSID->IdentifierAuthority.Value[4],
                    (USHORT)pSID->IdentifierAuthority.Value[5] );
		lstrcat(szSID, Buffer);
	}
	else
	{
        ULONG Tmp = (ULONG)pSID->IdentifierAuthority.Value[5]          +
              (ULONG)(pSID->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(pSID->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(pSID->IdentifierAuthority.Value[2] << 24);
        StringCchPrintf(Buffer, sizeof(Buffer)/sizeof(TCHAR), TEXT("%lu"), Tmp);
		lstrcat(szSID, Buffer);
    }

    for (int i=0;i<pSID->SubAuthorityCount ;i++ ) {
        StringCchPrintf(Buffer, sizeof(Buffer)/sizeof(TCHAR), TEXT("-%lu"), pSID->SubAuthority[i]);
		lstrcat(szSID, Buffer);
    }
}

DWORD GetToken(HANDLE* hToken)
{
	DWORD dwResult = ERROR_SUCCESS;
	if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, hToken))
	{
		// if the thread has no access token then use the process's access token
    	if (ERROR_NO_TOKEN == (dwResult = GetLastError()))
		{
			dwResult = ERROR_SUCCESS;
			if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, hToken))
				dwResult = GetLastError();
		}
	}
	return dwResult;
}

// retrieves the binary form of the current user SID. Caller is responsible for
// releasing *rgSID
DWORD GetCurrentUserSID(unsigned char** rgSID)
{
#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

	HANDLE hToken;
	*rgSID = NULL;

	if (ERROR_SUCCESS != GetToken(&hToken))
		return ERROR_FUNCTION_FAILED;

	unsigned char TokenUserInfo[SIZE_OF_TOKEN_INFORMATION];
	DWORD ReturnLength = 0;;
	BOOL fRes = GetTokenInformation(hToken, TokenUser, reinterpret_cast<void *>(&TokenUserInfo),
									sizeof(TokenUserInfo), &ReturnLength);

	CloseHandle(hToken);

	if(fRes == FALSE)
	{
		DWORD dwRet = GetLastError();
		return dwRet;
	}

	PISID piSid = (PISID)((PTOKEN_USER)TokenUserInfo)->User.Sid;
	if (IsValidSid(piSid))
	{
		DWORD cbSid = GetLengthSid(piSid);
		*rgSID = new unsigned char[cbSid];
		if (!*rgSID)
			return ERROR_FUNCTION_FAILED;

		if (CopySid(cbSid, *rgSID, piSid))
			return ERROR_SUCCESS;
		else
		{
			delete[] *rgSID;
			*rgSID = NULL;
			return GetLastError();
		}
	}
	return ERROR_FUNCTION_FAILED;
}

DWORD GetCurrentUserStringSID(TCHAR* szSID)
// get string form of SID for current user: caller does NOT need to impersonate
{
	if (!szSID)
		return ERROR_FUNCTION_FAILED;

	if (g_fWin9X)
	{
		lstrcpy(szSID, szCommonUserSID);
		return ERROR_SUCCESS;
	}

	unsigned char* pSID = NULL;
	DWORD dwRet = ERROR_SUCCESS;

	if (ERROR_SUCCESS == (dwRet = GetCurrentUserSID(&pSID)))
	{
		if (pSID)
		{
			GetStringSID(reinterpret_cast<SID*>(pSID), szSID);
			delete[] pSID;
		}
		else
			dwRet = ERROR_FUNCTION_FAILED;
	}
	return dwRet;
}



////
// Returns true if the process is a system process. Caches result.
bool RunningAsLocalSystem()
{
	static int iRet = -1;

	if(iRet != -1)
		return (iRet != 0);
	
	unsigned char *pSID = NULL;
	if (ERROR_SUCCESS == GetCurrentUserSID(&pSID))
	{
		if (pSID)
		{
			PSID pSystemSID = NULL;
			if (ERROR_SUCCESS != GetLocalSystemSID(&pSystemSID))
				return false;
	
			if (pSystemSID)
			{
				iRet = 0;
				if (EqualSid(pSID, pSystemSID))
					iRet = 1;
				delete[] pSID;
				return (iRet != 0);
			}
			delete[] pSID;
		}
	}
	return false;
}


enum sdSecurityDescriptor
{
    sdEveryoneUpdate,
    sdSecure,
};

DWORD GetSecurityDescriptor(char* rgchStaticSD, DWORD& cbStaticSD, sdSecurityDescriptor sdType)
{
    class CSIDPointer
    {
     public:
        CSIDPointer(SID* pi) : m_pi(pi){}
        ~CSIDPointer() {if (m_pi) FreeSid(m_pi);} // release ref count at destruction
        operator SID*() {return m_pi;}     // returns pointer, no ref count change
        SID** operator &() {if (m_pi) { FreeSid(m_pi); m_pi=NULL; } return &m_pi;}
     private:
        SID* m_pi;
    };

    struct Security
    {
        CSIDPointer pSID;
        DWORD dwAccessMask;
        Security() : pSID(0), dwAccessMask(0) {}
    } rgchSecurity[3];

    int cSecurity = 0;

    // Initialize the SIDs we'll need

    SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaWorld   = SECURITY_WORLD_SID_AUTHORITY;

    const SID* psidOwner;

    switch (sdType)
    {
        case sdSecure:
        {
            if ((!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[0].pSID))) ||
                 (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[1].pSID))) ||
                 (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[2].pSID))))
            {
                return GetLastError();
            }
			// if not running as system, system can't be the owner of the object. 
            psidOwner = rgchSecurity[RunningAsLocalSystem() ? 0 : 2].pSID;
            rgchSecurity[0].dwAccessMask = GENERIC_ALL;
            rgchSecurity[1].dwAccessMask = GENERIC_READ|GENERIC_EXECUTE|READ_CONTROL|SYNCHRONIZE; //?? Is this correct?
            rgchSecurity[2].dwAccessMask = GENERIC_ALL;
            cSecurity = 3;
            break;
        }
		case sdEveryoneUpdate:
		{
			if (((!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[0].pSID)))) ||
			   (!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[1].pSID))) ||
               (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[2].pSID))))
			{
				return GetLastError();
			}
			// if not running as system, system can't be the owner of the object. 
			psidOwner = rgchSecurity[RunningAsLocalSystem() ? 1 : 2].pSID;
			rgchSecurity[0].dwAccessMask = (STANDARD_RIGHTS_ALL|SPECIFIC_RIGHTS_ALL) & ~(WRITE_DAC|WRITE_OWNER|DELETE);			
			rgchSecurity[1].dwAccessMask = GENERIC_ALL;
			rgchSecurity[2].dwAccessMask = GENERIC_ALL;
			cSecurity = 3;
			break;
		}
		default:
		{
			return ERROR_INVALID_PARAMETER;
		}
    }

    // Initialize our ACL

    const int cbAce = sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD); // subtract ACE.SidStart from the size
    int cbAcl = sizeof (ACL);

    for (int c=0; c < cSecurity; c++)
        cbAcl += (GetLengthSid(rgchSecurity[c].pSID) + cbAce);

    char *rgchACL = new char[cbAcl];
    
    if (!InitializeAcl ((ACL*)rgchACL, cbAcl, ACL_REVISION))
	{
		delete[] rgchACL;
        return GetLastError();
	}

    // Add an access-allowed ACE for each of our SIDs

    for (c=0; c < cSecurity; c++)
    {
        if (!AddAccessAllowedAce((ACL*)rgchACL, ACL_REVISION, rgchSecurity[c].dwAccessMask, rgchSecurity[c].pSID))
		{
			delete[] rgchACL;
            return GetLastError();
		}

        ACCESS_ALLOWED_ACE* pAce;
        if (!GetAce((ACL*)(char*)rgchACL, c, (void**)&pAce))
		{
			delete[] rgchACL;
            return GetLastError();
		}

        pAce->Header.AceFlags = CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE;
    }

    // Initialize our security descriptor,throw the ACL into it, and set the owner
    SECURITY_DESCRIPTOR sd;

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) ||
        (!SetSecurityDescriptorDacl(&sd, TRUE, (ACL*)rgchACL, FALSE)) ||
        (!SetSecurityDescriptorOwner(&sd, (PSID)psidOwner, FALSE)))
    {
		delete[] rgchACL;
        return GetLastError();
    }

    DWORD cbSD = GetSecurityDescriptorLength(&sd);
    if (cbStaticSD < cbSD)
    {
		delete[] rgchACL;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    DWORD dwRet = MakeSelfRelativeSD(&sd, (char*)rgchStaticSD, &cbStaticSD) ? ERROR_SUCCESS: GetLastError();
	delete[] rgchACL;

    return dwRet;
}


DWORD GetSecureSecurityDescriptor(char** pSecurityDescriptor)
{
	if (g_fWin9X)
	{
		*pSecurityDescriptor = NULL;
		return ERROR_SUCCESS;
	}
    static bool fDescriptorSet = false;
    static char rgchStaticSD[256];
    DWORD cbStaticSD = sizeof(rgchStaticSD);

    DWORD dwRet = ERROR_SUCCESS;

    if (!fDescriptorSet)
    {
        if (ERROR_SUCCESS != (dwRet = GetSecurityDescriptor(rgchStaticSD, cbStaticSD, sdSecure)))
            return dwRet;

        fDescriptorSet = true;
    }

    *pSecurityDescriptor = rgchStaticSD;
    return ERROR_SUCCESS;
}


DWORD GetEveryoneUpdateSecurityDescriptor(char** pSecurityDescriptor)
{
	if (g_fWin9X)
	{
		*pSecurityDescriptor = NULL;
		return ERROR_SUCCESS;
	}

    static bool fDescriptorSet = false;
    static char rgchStaticSD[256];
    DWORD cbStaticSD = sizeof(rgchStaticSD);

    DWORD dwRet = ERROR_SUCCESS;

    if (!fDescriptorSet)
    {
        if (ERROR_SUCCESS != (dwRet = GetSecurityDescriptor(rgchStaticSD, cbStaticSD, sdEveryoneUpdate)))
            return dwRet;

        fDescriptorSet = true;
    }

    *pSecurityDescriptor = rgchStaticSD;
    return ERROR_SUCCESS;
}


////
// temp file name generation algorithm is based on code from MsiPath object.
DWORD GenerateSecureTempFile(TCHAR* szDirectory, const TCHAR rgchExtension[5], 
							 SECURITY_ATTRIBUTES *pSA, TCHAR rgchFileName[13], HANDLE &hFile)
{
	if(lstrlen(szDirectory) > MAX_PATH)
	{
		return ERROR_FUNCTION_FAILED;
	}

	int cDigits = 8; // number of hex digits to use in file name
	static bool fInitialized = false;
	static unsigned int uiUniqueStart;
	// Might be a chance for two threads to get in here, we're not going to be worried
	// about that. It would get intialized twice
	if (!fInitialized)
	{
		uiUniqueStart = GetTickCount();
		fInitialized = true;
	}

	hFile = INVALID_HANDLE_VALUE;
		
	unsigned int uiUniqueId = uiUniqueStart++;
	unsigned int cPerms = 0xFFFFFFFF; // number of possible file names to try (-1)
	
	for(unsigned int i = 0; i <= cPerms; i++)
	{
		wsprintf(rgchFileName, TEXT("%x"),uiUniqueId);
		lstrcat(rgchFileName, rgchExtension);

		TCHAR rgchBuffer[MAX_PATH];
		HRESULT hr;

		hr = StringCchCopy(rgchBuffer, sizeof(rgchBuffer)/sizeof(rgchBuffer[0]), szDirectory);
		if ( SUCCEEDED(hr) ) 
			hr = StringCchCat(rgchBuffer, sizeof(rgchBuffer)/sizeof(rgchBuffer[0]), rgchFileName);

		if ( ! SUCCEEDED(hr) )
			return ERROR_BAD_PATHNAME;

		DWORD iError = 0;
		if (INVALID_HANDLE_VALUE == (hFile = CreateFile(rgchBuffer, GENERIC_WRITE, FILE_SHARE_READ, 
									pSA, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0)))
		{
			iError = GetLastError();

			if(iError != ERROR_ALREADY_EXISTS)
				break;
		}
		else
			break;

		// increment number portion of name - if it currently equals cPerms, it is time to
		// wrap number around to 0
		uiUniqueStart++;
		if(uiUniqueId == cPerms)
			uiUniqueId = 0;
		else
			uiUniqueId++;
	}

		
	if(hFile == INVALID_HANDLE_VALUE)
	{
		return ERROR_FUNCTION_FAILED;
 	}
	
	return ERROR_SUCCESS;
}


BOOL CopyOpenedFile(HANDLE hSourceFile, HANDLE hDestFile)
{
	const int cbCopyBufferSize = 32*1024;
	static unsigned char rgbCopyBuffer[cbCopyBufferSize];

	for(;;)
	{
		unsigned long cbToCopy = cbCopyBufferSize;

		DWORD cbRead = 0;
		if (!ReadFile(hSourceFile, rgbCopyBuffer, cbToCopy, &cbRead, 0))
			return FALSE; 
		
		if (cbRead)
		{
			DWORD cbWritten;
			if (!WriteFile(hDestFile, rgbCopyBuffer, cbRead, &cbWritten, 0))
				return FALSE;

			if (cbWritten != cbRead)
				return FALSE;
		}
		else 
			break;
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Creates a reg key with a secure ACL and verifies that any existing key
// is trusted (by checking Admin or System ownership). If it is not 
// trusted, the key and all subkeys are replaced with a new secure
// empty key.
DWORD CreateSecureRegKey(HKEY hParent, LPCTSTR szNewKey, SECURITY_ATTRIBUTES *sa, HKEY* hResKey)
{
	DWORD dwDisposition = 0;
	DWORD dwResult = ERROR_SUCCESS;
	if (ERROR_SUCCESS != (dwResult = RegCreateKeyEx(hParent, szNewKey, 0, NULL, 0, KEY_ALL_ACCESS, (g_fWin9X ? NULL : sa), hResKey, &dwDisposition)))
	{
		DEBUGMSG2("Error: Unable to create secure key %s. Result: %d.", szNewKey, dwResult);
		return dwResult;
	}

	if (dwDisposition == REG_OPENED_EXISTING_KEY)
	{
		// ACL on this key must be system or admin or it can't be trusted
		if (!FIsKeyLocalSystemOrAdminOwned(*hResKey))
		{
			DEBUGMSG1("Existing key %s not owned by Admin or System. Deleting.", szNewKey);

			RegCloseKey(*hResKey);
			if (!DeleteRegKeyAndSubKeys(hParent, szNewKey))
			{
				DEBUGMSG2("Error: Unable to delete insecure key %s. Result: %d.", szNewKey, dwResult);
				return ERROR_FUNCTION_FAILED;
			}

			if (ERROR_SUCCESS != (dwResult = RegCreateKeyEx(hParent, szNewKey, 0, NULL, 0, KEY_ALL_ACCESS, sa, hResKey, NULL)))
			{
				DEBUGMSG2("Error: Unable to create secure key %s. Result: %d.", szNewKey, dwResult);
				return dwResult;
			}
		}
	}
	return ERROR_SUCCESS;
}

////
// Token privilege functions

bool AcquireTokenPriv(LPCTSTR szPrivName)
{
	bool fAcquired = false;
	HANDLE hToken;
	TOKEN_PRIVILEGES tkp;
	if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
	{
		// the the LUID for the shutdown privilege
		if (LookupPrivilegeValue(0, szPrivName, &tkp.Privileges[0].Luid))
		{
			tkp.PrivilegeCount = 1; // one privilege to set
			tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

			AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) 0, 0);
			fAcquired = true;
		}
		CloseHandle(hToken);
	}
	return fAcquired;
}

void AcquireTakeOwnershipPriv()
{
	if (g_fWin9X)
		return;

	static bool fAcquired = false;

	if (fAcquired)
		return;

	fAcquired = AcquireTokenPriv(SE_TAKE_OWNERSHIP_NAME);
}

void AcquireBackupPriv()
{
	if (g_fWin9X)
		return;
	
	static bool fAcquired = false;

	if (fAcquired)
		return;

	fAcquired = AcquireTokenPriv(SE_BACKUP_NAME);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiregmv\msiregmv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msiregmv.cpp
//
//--------------------------------------------------------------------------

#include "msiregmv.h"
#include <objbase.h>
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include <strsafe.h>
#include "MsiQuery.h"
#include <strsafe.h>

extern bool g_fWin9X = true;

////
// general registry paths
const TCHAR szOldInstallerKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer");


////
// Win9X migration information
const TCHAR szWin9XDummyPath[] = TEXT("Win9X");

///////////////////////////////////////////////////////////////////////
// new/delete overloads to use system heaps
void * operator new(size_t cb)
{
	return HeapAlloc(GetProcessHeap(), 0, cb);
}

void operator delete(void *pv)
{
	if (pv == 0)
			return;
	HeapFree(GetProcessHeap(), 0, pv);
}

void DebugOut(bool fDebugOut, LPCTSTR str, ...)
{
	TCHAR strbuf[1027] = TEXT("");
	HANDLE hStdOut;
	int cb;
	va_list list; 
	va_start(list, str); 
	StringCchVPrintf(strbuf, 1024, str, list);
	va_end(list);
	StringCchCat(strbuf, 1027, TEXT("\r\n"));
	if (fDebugOut)
		OutputDebugString(strbuf);
	
	hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if (hStdOut && hStdOut != INVALID_HANDLE_VALUE)
	{
#ifdef UNICODE
	    char ansibuf[1024] = "";
	    cb = WideCharToMultiByte(CP_ACP, 0, strbuf, lstrlen(strbuf), ansibuf, 1024, NULL, NULL);
	    // if there is an error converting, we won't write anything to the file.
	    if (cb && (cb <= sizeof(ansibuf)))
	    {
			DWORD dwWritten = 0;
			WriteFile(hStdOut, ansibuf, cb, &dwWritten, NULL);
	    }
#else
		DWORD dwWritten = 0;
		WriteFile(hStdOut, strbuf, lstrlen(strbuf), &dwWritten, NULL);
#endif
	}
}

///////////////////////////////////////////////////////////////////////
// 
void MakeRegEmergencyBackup()
{
	AcquireBackupPriv();
	HKEY hKey;
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldInstallerKeyName, 0, KEY_READ, &hKey))
	{
		SECURITY_ATTRIBUTES sa;
		sa.nLength        = sizeof(sa);
		sa.bInheritHandle = FALSE;
		if (!g_fWin9X)
			GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

		TCHAR rgchBackupFile[MAX_PATH+12];
		DWORD cch = GetWindowsDirectory(rgchBackupFile, MAX_PATH);
		if (cch && (cch < MAX_PATH))
		{
			lstrcat(rgchBackupFile, TEXT("\\msireg.bak"));
	
			RegSaveKey(hKey, rgchBackupFile, (g_fWin9X ? NULL : &sa));
		}
		RegCloseKey(hKey);
	}
}

#ifdef UNICODE
void MigrationPerMachine();
#endif // UNICODE

///////////////////////////////////////////////////////////////////////
// MsiRegMv.Exe - migrates Darwin 1.0/1.1 registration data into
// Darwin 1.5 format. Moves registration data and copies cached files
// as necessary.
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	PMSIHANDLE hDatabase;

	bool fSaveDB = false;
	bool fMakeBackup = false;
	bool fCleanup = true;
	int iExplicitFile = -1;

	NOTEMSG("MSI 2.0 Migration Utility.");
	NOTEMSG("Copyright (c) 2000 Microsoft Corp.");
	NOTEMSG("");

	if (!CheckWinVersion())
	{
		NOTEMSG("Unable to determine platform type.");
		return -1;
	}

	// do some simple command line processing. Ship builds do not have command line options
	int argc = 0;
	LPTSTR argv[255];
#ifdef DEBUG
	LPTSTR szCommandLine = GetCommandLine();
	while (*szCommandLine)
	{
		argv[argc++] = szCommandLine;

		if (*(szCommandLine++) == TEXT('\"'))
		{
			while (*szCommandLine && (*szCommandLine != TEXT('\"')))
				szCommandLine++;
		}
		else
		{
			while (*szCommandLine && *szCommandLine != TEXT(' '))
				szCommandLine++;
		}
		if (*szCommandLine)
		{
			*(szCommandLine++) = 0;
			while (*szCommandLine && *szCommandLine == TEXT(' '))
				szCommandLine++;
		}
		if (argc == 255)
			break;
	}

	for (int i=1; i < argc; i++)
	{
		if (2 == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, TEXT("-savedb"), -1, argv[i], -1))
		{
			fSaveDB = true;
		}
		else if (2 == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, TEXT("-noclean"), -1, argv[i], -1))
		{
			fCleanup = false;
		}
    		else if (2 == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, TEXT("-preclean"), -1, argv[i], -1))
		{
			CleanupOnFailure(hDatabase);
		}
    		else if (2 == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, TEXT("-backup"), -1, argv[i], -1))
		{
			fMakeBackup = true;
		}
		else if (2 == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, TEXT("-database"), -1, argv[i], -1) && i < argc-1)
		{
			iExplicitFile = ++i;
		}
		else
		{
			NOTEMSG("Syntax:");
			NOTEMSG("   -savedb            (to not delete database on exit)");
			NOTEMSG("   -backup            (to make a backup of the registry)");
			NOTEMSG("   -noclean           (to not clean up unused registration)");
			NOTEMSG("   -preclean          (to delete new keys before migrating)");
			NOTEMSG("   -database <file>   (to specify a database file name)");
			return -1;
		}
	}
#endif

	// if called during NT setup, do NOT perform any migration if upgrading from Win9X.
	// This can be detected by looking for our Installer key. In a Win9X upgrade, the key
	// won't exist yet. (And if it doesn't exist, there's no point in doing any migration
	// anyway.)
	HKEY hKey;
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\Setup"), 0, KEY_QUERY_VALUE, &hKey))
	{
		DWORD dwData;
		DWORD cbDataSize = sizeof(dwData);
		if ((ERROR_SUCCESS == RegQueryValueEx(hKey, TEXT("SystemSetupInProgress"), 0, NULL, reinterpret_cast<unsigned char *>(&dwData), &cbDataSize)) &&
			(dwData == 1))
		{
			HKEY hInstallerKey = 0;
			if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldInstallerKeyName, 0, KEY_QUERY_VALUE, &hInstallerKey))
			{
				RegCloseKey(hKey);
				return 0;
			}
			RegCloseKey(hInstallerKey);
		}
		RegCloseKey(hKey);
	}
	

	if (fMakeBackup)
		MakeRegEmergencyBackup();

	DWORD dwResult = ERROR_SUCCESS;

	// get a temp path for the migration database
	DWORD cchTempPath = MAX_PATH;
	TCHAR szTempPath[MAX_PATH];
	cchTempPath = ::GetTempPath(cchTempPath, szTempPath);

	// verify API succeeded with the provided buffer and ensure NULL termination
	if (!cchTempPath || cchTempPath > MAX_PATH-1)
		return ERROR_FUNCTION_FAILED;
	szTempPath[MAX_PATH-1]= TEXT('\0');

	// get a temp filename for the migration database
	TCHAR szTempFilename[MAX_PATH] = TEXT("");
	if (iExplicitFile != -1)
	{
		StringCchCopy(szTempFilename, MAX_PATH, szTempPath);
		if (FAILED(StringCchCat(szTempFilename, MAX_PATH, argv[iExplicitFile])))
			return ERROR_FUNCTION_FAILED;
	}
	else
	{
		UINT iResult = ::GetTempFileName(szTempPath, _T("MSI"), 0, szTempFilename);
	}

	// read all existing product registration data into the temporary database. In debug
	// builds or in multi-phase migration (Win9X upgrades for example), this database can
	// be saved at any point (it contains the complete state of migration). But normally
	// the database is only temporary for msiregmv.
	if (ERROR_SUCCESS != ReadProductRegistrationDataIntoDatabase(szTempFilename, *&hDatabase, /*fReadHKCUAsSystem=*/false))
		return ERROR_FUNCTION_FAILED;

	// write the data back into the registry in the new format
	if (ERROR_SUCCESS != WriteProductRegistrationDataFromDatabase(hDatabase, /*fMigrateSharedDLL=*/true, /*fMigratePatches=*/true))
		return ERROR_FUNCTION_FAILED;

	// finall cleanup/commit of all changes
	if (ERROR_SUCCESS == dwResult)
	{
    	if (fCleanup)
			CleanupOnSuccess(hDatabase);
	}
	else
	{
		// remove all newly migrated data and files
		if (fCleanup)
			CleanupOnFailure(hDatabase);
	}

 	if (fSaveDB)
	{
		DEBUGMSG1("Saved Database is: %s.", szTempFilename);
		::MsiDatabaseCommit(hDatabase);
	}

#ifdef UNICODE
	// Hack to fix bug 487742. See function definition for more comments.
	MigrationPerMachine();
#endif // UNICODE

	return 0;
}


#ifdef UNICODE

// Hack to fix bug 487742. When migrating MSI configuration data from win9x to
// NT, permachine installed application cached package location is not migrated,
// so here we try to migrate it after fact.

const TCHAR szSystemUserProductList[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\S-1-5-18\\Products");
const TCHAR szPerMachineInstallKey[] = TEXT("Software\\Classes\\Installer\\Products");
const TCHAR szInstallProperties[] = TEXT("InstallProperties");
const TCHAR szLocalPackageValueName[] = TEXT("LocalPackage");
const TCHAR szUninstallKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall");
const TCHAR szPackageExtension[] = TEXT(".msi");
const TCHAR szLocalPackage[] = TEXT("LocalPackage");

void MigrationPerMachine()
{
    HKEY    hNewProductKey = NULL;
    HKEY    hOldProductKey = NULL;
    HKEY    hUninstallKey = NULL;
    HKEY    hUninstallProductKey = NULL;
    HKEY    hInstallProperties = NULL;
    TCHAR   szProductCodePacked[cchGUIDPacked + 1];
    DWORD   dwProductCodePacked = cchGUIDPacked + 1;
    TCHAR   szProductCodeUnpacked[cchGUID + 1];
    TCHAR   szProductGUIDInstallProperties[MAX_PATH];	
    SECURITY_ATTRIBUTES sa;


    // Get the security descriptor
    sa.nLength        = sizeof(sa);
    sa.bInheritHandle = FALSE;
    GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));
    
    // Open the destination key.
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSystemUserProductList, 0, KEY_ALL_ACCESS, &hNewProductKey) != ERROR_SUCCESS)
    {
	goto Exit;
    }

    // Open the per-machine install key.
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPerMachineInstallKey, 0, KEY_ALL_ACCESS, &hOldProductKey) != ERROR_SUCCESS)
    {
	goto Exit;
    }

    // ACL on this key matters.
    if(!FIsKeyLocalSystemOrAdminOwned(hOldProductKey))
    {
	goto Exit;
    }
    
    // enumerate through all installed products for the current user
    DWORD   dwIndex = 0;
    while(RegEnumKeyEx(hOldProductKey, dwIndex, szProductCodePacked, &dwProductCodePacked, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
    {
	TCHAR	szCachedPackage[MAX_PATH + 1] = TEXT("");
	DWORD	dwCachedPackage = MAX_PATH + 1;

	dwIndex++;
	dwProductCodePacked = cchGUIDPacked + 1;

	// Open the InstallProperties key under the UserData location.
	StringCchPrintf(szProductGUIDInstallProperties, sizeof(szProductGUIDInstallProperties)/sizeof(TCHAR), TEXT("%s\\%s"), szProductCodePacked, szInstallProperties);
	if(RegOpenKeyEx(hNewProductKey, szProductGUIDInstallProperties, 0, KEY_ALL_ACCESS, &hInstallProperties) != ERROR_SUCCESS)
	{
	    goto Exit;
	}

	// Check if the LocalPackage value already exists.
	if(RegQueryValueEx(hInstallProperties, szLocalPackageValueName, NULL, NULL, (LPBYTE)szCachedPackage, &dwCachedPackage) == ERROR_SUCCESS)
	{
	    // LocalPackage value already exist, move on to the next product.
	    RegCloseKey(hInstallProperties);
	    hInstallProperties = NULL;
	    continue;
	}
	dwCachedPackage = MAX_PATH + 1;

	// Open the uninstall key where the cached package location is stored.
	if(hUninstallKey == NULL)
	{
	    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, szUninstallKey, 0, KEY_READ, &hUninstallKey) != ERROR_SUCCESS)
	    {
		goto Exit;
	    }
	}

	// GUIDs under the Uninstall key are not packed.
	if(!UnpackGUID(szProductCodePacked, szProductCodeUnpacked))
	{
	    goto Exit;
	}
	
	// Open the product key under the uninstall key.
	if(RegOpenKeyEx(hUninstallKey, szProductCodeUnpacked, 0, KEY_READ, &hUninstallProductKey) != ERROR_SUCCESS)
	{
	    goto Exit;
	}

	// ACL on this key matters.
	if(!FIsKeyLocalSystemOrAdminOwned(hUninstallProductKey))
	{
	    goto Exit;
	}
	
	// Query the cached package path.
	if(RegQueryValueEx(hUninstallProductKey, szLocalPackageValueName, 0, NULL, (LPBYTE)szCachedPackage, &dwCachedPackage) != ERROR_SUCCESS)
	{
	    goto Exit;
	}

	RegCloseKey(hUninstallProductKey);
	hUninstallProductKey = NULL;

	// Open the cached package
	HANDLE	hSourceFile = CreateFile(szCachedPackage, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
	if(hSourceFile == INVALID_HANDLE_VALUE)
	{
	    // The path doesn't exist. Skip to the next product.
	    RegCloseKey(hInstallProperties);
	    hInstallProperties = NULL;
	    continue;
	}

	// Generate new name for the secure cached package.
	TCHAR	szNewPath[MAX_PATH];
	TCHAR	szNewFileName[13];

	GetWindowsDirectory(szNewPath, MAX_PATH);
	lstrcat(szNewPath, szInstallerDir);

	HANDLE	hDestFile = INVALID_HANDLE_VALUE;
	GenerateSecureTempFile(szNewPath, szPackageExtension, &sa, szNewFileName, hDestFile);

	if(!CopyOpenedFile(hSourceFile, hDestFile))
	{
	    // Skip to the next product.
	    CloseHandle(hSourceFile);
	    CloseHandle(hDestFile);
	    RegCloseKey(hInstallProperties);
	    hInstallProperties = NULL;
	    continue;
	}

	CloseHandle(hSourceFile);
	CloseHandle(hDestFile);

	// Add the cached package information to the UserData location.
	StringCchCat(szNewPath, (sizeof(szNewPath)/sizeof(TCHAR)), szNewFileName);
	if(RegSetValueEx(hInstallProperties, szLocalPackage, 0, REG_SZ, (const BYTE*)szNewPath, (lstrlen(szNewPath) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS)
	{
	    CloseHandle(hSourceFile);
	    CloseHandle(hDestFile);
	    goto Exit;
	}
	
	RegCloseKey(hInstallProperties);
	hInstallProperties = NULL;
    }

Exit:

    if(hNewProductKey != NULL)
    {
	RegCloseKey(hNewProductKey);
    }
    if(hOldProductKey != NULL)
    {
	RegCloseKey(hOldProductKey);
    }
    if(hUninstallKey != NULL)
    {
	RegCloseKey(hUninstallKey);
    }
    if(hUninstallProductKey != NULL)
    {
	RegCloseKey(hUninstallProductKey);
    }
    if(hInstallProperties != NULL)
    {
	RegCloseKey(hInstallProperties);
    }

    return;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiregmv\migutil.cpp ===
#include <windows.h>
#include <tchar.h>
#include "msiregmv.h"

////
// Check that the string is actually a packed GUID and convert it to uppercase
bool CanonicalizeAndVerifyPackedGuid(LPTSTR szString)
{
    TCHAR *szCur = szString;
    for (int i=0; i < cchGUIDPacked; i++, szString++)
    {
        TCHAR chCur = *szString;
        if (chCur == TEXT('\0'))
            return false;

        if (chCur >= TEXT('0') && chCur <= TEXT('9'))
            continue;
        if (chCur >= TEXT('A') && chCur <= TEXT('F'))
            continue;
        if (chCur >= TEXT('a') && chCur <= TEXT('f'))
        {
            *szString = _toupper(chCur);
            continue;
        };

        break; // if it reaches here then it means that it contains invalid character. bug 573259
    }
    return (*szString == 0);
}

///////////////////////////////////////////////////////////////////////
// the following PackGUID and UnpackGUID are based on MSI functions
// in msinst, except these functions only create Packed GUIDs, not
// SQUIDs.
const unsigned char rgOrderGUID[32] = {8,7,6,5,4,3,2,1, 13,12,11,10, 18,17,16,15,
                                       21,20, 23,22, 26,25, 28,27, 30,29, 32,31, 34,33, 36,35}; 
const unsigned char rgOrderDash[4] = {9, 14, 19, 24};

bool PackGUID(const TCHAR* szGUID, TCHAR rgchPackedGUID[cchGUIDPacked+1])
{ 
    int cchTemp = 0;
    while (cchTemp < cchGUID)       // check if string is atleast cchGUID chars long,
        if (!(szGUID[cchTemp++]))       // can't use lstrlen as string doesn't HAVE to be null-terminated.
            return false;

    if (szGUID[0] != '{' || szGUID[cchGUID-1] != '}')
        return false;
    const unsigned char* pch = rgOrderGUID;

    int cChar = 0;
    while (pch < rgOrderGUID + sizeof(rgOrderGUID))
        rgchPackedGUID[cChar++] = szGUID[*pch++];
    rgchPackedGUID[cChar] = 0;
    return true;
}

bool UnpackGUID(const TCHAR rgchPackedGUID[cchGUIDPacked+1], TCHAR* szGUID)
{ 
    const unsigned char* pch;
    pch = rgOrderGUID;
    int i = 0;
    while (pch < rgOrderGUID + sizeof(rgOrderGUID))
        if (rgchPackedGUID[i])
            szGUID[*pch++] = rgchPackedGUID[i++];
        else              // unexpected end of string
            return false;
    pch = rgOrderDash;
    while (pch < rgOrderDash + sizeof(rgOrderDash))
        szGUID[*pch++] = '-';
    szGUID[0]         = '{';
    szGUID[cchGUID-1] = '}';
    szGUID[cchGUID]   = 0;
    return true;
}


///////////////////////////////////////////////////////////////////////
// checks the OS version to see if we're on Win9X for use during 
// migration information
bool CheckWinVersion() 
{
    g_fWin9X = false;
    OSVERSIONINFOA osviVersion;
    osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    if (!::GetVersionExA(&osviVersion))
    {
        return false;
    }
    if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        g_fWin9X = true;
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiregmv\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiregmv\sources.inc ===
TARGETNAME=msiregmv
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=windows
UMENTRY=winmain

TARGETPATH=$(MSI_BUILD_TARGET)
TARGETLIBS= \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\msi.lib

C_DEFINES=$(C_DEFINES) -D_EXE

USE_MSVCRT=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR);$(BUILD_COMMONDIR)

SOURCES= \
	..\msiregmv.cpp \
        ..\readcnfg.cpp \
        ..\writecfg.cpp \
        ..\migsecur.cpp \
        ..\cleanup.cpp \
        ..\migutil.cpp \
        ..\patch.cpp \
	..\msiregmv.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiregmv\readcnfg.cpp ===
#include "msiregmv.h"

const TCHAR szSecureSubKeyName[] = TEXT("Secure");

////
// feature-usage registration information
const TCHAR szOldFeatureUsageKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Products");
const TCHAR szOldFeatureUsageValueName[] = TEXT("Usage");

////
// component registration information
const TCHAR szOldComponentKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components");


////
// feature-component registration information
const TCHAR szOldFeatureComponentKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Features");


bool g_fCommonUserIsSystemSID = false;

/////////////////////////
// Read component information from the Installer\Components key and places the Product,
// Component, Path, and Permanent bit into the temporary table for later query.
// returns ERROR_SUCCESS, ERROR_OUTOFMEMORY or ERROR_FUNCTION_FAILED
DWORD ReadComponentRegistrationDataIntoDatabase(MSIHANDLE hDatabase) 
{					 
	DEBUGMSG("Reading existing component registration data.");
	DWORD dwResult = ERROR_SUCCESS;

	// create the component table.
	PMSIHANDLE hView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `Component` (`Product` CHAR(32), `Component` CHAR(32) NOT NULL, `Path` CHAR(0), `SecondaryPath` CHAR(0) PRIMARY KEY `Product`, `Component`, `Path`)"), &hView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hView, 0)))
	{
		DEBUGMSG1("Error: Unable to create Component table. Error %d", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// create SharedDLL table
	PMSIHANDLE hSharedDLLView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `SharedDLL` (`Path` CHAR(0) NOT NULL, `OldRefCount` INTEGER, `NewRefCount` INTEGER PRIMARY KEY `Path`)"), &hSharedDLLView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hSharedDLLView, 0)))
	{
		DEBUGMSG1("Error: Unable to create SharedDLL table. Error %d", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// open the old per-machine Installer\Components key for read.
	HKEY hComponentListKey;
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldComponentKeyName,
												  0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, 
												  &hComponentListKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no products are installed. So return success
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Could not open old per-machine component key. Result: %d. ", dwResult);
			return ERROR_FUNCTION_FAILED;
		}
		else
		{
			DEBUGMSG("No old per-machine component key. No components to migrate.");
			return ERROR_SUCCESS;
		}
	}

	////
	// check the ACL on the key to ensure that it is trustworthy.
	if (!g_fWin9X && !FIsKeyLocalSystemOrAdminOwned(hComponentListKey))
	{
		DEBUGMSG("Warning: Skipping old per-machine component key, key is not owned by Admin or System.");
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	////
	// open query for insert into table
	PMSIHANDLE hInsertView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `Component`"), &hInsertView)) ||
	    ERROR_SUCCESS != (dwResult = MsiViewExecute(hInsertView, 0)))
	{
		DEBUGMSG1("Error: Unable to create insert query on Component table. Error %d", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	////
	// open query for insert into SharedDLL Table
	PMSIHANDLE hRefCountInsertView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `SharedDLL`"), &hRefCountInsertView)) ||
	    ERROR_SUCCESS != (dwResult = MsiViewExecute(hRefCountInsertView, 0)))
	{
		DEBUGMSG1("Error: Unable to create insert query on SharedDLL table. Error %d", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	////
	// open query for update of SharedDLL Table
	PMSIHANDLE hRefCountUpdateView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `OldRefCount` FROM `SharedDLL` WHERE `Path`=?"), &hRefCountUpdateView)))
	{
		DEBUGMSG1("Error: Unable to create update query on SharedDLL table. Error %d", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	DWORD dwIndex=0;
	PMSIHANDLE hInsertRec = ::MsiCreateRecord(5);
    while (1)
	{
		TCHAR rgchComponent[cchGUIDPacked+1];
		DWORD cchComponent = cchGUIDPacked+1;

		//// 
		// retrieve the next component subkey name
		LONG lResult = RegEnumKeyEx(hComponentListKey, dwIndex++, rgchComponent, 
									&cchComponent, 0, NULL, NULL, NULL);
		if (lResult == ERROR_MORE_DATA)
		{
			// key is not a valid GUID, skip to the next component key
			DEBUGMSG("Warning: Detected too-long component key. Skipping.");
			continue;
		}
		else if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG1("Error: RegEnumKeyEx on per-machine component key returned %l.", lResult);
			RegCloseKey(hComponentListKey);
			return ERROR_FUNCTION_FAILED;
		}
	 
		////
		// check if the component is a valid guid
		if ((cchComponent != cchGUIDPacked) || !CanonicalizeAndVerifyPackedGuid(rgchComponent))
		{
			// key is not a valid GUID, skip to the next key
			DEBUGMSG1("Warning: Detected invalid component key: %s. Skipping.", rgchComponent);
			continue;
		}

		// store the component code in the record for later insertion
		MsiRecordSetString(hInsertRec, 2, rgchComponent);

		// open the subkey
		HKEY hComponentKey;
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hComponentListKey, rgchComponent, 
										  0, KEY_QUERY_VALUE, &hComponentKey)))
		{
			DEBUGMSG2("Error: Could not open old per-machine component key for %s. Result: %d. Skipping component.", rgchComponent, dwResult);
			return ERROR_FUNCTION_FAILED;
		}

		DWORD cchMaxValueLen = 0;
		DWORD cValues = 0;
        if (ERROR_SUCCESS != (dwResult = RegQueryInfoKey(hComponentKey, NULL, NULL, 0, 
											 NULL, NULL, NULL, &cValues, NULL, 
											 &cchMaxValueLen, NULL, NULL)))
		{
			DEBUGMSG2("Error: Could not retrieve key information for old per-machine component key %s. Result: %d. Skipping component.", rgchComponent, dwResult);
			RegCloseKey(hComponentKey);
			RegCloseKey(hComponentListKey);
			return ERROR_FUNCTION_FAILED;
		}

		// if no products, skip
		if (cValues == 0)
		{
			RegCloseKey(hComponentKey);
			continue;
		}

		// allocate memory to grab the path from the registry
		TCHAR *szValue = new TCHAR[cchMaxValueLen];
		if (!szValue)
		{
			DEBUGMSG("Error: out of memory.");
			RegCloseKey(hComponentListKey);
			RegCloseKey(hComponentKey);
			return ERROR_OUTOFMEMORY;
		}
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;

		DWORD dwValueIndex = 0;
		while (1)
		{
			cchProduct = cchGUIDPacked+1;
			DWORD cbValue = cchMaxValueLen*sizeof(TCHAR);
			DWORD dwType = 0;
			LONG lResult = RegEnumValue(hComponentKey, dwValueIndex++, rgchProduct, 
										&cchProduct, 0, &dwType, reinterpret_cast<unsigned char*>(szValue), &cbValue);
			if (lResult == ERROR_MORE_DATA)
			{
				// value is not a valid ProductId, skip to the next ProductId
				DEBUGMSG1("Warning: Detected too-long product value for component %s. Skipping.", rgchComponent);
				continue;
			}
			else if (lResult == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else if (lResult != ERROR_SUCCESS)
			{
				DEBUGMSG2("Error: Could not enumerate products for old per-machine component %s. Result: %d.", rgchComponent, dwResult);
				RegCloseKey(hComponentKey);
				RegCloseKey(hComponentListKey);
				delete[] szValue;
				return ERROR_FUNCTION_FAILED;
			}

			// if not reg-sz or reg-multi-sz, not a valid path registration
			if (dwType != REG_SZ && dwType != REG_MULTI_SZ)
			{
				DEBUGMSG1("Warning: Non-string registry value for component %s. Skipping.", rgchComponent);
				continue;
			}

			////
			// check if the product is a valid guid
			if ((cchProduct != cchGUIDPacked) || !CanonicalizeAndVerifyPackedGuid(rgchProduct))
			{
				// key is not a valid GUID, skip it
				DEBUGMSG2("Warning: Invalid product value %s for component %s. Skipping.", rgchProduct, rgchComponent);
				continue;
			}

			TCHAR *szSecondaryKeyPath = NULL;
			if (dwType == REG_MULTI_SZ)
			{
				// for MULTI_SZ the secondary keypath begins one NULL after the end
				// of the primary keypath
				szSecondaryKeyPath = szValue + lstrlen(szValue)+1;
			}

			////
			// check for sharedDLL information. If the paths differ in case, it 
			// doesn't matter too much because the update algorithm can handle
			// updating the same key twice with two different deltas. Must do
			// this before trashing szValue for dummy permanent product IDs.

			// Future: if ANSI builds, can we have DBCS drive letters?
			if (szValue[0] != '\0' && szValue[1] == TEXT('?'))
			{
				PMSIHANDLE hSharedDLLRec = MsiCreateRecord(3);
				MsiRecordSetString(hSharedDLLRec, 1, szValue);
				MsiRecordSetInteger(hSharedDLLRec, 2, 1);
				MsiRecordSetInteger(hSharedDLLRec, 3, 0);

				if (ERROR_SUCCESS != MsiViewModify(hRefCountInsertView, MSIMODIFY_INSERT, hSharedDLLRec))
				{
					// record might already exist
					if (ERROR_SUCCESS != (dwResult = MsiViewExecute(hRefCountUpdateView, hSharedDLLRec)) ||
						ERROR_SUCCESS != (dwResult = MsiViewFetch(hRefCountUpdateView, &hSharedDLLRec)))
					{
						DEBUGMSG3("Error: Unable to insert SharedDLL data for component %s, product %s into SharedDLL table. Error %d", rgchComponent, rgchProduct, dwResult);
						delete[] szValue;
						RegCloseKey(hComponentKey);
						RegCloseKey(hComponentListKey);
						return ERROR_FUNCTION_FAILED;
					}

					// increment the existing old SharedDLL cont for this path
					MsiRecordSetInteger(hSharedDLLRec, 1, MsiRecordGetInteger(hSharedDLLRec, 1)+1);
					if (ERROR_SUCCESS != (dwResult = MsiViewModify(hRefCountUpdateView, MSIMODIFY_UPDATE, hSharedDLLRec)))
					{
						DEBUGMSG3("Error: Unable to insert SharedDLL data for component %s, product %s into SharedDLL table. Error %d", rgchComponent, rgchProduct, dwResult);
						delete[] szValue;
						RegCloseKey(hComponentKey);
						RegCloseKey(hComponentListKey);
						return ERROR_FUNCTION_FAILED;
					}
				}
			}

			// if the productId is actually a GUID <= 255, its a dummy product 
			// for permanent components. the actual GUID is uninteresting and is set to NULL
			if (CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT, 0, rgchProduct, 30, TEXT("000000000000000000000000000000"), 30))
			{
				rgchProduct[0] = TEXT('\0');
			}

			MsiRecordSetString(hInsertRec, 1, rgchProduct);
			MsiRecordSetString(hInsertRec, 3, szValue);
			MsiRecordSetString(hInsertRec, 4, szSecondaryKeyPath);
			MsiRecordSetString(hInsertRec, 5, 0);

			if (ERROR_SUCCESS != (dwResult = MsiViewModify(hInsertView, MSIMODIFY_INSERT, hInsertRec)))
			{
				DEBUGMSG3("Error: Unable to insert data for component %s, product %s into Component table. Error %d", rgchComponent, rgchProduct, dwResult);
				delete[] szValue;
				RegCloseKey(hComponentKey);
				RegCloseKey(hComponentListKey);
				return ERROR_FUNCTION_FAILED;
			}

		}

		// cleanup memory
		delete[] szValue;
		szValue = NULL;

		RegCloseKey(hComponentKey);
	}
	RegCloseKey(hComponentListKey);

	return ERROR_SUCCESS;
}
					 

/////////////////
// reads the feature-component mappings from the registry into the FeatureComponent 
// table of the temporary database. Returns ERROR_SUCCESS, ERROR_FUNCTION_FAILED, or
// ERROR_OUT_OF_MEMORY
DWORD ReadFeatureRegistrationDataIntoDatabase(MSIHANDLE hDatabase) 
{					 
	DEBUGMSG("Reading existing feature registration data.");

	PMSIHANDLE hView;
	DWORD dwResult = ERROR_SUCCESS;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `FeatureComponent` (`Product` CHAR(32) NOT NULL, `Feature` CHAR(0) NOT NULL, `Components` CHAR(0) PRIMARY KEY `Product`, `Feature`)"), &hView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hView, 0)))
	{
		DEBUGMSG1("Error: Unable to create FeatureComponent table. Error %d", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	HKEY hFeatureListKey;
 	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldFeatureComponentKeyName,
												  0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, 
												  &hFeatureListKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no products are installed. So return success
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Could not open old per-machine feature key. Result: %d. ", dwResult);
			return ERROR_FUNCTION_FAILED;
		}
		else
		{
			DEBUGMSG("No old per-machine feature key. No products to migrate.");
			return ERROR_SUCCESS;
		}
	}

	////
	// check the ACL on the key to ensure that it is trustworthy.
	if (!g_fWin9X && !FIsKeyLocalSystemOrAdminOwned(hFeatureListKey))
	{
		DEBUGMSG("Warning: Skipping old per-machine feature key, key is not owned by Admin or System.");
		RegCloseKey(hFeatureListKey);
		return ERROR_FUNCTION_FAILED;
	}

	////
	// open query for insert into table
	PMSIHANDLE hInsertView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `FeatureComponent`"), &hInsertView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hInsertView, 0)))
	{
		DEBUGMSG1("Error: Unable to create insert query for FeatureComponent table. Error %d", dwResult);
		RegCloseKey(hFeatureListKey);
		return ERROR_FUNCTION_FAILED;
	}

	DWORD dwIndex=0;
	PMSIHANDLE hInsertRec = ::MsiCreateRecord(3);
    while (1)
	{
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;

		//// 
		// retrieve the next product subkey name
		LONG lResult = RegEnumKeyEx(hFeatureListKey, dwIndex++, rgchProduct, 
									&cchProduct, 0, NULL, NULL, NULL);
		if (lResult == ERROR_MORE_DATA)
		{
			// key is not a valid GUID, skip to the next product key
			DEBUGMSG("Warning: Detected too-long product value. Skipping.");
			continue;
		}
		else if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG1("Error: RegEnumKeyEx on old feature key returned %l.", lResult);
			RegCloseKey(hFeatureListKey);
			return ERROR_FUNCTION_FAILED;
		}
	 
		////
		// check if the product is a valid guid
		if ((cchProduct != cchGUIDPacked) || !CanonicalizeAndVerifyPackedGuid(rgchProduct))
		{
			// key is not a valid GUID, skip to the next key. Warn if not "Secure" key.
			if (2 != CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, rgchProduct, -1, szSecureSubKeyName, -1))
			{
				DEBUGMSG1("Warning: Detected non-product subkey %s. Skipping.", rgchProduct);
			}
			continue;
		}

		// store the product code in the record for later insertion
		MsiRecordSetString(hInsertRec, 1, rgchProduct);

		// open the subkey
		HKEY hProductKey;
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hFeatureListKey, rgchProduct, 
										  0, KEY_QUERY_VALUE, &hProductKey)))
		{
			DEBUGMSG2("Error: Could not open old feature key for product %s. Result: %d.", rgchProduct, dwResult);
			RegCloseKey(hFeatureListKey);
			return ERROR_FUNCTION_FAILED;
		}

		DWORD cbMaxValueLen = 0;
        DWORD cchMaxNameLen = 0;
		DWORD cValues = 0;
		if (ERROR_SUCCESS != (dwResult = RegQueryInfoKey(hProductKey, NULL, NULL, 0, 
											 NULL, NULL, NULL, &cValues, &cchMaxNameLen, 
											 &cbMaxValueLen, NULL, NULL)))
		{
			DEBUGMSG2("Error: Could not retrieve key information for old feature key for product %s. Result: %d. ", rgchProduct, dwResult);
			RegCloseKey(hProductKey);
			RegCloseKey(hFeatureListKey);
			return ERROR_FUNCTION_FAILED;
		}

		// if no features, skip subkey
		if (cValues == 0)
		{
			RegCloseKey(hProductKey);
			continue;
		}

		TCHAR *szValue = new TCHAR[cbMaxValueLen/sizeof(TCHAR)];
		if (!szValue)
		{
			DEBUGMSG("Error: out of memory.");
			RegCloseKey(hProductKey);
			RegCloseKey(hFeatureListKey);
			return ERROR_OUTOFMEMORY;
		}

		// QueryInfoKey length does not include terminating '\0' for value names.
		TCHAR *szName = new TCHAR[++cchMaxNameLen];
		if (!szName)
		{
			DEBUGMSG("Error: out of memory.");
			RegCloseKey(hProductKey);
			RegCloseKey(hFeatureListKey);
			delete[] szValue;
			return ERROR_OUTOFMEMORY;
		}

		// enumerate through all feature values for this product
		DWORD dwValueIndex = 0;
		while (1)
		{
			DWORD cbValue = cbMaxValueLen;
			DWORD cchValueName = cchMaxNameLen;
			LONG lResult = RegEnumValue(hProductKey, dwValueIndex++, szName, 
										&cchValueName, 0, NULL, reinterpret_cast<unsigned char*>(szValue), &cbValue);
			if (lResult == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else if (lResult != ERROR_SUCCESS)
			{
				DEBUGMSG2("Error: Could not enumerate features for product %s. Result: %d.", rgchProduct, dwResult);
				RegCloseKey(hProductKey);
				RegCloseKey(hFeatureListKey);
				delete[] szValue;
				delete[] szName;
				return ERROR_FUNCTION_FAILED;
			}

			MsiRecordSetString(hInsertRec, 2, szName);
			MsiRecordSetString(hInsertRec, 3, szValue);

			if (ERROR_SUCCESS != (dwResult = MsiViewModify(hInsertView, MSIMODIFY_INSERT, hInsertRec)))
			{
				DEBUGMSG3("Error: could not insert feature data for product %s, feature %s. Result: %d", rgchProduct, szName, dwResult);
				RegCloseKey(hProductKey);
				RegCloseKey(hFeatureListKey);
				delete[] szValue;
				delete[] szName;
				return ERROR_FUNCTION_FAILED;
			}
		}

		// cleanup memory
		delete[] szValue;
		delete[] szName;
		szValue = NULL;
		szName = NULL;
	
		RegCloseKey(hProductKey);
	}
	RegCloseKey(hFeatureListKey);

	return ERROR_SUCCESS;
}



///////////////////////////////////////////////////////////////////////
// reads the feature usage information from the registry into the FeatureUsage 
// table of the temporary database. Returns ERROR_SUCCESS or ERROR_OUTOFMEMORY.
// does not return ERROR_FUNCTION_FAILED, as feature usage data is useless anyway.
DWORD ReadFeatureUsageDataIntoDatabase(MSIHANDLE hDatabase) 
{					 
	DEBUGMSG("Reading existing feature usage data.");

	PMSIHANDLE hView;
	DWORD dwResult = ERROR_SUCCESS;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `FeatureUsage` (`Product` CHAR(32) NOT NULL, `Feature` CHAR(0) NOT NULL, `Usage` LONG PRIMARY KEY `Product`, `Feature`)"), &hView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hView, 0)))
	{
		DEBUGMSG1("Error: Unable to create FeatureUsage table. Error %d", dwResult);
		return ERROR_SUCCESS;
	}

	HKEY hFeatureListKey;
 	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldFeatureUsageKeyName,
												  0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, 
												  &hFeatureListKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no products are installed. So return success
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Could not open old feature usage key. Result: %d. ", dwResult);
		}
		else
		{
			DEBUGMSG("No old feature usage key to migrate.");
		}
		return ERROR_SUCCESS;
	}

	////
	// check the ACL on the key to ensure that it is trustworthy.
	if (!g_fWin9X && !FIsKeyLocalSystemOrAdminOwned(hFeatureListKey))
	{
		DEBUGMSG("Skipping old feature usage key, key is not owned by Admin or System.");
		RegCloseKey(hFeatureListKey);
		return ERROR_SUCCESS;
	}

	////
	// open query for insert into table
	PMSIHANDLE hInsertView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `FeatureUsage`"), &hInsertView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hInsertView, 0)))
	{
		RegCloseKey(hFeatureListKey);
		DEBUGMSG1("Error: Unable to create insert query for FeatureUsage table. Error %d", dwResult);
		return ERROR_SUCCESS;
	}


	DWORD dwIndex=0;
	PMSIHANDLE hInsertRec = ::MsiCreateRecord(3);
    while (1)
	{
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;

		//// 
		// retrieve the next product subkey name
		LONG lResult = RegEnumKeyEx(hFeatureListKey, dwIndex++, rgchProduct, 
									&cchProduct, 0, NULL, NULL, NULL);
		if (lResult == ERROR_MORE_DATA)
		{
			// key is not a valid GUID, skip to the next product key
			DEBUGMSG("Warning: Detected too-long product value. Skipping.");
			continue;
		}
		else if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG1("Error: RegEnumKeyEx on old feature usage key returned %l.", lResult);
			RegCloseKey(hFeatureListKey);
			return ERROR_SUCCESS;
		}
	 
		////
		// check if the product is a valid guid
		if ((cchProduct != cchGUIDPacked) || !CanonicalizeAndVerifyPackedGuid(rgchProduct))
		{
			// key is not a valid GUID, skip to the next key
			if (2 != CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, rgchProduct, -1, szSecureSubKeyName, -1))
			{
				DEBUGMSG1("Warning: Detected non-product subkey %s. Skipping.", rgchProduct);
			}
			continue;
		}

		// store the product code in the record for later insertion
		MsiRecordSetString(hInsertRec, 1, rgchProduct);

		// open the subkey. Although we don't actually query any values, retrieving key info (longest subkey, etc)
		// requires KEY_QUERY_VALUE access.
		HKEY hProductKey;
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hFeatureListKey, rgchProduct, 
										  0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hProductKey)))
		{
			DEBUGMSG2("Error: Could not open old feature usage key for %s. Result: %d. Skipping", rgchProduct, dwResult);
			continue;
		}

		DWORD cchMaxKeyLen = 0;
		DWORD cSubKeys = 0;
		if (ERROR_SUCCESS != (dwResult = RegQueryInfoKey(hProductKey, NULL, NULL, 0, 
											 &cSubKeys, &cchMaxKeyLen, NULL, NULL, NULL, 
											 NULL, NULL, NULL)))
		{
			RegCloseKey(hProductKey);
			DEBUGMSG2("Error: Could not retrieve key information for old feature usage key for %s. Result: %d. ", rgchProduct, dwResult);
			continue;
		}

		if (cSubKeys == 0)
		{
			RegCloseKey(hProductKey);
			continue;
		}

		TCHAR *szFeature = new TCHAR[++cchMaxKeyLen];
		if (!szFeature)
		{
			DEBUGMSG("Error: Out of memory");
			RegCloseKey(hFeatureListKey);
			return ERROR_OUTOFMEMORY;
		}

		DWORD dwKeyIndex = 0;
		while (1)
		{
			DWORD cchKeyName = cchMaxKeyLen;
			DWORD dwFeatureUsage = 0;
			DWORD cbValue = sizeof(dwFeatureUsage);
			LONG lResult = RegEnumKeyEx(hProductKey, dwKeyIndex++, szFeature, &cchKeyName, 0, NULL, NULL, NULL);
			if (lResult == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else if (lResult != ERROR_SUCCESS)
			{
				DEBUGMSG2("Error: Could not enumerate feature usage for product %s. Result: %d.", rgchProduct, dwResult);
				break;
			}

			HKEY hFeatureKey;
			if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hProductKey, szFeature, 0, KEY_QUERY_VALUE, &hFeatureKey)))
			{
				DEBUGMSG3("Error: Could not open old feature usage key for %s, %s. Result: %d. ", rgchProduct, szFeature, dwResult);
				continue;
			}

			if (ERROR_SUCCESS != (dwResult = RegQueryValueEx(hFeatureKey, szOldFeatureUsageValueName, 0, NULL, reinterpret_cast<unsigned char*>(&dwFeatureUsage), &cbValue)))
			{
				RegCloseKey(hFeatureKey);
				if (dwResult != ERROR_FILE_NOT_FOUND)
				{
					DEBUGMSG3("Error: Could not retrieve usage information for old %s, %s. Result: %d. ", rgchProduct, szFeature, dwResult);
				}
				continue;
				
			}
			RegCloseKey(hFeatureKey);

			MsiRecordSetString(hInsertRec, 2, szFeature);
			MsiRecordSetInteger(hInsertRec, 3, dwFeatureUsage);

			if (ERROR_SUCCESS != (dwResult = MsiViewModify(hInsertView, MSIMODIFY_INSERT, hInsertRec)))
			{
				DEBUGMSG3("Error: could not insert feature usage data for product %s, feature %s. Result: %d", rgchProduct, szFeature, dwResult);
			}
		}

		// cleanup memory
		delete[] szFeature;
		szFeature = NULL;
	
		RegCloseKey(hProductKey);
	}
	RegCloseKey(hFeatureListKey);

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// Reads the provided product-list registry key and adds the product and patch 
// to the temporary database. Returns one of ERROR_SUCCESS, ERROR_FUNCTION_FAILED,
// or ERROR_OUTOFMEMORY
DWORD ReadProductInstallKey(MSIHANDLE hDatabase, HKEY hKey, LPCTSTR szSID, MSIHANDLE hInsertView, eManagedType eManaged)
{
    PMSIHANDLE hInsertRec = MsiCreateRecord(3);
	MsiRecordSetString(hInsertRec, 1, szSID);
	MsiRecordSetInteger(hInsertRec, 3, eManaged);
	
	// Add all products to the list. 
	DWORD dwIndex=0;
	while (1)
	{
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;
		
		// retrieve the next product subkey name
		LONG lResult = RegEnumKeyEx(hKey, dwIndex++, rgchProduct, 
								 &cchProduct, 0, NULL, NULL, NULL);
		if (lResult == ERROR_MORE_DATA)
		{
			// key is not a valid packed GUID, skip to the next product
			DEBUGMSG("Warning: Detected too-long product value. Skipping.");
			continue;
		}
		else if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG2("Error: Could not enumerate product subkeys for %s. Result: %l. ", szSID, lResult);
			return ERROR_FUNCTION_FAILED;
		}
		
		////
		// check if the product is a valid guid
		if ((cchProduct != cchGUIDPacked) || !CanonicalizeAndVerifyPackedGuid(rgchProduct))
		{
			// key is not a valid packed GUID, skip to the next product
			DEBUGMSG2("Warning: Key %s for user %s is not a valid product. Skipping.", rgchProduct, szSID);
			continue;
		}
		
		// store the product code in the record
		MsiRecordSetString(hInsertRec, 2, rgchProduct);

		// most likely failure is that the product is already added for this user by another
		// install type.
		MsiViewModify(hInsertView, MSIMODIFY_INSERT, hInsertRec);

		DWORD dwResult = ERROR_SUCCESS;
		if (ERROR_SUCCESS != (dwResult = AddProductPatchesToPatchList(hDatabase, hKey, szSID, rgchProduct, eManaged)))
			return dwResult;
	}
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// Reads HKCU registry key for per user installs for the current user 
// and adds them to the database. Returns ERROR_SUCCESS, 
// ERROR_FUNCTION_FAILED, or ERROR_OUTOFMEMORY
DWORD ReadLocalPackagesKey(HKEY hKey, MSIHANDLE hInsertView)
{
    PMSIHANDLE hInsertRec = MsiCreateRecord(3);
	TCHAR rgchProduct[cchGUIDPacked+1];

	// enumerate each product key under the LocalPackages key
	DWORD dwIndex = 0;
	while(1)
	{
		// retrieve the next product subkey name
		DWORD cchProduct = cchGUIDPacked+1;
		LONG lResult = RegEnumKeyEx(hKey, dwIndex++, rgchProduct, 
								 &cchProduct, 0, NULL, NULL, NULL);
		if (lResult == ERROR_MORE_DATA)
		{
			// key is not a valid packed GUID, skip to the next product
			DEBUGMSG("Warning: Detected too-long product value. Skipping.");
			continue;
		}
		else if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG1("Error: Could not enumerate product subkeys for LocalPackages Key. Result: %l. ", lResult);
			return ERROR_FUNCTION_FAILED;
		}
		
		////
		// check if the product is a valid guid
		if ((cchProduct != cchGUIDPacked) || !CanonicalizeAndVerifyPackedGuid(rgchProduct))
		{
			// key is not a valid packed GUID, skip to the next product
			DEBUGMSG1("Warning: Key %s for LocalPackages is not a valid product. Skipping.", rgchProduct);
			continue;
		}
		
		// store the product code in the record
		MsiRecordSetString(hInsertRec, 2, rgchProduct);

    	// open the subkey
		HKEY hProductKey;
		DWORD dwResult = ERROR_SUCCESS;
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hKey, rgchProduct, 
										  0, KEY_QUERY_VALUE, &hProductKey)))
		{
			DEBUGMSG2("Error: Could not open old localpackages key for %s. Result: %d. ", rgchProduct, dwResult);
			return ERROR_FUNCTION_FAILED;
		}

		DWORD cchMaxValueNameLen = 0;
		DWORD cValues = 0;
        if (ERROR_SUCCESS != (dwResult = RegQueryInfoKey(hProductKey, NULL, NULL, 0, 
											 NULL, NULL, NULL, &cValues, &cchMaxValueNameLen, 
											 NULL, NULL, NULL)))
		{
			DEBUGMSG2("Error: Could not retrieve key information for localpackages key %s. Result: %d. ", rgchProduct, dwResult);
			RegCloseKey(hProductKey);
			return ERROR_FUNCTION_FAILED;
		}

		// if no values, skip
		if (cValues == 0)
		{
			RegCloseKey(hProductKey);
			continue;
		}

		TCHAR *szName = new TCHAR[++cchMaxValueNameLen];
		if (!szName)
		{
			DEBUGMSG("Error: Out of memory");
			RegCloseKey(hProductKey);
			return ERROR_OUTOFMEMORY;
		}

		DWORD dwValueIndex = 0;
		while (1)
		{
			DWORD cchName = cchMaxValueNameLen;
			LONG lResult = RegEnumValue(hProductKey, dwValueIndex++, szName, 
										&cchName, 0, NULL, NULL, NULL);
			if (lResult == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else if (lResult != ERROR_SUCCESS)
			{
				DEBUGMSG2("Could not enumerate users for product %s. Result: %d.", rgchProduct, lResult);
				delete[] szName;
				RegCloseKey(hProductKey);
				return ERROR_FUNCTION_FAILED;
			}
 
			// asume non-managed product.
			eManagedType eManaged = emtNonManaged;

			// if the SID is the machine SID, its a managed app.
			if (0 == lstrcmp(szName, szLocalSystemSID))
			{
				eManaged = emtMachineManaged;
			}
			else
			{
				// check if the name ends in "(Managed)" and strip it if it does, setting
				// the managed flag as appropriate
				int cchCount = lstrlen(szName) - cchManagedPackageKeyEnd + 1;
				if (cchCount > 0 && (0 == lstrcmp(szName + cchCount, szManagedPackageKeyEnd)))
				{
					eManaged = emtUserManaged;
					*(szName+cchCount) = 0;
				}
				else
					eManaged = emtNonManaged;
			}

			MsiRecordSetInteger(hInsertRec, 3, eManaged);
			MsiRecordSetString(hInsertRec, 1, szName);

			// most common failure is that the product already exists. All other
			// failures should be ignored.
			MsiViewModify(hInsertView, MSIMODIFY_MERGE, hInsertRec);
		}
		RegCloseKey(hProductKey);
		delete[] szName;
	}

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// build a mapping from product to user based on all available
// information, including explicit product registration information
// stored in Managed hives, per-user installs under HKCU, and cached
// package identification under the LocalPackages key. This will not
// catch per-user non-managed installs for the non-current user if the
// package was never successfully recached by 1.1.
DWORD BuildUserProductMapping(MSIHANDLE hDatabase, bool fReadHKCUAsSystem)
{
	DEBUGMSG("Reading product install information.");
	DWORD dwResult = ERROR_SUCCESS;

	PMSIHANDLE hView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `Products` (`User` CHAR(0) NOT NULL, `Product` CHAR(32) NOT NULL, `Managed` INTEGER PRIMARY KEY `User`, `Product`)"), &hView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hView, 0)))
	{
		DEBUGMSG1("Error: Unable to create Products table. Error %d", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hPatchTable;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `PatchApply` (`User` CHAR(0) NOT NULL, `Product` CHAR(32) NOT NULL, `Patch` CHAR(32) NOT NULL, `Known` INTEGER PRIMARY KEY `User`, `Product`, `Patch`)"), &hPatchTable)) ||
	ERROR_SUCCESS != (dwResult = MsiViewExecute(hPatchTable, 0)))
	{
		DEBUGMSG1("Error: Unable to create PatchApply table. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hInsertView;
	if (ERROR_SUCCESS != MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `Products`"), &hInsertView))
	{
		DEBUGMSG1("Error: Unable to create insert query for Products table. Error %d", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// user to product mappings come from four locations:
	// 1. Per-Machine installed apps
	// 2. Installer\Managed for per-user managed apps
	// 3. HKCU for the current user non-managed
	// 4. CachedPackage List
	HKEY hKey = 0;

	////
	// 1. Per-Machine installed apps. On Win9X upgrades these are per-machine
	if (ERROR_SUCCESS == (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPerMachineInstallKeyName, 
												  0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, &hKey)))
	{
		// ACL on this key does matter
		if (FIsKeyLocalSystemOrAdminOwned(hKey))
		{
			if (ERROR_SUCCESS != (dwResult = ReadProductInstallKey(hDatabase, hKey, szLocalSystemSID, hInsertView, emtMachineManaged)))
			{
				RegCloseKey(hKey);
				return dwResult;
			}
		}
		else
		{
			DEBUGMSG("Warning: Skipping per-machine installer key, key is not owned by Admin or System.");
		}
		
		RegCloseKey(hKey);
	}
	else
	{
		// if the reason that this failed is that the key doesn't exist, no products are installed. So we can
		// continue. Otherwise failure.
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Could not open per-machine installer key. Result: %d.", dwResult);
			return ERROR_FUNCTION_FAILED;
		}
	}


	////
	// 2. Installer\Managed for per-user managed apps, but not on Win9X
	if (!g_fWin9X)
	{
		// Although we don't actually query any values, retrieving key info (longest subkey, etc)
		// requires KEY_QUERY_VALUE access.
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPerUserManagedInstallKeyName, 
													  0, READ_CONTROL | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hKey)))
		{
			// if the reason that this failed is that the key doesn't exist, no products are installed.
			// This is not a catastrophic failure.
			if (ERROR_FILE_NOT_FOUND != dwResult)
			{
				DEBUGMSG1("Error: Failed to open per-user managed key. Result: %d.", dwResult);
				return ERROR_FUNCTION_FAILED;
			}
		}
		else
		{
			// ACL on this key does matter. If its not owned by LocalSystem or Admins, the
			// information can't be trusted.
			if (!g_fWin9X && FIsKeyLocalSystemOrAdminOwned(hKey))
			{
				// enumerate each user SID under the Managed key
				DWORD cchMaxKeyLen = 0;
				DWORD cSubKeys = 0;
				if (ERROR_SUCCESS != (dwResult = RegQueryInfoKey(hKey, NULL, NULL, 0, &cSubKeys, 
													 &cchMaxKeyLen, NULL, NULL, NULL, 
													 NULL, NULL, NULL)))
				{
					DEBUGMSG1("Error: Could not retrieve key information for per-user managed. Result: %d. ", dwResult);
					return ERROR_FUNCTION_FAILED;
				}
				else if (cSubKeys)
				{
					// on NT, cchMaxKeyLen does not include terminating NULL for the
					// longest subkey name.
					cchMaxKeyLen++;
					TCHAR *szUser = new TCHAR[cchMaxKeyLen];
					if (!szUser)
					{
						DEBUGMSG("Error: Out of memory");
						RegCloseKey(hKey);
						return ERROR_OUTOFMEMORY;
					}
					
					// the user key name is the user SID plus Installer\Products
					TCHAR *szUserKey = new TCHAR[cchMaxKeyLen+sizeof(szPerUserManagedInstallSubKeyName)];
					if (!szUserKey)
					{
						DEBUGMSG("Error: Out of memory");
						RegCloseKey(hKey);
						delete[] szUser;
						return ERROR_OUTOFMEMORY;
					}
					
					DWORD dwKeyIndex = 0;
					while (1)
					{
						DWORD cchUser = cchMaxKeyLen;
						LONG lResult = RegEnumKeyEx(hKey, dwKeyIndex++, szUser, 
													&cchUser, 0, NULL, NULL, NULL);
						if (lResult == ERROR_NO_MORE_ITEMS)
						{
							break;
						}
						else if (lResult != ERROR_SUCCESS)
						{
							DEBUGMSG1("Error: Could not enumerate users for per-user managed key. Result: %l.", lResult);
							RegCloseKey(hKey);
							delete[] szUser;
							delete[] szUserKey;
							return ERROR_FUNCTION_FAILED;
						}
			
						// have a user SID
						HKEY hPerUserKey;
						lstrcpy(szUserKey, szUser);
						lstrcat(szUserKey, szPerUserManagedInstallSubKeyName);
						if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hKey, szUserKey, 0, KEY_ENUMERATE_SUB_KEYS, &hPerUserKey)))
						{
							// if the reason that this failed is that the key doesn't exist, no products are installed.
							// this is not a catastrophic failure.
							if (ERROR_FILE_NOT_FOUND != dwResult)
							{
								DEBUGMSG2("Error: Failed to open per-user managed key for %s. Result: %d.", szUser, dwResult);
								delete[] szUser;
								delete[] szUserKey;
								RegCloseKey(hKey);
								return ERROR_FUNCTION_FAILED;
							}
						}
						else
						{
							dwResult = ReadProductInstallKey(hDatabase, hPerUserKey, szUser, hInsertView, emtUserManaged);
							if (ERROR_SUCCESS != dwResult)
							{
								delete[] szUser;
								delete[] szUserKey;
								RegCloseKey(hKey);
								return dwResult;
							}
						}
					}
					delete[] szUser;
					delete[] szUserKey;
				}
			}
			else
			{
				DEBUGMSG("Warning: Skipping per-user managed installer key, key is not owned by Admin or System.");
			}
			RegCloseKey(hKey);
		}
	}

	////
	// 3. HKCU for the current user non-managed. Read on Win9X 
	// only if profiles are not enabled (so HKCU is actually per-machine)
	if (!g_fWin9X || fReadHKCUAsSystem)
	{
		TCHAR szSID[cchMaxSID];
		if (fReadHKCUAsSystem)
		{
			lstrcpy(szSID, szLocalSystemSID);
		}
		else
		{
			dwResult = GetCurrentUserStringSID(szSID);
			if (ERROR_SUCCESS != dwResult)
			{
				DEBUGMSG1("Unable to retrieve current user SID string. Result: %d.", dwResult);
				RegCloseKey(hKey);
				return ERROR_FUNCTION_FAILED;
			}
		}

		if (g_fWin9X || lstrcmp(szSID, szLocalSystemSID))
		{
			if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_CURRENT_USER, szPerUserInstallKeyName, 0, KEY_ENUMERATE_SUB_KEYS, &hKey)))
			{
				// if the key could not be opened because it was not present, no products
				// are installed per-user. This is not a catastrophic failure.
				if (ERROR_FILE_NOT_FOUND != dwResult)
				{
					DEBUGMSG1("Error: Failed to open per-user managed key. Result: %d.", dwResult);
					return ERROR_FUNCTION_FAILED;
				}
			}
			else
			{
				// ACL on this key does not matter
				dwResult = ReadProductInstallKey(hDatabase, hKey, szSID, hInsertView, emtNonManaged);
				RegCloseKey(hKey);
		
				if (ERROR_SUCCESS != dwResult)
					return dwResult;
			}
		}
		else
		{
			DEBUGMSG("Running as system. No HKCU products to detect.");
		}
	}


	////
	// 4. Cached Package List
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szLocalPackagesKeyName, 
												  0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, &hKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no products are installed. So return success
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Failed to open local packages key. Result: %d.", dwResult);
			return ERROR_FUNCTION_FAILED;
		}
   	}
	else
	{
		// ACL on this key does matter
		if (g_fWin9X || FIsKeyLocalSystemOrAdminOwned(hKey))
		{
			dwResult = ReadLocalPackagesKey(hKey, hInsertView);
			if (ERROR_SUCCESS != dwResult)
			{
				RegCloseKey(hKey);
				return dwResult;
			}
		}
		else
  		{
			DEBUGMSG("Skipping localpackages key, key is not owned by Admin or System.");
		}

		RegCloseKey(hKey);
	}
	
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// Read all configuration informaiton into the specificied database
// path, including component registration, product install state, 
// patches, transforms, and feature-component mappings. Does not
// write anything into the registry.
DWORD ReadProductRegistrationDataIntoDatabase(TCHAR* szDatabase, MSIHANDLE& hDatabase, bool fReadHKCUAsSystem)
{
	DWORD dwResult = ERROR_SUCCESS;

	if (!CheckWinVersion())
		return ERROR_FUNCTION_FAILED;

	// try to open the database for read/write
	if (ERROR_SUCCESS != MsiOpenDatabase(szDatabase, MSIDBOPEN_CREATE, &hDatabase))
		return ERROR_FUNCTION_FAILED;

	// create a table to hold files that should be cleaned up on failure or success
	PMSIHANDLE hCleanUpTable;
	if (ERROR_SUCCESS == (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `CleanupFile` (`File` CHAR(0) NOT NULL, `OnSuccess` INTEGER PRIMARY KEY `File`)"), &hCleanUpTable)))
		dwResult = MsiViewExecute(hCleanUpTable, 0);

	// Read Component path registration data into the database and compute original
	// MSI-based SharedDLL reference counts.
	if (ERROR_SUCCESS == dwResult)
		dwResult = ReadComponentRegistrationDataIntoDatabase(hDatabase);

	// Read FeatureComponent data into the database
	if (ERROR_SUCCESS == dwResult)
		dwResult = ReadFeatureRegistrationDataIntoDatabase(hDatabase);
		
	// It doesn't matter if feature usage data gets migrated completely or not
	if (ERROR_SUCCESS == dwResult)
		ReadFeatureUsageDataIntoDatabase(hDatabase);

	// UserProduct mappings determine which users have products installed
	if (ERROR_SUCCESS == dwResult)
		dwResult = BuildUserProductMapping(hDatabase, fReadHKCUAsSystem);

	// tickles all cached patches to determine what potential products they
	// could be applied to. This info is used to migrate non-managed per-user
	// installs.
	if (ERROR_SUCCESS == dwResult)
		dwResult = ScanCachedPatchesForProducts(hDatabase);

	// cross-references per-user non-managed installs with patch data from 
	// above. Creates a list of patches that could be applied to each
	// per-user install.
	if (ERROR_SUCCESS == dwResult)
		dwResult = AddPerUserPossiblePatchesToPatchList(hDatabase);

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiregmv\patch.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       patch.cpp
//
//--------------------------------------------------------------------------

#include "msiregmv.h"
#include <strsafe.h>

////
// cached patch information
const TCHAR szOldPatchesKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Patches");
const TCHAR szOldPatchesSubKeyName[] = TEXT("Patches");
const TCHAR szOldPatchListValueName[] = TEXT("Patches");
const TCHAR szOldLocalPatchValueName[] = TEXT("LocalPackage");
const TCHAR szNewLocalPatchValueName[] = TEXT("LocalPackage");
const TCHAR szPatchExtension[] = TEXT(".msp");
const TCHAR szNewMigratedPatchesValueName[] = TEXT("MigratedPatches");

#define PID_TEMPLATE      7  // string


///////////////////////////////////////////////////////////////////////
// Reads patch application data from the provided old-format product
// key and inserts User/Product/Patch tuples into the PatchApply table
// Returns ERROR_SUCCESS, ERROR_FUNCTION_FAILED, ERROR_OUTOFMEMORY;
DWORD AddProductPatchesToPatchList(MSIHANDLE hDatabase, HKEY hProductListKey, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1], eManagedType eManaged)
{
	DWORD dwResult = ERROR_SUCCESS;

	HKEY hOldProductKey;
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hProductListKey, rgchProduct, 
								   0, KEY_ENUMERATE_SUB_KEYS, &hOldProductKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no product key.
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG2("Error: Failed to open product key for product %s. Result: %d.", rgchProduct, dwResult);
			return ERROR_FUNCTION_FAILED;
		}
		return ERROR_SUCCESS;
	}

	// open the "patches" subkey under the old product registration. 
	HKEY hOldPatchesKey;
	dwResult = RegOpenKeyEx(hOldProductKey, szOldPatchesSubKeyName, 0, KEY_QUERY_VALUE, &hOldPatchesKey);
	RegCloseKey(hOldProductKey);
	if (ERROR_SUCCESS != dwResult)
	{
		// if the reason that this failed is that the key doesn't exist, no patches.		
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG2("Error: Failed to open local patches key for product %s. Result: %d.", rgchProduct, dwResult);
			return ERROR_FUNCTION_FAILED;
		}
		return ERROR_SUCCESS;
	}
			
	// query for a value with name=Patches
	DWORD cchPatchList = MEMORY_DEBUG(MAX_PATH);
	TCHAR *szPatchList = new TCHAR[cchPatchList];
	if (!szPatchList)
	{
		DEBUGMSG("Error: Out of memory.");
		RegCloseKey(hOldPatchesKey);
		return ERROR_OUTOFMEMORY;
	}

	// Patches value is arbitrary length REG_MULT_SZ containing patch codes.
	DWORD cbPatchList = cchPatchList*sizeof(TCHAR);
	if (ERROR_MORE_DATA == (dwResult = RegQueryValueEx(hOldPatchesKey, szOldPatchListValueName, 0, NULL, reinterpret_cast<unsigned char*>(szPatchList), &cbPatchList)))
	{
		delete[] szPatchList;
		szPatchList = new TCHAR[cbPatchList/sizeof(TCHAR)];
		if (!szPatchList)
		{
			DEBUGMSG("Error: Out of memory.");
			RegCloseKey(hOldPatchesKey);
			return ERROR_OUTOFMEMORY;
		}
		dwResult = RegQueryValueEx(hOldPatchesKey, szOldPatchListValueName, 0, NULL, reinterpret_cast<unsigned char*>(szPatchList), &cbPatchList);
	}
	RegCloseKey(hOldPatchesKey);

	if (ERROR_SUCCESS == dwResult)
	{
		PMSIHANDLE hPatchView;
		if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `PatchApply`"), &hPatchView)) ||
			ERROR_SUCCESS != (dwResult = MsiViewExecute(hPatchView, 0)))
		{
			DEBUGMSG3("Error: Unable to create Patch insertion Query for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
			return ERROR_FUNCTION_FAILED;
		}

		PMSIHANDLE hInsertRec = MsiCreateRecord(4);
		MsiRecordSetString(hInsertRec, 1, szUser);
		MsiRecordSetString(hInsertRec, 2, rgchProduct);
		MsiRecordSetInteger(hInsertRec, 4, 1);

    	// loop through all patches in the patch list
		TCHAR* szNextPatch = szPatchList;
		while (szNextPatch && *szNextPatch)
		{
			TCHAR *szPatch = szNextPatch;

			// '\0' is never a valid lead byte, so no DBCS concerns here.
			while (*szNextPatch)
				szNextPatch++;
				
			// increment szNextPatch to the first character of the new patch.
			szNextPatch++;

			// check if the product is a valid guid
			if (!CanonicalizeAndVerifyPackedGuid(szPatch))
			{
				// patch code is not a valid packed GUID, skip to the next product
				DEBUGMSG3("Warning: Found invalid patch code %s for user %s, product %s. Skipping.", szPatch, szUser, rgchProduct);
				dwResult = ERROR_SUCCESS;
				continue;
			}

			MsiRecordSetString(hInsertRec, 3, szPatch);
			if (ERROR_SUCCESS != (dwResult = MsiViewModify(hPatchView, MSIMODIFY_INSERT, hInsertRec)))
			{
				DEBUGMSG4("Warning: Failed to insert patch %s for user %s, product %s. Result: %d", szPatch, szUser, rgchProduct, dwResult);
				dwResult = ERROR_FUNCTION_FAILED;
				break;
			}
		}
	}
	else if (dwResult != ERROR_FILE_NOT_FOUND)
	{
		DEBUGMSG3("Error: Could not retrieve patch information for user %s, product %s. Result: %d. ", szUser, rgchProduct, dwResult);
	}
	else
		dwResult = ERROR_SUCCESS;

	delete[] szPatchList;
	return dwResult;
}


///////////////////////////////////////////////////////////////////////
// Given a patch code and user makes a copy of the cached patches for
// that user and registers the filenames under the per-user patch key. 
// Returns one of ERROR_SUCCESS and ERROR_OUTOFMEMORY. Does NOT return
// ERROR_FUNCTION_FAILED, as all patches are recachable from source.
DWORD MigrateUserPatches(MSIHANDLE hDatabase, LPCTSTR szUser, HKEY hNewPatchesKey, bool fCopyCachedPatches)
{	
	DWORD dwResult = ERROR_SUCCESS;

	PMSIHANDLE hQueryRec = ::MsiCreateRecord(1);
	MsiRecordSetString(hQueryRec, 1, szUser);

	// open query on the PatchApply table, which mapps users to products to patch codes
	PMSIHANDLE hPatchView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Patch` FROM `PatchApply` WHERE `User`=?"), &hPatchView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hPatchView, hQueryRec)))
	{
		DEBUGMSG2("Warning: Unable to create Patch Query for user %s. Result: %d.", szUser, dwResult);
		return ERROR_SUCCESS;;
	}

	// open the old localpatch registry key containing cached patch filenames
	HKEY hOldLocalPatchKey;
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldPatchesKeyName, 0, KEY_ENUMERATE_SUB_KEYS, &hOldLocalPatchKey)))
	{
		// if the reason that this failed is that the key doesn't exist, patch is missing. So return success
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Warning: Failed to open old patches key. Result: %d.", dwResult);
		}
		return ERROR_SUCCESS;
	}

	// create insert query for files that should be cleaned up on failure or success. If this fails
	// we'll just orphan a file if migration fails.
	PMSIHANDLE hCleanUpTable;
	if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `CleanupFile`"), &hCleanUpTable))
		dwResult = MsiViewExecute(hCleanUpTable, 0);

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// retrieve the installer directory for new cached files
	TCHAR rgchInstallerDir[MAX_PATH];
	GetWindowsDirectory(rgchInstallerDir, MAX_PATH);
	lstrcat(rgchInstallerDir, szInstallerDir);

	int iBasePathEnd = lstrlen(rgchInstallerDir);

	// create new full-path to patch
	TCHAR rgchPatchFullPath[MAX_PATH];
	lstrcpy(rgchPatchFullPath, rgchInstallerDir);

	// loop through the PatchApply table, retrieving patch codes relevant to this
	// user.
	PMSIHANDLE hPatch;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hPatchView, &hPatch)))
	{
		// get the patch code from the result record
		TCHAR rgchPatchCode[cchGUIDPacked+1];
		DWORD cchPatchCode = cchGUIDPacked+1;
		if (ERROR_SUCCESS != MsiRecordGetString(hPatch, 1, rgchPatchCode, &cchPatchCode))
		{
			DEBUGMSG1("Warning: Unable to retrieve patch code for migration. Result: %d. Skipping.", dwResult);
			continue;
		}
    				
		NOTEMSG1("Migrating patch %s.", rgchPatchCode);

		// open the old patch key
		HKEY hOldPatchKey;
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hOldLocalPatchKey, rgchPatchCode, 0, KEY_QUERY_VALUE, &hOldPatchKey)))
		{
			// if the reason that this failed is that the key doesn't exist, patch is missing.
			if (ERROR_FILE_NOT_FOUND != dwResult)
			{
				DEBUGMSG1("Warning: Failed to open local patch key. Result: %d.", dwResult);
			}
			continue;
		}

		// read the cache patch location
		DWORD cchFileName = MEMORY_DEBUG(MAX_PATH);
		TCHAR *szFileName = new TCHAR[cchFileName];
		DWORD cbFileName = cchFileName*sizeof(TCHAR);
		if (ERROR_MORE_DATA == (dwResult = RegQueryValueEx(hOldPatchKey, szOldLocalPatchValueName, 0, NULL, reinterpret_cast<unsigned char*>(szFileName), &cbFileName)))
		{
			delete[] szFileName;
			szFileName = new TCHAR[cbFileName/sizeof(TCHAR)];
			dwResult = RegQueryValueEx(hOldPatchKey, szOldLocalPatchValueName, 0, NULL, reinterpret_cast<unsigned char*>(szFileName), &cbFileName);
		}
		RegCloseKey(hOldPatchKey);
		if (dwResult != ERROR_SUCCESS)
		{
			DEBUGMSG2("Warning: Failed to retrieve cached path for path %s. Result: %d.", rgchPatchCode, dwResult);
			continue;
		}


		// check for existance of cached patch and open the file
		HANDLE hSourceFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
		DWORD dwLastError = GetLastError();

		if(hSourceFile == INVALID_HANDLE_VALUE)
		{
			delete[] szFileName;
			if (dwLastError != ERROR_FILE_NOT_FOUND)
			{
				DEBUGMSG3("Warning: Unable to open cached patch %s for user %s. Result: %d.", rgchPatchCode, szUser, dwResult);
				continue;
			}
			else
				// patch is missing. No big deal.
				continue;
		}
	
		// create the new patch key under the per-user "Patches" key
		HKEY hPatchKey;
		if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hNewPatchesKey, rgchPatchCode, &sa, &hPatchKey)))
		{
			DEBUGMSG3("Warning: Unable to create new patch key for user %s, patch %s. Result: %d.", szUser, rgchPatchCode, dwResult);
			delete[] szFileName;
			continue;
		}

		// if we are supposed to copy the patch file, generate a temp name. Otherwise just register
		// the existing path
		TCHAR* szNewPatchFile = 0;
		if (fCopyCachedPatches)
		{
			// generated patch names are 8.3
			TCHAR rgchPatchFile[13];
			HANDLE hDestFile = INVALID_HANDLE_VALUE;
			GenerateSecureTempFile(rgchInstallerDir, szPatchExtension, &sa, rgchPatchFile, hDestFile);
	
			if (!CopyOpenedFile(hSourceFile, hDestFile))
			{
				DEBUGMSG2("Warning: Unable to copy cached patch %s for user %s.", rgchPatchCode, szUser);
			}
	
			CloseHandle(hSourceFile);
			CloseHandle(hDestFile);
	
			// add the new patch to the "delete on failure" list.
			StringCchCopy(&rgchPatchFullPath[iBasePathEnd], ((sizeof(rgchPatchFullPath)/sizeof(TCHAR)) - iBasePathEnd), rgchPatchFile);
			PMSIHANDLE hFileRec = MsiCreateRecord(2);
			MsiRecordSetString(hFileRec, 1, rgchPatchFullPath);
			MsiRecordSetInteger(hFileRec, 2, 0);
			MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);

			szNewPatchFile = rgchPatchFullPath;
		}
		else
			szNewPatchFile = szFileName;

		// set the new patch value
		if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hPatchKey, szNewLocalPatchValueName, 0, REG_SZ, 
				reinterpret_cast<unsigned char*>(szNewPatchFile), (lstrlen(szNewPatchFile)+1)*sizeof(TCHAR))))
		{
			DEBUGMSG3("Warning: Unable to create new LocalPackage value for user %s, patch %s. Result: %d.", szUser, szNewPatchFile, dwResult);
		}
		RegCloseKey(hPatchKey);

		delete[] szFileName;
	}

	RegCloseKey(hOldLocalPatchKey);

	return ERROR_SUCCESS;
}




///////////////////////////////////////////////////////////////////////
// Given a product code and user, checks for any "guessed" patch
// applications and registers the list of applicable patches under
// the InstallProperties key so they can be removed on uninstall. 
// Returns ERROR_SUCCESS or ERROR_OUTOFMEMORY. Doen NOT return
// ERROR_FUNCTION_FAILED, as failure merely orphans a patch until
// another product using the patch is installed.
DWORD MigrateUnknownProductPatches(MSIHANDLE hDatabase, HKEY hProductKey, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1])
{	
	DWORD dwResult = ERROR_SUCCESS;

	PMSIHANDLE hQueryRec = ::MsiCreateRecord(2);
	MsiRecordSetString(hQueryRec, 1, szUser);
	MsiRecordSetString(hQueryRec, 2, rgchProduct);

	// open query on the PatchApply table, which mapps users to products to patch codes. Search
	// for "guessed" application of a patch.
	PMSIHANDLE hPatchView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Patch` FROM `PatchApply` WHERE `User`=? AND `Product`=? AND `Known`=0"), &hPatchView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hPatchView, hQueryRec)))
	{
		DEBUGMSG2("Warning: Unable to create Patch Query for user %s. Result: %d.", szUser, dwResult);
		return ERROR_SUCCESS;;
	}

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// query for at least one patch applied to this product that was a guess.
    PMSIHANDLE hPatch;
	if (ERROR_SUCCESS == (dwResult = MsiViewFetch(hPatchView, &hPatch)))
	{
		PMSIHANDLE hGuessedPatchView;
		if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Patch` FROM `PatchApply` WHERE `User`=? AND `Product`=?"), &hGuessedPatchView)) ||
			ERROR_SUCCESS != (dwResult = MsiViewExecute(hGuessedPatchView, hQueryRec)))
		{
			DEBUGMSG2("Warning: Unable to create Patch Query for user %s. Result: %d.", szUser, dwResult);
			return ERROR_SUCCESS;;
		}

		// allocate initial buffer for patch list
		DWORD cchPatchList = 1;
		TCHAR *szPatchList = new TCHAR[cchPatchList];
		if (!szPatchList)
		{
			DEBUGMSG("Error: Out of memory.");
			return ERROR_OUTOFMEMORY;
		}
		DWORD cchNextPatchStart = 0;
		*szPatchList = 0;

		// loop through the PatchApply table, retrieving patch codes relevant to this
		// product that are guesses.
		while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hGuessedPatchView, &hPatch)))
		{
			// get the patch code from the result record
			TCHAR rgchPatchCode[cchGUIDPacked+1];
			DWORD cchPatchCode = cchGUIDPacked+1;
			if (ERROR_SUCCESS != MsiRecordGetString(hPatch, 1, rgchPatchCode, &cchPatchCode))
			{
				DEBUGMSG3("Warning: Unable to retrieve patch code for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
				continue;
			}

			// expand the patch list to hold the new patch
			TCHAR *szTempList = new TCHAR[cchPatchList+cchGUIDPacked+1];
			if (!szTempList)
			{
				delete[] szPatchList;
				DEBUGMSG("Error: Out of memory.");
				return ERROR_OUTOFMEMORY;
			}

			// copy the data over. Can contain embedded '\0' characters.
			for (DWORD i=0; i < cchPatchList; i++)
				szTempList[i] = szPatchList[i];
			
			delete[] szPatchList;
			cchPatchList += cchGUIDPacked+1;
			szPatchList = szTempList;

			// copy the new patch to the end of the list and ensure the double
			// '\0' exists at the end.
			lstrcpy(szPatchList+cchNextPatchStart, rgchPatchCode);
			cchNextPatchStart += cchGUIDPacked+1;
			*(szPatchList+cchNextPatchStart)='\0';
		}
	
		// if no patches were retrieved, the next patch is the beginning of the string. 
		// No need to write the MigratedPatches.
		if (cchNextPatchStart != 0)
		{
			// create the new InstallProperties key under the per-user "Patches" key
			HKEY hPropertiesKey;
			if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hProductKey, szNewInstallPropertiesSubKeyName, &sa, &hPropertiesKey)))
			{
				DEBUGMSG3("Unable to create new InstallProperties key for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
			}
			else
			{
				// set the new patch value.
				DWORD cbPatchList = cchPatchList*sizeof(TCHAR);
				if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hPropertiesKey, szNewMigratedPatchesValueName, 0, REG_MULTI_SZ, 
						reinterpret_cast<unsigned char*>(szPatchList), cbPatchList)))
				{
					DEBUGMSG3("Unable to create new MigratedPatches value for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
				}
				RegCloseKey(hPropertiesKey);
			}
		}
		delete[] szPatchList;
	}

	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Reads the PatchUnknownApply table for patches that might (or might
// not) apply to non-managed products and inserts a row 
// in the PatchApply table for each potential application of 
// a patch (excluding the current user). Returns ERROR_SUCCESS, 
// ERROR_FUNCTION_FAILED, ERROR_OUTOFMEMORY
DWORD AddPerUserPossiblePatchesToPatchList(MSIHANDLE hDatabase)
{
	// read the Product table for products installed per user to
	// a different user
	PMSIHANDLE hProductView;
	PMSIHANDLE hQueryRec = MsiCreateRecord(1);
	TCHAR szSID[cchMaxSID] = TEXT("");

	// if we can't retrieve the current users string SID, we'll just accidentally migrate
	// a few patches that we shouldn't. 
	DWORD dwResult = GetCurrentUserStringSID(szSID);
	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG("Warning: Unable to retrieve current user SID during patch migration.");
	}

	// create product selection query
	MsiRecordSetString(hQueryRec, 1, szSID);
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Product`, `User`, 0, 0 FROM `Products` WHERE `Managed`=0 AND `User`<>?"), &hProductView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hProductView, hQueryRec)))
	{
		DEBUGMSG1("Error: Unable to create patch product query. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// create patch selection query
	PMSIHANDLE hPatchUnknownView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Patch` FROM `PatchUnknownApply` WHERE `Product`=?"), &hPatchUnknownView)))
	{
		DEBUGMSG1("Error: Unable to create patch application query. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// create insertion query. Columns selected in non-standard order to match product query above.
	PMSIHANDLE hPatchInsertView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Product`, `User`, `Patch`, `Known`  FROM `PatchApply`"), &hPatchInsertView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hPatchInsertView, 0)))
	{
		DEBUGMSG1("Error: Unable to create Patch insertion Query. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hProduct;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hProductView, &hProduct)))
	{
		MsiViewExecute(hPatchUnknownView, hProduct);

		PMSIHANDLE hPatch;
		while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hPatchUnknownView, &hPatch)))
		{
			TCHAR rgchPatch[cchGUIDPacked+1];
			DWORD cchPatch = cchGUIDPacked+1;
			MsiRecordGetString(hPatch, 1, rgchPatch, &cchPatch);
			MsiRecordSetString(hProduct, 3, rgchPatch);
			if (ERROR_SUCCESS != (dwResult = MsiViewModify(hPatchInsertView, MSIMODIFY_INSERT, hProduct)))
			{
				DEBUGMSG2("Warning: Could not insert patch %s via assumed application. Result %d", rgchPatch, dwResult);
				continue;
			}
		}
	}
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Opens the old-style Patches key, reads the path to each cached
// patch, and opens the patch to get the ProductCodes that the patch
// applies to from the SummaryInfo. Inserts a row for each patch/product
// mapping into the PatchUnknownApply table. Returns ERROR_SUCCESS or
// ERROR_OUTOFMEMORY. Does not return ERROR_FUNCTION_FAILED, since
// failure to read this information only results in a lost patch.
DWORD ScanCachedPatchesForProducts(MSIHANDLE hDatabase)
{
	DWORD dwResult = ERROR_SUCCESS;

	// create old patch cache directory
	TCHAR rgchInstallerDir[MAX_PATH];
	GetWindowsDirectory(rgchInstallerDir, MAX_PATH);
	lstrcat(rgchInstallerDir, szInstallerDir);

	int iBasePathEnd = lstrlen(rgchInstallerDir);


	// create the PatchUnknownApply table.
	PMSIHANDLE hTableView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `PatchUnknownApply` (`Patch` CHAR(32) NOT NULL, `Product` CHAR(32) NOT NULL PRIMARY KEY `Patch`,`Product`)"), &hTableView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hTableView, 0)))
	{
		DEBUGMSG1("Error: Unable to create PatchUnknownApply table. Error %d", dwResult);
		return ERROR_SUCCESS;
	}

	// open the old patch key
	HKEY hOldPatchKey;
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldPatchesKeyName, 0, KEY_ENUMERATE_SUB_KEYS, &hOldPatchKey)))
	{
		// if the reason that this failed is that the key doesn't exist, there are no patches
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Failed to open local patch key. Result: %d.", dwResult);
		}
		return ERROR_SUCCESS;
	}

	// create insert query for files that should be cleaned up on success. If this fails
	// we'll just orphan a file if migration fails.
	PMSIHANDLE hCleanUpTable;
	if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `CleanupFile`"), &hCleanUpTable))
		dwResult = MsiViewExecute(hCleanUpTable, 0);

	// open insert query on PatchUnknownApply
	PMSIHANDLE hPatchView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `PatchUnknownApply`"), &hPatchView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hPatchView, 0)))
	{
		DEBUGMSG1("Error: Unable to create PatchUnknownApply insertion query. Result: %d.", dwResult);
		RegCloseKey(hOldPatchKey);
		return ERROR_SUCCESS;
	}

	PMSIHANDLE hInsertRec = MsiCreateRecord(2);

	// enumerate all cached patches
	DWORD dwKeyIndex = 0;
	while (1)
	{
		DWORD cchPatchCode = cchGUIDPacked+1;
		TCHAR rgchPatchCode[cchGUIDPacked+1];
		LONG lResult = RegEnumKeyEx(hOldPatchKey, dwKeyIndex++, rgchPatchCode, 
									&cchPatchCode, 0, NULL, NULL, NULL);
		if (lResult == ERROR_MORE_DATA)
		{
			// value is not a valid patch Id, skip it
			DEBUGMSG("Warning: Detected too-long pach code. Skipping.");
			continue;
		}
		else if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG1("Error: Could not enumerate patches. Result: %l.", lResult);
			break;
		}

		// have a patch code, open its subkey.
		HKEY hPerPatchKey;
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hOldPatchKey, rgchPatchCode, 0, KEY_QUERY_VALUE, &hPerPatchKey)))
		{
			if (ERROR_FILE_NOT_FOUND != dwResult)
			{
				DEBUGMSG2("Error: Failed to open patch key for %s. Result: %d. Skipping.", rgchPatchCode, dwResult);
			}
			continue;
		}
		else
		{
			MsiRecordSetString(hInsertRec, 1, rgchPatchCode);

			// read the cache patch location
			DWORD cchFileName = MEMORY_DEBUG(MAX_PATH);
			TCHAR *szFileName = new TCHAR[cchFileName];
			if (!szFileName)
			{
				DEBUGMSG("Error: Out of memory.");
				RegCloseKey(hPerPatchKey);
				RegCloseKey(hOldPatchKey);
				return ERROR_SUCCESS;
			}
			DWORD cbFileName = cchFileName*sizeof(TCHAR);
			if (ERROR_MORE_DATA == (dwResult = RegQueryValueEx(hPerPatchKey, szOldLocalPatchValueName, 0, NULL, reinterpret_cast<unsigned char*>(szFileName), &cbFileName)))
			{
				delete[] szFileName;
				szFileName = new TCHAR[cbFileName/sizeof(TCHAR)];
				if (!szFileName)
				{
					DEBUGMSG("Error: Out of memory.");
					RegCloseKey(hPerPatchKey);
					RegCloseKey(hOldPatchKey);
					return ERROR_SUCCESS;
				}
				dwResult = RegQueryValueEx(hPerPatchKey, szOldLocalPatchValueName, 0, NULL, reinterpret_cast<unsigned char*>(szFileName), &cbFileName);
			}
			RegCloseKey(hPerPatchKey);
   			if (ERROR_SUCCESS != dwResult)
			{
				// if the LocalPackage value is missing, this is not an error, there
				// is simply no cached patch.
				if (ERROR_FILE_NOT_FOUND != dwResult)
				{
					DEBUGMSG2("Warning: Failed to retrieve local patch path for patch %s. Result %d. Skipping.", rgchPatchCode, dwResult);
				}
				continue;
			}

			// add the new transform to the "delete on success" list.
			PMSIHANDLE hFileRec = MsiCreateRecord(2);
			MsiRecordSetString(hFileRec, 1, szFileName);
			MsiRecordSetInteger(hFileRec, 2, 1);
			MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);


			// get the summaryinfo stream from the patch
			PMSIHANDLE hSummary;
            dwResult = MsiGetSummaryInformation(0, szFileName, 0, &hSummary);
			delete[] szFileName;

			if (ERROR_SUCCESS == dwResult)
			{
				// retrieve the list of product codes from the patch summaryinfo
				DWORD cchProductList = MEMORY_DEBUG(MAX_PATH);
				TCHAR *szProductList = new TCHAR[cchProductList];
				if (!szProductList)
				{
					DEBUGMSG("Error: Out of memory.");
					RegCloseKey(hOldPatchKey);
					return ERROR_SUCCESS;
				}
				if (ERROR_MORE_DATA == (dwResult = MsiSummaryInfoGetProperty(hSummary, PID_TEMPLATE, NULL, NULL, NULL, szProductList, &cchProductList)))
				{
					delete[] szProductList;
					szProductList = new TCHAR[++cchProductList];
					if (!szProductList)
					{
						DEBUGMSG("Error: Out of memory.");
						RegCloseKey(hOldPatchKey);
						return ERROR_SUCCESS;
					}
					dwResult = MsiSummaryInfoGetProperty(hSummary, PID_TEMPLATE, NULL, NULL, NULL, szProductList, &cchProductList);
				}

				if (ERROR_SUCCESS != dwResult)
				{
					delete[] szProductList;
					DEBUGMSG2("Warning: Unable to retrieve product list from cached patch %s. Result: %d. Skipping.", rgchPatchCode, dwResult);
					continue;
				}

				// loop through the product list, searching for semicolon delimiters
				TCHAR *szNextProduct = szProductList;
				while (szNextProduct && *szNextProduct)
				{
					TCHAR *szProduct = szNextProduct;

					// string should be all product codes (no DBCS). If there is
					// DBCS, its an invalid patch code anyway
					while (*szNextProduct && *szNextProduct != TEXT(';'))
						szNextProduct++;

					// if reached the null terminator, don't increment past it. But if
					// reached a semicolon, increment the next product pointer to the 
					// beginning of the actual product code.
					if (*szNextProduct)
						*(szNextProduct++)='\0';

					TCHAR rgchProduct[cchGUIDPacked+1];
					if (!PackGUID(szProduct, rgchProduct))
					{
						DEBUGMSG2("Warning: Invalid product code %s found in application list of patch %s. Skipping.", szProduct, rgchPatchCode);
						continue;
					}

					MsiRecordSetString(hInsertRec, 2, rgchProduct);

					if (ERROR_SUCCESS != (dwResult = MsiViewModify(hPatchView, MSIMODIFY_INSERT, hInsertRec)))
					{
						DEBUGMSG3("Warning: Failed to insert potential patch application for patch %s, product %s. Result: %d", rgchPatchCode, szProduct, dwResult);
						continue;
					}
				}
			
				delete[] szProductList;
			}
			// MSIHANDLES for SummaryInfo goes out of scope here
		}
	}

	RegCloseKey(hOldPatchKey);
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiregmv\msiregmv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msiregmv.h
//
//--------------------------------------------------------------------------

#pragma once
#include <windows.h>
#include <tchar.h>
#include <strsafe.h>
#include "msiquery.h"

												  
// based off on values from winnt.h
const int cbMaxSID                   = sizeof(SID) + SID_MAX_SUB_AUTHORITIES*sizeof(DWORD);
const int cchMaxSID                  = 256;
const int cchGUIDPacked = 32;
const int cchGUID = 38;

////
// miscellaneous functions
bool CanonicalizeAndVerifyPackedGuid(LPTSTR szString);
bool PackGUID(const TCHAR* szGUID, TCHAR rgchPackedGUID[cchGUIDPacked+1]);
bool UnpackGUID(const TCHAR rgchPackedGUID[cchGUIDPacked+1], TCHAR* szGUID);
bool CheckWinVersion();

////
// security functions
bool FIsKeyLocalSystemOrAdminOwned(HKEY hKey);
DWORD GetCurrentUserStringSID(TCHAR* szSID);
DWORD GetSecureSecurityDescriptor(char** pSecurityDescriptor);
DWORD GetEveryoneUpdateSecurityDescriptor(char** pSecurityDescriptor);

DWORD GenerateSecureTempFile(TCHAR* szDirectory, const TCHAR rgchExtension[5], 
							 SECURITY_ATTRIBUTES *pSA, TCHAR rgchFilename[13], HANDLE &hFile);

bool DeleteRegKeyAndSubKeys(HKEY hKey, const TCHAR *szSubKey);
BOOL CopyOpenedFile(HANDLE hSourceFile, HANDLE hDestFile);
DWORD CreateSecureRegKey(HKEY hParent, LPCTSTR szNewKey, SECURITY_ATTRIBUTES *sa, HKEY* hResKey);
void AcquireTakeOwnershipPriv();
void AcquireBackupPriv();


// enum for managed attribute
enum eManagedType
{
	emtNonManaged = 0,
	emtUserManaged = 1,
	emtMachineManaged = 2,
};

////
// debug information
void DebugOut(bool fDebugOut, LPCTSTR str, ...);

#ifdef DEBUG
#define DEBUGMSG(x) DebugOut(true, TEXT(x))
#define DEBUGMSG1(x,a) DebugOut(true, TEXT(x),a)
#define DEBUGMSG2(x,a,b) DebugOut(true, TEXT(x),a,b)
#define DEBUGMSG3(x,a,b,c) DebugOut(true, TEXT(x),a,b,c)
#define DEBUGMSG4(x,a,b,c,d) DebugOut(true, TEXT(x),a,b,c,d)

// basically just printf, but can easily be changed to write to 
// debug output by passing "true". Used for "notification" 
// messages that shouldn't be part of debug spooge.
#define NOTEMSG(x) DebugOut(false, TEXT(x))
#define NOTEMSG1(x,a) DebugOut(false, TEXT(x),a)

// all resizable buffers start out at this size in debug builds.
// set this to a small number to force reallocations
#define MEMORY_DEBUG(x) 10

#else
#define DEBUGMSG(x)
#define DEBUGMSG1(x,a)
#define DEBUGMSG2(x,a,b)
#define DEBUGMSG3(x,a,b,c)
#define DEBUGMSG4(x,a,b,c,d)
#define NOTEMSG(x)
#define NOTEMSG1(x,a)

#define MEMORY_DEBUG(x) x
#endif

DWORD ReadProductRegistrationDataIntoDatabase(TCHAR* szDatabase, MSIHANDLE& hDatabase, bool fReadHKCUAsSystem);
DWORD WriteProductRegistrationDataFromDatabase(MSIHANDLE hDatabase, bool fMigrateSharedDLL, bool fMigratePatches);
DWORD UpdateSharedDLLRefCounts(MSIHANDLE hDatabase);
DWORD ReadComponentRegistrationDataIntoDatabase(MSIHANDLE hDatabase);
DWORD MigrateUserOnlyComponentData(MSIHANDLE hDatabase);

extern bool g_fWin9X;

////
// cached data functions
DWORD MigrateCachedDataFromWin9X(MSIHANDLE hDatabase, HKEY hUserHKCUKey, HKEY hUserDataKey, LPCTSTR szUser);


////
// patch functions
DWORD AddProductPatchesToPatchList(MSIHANDLE hDatabase, HKEY hProductListKey, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1], eManagedType eManaged);
DWORD MigrateUnknownProductPatches(MSIHANDLE hDatabase, HKEY hProductKey, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1]);
DWORD MigrateUserPatches(MSIHANDLE hDatabase, LPCTSTR szUser, HKEY hNewPatchesKey, bool fCopyCachedPatches);
DWORD ScanCachedPatchesForProducts(MSIHANDLE hDatabase);
DWORD AddPerUserPossiblePatchesToPatchList(MSIHANDLE hDatabase);


////
// cleanup functions
void CleanupOnFailure(MSIHANDLE hDatabase);
void CleanupOnSuccess(MSIHANDLE hDatabase);


const TCHAR szLocalSystemSID[] = TEXT("S-1-5-18");
const TCHAR szCommonUserSID[] = TEXT("CommonUser");

const TCHAR szLocalPackagesKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\LocalPackages");

const TCHAR szManagedPackageKeyEnd[] = TEXT("(Managed)");
const DWORD cchManagedPackageKeyEnd = sizeof(szManagedPackageKeyEnd)/sizeof(TCHAR);


////
// product source registry keys
const TCHAR szPerMachineInstallKeyName[] = TEXT("Software\\Classes\\Installer\\Products");
const TCHAR szPerUserInstallKeyName[] = TEXT("Software\\Microsoft\\Installer\\Products");
const TCHAR szPerUserManagedInstallKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Managed");
const TCHAR szPerUserManagedInstallSubKeyName[] = TEXT("\\Installer\\Products");
const int cchPerUserManagedInstallKeyName = sizeof(szPerUserManagedInstallKeyName)/sizeof(TCHAR);
const DWORD cchPerUserManagedInstallSubKeyName = sizeof(szPerUserManagedInstallSubKeyName)/sizeof(TCHAR);
const TCHAR szNewProductSubKeyName[] = TEXT("Products");


////
// some generic paths used in multiple places
const TCHAR szNewInstallPropertiesSubKeyName[] = TEXT("InstallProperties");
const TCHAR szInstallerDir[] = TEXT("\\Installer\\");
const TCHAR szNewPatchesSubKeyName[] = TEXT("Patches");
const TCHAR szTransformsValueName[] = TEXT("Transforms");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msiregmv\writecfg.cpp ===
#include <windows.h>
#include <tchar.h>
#include <strsafe.h>

#include "msiregmv.h"

const TCHAR szNewComponentSubKeyName[] = TEXT("Components");
const TCHAR szNewFeaturesSubKeyName[] = TEXT("Features");
const TCHAR szNewFeatureUsageSubKeyName[] = TEXT("Usage");
const TCHAR szNewBaseUserKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData");

////
// cached package registration information
const TCHAR szNewLocalPackagesValueName[] = TEXT("LocalPackage");
const TCHAR szNewLocalPackagesManagedValueName[] = TEXT("ManagedLocalPackage");
const TCHAR szPackageExtension[] = TEXT(".msi");

////
// cached transform information
const TCHAR szSecureTransformsDir[] = TEXT("\\SecureTransforms\\");
const TCHAR szNewTransformsSubKeyName[] = TEXT("Transforms");
const TCHAR szTransformExtension[] = TEXT(".mst");

////
// Shared DLL information
const TCHAR szSharedDLLKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs");

////
// uninstall information
const TCHAR szOldUninstallKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall");



///////////////////////////////////////////////////////////////////////
// Given a record containing <Path, Component, AlternatePath>, a 
// registry key, and a productcode, creates \Component!Product=Path
// registry value. Returns ERROR_SUCCESS, ERROR_OUTOFMEMORY, 
// ERROR_FUNCTION_FAILED. szUser is just for logging.
DWORD WriteComponentData(HKEY hComponentListKey, MSIHANDLE hComponentRec, TCHAR rgchProduct[cchGUIDPacked+1], LPCTSTR szUser, MSIHANDLE hRefCountUpdateView)
{
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	TCHAR rgchComponent[cchGUIDPacked+1];
	DWORD cchComponent = cchGUIDPacked+1;
	MsiRecordGetString(hComponentRec, 2, rgchComponent, &cchComponent);
	
	DWORD cchPathBuf = MEMORY_DEBUG(MAX_PATH);
	TCHAR *szPath = new TCHAR[cchPathBuf];
	if (!szPath)
	{
		DEBUGMSG("Error: Out of memory");
		return ERROR_OUTOFMEMORY;
	}
	
	DWORD dwType = REG_SZ;
	DWORD cchPath = cchPathBuf;
	if (ERROR_MORE_DATA == (dwResult = MsiRecordGetString(hComponentRec, 1, szPath, &cchPath)))
	{
		delete[] szPath;
		cchPathBuf = ++cchPath;
		szPath = new TCHAR[cchPathBuf];
		if (!szPath)
		{
			DEBUGMSG("Error: Out of memory");
			return ERROR_OUTOFMEMORY;
		}
		dwResult = MsiRecordGetString(hComponentRec, 1, szPath, &cchPath);
	}
	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG4("Error: Unable to retrive component path for user %s, component %s, product %s. Result: %d.", szUser, rgchComponent, rgchProduct, dwResult);
		return ERROR_SUCCESS;
	}

	// if the third coulmn is not null, there is a secondary keypath (used for detecting HKCR components
	// for per-user installs)		
	if (!::MsiRecordIsNull(hComponentRec, 3))
	{
		// secondary keypaths require a MULT_SZ value type
		dwType = REG_MULTI_SZ;

		// retrieve the secondary keypath into the same buffer as the primary, but separated by
		// a NULL character.
		DWORD cchSecondaryPath = cchPathBuf-cchPath-1;
		if (ERROR_MORE_DATA == (dwResult = MsiRecordGetString(hComponentRec, 3, szPath+cchPath+1, &cchSecondaryPath)))
		{
			// must have space for 3 nulls, (1 in middle, two at end)
			cchPathBuf = cchPath+1+cchSecondaryPath+2;
			TCHAR *szNewPath = new TCHAR[cchPathBuf];
			if (!szNewPath)
			{
				delete[] szPath;
				DEBUGMSG("Error: Out of memory");
				return ERROR_OUTOFMEMORY;
			}

			lstrcpyn(szNewPath, szPath, cchPath+1);
			delete[] szPath;
			szPath = szNewPath;
			DWORD cchSecondaryPath = cchPathBuf-cchPath-1;
			dwResult = MsiRecordGetString(hComponentRec, 3, szPath+cchPath+1, &cchSecondaryPath);
		}
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG4("Error: Unable to retrive secondary component path for user %s, component %s, product %s. Result: %d.", szUser, rgchComponent, rgchProduct, dwResult);
			delete[] szPath;
			return ERROR_FUNCTION_FAILED;
		}

		// add extra null for double terminating null at the end. And ensure
		// cchPath includes the new string and extra null.
		cchPath = cchPath+1 + cchSecondaryPath;
		*(szPath+cchPath+1) = 0;
	}

	// create the component key
	HKEY hComponentKey;
	if (ERROR_SUCCESS != (dwResult = RegCreateKeyEx(hComponentListKey, rgchComponent, 0, NULL, 0, KEY_ALL_ACCESS, &sa, &hComponentKey, NULL)))
	{
		DEBUGMSG3("Error: Unable to create new component key for user %s, component %s. Result: %d.", szUser, rgchComponent, dwResult);
		delete[] szPath;
		return ERROR_FUNCTION_FAILED;
	}

	dwResult = RegSetValueEx(hComponentKey, rgchProduct, 0, dwType, reinterpret_cast<unsigned char*>(szPath), (cchPath+1)*sizeof(TCHAR));
	RegCloseKey(hComponentKey);
	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG4("Error: Unable to create new component path value for user %s, component %s, product %s. Result: %d.", szUser, rgchComponent, rgchProduct, dwResult);
		delete[] szPath;
		return ERROR_FUNCTION_FAILED;
	}

	if (szPath[0] != TEXT('\0') && szPath[1] == TEXT('?'))
	{
		PMSIHANDLE hSharedDLLRec;
		if (ERROR_SUCCESS != (dwResult = MsiViewExecute(hRefCountUpdateView, hComponentRec)) ||
			ERROR_SUCCESS != (dwResult = MsiViewFetch(hRefCountUpdateView, &hSharedDLLRec)))
		{
			DEBUGMSG3("Error: Unable to retrieve SharedDLL data for user %s, product %s in SharedDLL table. Error %d", szUser, rgchProduct, dwResult);
			delete[] szPath;
			return ERROR_FUNCTION_FAILED;
		}
		else
		{	
			// increment the existing old SharedDLL cont for this path
			MsiRecordSetInteger(hSharedDLLRec, 1, MsiRecordGetInteger(hSharedDLLRec, 1)+1);
			if (ERROR_SUCCESS != (dwResult = MsiViewModify(hRefCountUpdateView, MSIMODIFY_UPDATE, hSharedDLLRec)))
			{
				DEBUGMSG3("Error: Unable to update SharedDLL data for user %s, product %s into SharedDLL table. Error %d", szUser, rgchProduct, dwResult);
				delete[] szPath;
				return ERROR_FUNCTION_FAILED;
			}
		}
	}

	return ERROR_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////
// Migrates user Component Path data by quering the Component and Product
// tables for products installed by szUser and components that belong
// to those products. Uses a temporary Marking column because native
// MSI joins do not scale well to large tables.
DWORD MigrateUserComponentData(MSIHANDLE hDatabase, HKEY hUserDataKey, LPCTSTR szUser)
{
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	////
	// create the "Component" key underneath the UserData key
	HKEY hComponentListKey;
	DWORD dwDisposition = 0;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hUserDataKey, szNewComponentSubKeyName, &sa, &hComponentListKey)))
	{
		DEBUGMSG2("Error: Unable to create new component key for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;
	}																				

	////
	// mark the component table with all components of interest based on products this user has installed
	PMSIHANDLE hAddColumnView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("ALTER TABLE `Component` ADD `_Mark` INT TEMPORARY"), &hAddColumnView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hAddColumnView, 0)))
	{
		DEBUGMSG2("Error: Unable to create marking column in Component table for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	// put the user SID into a temporary record for query mapping
	PMSIHANDLE hQueryRec = ::MsiCreateRecord(1);							 
	MsiRecordSetString(hQueryRec, 1, szUser);
 																			 
	PMSIHANDLE hProductView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Product` FROM `Products` WHERE `User`=?"), &hProductView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hProductView, hQueryRec)))
	{
		DEBUGMSG2("Error: Unable to create product query for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hMarkView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("UPDATE `Component` SET `_Mark`=1 WHERE `Product`=?"), &hMarkView)))
	{
		DEBUGMSG2("Error: Unable to create marking query for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hProductRec;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hProductView, &hProductRec)))
	{
		if (ERROR_SUCCESS != MsiViewExecute(hMarkView, hProductRec))
		{
			DEBUGMSG2("Error: Unable to execute marking query for user %s. Result: %d.", szUser, dwResult);
			RegCloseKey(hComponentListKey);
			return ERROR_FUNCTION_FAILED;
		}
	}
	if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		DEBUGMSG2("Error: Unable to mark all product components for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}
	
	// all components of interest have been maked in the _Mark column. Selected out of order so
	// SharedDLL queries can use fetched record in the execute call.
	PMSIHANDLE hComponentView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Path`, `Component`, `SecondaryPath`, `Product` FROM `Component` WHERE `_Mark`=1"), &hComponentView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hComponentView, 0)))
	{
   		DEBUGMSG2("Error: Unable to create Component query for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}
	
   	////
	// open query for update of SharedDLL Table
	PMSIHANDLE hRefCountUpdateView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `NewRefCount` FROM `SharedDLL` WHERE `Path`=?"), &hRefCountUpdateView)))
	{
		DEBUGMSG1("Error: Unable to create update query on SharedDLL table. Error %d", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	// loop through all installed components
	PMSIHANDLE hComponentRec;
 	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hComponentView, &hComponentRec)))
	{
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;
		MsiRecordGetString(hComponentRec, 4, rgchProduct, &cchProduct);

		if (ERROR_SUCCESS != (dwResult = WriteComponentData(hComponentListKey, hComponentRec, rgchProduct, szUser, hRefCountUpdateView)))
		{
			RegCloseKey(hComponentListKey);
			return ERROR_FUNCTION_FAILED;
		}
	}
	
	if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		DEBUGMSG2("Error: Unable to retrieve all component paths for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}
	RegCloseKey(hComponentListKey);
	return ERROR_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////
// Migrates permanent Component data by quering the Component
// tables for NULL products. Returns ERROR_FUNCTION_FAILED or ERROR_SUCCESS
DWORD MigratePermanentComponentData(MSIHANDLE hDatabase, HKEY hUserDataKey)
{
	DWORD dwResult = ERROR_SUCCESS;
	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// create the "Component" key underneath the UserData key
	HKEY hComponentListKey;
	DWORD dwDisposition = 0;

	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hUserDataKey, szNewComponentSubKeyName, &sa, &hComponentListKey)))
	{
		DEBUGMSG1("Error: Unable to create new component. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}																				
  	
	////
	// open query for update of SharedDLL Table
	PMSIHANDLE hRefCountUpdateView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `NewRefCount` FROM `SharedDLL` WHERE `Path`=?"), &hRefCountUpdateView)))
	{
		DEBUGMSG1("Error: Unable to create update query on SharedDLL table. Error %d", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	// open query for distinct component IDs.
	PMSIHANDLE hPermanentComponentView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT DISTINCT `Component` FROM `Component` WHERE `Product` IS NULL"), &hPermanentComponentView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hPermanentComponentView, 0)))
	{
		DEBUGMSG1("Error: Unable to create permanent component query. Result: %d.", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

   	// open query to select all paths of a specific component that are marked permanent.
	PMSIHANDLE hPermanentView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT DISTINCT `Path`, `Component`, `SecondaryPath`, 0 FROM `Component` WHERE `Product` IS NULL AND `Component`=?"), &hPermanentView)))
	{
   		DEBUGMSG1("Error: Unable to create Permanent Component path query. Result: %d.", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	TCHAR rgchProduct[cchGUIDPacked+1] = TEXT("00000000000000000000000000000000");

	// next check for all components marked "permanent' under any path
	PMSIHANDLE hComponentRec;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hPermanentComponentView, &hComponentRec)))
	{
		if (ERROR_SUCCESS != (dwResult = MsiViewExecute(hPermanentView, hComponentRec)))
		{
			DEBUGMSG1("Error: Unable to execute Permanent Component query. Result: %d.", dwResult);
			RegCloseKey(hComponentListKey);
			return ERROR_FUNCTION_FAILED;
		}

		// start with all-0s product GUID, and increment the last two chars
		// in HEX for each unique path.
		int iPermanent = 0;
		PMSIHANDLE hPermanentRec;
		while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hPermanentView, &hPermanentRec)))
		{
			wsprintf(&rgchProduct[cchGUIDPacked-2], TEXT("%0.2X"), iPermanent);
			MsiRecordSetString(hPermanentRec, 4, rgchProduct);
		
			if (ERROR_SUCCESS != (dwResult = WriteComponentData(hComponentListKey, hPermanentRec, rgchProduct, szLocalSystemSID, hRefCountUpdateView)))
			{
				RegCloseKey(hComponentListKey);
				return ERROR_FUNCTION_FAILED;
			}
			iPermanent++;
		}
		if (ERROR_NO_MORE_ITEMS != dwResult)
		{
			DEBUGMSG1("Error: Unable to retrieve all permanent component paths. Result: %d.", dwResult);
			RegCloseKey(hComponentListKey);
			return ERROR_FUNCTION_FAILED;
		}
	}
	RegCloseKey(hComponentListKey);
	return ERROR_SUCCESS;
}



///////////////////////////////////////////////////////////////////////
// Reads FeatureComponent registration data from the temporary
// database for the specified user and product, then writes the
// data under the provided product key in the new format. Returns
// ERROR_SUCCESS, ERROR_FUNCTION_FAILED, ERROR_OUTOFMEMORY
DWORD MigrateProductFeatureData(MSIHANDLE hDatabase, HKEY hProductKey, TCHAR* szUser, TCHAR rgchProduct[cchGUIDPacked+1])
{
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// create the "Features" key under the Products
	HKEY hFeatureKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hProductKey, szNewFeaturesSubKeyName, &sa, &hFeatureKey)))
	{
		DEBUGMSG3("Error: Unable to create new Features key for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		return ERROR_FUNCTION_FAILED;
	}
	
	// query for all feature data beloning to this product
	PMSIHANDLE hFeatureView;
	PMSIHANDLE hQueryRec = ::MsiCreateRecord(1);
	MsiRecordSetString(hQueryRec, 1, rgchProduct);

	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Feature`, `Components` FROM `FeatureComponent` WHERE `Product`=?"), &hFeatureView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hFeatureView, hQueryRec)))
	{
		DEBUGMSG3("Error: Unable to query FeatureComponent table for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		RegCloseKey(hFeatureKey);
		return ERROR_FUNCTION_FAILED;
	}

	DWORD cchNameBuf = MEMORY_DEBUG(72);
	TCHAR *szName = new TCHAR[cchNameBuf];
	if (!szName)
	{
		DEBUGMSG("Error: Out of memory");
		RegCloseKey(hFeatureKey);
		return ERROR_OUTOFMEMORY;
	}

	DWORD cchValueBuf = MEMORY_DEBUG(128);
	TCHAR *szValue = new TCHAR[cchValueBuf];
	if (!szValue)
	{
		DEBUGMSG("Error: Out of memory");
		RegCloseKey(hFeatureKey);
		delete[] szName;
		return ERROR_OUTOFMEMORY;
	}

	PMSIHANDLE hFeatureRec;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hFeatureView, &hFeatureRec)))
	{
		DWORD cchName = cchNameBuf;
		if (ERROR_MORE_DATA == (dwResult = MsiRecordGetString(hFeatureRec, 1, szName, &cchName)))
		{
			delete[] szName;
			cchNameBuf = ++cchName;
			szName = new TCHAR[cchNameBuf];
			if (!szName)
			{
				DEBUGMSG("Error: Out of memory");
				delete[] szValue;
				RegCloseKey(hFeatureKey);
				return ERROR_OUTOFMEMORY;
			}
			dwResult = MsiRecordGetString(hFeatureRec, 1, szName, &cchName);
		}
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG3("Warning: Unable to retrieve feature name for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
			delete[] szValue;
			delete[] szName;
			RegCloseKey(hFeatureKey);
			return ERROR_FUNCTION_FAILED;
		}

		DWORD cchValue = cchValueBuf;
		if (ERROR_MORE_DATA == (dwResult = MsiRecordGetString(hFeatureRec, 2, szValue, &cchValue)))
		{
			delete[] szValue;
			cchValueBuf = ++cchValue;
			szValue = new TCHAR[cchValueBuf];
			if (!szName)
			{
				DEBUGMSG("Error: Out of memory");
				delete[] szName;
				RegCloseKey(hFeatureKey);
				return ERROR_OUTOFMEMORY;
			}
			dwResult = MsiRecordGetString(hFeatureRec, 2, szValue, &cchValue);
		}
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG4("Warning: Unable to retrieve feature components for user %s, product %s, Feature %s. Result: %d.", szUser, rgchProduct, szName, dwResult);
			delete[] szValue;
			delete[] szName;
			RegCloseKey(hFeatureKey);
			return ERROR_FUNCTION_FAILED;
		}

		// create the component key
        if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hFeatureKey, szName, 0, REG_SZ, reinterpret_cast<unsigned char*>(szValue), (cchValue+1)*sizeof(TCHAR))))
		{
			DEBUGMSG4("Warning: Unable to create new feature value for user %s, product %s, feature %s. Result: %d.", szUser, rgchProduct, szName, dwResult);
			delete[] szValue;
			delete[] szName;
			RegCloseKey(hFeatureKey);
			return ERROR_FUNCTION_FAILED;
		}
	}
	if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		DEBUGMSG3("Warning: Unable to retrieve all feature information for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		delete[] szValue;
		delete[] szName;
		RegCloseKey(hFeatureKey);
		return ERROR_FUNCTION_FAILED;
	}
	delete[] szName;
	delete[] szValue;
	RegCloseKey(hFeatureKey);
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Reads Feature Usage Data data from the temporary
// database for the specified user and product, then writes the
// data under the provided product key in the new format. Returns
// ERROR_SUCCESS, ERROR_OUTOFMEMORY. Does not return ERROR_FUNCTION_FAILED
// because feature usage data is not required in 1.5.
DWORD MigrateProductFeatureUsageData(MSIHANDLE hDatabase, HKEY hProductKey, TCHAR* szUser, TCHAR rgchProduct[cchGUIDPacked+1])
{
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetEveryoneUpdateSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// create the "Features" key under the Products
	HKEY hFeatureKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hProductKey, szNewFeatureUsageSubKeyName, &sa, &hFeatureKey)))
	{
		DEBUGMSG3("Unable to create new feature usage key for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		return ERROR_SUCCESS;
	}
	
	// query for all feature data belonging to this product
	PMSIHANDLE hFeatureView;
	PMSIHANDLE hQueryRec = ::MsiCreateRecord(1);
	MsiRecordSetString(hQueryRec, 1, rgchProduct);

	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Feature`, `Usage` FROM `FeatureUsage` WHERE `Product`=?"), &hFeatureView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hFeatureView, hQueryRec)))
	{
		DEBUGMSG3("Error: Unable to query FeatureUsage table for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		RegCloseKey(hFeatureKey);
		return ERROR_SUCCESS;
	}

	DWORD dwUsage;
	DWORD cchNameBuf = MEMORY_DEBUG(72);
	TCHAR *szName = new TCHAR[cchNameBuf];
	if (!szName)
	{
		DEBUGMSG("Error: Out of memory");
		RegCloseKey(hFeatureKey);
		return ERROR_OUTOFMEMORY;
	}

	PMSIHANDLE hFeatureRec;
    while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hFeatureView, &hFeatureRec)))
	{
		DWORD cchName = cchNameBuf;
		if (ERROR_MORE_DATA == (dwResult = MsiRecordGetString(hFeatureRec, 1, szName, &cchName)))
		{
			delete[] szName;
			cchNameBuf = ++cchName;
			szName = new TCHAR[cchNameBuf];
			if (!szName)
			{
				DEBUGMSG("Error: Out of memory");
				RegCloseKey(hFeatureKey);
				return ERROR_OUTOFMEMORY;
			}
			dwResult = MsiRecordGetString(hFeatureRec, 1, szName, &cchName);
		}
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG4("Warning: Unable to retrieve feature usage data for user %s, product %s, feature %s. Result: %d.", szUser, rgchProduct, szName, dwResult);
			continue;
		}

		dwUsage = ::MsiRecordGetInteger(hFeatureRec, 2);

		// create the feature usage value key
        if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hFeatureKey, szName, 0, REG_DWORD, reinterpret_cast<unsigned char*>(&dwUsage), sizeof(dwUsage))))
		{
			DEBUGMSG4("Warning: Unable to create new feature usage value for user %s, product %s, feature %s. Result: %d.", szUser, rgchProduct, szName, dwResult);
		}
	}
	if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		DEBUGMSG3("Warning: Unable to retrieve all feature usage information for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
	}

	delete[] szName;
	RegCloseKey(hFeatureKey);
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Given a product code, makes a copy of the cached local package
// and registers the path under the per-user product attributes key.
// Returns one of ERROR_SUCCESS and ERROR_OUTOFMEMORY. Does NOT return
// ERROR_FUNCTION_FAILED, as all cached packages are trivially
// recachable.
DWORD MigrateCachedPackage(MSIHANDLE hDatabase, HKEY hProductKey, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1], eManagedType eManaged, bool fCopyCachedPackage)
{
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// open the existing localpackage key 
	HKEY hKey;
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szLocalPackagesKeyName, 
												  0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, &hKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no packages are cached. 
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Warning: Failed to open local packages key. Result: %d.", dwResult);
		}
		return ERROR_SUCCESS;
   	}
	else
	{
		// ACL on this key does matter
		if (!FIsKeyLocalSystemOrAdminOwned(hKey))
  		{
			DEBUGMSG("Warning: Skipping localpackages key, key is not owned by Admin or System.");
			RegCloseKey(hKey);
			return ERROR_SUCCESS;
		}
		else
		{
			// open the product key 
			HKEY hOldProductKey;
			if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hKey, rgchProduct, 0, KEY_QUERY_VALUE, &hOldProductKey)))
			{
				RegCloseKey(hKey);

				// if the reason that this failed is that the key doesn't exist, the product is not installed or
				// has no localpackage. 
				if (ERROR_FILE_NOT_FOUND != dwResult)
				{
					DEBUGMSG2("Error: Failed to open local packages key for %s. Result: %d.", rgchProduct, dwResult);
				}
				return ERROR_SUCCESS;
			}

			// query for a value with name=UserSID or UserSID(Managed)
			TCHAR *szValueName = const_cast<TCHAR*>(szUser);
			if (eManaged == emtUserManaged)
			{
				szValueName = new TCHAR[lstrlen(szUser)+cchManagedPackageKeyEnd+1];
				if (!szValueName)
				{
					RegCloseKey(hKey);
					RegCloseKey(hOldProductKey);
					DEBUGMSG("Error: Out of memory.");
					return ERROR_OUTOFMEMORY;
				}
				lstrcpy(szValueName, szUser);
				lstrcat(szValueName, szManagedPackageKeyEnd);
			}

			DWORD cchPath = MEMORY_DEBUG(MAX_PATH);
			TCHAR *szPath = new TCHAR[cchPath];
			DWORD cbPath = cchPath*sizeof(TCHAR);
			if (!szPath)
			{
				RegCloseKey(hKey);
				RegCloseKey(hOldProductKey);
				delete[] szValueName;
				DEBUGMSG("Error: Out of memory.");
				return ERROR_OUTOFMEMORY;
			}
			if (ERROR_MORE_DATA == (dwResult = RegQueryValueEx(hOldProductKey, szValueName, 0, NULL, reinterpret_cast<unsigned char*>(szPath), &cbPath)))
			{
				delete[] szPath;
				szPath = new TCHAR[cbPath/sizeof(TCHAR)];
				if (!szPath)
				{
					RegCloseKey(hKey);
					RegCloseKey(hOldProductKey);
					delete[] szValueName;
					DEBUGMSG("Error: Out of memory.");
					return ERROR_OUTOFMEMORY;
				}
				dwResult = RegQueryValueEx(hOldProductKey, szValueName, 0, NULL, reinterpret_cast<unsigned char*>(szPath), &cbPath);
			}

			if (ERROR_SUCCESS != dwResult)
			{
				if (ERROR_FILE_NOT_FOUND != dwResult)
				{
					DEBUGMSG3("Warning: Unable to retrieve cached package path for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);								
				}
			}
			else
			{
				// create the "InstallProperties" key under the new Products key
				HKEY hPropertyKey;
				if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hProductKey, szNewInstallPropertiesSubKeyName, &sa, &hPropertyKey)))
				{
					DEBUGMSG3("Warning: Unable to create new InstallProperties key for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
				}
				else
				{
					TCHAR rgchPackageFullPath[MAX_PATH] = TEXT("");
					TCHAR *szWritePath = szPath;

					if (fCopyCachedPackage && cbPath && szPath && *szPath)
					{
						// check for existance of cached package and open the file
						HANDLE hSourceFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
						DWORD dwLastError = GetLastError();
						
						if(hSourceFile == INVALID_HANDLE_VALUE)
						{
							if (dwLastError != ERROR_FILE_NOT_FOUND)
							{
								DEBUGMSG4("Warning: Unable to open cached package %s for user %s, product %s. Result: %d.", szPath, szUser, rgchProduct, dwResult);
							}
						}
						else
						{
							// create insert query for files that should be cleaned up on failure or success. If this fails
							// we'll just orphan a file if migration fails.
							PMSIHANDLE hCleanUpTable;
							if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `CleanupFile`"), &hCleanUpTable))
								dwResult = MsiViewExecute(hCleanUpTable, 0);
							
							// add the old package to the "delete on success" list. This may exist
							// already due to migration by other users
							PMSIHANDLE hFileRec = MsiCreateRecord(2);
							MsiRecordSetString(hFileRec, 1, szPath);
							MsiRecordSetInteger(hFileRec, 2, 1);
							MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);
		
							// get installer directory for target path
							GetWindowsDirectory(rgchPackageFullPath, MAX_PATH);
							lstrcat(rgchPackageFullPath, szInstallerDir);

							// copy the file from source to Generated destination file. generated package names are 8.3
							TCHAR rgchPackageFile[13];
							HANDLE hDestFile = INVALID_HANDLE_VALUE;
							GenerateSecureTempFile(rgchPackageFullPath, szPackageExtension, &sa, rgchPackageFile, hDestFile);
				
							if (!CopyOpenedFile(hSourceFile, hDestFile))
							{
								DEBUGMSG3("Warning: Unable to copy Transform for user %s, product %s, Transform %s.", szUser, rgchProduct, szPath);
							}
		
							CloseHandle(hSourceFile);
							CloseHandle(hDestFile);
				
							// add the new transform to the "delete on failure" list.
							StringCchCat(rgchPackageFullPath, 
								(sizeof(rgchPackageFullPath)/sizeof(TCHAR)), 
								rgchPackageFile);
							hFileRec = MsiCreateRecord(2);
							MsiRecordSetString(hFileRec, 1, rgchPackageFullPath);
							MsiRecordSetInteger(hFileRec, 2, 0);
							MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);

							// ensure that we write the new path
							szWritePath = rgchPackageFullPath;
						}
					}
					
					// set the new localpackages value
					if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hPropertyKey, (eManaged == emtUserManaged) ? 
							szNewLocalPackagesManagedValueName : szNewLocalPackagesValueName, 0, REG_SZ, 
							reinterpret_cast<unsigned char*>(szWritePath), (lstrlen(szWritePath)+1)*sizeof(TCHAR))))
					{
						DEBUGMSG3("Warning: Unable to create new LocalPackage value for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
    				}
					RegCloseKey(hPropertyKey);
				}
			}

			delete[] szPath;
			if (eManaged == emtUserManaged)
			{
				delete[] szValueName;
			}
			RegCloseKey(hOldProductKey);
		}
		RegCloseKey(hKey);
	}

    return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Given a product code and key makes a copy of any secure cached 
// transforms for the product and registers the filename mapping under
// the per-product transforms key. Returns one of ERROR_SUCCESS and 
// ERROR_OUTOFMEMORY. Does NOT return ERROR_FUNCTION_FAILED, as all
// transforms are recachable from source, so nothing here
// is catastrophic.
DWORD MigrateSecureCachedTransforms(MSIHANDLE hDatabase, HKEY hOldProductKey, HKEY hNewProductKey, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1], eManagedType eManaged)
{
	DWORD dwResult = ERROR_SUCCESS;

	// query for a value with name=Transforms
	DWORD cchTransformList = MEMORY_DEBUG(MAX_PATH);
	TCHAR *szTransformList = new TCHAR[cchTransformList];
	if (!szTransformList)
	{
		DEBUGMSG("Error: Out of memory.");
		return ERROR_OUTOFMEMORY;
	}
	DWORD cbTransformList = cchTransformList*sizeof(TCHAR);

	// retrieve the "Transforms" value, which is a semicolon delimited list of transforms
	// to apply
	if (ERROR_MORE_DATA == (dwResult = RegQueryValueEx(hOldProductKey, szTransformsValueName, 0, NULL, reinterpret_cast<unsigned char*>(szTransformList), &cbTransformList)))
	{
		delete[] szTransformList;
		szTransformList = new TCHAR[cbTransformList/sizeof(TCHAR)];
		if (!szTransformList)
		{
			DEBUGMSG("Error: Out of memory.");
			return ERROR_OUTOFMEMORY;
		}
		dwResult = RegQueryValueEx(hOldProductKey, szTransformsValueName, 0, NULL, reinterpret_cast<unsigned char*>(szTransformList), &cbTransformList);
	}

	if (ERROR_SUCCESS == dwResult)
	{
		// create insert query for files that should be cleaned up on failure or success. If this fails
		// we'll just orphan a file if migration fails.
		PMSIHANDLE hCleanUpTable;
		if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `CleanupFile`"), &hCleanUpTable))
			MsiViewExecute(hCleanUpTable, 0);

		// get security descriptor for new Transforms Key
		SECURITY_ATTRIBUTES sa;
		sa.nLength        = sizeof(sa);
		sa.bInheritHandle = FALSE;
		GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));
		
		// create the "Transforms" key under the new Product key
		HKEY hTransformsKey;
		if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hNewProductKey, szNewTransformsSubKeyName, &sa, &hTransformsKey)))
		{
			DEBUGMSG3("Error: Unable to create new Transforms key for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		}
		else
		{
			// verify that its secure transforms
			if (*szTransformList==TEXT('@') || *szTransformList==TEXT('|'))
			{
				// get installer directory
				TCHAR rgchInstallerDir[MAX_PATH];
				DWORD cch = GetWindowsDirectory(rgchInstallerDir, MAX_PATH);
				if (!cch || (cch >= MAX_PATH))
				{
					delete[] szTransformList;
					return ERROR_FUNCTION_FAILED;
				}
				lstrcat(rgchInstallerDir, szInstallerDir);
				int iInstallerPathEnd = lstrlen(rgchInstallerDir);
	
				// create new full-path to transforms
				TCHAR rgchTransformFullPath[MAX_PATH];
				lstrcpy(rgchTransformFullPath, rgchInstallerDir);
	
				// create old secure transforms directory
				TCHAR rgchFullPath[MAX_PATH];
				lstrcpy(rgchFullPath, rgchInstallerDir);
				TCHAR rgchGUID[cchGUID+1];
	
				// subdirectory from installer dir is unpacked produccode GUID
				UnpackGUID(rgchProduct, rgchGUID);
				lstrcat(rgchFullPath, rgchGUID);
				
				// add the old product dir to the "delete on success" list
				// the directory will not be deleted if it is not empty.
				// (if it has icons, etc)
				PMSIHANDLE hFileRec = MsiCreateRecord(2);
				MsiRecordSetString(hFileRec, 1, rgchFullPath);
				MsiRecordSetInteger(hFileRec, 2, 3);
				MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);			
				
				// subdirectory under the product is "SecureTransforms"
				lstrcat(rgchFullPath, szSecureTransformsDir);
				int iBasePathEnd = lstrlen(rgchFullPath);
				
				// add the old transforms dir to the "delete on success" list
				// the directory will not be deleted if it is not empty.
				// (if it has icons, etc)
				MsiRecordSetString(hFileRec, 1, rgchFullPath);
				MsiRecordSetInteger(hFileRec, 2, 2);
				MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);			

				// move past the initial "secure" character before parsing list.
				TCHAR *szNextTransform = szTransformList+1;

				while (szNextTransform && *szNextTransform)
				{
					TCHAR *szTransform = szNextTransform;

					// use CharNext/ExA to handle DBCS directory and file names
					while (*szNextTransform && *szNextTransform != TEXT(';'))
#ifdef UNICODE
						szNextTransform = CharNext(szNextTransform);
#else
						szNextTransform = CharNextExA(0, szNextTransform, 0);
#endif
					
					// if reached the null terminator, don't increment past it. But if
					// reached a semicolon, increment the next transform pointer to the 
					// beginning of the actual transform path.
					if (*szNextTransform)
						*(szNextTransform++)='\0';

					// if the transform name begins with ':', its embedded in the package and
					// is not cached
					if (*szTransform==TEXT(':'))
						continue;
					
					// search for a backslash to see if this is a secure full-path transform
					TCHAR *szTransformFilename=szNextTransform;
					do
					{
#ifdef UNICODE
						szTransformFilename = CharPrev(szTransform, szTransformFilename);
#else
						szTransformFilename = CharPrevExA(0, szTransform, szTransformFilename, 0);
#endif
						if (*szTransformFilename == '\\')
						{
							szTransformFilename++;
							break;
						}
					}
					while (szTransformFilename != szTransform);

					// check for existance of cached transform and open the file
					lstrcpy(&rgchFullPath[iBasePathEnd], szTransformFilename);
					
					HANDLE hSourceFile = CreateFile(rgchFullPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
					
					DWORD dwLastError = GetLastError();
					
					if(hSourceFile == INVALID_HANDLE_VALUE)
					{
					if (dwLastError != ERROR_FILE_NOT_FOUND)
					{
						DEBUGMSG4("Warning: Unable to open cached transform %s for user %s, product %s. Result: %d.", szTransform, szUser, rgchProduct, dwResult);
						continue;
					}
					else
						// transform is missing. No big deal.
						continue;
					}

					// add the old transform to the "delete on success" list.
					MsiRecordSetString(hFileRec, 1, rgchFullPath);
					MsiRecordSetInteger(hFileRec, 2, 1);
					MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);

					// copy the file from source to Generated destination file. generated transform names are 8.3
					TCHAR rgchTransformFile[13];
					HANDLE hDestFile = INVALID_HANDLE_VALUE;
					GenerateSecureTempFile(rgchInstallerDir, szTransformExtension, &sa, rgchTransformFile, hDestFile);
		
					if (!CopyOpenedFile(hSourceFile, hDestFile))
					{
						DEBUGMSG3("Warning: Unable to copy Transform for user %s, product %s, Transform %s.", szUser, rgchProduct, szTransform);
						continue;
					}

					CloseHandle(hSourceFile);
					CloseHandle(hDestFile);
		
					// add the new transform to the "delete on failure" list.
					lstrcpy(&rgchTransformFullPath[iInstallerPathEnd], rgchTransformFile);
					hFileRec = MsiCreateRecord(2);
					MsiRecordSetString(hFileRec, 1, rgchTransformFullPath);
					MsiRecordSetInteger(hFileRec, 2, 0);
					MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);

					// set the new transform mapping value
					if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hTransformsKey, szTransform, 0, REG_SZ, 
							reinterpret_cast<unsigned char*>(rgchTransformFile), (lstrlen(rgchTransformFile)+1)*sizeof(TCHAR))))
					{
						DEBUGMSG4("Warning: Unable to create new Transform value for user %s, product %s, Transform %s. Result: %d.", szUser, rgchProduct, szTransform, dwResult);
					}
				}
			}
			RegCloseKey(hTransformsKey);
		}
	}
	else if (dwResult != ERROR_FILE_NOT_FOUND)
	{
		DEBUGMSG3("Warning: Could not retrieve transform information for user %s, product %s. Result: %d. ", szUser, rgchProduct, dwResult);
	}

	delete[] szTransformList;
	return ERROR_SUCCESS;
}



///////////////////////////////////////////////////////////////////////
// Given a product code, user, and managed state, opens the old product
// key. Returns ERROR_SUCCESS if opened, ERROR_NO_DATA if no such
// product, ERROR_FUNCTION_FAILED, or ERROR_OUTOFMEMORY;
DWORD OpenOldProductKey(eManagedType eManaged, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1], HKEY hHKCUKey, HKEY *hOldProductKey)
{
	DWORD dwResult = ERROR_SUCCESS;
	bool fACLMatters = false;
	
	HKEY hKey;
	switch (eManaged)
	{
	case emtNonManaged:
	{
		dwResult = RegOpenKeyEx(hHKCUKey ? hHKCUKey : HKEY_CURRENT_USER, szPerUserInstallKeyName, 0, KEY_ENUMERATE_SUB_KEYS, &hKey);
		fACLMatters = false;
		break;
	}
	case emtUserManaged:
	{
		HKEY hUserKey;
		TCHAR *szUserKey = new TCHAR[cchPerUserManagedInstallKeyName+lstrlen(szUser)+cchPerUserManagedInstallSubKeyName+1];
  		if (!szUserKey)
		{
			DEBUGMSG("Error: Out of memory.");
			return ERROR_OUTOFMEMORY;
		}

		lstrcpy(szUserKey, szPerUserManagedInstallKeyName);
		lstrcat(szUserKey, szUser);
		lstrcat(szUserKey, szPerUserManagedInstallSubKeyName);

		dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szUserKey, 0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, &hKey);
		fACLMatters = true;

		delete[] szUserKey;
		break;
	}
	case emtMachineManaged:
	{
		dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPerMachineInstallKeyName, 0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, &hKey);
		fACLMatters = true;
		break;
	}
	default:
	{
		DEBUGMSG("Error: Invalid Managed type in OpenOldProductKey.");
		dwResult = ERROR_FUNCTION_FAILED;
		break;
	}
	}

	if (ERROR_SUCCESS != dwResult)
	{
		// if the reason that this failed is that the key doesn't exist, product is missing. So "no data'
		if (ERROR_FILE_NOT_FOUND == dwResult)
			return ERROR_NO_DATA;
		
		DEBUGMSG2("Error: Failed to open product key for %s. Result: %d.", rgchProduct, dwResult);
		return ERROR_FUNCTION_FAILED;		
	}
	else
	{
		// if concerned about the ACL on the key, check now
		if (fACLMatters && !FIsKeyLocalSystemOrAdminOwned(hKey))
		{
			RegCloseKey(hKey);
			DEBUGMSG1("Error: Product key for %s exists but is not owned by system or admin. Ignoring.", rgchProduct);
			return ERROR_NO_DATA;
		}
	
		// open the product key 
		dwResult = RegOpenKeyEx(hKey, rgchProduct, 0, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, hOldProductKey);
		RegCloseKey(hKey);
		if (ERROR_SUCCESS != dwResult)
		{		
			// if the reason that this failed is that the key doesn't exist, the product is not installed
			if (ERROR_FILE_NOT_FOUND != dwResult)
			{
				DEBUGMSG2("Error: Failed to open product key for %s. Result: %d.", rgchProduct, dwResult);
				return ERROR_FUNCTION_FAILED;
			}
			return ERROR_NO_DATA;
		}
	}
	return ERROR_SUCCESS;
}



///////////////////////////////////////////////////////////////////////
// Given a user name and product code, migrates the ARP information
// from the Uninstall key to the per-user InstallProperties
// key for the product. Excludes the LocalPackage value, but otherwise
// has no understanding of the values moved. Returns ERROR_SUCCESS, 
// ERROR_FUNCTION_FAILED, or ERROR_OUTOFMEMORY.
DWORD MigrateUninstallInformation(MSIHANDLE hDatabase, HKEY hNewProductKey, TCHAR* szUser, TCHAR rgchProduct[cchGUIDPacked+1])
{
	DWORD dwResult = ERROR_SUCCESS;

	// open the old Uninstall key
	HKEY hUninstallKey;
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldUninstallKeyName,
												  0, KEY_ENUMERATE_SUB_KEYS, &hUninstallKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no products are installed. So return success
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Could not open old uninstall key. Result: %d. ", dwResult);
			return ERROR_SUCCESS;
		}
		return ERROR_SUCCESS;
	}

	// unpack product code to load Uninstall key
	TCHAR rgchGUID[cchGUID+1];
	UnpackGUID(rgchProduct, rgchGUID);

	// open the unpacked-GUID subkey of the product key.
	HKEY hOldPropertyKey;
	dwResult = RegOpenKeyEx(hUninstallKey, rgchGUID, 0, KEY_QUERY_VALUE, &hOldPropertyKey);
	RegCloseKey(hUninstallKey);
	if (ERROR_SUCCESS != dwResult)
	{
		// if the reason that this failed is that the key doesn't exist, the product is not installed.
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG2("Error: Could not open old uninstall key for product %s. Result: %d. ", rgchProduct, dwResult);
			return ERROR_SUCCESS;
		}
		return ERROR_SUCCESS;
	}

	// query the old uninstall key for information
	DWORD cValues;
	DWORD cchMaxValueNameLen;
	DWORD cbMaxValueLen;
	if (ERROR_SUCCESS != (dwResult = RegQueryInfoKey(hOldPropertyKey, NULL, NULL, 0, 
										 NULL, NULL, NULL, &cValues, &cchMaxValueNameLen, 
										 &cbMaxValueLen, NULL, NULL)))
	{
		DEBUGMSG2("Error: Could not retrieve key information for uninstall key of product %s. Result: %d. Skipping component.", rgchProduct, dwResult);
		RegCloseKey(hOldPropertyKey);
		return ERROR_SUCCESS;
	}

	if (cValues == 0)
	{
		RegCloseKey(hOldPropertyKey);
		return ERROR_SUCCESS;
	}

	// allocate memory to grab the name and value from the uninstall key
	TCHAR *szName = new TCHAR[++cchMaxValueNameLen];
	if (!szName)
	{
		DEBUGMSG("Error: out of memory.");
		RegCloseKey(hOldPropertyKey);
		return ERROR_OUTOFMEMORY;
	}

	unsigned char *pValue = new unsigned char[cbMaxValueLen];
	if (!pValue)
	{
		delete[] szName;
		DEBUGMSG("Error: out of memory.");
		RegCloseKey(hOldPropertyKey);
		return ERROR_OUTOFMEMORY;
	}


	// grab SD for new InstallProperties key.
	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// open the InstallPropertiesKey under the Product Key
	HKEY hNewPropertyKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hNewProductKey, szNewInstallPropertiesSubKeyName, &sa, &hNewPropertyKey)))
	{
		delete[] szName;
		delete[] pValue;
		DEBUGMSG3("Warning: Unable to create new InstallProperties key for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		RegCloseKey(hOldPropertyKey);
		return ERROR_FUNCTION_FAILED;
	}

	// loop through all values under the Uninstall key.
	DWORD dwValueIndex = 0;
	while (1)
	{
		DWORD cchName = cchMaxValueNameLen;
		DWORD cbValue = cbMaxValueLen;
		DWORD dwType = 0;
		LONG lResult = RegEnumValue(hOldPropertyKey, dwValueIndex++, szName, &cchName,
									0, &dwType, reinterpret_cast<unsigned char*>(pValue), &cbValue);
		if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG2("Error: Could not enumerate product properties for %s. Result: %d.", rgchProduct, lResult);
			break;
		}

		// if this is the LocalPackage value written by Darwin 1.0, do NOT migrate the key
		// since it would overwrite the new package registration.
		if (2 == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szName, -1, szNewLocalPackagesValueName, -1))
			continue;

		// create the feature usage value key
        if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hNewPropertyKey, szName, 0, dwType, pValue, cbValue)))
		{
			DEBUGMSG4("Warning: Unable to create new product property %s for user %s, product %s. Result: %d.", szName, szUser, rgchProduct, dwResult);
		}
	}
	delete[] szName;
	delete[] pValue;

	RegCloseKey(hOldPropertyKey);
	RegCloseKey(hNewPropertyKey);
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Given a product code, user, managed state, and registry handle to
// the userdata key, migrates all product information from the
// database and the old registry. This includes FeatureComponent data, 
// Feature Usage data, cached packages, and cached transforms. For
// non-managed installs, it also generates the MigratedPatches value
// under InstallProperties. No patches are migrated. Returns
// ERROR_SUCCESS, ERROR_OUTOFMEMORY, ERROR_FUNCTION_FAILED.
DWORD MigrateProduct(MSIHANDLE hDatabase, HKEY hUserDataKey, TCHAR* szUser, TCHAR rgchProduct[cchGUIDPacked+1], eManagedType eManaged, bool fMigrateCachedFiles)
{
	NOTEMSG1("Migrating product %s.", rgchProduct);

	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));
	
	////
	// create the "Products" key underneath the UserData key
	HKEY hProductListKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hUserDataKey, szNewProductSubKeyName, &sa, &hProductListKey)))
	{
		DEBUGMSG2("Error: Unable to create new component key for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// create the <productcode> key under the Products
	HKEY hProductKey;
	dwResult = CreateSecureRegKey(hProductListKey, rgchProduct, &sa, &hProductKey);
	RegCloseKey(hProductListKey);
	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG2("Error: Unable to create new component key for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;
	}
	
	dwResult = MigrateProductFeatureData(hDatabase, hProductKey, szUser, rgchProduct);
	if (ERROR_SUCCESS != dwResult)
	{
		RegCloseKey(hProductKey);
		return dwResult;
	}

	dwResult = MigrateProductFeatureUsageData(hDatabase, hProductKey, szUser, rgchProduct);
	if (ERROR_SUCCESS != dwResult)
	{
		RegCloseKey(hProductKey);
		return dwResult;
	}

	dwResult = MigrateCachedPackage(hDatabase, hProductKey, szUser, rgchProduct, eManaged, /*fCopyCachedPackage=*/false);
	if (ERROR_SUCCESS != dwResult)
	{
		RegCloseKey(hProductKey);
		return dwResult;
	}

	dwResult = MigrateUninstallInformation(hDatabase, hProductKey, szUser, rgchProduct);
	if (ERROR_SUCCESS != dwResult)
	{
		RegCloseKey(hProductKey);
		return dwResult;
	}

	if (eManaged == emtNonManaged)
	{
		dwResult = MigrateUnknownProductPatches(hDatabase, hProductKey, szUser, rgchProduct);
		if (ERROR_SUCCESS != dwResult)
		{
			RegCloseKey(hProductKey);
			return dwResult;
		}
	}

	// open the existing product key to read transform and patch information 
	if (fMigrateCachedFiles)
	{
		HKEY hOldProductKey;
		dwResult = OpenOldProductKey(eManaged, szUser, rgchProduct, 0, &hOldProductKey);
		if (dwResult == ERROR_SUCCESS)
		{
			dwResult = MigrateSecureCachedTransforms(hDatabase, hOldProductKey, hProductKey, szUser, rgchProduct, eManaged);	
		}
		else if (dwResult == ERROR_NO_DATA)
		{
			dwResult = ERROR_SUCCESS;			
		} 
	}

	RegCloseKey(hProductKey);

	return dwResult;
}



///////////////////////////////////////////////////////////////////////
// Given a user SID, migrates all data for that user given that the
// temporary database has been correctly initialized with all
// machine information. Migrates Component Data, Product data, and 
// Patches. Returns ERROR_SUCCESS, ERROR_FUNCTION_FAILED, or
// ERROR_OUTOFMEMORY
DWORD MigrateUser(MSIHANDLE hDatabase, TCHAR* szUser, bool fMigrateCachedFiles)
{
	NOTEMSG1("Migrating user: %s.", szUser);

	////
	// create the new key
	DWORD dwDisposition = 0;
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// create "UserData" key
	HKEY hKey;
 	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(HKEY_LOCAL_MACHINE, szNewBaseUserKeyName, &sa, &hKey)))
	{
		DEBUGMSG1("Error: Unable to create new UserData key. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// create SID key
	HKEY hUserDataKey;
	dwResult = CreateSecureRegKey(hKey, szUser, &sa, &hUserDataKey);
	RegCloseKey(hKey);
	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG2("Error: Unable to create new userdata key for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;		 
	}

	// migrate component data and set up SharedDLL changes required for this user.
	if (ERROR_SUCCESS != (dwResult = MigrateUserComponentData(hDatabase, hUserDataKey, szUser)))
		return dwResult;

	// open query to retrieve products installed for this user.
	PMSIHANDLE hQueryRec = ::MsiCreateRecord(1);	
	MsiRecordSetString(hQueryRec, 1, szUser);
	PMSIHANDLE hProductView;
	if (ERROR_SUCCESS != MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Product`, `Managed` FROM `Products` WHERE `User`=?"), &hProductView) ||
		ERROR_SUCCESS != MsiViewExecute(hProductView, hQueryRec))
	{
		DEBUGMSG2("Error: Unable to create product query for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;
	}
		
	// retrieve all products currently installed for this user.
	PMSIHANDLE hProductRec;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hProductView, &hProductRec)))
	{
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;
		eManagedType eManaged = static_cast<eManagedType>(::MsiRecordGetInteger(hProductRec, 2));
		MsiRecordGetString(hProductRec, 1, rgchProduct, &cchProduct);
		
		// migrate product information
		if (ERROR_SUCCESS != (dwResult = MigrateProduct(hDatabase, hUserDataKey, szUser, rgchProduct, eManaged, fMigrateCachedFiles)))
		{
			DEBUGMSG3("Error: Unable to migrate product %s for user %s. Result: %d.", rgchProduct, szUser, dwResult);
			RegCloseKey(hUserDataKey);
			return ERROR_FUNCTION_FAILED;
		}
	}
	if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		DEBUGMSG2("Error: Unable to retrieve all products for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hUserDataKey);
		return ERROR_FUNCTION_FAILED;
	}


	////
	// create the "Patches" key underneath the UserData key
	HKEY hPatchListKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hUserDataKey, szNewPatchesSubKeyName, &sa, &hPatchListKey)))
	{
		DEBUGMSG2("Error: Unable to create new Patches key for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hUserDataKey);
		return ERROR_FUNCTION_FAILED;
	}
	else
	{
		// migrate all patches for this user
		dwResult = MigrateUserPatches(hDatabase, szUser, hPatchListKey, fMigrateCachedFiles);
		RegCloseKey(hPatchListKey);
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG2("Error: Unable to create new Patches key for user %s. Result: %d.", szUser, dwResult);
			RegCloseKey(hUserDataKey);
			return ERROR_FUNCTION_FAILED;
		}
	}

	// if this is the system, also migrate permanent components
	if (0 == lstrcmp(szUser, szLocalSystemSID))
	{
		if (ERROR_SUCCESS != (dwResult = MigratePermanentComponentData(hDatabase, hUserDataKey)))
		{
			RegCloseKey(hUserDataKey);
			return dwResult;
		}
	}

	RegCloseKey(hUserDataKey);
	return ERROR_SUCCESS;
}


DWORD UpdateSharedDLLRefCounts(MSIHANDLE hDatabase)
{
	DEBUGMSG("Updating SharedDLL reference counts.");
	DWORD dwResult = ERROR_SUCCESS;
	
	////
	// open query for insert into SharedDLL Table
	PMSIHANDLE hRefCountView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `SharedDLL`"), &hRefCountView)) ||
	    ERROR_SUCCESS != (dwResult = MsiViewExecute(hRefCountView, 0)))
	{
		DEBUGMSG1("Error: Unable to create query on SharedDLL table. Error %d", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// open the SharedDLLRegistryKey. If the key doesn't exist, create it.
	HKEY hSharedDLLKey;
	if (ERROR_SUCCESS != (dwResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szSharedDLLKeyName, 0, NULL, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hSharedDLLKey, NULL)))
	{
		DEBUGMSG1("Error: Failed to create SharedDLL key. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hRec;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hRefCountView, &hRec)))
	{
		int iOldCount= MsiRecordGetInteger(hRec, 2);
		int iNewCount= MsiRecordGetInteger(hRec, 3);

		// if the old count is the same as the new count, no need to tweak
		if (iOldCount == iNewCount)
			continue;
		
		DWORD cchFileName = MEMORY_DEBUG(MAX_PATH);
		TCHAR *szFileName = new TCHAR[cchFileName];
  		if (!szFileName)
		{
			DEBUGMSG("Error: Out of memory.");
			RegCloseKey(hSharedDLLKey);
			return ERROR_OUTOFMEMORY;
		}

		if (ERROR_MORE_DATA == (dwResult = MsiRecordGetString(hRec, 1, szFileName, &cchFileName)))
		{
			delete[] szFileName;
			szFileName = new TCHAR[++cchFileName];
			if (!szFileName)
			{
				DEBUGMSG("Error: Out of memory");
				RegCloseKey(hSharedDLLKey);
				return ERROR_OUTOFMEMORY;
			}
			dwResult = MsiRecordGetString(hRec, 1, szFileName, &cchFileName);
		}
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG1("Error: Unable to retrive SharedDLL path. Result: %d.", dwResult);
			continue;
		}

		// convert the filename from <drive>?<path> back to <drive>:<path> format
		// before querying the registry
		szFileName[1] = TEXT(':');

		int iRegCount = 0;
		DWORD cbCount = sizeof(iRegCount);
		if (ERROR_SUCCESS != (dwResult = RegQueryValueEx(hSharedDLLKey, szFileName, 0, NULL, reinterpret_cast<unsigned char *>(&iRegCount), &cbCount)))
		{
			// if the value doesn't exist, the registry count is 0. We should set the count
			// to what it should be.
			if (dwResult != ERROR_FILE_NOT_FOUND)
			{
				DEBUGMSG2("Error: Failed to retrieve existing SharedDLL count for %s. Result: %d.", szFileName, dwResult);
				continue;
			}
		}

		// if the number of refcounts in the registry is less than the number of refcounts we can
		// account for
		int iNewRegCount = iRegCount + (iNewCount - iOldCount);

		// if something really bizarre is happening and we actually have fewer refcounts than
		// we did before, and it would drop us below the number of refcounts that we can account
		// for once migration is complete, set the refcount to the new count to ensure that
        // the file doesn't go away until all users uninstall
		if (iNewCount != 0 && iNewRegCount < iNewCount)
			iNewRegCount = iNewCount;

		// if the new regcount is less than 0, it should be 0
		if (iNewRegCount < 0)
			iNewRegCount = 0;
   	
		// if MSI can account for 0 refcounts, and the new count would be less than 0, it means
		// existing refcounts can't be accounted for. Delete the refcounts.
		// all of the existing registry counts are 
		if (iNewCount == 0 && iNewRegCount <= 0)
		{
			if (ERROR_SUCCESS != (dwResult = RegDeleteValue(hSharedDLLKey, szFileName)))
			{
				DEBUGMSG2("Error: Failed set new SharedDLL count for %s. Result: %d.", szFileName, dwResult);
				continue;
			}		
		}
		else
		{
			if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hSharedDLLKey, szFileName, 0, REG_DWORD, reinterpret_cast<unsigned char *>(&iNewRegCount), sizeof(iNewRegCount))))
			{
				DEBUGMSG2("Error: Failed set new SharedDLL count for %s. Result: %d.", szFileName, dwResult);
				continue;
			}
		} 
	}
	if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		DEBUGMSG1("Error: Failed set all SharedDLL counts. Result: %d.", dwResult);
	}

	RegCloseKey(hSharedDLLKey);
	return ERROR_SUCCESS;
}

DWORD WriteProductRegistrationDataFromDatabase(MSIHANDLE hDatabase, bool fMigrateSharedDLL, bool fMigratePatches)
{
	DWORD dwResult = ERROR_SUCCESS;

	// query for distinct users on the machine
 	PMSIHANDLE hUserView;
	if (ERROR_SUCCESS == dwResult)
	{
		if (ERROR_SUCCESS == (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT DISTINCT `User` FROM `Products`"), &hUserView)) &&
			ERROR_SUCCESS == (dwResult = MsiViewExecute(hUserView, 0)))
		{
			// default SID size is 256
			PMSIHANDLE hRec;
			DWORD cchUserSID = MEMORY_DEBUG(256);
			TCHAR* szUserSID = new TCHAR[cchUserSID];
			if (!szUserSID)
				dwResult = ERROR_OUTOFMEMORY;
							
			// loop across all users
			while (ERROR_SUCCESS == dwResult)
			{
				if (ERROR_SUCCESS != (dwResult = MsiViewFetch(hUserView, &hRec)))
					break;
			
				// retrieve the user SID
				DWORD cchTempSID = cchUserSID;
				dwResult = MsiRecordGetString(hRec, 1, szUserSID, &cchTempSID);
				if (ERROR_MORE_DATA == dwResult)
				{
					delete[] szUserSID;
					cchUserSID = ++cchUserSID;
					szUserSID = new TCHAR[++cchTempSID];
					if (!szUserSID)
					{
						dwResult = ERROR_OUTOFMEMORY;
						break;
					}
	
					dwResult = MsiRecordGetString(hRec, 1, szUserSID, &cchTempSID);
				}
				if (ERROR_SUCCESS != dwResult)
					break;
		
				// migrate all user information
				dwResult = MigrateUser(hDatabase, szUserSID, fMigratePatches);
			}
			delete[] szUserSID;
			szUserSID = NULL;
		}
	}
	if (ERROR_NO_MORE_ITEMS == dwResult)
		dwResult = ERROR_SUCCESS;

	if (ERROR_SUCCESS == dwResult && fMigrateSharedDLL)
		dwResult = UpdateSharedDLLRefCounts(hDatabase);

	return dwResult;
}




///////////////////////////////////////////////////////////////////////
// Given a user SID, migrates all cached package data for that user, 
// given that the temporary database has been correctly initialized 
// with all machine information. Migrates cached packages and cached
// transforms. Returns ERROR_SUCCESS, ERROR_FUNCTION_FAILED, or
// ERROR_OUTOFMEMORY
DWORD MigrateCachedDataFromWin9X(MSIHANDLE hDatabase, HKEY hUserHKCUKey, HKEY hUserDataKey, LPCTSTR szUser)
{
	NOTEMSG1("Migrating user: %s.", szUser);

	////
	// create the new key
	DWORD dwDisposition = 0;
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));


	// open query to retrieve products installed for this user.
	PMSIHANDLE hQueryRec = ::MsiCreateRecord(1);	
	MsiRecordSetString(hQueryRec, 1, szUser);
	PMSIHANDLE hProductView;
	if (ERROR_SUCCESS != MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Product`, `Managed` FROM `Products` WHERE `User`=?"), &hProductView) ||
		ERROR_SUCCESS != MsiViewExecute(hProductView, hQueryRec))
	{
		DEBUGMSG2("Error: Unable to create product query for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;
	}
	
	////
	// create the "Products" key underneath the UserData key
	HKEY hProductListKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hUserDataKey, szNewProductSubKeyName, &sa, &hProductListKey)))
	{
		DEBUGMSG2("Error: Unable to create new component key for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;
	}
		
	// retrieve all products currently installed for this user.
	PMSIHANDLE hProductRec;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hProductView, &hProductRec)))
	{
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;
		eManagedType eManaged = static_cast<eManagedType>(::MsiRecordGetInteger(hProductRec, 2));
		MsiRecordGetString(hProductRec, 1, rgchProduct, &cchProduct);
		
		// create the <productcode> key under the Products
		HKEY hProductKey;
		dwResult = CreateSecureRegKey(hProductListKey, rgchProduct, &sa, &hProductKey);
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG2("Error: Unable to create new component key for user %s. Result: %d.", szUser, dwResult);
			continue;
		}

		// migrate cached packages
		MigrateCachedPackage(hDatabase, hProductKey, szUser, rgchProduct, eManaged, /*fCopyCachedPackage=*/true);

		// write the "MigratedPatches" key to assist in proper cleanup with the product is uninstalled
		MigrateUnknownProductPatches(hDatabase, hProductKey, szUser, rgchProduct);

		// open the existing product key to read transform information 
		HKEY hOldProductKey;
		dwResult = OpenOldProductKey(eManaged, szUser, rgchProduct, hUserHKCUKey, &hOldProductKey);
		if (dwResult == ERROR_SUCCESS)
		{
			MigrateSecureCachedTransforms(hDatabase, hOldProductKey, hProductKey, szUser, rgchProduct, eManaged);	
			RegCloseKey(hOldProductKey);
		}
		else if (dwResult == ERROR_NO_DATA)
		{
			dwResult = ERROR_SUCCESS;			
		} 
	}
	RegCloseKey(hProductListKey);

	////
	// create the "Patches" key underneath the UserData key
	HKEY hPatchListKey;
	if (ERROR_SUCCESS == (dwResult = CreateSecureRegKey(hUserDataKey, szNewPatchesSubKeyName, &sa, &hPatchListKey)))
	{
		// migrate all patches for this user
		MigrateUserPatches(hDatabase, szUser, hPatchListKey, /*fCopyCachedPatches=*/true);
		RegCloseKey(hPatchListKey);
	}

	return ERROR_SUCCESS;
}

DWORD MigrateSingleUserOnlyComponentData(MSIHANDLE hDatabase, LPCTSTR szUserSID)
{
	////
	// create the new key
	DWORD dwDisposition = 0;
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// create "UserData" key
	HKEY hKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(HKEY_LOCAL_MACHINE, szNewBaseUserKeyName, &sa, &hKey)))
	{
		DEBUGMSG1("Error: Unable to create new UserData key. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// create SID key
	HKEY hUserDataKey;
	dwResult = CreateSecureRegKey(hKey, szUserSID, &sa, &hUserDataKey);
	RegCloseKey(hKey);
	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG2("Error: Unable to create new userdata key for user %s. Result: %d.", szUserSID, dwResult);
		return ERROR_FUNCTION_FAILED;		 
	}

	// migrate component data and set up SharedDLL changes required for this user.
	if (ERROR_SUCCESS != (dwResult = MigrateUserComponentData(hDatabase, hUserDataKey, szUserSID)))
		return dwResult;

	// if this is the system, also migrate permanent components
	if (0 == lstrcmp(szUserSID, szLocalSystemSID))
	{
		if (ERROR_SUCCESS != (dwResult = MigratePermanentComponentData(hDatabase, hUserDataKey)))
		{
			RegCloseKey(hUserDataKey);
			return dwResult;
		}
	}

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// Writes all component registration paths (including permanent
// components) for all users and updates database SharedDLL counts.
// Does not write any other user data. 
DWORD MigrateUserOnlyComponentData(MSIHANDLE hDatabase)
{
	DWORD dwResult = ERROR_SUCCESS;
	bool fMigratedSystem = false;

	// query for distinct users on the machine
 	PMSIHANDLE hUserView;
	if (ERROR_SUCCESS == dwResult)
	{
		if (ERROR_SUCCESS == (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT DISTINCT `User` FROM `Products`"), &hUserView)) &&
			ERROR_SUCCESS == (dwResult = MsiViewExecute(hUserView, 0)))
		{
			// default SID size is 256
			PMSIHANDLE hRec;
			DWORD cchUserSID = MEMORY_DEBUG(256);
			TCHAR* szUserSID = new TCHAR[cchUserSID];
			if (!szUserSID)
				dwResult = ERROR_OUTOFMEMORY;
							
			// loop across all users
			while (ERROR_SUCCESS == dwResult)
			{
				if (ERROR_SUCCESS != (dwResult = MsiViewFetch(hUserView, &hRec)))
					break;
			
				// retrieve the user SID
				DWORD cchTempSID = cchUserSID;
				dwResult = MsiRecordGetString(hRec, 1, szUserSID, &cchTempSID);
				if (ERROR_MORE_DATA == dwResult)
				{
					delete[] szUserSID;
					cchUserSID = ++cchUserSID;
					szUserSID = new TCHAR[++cchTempSID];
					if (!szUserSID)
					{
						dwResult = ERROR_OUTOFMEMORY;
						break;
					}
	
					dwResult = MsiRecordGetString(hRec, 1, szUserSID, &cchTempSID);
				}
				if (ERROR_SUCCESS != dwResult)
					break;
		
				// on failure just move on to the next user
	 			MigrateSingleUserOnlyComponentData(hDatabase, szUserSID);
				if (0 == lstrcmp(szUserSID, szLocalSystemSID))
					fMigratedSystem = true;

			}
			delete[] szUserSID;
			szUserSID = NULL;
			if (ERROR_NO_MORE_ITEMS == dwResult)
				dwResult = ERROR_SUCCESS;
		}

		// always migrate the system account so that permanent components
		// are registered correctly
		if (!fMigratedSystem)
			MigrateSingleUserOnlyComponentData(hDatabase, szLocalSystemSID);
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msishort\sources.inc ===
TARGETNAME=msishort
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=LIBRARY
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
        $(SDK_LIB_PATH)\msi.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\OLE32.lib

USE_MSVCRT=1

DLLDEF=..\msishort.def

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msishort.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msitran\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msistuff\sources.inc ===
TARGETNAME=MsiStuff
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

TARGETPATH=$(MSI_BUILD_TARGET)

USE_LIBCMT=1

TARGETLIBS=\
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib

C_DEFINES=$(C_DEFINES) -D_EXE
USE_NOLIBS=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=\
	..\msistuff.cpp \
	..\msistuff.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msishort\msishort.cpp ===
#include <windows.h>
#include <shlwapi.h>
#include <setupapi.h>
#include <assert.h>
#include <limits.h>
#include "shlobj.h"
#include "shlwapi.h"
#include "msi.h"

bool g_fWin9X = false;
int g_iMajorVersion = 0;
int g_iMinorVersion = 0;
int g_iBuildNumber = 0;


// API names used in GetProcAddress
#define MSIGETSHORTCUTTARGET  "MsiGetShortcutTargetA"
#define DLLGETVERSION         "DllGetVersion"

#define MSGUID(iid) {iid,0,0,{0xC0,0,0,0,0,0,0,0x46}}


// from shlobjp.h

// NT4 Console Server included shell32\shlink.h to get structure
// definitions and mimicked shell32\shlink.c to understand the
// stream format so our stream format is fixed forever. This is
// not bad since it was designed with extension in mind. We need
// to publish (as privately as possible) the file format and
// structures needed to read the file format.
//
// The stream format is a SHELL_LINK_DATA followed by
//   if SLDF_HAS_ID_LIST an ILSaveToStream followed by
//   if SLDF_HAS_LINK_INFO a LINKINFO followed by
//   if SLDF_HAS_NAME a STREAMSTRING followed by
//   if SLDF_RELPATH a STREAMSTRING followed by
//   if SLDF_WORKINGDIR a STREAMSTRING followed by
//   if SLDF_HAS_ARGS a STREAMSTRING followed by
//   if SLDF_HAS_ICON_LOCATION a STREAMSTRING followed by
//   SHWriteDataBlockList list of signature blocks
//
// Where a STREAMSTRING is a USHORT count of characters
// followed by that many (SLDF_UNICODE ? WIDE : ANSI) characters.
//
typedef struct {        // sld
    DWORD       cbSize;                 // signature for this data structure
    CLSID       clsid;                  // our GUID
    DWORD       dwFlags;                // SHELL_LINK_DATA_FLAGS enumeration

    DWORD       dwFileAttributes;
    FILETIME    ftCreationTime;
    FILETIME    ftLastAccessTime;
    FILETIME    ftLastWriteTime;
    DWORD       nFileSizeLow;

    int         iIcon;
    int         iShowCmd;
    WORD        wHotkey;
    WORD        wUnused;
    DWORD       dwRes1;
    DWORD       dwRes2;
} SHELL_LINK_DATA, *LPSHELL_LINK_DATA;


#define WIN
#define OLE32

// defines for guid separators
#define chComponentGUIDSeparatorToken    '>'
#define chGUIDAbsentToken                '<'
#define chGUIDCOMToCOMPlusInteropToken   '|'

enum ipgEnum
{
	ipgFull       = 0,  // no compression
	ipgPacked     = 1,  // remove punctuation and reorder low byte first
	ipgCompressed = 2,  // max text compression, can't use in reg keys or value names
	ipgPartial    = 3,  // partial translation, between ipgCompressed and ipgPacked
//  ipgMapped     = 4,  // pack as mapped token (not implemented)
	ipgTrimmed    = 5,  // remove punctuation only - don't reorder
};

const int cchMaxFeatureName           = MAX_FEATURE_CHARS;
const int cchGUID                     = 38;
const int cchGUIDCompressed           = 20;  // used in descriptors only
const int cchComponentId              = cchGUID;
const int cchComponentIdCompressed    = cchGUIDCompressed;
const int cchProductCode              = cchGUID;
const int cchProductCodeCompressed    = cchGUIDCompressed;

const unsigned char rgOrderGUID[32] = {8,7,6,5,4,3,2,1, 13,12,11,10, 18,17,16,15,
									   21,20, 23,22, 26,25, 28,27, 30,29, 32,31, 34,33, 36,35}; 

const unsigned char rgTrimGUID[32]  = {1,2,3,4,5,6,7,8, 10,11,12,13, 15,16,17,18,
									   20,21, 22,23, 25,26, 27,28, 29,30, 31,32, 33,34, 35,36}; 

const unsigned char rgOrderDash[4] = {9, 14, 19, 24};

const unsigned char rgDecodeSQUID[95] =
{  0,85,85,1,2,3,4,5,6,7,8,9,10,11,85,12,13,14,15,16,17,18,19,20,21,85,85,85,22,85,23,24,
// !  "  # $ % & ' ( ) * + ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?  @
  25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,85,52,53,54,55,
// A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _  `
  56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,85,83,84,85};
// a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~  ^ 0x7F

typedef HRESULT (__stdcall *LPDLLGETVERSION)(DLLVERSIONINFO *);
typedef UINT (WINAPI *pfnMsiGetShortcutTargetA)(
	LPCSTR    szShortcutPath,    // full file path for the shortcut
	LPSTR     szProductCode,     // returned product code   - GUID
	LPSTR     szFeatureId,       // returned Feature Id.
	LPSTR     szComponentCode);  // returned component code - GUID


/*****************************************************
*
*  Functions I've copied from Src\Engine\Msinst.cpp
*
*****************************************************/


UINT DoCoInitialize()
{
	HRESULT hRes = OLE32::CoInitialize(0);  // we're statically linked into OLE32.DLL

	if (SUCCEEDED(hRes))
	{
		return hRes;
	}
	else if (RPC_E_CHANGED_MODE == hRes)
	{
		//?? Is this OK to ignore? 

		// ignore -- OLE has been initialized with COINIT_MULTITHREADED
	}
	else
	{
		return ERROR_INSTALL_FAILURE;
	}

	return E_FAIL;
}


bool UnpackGUID(const char* szSQUID, char* szGUID, ipgEnum ipg)
{ 
	const unsigned char* pch;
	switch (ipg)
	{
	case ipgFull:
		lstrcpynA(szGUID, szSQUID, cchGUID+1);
		return true;
	case ipgPacked:
	{
		pch = rgOrderGUID;
		while (pch < rgOrderGUID + sizeof(rgOrderGUID))
			if (*szSQUID)
				szGUID[*pch++] = *szSQUID++;
			else              // unexpected end of string
				return false;
		break;
	}
	case ipgTrimmed:
	{
		pch = rgTrimGUID;
		while (pch < rgTrimGUID + sizeof(rgTrimGUID))
			if (*szSQUID)
				szGUID[*pch++] = *szSQUID++;
			else              // unexpected end of string
				return false;
		break;
	}
	case ipgCompressed:
	{
		pch = rgOrderGUID;
#ifdef DEBUG //!! should not be here for performance reasons, onus is on caller to insure buffer is sized properly
		int cchTemp = 0;
		while (cchTemp < cchGUIDCompressed)     // check if string is atleast cchGUIDCompressed chars long,
			if (!(szSQUID[cchTemp++]))          // can't use lstrlen as string doesn't HAVE to be null-terminated.
				return false;
#endif
		for (int il = 0; il < 4; il++)
		{
			int cch = 5;
			unsigned int iTotal = 0;
			while (cch--)
			{
				unsigned int iNew = szSQUID[cch] - '!';
				if (iNew >= sizeof(rgDecodeSQUID) || (iNew = rgDecodeSQUID[iNew]) == 85)
					return false;   // illegal character
				iTotal = iTotal * 85 + iNew;
			}
			szSQUID += 5;
			for (int ich = 0; ich < 8; ich++)
			{
				int ch = (iTotal & 15) + '0';
				if (ch > '9')
					ch += 'A' - ('9' + 1);
				szGUID[*pch++] = (char)ch;
				iTotal >>= 4;
			}
		}
		break;
	}
	case ipgPartial:
	{
		for (int il = 0; il < 4; il++)
		{
			int cch = 5;
			unsigned int iTotal = 0;
			while (cch--)
			{
				unsigned int iNew = szSQUID[cch] - '!';
				if (iNew >= sizeof(rgDecodeSQUID) || (iNew = rgDecodeSQUID[iNew]) == 85)
					return false;   // illegal character
				iTotal = iTotal * 85 + iNew;
			}
			szSQUID += 5;
			for (int ich = 0; ich < 8; ich++)
			{
				int ch = (iTotal & 15) + '0';
				if (ch > '9')
					ch += 'A' - ('9' + 1);
				*szGUID++ = (char)ch;
				iTotal >>= 4;
			}
		}
		*szGUID = 0;
		return true;
	}
	default:
		return false;
	} // end switch
	pch = rgOrderDash;
	while (pch < rgOrderDash + sizeof(rgOrderDash))
		szGUID[*pch++] = '-';
	szGUID[0]         = '{';
	szGUID[cchGUID-1] = '}';
	szGUID[cchGUID]   = 0;
	return true;
}


BOOL DecomposeDescriptor(
							const char* szDescriptor,
							char* szProductCode,
							char* szFeatureId,
							char* szComponentCode,
							DWORD* pcchArgsOffset,	
							DWORD* pcchArgs = 0,
							bool* pfComClassicInteropForAssembly = 0
							)

/*----------------------------------------------------------------------------
Decomposes a descriptor plus optional args into its constituent parts. 

Arguments:
	szDescriptor:  the descriptor optionally followed by arguments
	szProductCode: a buffer of size cchGUID+1 to contain the descriptor's
						product code. May be NULL if not desired.
	szFeatureId:   a buffer of size cchMaxFeatureName+1 to contain the
						descriptor's feature ID. May be NULL if not desired.
	szComponentCode: a buffer of size cchGUID+1 to contain the
						  descriptor's component code. May be NULL if not desired.
	pcchArgsOffset: Will contain the character offset to the args. May be NULL
						 if not desired.
Returns:
	TRUE - Success
	FALSE - szDescriptor was of invalid form
------------------------------------------------------------------------------*/
{
	assert(szDescriptor);

	const char* pchDescriptor = szDescriptor;
	int cchDescriptor          = lstrlenA(pchDescriptor);
	int cchDescriptorRemaining = cchDescriptor;

	if (cchDescriptorRemaining < cchProductCodeCompressed) // minimum size of a descriptor
		return FALSE;

	char szProductCodeLocal[cchProductCode + 1];
	char szFeatureIdLocal[cchMaxFeatureName + 1];
	bool fComClassicInteropForAssembly = false;


	// we need these values locally for optimised descriptors
	if (!szProductCode)
		szProductCode = szProductCodeLocal; 
	if (!szFeatureId)
		szFeatureId = szFeatureIdLocal;
	if(!pfComClassicInteropForAssembly)
		pfComClassicInteropForAssembly = &fComClassicInteropForAssembly;
	char* pszCurr = szFeatureId;

	if(*pchDescriptor == chGUIDCOMToCOMPlusInteropToken)
	{
		pchDescriptor++;
		*pfComClassicInteropForAssembly = true;
	}
	else
	{
		*pfComClassicInteropForAssembly = false;
	}

	// unpack the product code
	if (!UnpackGUID(pchDescriptor, szProductCode, ipgCompressed))
		return FALSE;

	pchDescriptor += cchProductCodeCompressed;
	cchDescriptorRemaining -= cchProductCodeCompressed;

	int cchFeatureRemaining = cchMaxFeatureName;

	// look for the feature
	while ((*pchDescriptor != chComponentGUIDSeparatorToken) && (*pchDescriptor != chGUIDAbsentToken))
	{
		// have we exceeded the maximum feature size
		if(!cchFeatureRemaining--)
			return FALSE; 

		*pszCurr++ = *pchDescriptor;

		pchDescriptor++;
		// have we reached the end without encountering either 
		// the chComponentGUIDSeparatorToken or the chGUIDAbsentToken
		if(--cchDescriptorRemaining == 0)
			return FALSE; 
	}

	if(pchDescriptor - szDescriptor == (*pfComClassicInteropForAssembly == false ? cchProductCodeCompressed : cchProductCodeCompressed + 1))// we do not have the feature
	{
		if(MsiEnumFeaturesA(szProductCode, 0, szFeatureId, 0) != ERROR_SUCCESS)
			return FALSE;
		char szFeatureIdTmp[cchMaxFeatureName + 1];
		if(MsiEnumFeaturesA(szProductCode, 1, szFeatureIdTmp, 0) != ERROR_NO_MORE_ITEMS) //?? product was supposed to have only one feature
			return FALSE;
	}
	else
		*pszCurr = 0;
	
	cchDescriptorRemaining--; // for the chComponentGUIDSeparatorToken or the chGUIDAbsentToken
	if (*pchDescriptor++ == chComponentGUIDSeparatorToken)// we do have the component id
	{
		// do we have enough characters left for a Compressed guid
		if (cchDescriptorRemaining < cchComponentIdCompressed)
			return FALSE;

		if (szComponentCode)
		{
			if (!UnpackGUID(pchDescriptor, szComponentCode, ipgCompressed))
				return FALSE;
		}

		pchDescriptor  += cchComponentIdCompressed;
		cchDescriptorRemaining  -= cchComponentIdCompressed;
	}
	else
	{
		// we do not have a component id
		assert(*(pchDescriptor - 1) == chGUIDAbsentToken);

		if (szComponentCode) // we need to get component code			
			*szComponentCode = 0; // initialize to null since we were not able to get the component here
	}

	if (pcchArgsOffset)
	{
		assert((pchDescriptor - szDescriptor) <= UINT_MAX);			//--merced: 64-bit ptr subtraction may lead to values too big for *pcchArgsOffset
		*pcchArgsOffset = (DWORD)(pchDescriptor - szDescriptor);

		if (pcchArgs)
		{
			*pcchArgs = cchDescriptor - *pcchArgsOffset;
		}
	}

	return TRUE;
}


/*****************************************************
*
*  Functions I've copied from Src\Engine\Services.cpp
*
*****************************************************/


IUnknown* CreateCOMInterface(const CLSID& clsId)
{
	HRESULT hres;
	IUnknown* piunk;

	//!! currently assumes static linking, later change to "LoadLibrary"

//	if(fFalse == m_fCoInitialized)
//	{
//		hres = OLE32::CoInitialize(0);
//		if(FAILED(hres))
//		{
//			return 0;
//		}
//		m_fCoInitialized = fTrue;
//	}

	const int iidUnknown          = 0x00000L;
	#define GUID_IID_IUnknown     MSGUID(iidUnknown)
	const GUID IID_IUnknown = GUID_IID_IUnknown;
	hres = OLE32::CoCreateInstance(clsId,  /* eugend: we're statically linked into OLE32 */
							0,
							CLSCTX_INPROC_SERVER,
							IID_IUnknown,
							(void**)&piunk);
	if (SUCCEEDED(hres))
		return piunk;
	else
		return 0;
}


enum iddSupport{
        iddOLE      = 0,
        iddShell    = 1, // smart shell
};

// Are Darwin Descriptors supported?
bool IsDarwinDescriptorSupported(iddSupport iddType)
{
	static int fRetDD    = -1;
	static int fRetShell = -1;
	if(iddType == iddOLE)
	{
		if(fRetDD == -1) // we have not evaluated as yet
		{
			fRetDD = FALSE; // initialize to false
			// the logic to determine if we can create Darwin Descriptor shortcuts
			if((g_fWin9X == false) && (g_iMajorVersion >= 5))
			{
				// we are on NT 5.0 or greater, we have GPT support
				fRetDD = TRUE;
			}
			else
			{
				// check for the correct entry point that indicates that we have DD support
				HINSTANCE hLib;
				FARPROC pEntry;
				const char rgchGPTSupportEntryDll[] = "OLE32.DLL";
				const char rgchGPTSupportEntry[] = "CoGetClassInfo";
				if((hLib = WIN::LoadLibraryEx(rgchGPTSupportEntryDll, 0, DONT_RESOLVE_DLL_REFERENCES)) != 0)
				{
					if((pEntry = WIN::GetProcAddress(hLib, rgchGPTSupportEntry)) != 0)
					{
						// we have detected the magic entry point, we have GPT support
						fRetDD = TRUE;
					}
					WIN::FreeLibrary(hLib);
				}
			}
		}
		return fRetDD ? true : false;
	}
	else if(iddType == iddShell)
	{
		if(fRetShell == -1) // we have not evaluated as yet
		{
			fRetShell = FALSE;
			HMODULE hShell = WIN::LoadLibraryEx("SHELL32", 0, DONT_RESOLVE_DLL_REFERENCES);
			if ( hShell )
			{
				// SHELL32 detected. Determine version.
				DLLVERSIONINFO VersionInfo;
				memset(&VersionInfo, 0, sizeof(VersionInfo));
				VersionInfo.cbSize = sizeof(DLLVERSIONINFO);
				LPDLLGETVERSION pfVersion = (LPDLLGETVERSION)WIN::GetProcAddress(hShell, DLLGETVERSION);
				if ( pfVersion && (*pfVersion)(&VersionInfo) == ERROR_SUCCESS &&
					  ((VersionInfo.dwMajorVersion > 4) ||
						(VersionInfo.dwMajorVersion == 4 && VersionInfo.dwMinorVersion > 72) ||
						(VersionInfo.dwMajorVersion == 4 && VersionInfo.dwMinorVersion == 72 && VersionInfo.dwBuildNumber >= 3110)))
				{
					 fRetShell = TRUE;
				}
				WIN::FreeLibrary(hShell);
			}
		}
		return fRetShell ? true : false;
	}
	else
	{
		assert(0);// this should never happen
		return false;
	}
}


/*****************************************************
*
*  Functions I've added (eugend)
*
*****************************************************/


UINT LoadMsiAndAPI(HMODULE& hMSI, pfnMsiGetShortcutTargetA& pfAPI)
{
	UINT uResult = ERROR_SUCCESS;
	LPDLLGETVERSION pfVersion = NULL;

	pfAPI = NULL;
	if ( hMSI )
	{
		return ERROR_FUNCTION_FAILED;
//		assert(0);
//		WIN::FreeLibrary(hMSI);
	}
	hMSI = WIN::LoadLibrary("MSI");
	if ( !hMSI )
		return ERROR_NOT_INSTALLED;

	// MSI detected. Get the API.
	pfAPI = (pfnMsiGetShortcutTargetA)WIN::GetProcAddress(hMSI, MSIGETSHORTCUTTARGET);
	if ( !pfAPI )
	{
		// this is possible since MsiGetShortcutTarget API is not implemented in Darwin < 1.1
		uResult = ERROR_CALL_NOT_IMPLEMENTED;
		goto Return;
	}

	// Determine version.
	pfVersion = (LPDLLGETVERSION)::GetProcAddress(hMSI, DLLGETVERSION);
	if ( !pfVersion )
	{
		uResult = ERROR_CALL_NOT_IMPLEMENTED;
		goto Return;
	}
	DLLVERSIONINFO VersionInfo;
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.cbSize = sizeof(DLLVERSIONINFO);
	if ( (*pfVersion)(&VersionInfo) != NOERROR )
	{
		uResult = ERROR_FUNCTION_FAILED;
		goto Return;
	}
	g_iMajorVersion = VersionInfo.dwMajorVersion;
	g_iMinorVersion = VersionInfo.dwMinorVersion;
	g_iBuildNumber = VersionInfo.dwBuildNumber;

Return:
	if ( uResult != ERROR_SUCCESS )
		WIN::FreeLibrary(hMSI);
	return uResult;
}


void CheckOSVersion()
{
	OSVERSIONINFO osviVersion;
	memset(&osviVersion, 0, sizeof(osviVersion));
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	WIN::GetVersionEx(&osviVersion);	// fails only if size set wrong

	if ( osviVersion.dwPlatformId == VER_PLATFORM_WIN32_NT )
		g_fWin9X = false;
	else
		g_fWin9X = true;
}

//  Provides a fix to MsiGetShortcutTarget API for ANSI Windows Installer version <= 1.2


UINT DoGetMsiShortcutTarget(LPCSTR szShortcutPath, LPSTR szProductCode, LPSTR szFeatureId, LPSTR szComponentCode);

extern "C"
UINT WINAPI GetMsiShortcutTargetA(
											LPCSTR    szShortcutPath,		// full file path for the shortcut
											LPSTR     szProductCode,		// returned product code   - GUID
											LPSTR     szFeatureId,			// returned Feature Id.
											LPSTR     szComponentCode)	// returned component code - GUID
{
	return DoGetMsiShortcutTarget(szShortcutPath, szProductCode,
											szFeatureId, szComponentCode);
}

LONG MultiByteToWCHAR(LPCSTR pszAString, LPWSTR pszWString)
{
	// converts char string to Unicode  pszWString can be null, in which case returns success.
	if ( !pszWString )
		return ERROR_SUCCESS;

	int cch = MultiByteToWideChar(CP_ACP, 0, pszAString, -1, 0, 0);
	int iRes = MultiByteToWideChar(CP_ACP, 0, pszAString, -1, pszWString, cch);
	return iRes == cch ? ERROR_SUCCESS : WIN::GetLastError();
}

extern "C"
UINT WINAPI GetMsiShortcutTargetW(
											LPCWSTR    szShortcutPath,	  // full file path for the shortcut
											LPWSTR     szProductCode,	  // returned product code   - GUID
											LPWSTR     szFeatureId,		  // returned Feature Id.
											LPWSTR     szComponentCode)	  // returned component code - GUID
{
	char rgchProductCode[cchProductCode+1] = {NULL};
	char rgchFeatureId[cchMaxFeatureName+1] = {NULL};
	char rgchComponentCode[cchComponentId+1] = {NULL};
	int cch = WideCharToMultiByte(CP_ACP, 0, szShortcutPath, -1, 0, 0, 0, 0);
	char* pszShortcutPath = new char[cch];
	if ( !pszShortcutPath )
		return ERROR_NOT_ENOUGH_MEMORY;
	else
		*pszShortcutPath = 0;
	WideCharToMultiByte(CP_ACP, 0, szShortcutPath, -1, pszShortcutPath, cch, 0, 0);

	UINT uResult = DoGetMsiShortcutTarget(pszShortcutPath, rgchProductCode,
													  rgchFeatureId, rgchComponentCode);
	if ( uResult == ERROR_SUCCESS )
		uResult = MultiByteToWCHAR(rgchProductCode, szProductCode);
	if ( uResult == ERROR_SUCCESS )
		uResult = MultiByteToWCHAR(rgchFeatureId, szFeatureId);
	if ( uResult == ERROR_SUCCESS )
		uResult = MultiByteToWCHAR(rgchComponentCode, szComponentCode);

	delete [] pszShortcutPath;
	return uResult;
}

UINT DoGetMsiShortcutTarget(LPCSTR szShortcutPath, LPSTR szProductCode,
									 LPSTR szFeatureId, LPSTR szComponentCode)
{
	if ( !szShortcutPath )
		return ERROR_INVALID_PARAMETER;
	
	UINT uResult = ERROR_SUCCESS;
	IShellLinkDataList* psdl=0;
	IPersistFile* ppf=0;
	HANDLE hFile = 0;
	bool fOLEInitialized = false;
	HMODULE hMSI = 0;
	pfnMsiGetShortcutTargetA pfAPI = NULL;
	const GUID IID_IShellLinkDataList =  
		{0x45e2b4ae, 0xb1c3, 0x11d0, {0xb9, 0x2f, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1}};
	const int clsidShellLink = 0x00021401L;
	#define GUID_CLSID_ShellLink MSGUID(clsidShellLink)
	const GUID CLSID_ShellLink = GUID_CLSID_ShellLink;

	uResult = LoadMsiAndAPI(hMSI, pfAPI);
	if ( uResult != ERROR_SUCCESS )
		goto Return;

	CheckOSVersion();

	bool fCallMsiAPI;
	if ( !g_fWin9X )
		// UNICODE MSI.DLL is OK, so it's safe to call directly the API.
		fCallMsiAPI = true;
	else if ( (g_iMajorVersion >= 1) &&
				 (g_iMinorVersion > 20 || 
				  (g_iMinorVersion == 20 && g_iBuildNumber >= 1710)) )
		// we're on Win9x.  The bug was fixed in build 1710
		// so that it is OK to call the API directly.
		fCallMsiAPI = true;
	else
		fCallMsiAPI	= false;

	if(!IsDarwinDescriptorSupported(iddOLE) && !IsDarwinDescriptorSupported(iddShell))
	{
		uResult = E_NOTIMPL;
		goto Return;
	}

	if ( fCallMsiAPI )
	{
		uResult = (*pfAPI)(szShortcutPath, szProductCode, szFeatureId, szComponentCode);
		goto Return;
	}

	// the fixed up code in GetShortcutTarget.  I've commented out stuff that seemed
	// unnecessary.

//!! eugend: moved up a bit
//	if(!IsDarwinDescriptorSupported(iddOLE) && !IsDarwinDescriptorSupported(iddShell))
//		return fFalse;


//!! eugend: moved to top of function
//	if ( ! szShortcutTarget )
//		return fFalse;

//!! eugend: is it possible to elevate/impersonate at this point?
	// impersonate if shortcut is on a network path and we are a service
//	Bool fImpersonate = (g_scServerContext == scService) && (GetImpersonationFromPath(szShortcutTarget) == fTrue) ? fTrue : fFalse;

	uResult = DoCoInitialize();  // this is from MSINST.CPP's MsiGetShortcutTarget
	if ( SUCCEEDED(uResult) )
		fOLEInitialized = true;
	else
		goto Return;
	
	IUnknown *piunk;
	piunk = CreateCOMInterface(CLSID_ShellLink);
	if(piunk == 0)
	{
		uResult = ERROR_FUNCTION_FAILED;
		goto Return;
	}

	HRESULT hres;
	hres = piunk->QueryInterface(IID_IShellLinkDataList, (void **) &psdl);
	piunk->Release();
	if ((FAILED(hres)) || (psdl == 0))
	{
		// IID_IShellLinkDataList not supported try munging through the file itself
		// Try to open the file

//		if(fImpersonate)
//			AssertNonZero(StartImpersonating());
		/*CHandle*/ hFile = CreateFileA(szShortcutPath,
												GENERIC_READ,
												FILE_SHARE_READ,
												NULL,
												OPEN_EXISTING,
												FILE_ATTRIBUTE_NORMAL,
												NULL);

		DWORD dwLastError = GetLastError();
//		if(fImpersonate)
//			StopImpersonating();

		if(hFile == INVALID_HANDLE_VALUE) // unable to open the link file
		{
			uResult = ERROR_FUNCTION_FAILED;
			goto Return;
		}

		SHELL_LINK_DATA sld;
		memset(&sld, 0, sizeof(sld));
		DWORD cbSize=0;

		// Now, read out data...
		DWORD dwNumberOfBytesRead;
		if(!WIN::ReadFile(hFile,(LPVOID)&sld,sizeof(sld),&dwNumberOfBytesRead,0) ||
			sizeof(sld) != dwNumberOfBytesRead) // could not read the shortcut info
		{
			uResult = ERROR_FUNCTION_FAILED;
			goto Return;
		}

		// check to see if the link has a pidl
		if(sld.dwFlags & SLDF_HAS_ID_LIST)
		{
			// Read the size of the IDLIST
			USHORT cbSize1;
			if (!WIN::ReadFile(hFile, (LPVOID)&cbSize1, sizeof(cbSize1), &dwNumberOfBytesRead, 0) ||
				sizeof(cbSize1) != dwNumberOfBytesRead)// could not read the shortcut info
			{
				uResult = ERROR_FUNCTION_FAILED;
				goto Return;
			}

			WIN::SetFilePointer(hFile, cbSize1, 0, FILE_CURRENT);
		}

		// check to see if we have a linkinfo pointer
		if(sld.dwFlags & SLDF_HAS_LINK_INFO)
		{
			// the linkinfo pointer is just a DWORD
			if(!WIN::ReadFile(hFile,(LPVOID)&cbSize,sizeof(cbSize),&dwNumberOfBytesRead,0) ||
				sizeof(cbSize) != dwNumberOfBytesRead) // could not read the shortcut info
			{
				uResult = ERROR_FUNCTION_FAILED;
				goto Return;
			}

			// do we need to advance any further than just a dword?
			if (cbSize >= sizeof(DWORD))
			{
				cbSize -= sizeof(DWORD);
				WIN::SetFilePointer(hFile, cbSize, 0, FILE_CURRENT);
			}
		}

		// is this a unicode link?
		int bUnicode = (sld.dwFlags & SLDF_UNICODE);

		// skip all the string info in the links
		static const unsigned int rgdwFlags[] = {SLDF_HAS_NAME, SLDF_HAS_RELPATH, SLDF_HAS_WORKINGDIR, SLDF_HAS_ARGS, SLDF_HAS_ICONLOCATION, 0};
		for(int cchIndex = 0; rgdwFlags[cchIndex]; cchIndex++)
		{
			if(sld.dwFlags & rgdwFlags[cchIndex])
			{
				USHORT cch;

				// get the size
				if(!WIN::ReadFile(hFile, (LPVOID)&cch, sizeof(cch), &dwNumberOfBytesRead,0) ||
					sizeof(cch) != dwNumberOfBytesRead) // could not read the shortcut info
				{
					uResult = ERROR_FUNCTION_FAILED;
					goto Return;
				}

				// skip over the string
				WIN::SetFilePointer(hFile, cch * (bUnicode ? sizeof(WCHAR) : sizeof(char)), 0, FILE_CURRENT);
			}
		}

		// Read in extra data sections
		EXP_DARWIN_LINK expDarwin;
		for(;;)
		{
			DATABLOCK_HEADER dbh;
			memset(&dbh, 0, sizeof(dbh));

			// read in the datablock header
			if(!WIN::ReadFile(hFile, (LPVOID)&dbh, sizeof(dbh), &dwNumberOfBytesRead,0) ||
				sizeof(dbh) != dwNumberOfBytesRead) // could not read the shortcut info
			{
				uResult = ERROR_FUNCTION_FAILED;
				goto Return;
			}

			// check to see if we have DARWIN extra data
			if (dbh.dwSignature == EXP_DARWIN_ID_SIG)
			{
				// we do, so read the rest of the darwin info
				if(!WIN::ReadFile(hFile, (LPVOID)((char*)&expDarwin + sizeof(dbh)), sizeof(expDarwin) - sizeof(dbh), &dwNumberOfBytesRead, 0) ||
				sizeof(expDarwin) - sizeof(dbh) != dwNumberOfBytesRead)// could not read the shortcut info
				{
					uResult = ERROR_FUNCTION_FAILED;
					goto Return;
				}
				break;// we found the darwin descriptor

			}
			else
			{
				// this is some other extra-data blob, skip it and go on
				WIN::SetFilePointer(hFile, dbh.cbSize - sizeof(dbh), 0, FILE_CURRENT);
			}
		}
		uResult = DecomposeDescriptor(
//#ifdef UNICODE
//							expDarwin.szwDarwinID,
//#else
							expDarwin.szDarwinID,
//#endif
							szProductCode,
							szFeatureId,
							szComponentCode,
							0,
							0,
							0) ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
	}
	else
	{
		const int iidPersistFile      = 0x0010BL;
		#define GUID_IID_IPersistFile MSGUID(iidPersistFile)
		const GUID IID_IPersistFile = GUID_IID_IPersistFile;
		hres = psdl->QueryInterface(IID_IPersistFile, (void **) &ppf);
		if ((FAILED(hres)) || (ppf == 0))
		{
			uResult = hres;
			goto Return;
		}
	
/*
		if(fImpersonate)
			AssertNonZero(StartImpersonating());
#ifndef UNICODE
*/			
	
/*
		// called from MsiGetShortcutTarget -- cannot use CTempBuffer.
		CAPITempBuffer<WCHAR, MAX_PATH> wsz; // Buffer for unicode string
		wsz.SetSize(lstrlen(szShortcutTarget) + 1);
		MultiByteToWideChar(CP_ACP, 0, szShortcutTarget, -1, wsz, wsz.GetSize());
		hres = ppf->Load(wsz, STGM_READ);
*/
		// same code as above, rewritten not to use CAPITempBuffer
		int cch = lstrlenA(szShortcutPath);
		WCHAR* pszShortcutPath = new WCHAR[cch+1];
		if ( !pszShortcutPath )
		{
			uResult = ERROR_NOT_ENOUGH_MEMORY;
			goto Return;
		}
		MultiByteToWideChar(CP_ACP, 0, szShortcutPath, -1, pszShortcutPath, cch+1);
		hres = ppf->Load(pszShortcutPath, STGM_READ);
		delete [] pszShortcutPath;
/*
#else
		hres = ppf->Load(szShortcutPath, STGM_READ);
#endif
		if(fImpersonate)
			StopImpersonating();
*/		
		if (FAILED(hres))
		{
			uResult = hres;
			goto Return;
		}
	
		EXP_DARWIN_LINK* pexpDarwin = 0;
	
		hres = psdl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin);
		if (FAILED(hres) || (pexpDarwin == 0))
		{
			uResult = ERROR_FUNCTION_FAILED;
			goto Return;
		}
	
		uResult = DecomposeDescriptor(
//	#ifdef UNICODE
//								pexpDarwin->szwDarwinID,
//	#else
								pexpDarwin->szDarwinID,
//	#endif
								szProductCode,
								szFeatureId,
								szComponentCode,
								0,
								0,
								0) ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
	
		LocalFree(pexpDarwin);
	}

Return:
	if (hMSI)
		WIN::FreeLibrary(hMSI);
	if (hFile)
		WIN::CloseHandle(hFile);
	if (psdl)
		psdl->Release();
	if (ppf)
		ppf->Release();
	if (fOLEInitialized)
		OLE32::CoUninitialize();

	return uResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msistuff\msistuff.cpp ===
//+-------------------------------------------------------------------------
//
//      Copyright (C) Microsoft Corporation. All rights reserved.
//
//      File:           msistuff.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include "..\setup.exe\common.h"
#include "strsafe.h"

//=======================================================
// command line options and matching properties
// ORDER is IMPORTANT!
//=======================================================
TCHAR rgszCommandOptions[]= TEXT("udnviawpmo");
//////////////////////////        0123456789

TCHAR* rgszResName[] = {
/* BaseURL                 */ ISETUPPROPNAME_BASEURL, 
/* Msi Package             */ ISETUPPROPNAME_DATABASE,
/* Product Name            */ ISETUPPROPNAME_PRODUCTNAME,
/* Minimum Msi Version     */ ISETUPPROPNAME_MINIMUM_MSI,
/* InstMsi URL Location    */ ISETUPPROPNAME_INSTLOCATION,
/* InstMsiA                */ ISETUPPROPNAME_INSTMSIA,
/* InstMsiW                */ ISETUPPROPNAME_INSTMSIW,
/* Properties              */ ISETUPPROPNAME_PROPERTIES,
/* Patch                   */ ISETUPPROPNAME_PATCH,
/* Operation               */ ISETUPPROPNAME_OPERATION
};
const int cStandardProperties = sizeof(rgszResName)/sizeof(TCHAR*);

TCHAR rgchResSwitch[] ={TEXT('u'),TEXT('d'),TEXT('n'),TEXT('v'),TEXT('i'),TEXT('a'),TEXT('w'),TEXT('p'),TEXT('m'),TEXT('o')};

const DWORD lcidLOCALE_INVARIANT = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);

//=======================================================
// special options
//=======================================================
const TCHAR chProperties      = TEXT('p');
const TCHAR chMinMsiVer       = TEXT('v');
const TCHAR chOperation       = TEXT('o');
const TCHAR szInstall[]         = TEXT("INSTALL");
const TCHAR szInstallUpd[]      = TEXT("INSTALLUPD");
const TCHAR szMinPatch[]        = TEXT("MINPATCH");
const TCHAR szMajPatch[]        = TEXT("MAJPATCH");
const int   iMinMsiAllowedVer = 150;



//=======================================================
// function prototypes
//=======================================================

void           DisplayHelp();
bool           ParseCommandLine(LPTSTR lpCommandLine);
TCHAR          SkipWhiteSpace(TCHAR*& rpch);
bool           SkipValue(TCHAR*& rpch);
bool           RemoveQuotes(LPCTSTR lpOriginal, LPTSTR lpStripped, DWORD cchStripped);
bool           DisplayResources(LPCTSTR lpExecutable);
bool           DisplayInstallResource(HMODULE hExeModule, LPCTSTR lpszType, LPCTSTR lpszName);
BOOL  CALLBACK EnumResNamesProc(HMODULE hExeModule, LPCTSTR lpszType, LPTSTR lpszName, LONG_PTR lParam);

//=======================================================
// global constants
//=======================================================
int g_cResources = 0; // count of resources in setup.exe; information purposes only

//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
        if (argc <= 2)
        {
                if (1 == argc
                    || 0 == lstrcmp(argv[1], TEXT("/?"))
                    || 0 == lstrcmp(argv[1], TEXT("-?")))
                {
                        //
                        // display help

                        DisplayHelp();
                }
                else
                {
                        //
                        // display setup resources

                        TCHAR szExecutable[MAX_PATH] = {0};
                        if (FAILED(StringCchCopy(szExecutable, sizeof(szExecutable)/sizeof(szExecutable[0]), argv[1])))
                            return -1;
                        if (!DisplayResources(szExecutable))
                                return -1;
                }

        }
        else
        {
                //
                // set resource properties

                TCHAR *szCommandLine = GetCommandLine();
                if (!ParseCommandLine(szCommandLine))
                        return -1;
        }

        return 0;
}

//_____________________________________________________________________________________________________
//
// DisplayHelp
//_____________________________________________________________________________________________________

void DisplayHelp()
{
        TCHAR szHelp[] =
                                        TEXT("Copyright (c) Microsoft Corporation. All rights reserved.\n")
                                        TEXT("\n")
                                        TEXT("MsiStuff will display or update the resources \n")
                                        TEXT(" in the setup.exe boot strap executable\n")
                                        TEXT("\n")
                                        TEXT("[MsiStuff Command Line Syntax]\n")
                                        TEXT(" Display Properties->> msistuff setup.exe \n")
                                        TEXT(" Set Properties    ->> msistuff setup.exe option {data} ... \n")
                                        TEXT("\n")
                                        TEXT("[MsiStuff Options -- Multiple specifications are allowed]\n")
                                        TEXT(" BaseURL                             - /u {value} \n")
                                        TEXT(" Msi                                 - /d {value} \n")
                                        TEXT(" Product Name                        - /n {value} \n")
                                        TEXT(" Minimum Msi Version                 - /v {value} \n")
                                        TEXT(" InstMsi URL Location                - /i {value} \n")
                                        TEXT(" InstMsiA                            - /a {value} \n")
                                        TEXT(" InstMsiW                            - /w {value} \n")
                                        TEXT(" Patch                               - /m {value} \n")
                                        TEXT(" Operation                           - /o {value} \n")
                                        TEXT(" Properties (PROPERTY=VALUE strings) - /p {value} \n")
                                        TEXT("\n")
                                        TEXT("If an option is specified multiple times, the last one wins\n")
                                        TEXT("\n")
                                        TEXT("/p must be last on the command line.  The remainder of\n")
                                        TEXT("the command line is considered a part of the {value}\n")
                                        TEXT("This also means that /p cannot be specified multiple times\n");
        _tprintf(TEXT("%s"), szHelp);
}

//_____________________________________________________________________________________________________
//
// ParseCommandLine
//
//       If a property has a value that contains spaces, the value must be enclosed in quotation marks
//_____________________________________________________________________________________________________

bool ParseCommandLine(LPTSTR lpCommandLine)
{
        if (!lpCommandLine)
            return false;

        TCHAR szSetupEXE[MAX_PATH] = {0};
        TCHAR szFullPath[2*MAX_PATH] = {0};

        TCHAR  chNextCommand;
        TCHAR *pchCommandLine = lpCommandLine;

        // skip over module name and subsequent white space
        if (!SkipValue(pchCommandLine))
            return false;
        chNextCommand = SkipWhiteSpace(pchCommandLine);
        
        TCHAR* pchCommandData = pchCommandLine;
        if (!SkipValue(pchCommandLine))
            return false;
        if (!RemoveQuotes(pchCommandData, szSetupEXE, sizeof(szSetupEXE)/sizeof(szSetupEXE[0])))
            return false;

        // handle possibility of a relative path
        LPTSTR lpszFilePart = 0;
        int cchFullPath = 0;
        if (0 == (cchFullPath = GetFullPathName(szSetupEXE, sizeof(szFullPath)/sizeof(TCHAR), szFullPath, &lpszFilePart)))
        {
                // error
                _tprintf(TEXT("Unable to obtain fullpath for %s\n"), szSetupEXE);
                return false;
        }
        else if (cchFullPath > sizeof(szFullPath)/sizeof(TCHAR))
        {
            // szFullPath buffer is too small; we could resize, but we'll simply fail here
            _tprintf(TEXT("szFullPath buffer is insufficiently sized for obtaining the full path for %s\n"), szSetupEXE);
            return false;
        }

        _tprintf(TEXT("\nModifying setup properties in:\n\t<%s>\n\n"), szFullPath);

        // make sure the EXE is not already loaded,in use, or read-only
        HANDLE hInUse = CreateFile(szFullPath, GENERIC_WRITE, (DWORD)0, (LPSECURITY_ATTRIBUTES)0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, (HANDLE)0);
        if (INVALID_HANDLE_VALUE == hInUse)
        {
                // error
                _tprintf(TEXT("Unable to obtain file handle for %s.  The file probably does not exist, is marked read-only, or is in use.  LastError = %d\n"), szFullPath, GetLastError());
                return false;
        }
        CloseHandle(hInUse);

        // begin update resource
        HANDLE hUpdate = BeginUpdateResource(szFullPath, /* bDeleteExistingResources = */ FALSE);
        if ( !hUpdate )
        {
                // error
                _tprintf(TEXT("Unable to update resources in %s.  LastError = %d\n"), szFullPath, GetLastError());
                return false;
        }

        while ((chNextCommand = SkipWhiteSpace(pchCommandLine)) != 0)
        {
                if (chNextCommand == TEXT('/') || chNextCommand == TEXT('-'))
                {
                        TCHAR *szOption = pchCommandLine++;  // save for error msg
                        TCHAR  chOption = (TCHAR)(*pchCommandLine++ | 0x20); // lower case flag
                        chNextCommand = SkipWhiteSpace(pchCommandLine);
                        pchCommandData = pchCommandLine;

                        for (const TCHAR* pchOptions = rgszCommandOptions; *pchOptions; pchOptions++)
                        {
                                if (*pchOptions == chOption)
                                        break;
                        }

                        if (*pchOptions)
                        {
                                bool fSkipValue   = true; // whether or not to look for next option in command line; (true = look)
                                bool fDeleteValue = false;// whether to delete the value

                                // option is recognized
                                const TCHAR chIndex = (TCHAR)(pchOptions - rgszCommandOptions);
                                if (chIndex >= cStandardProperties)
                                {
                                        // error
                                        _tprintf(TEXT("Invalid index (chIndex = %d, chOption = %c)!!!\n"), chIndex, chOption);
                                        return false;
                                }

                                if (chOption == chProperties)
                                {
                                        fSkipValue = false;
                                        // special for /p -- remainder of command line is part of property
                                        TCHAR chNext = *pchCommandData;
                                        if (chNext == 0 || chNext == TEXT('/') || chNext == TEXT('-'))
                                        {
                                                // no value present
                                                fDeleteValue = true;
                                        }
                                        else
                                        {
                                                // set value to remainder of command line, i.e. all of pchCommandData
                                                // with enclosing quotes stripped -- we do this by telling the command
                                                // line processor to not attempt to look for other options on the
                                                // command line; the remainder is part of this property
                                                fSkipValue = false;
                                        }
                                }

                                if (fSkipValue)
                                        fDeleteValue = (SkipValue(pchCommandLine)) ? false : true;

                                if (fDeleteValue)
                                {
                                        // delete value and reset to ensure resource is properly removed
                                        if (!UpdateResource(hUpdate, RT_INSTALL_PROPERTY, rgszResName[chIndex], MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL), NULL, 0)
                                                || !EndUpdateResource(hUpdate, /* fDiscard = */ FALSE)
                                                || (!(hUpdate = BeginUpdateResource(szFullPath, /* bDeleteExistingResources = */ FALSE))))
                                        {
                                                // error
                                                _tprintf(TEXT("Unable to delete resource %s in %s.  LastError = %d\n"), rgszResName[chIndex], szFullPath, GetLastError());
                                                return false;
                                        }
                                        _tprintf(TEXT("Removing '%s' . . .\n"), rgszResName[chIndex]);
                                }
                                else
                                {
                                        TCHAR szValueBuf[1024] = {0};
                                        if (!RemoveQuotes(pchCommandData, szValueBuf, sizeof(szValueBuf)/sizeof(szValueBuf[0])))
                                            return false;

                                        if (chOption == chMinMsiVer && (_ttoi(szValueBuf) < iMinMsiAllowedVer))
                                        {
                                                // extra validation: must be >= iMinAllowedVer
                                                _tprintf(TEXT("Skipping option %c with data %s. Data value must be >= %d. . .\n"), chOption, szValueBuf, iMinMsiAllowedVer);
                                                continue;
                                        }

                                        if (chOption == chOperation
                                            && CSTR_EQUAL != CompareString(lcidLOCALE_INVARIANT, NORM_IGNORECASE, szValueBuf, -1, szInstall, -1)
                                            && CSTR_EQUAL != CompareString(lcidLOCALE_INVARIANT, NORM_IGNORECASE, szValueBuf, -1, szInstallUpd, -1)
                                            && CSTR_EQUAL != CompareString(lcidLOCALE_INVARIANT, NORM_IGNORECASE, szValueBuf, -1, szMinPatch, -1)
                                            && CSTR_EQUAL != CompareString(lcidLOCALE_INVARIANT, NORM_IGNORECASE, szValueBuf, -1, szMajPatch, -1))
                                        {
                                            // extra validation: must be one of those values
                                            _tprintf(TEXT("Skipping option %c with data %s. Data value must be INSTALL, INSTALLUPD, MINPATCH, or MAJPATCH...\n"), chOption, szValueBuf);
                                            continue;
                                        }

                                        // update value -- this is our own custom resource, so to make it easier on ourselves, we will pack in the NULL as well
                                #ifdef UNICODE
                                        if (!UpdateResource(hUpdate, RT_INSTALL_PROPERTY, rgszResName[chIndex], MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL), szValueBuf, (lstrlen(szValueBuf) + 1)*sizeof(TCHAR)))
                                        {
                                                // error
                                                _tprintf(TEXT("Unable to update resource %s in %s with value %s.  LastError = %d\n"), rgszResName[chIndex], szFullPath, szValueBuf, GetLastError());
                                                return false;
                                        }
                                #else // !UNICODE
                                        // must convert value to Unicode
                                        int cchWide = MultiByteToWideChar(CP_ACP, 0, szValueBuf, -1, NULL, 0);
                                        WCHAR* wszValueBuf = new WCHAR[cchWide];
                                        if (!wszValueBuf)
                                            return false; // out of memory
                                        ZeroMemory(wszValueBuf, cchWide*sizeof(WCHAR));
                                        if (0 == MultiByteToWideChar(CP_ACP, 0, szValueBuf, -1, wszValueBuf, cchWide))
                                        {
                                            // error
                                            _tprintf(TEXT("Unable to convert value to Unicode. LastError = %d\n"), GetLastError());
                                            delete [] wszValueBuf;
                                            return false;
                                        }
                                        if (!UpdateResource(hUpdate, RT_INSTALL_PROPERTY, rgszResName[chIndex], MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL), wszValueBuf, (lstrlenW(wszValueBuf) +1)*sizeof(WCHAR)))
                                        {
                                                // error
                                                _tprintf(TEXT("Unable to update resource %s in %s with value %s.  LastError = %d\n"), rgszResName[chIndex], szFullPath, szValueBuf, GetLastError());
                                                delete [] wszValueBuf;
                                                return false;
                                        }
                                        delete [] wszValueBuf;
                                #endif // UNICODE
                                        _tprintf(TEXT("Setting '%s' to '%s' . . .\n"), rgszResName[chIndex], szValueBuf);
                                        if (!fSkipValue)
                                                break; // done processing
                                }
                        }
                        else
                        {
                                // invalid option
                                _tprintf(TEXT("Skipping invalid option %c . . .\n"), chOption);
                                SkipValue(pchCommandLine);
                                continue;
                        }
                }
                else
                {
                        // error
                        _tprintf(TEXT("Switch is missing\n"));
                        return false;
                }
        }

        // persist changes
        if (!EndUpdateResource(hUpdate, /* fDiscard = */ FALSE))
        {
                // error
                _tprintf(TEXT("Unable to update resources in %s.  LastError = %d\n"), szFullPath, GetLastError());
                return false;
        }

        return true;
}

//_____________________________________________________________________________________________________
//
// SkipWhiteSpace
//
//       Skips whitespace in the string and returns next non-tab non-whitespace charcter 
//_____________________________________________________________________________________________________

TCHAR SkipWhiteSpace(TCHAR*& rpch)
{
        TCHAR ch = 0;
        if (rpch)
        {
            for (; (ch = *rpch) == TEXT(' ') || ch == TEXT('\t'); rpch++)
                    ;
        }
        return ch;
}

//_____________________________________________________________________________________________________
//
// SkipValue
//
//       Skips over the value of a switch and returns true if a value was present. Handles value enclosed
//       in quotation marks
//_____________________________________________________________________________________________________

bool SkipValue(TCHAR*& rpch)
{
        if (!rpch)
            return false;

        TCHAR ch = *rpch;
        if (ch == 0 || ch == TEXT('/') || ch == TEXT('-'))
                return false;   // no value present
        for (int i = 0; (ch = *rpch) != TEXT(' ') && ch != TEXT('\t') && ch != 0; rpch = CharNext(rpch), i++)
        {
                if (0 == i && *rpch == TEXT('"'))
                {
                        rpch++; // for '"'
                        for (; (ch = *rpch) != TEXT('"') && ch != 0; rpch++)
                                ;
                        ch = *(++rpch);
                        break;
                }
        }
        if (ch != 0)
        {
                TCHAR* pch = rpch;
                rpch = CharNext(rpch);
                *pch = 0;
        }
        return true;
}

//_____________________________________________________________________________________________________
//
// RemoveQuotes
//
//  Removes enclosing quotation marks for the value. Returns copy of original string
//  if no enclosing quotation mark at front of string.  Returns false on error.
//_____________________________________________________________________________________________________

bool RemoveQuotes(LPCTSTR lpOriginal, LPTSTR lpStripped, DWORD cchStripped)
{
        if (!lpOriginal)
            return false;

        bool fEnclosedInQuotes = false;

        const TCHAR *pchOrig = lpOriginal;

        // check for "
        if (*pchOrig == TEXT('"'))
        {
                fEnclosedInQuotes = true;
                pchOrig++;
        }
        
        if (FAILED(StringCchCopy(lpStripped, cchStripped, pchOrig)))
            return false;

        if (!fEnclosedInQuotes)
                return true;

        TCHAR *pch = lpStripped + lstrlen(lpStripped) + 1; // start at NULL

        pch = CharPrev(lpStripped, pch);

        // look for trailing "
        while (pch != lpStripped)
        {
                if (*pch == TEXT('"'))
                {
                        *pch = 0;
                        break; // only care about trailing ", and not quotes in middle
                }
                pch = CharPrev(lpStripped, pch);
        }

        return true;
}

//_____________________________________________________________________________________________________
//
// DisplayInstallResource
//_____________________________________________________________________________________________________

bool DisplayInstallResource(HMODULE hExeModule, LPCTSTR lpszType, LPCTSTR lpszName)
{
        HRSRC   hRsrc   = 0;
        HGLOBAL hGlobal = 0;
        WCHAR   *pch    = 0;

        if ((hRsrc = FindResource(hExeModule, lpszName, lpszType)) != 0
                && (hGlobal = LoadResource(hExeModule, hRsrc)) != 0
                && (pch = (WCHAR*)LockResource(hGlobal)) != 0)
        {
                // resource exists
                g_cResources++;

                if (!pch)
                        _tprintf(TEXT("%s = NULL\n"), lpszName);
                else
                {
                #ifdef UNICODE
                        _tprintf(TEXT("%s = %s\n"), lpszName, pch);
                #else // !UNICODE
                        unsigned int cch = WideCharToMultiByte(CP_ACP, 0, pch, -1, NULL, 0, NULL, NULL);
                        char *szValue = new char[cch];
                        if (!szValue)
                        {
                                _tprintf(TEXT("Error -- out of memory\n"));
                                return false;
                        }
                        ZeroMemory(szValue, cch * sizeof(char));

                        if (0 == WideCharToMultiByte(CP_ACP, 0, pch, -1, szValue, cch, NULL, NULL))
                        {
                            // error -- could not convert
                            _tprintf(TEXT("Unable to convert value.  LastError = %d\n"), GetLastError());
                            delete [] szValue;
                            return false;
                        }

                        _tprintf(TEXT("%s = %s\n"), lpszName, szValue);
                        delete [] szValue;
                #endif // UNICODE
                }
        }

        return true;
}

//_____________________________________________________________________________________________________
//
// EnumResNamesProc
//_____________________________________________________________________________________________________

BOOL CALLBACK EnumResNamesProc(HMODULE hExeModule, LPCTSTR lpszType, LPTSTR lpszName, LONG_PTR /*lParam*/)
{
        if (!DisplayInstallResource(hExeModule, lpszType, lpszName))
                return FALSE;
        return TRUE;
}

//_____________________________________________________________________________________________________
//
// DisplayResources
//_____________________________________________________________________________________________________

bool DisplayResources(LPCTSTR szExecutable)
{
        // handle possibility of a relative path
        TCHAR szFullPath[2*MAX_PATH] = {0};
        LPTSTR lpszFilePart = 0;
        int cchFullPath = 0;
        if (0 == (cchFullPath = GetFullPathName(szExecutable, sizeof(szFullPath)/sizeof(TCHAR), szFullPath, &lpszFilePart)))
        {
                // error
                _tprintf(TEXT("Unable to obtain full file path for %s.  LastError = %d\n"), szExecutable, GetLastError());
                return false;
        }
        else if (cchFullPath > sizeof(szFullPath)/sizeof(TCHAR))
        {
            // szFullPath buffer is too small; we could resize, but we'll simply fail here
            _tprintf(TEXT("szFullPath buffer is insufficiently sized for obtaining the full path for %s\n"), szExecutable);
            return false;
        }

        _tprintf(TEXT("\n<%s>\n\n"), szFullPath);

        HMODULE hExeModule = LoadLibraryEx(szFullPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (NULL == hExeModule)
        {
                // error
                _tprintf(TEXT("Unable to load %s.  LastError = %d\n"), szFullPath, GetLastError());
                return false;
        }

        // only enumerate on RT_INSTALL_PROPERTY type
        if (!EnumResourceNames(hExeModule, RT_INSTALL_PROPERTY, EnumResNamesProc, (LPARAM)0))
        {
                DWORD dwLastErr = GetLastError();
                if (ERROR_RESOURCE_TYPE_NOT_FOUND == dwLastErr)
                        _tprintf(TEXT("No RT_INSTALL_PROPERTY resources were found.\n"));
                else if (ERROR_RESOURCE_DATA_NOT_FOUND == dwLastErr)
                        _tprintf(TEXT("This file does not have a resource section.\n"));
                else
                {
                        // error
                        _tprintf(TEXT("Failed to enumerate all resources in %s.  LastError = %d\n"), szFullPath, GetLastError());
                        FreeLibrary(hExeModule);
                        return false;
                }
        }

        if (g_cResources)
        {
                if (1 == g_cResources)
                        _tprintf(TEXT("\n\n 1 RT_INSTALL_PROPERTY resource was found.\n"));
                else
                        _tprintf(TEXT("\n\n %d RT_INSTALL_PROPERTY resources were found.\n"), g_cResources);
        }

        if (!FreeLibrary(hExeModule))
        {
                // error
                _tprintf(TEXT("Failed to unload %s.  LastError = %d\n"), szFullPath, GetLastError());
                return false;
        }

        return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msival\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msitran\sources.inc ===
TARGETNAME=msitran
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
	$(SDK_LIB_PATH)\msi.lib \
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\OLE32.lib

C_DEFINES=$(C_DEFINES) -D_EXE
USE_LIBCMT=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msitran.cpp \
	..\msitran.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msitran\msitran.cpp ===
#if 0  // makefile definitions
DESCRIPTION = Transform file display
MODULENAME = MsiTran
SUBSYSTEM = console
FILEVERSION = Msi
LINKLIBS = OLE32.lib
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2001
//
//  File:       msitran.cpp
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f msitran.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 Console Application project
//      2. Add msitran.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------

#define W32DOWS_LEAN_AND_MEAN  // faster compile
#define OLE
#define W32
#define MSI

#include <windows.h>
#ifndef RC_INVOKED    // start of source code
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include <stdio.h>
#include <wtypes.h> // Needed for OLECHAR definitions
#include <objidl.h> // Needed for IStorage definitions
#include "MsiQuery.h" // MSI API

//________________________________________________________________________________
//
// Constants and globals
//________________________________________________________________________________

// storage format classes (IStorage SetClass, Stat)
const int iidMsiDatabaseStorage           = 0xC1080L;
const int iidMsiTransformStorage          = 0xC1081L;
const int iidMsiTransformStorageOld       = 0xC1082L;
#define MSGUID(iid) {iid,0,0,{0xC0,0,0,0,0,0,0,0x46}}
const GUID STGID_MsiDatabase     = MSGUID(iidMsiDatabaseStorage);
const GUID STGID_MsiTransform    = MSGUID(iidMsiTransformStorage);
const GUID STGID_MsiTransformOld = MSGUID(iidMsiTransformStorageOld);

const TCHAR szStringPool[]       = TEXT("_StringPool");
const TCHAR szStringData[]       = TEXT("_StringData");
const TCHAR szTableCatalog[]     = TEXT("_Tables");
const TCHAR szColumnCatalog[]    = TEXT("_Columns");
const TCHAR szSummaryInfo[]      = TEXT("\005SummaryInformation");
const TCHAR szTransformCatalog[] = TEXT("_Transforms");

const TCHAR szHelp[] =
TEXT("Copyright (C) Microsoft Corporation.  All rights reserved.\nMsi Transform Tool --- Generate and Apply Transform Files\n\n")
TEXT("Options for MsiTran.exe:\n")
TEXT("-g {base db} {new db} {transform} [{error/validation conditions}] -->Generate\n")
TEXT("-a {transform} {database} [{error conditions}]              -->Apply\n\n")
TEXT("Error Conditions:\n")
TEXT("The following errors may be suppressed when applying a transform.\n")
TEXT("To suppress an error, include the appropriate character in\n")
TEXT("{error conditions}. Conditions specified with -g are placed in\n")
TEXT("the summary information of the transform, but are not used when\n")
TEXT("applying a transform with -a.\n\n")
TEXT("'a': Add existing row.\n")
TEXT("'b': Delete non-existing row.\n")
TEXT("'c': Add existing table.\n")
TEXT("'d': Delete non-existing table.\n")
TEXT("'e': Modify existing row.\n")
TEXT("'f': Change codepage.\n\n")
TEXT("Validation Conditions:\n")
TEXT("The following validation conditions may be used to indicate when a\n")
TEXT("transform may be applied to a package. These conditions may be\n")
TEXT("specified with -g but not -a.\n\n")
TEXT("'g': Check upgrade code.\n")
TEXT("'l': Check language.\n")
TEXT("'p': Check platform.\n")
TEXT("'r': Check product.\n")
TEXT("'s': Check major version only.\n")
TEXT("'t': Check major and minor versions only.\n")
TEXT("'u': Check major, minor, and update versions.\n")
TEXT("'v': Applied database version < base database version.\n")
TEXT("'w': Applied database version <= base database version.\n")
TEXT("'x': Applied database version =  base database version.\n")
TEXT("'y': Applied database version >= base database version.\n")
TEXT("'z': Applied database version >  base database version.\n") 

TEXT("\nGenerate transform without summary info stream (conditions ignored):\n")
TEXT("'@': Suppress summary information stream generation.\n");

const int cchDisplayBuf = 4096;										

const int icdShort      = 1 << 10; // 16-bit integer, or string index
const int icdObject     = 1 << 11; // IMsiData pointer for temp. column, stream for persistent column
const int icdNullable   = 1 << 12; // column will accept null values
const int icdPrimaryKey = 1 << 13; // column is component of primary key
const int icdLong     = 0; // !Object && !Short
const int icdString   = icdObject+icdShort;
const int icdTypeMask = icdObject+icdShort;


const int ictTable = 1;
const int ictColumn = 2;
const int ictOrder = 3;
const int ictType = 4;

OLECHAR* g_szwStringPool;
OLECHAR* g_szwStringData;
OLECHAR* g_szwSummaryInfo;
OLECHAR* g_szwTableCatalog;
OLECHAR* g_szwColumnCatalog;

HANDLE g_hStdOut;
TCHAR g_rgchBuffer[4096];
BOOL g_cbShort;  // used temporarily to support display of old format transform files

//________________________________________________________________________________
//
// Structures and enums
//________________________________________________________________________________

struct StringEntry
{
	char* sz;      // String
	StringEntry() : sz(0) {}
};

enum iceDef
{
	iceNone   = 0,  // No Definition
	iceLong   = 1,  // Long Integer
	iceShort  = 2,  // Short Integer
	iceStream = 3,  // Stream
	iceString = 4   // String
};

struct ColumnEntry
{
	int  nTable;      // Index Into TableEntry Array
	BOOL fPrimaryKey; // Whether Col Is A Primary Key
	BOOL fNullable;   // Whether Col Is Nullable
	char* szName;    // Name Of Col
	iceDef iceType;   // Col Type
	ColumnEntry() : szName(0), nTable(0), iceType(iceNone), fPrimaryKey(FALSE), fNullable(FALSE) {}
};

struct TableEntry
{
	char* szName;         // Name Of Table
	int cColumns;          // Number Of Columns In Table
	int cPrimaryKeys;      // Number Of Primary Keys
	BOOL fNew;             // Whether new table
	iceDef iceColDefs[32]; // Array of Column Definitions
	TableEntry() : szName(0), cColumns(0), cPrimaryKeys(0), fNew(FALSE) {memset(iceColDefs, iceNone, sizeof(iceColDefs));}
};



//________________________________________________________________________________
//
// Function prototypes
//________________________________________________________________________________

void Display(LPCTSTR szMessage);
void ErrorExit(UINT iError, LPCTSTR szMessage);
void CheckError(UINT iError, LPCTSTR szMessage);
void CheckErrorRecord(UINT iError, LPCTSTR szMessage);
void ProcessTransformFile(TCHAR* szDatabase, TCHAR* szTransform);
void AnsiToWide(LPCTSTR sz, OLECHAR*& szw);
void WideToAnsi(const OLECHAR* szw, char*& sz);
void DisplayWide(const char* sz, OLECHAR*& szw);
void EnumerateStreams(IStorage& riStorage, IEnumSTATSTG& riEnum, BOOL fTableCatalog, BOOL fColumnCatalog, MSIHANDLE hDatabase);
void DecodeStringPool(IStorage& riStorage, StringEntry*& rgStrings, int& iMaxStringId);
void FillTransformCatalogArrays(IStorage& riTransformStg, TableEntry*& rgTables, int& cTables,
										  ColumnEntry*& rgColumns, int& cColumns, StringEntry* rgStrings, int iMaxStringId); 
void DisplayColumnCatalog(ColumnEntry* rgColumns, int cColumns, TableEntry* rgTables);
void DisplayTableCatalog(IStorage& riStorage, StringEntry* rgStrings, int iMaxStringId);
void DisplayStream(IStorage& riStorage, OLECHAR* szwStreamName, TCHAR* szStreamName, int cbSize, MSIHANDLE hView, TableEntry* rgTables,
						 int cTables, StringEntry* rgStrings, int iMaxStringId);
void GenerateTransform(TCHAR* szBaseDb, TCHAR* szRefDb, TCHAR* szTransform, int iErrorConditions, int iValidationConditions);
void ApplyTransform(TCHAR* szTransform, TCHAR* szDatabase, int iErrorConditions);
int  TranslateErrorConditions(TCHAR* szErrorConditions);
int  TranslateValidationConditions(TCHAR* szErrorConditions);

//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
	// Determine handle
	g_hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
	if (g_hStdOut == INVALID_HANDLE_VALUE)
		g_hStdOut = 0;  // non-zero if stdout redirected or piped

	OLE::CoInitialize(0);

	if (argc == 2 && ((_tcscmp(argv[1], TEXT("-?")) == 0) || (_tcscmp(argv[1], TEXT("/?")) == 0)))
		ErrorExit(0, szHelp);

	// Check for enough arguments and valid options
	if (argc <= 1)
		ErrorExit( 1, TEXT("USAGE: msitran.exe [Option] [Values....]"));
	CheckError(argv[1][0] != TEXT('-') && argv[1][0] != TEXT('/'), TEXT("USAGE: msitran.exe [Option] [Values....]"));
	CheckError(_tcsclen(argv[1]) != 2, TEXT("USAGE: msitran.exe [Option] [Values....]"));

	// Determine option
	switch (argv[1][1])
	{
	case TEXT('a'):
		{
			// Apply Transform

			CheckError(argc != 4 && argc != 5, TEXT("msitran.exe -a {transform} {database} [{error conditions}]"));
			TCHAR* szTransform = argv[2];
			TCHAR* szDatabase = argv[3];
			int iErrorConditions = 0;
			if(argc == 5)
				iErrorConditions = TranslateErrorConditions(argv[4]);
			ApplyTransform(szTransform, szDatabase, iErrorConditions);
			ErrorExit(0, TEXT("Done"));
			break;
		}
	case TEXT('g'):
		{
			// Generate Transform
			CheckError(argc != 5 && argc != 6, TEXT("msitran.exe -g {base db} {ref db} {transform} [{error conditions}]"));
			TCHAR* szBaseDb = argv[2];
			TCHAR* szRefDb = argv[3];
			TCHAR* szTransform = argv[4];
			int iErrorConditions = 0;
			int iValidationConditions = 0;
			if(argc == 6)
			{
				if(_tcsstr(argv[5],TEXT("@")))
					iErrorConditions = -1;  // no summary info
				else
				{
					iErrorConditions = TranslateErrorConditions(argv[5]);
					iValidationConditions = TranslateValidationConditions(argv[5]);
				}
			}
			GenerateTransform(szBaseDb, szRefDb, szTransform, iErrorConditions, iValidationConditions);
			ErrorExit(0, TEXT("Done"));
			break;
		}
	default:
		{
			// Unknown Option
			ErrorExit(1, TEXT("Unknown Option."));
			break;
		}
	};

	return 0;
}

//________________________________________________________________________________
//
// Utility functions:
//    TranslateErrorConditions(...);
//    TranslateValidationConditions(...);
//________________________________________________________________________________

int TranslateErrorConditions(TCHAR* szConditions)
{
	if(!szConditions || !*szConditions)
		return 0;
	
	int iErrorConditions = 0;
	if(_tcsstr(szConditions,TEXT("a")))
		iErrorConditions |= MSITRANSFORM_ERROR_ADDEXISTINGROW;
	if(_tcsstr(szConditions,TEXT("b")))
		iErrorConditions |= MSITRANSFORM_ERROR_DELMISSINGROW;
	if(_tcsstr(szConditions,TEXT("c")))
		iErrorConditions |= MSITRANSFORM_ERROR_ADDEXISTINGTABLE;
	if(_tcsstr(szConditions,TEXT("d")))
		iErrorConditions |= MSITRANSFORM_ERROR_DELMISSINGTABLE;
	if(_tcsstr(szConditions,TEXT("e")))
		iErrorConditions |= MSITRANSFORM_ERROR_UPDATEMISSINGROW;
	if(_tcsstr(szConditions,TEXT("f")))
		iErrorConditions |= MSITRANSFORM_ERROR_CHANGECODEPAGE;

	return iErrorConditions;
}

int TranslateValidationConditions(TCHAR* szConditions)
{
	if(!szConditions || !*szConditions)
		return 0;
	
	int iValidationConditions = 0;
	if(_tcsstr(szConditions,TEXT("s")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_MAJORVERSION;
	if(_tcsstr(szConditions,TEXT("t")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_MINORVERSION;
	if(_tcsstr(szConditions,TEXT("u")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_UPDATEVERSION;
	if(_tcsstr(szConditions,TEXT("v")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION;
	if(_tcsstr(szConditions,TEXT("w")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION;
	if(_tcsstr(szConditions,TEXT("x")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION;
	if(_tcsstr(szConditions,TEXT("y")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION;
	if(_tcsstr(szConditions,TEXT("z")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION;
	if(_tcsstr(szConditions,TEXT("l")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_LANGUAGE;
	if(_tcsstr(szConditions,TEXT("p")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_PLATFORM;
	if(_tcsstr(szConditions,TEXT("r")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_PRODUCT;
	if(_tcsstr(szConditions,TEXT("g")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_UPGRADECODE;

	return iValidationConditions;
}

//________________________________________________________________________________
//
// Error handling and Display functions:
//    Display(...);
//	   ErrorExit(...);
//    CheckError(...);
//
//________________________________________________________________________________

void Display(LPCTSTR szMessage)
{
	if (szMessage)
	{
		int cbOut = _tcsclen(szMessage);;
		if (g_hStdOut)
		{
#ifdef UNICODE
			char rgchTemp[cchDisplayBuf];
			if (W32::GetFileType(g_hStdOut) == FILE_TYPE_CHAR)
			{
				W32::WideCharToMultiByte(CP_ACP, 0, szMessage, cbOut, rgchTemp, sizeof(rgchTemp), 0, 0);
				szMessage = (LPCWSTR)rgchTemp;
			}
			else
				cbOut *= sizeof(TCHAR);   // write Unicode if not console device
#endif // UNICODE
			DWORD cbWritten;
			W32::WriteFile(g_hStdOut, szMessage, cbOut, &cbWritten, 0);
		}
		else
			W32::MessageBox(0, szMessage, W32::GetCommandLine(), MB_OK);
	}
}


void ErrorExit(UINT iError, LPCTSTR szMessage)
{
	if (szMessage)
	{
		int cbOut;
		TCHAR szBuffer[256];  // errors only, not used for display output
		if (iError == 0)
			cbOut = lstrlen(szMessage);
		else
		{
			LPCTSTR szTemplate = (iError & 0x80000000L)
										? TEXT("Error 0x%X. %s\n")
										: TEXT("Error %i. %s\n");
			cbOut = _stprintf(szBuffer, szTemplate, iError, szMessage);
			szMessage = szBuffer;
		}
		if (g_hStdOut)
		{
#ifdef UNICODE
			char rgchTemp[cchDisplayBuf];
			if (W32::GetFileType(g_hStdOut) == FILE_TYPE_CHAR)
			{
				W32::WideCharToMultiByte(CP_ACP, 0, szMessage, cbOut, rgchTemp, sizeof(rgchTemp), 0, 0);
				szMessage = (LPCWSTR)rgchTemp;
			}
			else
				cbOut *= sizeof(TCHAR);   // write Unicode if not console device
#endif // UNICODE
			DWORD cbWritten;
			W32::WriteFile(g_hStdOut, szMessage, cbOut, &cbWritten, 0);
		}
		else
			W32::MessageBox(0, szMessage, W32::GetCommandLine(), MB_OK);
	}
	MSI::MsiCloseAllHandles();
	OLE::CoUninitialize();
	W32::ExitProcess(iError);
}

void CheckError(UINT iError, LPCTSTR szMessage)
{
	if (iError != ERROR_SUCCESS)
		ErrorExit(iError, szMessage);
}

void CheckErrorRecord(UINT iError, LPCTSTR szMessage)
{
	if (iError != ERROR_SUCCESS)
	{
		PMSIHANDLE hError = MsiGetLastErrorRecord();
		if (hError)
		{ 
			if (MsiRecordIsNull(hError, 0))
				MsiRecordSetString(hError, 0, TEXT("Error [1]: [2]{, [3]}{, [4]}{, [5]}"));
			TCHAR rgchBuf[1024];
			DWORD cchBuf = sizeof(rgchBuf)/sizeof(TCHAR);
			MsiFormatRecord(0, hError, rgchBuf, &cchBuf);
			szMessage = rgchBuf;
		}
		ErrorExit(iError, szMessage);
	}
}

//_____________________________________________________________________________________________________
//
// Transform application and generation functions
//    GenerateTransform(...);
//    ApplyTransform(...);
//_____________________________________________________________________________________________________

void GenerateTransform(TCHAR* szBaseDb, TCHAR* szRefDb, TCHAR* szTransform, int iErrorConditions,
							  int iValidation)
{
	PMSIHANDLE hBaseDb = 0;
	PMSIHANDLE hRefDb = 0;

	CheckError(MSI::MsiOpenDatabase(szBaseDb, MSIDBOPEN_READONLY, &hBaseDb), TEXT("Error Opening Base Database"));
	CheckError(MSI::MsiOpenDatabase(szRefDb, MSIDBOPEN_READONLY, &hRefDb), TEXT("Error Opening Updated Database"));

	CheckErrorRecord(MSI::MsiDatabaseGenerateTransform(hRefDb, hBaseDb, szTransform, 0, 0), TEXT("Error Generating Transform"));
	if (iErrorConditions != -1)
	{
		CheckErrorRecord(MSI::MsiCreateTransformSummaryInfo(hRefDb, hBaseDb, szTransform, iErrorConditions, iValidation), TEXT("Error Create Transform Summary Info"));
	}
}


void ApplyTransform(TCHAR* szTransform, TCHAR* szDatabase, int iErrorConditions)
{
	PMSIHANDLE hDatabase = 0;

	CheckError(MSI::MsiOpenDatabase(szDatabase, MSIDBOPEN_TRANSACT, &hDatabase), TEXT("Error Opening Database"));

	CheckErrorRecord(MSI::MsiDatabaseApplyTransform(hDatabase, szTransform, iErrorConditions), TEXT("Error Applying Transform"));
	CheckErrorRecord(MSI::MsiDatabaseCommit(hDatabase), TEXT("Error Saving Database"));
}

#else // RC_INVOKED, end of source code, start of resources
#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msival2\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msival\msival.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msival.h
//
//--------------------------------------------------------------------------

#include <windows.h>

#define IDS_NoError            0
#define IDS_DuplicateKey       1
#define IDS_Required           2
#define IDS_BadLink            3
#define IDS_Overflow           4
#define IDS_Underflow          5
#define IDS_NotInSet           6
#define IDS_BadVersion         7
#define IDS_BadCase            8
#define IDS_BadGuid            9
#define IDS_BadWildCard        10
#define IDS_BadIdentifier      11
#define IDS_BadLanguage        12
#define IDS_BadFileName        13
#define IDS_BadPath            14
#define IDS_BadCondition       15
#define IDS_BadFormatted       16
#define IDS_BadTemplate        17
#define IDS_BadDefaultDir      18
#define IDS_BadRegPath         19
#define IDS_BadCustomSource    20 
#define IDS_BadProperty        21
#define IDS_MissingData        22
#define IDS_BadCabinet         23
#define IDS_BadCategory        24
#define IDS_BadKeyTable        25
#define IDS_BadMaxMinValues    26
#define IDS_BadShortcut        27
#define IDS_StringOverflow     28
#define IDS_UndefinedError     29
#define IDS_MissingEntry       30
#define IDS_BadLocalizeAttrib  31
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msistver\msistver.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msistver.cpp
//
//--------------------------------------------------------------------------


#define W32
#define MSI

#include <windows.h>
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include <stdio.h>
#include <stdlib.h>
#include "MsiQuery.h" // MSI API
#include "version.h"

//________________________________________________________________________________
//
// Constants and globals
//________________________________________________________________________________

const char szHelp[] = "MSI Set Version. Syntax: m {module} | p {package}\n";

const char szDBQuery[] = "UPDATE `Property` SET `Value`='%d.%02d.%.4d.%d' WHERE `Property`='ProductVersion'";
const char szModuleQuery[] = "UPDATE `ModuleSignature` SET `Version`='%d.%02d.%.4d.%d'";

const int cchDisplayBuf = 4096;										

char g_rgchBuffer[409];

//________________________________________________________________________________
//
// Function prototypes
//________________________________________________________________________________

UINT CheckError(UINT iError, LPCSTR szMessage);

//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

int __cdecl main(int argc, char* argv[])
{
	if (argc != 3)
	{
		printf(szHelp);
		return -1;
	}


	LPCSTR szQueryTmpl = NULL;
	if (*argv[1]==TEXT('m'))
		szQueryTmpl = szModuleQuery;
	else
		szQueryTmpl = szDBQuery;

	char szQuery[2048];
	sprintf(szQuery, szQueryTmpl, rmj, rmm, rup, rin);
	
	MSIHANDLE hDB = 0;
	MSIHANDLE hView = 0;
	printf("Changing Version: Open...");
	if (!CheckError(MsiOpenDatabaseA(argv[2], (char *)MSIDBOPEN_DIRECT, &hDB), "Failed to Open Database"))
	{
		printf("Query...");
		if (!CheckError(MsiDatabaseOpenViewA(hDB, szQuery, &hView), "Failed to Open View"))
		{
			printf("Change...");
			if (!CheckError(MsiViewExecute(hView, 0), "Failed to Execute View"))
			{
				printf("Close...");
				CheckError(MsiDatabaseCommit(hDB), "Failed to Commit DB");
			}
		}
	}

	MsiCloseHandle(hView);
	MsiCloseHandle(hDB);
	printf("Done.\n");
	return 0;
}


UINT CheckError(UINT iError, LPCSTR szMessage)
{
	if (iError != ERROR_SUCCESS)
	{
		printf(szMessage);
	}
	return iError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msival\sources.inc ===
TARGETNAME=msival
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\msi.lib

C_DEFINES=$(C_DEFINES) -D_EXE
USE_LIBCMT=1
USE_NATIVE_EH=1

INCLUDES=$(INCLUDES);$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msival.cpp \
	..\msival.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msival\msival.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       msival.cpp
//
//--------------------------------------------------------------------------

// Required headers
#include "msival.h"
#include <stdio.h>   // printf/wprintf
#include <stdlib.h>  // atoi
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h"

//!! Need to fix warnings and remove pragma
#pragma warning(disable : 4018) // signed/unsigned mismatch

TCHAR*  g_szErrorContext = 0; // Global error string
HANDLE g_hStdOut = 0; // Global handle

// Function prototypes
void Display(LPCTSTR szMessage);
void CheckMsi(UINT iStat, TCHAR* szContext);
void CheckMsiRecord(UINT iStat, TCHAR* szContext);
BOOL CheckMissingColumns(MSIHANDLE hDatabase);
BOOL Validate(MSIHANDLE hDatabase);
BOOL ValidateRequired(MSIHANDLE hDatabase);
BOOL ValidateInstallSequence(MSIHANDLE hDatabase, const TCHAR* szSQLInstallSeqTable);

// SQL queries
const TCHAR szSQLTableCatalog[]         = TEXT("SELECT `Name` FROM `_Tables`");
const TCHAR szSQLTable[]                = TEXT("SELECT * FROM ");
const TCHAR szSQLColMissing[]           = TEXT("SELECT `Table`, `Number`, `Name`, `Type` FROM `_Columns` WHERE `Table`=? AND `Name`=?");
const TCHAR szSQLValidationTable[]      = TEXT("SELECT `Table`, `Column` FROM `_Validation`, `_Tables` WHERE `_Validation`.`Table` = `_Tables`.`Name`");

struct
{
	const TCHAR* Name;
	const TCHAR* SQL;
} pSeqTables[] =

{
	TEXT("AdminExecuteSequence"), TEXT("SELECT `Action`, `Sequence` FROM `AdvtExecuteSequence` ORDER BY `Sequence`"),
	TEXT("AdminUISequence"), TEXT("SELECT `Action`, `Sequence` FROM `AdminUISequence` ORDER BY `Sequence`"),
	TEXT("AdvtExecuteSequence"), TEXT("SELECT `Action`, `Sequence` FROM `AdvtExecuteSequence` ORDER BY `Sequence`"),
	TEXT("AdvtUISequence"), TEXT("SELECT `Action`, `Sequence` FROM `AdvtUISequence` ORDER BY `Sequence`"),
	TEXT("InstallExecuteSequence"), TEXT("SELECT `Action`, `Sequence` FROM `InstallExecuteSequence` ORDER BY `Sequence`"),
	TEXT("InstallUISequence"), TEXT("SELECT `Action`, `Sequence` FROM `InstallUISequence` ORDER BY `Sequence`")
};


const TCHAR szSQLInstallValidate[]      = TEXT("SELECT `Action`, `SectionFlag` FROM `_InstallValidate` WHERE `Action`=?");
const TCHAR szSQLRequiredTable[]        = TEXT("SELECT `Table`, `Value`, `KeyCount` FROM `_Required` ORDER BY `Table`");
const TCHAR szSQLSeqTableQueryNotNull[] = TEXT("SELECT `Dependent` FROM `_Sequence` WHERE `Action`=? AND `Marker`<>0  AND `After`=0");
const TCHAR szSQLSeqTableQueryNull[]    = TEXT("SELECT `Dependent` FROM `_Sequence` WHERE `Action`=? AND `Marker`=0 AND `After`=1 AND `Optional`=0"); 
const TCHAR szSQLSeqTableAddCol[]       = TEXT("ALTER TABLE `_Sequence` ADD `Marker` SHORT TEMPORARY");
const TCHAR szSQLSeqMarkerInit[]        = TEXT("UPDATE `_Sequence` SET `Marker`=0");

const TCHAR sqlSeqInsert[]           = TEXT("SELECT `Action`, `Dependent`, `After`, `Optional` FROM `_Sequence`");
const TCHAR sqlSeqFindAfterOptional[]= TEXT("SELECT `Dependent`, `Action`, `After`, `Optional` FROM `_Sequence` WHERE `After`=1 AND `Optional`=1");

const int iMaxNumColumns = 32;
const int cchBuffer = 4096;
const int cbName = 64;

const int cchDisplayBuf = 4096;

//_______________________________________________________________________________________________________________
//
// _tmain -- UNICODE/ANSI main function
// 
// Driver routine
//_______________________________________________________________________________________________________________

extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
	// Determine handle
	g_hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
	if (g_hStdOut == INVALID_HANDLE_VALUE)
		g_hStdOut = 0;  // non-zero if stdout redirected or piped

	// Bool to allow user to specify option to turn OFF InstallSequence and Required Validation
	// So that databases won't fail if don't have the _InstallValidate and/or _Required tables
	// fSeq means to validate sequencing only.   Basically, the opposite of -OFF.
	BOOL fOff = FALSE;
	BOOL fSeq = FALSE;
	BOOL fSeqAll = FALSE;

	if (2 > argc)
	{
		_tprintf(TEXT("USAGE:\n msival.exe {database}\n msival.exe {database} -OFF"));
		return 1;
	}
	
	if (argc == 2 && (lstrcmp(argv[1],TEXT("-?")) == 0 || lstrcmp(argv[1],TEXT("/?")) == 0))
	{
		_tprintf(TEXT("USAGE:\n msival.exe {database}\n msival.exe {database} -OFF\nNOTE:\n For validation to proceed. . .\n\tTables required:\n\t _Validation (always)\n\t _InstallValidate (unless -OFF)\n\t _Required (unless -OFF)\n\t _Sequence (unless -OFF)\n"));
		return 0;
	}

	if (argc == 3)
	{
		if (lstrcmp(argv[2],TEXT("-OFF")) == 0 || lstrcmp(argv[2],TEXT("/OFF")) == 0
			|| lstrcmp(argv[2],TEXT("-off")) == 0 || lstrcmp(argv[2],TEXT("/off")) == 0)
			fOff = TRUE;
		else if (lstrcmp(argv[2],TEXT("-SEQ")) == 0 || lstrcmp(argv[2],TEXT("/SEQ")) == 0
			|| lstrcmp(argv[2],TEXT("-seq")) == 0 || lstrcmp(argv[2],TEXT("/seq")) == 0)
			fSeq = TRUE;
		else if (lstrcmp(argv[2],TEXT("-SEQALL")) == 0 || lstrcmp(argv[2],TEXT("/SEQALL")) == 0
			|| lstrcmp(argv[2],TEXT("-seqall")) == 0 || lstrcmp(argv[2],TEXT("/seqall")) == 0)
		{
			fSeq = TRUE;
			fSeqAll = TRUE;
		}
		else
		{
			_tprintf(TEXT("USAGE:\n msival.exe {database} -OFF\n"));
			return 0;
		}
	}

	BOOL fDataValid = TRUE;
	BOOL fColValid  = TRUE;
	BOOL fSeqOrderValid = TRUE;
	BOOL fReqValid  = TRUE;
	try
	{
		PMSIHANDLE hDatabase;
		CheckMsiRecord(MsiOpenDatabase(argv[1],MSIDBOPEN_READONLY,&hDatabase),TEXT("OpenDatabase"));


		if (fSeq)
			_tprintf(TEXT("WARNING!  Skipping validation for missing columns, data and foriegn keys.  Database may not be completely valid\n"));
		else
		{
			_tprintf(TEXT("INFO: Validating for missing columns. . .\n"));
			fColValid = CheckMissingColumns(hDatabase);
			_tprintf(TEXT("INFO: Validating data and foreign keys. . .\n"));
			fDataValid = Validate(hDatabase);
		}

		if (fOff)
		{
			// Print out warning of database not exactly valid since skipping these validations
			_tprintf(TEXT("WARNING! Skipping InstallSequence and Required Validation. Database may not be completely valid\n"));
		}
		else
		{
			if (MsiDatabaseIsTablePersistent(hDatabase, TEXT("_Sequence")) == MSICONDITION_NONE)
			{
				_tprintf(TEXT("No _Sequence table in this database.  Use ICEMAN/msival2/orca for this validation\n"));
				fSeqOrderValid = TRUE; // no validation to occur
			}
			else
			{
				const int cTables = sizeof(pSeqTables) / (2*sizeof(TCHAR*));
				_tprintf(TEXT("INFO: Validating Sequence of Actions In *Sequence Table. . .\n"));
				for (int cCounter = 0; cCounter < cTables; cCounter++)
				{
					if(MsiDatabaseIsTablePersistent(hDatabase,pSeqTables[cCounter].Name) == MSICONDITION_NONE)
					{
						_tprintf(TEXT("\tINFO: %s not found, skipping. . .\n"), pSeqTables[cCounter].Name);
						continue;
					}

					_tprintf(TEXT("\tINFO: %s\n"), pSeqTables[cCounter].Name);
					fSeqOrderValid = ValidateInstallSequence(hDatabase, pSeqTables[cCounter].SQL);
					if (!fSeqOrderValid)
						if (!fSeqAll)
							break;
				}
			}

			if (fSeq)
				_tprintf(TEXT("WARNING!  Skipping validation for required values.  Database may not be completely valid\n"));
			else
			{
				_tprintf(TEXT("INFO: Validating Required Values. . .\n"));
				fReqValid = ValidateRequired(hDatabase);
			}

		}
		if (fDataValid && fColValid && fReqValid && fSeqOrderValid)
			_tprintf(TEXT("Database is valid: %s\n"), argv[1]);
	}
	catch (UINT iError)
	{
		_tprintf(TEXT("\n%s error %i"), g_szErrorContext, iError);
		MsiCloseAllHandles();
		return 1;
	}
	catch (...)
	{
		_tprintf(TEXT("\n%s"), TEXT("Unhandled exception"));
		MsiCloseAllHandles();
		return 99;
	}
	int iOpenHandles = MsiCloseAllHandles();  // diagnostic check only
	if (iOpenHandles != 0)
		_tprintf(TEXT("\n%i Handle(s) not closed"), iOpenHandles);
	return (fDataValid && fColValid && fReqValid && fSeqOrderValid) ? 0 : 1;
}


void CheckMsi(UINT iStat, TCHAR* szContext)
/*----------------------------------------------------------------------------------
CheckMsi -- Routine to check return status for error and throw exception if error.
  Arguments:
	iStat -- error status
	szContext -- error string
  Returns:
	none, but throws error if one
-------------------------------------------------------------------------------------*/
{
	if (iStat != ERROR_SUCCESS)
	{
		g_szErrorContext = szContext;
		throw iStat;
	}
}

void CheckMsiRecord(UINT iStat, TCHAR* szContext)
/*----------------------------------------------------------------------------------
CheckMsi -- Routine to check return status for error and throw exception if error.
            If MsiGetLastErrorRecord returns record, that string is used instead.
  Arguments:
	iStat -- error status
	szContext -- error string
  Returns:
	none, but throws error if one
-------------------------------------------------------------------------------------*/
{
	if (iStat != ERROR_SUCCESS)
	{
		PMSIHANDLE hError = MsiGetLastErrorRecord();
		if (hError)
		{ 
			if (MsiRecordIsNull(hError, 0))
				MsiRecordSetString(hError, 0, TEXT("Error [1]: [2]{, [3]}{, [4]}{, [5]}"));
			TCHAR rgchBuf[1024];
			DWORD cchBuf = sizeof(rgchBuf)/sizeof(TCHAR);
			MsiFormatRecord(0, hError, rgchBuf, &cchBuf);
			g_szErrorContext = rgchBuf;
			throw iStat;
		}
		else
		{
			CheckMsi(iStat, szContext);
		}
	}
}


BOOL CheckMissingColumns(MSIHANDLE hDatabase)
/*---------------------------------------------------------------------
CheckMissingColumns -- used _Validation table and _Columns catalog to
 determine if any columns/tables are not listed.  All columns in
 _Validation table must be listed in the _Columns catalog.  If a column
 is optional and not used in the database, then it should not be found
 in the _Validation table or the _Columns catalog.  Normal validation
 catches the instance where a column is defined in the _Columns catalog
 but not in the _Validation table.
---------------------------------------------------------------------*/
{
	PMSIHANDLE hValidationView   = 0;
	PMSIHANDLE hColCatalogView   = 0;
	PMSIHANDLE hValidationRecord = 0;
	PMSIHANDLE hColCatalogRecord = 0;
	PMSIHANDLE hExecRecord       = 0;
	
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLColMissing, &hColCatalogView), TEXT("OpenColumnCatalogView"));
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLValidationTable, &hValidationView), TEXT("OpenValidationTableView"));

	UINT iRet = 0;
	TCHAR szTable[cbName] = {0};
	TCHAR szColumn[cbName] = {0};
	unsigned long cchTableBuf = sizeof(szTable)/sizeof(TCHAR);
	unsigned long cchColumnBuf = sizeof(szColumn)/sizeof(TCHAR);
	BOOL fStat = TRUE;

	hExecRecord = MsiCreateRecord(2);
	CheckMsiRecord(MsiViewExecute(hValidationView, 0), TEXT("ExecuteValidationView"));
	for (;;)
	{
		iRet = MsiViewFetch(hValidationView, &hValidationRecord);
		if (iRet == ERROR_NO_MORE_ITEMS || !hValidationRecord)
			break;
		CheckMsiRecord(iRet, TEXT("ColumnCatalogFetch"));
		CheckMsi(MsiRecordGetString(hValidationRecord, 1, szTable, &cchTableBuf), TEXT("GetTableName"));
		cchTableBuf = sizeof(szTable)/sizeof(TCHAR);
		CheckMsi(MsiRecordGetString(hValidationRecord, 2, szColumn, &cchColumnBuf), TEXT("GetColumnName"));
		cchColumnBuf = sizeof(szColumn)/sizeof(TCHAR);
		CheckMsi(MsiRecordSetString(hExecRecord, 1, szTable), TEXT("SetTableName"));
		CheckMsi(MsiRecordSetString(hExecRecord, 2, szColumn), TEXT("SetColumnName"));
		CheckMsi(MsiViewExecute(hColCatalogView, hExecRecord), TEXT("ExecuteColumnCatalogView"));
		iRet = MsiViewFetch(hColCatalogView, &hColCatalogRecord);
		if (iRet == ERROR_NO_MORE_ITEMS || !hColCatalogRecord)
		{
			// Error --> Missing from database
			TCHAR szMsgBuf[150];
			const TCHAR* szMessage = (TCHAR*)IDS_MissingEntry;
			const TCHAR** pszMsg;
			pszMsg = &szMessage;
			::LoadString(0, *(unsigned*)pszMsg, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR));
			*pszMsg = szMsgBuf;
			_tprintf(TEXT("Table.Column: %s.%s Message: %s\n"), szTable, szColumn, szMsgBuf);
			fStat = FALSE;
		}
		CheckMsi(MsiViewClose(hColCatalogView), TEXT("CloseView"));
	}
	MsiViewClose(hValidationView);
	
	return fStat;
}


BOOL ValidateRequired(MSIHANDLE hDatabase)
/*-----------------------------------------------------------------------------------
ValidateRequired -- Uses the _Required table and checks the tables listed for the
'required' values that are listed in the table.

-------------------------------------------------------------------------------------*/
{
	PMSIHANDLE hviewRequiredTable = 0;
	PMSIHANDLE hviewTable         = 0;
	PMSIHANDLE hrecTableExecute   = 0;
	PMSIHANDLE hrecRequiredFetch  = 0;
	PMSIHANDLE hrecTableFetch     = 0;
	PMSIHANDLE hrecColInfo        = 0;

	BOOL fValid = TRUE;
	BOOL fFirstRun = TRUE;
	UINT iStat = ERROR_SUCCESS;

	TCHAR szPrevTable[100] = {0};
	TCHAR szTable[100] = {0};
	TCHAR szValue[256] = {0};
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLRequiredTable, &hviewRequiredTable), TEXT("OpenViewRequiredTable"));
	CheckMsiRecord(MsiViewExecute(hviewRequiredTable, 0), TEXT("RequiredTableViewExecute"));
	while ((iStat = MsiViewFetch(hviewRequiredTable, &hrecRequiredFetch)) != ERROR_NO_MORE_ITEMS)
	{
		CheckMsi(iStat, TEXT("RequiredTableViewFetch"));
		if (!hrecRequiredFetch)
			break;
		int cPrimaryKeys = MsiRecordGetInteger(hrecRequiredFetch, 3);
		DWORD cbTable = sizeof(szTable)/sizeof(TCHAR);
		DWORD cbValue = sizeof(szValue)/sizeof(TCHAR);
		CheckMsi(MsiRecordGetString(hrecRequiredFetch, 1, szTable, &cbTable), TEXT("RequiredTableRecordGetString"));
		CheckMsi(MsiRecordGetString(hrecRequiredFetch, 2, szValue, &cbValue), TEXT("RequiredTableRecordGetString"));
		if (fFirstRun)
			fFirstRun = FALSE;
		else
			CheckMsi(MsiViewClose(hviewTable), TEXT("TableViewClose"));
		hrecTableExecute = MsiCreateRecord(cPrimaryKeys);
		if (hrecTableExecute == 0)
			return FALSE;

		if (lstrcmp(szPrevTable, szTable) != 0)
		{
			// New table, need to open a new view.
			TCHAR szSQL[1024] = {0};
			PMSIHANDLE hrecPrimaryKeys = 0;
			TCHAR szKeyColName[50] = {0};
			DWORD cbKey = sizeof(szKeyColName)/sizeof(TCHAR);
			CheckMsi(MsiDatabaseGetPrimaryKeys(hDatabase, szTable, &hrecPrimaryKeys), TEXT("DatabaseGetPrimaryKeys"));
			CheckMsi(MsiRecordGetString(hrecPrimaryKeys, 1, szKeyColName, &cbKey), TEXT("PrimaryKeysRecordGetString"));
			CheckMsi(MsiRecordGetFieldCount(hrecPrimaryKeys) != cPrimaryKeys, TEXT("PrimaryKeyCountWrong"));
			CheckMsi(cPrimaryKeys == ERROR_INVALID_HANDLE, TEXT("PrimaryKeysRecordGetFieldCount"));
			
			// Develop query of table to be checked
			int cchWritten = _stprintf(szSQL, TEXT("SELECT * FROM `%s` WHERE `%s`=?"), szTable, szKeyColName);
			int cchAddition = cchWritten;
			for (int i = 2; i <= cPrimaryKeys; i++)
			{
				cbKey = sizeof(szKeyColName)/sizeof(TCHAR);
				CheckMsi(MsiRecordGetString(hrecPrimaryKeys, i, szKeyColName, &cbKey), TEXT("PrimaryKeysRecordGetString"));
				cchWritten = _stprintf(szSQL + cchAddition, TEXT(" AND `%s`=?"), szKeyColName);
				cchAddition = cchWritten;
			}
			CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQL, &hviewTable), TEXT("DatabaseOpenView"));
			CheckMsi(MsiViewGetColumnInfo(hviewTable, MSICOLINFO_TYPES, &hrecColInfo), TEXT("GetColumnInfo"));
			lstrcpy(szPrevTable, szTable);
		}

		// Fill in execute record with the key data values
		TCHAR* pch = szValue;
		TCHAR szKeyValue[256] = {0};
		TCHAR szType[32] = {0};
		DWORD cbType = sizeof(szType)/sizeof(TCHAR);
		int nDex = 0;
		for (int j = 1; j <= cPrimaryKeys; j++)
		{
			while (pch != 0 && *pch != TEXT(';') &&  *pch != 0)
				szKeyValue[nDex++] = *pch++;
			szKeyValue[nDex] = 0;
			pch++; // for ; or 0
			cbType = sizeof(szType)/sizeof(TCHAR);
			CheckMsi(MsiRecordGetString(hrecColInfo, j, szType, &cbType), TEXT("ColInfoGetString"));
			if (szType != 0 && *szType == TEXT('s'))
				CheckMsi(MsiRecordSetString(hrecTableExecute, j, szKeyValue), TEXT("TableExecuteRecordSetString"));
			else // integer primary key
				CheckMsi(MsiRecordSetInteger(hrecTableExecute, j, _ttoi(szKeyValue)), TEXT("TableExecuteRecordSetInteger"));
			nDex = 0;
		}

		// Execute view and attempt to fetch listed item from table
		CheckMsiRecord(MsiViewExecute(hviewTable, hrecTableExecute), TEXT("TableViewExecute"));
		iStat = MsiViewFetch(hviewTable, &hrecTableFetch);
		if (iStat == ERROR_NO_MORE_ITEMS)
		{
			// Value not found
			TCHAR szError[cchBuffer] = {0};
			_stprintf(szError, TEXT("ERROR: Value: '%s' Is Required In Table: '%s'\n"), szValue, szTable);
			Display(szError);
			fValid = FALSE;
		}
		else if (iStat != ERROR_SUCCESS)
			CheckMsi(iStat, TEXT("TableViewFetch"));
	}

	return fValid;

}


BOOL ValidateInstallSequence(MSIHANDLE hDatabase, const TCHAR* szSQLInstallSeqTable)
/*----------------------------------------------------------------------------
ValidateInstallSequence -- validates the order of the actions in the
InstallSequence table to ensure that they are allowed by the _Sequence table.
The _Sequence table is required for this validation.
------------------------------------------------------------------------------*/
{
	BOOL fValid = TRUE;
	UINT iStat1 = ERROR_SUCCESS;
	UINT iStat2 = ERROR_SUCCESS;
	
	PMSIHANDLE hviewInstallTable    = 0;
	PMSIHANDLE hviewSeqQueryNull    = 0;
	PMSIHANDLE hviewSeqQueryNotNull = 0;
	PMSIHANDLE hviewSeqUpdate       = 0;
	PMSIHANDLE hviewSeqAddColumn    = 0;
	PMSIHANDLE hviewSeqMarkerInit   = 0;
	PMSIHANDLE hrecSeqUpdateExecute = 0;
	PMSIHANDLE hrecQueryExecute     = 0;
	PMSIHANDLE hrecInstallFetch     = 0;
	PMSIHANDLE hrecQueryNullFetch   = 0;
	PMSIHANDLE hrecQueryNotNullFetch= 0;

	// Set up the _Sequence table with the insert temporary of actions where After=1 and Optional=1
	// This is so that we can catch errors.  WE need to insert w/ Action=Dependent, Dependent=Action, After=0, and Optional=1
	PMSIHANDLE hViewSeqInsert = 0;
	PMSIHANDLE hViewSeqFind   = 0;
	PMSIHANDLE hRecSeqFind    = 0;
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, sqlSeqFindAfterOptional, &hViewSeqFind), TEXT("Find AfterOptional entries"));
	CheckMsiRecord(MsiViewExecute(hViewSeqFind, 0), TEXT("Execute AfterOptional entries"));
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, sqlSeqInsert, &hViewSeqInsert), TEXT("Insert query for AfterOptional"));
	CheckMsiRecord(MsiViewExecute(hViewSeqInsert, 0), TEXT("Execute insert query for AfterOptional"));

	// fetch all of those actions
	while (ERROR_SUCCESS == (iStat1 = MsiViewFetch(hViewSeqFind, &hRecSeqFind)))
	{
		CheckMsi(iStat1, TEXT("AfterOptional Find Fetch"));

		// set After from 1 to 0, leave optional as is
		::MsiRecordSetInteger(hRecSeqFind, 3, 0);

		// insert temporary (possible read only db)
		if (ERROR_SUCCESS != (iStat1 = ::MsiViewModify(hViewSeqInsert, MSIMODIFY_INSERT_TEMPORARY, hRecSeqFind)))
		{
			// if ERROR_FUNCTION_FAILED, we're okay....author already took care of this for us
			if (ERROR_FUNCTION_FAILED != iStat1)
				CheckMsi(iStat1, TEXT("MsiViewModify after-optional"));
		}
	}
	::MsiViewClose(hViewSeqFind);
	::MsiViewClose(hViewSeqInsert);

	// Create the temporary marking column for the _Sequence table (this will store the sequence #s of the Dependent Actions)
	if (ERROR_SUCCESS == (iStat1 = MsiDatabaseOpenView(hDatabase, szSQLSeqTableAddCol, &hviewSeqAddColumn)))
	{
		CheckMsiRecord(MsiViewExecute(hviewSeqAddColumn, 0), TEXT("_SequenceTableAddColExecute"));
		CheckMsi(MsiViewClose(hviewSeqAddColumn), TEXT("_SequenceTableAddColClose"));
	}
	else if (iStat1 != ERROR_BAD_QUERY_SYNTAX) // Marking column already in memory
		CheckMsiRecord(iStat1, TEXT("Add column view"));
	
	// Initialize the temporary marking column to zero
	// NO INSTALL SEQUENCE ACTIONS CAN HAVE A ZERO SEQUENCE # AS ZERO IS CONSIDERED "NULL"
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLSeqMarkerInit, &hviewSeqMarkerInit), TEXT("_SequenceTableMarkerInitOpenView"));
	CheckMsiRecord(MsiViewExecute(hviewSeqMarkerInit, 0), TEXT("_SequenceTableMarkerInitExecute"));
	CheckMsi(MsiViewClose(hviewSeqMarkerInit), TEXT("_SequenceTableMarkerInitClose"));

	// Open view on InstallSequence table and order by the Sequence #
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLInstallSeqTable, &hviewInstallTable), TEXT("InstallSequenceTableOpenView"));
	CheckMsiRecord(MsiViewExecute(hviewInstallTable, 0), TEXT("InstallSequenceTableExecute"));

	// Open the two query views on _Sequence table for determining the validity of the actions
	// Create execution record
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLSeqTableQueryNull, &hviewSeqQueryNull), TEXT("SequenceTableQueryNullOpenView"));
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLSeqTableQueryNotNull, &hviewSeqQueryNotNull), TEXT("_SequenceTableQueryNotNullOpenView"));
	hrecQueryExecute = MsiCreateRecord(1); // for action
	CheckMsi(hrecQueryExecute == 0, TEXT("QueryExecuteCreateRecord"));
	hrecSeqUpdateExecute = MsiCreateRecord(1); // for action
	CheckMsi(hrecSeqUpdateExecute == 0, TEXT("UpdateExecuteCreateRecord"));

	// Start fetching actions from the InstallSequence table
	TCHAR szSQLUpdateQuery[4096] = {0};
	TCHAR szAction[100] = {0};
	int iSequence = 0;
	for (;;)
	{
		iStat1 = MsiViewFetch(hviewInstallTable, &hrecInstallFetch);
		if (iStat1 == ERROR_NO_MORE_ITEMS || !hrecInstallFetch)
			break;
		CheckMsi(iStat1, TEXT("InstallTableFetch"));
		DWORD cbSize = sizeof(szAction)/sizeof(TCHAR);
		
		// Obtain name of action and Sequence # of action in InstallSequence table
		CheckMsi(MsiRecordGetString(hrecInstallFetch, 1, szAction, &cbSize), TEXT("InstallFetchRecordGetString"));
		iSequence = MsiRecordGetInteger(hrecInstallFetch, 2);
		CheckMsi(iSequence == MSI_NULL_INTEGER, TEXT("InstallFetchRecordGetInteger"));

		// Prepare execution records
		CheckMsi(MsiRecordSetString(hrecQueryExecute, 1, szAction), TEXT("_SequenceQueryExecuteRecordSetString"));
		CheckMsi(MsiRecordSetString(hrecSeqUpdateExecute, 1, szAction), TEXT("_SequenceUpdateExecuteRecordSetString"));
		
		// Execute _Sequence query table views
		CheckMsiRecord(MsiViewExecute(hviewSeqQueryNull, hrecQueryExecute), TEXT("_SequenceQueryNullExecute"));
		CheckMsiRecord(MsiViewExecute(hviewSeqQueryNotNull, hrecQueryExecute), TEXT("_SequenceQueryNotNullExecute"));

		// Fetch from _Sequence table.  If resultant set, then ERROR
		// Following are the possibilities and whether permitted:
		//   Action After Dependent Where Dependent Is Required And Temp Sequence Column Is Zero --> ERROR
		//   Action After Dependent Where Dependent Is Required And Temp Sequence Column Is Greater Than Zero --> CORRECT
		//   Action After Dependent Where Dependent Is Optional And Temp Sequence Column Is Zero --> CORRECT
		//   Action After Dependent Where Dependent Is Optional And Temp Sequence Column Is Greater Than Zero --> CORRECT
		//   Action Before Dependent Where Dependent Is Optional Or Required And Temp Sequence Column Is Zero --> CORRECT
		//   Action Before Dependent Where Dependent Is Optional Or Requred And Temp Sequence Column Is Greater Than Zero --> ERROR

		// ** Only issue is when Action Is After Optional Dependent And Temp Sequence Column Is Zero because we
		// ** have no way of knowing whether the action will be later (in which case it would be invalid.  This is
		// ** ensured to be successful though by proper authoring of the _Sequence table.  If an Action comes after
		// ** the Optional Dependent Action, then the _Sequence table must also be authored with the Dependent Action
		// ** listed as coming before that Action (so if we come later, and find a result set, we flag this case).

		// If return is not equal to ERROR_NO_MORE_ITEMS, then ERROR and Output Action
		while (ERROR_NO_MORE_ITEMS != MsiViewFetch(hviewSeqQueryNull, &hrecQueryNullFetch))
		{
			TCHAR szError[1024] = {0};
			TCHAR szDependent[100] = {0};
			DWORD cch = sizeof(szDependent)/sizeof(TCHAR);
			CheckMsi(MsiRecordGetString(hrecQueryNullFetch, 1, szDependent, &cch), TEXT("MsiRecordGetString"));
			_stprintf(szError, TEXT("ERROR: %s Action Is Sequenced Incorrectly (Dependent=%s)\n"), szAction, szDependent);
			Display(szError);
			cch = sizeof(szDependent)/sizeof(TCHAR); // reset
			fValid = FALSE;
		}

		while (ERROR_NO_MORE_ITEMS != MsiViewFetch(hviewSeqQueryNotNull, &hrecQueryNotNullFetch))
		{
			TCHAR szError[1024] = {0};
			TCHAR szDependent[100] = {0};
			DWORD cch = sizeof(szDependent)/sizeof(TCHAR);
			CheckMsi(MsiRecordGetString(hrecQueryNotNullFetch, 1, szDependent, &cch), TEXT("MsiRecordGetString"));
			_stprintf(szError, TEXT("ERROR: %s Action Is Sequenced Incorrectly (Dependent=%s)\n"), szAction, szDependent);
			Display(szError);
			cch = sizeof(szDependent)/sizeof(TCHAR); // reset
			fValid = FALSE;
		}

		// Update _Sequence table temporary Sequence column (that we created) with the install sequence number
		// The Sequence column stores the sequence number of the Dependent Actions, so we are updating every
		// row where the action in the Dependent column equals the current action.  In the query view, we only
		// check to insure that this column is zero or greater than zero (so we don't care too much about the value)
		// Build the query: UPDATE `_Sequence` SET `Marker`=iSequence WHERE `Dependent`=szAction
		_stprintf(szSQLUpdateQuery, TEXT("UPDATE `_Sequence` SET `Marker`=%d WHERE `Dependent`=?"), iSequence);
		CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLUpdateQuery, &hviewSeqUpdate), TEXT("_SequenceTableUpdateOpenView"));
		CheckMsiRecord(MsiViewExecute(hviewSeqUpdate, hrecSeqUpdateExecute), TEXT("_SequenceUpdateExectue"));

		// Close the _Sequence table views so we can re-execute
		CheckMsi(MsiViewClose(hviewSeqUpdate), TEXT("_SequenceUpdateViewClose"));
		CheckMsi(MsiViewClose(hviewSeqQueryNull), TEXT("_SequenceQueryNullViewClose"));
		CheckMsi(MsiViewClose(hviewSeqQueryNotNull), TEXT("_SequenceQueryNotNullViewClose"));
	}

	// Close the InstallSequence table view
	CheckMsi(MsiViewClose(hviewInstallTable), TEXT("InstallSequenceTableViewClose"));

	return fValid;
}


BOOL Validate(MSIHANDLE hDatabase)
/*-----------------------------------------------------------------------------------
Validate -- Routine to validate database.  Prints out invalid data if any.
  Arguments:
	hDatabase -- handle to database
	iValid -- integer for storing whether database is valid
  Returns:
	BOOL status -- TRUE (all valid), FALSE (invalid data found)
-------------------------------------------------------------------------------------*/
{
	// _Tables (Table Catalog)
	PMSIHANDLE hTableCatalogView;
	PMSIHANDLE hTableCatalogRecord;
	// Table To Validate
	PMSIHANDLE hValidationView;
	PMSIHANDLE hValidationRecord;
	// Record for Primary Keys
	PMSIHANDLE hKeyRecord;

	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLTableCatalog, &hTableCatalogView),TEXT("OpenTableCatalogView"));
	CheckMsiRecord(MsiViewExecute(hTableCatalogView, 0), TEXT("Execute Table Catalog View"));
	TCHAR szSQL[256];
	TCHAR szTableName[32];
	TCHAR szColumnData[255];
	TCHAR szColumnName[32];
	DWORD cchTableName = sizeof(szTableName)/sizeof(TCHAR);
	DWORD cchColumnName = sizeof(szColumnName)/sizeof(TCHAR);
	DWORD cchColumnData = sizeof(szColumnData)/sizeof(TCHAR);
	
	BOOL fDataValid = TRUE; // initially valid
	DWORD cchTableBuf = cchTableName;
	DWORD cchDataBuf = cchColumnData;
	DWORD cchBuf = cchColumnName;
	UINT uiRet = 0;			

	// process the tables.
	for (;;)
	{

		uiRet = MsiViewFetch(hTableCatalogView, &hTableCatalogRecord);
		if (uiRet == ERROR_NO_MORE_ITEMS)
			break;
		CheckMsi(uiRet, TEXT("Fetch Table Catalog Record"));
		if (!hTableCatalogRecord)
			break;
		cchTableBuf = cchTableName; // on return size of string written
		CheckMsi(MsiRecordGetString(hTableCatalogRecord, 1, szTableName, &cchTableBuf), TEXT("Get Table Name From Fetched Record"));
		MSICONDITION ice = MsiDatabaseIsTablePersistent(hDatabase, szTableName);
		if (ice == MSICONDITION_FALSE)
			continue;
		CheckMsi(ice != MSICONDITION_TRUE, TEXT("IsTablePersistent"));
		_stprintf(szSQL, TEXT("%s`%s`"), szSQLTable, szTableName);
		CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQL, &hValidationView),TEXT("OpenView"));
		CheckMsiRecord(MsiViewExecute(hValidationView, 0), TEXT("Execute View"));

		BOOL fMissingValidation = FALSE;
		BOOL fSkipMissingValidation = FALSE;

		// process current table
		for (;;)
		{
			uiRet = MsiViewFetch(hValidationView, &hValidationRecord);
			if (uiRet == ERROR_NO_MORE_ITEMS)
				break;
			CheckMsi(uiRet, TEXT("Fetch record"));
			if (!hValidationRecord)
				break;
			if (MsiViewModify(hValidationView, MSIMODIFY_VALIDATE, hValidationRecord) != ERROR_SUCCESS)
			{
				fDataValid = FALSE;
				cchTableBuf = cchTableName;
				cchDataBuf = cchColumnData;
				cchBuf = cchColumnName;

				MSIDBERROR eReturn;
				if (fMissingValidation)
					fSkipMissingValidation = TRUE;

				// Display errors from current row
				while ((eReturn = MsiViewGetError(hValidationView, szColumnName, &cchBuf)) != MSIDBERROR_NOERROR)
				{
					if (eReturn == MSIDBERROR_FUNCTIONERROR || eReturn == MSIDBERROR_MOREDATA || eReturn == MSIDBERROR_INVALIDARG)
					{
						_tprintf(TEXT("\nFunction Error"));
					//	break;
					}
					
					int iResId;
					int iValue;
					switch (eReturn)
					{
					case MSIDBERROR_NOERROR:           iResId = IDS_NoError;          break;
					case MSIDBERROR_DUPLICATEKEY:      iResId = IDS_DuplicateKey;     break;
					case MSIDBERROR_REQUIRED:          iResId = IDS_Required;         break;
					case MSIDBERROR_BADLINK:           iResId = IDS_BadLink;          break;
					case MSIDBERROR_OVERFLOW:          iResId = IDS_Overflow;         break;
					case MSIDBERROR_UNDERFLOW:         iResId = IDS_Underflow;        break;
					case MSIDBERROR_NOTINSET:          iResId = IDS_NotInSet;         break;
					case MSIDBERROR_BADVERSION:        iResId = IDS_BadVersion;       break;
					case MSIDBERROR_BADCASE:           iResId = IDS_BadCase;          break;
					case MSIDBERROR_BADGUID:           iResId = IDS_BadGuid;          break;
					case MSIDBERROR_BADWILDCARD:       iResId = IDS_BadWildCard;      break;
					case MSIDBERROR_BADIDENTIFIER:     iResId = IDS_BadIdentifier;    break;
					case MSIDBERROR_BADLANGUAGE:       iResId = IDS_BadLanguage;      break;
					case MSIDBERROR_BADFILENAME:       iResId = IDS_BadFileName;      break;
					case MSIDBERROR_BADPATH:           iResId = IDS_BadPath;          break;
					case MSIDBERROR_BADCONDITION:      iResId = IDS_BadCondition;     break;
					case MSIDBERROR_BADFORMATTED:      iResId = IDS_BadFormatted;     break;
					case MSIDBERROR_BADTEMPLATE:       iResId = IDS_BadTemplate;      break;
					case MSIDBERROR_BADDEFAULTDIR:     iResId = IDS_BadDefaultDir;    break;
					case MSIDBERROR_BADREGPATH:        iResId = IDS_BadRegPath;       break;
					case MSIDBERROR_BADCUSTOMSOURCE:   iResId = IDS_BadCustomSource;  break;
					case MSIDBERROR_BADPROPERTY:       iResId = IDS_BadProperty;      break;
					case MSIDBERROR_MISSINGDATA:       iResId = IDS_MissingData;      
						fMissingValidation = TRUE;  
						break;
					case MSIDBERROR_BADCATEGORY:       iResId = IDS_BadCategory;      break;
					case MSIDBERROR_BADKEYTABLE:       iResId = IDS_BadKeyTable;      break;
					case MSIDBERROR_BADMAXMINVALUES:   iResId = IDS_BadMaxMinValues;  break;
					case MSIDBERROR_BADCABINET:        iResId = IDS_BadCabinet;       break;
					case MSIDBERROR_BADSHORTCUT:       iResId = IDS_BadShortcut;      break;
					case MSIDBERROR_STRINGOVERFLOW:    iResId = IDS_StringOverflow;   break;
					case MSIDBERROR_BADLOCALIZEATTRIB: iResId = IDS_BadLocalizeAttrib;break;
					default:                           iResId = IDS_UndefinedError;   break;
					};

					cchBuf = cchColumnName; // on return size of string written
					cchDataBuf = cchColumnData;

					if ((MSIDBERROR_MISSINGDATA == eReturn) && fSkipMissingValidation)
						continue;

					// Print table
					_tprintf(TEXT("\n Error: %s\t"), szTableName);
					
					// Get Row	
					CheckMsi(MsiDatabaseGetPrimaryKeys(hDatabase, szTableName, &hKeyRecord), TEXT("Get Primary Keys"));
					unsigned int iNumFields = MsiRecordGetFieldCount(hKeyRecord);
					if (MsiRecordGetString(hValidationRecord, 1, szColumnData, &cchDataBuf) != ERROR_SUCCESS)
					{
						iValue = MsiRecordGetInteger(hValidationRecord, 1);
						_tprintf(TEXT("%d"), iValue);
					}
					else
						_tprintf(TEXT("%s"), szColumnData);
					cchDataBuf = cchColumnData;
					for (int i = 2; i <= iNumFields; i++)
					{
						_tprintf(TEXT("."));
						cchDataBuf = cchColumnData;
						if (MsiRecordGetString(hValidationRecord, i, szColumnData, &cchDataBuf) != ERROR_SUCCESS)
						{
							iValue = MsiRecordGetInteger(hValidationRecord, 1);
							_tprintf(TEXT("%d"), iValue);
						}
						else
							_tprintf(TEXT("%s"), szColumnData);
					}
					// Print name of column and enum value
					TCHAR szMsgBuf[80];
					const TCHAR* szMessage = (TCHAR*)IntToPtr(iResId);
					const TCHAR** pszMsg;
					pszMsg = &szMessage;
					::LoadString(0, *(unsigned*)pszMsg, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR));
					*pszMsg = szMsgBuf;
					_tprintf(TEXT("\t%s\t%s\n"), szColumnName, szMsgBuf);

				}
				cchBuf = cchColumnName; // on return size of string written
			}
		}
		CheckMsi(MsiViewClose(hValidationView), TEXT("Close view"));
	}
	CheckMsi(MsiViewClose(hTableCatalogView), TEXT("Close Table Catalog View"));
	return fDataValid;
}

void Display(LPCTSTR szMessage)
{
	if (szMessage)
	{
		int cbOut = _tcsclen(szMessage);;
		if (g_hStdOut)
		{
#ifdef UNICODE
			char rgchTemp[cchDisplayBuf];
			if (GetFileType(g_hStdOut) == FILE_TYPE_CHAR)
			{
				WideCharToMultiByte(CP_ACP, 0, szMessage, cbOut, rgchTemp, sizeof(rgchTemp), 0, 0);
				szMessage = (LPCWSTR)rgchTemp;
			}
			else
				cbOut *= 2;   // write Unicode if not console device
#endif
			DWORD cbWritten;
			WriteFile(g_hStdOut, szMessage, cbOut, &cbWritten, 0);
		}
		else
			MessageBox(0, szMessage, GetCommandLine(), MB_OK);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msival2\msival2.cpp ===
#if 0  // makefile definitions, to build: %vcbin%\nmake -fMsiVal2.cpp
DESCRIPTION = MSI Evaluation Tool - using ICEs
MODULENAME = msival2
SUBSYSTEM = console
FILEVERSION = MSI
LINKLIBS = OLE32.lib
!include "MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File:       msival2.cpp
//
//--------------------------------------------------------------------------

// Required headers
#include <windows.h>

#define IDS_UnknownTable      36

#ifndef RC_INVOKED    // start of source code

#ifndef W32	// if W32 not defined
#define W32
#endif	// W32 defined

#ifndef MSI	// if MSI not defined
#define MSI
#endif	// MSI defined

#include "msiquery.h"
#include <stdio.h>   // wprintf
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE

/////////////////////////////////////////////////////////////////////////////
// global strings
TCHAR g_szFormatter[] = _T("%-10s   %-7s   %s\r\n");
BOOL  g_fInfo = TRUE;

/////////////////////////////////////////////////////////////////////////////
// COM
#include <objbase.h>
#include <initguid.h>
#include "iface.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ProductCode changes from one SDK to the Next; Component Code stays the same 
// Below must be changed when/if Component Code changes in the MSI!
// MsiVal2 has conditionalized components for main exe depending on platform
#define MAX_GUID 38
TCHAR   g_szMsiValWin9XComponentCode[MAX_GUID+1] = _T("{EAB27DFA-90C6-11D2-88AC-00A0C981B015}");
TCHAR   g_szMsiValWinNTComponentCode[MAX_GUID+1] = _T("{EAB27DFB-90C6-11D2-88AC-00A0C981B015}");

///////////////////////////////////////////////////////////
// CleanUp
// uninitializes COM and cleans up evaluator
//
void CleanUp(IEval* pIEval)
{
	if (pIEval)
		pIEval->Release();
	W32::CoUninitialize();
}

///////////////////////////////////////////////////////////
// AnsiToWide
// pre:  sz is the ansi string
// pos:  szw is the wide string
//NOTE:  if sz is NULL, sets szw to NULL
void AnsiToWide(LPCSTR sz, OLECHAR*& szw)
{
	if (!sz)
	{
		szw = NULL;
		return;
	}
	int cchWide = W32::MultiByteToWideChar(CP_ACP, 0, sz, -1, szw, 0);
	szw = new OLECHAR[cchWide];
	W32::MultiByteToWideChar(CP_ACP, 0, sz, -1, szw, cchWide);
}

////////////////////////////////////////////////////////////
// WideToAnsi
// pre: szw is the wide string
// pos: sz is the ansi string
//NOTE: if szw is NULL, sets sz to NULL
void WideToAnsi(const OLECHAR* szw, char*& sz)
{
	if (!szw)
	{
		sz = NULL;
		return;
	}
	int cchAnsi = W32::WideCharToMultiByte(CP_ACP, 0, szw, -1, 0, 0, 0, 0);
	sz = new char[cchAnsi];
	W32::WideCharToMultiByte(CP_ACP, 0, szw, -1, sz, cchAnsi, 0, 0);
}		

///////////////////////////////////////////////////////////
// CheckFeature
// pre:	szFeatureName is a Feature that belongs to this product
// pos:	installs the feature if not present and we go
BOOL CheckFeature(LPCTSTR szFeatureName)
{
	// determine platform (Win9X or WinNT) -- EXE component code conditionalized on platform
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); // init structure
	if (!GetVersionEx(&osvi))
		return FALSE;

	bool fWin9X = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ? true : false;

	// get ProductCode -- Windows Installer can determine the product code from a component code.
	// Here we use the MsiVal2 main component (component containing msival2.exe).  You must choose
	// a component that identifies the app, not a component that could be shared across products.
	// This is why we can't use the EvalComServer component.  EvalCom is shared between msival2 and orca
	// so the Windows Installer would be unable to determine to which product (if both were installed)
	// the component belonged.
	TCHAR szProductCode[MAX_GUID+1] = TEXT("");
	UINT iStat = 0;
	if (ERROR_SUCCESS != (iStat = MsiGetProductCode(fWin9X ? g_szMsiValWin9XComponentCode : g_szMsiValWinNTComponentCode,
											szProductCode)))
	{
		// error obtaining product code (may not be installed or component code may have changed)
		_tprintf(_T(">>> Fatal Error: MsiGetProductCode failed with error: %d.  Please install or re-install MsiVal2\n"), iStat);
		return FALSE;
	}

	// Prepare to use the feature: check its current state and increase usage count.
	INSTALLSTATE iFeatureState = MSI::MsiUseFeature(szProductCode, szFeatureName);


	// If feature is not currently usable, try fixing it
	switch (iFeatureState) 
	{
	case INSTALLSTATE_LOCAL:
	case INSTALLSTATE_SOURCE:
		break;
	case INSTALLSTATE_ABSENT:
		// feature isn't installed, try installing it
		if (ERROR_SUCCESS != MSI::MsiConfigureFeature(szProductCode, szFeatureName, INSTALLSTATE_LOCAL))
			return FALSE;			// installation failed
		break;
	default:
		// feature is busted- try fixing it
		if (MsiReinstallFeature(szProductCode, szFeatureName, 
			REINSTALLMODE_FILEEQUALVERSION
			+ REINSTALLMODE_MACHINEDATA 
			+ REINSTALLMODE_USERDATA
			+ REINSTALLMODE_SHORTCUT) != ERROR_SUCCESS)
			return FALSE;			// we couldn't fix it
		break;
	}

	return TRUE;
}	// end of CheckFeature

///////////////////////////////////////////////////////////
// DisplayFunction
// pre:	called from Evaluation COM Object
// pos:	displays output from COM Object
BOOL WINAPI DisplayFunction(LPVOID pContext, UINT uiType, LPCWSTR szwVal, LPCWSTR szwDescription, LPCWSTR szwLocation)
{
	if (ieInfo == uiType && !g_fInfo)
		return TRUE;

	// try to change the context into a log file handle
	HANDLE hLogFile = *((HANDLE*)pContext);

	// fill up a buffer string
	static TCHAR szBuffer[1024];
	DWORD cchBuffer;
	

	// set the type correctly
	LPTSTR szType;
	switch (uiType)
	{
	case ieError:
		szType = _T("ERROR");
		break;
	case ieWarning:
		szType = _T("WARNING");
		break;
	case ieInfo:
		szType = _T("INFO");
		break;
	default:
		szType = _T("UNKNOWN");
		break;
	}

	// create and then get length of buffer
#ifdef UNICODE
	_stprintf(szBuffer, g_szFormatter, szwVal, szType, szwDescription);
	cchBuffer = wcslen(szBuffer);
#else
	// convert the display strings into ANSI
	char *szVal = NULL;
	char *szDescription = NULL;
	WideToAnsi(szwVal, szVal);
	WideToAnsi(szwDescription, szDescription);
	_stprintf(szBuffer, g_szFormatter, szVal, szType, szDescription);
	cchBuffer = strlen(szBuffer);
#endif // UNICODE

	// if there is something in the buffer to display
	if (cchBuffer > 0)
	{
		// display the buffer string
		_tprintf(szBuffer);

		// if there is a log file write to it
		if (hLogFile != INVALID_HANDLE_VALUE)
		{
			// write to file
			DWORD cchDiscard;
			W32::WriteFile(hLogFile, szBuffer, cchBuffer * sizeof(TCHAR), &cchDiscard, NULL);
		}
	}

#ifndef UNICODE
	if (szVal)
		delete [] szVal;
	if (szDescription)
		delete [] szDescription;
#endif // !UNICODE

	return FALSE;
}

///////////////////////////////////////////////////////////
// RemoveQuotes
// pre:	pszOriginal points to a string
// pos:	removes " from either end of string
void RemoveQuotes(TCHAR*& rpszOriginal)
{
	// if string starts with a "
	if (*rpszOriginal == _T('"'))
		rpszOriginal++;	// step over "

	// get length of string
	int iLen = lstrlen(rpszOriginal);

	// if string ends with a " erase last char
	if (*(rpszOriginal + iLen) == _T('"'))
		*(rpszOriginal + iLen) = _T('\0');
}	// end of RemoveQuotes

///////////////////////////////////////////////////////////
// Usage
// pre:	none
// pos:	prints help to stdout
void Usage()
{
	_tprintf(_T("Copyright (C) Microsoft Corporation, 1998-2001.  All rights reserved.\n"));
	_tprintf(_T("msival2.exe database.msi EvaluationURL/Filename\n"));
//	_tprintf(_T("msival2.exe database.msi -Z\n"));
	_tprintf(_T("            [-i ICE01:ICE02:ICE03:...] [-l LogFile] [-?] [-f]\n"));
	_tprintf(_T("   i - [optional] specifies exact Internal Consistency Evaluators to run.\n"));
	_tprintf(_T("                  Each ICE must be separated by a colon.\n"));
	_tprintf(_T("   l - [optional] specifies log file \n"));
    _tprintf(_T("   ? - [optional] displays this help\n"));
//	_tprintf(_T("   Z - [special] use latest known evaluation file (off of ICEMAN website)"));
	_tprintf(_T("   f - [optional] suppress info messages\n\n"));
    _tprintf(_T("   WARNING: Be careful not to reverse the order of your database file and your validation file as no direct error message will be given if you do.\n"));

	return;
}	// end of Usage

///////////////////////////////////////////////////////////
// main
extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
	// flags
	BOOL bLogging = FALSE;			// assume no logging
	
	BOOL bResult = FALSE;				// assume results are always bad
	HRESULT hResult = ERROR_SUCCESS;	// assume COM results are always good

	// strings for command line information
	TCHAR* pszDatabase = NULL;
	TCHAR* pszEvalFile = NULL;
	TCHAR* pszICEs = NULL;
	TCHAR* pszLogFile = NULL;
	HANDLE hLogFile = INVALID_HANDLE_VALUE;	// set the log file to invalid

	// if there is something on the command line
	// set the database to the first parameter on the command line
	if (argc > 1)
	{
		pszDatabase = argv[1];
		RemoveQuotes(pszDatabase);
	}

	if (argc > 2)
	{
		pszEvalFile = argv[2];
		RemoveQuotes(pszEvalFile);
	}

	// loop through all parameters on command line
	TCHAR chCommand;
	for(int i = 0; i < argc; i++)
	{
		// if we have a command character
		if ('-' == *argv[i] || '/' == *argv[i])
		{
			// get the command letter
			chCommand = argv[i][1];

			switch (chCommand)
			{
				case 'D':	// set the database
				case 'd':
					if (argc == i + 1)
					{
						_tprintf(TEXT(">>ERROR: Database not specified\n"));
						return 0;
					}
					pszDatabase = argv[i + 1];
					RemoveQuotes(pszDatabase);
					i++;
					break;
				case 'E':	// set evaluation file
				case 'e':
					if (argc == i + 1)
					{
						_tprintf(TEXT(">>ERROR: Evaluation file not specified\n"));
						return 0;
					}
					pszEvalFile = argv[i + 1];
					RemoveQuotes(pszEvalFile);
					i++;
					break;
				case 'I':	// set ices
				case 'i':
					if (argc == i + 1)
					{
						_tprintf(TEXT(">>ERROR: ICES not specified\n"));
						return 0;
					}
					pszICEs = argv[i + 1];
					RemoveQuotes(pszICEs);
					i++;
					break;
				case 'L':	// log file
				case 'l':
					if (argc == i + 1)
					{
						_tprintf(TEXT(">>ERROR: Log file not specified\n"));
						return 0;
					}
					pszLogFile = argv[i + 1];
					RemoveQuotes(pszLogFile);
					i++;
					break;
				case '?':		// help 
					Usage();
					return 0;		// bail program
				case 'T':		// test for the existance of the COM Object
				case 't':
					W32::CoInitialize(NULL);

					IEval* pIDiscard;
					hResult = W32::CoCreateInstance(CLSID_EvalCom, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
																		 IID_IEval, (void**)&pIDiscard);
					W32::CoUninitialize();

					if (FAILED(hResult))
					{
						_tprintf(_T("Evaluation server is NOT registered.\n"));
//						ERRMSG(hResult);
					}
					else
						_tprintf(_T("Evaluation server is registered and ready to rock.\n   Bring on the ICE!!!\n"));

					return hResult;
				case 'Z':
				case 'z':
					break;
				case 'F':
				case 'f':
					g_fInfo = FALSE; // suppress info messages
					break;
				default:
					_tprintf(_T("Unknown parameter: %c\n\n"), chCommand);
					Usage();
					
					return -1;
			}
		}
	}

	BOOL bGood = TRUE;		// assume everything's good

	// if database was not defined
	if (!pszDatabase)
	{
		_tprintf(_T(">> Error: MSI Database not specified.\n"));
		bGood = FALSE;
	}

	// if we are doing files and sourceDir was not defined
	if (!pszEvalFile)
	{
		_tprintf(_T(">> Error: Did not specify evaluation file.\n"));
		bGood = FALSE;
	}

	// if we're not good anymore bail
	if (!bGood)
	{
		_tprintf(_T(">>> Fatal Error: Cannot recover from previous errors.\n"));
		_tprintf(_T("\nUse -? for more information.\n"));
		return -1;
	}

	// check the msival2 COM Server real quick before using it
	if (!CheckFeature(_T("EvalComServer")))
	{
		_tprintf(_T(">>> Fatal Error:  Failed to locate msival2 Evaluation COM Server.\n"));
		return -666;
	}

	W32::CoInitialize(NULL);

	// create a msival2 COM object
	IEval* pIEval;
	hResult = W32::CoCreateInstance(CLSID_EvalCom, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
											  IID_IEval, (void**)&pIEval);

	// if failed to create the object
	if (FAILED(hResult))
	{
		_tprintf(_T(">>> Fatal Error: Failed to instantiate EvalCom Object.\n\n"));
		return -1;
	}

	// if we are logging
	if (pszLogFile)
	{
		// open the file or create it if it doesn't exist
		hLogFile = W32::CreateFile(pszLogFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		
		// if the file is open
		if (INVALID_HANDLE_VALUE != hLogFile)
		{
			// move the pointer to the end of file
			W32::SetFilePointer(hLogFile, 0, 0, FILE_END);
		}
		else
		{
			_tprintf(_T(">> Error: Failed to open log file: %s\r\n"), pszLogFile);
			CleanUp(pIEval);
			return -2;
		}
	}

	// open the database and the evaluations
	HRESULT hResOpen;

#ifdef UNICODE
	hResult = pIEval->OpenDatabase(pszDatabase);
	hResOpen = pIEval->OpenEvaluations(pszEvalFile);
#else
	OLECHAR *szwDatabase = NULL;
	OLECHAR *szwEvalFile = NULL;
	AnsiToWide(pszDatabase, szwDatabase);
	hResult = pIEval->OpenDatabase(szwDatabase);
	AnsiToWide(pszEvalFile, szwEvalFile);
	hResOpen = pIEval->OpenEvaluations(szwEvalFile);
#endif // UNICODE

	// check results
	if (FAILED(hResult))
	{
		_tprintf(_T(">>> Fatal Error: Failed to open database: %s\r\n"), pszDatabase);
		CleanUp(pIEval);
		return -2;
	}

	if (FAILED(hResOpen))
	{
		_tprintf(_T(">>> Fatal Error: Failed to open evaulation file: %s\r\n"), pszEvalFile);
		CleanUp(pIEval);
		return -2;
	}
	else
	{
		// set UI handler
		pIEval->SetDisplay(DisplayFunction, &hLogFile);
		
		// now do the evaluations
		_tprintf(g_szFormatter, _T(" ICE"), _T(" Type"), _T("  Description"));

#ifdef UNICODE
		hResult = pIEval->Evaluate(pszICEs);
#else
		OLECHAR* szwICEs = NULL;
		AnsiToWide(pszICEs, szwICEs);
		hResult = pIEval->Evaluate(szwICEs);
#endif // UNICODE

		pIEval->CloseDatabase();
		pIEval->CloseEvaluations();

		if(FAILED(hResult))
		{
			_tprintf(_T("\n>> Error: Failed to run all of the evaluations.\r\n"));
			CleanUp(pIEval);
			return -2;
		}

		// cleanup
#ifndef UNICODE
		if (szwICEs)
			delete [] szwICEs;
#endif // !UNICODE
	}
	
	// see if there were any validation errors
	IEnumEvalResult* pIEnumEvalResults;
	ULONG pcResults;
	hResult = pIEval->GetResults(&pIEnumEvalResults, &pcResults);
	if (FAILED(hResult))
	{
		_tprintf(_T("\n>> Error: Failed to obtain enumerator.\r\n"));
		if (pIEnumEvalResults)
			pIEnumEvalResults->Release();
		CleanUp(pIEval);
		return -2;
	}

	// count errors
	int cErrors = 0;
	RESULTTYPES tResult;			// type of result
	ULONG cFetched;
	IEvalResult* pIResult;
	for (ULONG j = 0; j < pcResults; j++)
	{
		// get the next result
		pIEnumEvalResults->Next(1, &pIResult, &cFetched);

		if (cFetched != 1)
		{
			_tprintf(_T("\n>> Error: Failed to fetch error.\r\n"));
			if (pIEnumEvalResults)
				pIEnumEvalResults->Release();
			CleanUp(pIEval);
			return -2;
		}

		// if this is an error message or warning message
		pIResult->GetResultType((UINT*)&tResult);
		if (ieError == tResult)
		{
			cErrors++;
		}
	}

	// release enumerator
	if (pIEnumEvalResults)
		pIEnumEvalResults->Release();

	// release the object
	if (pIEval)
		pIEval->Release();

	// cleanup
#ifndef UNICODE
	if (szwDatabase)
		delete [] szwDatabase;
	if (szwEvalFile)
		delete [] szwEvalFile;
#endif // !UNICODE

	W32::CoUninitialize();	// uninitialize COM

	
	// for build process possibility, return 0 for success, -1 for failure
	if (cErrors)
		return -1;

	return 0;
}	// end of main



#else // RC_INVOKED, end of source code, start of resources
// resource definition go here
STRINGTABLE DISCARDABLE
{
 IDS_UnknownTable,       "Table name not found"
}

#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msival2\sources.inc ===
TARGETNAME=Msival2
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\msi.lib 

C_DEFINES=$(C_DEFINES) -D_EXE
USE_LIBCMT=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msival2.cpp \
	..\msival2.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msizap\msizap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       msizap.h
//
//--------------------------------------------------------------------------

#ifndef _MSIZAP_H_
#define _MSIZAP_H_

#include <aclapi.h>


//==============================================================================================
// CRegHandle class declaration -- smart class for managing registry key handles (HKEYs)

class CRegHandle
{
public:
    CRegHandle();
    CRegHandle(HKEY h);
    ~CRegHandle();
    void operator =(HKEY h);
    operator HKEY() const;
    HKEY* operator &();
    operator bool() { return m_h==0 ? false : true; }
//   HKEY* operator &() { return &m_h;}
//   operator &() { return m_h;}

private:
    HKEY m_h;
};

//!! eugend: I've copied this over from Darwin's COMMON.H.  It had
//           been around for ever so I don't expect it to have any
//           bugs.
//____________________________________________________________________________
//
// CTempBuffer<class T, int C>   // T is array type, C is element count
//
// Temporary buffer object for variable size stack buffer allocations
// Template arguments are the type and the stack array size.
// The size may be reset at construction or later to any other size.
// If the size is larger that the stack allocation, new will be called.
// When the object goes out of scope or if its size is changed,
// any memory allocated by new will be freed.
// Function arguments may be typed as CTempBufferRef<class T>&
//  to avoid knowledge of the allocated size of the buffer object.
// CTempBuffer<T,C> will be implicitly converted when passed to such a function.
//____________________________________________________________________________

template <class T> class CTempBufferRef;  // for passing CTempBuffer as unsized ref

template <class T, int C> class CTempBuffer
{
 public:
        CTempBuffer() {m_cT = C; m_pT = m_rgT;}
        CTempBuffer(int cT) {m_pT = (m_cT = cT) > C ? new T[cT] : m_rgT;}
        ~CTempBuffer() {if (m_cT > C) delete m_pT;}
        operator T*()  {return  m_pT;}  // returns pointer
        operator T&()  {return *m_pT;}  // returns reference
        int  GetSize() {return  m_cT;}  // returns last requested size
        void SetSize(int cT) {if (m_cT > C) delete[] m_pT; m_pT = (m_cT=cT) > C ? new T[cT] : m_rgT;}
        void Resize(int cT) {
                T* pT = cT > C ? new T[cT] : m_rgT;
                if ( ! pT ) cT = 0;
                if(m_pT != pT)
                        for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
                if(m_pT != m_rgT) delete[] m_pT; m_pT = pT; m_cT = cT;
        }
        operator CTempBufferRef<T>&() {m_cC = C; return *(CTempBufferRef<T>*)this;}
        T& operator [](int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
        T& operator [](unsigned int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#ifdef _WIN64           //--merced: additional operators for int64
        T& operator [](INT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
        T& operator [](UINT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#endif
 protected:
        void* operator new(size_t) {return 0;} // restrict use to temporary objects
        T*  m_pT;     // current buffer pointer
        int m_cT;     // reqested buffer size, allocated if > C
        int m_cC;     // size of local buffer, set only by conversion to CTempBufferRef
        T   m_rgT[C]; // local buffer, must be final member data
};

template <class T> class CTempBufferRef : public CTempBuffer<T,1>
{
 public:
        void SetSize(int cT) {if (m_cT > m_cC) delete[] m_pT; m_pT = (m_cT=cT) > m_cC ? new T[cT] : m_rgT;}
        void Resize(int cT) {
                T* pT = cT > m_cC ? new T[cT] : m_rgT;
                if ( ! pT ) cT = 0;
                if(m_pT != pT)
                        for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
                if(m_pT != m_rgT) delete[] m_pT; m_pT = pT; m_cT = cT;
        }
 private:
        CTempBufferRef(); // cannot be constructed
        ~CTempBufferRef(); // ensure use as a reference
};


//==============================================================================================
// Constants

const int cbMaxSID  = sizeof(SID) + SID_MAX_SUB_AUTHORITIES*sizeof(DWORD);
const int cchMaxSID = 256;
const int cchGUID   = 39;

const int iRemoveAllFoldersButUserProfile = 1 << 0;
const int iRemoveAllRegKeys               = 1 << 1;
const int iRemoveInProgressRegKey         = 1 << 2;
const int iOnlyRemoveACLs                 = 1 << 3;
const int iAdjustSharedDLLCounts          = 1 << 4;
const int iForceYes                       = 1 << 5;
const int iStopService                    = 1 << 6;
const int iRemoveUserProfileFolder        = 1 << 7;
const int iRemoveWinMsiFolder             = 1 << 8;
const int iRemoveConfigMsiFolder          = 1 << 9;
const int iRemoveUninstallKey             = 1 << 10;
const int iRemoveProduct                  = 1 << 11;
const int iRemoveRollbackKey              = 1 << 13; 
const int iOrphanProduct                  = 1 << 14; // removes Installer info about product but leaves other info (like sharedDLL counts)
const int iForAllUsers                    = 1 << 15;
const int iRemoveGarbageFiles             = 1 << 16;
const int iRemoveRollback                 = iRemoveRollbackKey | iRemoveConfigMsiFolder;
const int iRemoveAllFolders               = iRemoveWinMsiFolder | iRemoveUserProfileFolder | iRemoveConfigMsiFolder;
const int iRemoveAllNonStateData          = iRemoveAllFolders | iRemoveAllRegKeys | iAdjustSharedDLLCounts | iStopService;

#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

/*
#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_GROUPS )                            \
    + 10*(sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES)
*/
#define MAX_SID_STRING 256

const TCHAR* szAllProductsArg = TEXT("ALLPRODUCTS");

//==============================================================================================
// Functions -- SID manipulation
DWORD GetAdminSid(char** pSid);
void GetStringSID(PISID pSID, TCHAR* szSID);
DWORD GetUserSID(HANDLE hToken, char* rgSID);
DWORD GetCurrentUserSID(char* rgchSID);
inline TCHAR* GetCurrentUserStringSID(DWORD* dwReturn);
const TCHAR szLocalSystemSID[] = TEXT("S-1-5-18");

//==============================================================================================
// Functions -- Token manipulation
DWORD OpenUserToken(HANDLE &hToken, bool* pfThreadToken=0);
DWORD GetCurrentUserToken(HANDLE &hToken);
bool GetUsersToken(HANDLE &hToken);
bool AcquireTokenPrivilege(const TCHAR* szPrivilege);

//==============================================================================================
// Functions -- Security manipulation
DWORD AddAdminFullControl(HANDLE hObject, SE_OBJECT_TYPE ObjectType);
DWORD AddAdminOwnership(HANDLE hObject, SE_OBJECT_TYPE ObjectType);
DWORD AddAdminFullControlToRegKey(HKEY hKey);
DWORD GetAdminFullControlSecurityDescriptor(char** pSecurityDescriptor);
DWORD TakeOwnershipOfFile(const TCHAR* szFile, bool fFolder);
DWORD MakeAdminRegKeyOwner(HKEY hKey, TCHAR* szSubKey);


//==============================================================================================
// Functions -- Miscellaneous
bool StopService();
BOOL IsGUID(const TCHAR* sz);
void GetSQUID(const TCHAR* szProduct, TCHAR* szProductSQUID);
bool IsProductInstalledByOthers(const TCHAR* szProductSQUID);
void DisplayHelp(bool fVerbose);
void SetPlatformFlags(void);
bool ReadInUsers();
bool DoTheJob(int iTodo, const TCHAR* szProduct);
bool IsAdmin();

//==============================================================================================
// Functions -- Zap

enum ieClearingWhat
{
	iePublishedComponents,
	ieDotNetAssemblies,
	ieWin32Assemblies,
};

struct stClearingWhat
{
	const TCHAR* szRegSubkey;
	const TCHAR* szDisplayWhat;
	const TCHAR* szDisplayValue;
} rgToClear[] = {TEXT("Components"),      TEXT("published component"), TEXT("published components qualifier"),
					  TEXT("Assemblies"),      TEXT(".Net assembly"),       TEXT(".Net assembly"),
					  TEXT("Win32Assemblies"), TEXT("Win32 assembly"),      TEXT("Win32 assembly")};

const TCHAR g_szHKLM[] = TEXT("HKLM");
const TCHAR g_szHKCU[] = TEXT("HKCU");

bool RemoveFile(TCHAR* szFilePath, bool fJustRemoveACLs);
BOOL DeleteFolder(TCHAR* szFolder, bool fJustRemoveACLs);
BOOL DeleteTree(HKEY hKey, TCHAR* szSubKey, bool fJustRemoveACLs);
bool ClearWindowsUninstallKey(bool fJustRemoveACLs, const TCHAR* szProduct);
bool ClearUninstallKey(bool fJustRemoveACLs, const TCHAR* szProduct=0);
bool ClearSharedDLLCounts(TCHAR* szComponentsSubkey, const TCHAR* szProduct=0);
bool ClearProductClientInfo(TCHAR* szComponentsSubkey, const TCHAR *szProduct, bool fJustRemoveACLs);
bool ClearFolders(int iTodo, const TCHAR* szProduct, bool fOrphan);
bool ClearPublishComponents(HKEY hKey, const TCHAR* szRoot, const TCHAR* szSubKey, const TCHAR* szProduct, const stClearingWhat&);
bool ClearRollbackKey(bool fJustRemoveACLs);
bool ClearInProgressKey(bool fJustRemoveACLs);
bool ClearRegistry(bool fJustRemoveACLs);
bool RemoveCachedPackage(const TCHAR* szProduct, bool fJustRemoveACLs);
bool ClearPatchReferences(HKEY hRoot, HKEY hProdPatchKey, TCHAR* szPatchKey, TCHAR* szProductsKey, TCHAR* szProductSQUID);
bool ClearUpgradeProductReference(HKEY HRoot, const TCHAR* szSubKey, const TCHAR* szProductSQUID);
bool ClearProduct(int iTodo, const TCHAR* szProduct, bool fJustRemoveACLs, bool fOrphan);



#endif _MSIZAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msizap\sources.inc ===
TARGETNAME=MsiZap
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

USE_LIBCMT=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\shell32.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\msi.lib

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(INC_DIR);$(RES_OBJDIR);$(ADMIN_INC_PATH)

SOURCES=..\msizap.cpp \
	..\msizap.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\msizap\msizap.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File:       msizap.cpp
//
//--------------------------------------------------------------------------

// Required headers
#include <windows.h>
#include "msiquery.h"
#include "msip.h"
#include "msizap.h"
#include <aclapi.h>
#include <stdio.h>
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include <shlobj.h>
#include <strsafe.h>

//!! Fix warnings and remove pragma
#pragma warning(disable : 4018) // signed/unsigned mismatch

//==============================================================================================
// Globals

bool g_fWin9X = false;
bool g_fWinNT64 = false;
DWORD g_iMajorVersion = 0;
TCHAR** g_rgpszAllUsers = NULL;
int g_iUserIndex = -1;
bool g_fDataFound = false;

//==============================================================================================
// CRegHandle class implementation -- smart class for managing registry key handles (HKEYs)

inline CRegHandle::CRegHandle() : m_h(0)
{
}

inline CRegHandle::CRegHandle(HKEY h) : m_h(h)
{
}

inline void CRegHandle::operator =(HKEY h) 
{ 
    if(m_h != 0) 
        RegCloseKey(m_h); 
    m_h = h; 
}

inline CRegHandle::operator HKEY() const 
{ 
    return m_h; 
}

inline HKEY* CRegHandle::operator &() 
{ 
    if (m_h != 0) 
    {
        RegCloseKey(m_h); 
        m_h = 0;
    }
    return &m_h; 
}

inline CRegHandle::~CRegHandle()
{
    if(m_h != 0) 
    {
        RegCloseKey(m_h); 
        m_h = 0;
    }

}

inline DWORD RegOpen64bitKey(IN HKEY hKey,
                             IN LPCTSTR lpSubKey,
                             IN DWORD ulOptions,
                             IN REGSAM samDesired,
                             OUT PHKEY phkResult)
{
#ifndef _WIN64
    if ( g_fWinNT64 &&
         (samDesired & KEY_WOW64_64KEY) != KEY_WOW64_64KEY )
        samDesired |= KEY_WOW64_64KEY;
#endif
    return RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);
}


DWORD RegDelete64bitKey(IN HKEY hKey,
                               IN LPCTSTR lpSubKey)
{
#ifndef _WIN64
    if ( g_fWinNT64 )
    {
        // 32-bit RegDeleteKey does not handle deletion of 64-bit redirected
        // registry keys so we need to call NtDeleteKey
        
        CRegHandle hTemp;
        DWORD dwRes = RegOpen64bitKey(hKey, lpSubKey, 0,
                                      KEY_ALL_ACCESS, &hTemp);
        if ( dwRes == ERROR_SUCCESS )
        {
            HMODULE hModule = LoadLibrary(TEXT("ntdll.dll"));
            if( hModule != NULL )
            {
                typedef LONG(NTAPI *pNtDeleteKey)(IN HANDLE KeyHandle);
                typedef ULONG(NTAPI *pRtlNtStatusToDosError)(IN LONG Status);
                pNtDeleteKey pDel = NULL;
                pRtlNtStatusToDosError pConv = NULL;
                pDel = (pNtDeleteKey)GetProcAddress(hModule, "NtDeleteKey");
                if ( pDel )
                    pConv = (pRtlNtStatusToDosError)GetProcAddress(hModule, "RtlNtStatusToDosError");
                if ( pDel && pConv )
                    dwRes = pConv(pDel(hTemp));
                else
                    dwRes = GetLastError();
                FreeLibrary(hModule);
            }
            else
                dwRes = GetLastError();
        }
        return dwRes;
    }
#endif
    return RegDeleteKey(hKey, lpSubKey);
}

enum ieFolder
{
    iefSystem = 0,
    iefFirst = iefSystem,
    iefPrograms = 1,
    iefCommon = 2,
    iefLast = iefCommon,
};

enum ieBitness
{
    ieb32bit = 0,
    iebFirst = ieb32bit,
    ieb64bit = 1,
    iebLast = ieb64bit,
};

// the array below is initialized with the special 64-bit NT folders in this outlay:
//
// 32-bit folders:                      corresponding 64-bit folder:
//
// C:\Windows\Syswow64                  C:\Windows\System32
// C:\Program Files (x86)               C:\Program Files
// C:\Program Files (x86)\CommonFiles   C:\Program Files\CommonFiles
//
TCHAR g_rgchSpecialFolders[iefLast+1][iebLast+1][MAX_PATH];

void LoadSpecialFolders(int iTodo)
{
    CRegHandle hKey = 0;
    
    for (int i = iefFirst; i <= iefLast; i++)
        for (int j = iebFirst; j <= iebLast; j++)
            *g_rgchSpecialFolders[i][j] = NULL;

    if ( g_fWinNT64 )
    {
        TCHAR rgchBuffer[(MAX_PATH+5)*iebLast];
        TCHAR rgchPath[MAX_PATH+1];

#ifdef _WIN64
        // this is the recommended method of retrieving these folders,
        // only that it does not work properly in 32-bit processes
        // running on WIN64
        HMODULE hModule = LoadLibrary(TEXT("shell32.dll"));
        if( hModule == NULL )
        {
            StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR), 
                     TEXT("MsiZap warning: failed to load Shell32.dll. ")
                     TEXT("GetLastError returned %d\n"),
                     GetLastError());
            OutputDebugString(rgchBuffer);
            goto OneMoreTry;
        }

        typedef HRESULT(WINAPI *pSHGetFolderPathW)(HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);
        pSHGetFolderPathW pFunc = (pSHGetFolderPathW)GetProcAddress(hModule, "SHGetFolderPathW");
        if( pFunc == NULL )
        {
            StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR),
                     TEXT("MsiZap warning: failed to get pointer to SHGetFolderPathW. ")
                     TEXT("GetLastError returned %d\n"),
                     GetLastError());
            OutputDebugString(rgchBuffer);
            FreeLibrary(hModule);
            goto OneMoreTry;
        }

        // Initialize the special folder paths.
        int SpecialFoldersCSIDL[][iebLast+1] = 
            {{CSIDL_SYSTEMX86, CSIDL_SYSTEM},
             {CSIDL_PROGRAM_FILESX86, CSIDL_PROGRAM_FILES},
             {CSIDL_PROGRAM_FILES_COMMONX86, CSIDL_PROGRAM_FILES_COMMON}};
        int cErrors = 0;
        for(i = iefFirst; i <= iefLast; i++)
        {
            for(int j = iebFirst; j <= iebLast; j++)
            {
                HRESULT hRes = pFunc(NULL,
                                     SpecialFoldersCSIDL[i][j],
                                     NULL,
                                     SHGFP_TYPE_DEFAULT,
                                     g_rgchSpecialFolders[i][j]);
                if( hRes != S_OK )
                {
                    StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR),
                             TEXT("MsiZap warning: failed to get special folder path ")
                             TEXT("for CSIDL = %d. GetLastError returned %d\n"),
                             GetLastError());
                    OutputDebugString(rgchBuffer);
                    cErrors++;
                }
            }
        }
        FreeLibrary(hModule);
        if ( cErrors == sizeof(SpecialFoldersCSIDL)/sizeof(SpecialFoldersCSIDL[0]) )
            // no special folder could be retrieved
            goto OneMoreTry;
        else
            goto End;
#else // _WIN64
        goto OneMoreTry; // keeps the 32-bit compilation happy
#endif // _WIN64
        
OneMoreTry:        
        if ( !GetSystemDirectory(rgchPath, sizeof(rgchPath)/sizeof(TCHAR)) )
        {
            StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR),
                     TEXT("MsiZap warning: GetSystemDirectory call failed. GetLastError returned %d.\n"),
                     GetLastError());
            OutputDebugString(rgchBuffer);
        }
        else
        {
            _tcscpy(g_rgchSpecialFolders[iefSystem][ieb64bit], rgchPath); // 'strcpy'
            TCHAR* pszSep = _tcsrchr(rgchPath, TEXT('\\')); // 'strrchr'
            if ( !pszSep || !_tcsclen(pszSep) ) // 'strlen'
            {
                StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR),
                         TEXT("MsiZap warning: \'%s\' is a strange 64-bit system directory. ")
                         TEXT("We'll not attempt to figure out its 32-bit counterpart.\n"),
                         rgchPath);
                OutputDebugString(rgchBuffer);
            }
            else
            {
                _tcscpy(pszSep, TEXT("\\syswow64")); // 'strcpy'
                _tcscpy(g_rgchSpecialFolders[iefSystem][ieb32bit], rgchPath); // 'strcpy'
            }
        }

        const TCHAR rgchSubKey[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion");
        LONG lResult = RegOpen64bitKey(HKEY_LOCAL_MACHINE,
                                       rgchSubKey, 0, KEY_READ, &hKey);
        if ( lResult != ERROR_SUCCESS )
        {
            StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR),
                     TEXT("MsiZap warning: RegOpenKeyEx failed returning %d ")
                     TEXT("while retrieving special folders.  GetLastError ")
                     TEXT("returns %d.\n"), lResult, GetLastError());
            OutputDebugString(rgchBuffer);
            goto End;
        }

        struct
        {
           const TCHAR*  szRegistryName;
           const TCHAR*  szFolderName;
        } rgData64[][2] = {{{TEXT("ProgramFilesDir (x86)"), TEXT("Program Files (x86)")},
                            {TEXT("ProgramFilesDir"),       TEXT("Program Files")      }},
                           {{TEXT("CommonFilesDir (x86)"),  TEXT("Common Files (x86)") },
                            {TEXT("CommonFilesDir"),        TEXT("Common Files")       }}};
        for (int i = 0, ii = iefPrograms; i < 2; i++, ii++)
        {
            for (int j = 0, jj = ieb32bit; j < 2; j++, jj++)
            {
                DWORD cbValue = sizeof(rgchPath);
                lResult = RegQueryValueEx(hKey, rgData64[i][j].szRegistryName,
                                          0, 0, (BYTE*)rgchPath, &cbValue);
                if ( lResult != ERROR_SUCCESS )
                {
                    StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR),
                             TEXT("MsiZap warning: RegQueryValueEx failed returning %d ")
                             TEXT("while retrieving \'%s\' folder.  GetLastError ")
                             TEXT("returns %d.\n"), lResult,
                             rgData64[i][j].szFolderName, GetLastError());
                    OutputDebugString(rgchBuffer);
                    continue;
                }

                _tcscpy(g_rgchSpecialFolders[ii][jj], rgchPath); // 'strcpy'
            }
        }
End:
#ifdef DEBUG
        OutputDebugString(TEXT("MsiZap info: special folders table's content:\n"));
        int iLen = 0;
        for (int i = iefFirst; i <= iefLast; i++, iLen = 0)
        {
            for (int j = iebFirst; j <= iebLast; j++)
            {
                StringCchPrintf(rgchBuffer+iLen, (sizeof(rgchBuffer)/sizeof(TCHAR))-iLen,
                                        TEXT("   \'%s\'"),
                                        g_rgchSpecialFolders[i][j]);
				size_t iThisLen = 0;
                StringCchLength(rgchBuffer+iLen, (sizeof(rgchBuffer)/sizeof(TCHAR))-iLen, &iThisLen);
                iLen += iThisLen;
            }
            StringCchPrintf(rgchBuffer+iLen, (sizeof(rgchBuffer)/sizeof(TCHAR))-iLen, TEXT("\n"));
            OutputDebugString(rgchBuffer);
        }
#else
        int iDummyStatement = 1;
#endif // DEBUG
    } // if ( g_fWinNT64 )
}

enum ieFolderType
{
    ieftNotSpecial = 0,
    ieft32bit,
    ieft64bit,
};

ieFolderType IsInSpecialFolder(LPTSTR rgchFolder, int* piIndex = 0)
{
    if ( !g_fWinNT64 )
        return ieftNotSpecial;

    for (int i = iebFirst; i <= iebLast; i++)
    {
        for (int j = iefFirst; j <= iefLast; j++)
        {
            if ( !*g_rgchSpecialFolders[i][j] )
                continue;
            int iSpFolderLen = _tcsclen(g_rgchSpecialFolders[i][j]); // a sophisticated 'strlen'
            if ( !_tcsncicmp(rgchFolder, g_rgchSpecialFolders[i][j], iSpFolderLen) &&
                 (!rgchFolder[iSpFolderLen] || rgchFolder[iSpFolderLen] == TEXT('\\')) )
            {
                // OK, we have a match
                if ( piIndex )
                    *piIndex = j;
                return i == ieb32bit ? ieft32bit : ieft64bit;
            }

        }
    }

    return ieftNotSpecial;
}

enum ieSwapType
{
    iest32to64 = 0,
    iest64to32,
};

void SwapSpecialFolder(LPTSTR rgchFolder, ieSwapType iHowTo)
{
    int iIndex = -1;

    ieFolderType iType = IsInSpecialFolder(rgchFolder, &iIndex);
    if ( iType == ieftNotSpecial )
        return;

    if ( iIndex < iefFirst || iIndex > iefLast )
    {
        OutputDebugString(TEXT("MsiZap warning: did not swap special folder due to invalid index.\n"));
        return;
    }
    if ( (iHowTo == iest32to64 && iType == ieft64bit) ||
         (iHowTo == iest64to32 && iType == ieft32bit) )
    {
        OutputDebugString(TEXT("MsiZap warning: did not swap special folder due to mismatching types.\n"));
        return;
    }
    TCHAR rgchBuffer[MAX_PATH+1];
    int iSwapFrom = iHowTo == iest32to64 ? ieb32bit : ieb64bit;
    int iSwapTo = iSwapFrom == ieb32bit ? ieb64bit : ieb32bit;
    if ( !*g_rgchSpecialFolders[iIndex][iSwapTo] )
    {
        StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR),
                 TEXT("MsiZap warning: did not swap \'%s\' folder because of uninitialized replacement.\n"),
                 rgchFolder);
        OutputDebugString(rgchBuffer);
        return;
    }
    int iSwappedLength = _tcsclen(g_rgchSpecialFolders[iIndex][iSwapFrom]); // 'strlen'
    _tcscpy(rgchBuffer, g_rgchSpecialFolders[iIndex][iSwapTo]); // 'strcpy'
    if ( rgchFolder[iSwappedLength] )
        _tcscat(rgchBuffer, &rgchFolder[iSwappedLength]); // 'strcat'
    _tcscpy(rgchFolder, rgchBuffer); // 'strcpy'
}

//  functions called from ClearGarbageFiles

#define DYNAMIC_ARRAY_SIZE      10

bool IsStringInArray(LPCTSTR szString,
                CTempBufferRef<TCHAR*>& rgStrings,
                UINT* piIndex = 0)
{
    if ( !szString || !*szString )
        // empty strings are out of discussion
        return false;

    for (UINT i = 0; i < rgStrings.GetSize(); i++)
        if ( rgStrings[i] && !_tcsicmp(rgStrings[i], szString) ) // '_stricmp'
        {
            if ( piIndex )
                *piIndex = i;
            // szString is in array
            return true;
        }
    return false;
}

bool LearnNewString(LPCTSTR szString,
               CTempBufferRef<TCHAR*>& rgNewStrings, UINT& cNewStrings,
               bool fCheckExistence = false)
{
    if ( !szString || !*szString )
        // empty strings are out of discussion
        return true;

    if ( fCheckExistence && IsStringInArray(szString, rgNewStrings) )
    {
        // szString is already known
        return true;
    }

    // OK, we have a new string that we'll 'memorize'
    if ( rgNewStrings.GetSize() == cNewStrings )
    {
        // rgNewStrings is max-ed.
        rgNewStrings.Resize(cNewStrings+DYNAMIC_ARRAY_SIZE);
        if ( !rgNewStrings.GetSize() )
            // there was a problem allocating memory
            return false;
        for (UINT i = cNewStrings; i < rgNewStrings.GetSize(); i++)
            rgNewStrings[i] = NULL;
    }

    TCHAR* pszDup = _tcsdup(szString); // '_strdup'
    if ( !pszDup )
        // there was a problem allocating memory
        return false;

    rgNewStrings[cNewStrings++] = pszDup;
    return true;
}

bool LearnPathAndExtension(LPCTSTR szPath,
               CTempBufferRef<TCHAR*>& rgPaths, UINT& cPaths,
               CTempBufferRef<TCHAR*>& rgExts, UINT& cExts)
{
    TCHAR* pszDot = _tcsrchr(szPath, TEXT('.')); // 'strrchr'
    if ( pszDot )
    {
        if ( !LearnNewString(pszDot, rgExts, cExts, true) )
            return false;
    }

    // since we're dealing with paths in the FS there's no need here to
    // make sure here that they're unique.
    return LearnNewString(szPath, rgPaths, cPaths);
}

// ClearGarbageFiles goes through the folders where Windows Installer caches
// data files and removes the ones that are not referenced in the registry

bool ClearGarbageFiles(void)
{
    // this ensures this function runs only once
    static bool fAlreadyRun = false;
    static bool fError = false;
    if ( fAlreadyRun )
        return !fError;
    else
        fAlreadyRun = true;

    _tprintf(TEXT("Removing orphaned cached files.\n"));

    // 0. Declare and initialize arrays where we store info we learn

    // dynamic list of folders where we look for cached files
    CTempBuffer<TCHAR*, DYNAMIC_ARRAY_SIZE> rgpszFolders;
    UINT cFolders = 0;
    for (int i = 0; i < rgpszFolders.GetSize(); i++)
        rgpszFolders[i] = NULL;
    
    // dynamic array of cached files that are referenced in the registry
    CTempBuffer<TCHAR*, DYNAMIC_ARRAY_SIZE> rgpszReferencedFiles;
    UINT cReferencedFiles = 0;
    for (i = 0; i < rgpszReferencedFiles.GetSize(); i++)
        rgpszReferencedFiles[i] = NULL;

    DWORD dwType;

    // dynamic array of file extensions
    CTempBuffer<TCHAR*, DYNAMIC_ARRAY_SIZE> rgpszExtensions;
    UINT cExtensions = 0;
    for (i = 0; i < rgpszExtensions.GetSize(); i++)
        rgpszExtensions[i] = NULL;
    const TCHAR* rgpszKnownExtensions[] = {TEXT(".msi"),
                                           TEXT(".mst"),
                                           TEXT(".msp")};
    for (i = 0; i < sizeof(rgpszKnownExtensions)/sizeof(rgpszKnownExtensions[0]); i++ )
    {
        if ( !LearnNewString(rgpszKnownExtensions[i], rgpszExtensions, cExtensions) )
            return !(fError = true);
    }

    TCHAR rgchMsiDirectory[MAX_PATH] = {0};
    if ( !GetWindowsDirectory(rgchMsiDirectory, MAX_PATH) )
    {
        _tprintf(TEXT("   Error retrieving Windows directory. GetLastError returned: %d.\n"),
                 GetLastError());
        fError = true;
    }
    else
    {
        int iLen = _tcsclen(rgchMsiDirectory); // 'strlen'
        if ( rgchMsiDirectory[iLen-1] != TEXT('\\') )
            _tcscat(rgchMsiDirectory, TEXT("\\")); // 'strcat'
        _tcscat(rgchMsiDirectory, TEXT("Installer"));
    }

    // 1. We read in the list of cached files the Windows Installer knows about

    // 1.1. We go first through the user-migrated keys
    bool fUserDataFound = false;
    CRegHandle hKey;
    long lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData"),
                          0, KEY_READ, &hKey);
    if ( lError == ERROR_SUCCESS )
    {
        TCHAR szUser[MAX_PATH];
        DWORD cchUser = sizeof(szUser)/sizeof(TCHAR);
        // 1.1.1. We enumerate users that have products installed
        for ( int iUserIndex = 0;
              (lError = RegEnumKeyEx(hKey, iUserIndex,
                                     szUser, &cchUser, 0, 0, 0, 0)) == ERROR_SUCCESS;
              iUserIndex++, cchUser = sizeof(szUser)/sizeof(TCHAR) )
        {
            TCHAR rgchBuffer[MAX_PATH];
            StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR), TEXT("%s\\Products"), szUser);
            CRegHandle hProductsKey;
            lError = RegOpen64bitKey(hKey, rgchBuffer,
                                     0, KEY_READ, &hProductsKey);
            if ( lError != ERROR_SUCCESS )
            {
                if ( lError != ERROR_FILE_NOT_FOUND )
                {
                    _tprintf(TEXT("   Error opening HKLM\\...\\Installer\\UserData\\%s\\Products key. Error: %d.\n"),
                             szUser, lError);
                    fError = true;
                    goto Patches; // ugly, but saves some indentations
                }
            }
            TCHAR szProduct[MAX_PATH];
            DWORD cchProduct = sizeof(szProduct)/sizeof(TCHAR);
            // 1.1.1.1. For each user we enumerate products and check if they'd
            //          been installed with Windows Installer.  If so, we
            //          'memorize' the path to the cached package & transforms
            for ( int iProdIndex = 0;
                  (lError = RegEnumKeyEx(hProductsKey, iProdIndex,
                                         szProduct, &cchProduct, 0, 0, 0, 0)) == ERROR_SUCCESS;
                  iProdIndex++, cchProduct = sizeof(szProduct)/sizeof(TCHAR) )
            {
                TCHAR szKey[MAX_PATH];
                StringCchPrintf(szKey, sizeof(szKey)/sizeof(TCHAR), TEXT("%s\\InstallProperties"),
                         szProduct);
                CRegHandle hUserProductKey;
                lError = RegOpen64bitKey(hProductsKey, szKey, 0,
                                         KEY_READ, &hUserProductKey);
                if ( lError != ERROR_SUCCESS )
                {
                    _tprintf(TEXT("   Error opening %s subkey of Products key for %s user. Error: %d.\n"),
                             szKey, szUser, lError);
                    fError = true;
                    continue;
                }

                DWORD dwValue;
                DWORD cb = sizeof(DWORD);
                lError = RegQueryValueEx(hUserProductKey,
                                         TEXT("WindowsInstaller"), 0,
                                         &dwType, (LPBYTE)&dwValue, &cb);
                if ( lError != ERROR_SUCCESS || (dwType == REG_DWORD && dwValue != 1) )
                    // this product had not been installed by Windows Installer
                    continue;
                else
                    fUserDataFound = true;

                TCHAR szPath[MAX_PATH] = {0};
                TCHAR* rgpszPackageTypes[] = {TEXT("LocalPackage"),
                                              TEXT("ManagedLocalPackage"),
                                              NULL};
                for (int i = 0; rgpszPackageTypes[i]; i++)
                {
                    cb = sizeof(szPath);
                    lError = RegQueryValueEx(hUserProductKey,
                                             rgpszPackageTypes[i], 0,
                                             &dwType, (LPBYTE)szPath, &cb);
                    if ( lError == ERROR_SUCCESS && dwType == REG_SZ )
                        break;
                }
                if ( *szPath )
                {
                    // OK, we have a path in hand: we 'memorize' it and try
                    // to learn new extensions
                    bool fLearn = LearnPathAndExtension(szPath,
                            rgpszReferencedFiles, cReferencedFiles,
                            rgpszExtensions, cExtensions);
                    if ( !fLearn )
                    {
                        fError = true;
                        goto Return;
                    }
                }
                if ( !g_fWin9X && *rgchMsiDirectory )
                {
                    // let's take a peek at cached secure transforms
                    StringCchPrintf(szKey, sizeof(szKey)/sizeof(TCHAR), TEXT("%s\\Transforms"), szProduct);
                    CRegHandle hTransforms;
                    lError = RegOpen64bitKey(hProductsKey, szKey, 0,
                                             KEY_READ, &hTransforms);
                    if ( lError != ERROR_SUCCESS )
                    {
                        if ( lError != ERROR_FILE_NOT_FOUND )
                        {
                            _tprintf(TEXT("   Error opening %s subkey of Products key for %s user. Error: %d.\n"),
                                     szKey, szUser, lError);
                            fError = true;
                        }
                        continue;
                    }
                    TCHAR rgchFullPath[MAX_PATH];
                    _tcscpy(rgchFullPath, rgchMsiDirectory);
                    int iLen = _tcsclen(rgchFullPath); // 'strlen'
                    if ( rgchFullPath[iLen-1] != TEXT('\\') )
                        _tcscat(rgchFullPath, TEXT("\\")); // 'strcat'
                    TCHAR* pszEnd = _tcsrchr(rgchFullPath, TEXT('\\'));
                    pszEnd++;

                    TCHAR rgchDummy[MAX_PATH];
                    DWORD dwDummy = sizeof(rgchDummy)/sizeof(TCHAR);
                    cb = sizeof(szPath);
                    for (i = 0;
                         (lError = RegEnumValue(hTransforms, i++, rgchDummy, &dwDummy,
                                    0, &dwType, (LPBYTE)szPath, &cb)) == ERROR_SUCCESS;
                         i++, cb = sizeof(szPath), dwDummy = sizeof(rgchDummy)/sizeof(TCHAR))
                    {
                        if ( *szPath && dwType == REG_SZ )
                        {
                            _tcscpy(pszEnd, szPath); // 'strcpy'
                            bool fLearn = LearnPathAndExtension(rgchFullPath,
                                                    rgpszReferencedFiles,
                                                    cReferencedFiles,
                                                    rgpszExtensions,
                                                    cExtensions);
                            if ( !fLearn )
                            {
                                fError = true;
                                goto Return;
                            }
                        }
                    }
                    if (ERROR_NO_MORE_ITEMS != lError)
                    {
                        _tprintf(TEXT("   Error enumerating %s key for %s user. Error: %d.\n"),
                                 szKey, szUser, lError);
                        fError = true;
                    }
                }
            }
            if (ERROR_NO_MORE_ITEMS != lError)
            {
                _tprintf(TEXT("   Error enumerating Products key for %s user. Error: %d.\n"),
                         szUser, lError);
                fError = true;
            }
Patches:
            // 1.1.1.2. For each user we enumerate patches and 'memorize'
            //          the paths to the cached packages.
            StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR), TEXT("%s\\Patches"), szUser);
            CRegHandle hPatchesKey;
            lError = RegOpen64bitKey(hKey, rgchBuffer,
                                     0, KEY_READ, &hPatchesKey);
            if ( lError != ERROR_SUCCESS )
            {
                if ( lError != ERROR_FILE_NOT_FOUND )
                {
                    _tprintf(TEXT("   Error opening HKLM\\...\\Installer\\UserData\\%s\\Patches key. Error: %d.\n"),
                             szUser, lError);
                    fError = true;
                }
                continue;
            }
            TCHAR szPatch[MAX_PATH];
            DWORD cchPatch = sizeof(szPatch)/sizeof(TCHAR);
            for ( int iPatchIndex = 0;
                  (lError = RegEnumKeyEx(hPatchesKey, iPatchIndex,
                                         szPatch, &cchPatch, 0, 0, 0, 0)) == ERROR_SUCCESS;
                  iPatchIndex++, cchPatch = sizeof(szPatch)/sizeof(TCHAR) )
            {
                CRegHandle hPatchKey;
                lError = RegOpen64bitKey(hPatchesKey, szPatch, 0,
                                         KEY_READ, &hPatchKey);
                if ( lError != ERROR_SUCCESS )
                {
                    _tprintf(TEXT("   Error opening %s subkey of HKLM\\...\\Installer\\UserData\\%s\\Patches key. Error: %d.\n"),
                             szPatch, szUser, lError);
                    fError = true;
                    continue;
                }
                fUserDataFound = true;
                DWORD cb = sizeof(rgchBuffer);
                *rgchBuffer = NULL;
                lError = RegQueryValueEx(hPatchKey,
                                         TEXT("LocalPackage"), 0,
                                         &dwType, (LPBYTE)rgchBuffer, &cb);
                if ( lError == ERROR_SUCCESS && dwType == REG_SZ && *rgchBuffer )
                {
                    if ( !LearnPathAndExtension(rgchBuffer,
                                                rgpszReferencedFiles,
                                                cReferencedFiles,
                                                rgpszExtensions,
                                                cExtensions) )
                    {
                        fError = true;
                        goto Return;
                    }
                }
            }
            if (ERROR_NO_MORE_ITEMS != lError)
            {
                _tprintf(TEXT("   Error enumerating Patches key for %s user. Error: %d.\n"),
                         szUser, lError);
                fError = true;
            }
        }
        if (ERROR_NO_MORE_ITEMS != lError)
        {
            _tprintf(TEXT("   Error enumerating user IDs. Error: %d.\n"), lError);
            fError = true;
        }
    }
    else if ( lError != ERROR_FILE_NOT_FOUND )
    {
        _tprintf(TEXT("   Error opening HKLM\\...\\Installer\\UserData key. Error: %d.\n"),
                 lError);
        fError = true;
    }

    // 1.2. we go through old, non-user-migrated configuration data.
    lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"),
                0, KEY_READ, &hKey);
    if ( lError == ERROR_SUCCESS )
    {
        TCHAR szProduct[MAX_PATH];
        DWORD cchProduct = sizeof(szProduct)/sizeof(TCHAR);
        // 1.2.1. We enumerate products and check if they'd
        //        been installed with Windows Installer
        for ( int iProdIndex = 0;
              (lError = RegEnumKeyEx(hKey, iProdIndex,
                                     szProduct, &cchProduct, 0, 0, 0, 0)) == ERROR_SUCCESS;
              iProdIndex++, cchProduct = sizeof(szProduct)/sizeof(TCHAR) )
        {
            CRegHandle hProductKey;
            lError = RegOpen64bitKey(hKey, szProduct, 0,
                                     KEY_READ, &hProductKey);
            if ( lError != ERROR_SUCCESS )
            {
                _tprintf(TEXT("   Error opening %s subkey of HKLM\\...\\CurrentVersion\\Uninstall key. Error: %d.\n"),
                         szProduct, lError);
                fError = true;
                continue;
            }

            DWORD dwValue;
            DWORD cb = sizeof(DWORD);
            lError = RegQueryValueEx(hProductKey,
                                     TEXT("WindowsInstaller"), 0,
                                     &dwType, (LPBYTE)&dwValue, &cb);
            if ( lError != ERROR_SUCCESS || (dwType == REG_DWORD && dwValue != 1) )
                // this product had not been installed by the Windows Installer
                continue;

            TCHAR szPath[MAX_PATH] = {0};
            TCHAR* rgpszPackageTypes[] = {TEXT("LocalPackage"),
                                          TEXT("ManagedLocalPackage"),
                                          NULL};
            for (int i = 0; rgpszPackageTypes[i]; i++)
            {
                cb = sizeof(szPath);
                lError = RegQueryValueEx(hProductKey,
                                         rgpszPackageTypes[i], 0,
                                         &dwType, (LPBYTE)szPath, &cb);
                if ( lError == ERROR_SUCCESS && dwType == REG_SZ )
                    break;
            }
            if ( !*szPath )
                continue;

            // OK, we have a path in hand: we 'memorize' it and try
            // to learn new extensions
            bool fLearn = LearnPathAndExtension(szPath,
                                rgpszReferencedFiles, cReferencedFiles,
                                rgpszExtensions, cExtensions);
            if ( !fLearn )
            {
                fError = true;
                goto Return;
            }
        }
        if (ERROR_NO_MORE_ITEMS != lError)
        {
            _tprintf(TEXT("   Error enumerating Products key under HKLM\\...\\Uninstall key. Error: %d.\n"),
                     lError);
            fError = true;
        }
    }
    else if ( lError != ERROR_FILE_NOT_FOUND )
    {
        _tprintf(TEXT("   Error opening HKLM\\...\\CurrentVersion\\Uninstall key. Error: %d.\n"),
                 lError);
        fError = true;
    }

    // 1.3. we go through some other old, pre-per-user-migrated configuration data.
    if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\LocalPackages"),
                            0, KEY_READ, &hKey)) == ERROR_SUCCESS)
    {
        TCHAR szProduct[MAX_PATH];
        DWORD cchProduct = sizeof(szProduct)/sizeof(TCHAR);
        // 1.3.1. We enumerate the products.
        for ( int iProdIndex = 0;
              (lError = RegEnumKeyEx(hKey, iProdIndex,
                                     szProduct, &cchProduct, 0, 0, 0, 0)) == ERROR_SUCCESS;
              iProdIndex++, cchProduct = sizeof(szProduct)/sizeof(TCHAR) )
        {
            CRegHandle hProductKey;
            lError = RegOpen64bitKey(hKey, szProduct, 0,
                                     KEY_READ, &hProductKey);
            if ( lError != ERROR_SUCCESS )
            {
                _tprintf(TEXT("   Error opening %s subkey of HKLM\\...\\Installer\\LocalPackages key. Error: %d.\n"),
                         szProduct, lError);
                fError = true;
                continue;
            }

            int iValueIndex = 0;
            TCHAR szPackage[MAX_PATH] = {0};
            DWORD cbPackage = sizeof(szPackage);
            TCHAR rgchDummy[MAX_PATH] = {0};
            DWORD dwDummy = sizeof(rgchDummy)/sizeof(TCHAR);

            // 1.3.1.1. we enumerate packages within product
            while (ERROR_SUCCESS == (lError = RegEnumValue(hProductKey,
                                                iValueIndex++,
                                                rgchDummy, &dwDummy,
                                                0, &dwType,
                                                (LPBYTE)szPackage, &cbPackage)))
            {
                // OK, we have a path in hand: we 'memorize' it and try
                // to learn new extensions
                bool fLearn = LearnPathAndExtension(szPackage,
                                    rgpszReferencedFiles, cReferencedFiles,
                                    rgpszExtensions, cExtensions);
                if ( !fLearn )
                {
                    fError = true;
                    goto Return;
                }
                dwDummy = sizeof(rgchDummy)/sizeof(TCHAR);
                cbPackage = sizeof(szPackage);
            }
            if (ERROR_NO_MORE_ITEMS != lError)
            {
                _tprintf(TEXT("   Error enumerating %s subkey of HKLM\\...\\Installer\\LocalPackages key. Error: %d.\n"),
                         szProduct, lError);
                fError = true;
            }
        }
        if (ERROR_NO_MORE_ITEMS != lError)
        {
            _tprintf(TEXT("   Error enumerating Products key under ")
                     TEXT("HKLM\\...\\Installer\\LocalPackages key. Error: %d.\n"),
                     lError);
            fError = true;
        }
    }
    else if ( lError != ERROR_FILE_NOT_FOUND )
    {
        _tprintf(TEXT("   Error opening HKLM\\...\\CurrentVersion\\Installer\\LocalPackages key. Error: %d.\n"),
                 lError);
        fError = true;
    }

    // 1.4. we go through some old registry location where info about patches
    //      used to be stored.
    lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Patches"),
                0, KEY_READ, &hKey);
    if ( lError == ERROR_SUCCESS )
    {
		TCHAR szPatch[cchGUID+1] = {0};
        DWORD cchPatch = sizeof(szPatch)/sizeof(TCHAR);
        // 1.4.1. We enumerate patches and look for LocalPackage value
        for ( int iPatchIndex = 0;
              (lError = RegEnumKeyEx(hKey, iPatchIndex,
                                     szPatch, &cchPatch, 0, 0, 0, 0)) == ERROR_SUCCESS;
              iPatchIndex++, cchPatch = sizeof(szPatch)/sizeof(TCHAR) )
        {
            CRegHandle hPatchKey;
            lError = RegOpen64bitKey(hKey, szPatch, 0,
                                     KEY_READ, &hPatchKey);
            if ( lError != ERROR_SUCCESS )
            {
                _tprintf(TEXT("   Error opening %s subkey of HKLM\\...\\Installer\\Patches key. Error: %d.\n"),
                         szPatch, lError);
                fError = true;
                continue;
            }
			TCHAR szPatchPackage[MAX_PATH] = {0};
            DWORD cbPatchPackage = sizeof(szPatchPackage);
            lError = RegQueryValueEx(hPatchKey,
                                     TEXT("LocalPackage"), 0,
                                     &dwType, (LPBYTE)szPatchPackage, &cbPatchPackage);
            if ( lError == ERROR_SUCCESS && dwType == REG_SZ && *szPatchPackage )
            {
                if ( !LearnPathAndExtension(szPatchPackage,
                                            rgpszReferencedFiles,
                                            cReferencedFiles,
                                            rgpszExtensions,
                                            cExtensions) )
                {
                    fError = true;
                    goto Return;
                }
            }
        }
        if (ERROR_NO_MORE_ITEMS != lError)
        {
            _tprintf(TEXT("   Error enumerating Patches under HKLM\\...\\Installer\\Patches key. Error: %d.\n"),
                     lError);
            fError = true;
        }
    }
    else if ( lError != ERROR_FILE_NOT_FOUND )
    {
        _tprintf(TEXT("   Error opening HKLM\\...\\CurrentVersion\\Installer\\Patches key. Error: %d.\n"),
                 lError);
        fError = true;
    }

    // 2. we figure out the folders where cached files reside
    
    // 2.1. we figure out folders we know we are/had been using
    TCHAR szFolder[2*MAX_PATH+1];
    if ( *rgchMsiDirectory )
    {
        if ( !LearnNewString(rgchMsiDirectory, rgpszFolders, cFolders, true) )
        {
            fError = true;
            goto Return;
        }
        _tcscpy(szFolder, rgchMsiDirectory);
        TCHAR* pszEnd = _tcsrchr(szFolder, TEXT('\\')); // 'strrchr'
        if ( pszEnd )
        {
            _tcscpy(pszEnd, TEXT("\\Msi")); // 'strcpy'
            if ( !LearnNewString(szFolder, rgpszFolders, cFolders, true) )
            {
                fError = true;
                goto Return;
            }
        }
    }
    if ( GetEnvironmentVariable(TEXT("USERPROFILE"), szFolder, sizeof(szFolder)/sizeof(TCHAR)) )
    {
        _tcscat(szFolder, TEXT("\\Msi")); // 'strcat'
        if ( !LearnNewString(szFolder, rgpszFolders, cFolders, true) )
        {
            fError = true;
            goto Return;
        }
    }
    *szFolder = NULL;
    IMalloc* piMalloc = 0;
    LPITEMIDLIST pidlFolder; // NOT ITEMIDLIST*, LPITEMIDLIST is UNALIGNED ITEMIDLIST*
    if (SHGetMalloc(&piMalloc) == NOERROR)
    {
        if (SHGetSpecialFolderLocation(0, CSIDL_APPDATA, &pidlFolder) == NOERROR)
        {
            if (SHGetPathFromIDList(pidlFolder, szFolder))
            {
                // it's safer not to try to guess locations for other users
                // so we check these folders only for the current user.
                if (szFolder[_tcsclen(szFolder) - 1] != TEXT('\\')) // 'strlen'
                {
                    _tcscat(szFolder, TEXT("\\")); // 'strcat'
                }

                _tcscat(szFolder, TEXT("Microsoft\\Installer")); // 'strcat'
            }
            piMalloc->Free(pidlFolder);
        }
        piMalloc->Release();
        piMalloc = 0;
    }
    if ( *szFolder && !LearnNewString(szFolder, rgpszFolders, cFolders, true) )
    {
        fError = true;
        goto Return;
    }

    if ( cReferencedFiles )
    {
        // 2.2. we go through the list of cached files and try to learn
        //      some new folders
        for (int i = 0; i < cReferencedFiles; i++)
        {
            TCHAR* pszDelim = _tcsrchr(rgpszReferencedFiles[i], TEXT('\\')); // 'strrchr'
            if ( !pszDelim )
                continue;
            INT_PTR iLen = pszDelim - rgpszReferencedFiles[i];
            _tcsnccpy(szFolder, rgpszReferencedFiles[i], iLen);
            szFolder[iLen] = 0;
            if ( !LearnNewString(szFolder, rgpszFolders, cFolders, true) )
            {
                fError = true;
                goto Return;
            }
        }
    }

#ifdef DEBUG
    TCHAR rgchBuffer[MAX_PATH];
    if ( cReferencedFiles )
    {

        OutputDebugString(TEXT("MsiZap info: the cached files below were found in the registry. ")
                          TEXT(" These files will not be removed.\n"));
        for (int i = 0; i < cReferencedFiles; i++)
        {
            StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR), TEXT("   %s\n"), rgpszReferencedFiles[i]);
            OutputDebugString(rgchBuffer);
        }
    }
    else
        OutputDebugString(TEXT("MsiZap info: no cached files were found in the registry.\n"));
    OutputDebugString(TEXT("MsiZap info: cached files with the following extensions will be removed:\n"));
    for (int i = 0; i < cExtensions; i++)
    {
        StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR), TEXT("   %s\n"), rgpszExtensions[i]);
        OutputDebugString(rgchBuffer);
    }
    OutputDebugString(TEXT("MsiZap info: cached files will be removed from the following directories:\n"));
    for (int i = 0; i < cFolders; i++)
    {
        StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR), TEXT("   %s\n"), rgpszFolders[i]);
        OutputDebugString(rgchBuffer);
    }
#endif

    // 3.  we go through the constructed list of folders, we look for files
    //     with extensions in the constructed array of extensions and we
    //     delete all files we find on the disk that are not present in the
    //     registry (files that are not present in rgpszReferencedFiles array)
    for (UINT iF = 0; iF < cFolders; iF++)
    {
        for (UINT iE = 0; iE < cExtensions; iE++)
        {
            _tcscpy(szFolder, rgpszFolders[iF]); // 'strcpy'
            if ( szFolder[_tcsclen(szFolder)] != TEXT('\\') ) // 'strlen'
                _tcscat(szFolder, TEXT("\\")); // 'strcat'
            _tcscat(szFolder, TEXT("*"));
            TCHAR* pszDelim = _tcsrchr(szFolder, TEXT('*')); // 'strrchr'
            _tcscat(szFolder, rgpszExtensions[iE]);
            DWORD dwError = ERROR_SUCCESS;
            WIN32_FIND_DATA FindFileData;
            HANDLE hHandle = FindFirstFile(szFolder, &FindFileData);
            if ( hHandle == INVALID_HANDLE_VALUE )
            {
                dwError = GetLastError();
                if ( dwError != ERROR_FILE_NOT_FOUND &&
                     dwError != ERROR_PATH_NOT_FOUND )
                {
                    _tprintf(TEXT("   Could not find any \'%s\' files. GetLastError returns: %d.\n"),
                             szFolder, dwError);
                }
                continue;
            }
            BOOL fFound;
            do
            {
                if ( (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) !=
                     FILE_ATTRIBUTE_DIRECTORY)
                {
                    _tcscpy(pszDelim, FindFileData.cFileName);
                    // OK, we have the full file name, now we need to check
                    // if it is a known file.
                    if ( !IsStringInArray(szFolder, rgpszReferencedFiles) )
                    {
                        if ( !RemoveFile(szFolder, false) )
                            fError = true;
                    }
                }
                fFound = FindNextFile(hHandle, &FindFileData);
                if ( !fFound &&
                     (dwError = GetLastError()) != ERROR_NO_MORE_FILES )
                {
                    _tprintf(TEXT("   Could not find any more \'%s\' files. GetLastError returns: %d.\n"),
                             szFolder, dwError);
                }
            } while( fFound );
            FindClose(hHandle);
        }
    }

Return:
    for (i = 0; i < rgpszExtensions.GetSize(); i++)
        if ( rgpszExtensions[i] )
            free(rgpszExtensions[i]);
    for (i = 0; i < rgpszReferencedFiles.GetSize(); i++)
        if ( rgpszReferencedFiles[i] )
            free(rgpszReferencedFiles[i]);
    for (i = 0; i < rgpszFolders.GetSize(); i++)
        if ( rgpszFolders[i] )
            free(rgpszFolders[i]);

    return !fError;
}


//==============================================================================================
// StopService function:
//   Queries the Service Control Manager for MsiServer (Windows Installer Service) and
//    attempts to stop the service if currently running
//
bool StopService()
{
    SERVICE_STATUS          ssStatus;       // current status of the service

    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    int iRetval = ERROR_SUCCESS;

    schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (schSCManager)
    {
        schService = OpenService(schSCManager, TEXT("MsiServer"), SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if (ControlService(schService, SERVICE_CONTROL_STOP, &ssStatus))
            {
                 Sleep(1000);
                 while (QueryServiceStatus(schService, &ssStatus))
                 {
                      if (ssStatus.dwCurrentState == SERVICE_STOP_PENDING)
                            Sleep(1000);
                      else
                            break;
                 }
                
                 if (ssStatus.dwCurrentState != SERVICE_STOPPED)
                    iRetval = E_FAIL; //??
            }
            else // control service may have failed because service was already stopped
            {
                iRetval = GetLastError();

                if (ERROR_SERVICE_NOT_ACTIVE == iRetval)
                    iRetval = ERROR_SUCCESS;
            }

            CloseServiceHandle(schService);
        }
        else // !schService
        {
            iRetval = GetLastError();
            if (ERROR_SERVICE_DOES_NOT_EXIST == iRetval)
                iRetval = ERROR_SUCCESS;

        }

        CloseServiceHandle(schSCManager);
    }
    else // !schSCManager
    {
        iRetval = GetLastError();
    }
    
    if (iRetval != ERROR_SUCCESS)
        _tprintf(TEXT("Could not stop Msi service: Error %d\n"), iRetval);
    return iRetval == ERROR_SUCCESS;
}

//==============================================================================================
// GetAdminSid function:
//   Allocates a sid for the BUILTIN\Administrators group
//
DWORD GetAdminSid(char** pSid)
{
    static bool fSIDSet = false;
    static char rgchStaticSID[256];
    const int cbStaticSID = sizeof(rgchStaticSID);
    SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
    PSID pSID;
    if (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(pSID)))
        return GetLastError();

    //Assert(pSID->GetLengthSid() <= cbStaticSID);
    memcpy(rgchStaticSID, pSID, GetLengthSid(pSID));
    *pSid = rgchStaticSID;
    fSIDSet = true;
    return ERROR_SUCCESS;
}

//==============================================================================================
// OpenUserToken function:
//   Returns the user's thread token if available; otherwise, it obtain's the user token from
//    the process token
//
DWORD OpenUserToken(HANDLE &hToken, bool* pfThreadToken)
{
    DWORD dwResult = ERROR_SUCCESS;
    if (pfThreadToken)
        *pfThreadToken = true;

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE|TOKEN_QUERY, TRUE, &hToken))
    {
        // if the thread has no access token then use the process's access token
        dwResult = GetLastError();
        if (pfThreadToken)
            *pfThreadToken = false;
        if (ERROR_NO_TOKEN == dwResult)
        {
            dwResult = ERROR_SUCCESS;
            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE|TOKEN_QUERY, &hToken))
                dwResult = GetLastError();
        }
    }
    return dwResult;
}

//==============================================================================================
// GetCurrentUserToken function:
//  Obtains the current user token -- either from the thread token or the process token.
//   Wrapper around OpenUserToken
//
DWORD GetCurrentUserToken(HANDLE &hToken)
{
    DWORD dwRet = ERROR_SUCCESS;
    dwRet = OpenUserToken(hToken);
    return dwRet;
}

//==============================================================================================
// GetStringSID function:
//  Converts a binary SID into its string from (S-n-...). szSID should be length of cchMaxSID
//
void GetStringSID(PISID pSID, TCHAR* szSID)
{
    TCHAR Buffer[cchMaxSID];
    
    StringCchPrintf(Buffer, sizeof(Buffer)/sizeof(TCHAR), TEXT("S-%u-"), (USHORT)pSID->Revision);

    lstrcpy(szSID, Buffer);

    if (  (pSID->IdentifierAuthority.Value[0] != 0)  ||
            (pSID->IdentifierAuthority.Value[1] != 0)     )
    {
        StringCchPrintf(Buffer, sizeof(Buffer)/sizeof(TCHAR), TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                     (USHORT)pSID->IdentifierAuthority.Value[0],
                     (USHORT)pSID->IdentifierAuthority.Value[1],
                    (USHORT)pSID->IdentifierAuthority.Value[2],
                    (USHORT)pSID->IdentifierAuthority.Value[3],
                    (USHORT)pSID->IdentifierAuthority.Value[4],
                    (USHORT)pSID->IdentifierAuthority.Value[5] );
        lstrcat(szSID, Buffer);

    } else {

        ULONG Tmp = (ULONG)pSID->IdentifierAuthority.Value[5]          +
              (ULONG)(pSID->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(pSID->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(pSID->IdentifierAuthority.Value[2] << 24);
        StringCchPrintf(Buffer, sizeof(Buffer)/sizeof(TCHAR), TEXT("%lu"), Tmp);
        lstrcat(szSID, Buffer);
    }

    for (int i=0;i<pSID->SubAuthorityCount ;i++ ) {
        StringCchPrintf(Buffer, sizeof(Buffer)/sizeof(TCHAR), TEXT("-%lu"), pSID->SubAuthority[i]);
        lstrcat(szSID, Buffer);
    }
}

//==============================================================================================
// GetUserSID function:
//  Obtains the (binary form of the) SID for the user specified by hToken
//
DWORD GetUserSID(HANDLE hToken, char* rgSID)
{
    UCHAR TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG ReturnLength;

    BOOL f = GetTokenInformation(hToken,
                                                TokenUser,
                                                TokenInformation,
                                                sizeof(TokenInformation),
                                                &ReturnLength);

    if(f == FALSE)
    {
        DWORD dwRet = GetLastError();
        return dwRet;
    }

    PISID iSid = (PISID)((PTOKEN_USER)TokenInformation)->User.Sid;
    if (CopySid(cbMaxSID, rgSID, iSid))
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

//==============================================================================================
// GetCurrentUserSID function:
//  Obtains the (binary form of the) SID for the current user. Caller does NOT need to
//   impersonate
//
DWORD GetCurrentUserSID(char* rgchSID)
{
    HANDLE hToken;
    DWORD dwRet = ERROR_SUCCESS;

    dwRet = GetCurrentUserToken(hToken);
    if (ERROR_SUCCESS == dwRet)
    {
        dwRet = GetUserSID(hToken, rgchSID);
        CloseHandle(hToken);
    }
    return dwRet;
}

//==============================================================================================
// GetCurrentUserStringSID function:
//  Obtains the string from of the SID for the current user. Caller does NOT need to impersonate
//
inline TCHAR* GetCurrentUserStringSID(DWORD* dwReturn)
{
    DWORD dwRet = ERROR_SUCCESS;
    TCHAR *szReturn = NULL;

    if ( g_iUserIndex >= 0 && g_rgpszAllUsers )
        szReturn = g_rgpszAllUsers[g_iUserIndex];
    else
    {
        if ( !g_fWin9X )
        {
            static TCHAR szCurrentUserSID[cchMaxSID] = {0};
            if ( !*szCurrentUserSID )
            {
                char rgchSID[cbMaxSID];
                if (ERROR_SUCCESS == (dwRet = GetCurrentUserSID(rgchSID)))
                {
                    GetStringSID((PISID)rgchSID, szCurrentUserSID);
                }
            }
            szReturn = szCurrentUserSID;
        }
        else
        {
            static TCHAR szWin9xSID[] = TEXT("CommonUser");
            szReturn = szWin9xSID;
        }
    }

    if ( dwReturn )
        *dwReturn = dwRet;
    return szReturn;
}

//==============================================================================================
// GetAdminFullControlSecurityDescriptor function:
//  Returns a full control ACL for BUILTIN\Administrators
//
DWORD GetAdminFullControlSecurityDescriptor(char** pSecurityDescriptor)
{
    static bool fDescriptorSet = false;
    static char rgchStaticSD[256];
    const int cbStaticSD = sizeof(rgchStaticSD);

    DWORD dwError;
    if (!fDescriptorSet)
    {

        char* pAdminSid;
        if (ERROR_SUCCESS != (dwError = GetAdminSid(&pAdminSid)))
            return dwError;
        
        const SID* psidOwner = (SID*)pAdminSid;

        DWORD dwAccessMask = STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL;

        // Initialize our ACL

        const int cbAce = sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD); // subtract ACE.SidStart from the size
        int cbAcl = sizeof (ACL);

        cbAcl += (2*GetLengthSid(pAdminSid) + 2*cbAce);

        const int cbDefaultAcl = 512; //??
        char rgchACL[cbDefaultAcl];

        if (!InitializeAcl ((ACL*) (char*) rgchACL, cbAcl, ACL_REVISION))
            return GetLastError();

        // Add an access-allowed ACE for each of our SIDs

        if (!AddAccessAllowedAce((ACL*) (char*) rgchACL, ACL_REVISION, (GENERIC_ALL), pAdminSid))
            return GetLastError();
        if (!AddAccessAllowedAce((ACL*) (char*) rgchACL, ACL_REVISION, (GENERIC_ALL), pAdminSid))
            return GetLastError();

        ACCESS_ALLOWED_ACE* pAce;
        if (!GetAce((ACL*)(char*)rgchACL, 0, (void**)&pAce))
            return GetLastError();

        pAce->Header.AceFlags = INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE;

        if (!GetAce((ACL*)(char*)rgchACL, 1, (void**)&pAce))
            return GetLastError();

        pAce->Header.AceFlags = CONTAINER_INHERIT_ACE;

/*
   ACE1 (applies to files in the directory)
      ACE flags:   INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE
      Access Mask: DELETE | GENERIC_READ | GENERIC_WRITE |
                   GENERIC_EXECUTE
   ACE2 (applies to the directory and subdirectories)
      ACE flags:   CONTAINER_INHERIT_ACE
      Access Mask: DELETE | FILE_GENERIC_READ | FILE_GENERIC_WRITE |
                   FILE_GENERIC_EXECUTE
*/
        // Initialize our security descriptor,throw the ACL into it, and set the owner

        SECURITY_DESCRIPTOR sd;

        if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) ||
            (!SetSecurityDescriptorDacl(&sd, TRUE, (ACL*) (char*) rgchACL, FALSE)) ||
            (!SetSecurityDescriptorOwner(&sd, (PSID)psidOwner, FALSE)))
        {
            return GetLastError();
        }

        DWORD cbSD = GetSecurityDescriptorLength(&sd);
        if (cbStaticSD < cbSD)
            return ERROR_INSUFFICIENT_BUFFER;

        MakeSelfRelativeSD(&sd, (char*)rgchStaticSD, &cbSD); //!! AssertNonZero
        fDescriptorSet = true;
    }

    *pSecurityDescriptor = rgchStaticSD;
    return ERROR_SUCCESS;
}

//==============================================================================================
// GetUsersToken function:
//  Returns the user's thread token if possible; otherwise obtains the user's process token.
//   Caller must impersonate!
//
bool GetUsersToken(HANDLE &hToken)
{
    bool fResult = true;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE|TOKEN_QUERY, &hToken))
        fResult = false;

    return fResult;
}

//==============================================================================================
// IsAdmin(): return true if current user is an Administrator (or if on Win95)
// See KB Q118626 
#define ADVAPI32_DLL TEXT("advapi32.dll")
#define ADVAPI32_CheckTokenMembership "CheckTokenMembership"
typedef BOOL (WINAPI *PFnAdvapi32CheckTokenMembership)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);

bool IsAdmin(void)
{
	if(g_fWin9X)
		return true; // convention: always Admin on Win95
	
	// get the administrator sid		
	PSID psidAdministrators;
	SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
	if(!AllocateAndInitializeSid(&siaNtAuthority, 2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0, 0, 0, 0, 0, 0,
		&psidAdministrators))
		return false;

	// on NT5, use the CheckTokenMembershipAPI to correctly handle cases where
	// the Administrators group might be disabled. bIsAdmin is BOOL 
	BOOL bIsAdmin = FALSE;
	if (g_iMajorVersion >= 5) 
	{
		// CheckTokenMembership checks if the SID is enabled in the token. NULL for
		// the token means the token of the current thread. Disabled groups, restricted
		// SIDS, and SE_GROUP_USE_FOR_DENY_ONLY are all considered. If the function
		// returns false, ignore the result.
		HMODULE hAdvapi32 = 0;
		hAdvapi32 = LoadLibrary(ADVAPI32_DLL);
		if (hAdvapi32)
		{
			PFnAdvapi32CheckTokenMembership pfnAdvapi32CheckTokenMembership = (PFnAdvapi32CheckTokenMembership)GetProcAddress(hAdvapi32, ADVAPI32_CheckTokenMembership);
			if (pfnAdvapi32CheckTokenMembership)
			{
				if (!pfnAdvapi32CheckTokenMembership(NULL, psidAdministrators, &bIsAdmin))
					bIsAdmin = FALSE;
			}
			FreeLibrary(hAdvapi32);
			hAdvapi32 = 0;
		}
	}
	else
	{
		// NT4, check groups of user
		HANDLE hAccessToken;
		DWORD dwOrigInfoBufferSize = 1024;
		DWORD dwInfoBufferSize;
		UCHAR *pInfoBuffer = new UCHAR[dwOrigInfoBufferSize]; // may need to resize if TokenInfo too big
		if (!pInfoBuffer)
		{
			_tprintf(TEXT("Out of memory\n"));
			return false;
		}
		UINT x;

		if (OpenProcessToken(GetCurrentProcess(),TOKEN_READ,&hAccessToken))
		{
			bool bSuccess = false;
			bSuccess = GetTokenInformation(hAccessToken,TokenGroups,pInfoBuffer,
				dwOrigInfoBufferSize, &dwInfoBufferSize) == TRUE;

			if(dwInfoBufferSize > dwOrigInfoBufferSize)
			{
				delete [] pInfoBuffer;
				pInfoBuffer = new UCHAR[dwInfoBufferSize];
				if (!pInfoBuffer)
				{
					_tprintf(TEXT("Out of memory\n"));
					return false;
				}
				bSuccess = GetTokenInformation(hAccessToken,TokenGroups,pInfoBuffer,
					dwInfoBufferSize, &dwInfoBufferSize) == TRUE;
			}

			CloseHandle(hAccessToken);
			
			if (bSuccess)
			{
				PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)(UCHAR*)pInfoBuffer;
				for(x=0;x<ptgGroups->GroupCount;x++)
				{
					if( EqualSid(psidAdministrators, ptgGroups->Groups[x].Sid) )
					{
						bIsAdmin = TRUE;
						break;
					}

				}
			}
		}

		if (pInfoBuffer)
		{
			delete [] pInfoBuffer;
			pInfoBuffer = 0;
		}
	}
	
	FreeSid(psidAdministrators);
	return bIsAdmin ? true : false;
}

//==============================================================================================
// AcquireTokenPrivilege function:
//  Acquires the requested privilege
//
bool AcquireTokenPrivilege(const TCHAR* szPrivilege)
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tkp;
    // get the token for this process
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
        return false;
    // the the LUID for the shutdown privilege
    if (!LookupPrivilegeValue(0, szPrivilege, &tkp.Privileges[0].Luid))
        return CloseHandle(hToken), false;
    tkp.PrivilegeCount = 1; // one privilege to set
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    // get the shutdown privilege for this process
    AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) 0, 0);
    // cannot test the return value of AdjustTokenPrivileges
    CloseHandle(hToken);
    if (GetLastError() != ERROR_SUCCESS)
        return false;
    return true;
}

//==============================================================================================
// IsGUID function:
//  Indicates whether or not the provided string is a valid GUID
//
BOOL IsGUID(const TCHAR* sz)
{
    return ( (lstrlen(sz) == 38) && 
             (sz[0] == '{') && 
             (sz[9] == '-') &&
             (sz[14] == '-') &&
             (sz[19] == '-') &&
             (sz[24] == '-') &&
             (sz[37] == '}')
             ) ? TRUE : FALSE;
}

//==============================================================================================
// GetSQUID function:
//  Converts the provided product code into a SQUID
//
void GetSQUID(const TCHAR* szProduct, TCHAR* szProductSQUID)
{
    TCHAR* pchSQUID = szProductSQUID;
    const unsigned char rgOrderGUID[32] = {8,7,6,5,4,3,2,1, 13,12,11,10, 18,17,16,15,
                                           21,20, 23,22, 26,25, 28,27, 30,29, 32,31, 34,33, 36,35}; 

    const unsigned char* pch = rgOrderGUID;
    while (pch < rgOrderGUID + sizeof(rgOrderGUID))
        *pchSQUID++ = szProduct[*pch++];
    *pchSQUID = 0;
}

//==============================================================================================
// TakeOwnershipOfFile function:
//  Attempts to give the admin ownership and full control of the file (or folder)
//
DWORD TakeOwnershipOfFile(const TCHAR* szFile, bool fFolder)
{
    DWORD lError = ERROR_SUCCESS;
	HANDLE hFile = INVALID_HANDLE_VALUE;
    if (AcquireTokenPrivilege(SE_TAKE_OWNERSHIP_NAME))
    {
		// open file with WRITE_DAC, WRITE_OWNER, and READ_CONTROL access
		DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
		if (fFolder)
			dwFlagsAndAttributes |= FILE_FLAG_BACKUP_SEMANTICS;
		hFile = CreateFile(szFile, READ_CONTROL | WRITE_DAC | WRITE_OWNER, FILE_SHARE_READ, NULL, OPEN_EXISTING, dwFlagsAndAttributes, NULL);
		if (INVALID_HANDLE_VALUE == hFile)
		{
			lError = GetLastError();
			_tprintf(TEXT("   Failed to access %s: %s. LastError %d\n"), fFolder ? TEXT("folder") : TEXT("file"), szFile, lError);
			return lError;
		}

		// add admin as owner and include admin full control in DACL
		if (ERROR_SUCCESS == (lError = AddAdminOwnership(hFile, SE_FILE_OBJECT)))
		{
			lError = AddAdminFullControl(hFile, SE_FILE_OBJECT);
		}
    }

    if (ERROR_SUCCESS == lError || ERROR_CALL_NOT_IMPLEMENTED == lError)
    {
        if (!SetFileAttributes(szFile, FILE_ATTRIBUTE_NORMAL))
		{
			lError = GetLastError();
            _tprintf(TEXT("   Failed to set file attributes for %s: %s %d\n"), fFolder ? TEXT("folder") : TEXT("file"), szFile, lError);
		}
    }

	if (ERROR_SUCCESS != lError)
		_tprintf(TEXT("   Failed to take ownership of %s: %s %d\n"), fFolder ? TEXT("folder") : TEXT("file"), szFile, lError);
   
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	return lError;
}

//==============================================================================================
// RemoveFile function:
//  Deletes a file or adjusts the ACLs on the file. If the 1st attempt to delete the file
//   fails, will attempt a 2nd time after having taken ownership
//
bool RemoveFile(TCHAR* szFilePath, bool fJustRemoveACLs)
{
	if (GetFileAttributes(szFilePath) == 0xFFFFFFFF && GetLastError() == ERROR_FILE_NOT_FOUND)
		return true; // nothing to do -- file does not exist

	DWORD dwRet = ERROR_SUCCESS;
	if (fJustRemoveACLs || !DeleteFile(szFilePath))
	{
		dwRet = TakeOwnershipOfFile(szFilePath, /*fFolder=*/false);
		if (!fJustRemoveACLs && !DeleteFile(szFilePath))
		{
			TCHAR szMsg[256];
			DWORD cchMsg = sizeof(szMsg)/sizeof(TCHAR);
			UINT uiLastErr = GetLastError();
			if (0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, uiLastErr, 0, szMsg, cchMsg, 0))
				_tprintf(TEXT("   Error %d attempting to delete file: '%s'\n"), uiLastErr, szFilePath);
			else
				_tprintf(TEXT("   Could not delete file: %s\n      %s\n"), szFilePath, szMsg);

			return false;
		}
	}

	if (ERROR_SUCCESS != dwRet)
	{
		_tprintf(fJustRemoveACLs ? TEXT("   Failed to remove ACL on file: %s\n") : TEXT("   Failed to remove file: %s\n"), szFilePath);
		return false;
	}

	// success!
	_tprintf(fJustRemoveACLs ? TEXT("   Removed ACL on file: %s\n") : TEXT("   Removed file: %s\n"), szFilePath);
	g_fDataFound = true;
	return true;
}

//==============================================================================================
// DeleteFolder function:
//  Deletes a folder and all files contained within the folder
//
BOOL DeleteFolder(TCHAR* szFolder, bool fJustRemoveACLs)
{
	if (!szFolder || (MAX_PATH < lstrlen(szFolder)))
		return FALSE;

    TCHAR szSearchPath[MAX_PATH*3];
    TCHAR szFilePath[MAX_PATH*3];
    lstrcpy(szSearchPath, szFolder);
    lstrcat(szSearchPath, TEXT("\\*.*"));

    if (0xFFFFFFFF == GetFileAttributes(szFolder)/* && ERROR_FILE_NOT_FOUND == GetLastError()*/) // return TRUE if the folder isn't there
        return TRUE;

    WIN32_FIND_DATA fdFindData;
    HANDLE hFile = FindFirstFile(szSearchPath, &fdFindData);

    if ((hFile == INVALID_HANDLE_VALUE) && (ERROR_ACCESS_DENIED == GetLastError()))
    {
        TakeOwnershipOfFile(szFolder, /*fFolder=*/true);
        hFile = FindFirstFile(szSearchPath, &fdFindData);
    }
    
    if(hFile != INVALID_HANDLE_VALUE)
    {
        // may still only contain "." and ".."
        do
        {
            if((0 != lstrcmp(fdFindData.cFileName, TEXT("."))) &&
                (0 != lstrcmp(fdFindData.cFileName, TEXT(".."))))
            {
                lstrcpy(szFilePath, szFolder);
                lstrcat(szFilePath, TEXT("\\"));
                lstrcat(szFilePath, fdFindData.cFileName);
                if (GetFileAttributes(szFilePath) & FILE_ATTRIBUTE_DIRECTORY)
                {
                    if (!DeleteFolder(szFilePath, fJustRemoveACLs))
                        return FALSE;
                }
                else
                {
                    if (!RemoveFile(szFilePath, fJustRemoveACLs))
                        return FALSE;
                }
            }

        }
        while(FindNextFile(hFile, &fdFindData) == TRUE);
    }
    else if (ERROR_FILE_NOT_FOUND != GetLastError())
    {
        _tprintf(TEXT("   Error enumerating files in folder %s\n"), szFolder);
    }
    else
    {
        return TRUE;
    }
    
    FindClose(hFile);

	DWORD dwRet = ERROR_SUCCESS;
	if (fJustRemoveACLs || !RemoveDirectory(szFolder))
	{
		dwRet = TakeOwnershipOfFile(szFolder, /*fFolder=*/true);
		if (!fJustRemoveACLs && !RemoveDirectory(szFolder))
		{
			TCHAR szMsg[256];
			DWORD cchMsg = sizeof(szMsg)/sizeof(TCHAR);
			UINT uiLastErr = GetLastError();
			if (0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, uiLastErr, 0, szMsg, cchMsg, 0))
				_tprintf(TEXT("   Error %d attempting to delete folder: '%s'\n"), uiLastErr, szFolder);
			else
				_tprintf(TEXT("   Could not delete folder: %s\n      %s\n"), szFolder, szMsg);

			return FALSE;
		}
	}

	if (ERROR_SUCCESS != dwRet)
	{
		_tprintf(fJustRemoveACLs ? TEXT("   Failed to remove ACL on folder: %s\n") : TEXT("   Failed to remove folder: %s\n"), szFolder);
		return FALSE;
	}

	// success!
	_tprintf(fJustRemoveACLs ? TEXT("   Removed ACL on folder: %s\n") : TEXT("   Removed folder: %s\n"), szFolder);
	g_fDataFound = true;
	return TRUE;
}

//==============================================================================================
// AddAdminOwnership function:
//  Sets the BUILTIN\Administrators group as the owner of the provided object
//
DWORD AddAdminOwnership(HANDLE hObject, SE_OBJECT_TYPE ObjectType)
{
	DWORD dwRes = 0;
	SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
	PSID pAdminSID = NULL;

	// Create a SID for the BUILTIN\Administrators group.

	if(! AllocateAndInitializeSid( &SIDAuthNT, 2,
					 SECURITY_BUILTIN_DOMAIN_RID,
					 DOMAIN_ALIAS_RID_ADMINS,
					 0, 0, 0, 0, 0, 0,
					 &pAdminSID) ) {
		dwRes = GetLastError();
		_tprintf(TEXT("   AllocateAndInitializeSid Error %u\n"), dwRes );
		return dwRes;
	}


	// Attach the admin sid as the object's owner

	dwRes = SetSecurityInfo(hObject, ObjectType, 
		  OWNER_SECURITY_INFORMATION,
		  pAdminSID, NULL, NULL, NULL);
	if (ERROR_SUCCESS != dwRes)  {
		if (pAdminSID)
			FreeSid(pAdminSID);
		_tprintf(TEXT("   SetSecurityInfo Error %u\n"), dwRes );
		return dwRes;
	}  

	if (pAdminSID)
		FreeSid(pAdminSID);

	return ERROR_SUCCESS;
}

//==============================================================================================
// MakeAdminRegKeyOwner function:
//  Sets the BUILTIN\Administrators group as the owner of the provided registry key
//
DWORD MakeAdminRegKeyOwner(HKEY hKey, TCHAR* szSubKey)
{
	CRegHandle HSubKey = 0;
	LONG lError = 0;

	// Open registry key with permission to change owner
	if (ERROR_SUCCESS != (lError = RegOpen64bitKey(hKey, szSubKey, 0, WRITE_OWNER, &HSubKey)))
	{
		_tprintf(TEXT("   Error %d opening subkey: '%s'\n"), lError, szSubKey);
		return lError;
	}

	return AddAdminOwnership(HSubKey, SE_REGISTRY_KEY);
}

//==============================================================================================
// AddAdminFullControl function:
//  Includes admin full control (BUILTIN\Administrators group) in the current DACL on the
//   specified object (can be file or registry key)
//
DWORD AddAdminFullControl(HANDLE hObject, SE_OBJECT_TYPE ObjectType)
{
	DWORD dwRes = 0;
	PACL pOldDACL = NULL, pNewDACL = NULL;
	PSECURITY_DESCRIPTOR pSD = NULL;
	EXPLICIT_ACCESS ea;
	PSID pAdminSID = NULL;
	SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;

	// Get a pointer to the existing DACL.

	dwRes = GetSecurityInfo(hObject, ObjectType, 
		  DACL_SECURITY_INFORMATION,
		  NULL, NULL, &pOldDACL, NULL, &pSD);
	if (ERROR_SUCCESS != dwRes) {
		_tprintf( TEXT("   GetSecurityInfo Error %u\n"), dwRes );
		goto Cleanup; 
	}  

	// Create a SID for the BUILTIN\Administrators group.

	if(! AllocateAndInitializeSid( &SIDAuthNT, 2,
					 SECURITY_BUILTIN_DOMAIN_RID,
					 DOMAIN_ALIAS_RID_ADMINS,
					 0, 0, 0, 0, 0, 0,
					 &pAdminSID) ) {
		dwRes = GetLastError();
		_tprintf( TEXT("   AllocateAndInitializeSid Error %u\n"), dwRes );
		goto Cleanup; 
	}

	// Initialize an EXPLICIT_ACCESS structure for an ACE.
	// The ACE will allow the Administrators group full access to the key.

	ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
	ea.grfAccessPermissions = KEY_ALL_ACCESS;
	ea.grfAccessMode = SET_ACCESS;
	ea.grfInheritance= NO_INHERITANCE;
	ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
	ea.Trustee.ptstrName  = (LPTSTR) pAdminSID;

	// Create a new ACL that merges the new ACE
	// into the existing DACL.

	dwRes = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL);
	if (ERROR_SUCCESS != dwRes)  {
		_tprintf( TEXT("   SetEntriesInAcl Error %u\n"), dwRes );
		goto Cleanup; 
	}  

	// Attach the new ACL as the object's DACL.

	dwRes = SetSecurityInfo(hObject, ObjectType, 
		  DACL_SECURITY_INFORMATION,
		  NULL, NULL, pNewDACL, NULL);
	if (ERROR_SUCCESS != dwRes)  {
		_tprintf( TEXT("   SetSecurityInfo Error %u\n"), dwRes );
		goto Cleanup; 
	}  

Cleanup:

	if(pSD != NULL) 
		LocalFree((HLOCAL) pSD); 
	if(pNewDACL != NULL) 
		LocalFree((HLOCAL) pNewDACL); 
	if (pAdminSID != NULL)
		FreeSid(pAdminSID);

	return dwRes;
}

//==============================================================================================
// AddAdminFullControlToRegKey function:
//  Includes admin full control (BUILTIN\Administrators group) in the current DACL on the
//   registry key
//
DWORD AddAdminFullControlToRegKey(HKEY hKey)
{
	return AddAdminFullControl(hKey, SE_REGISTRY_KEY);
}

//==============================================================================================
// DeleteTree function:
//  Deletes the key szSubKey and all subkeys and values beneath it
//
BOOL DeleteTree(HKEY hKey, TCHAR* szSubKey, bool fJustRemoveACLs)
{
    CRegHandle HSubKey;
    LONG lError;
    if ((lError = RegOpen64bitKey(hKey, szSubKey, 0, KEY_READ, &HSubKey)) != ERROR_SUCCESS)
    {
        if (ERROR_FILE_NOT_FOUND != lError)
        {
			_tprintf(TEXT("   Error %d attempting to open \\%s\n"), lError, szSubKey);
            return FALSE;
		}
        else
			return TRUE; // nothing to do
    }
    TCHAR szName[500];
    DWORD cbName = sizeof(szName)/sizeof(TCHAR);
    unsigned int iIndex = 0;
    while ((lError = RegEnumKeyEx(HSubKey, iIndex, szName, &cbName, 0, 0, 0, 0)) == ERROR_SUCCESS)
    {
        if (!DeleteTree(HSubKey, szName, fJustRemoveACLs))
            return FALSE;

        if (fJustRemoveACLs)
            iIndex++;

        cbName = sizeof(szName)/sizeof(TCHAR);
    }

    if (lError != ERROR_NO_MORE_ITEMS)
	{
		_tprintf(TEXT("   Failed to enumerate all subkeys. Error: %d\n"), lError);
        return FALSE;
	}

    HSubKey = 0;

    if (fJustRemoveACLs || (ERROR_SUCCESS != (lError = RegDelete64bitKey(hKey, szSubKey))))
    {
        if (fJustRemoveACLs || (ERROR_ACCESS_DENIED == lError))
        {
            // see whether we're *really* denied access. 
            // give the admin ownership and full control of the key and try again to delete it
            if (AcquireTokenPrivilege(SE_TAKE_OWNERSHIP_NAME))
            {
				if (ERROR_SUCCESS != (lError = MakeAdminRegKeyOwner(hKey, szSubKey)))
				{
					_tprintf(TEXT("   Error %d setting BUILTIN\\Administrators as owner of key '%s'\n"), lError, szSubKey);
					if (fJustRemoveACLs)
						return FALSE;
				}
				else if (ERROR_SUCCESS == (lError = RegOpen64bitKey(hKey, szSubKey, 0, READ_CONTROL | WRITE_DAC, &HSubKey)))
				{
					if (ERROR_SUCCESS == (lError = AddAdminFullControlToRegKey(HSubKey)))
						_tprintf(TEXT("   ACLs changed to admin ownership and full control for key '%s'\n"), szSubKey);
					else
					{
						_tprintf(TEXT("   Unable to add admin full control to reg key '%s'. Error: %d\n"), szSubKey, lError);
						if (fJustRemoveACLs)
							return FALSE;
					}
					HSubKey = 0;
					if (!fJustRemoveACLs)
						lError = RegDelete64bitKey(hKey, szSubKey);
				}
				else
				{
					_tprintf(TEXT("   Error %d opening subkey: '%s'\n"), lError, szSubKey);
					HSubKey = 0;
				}
			}
        }

        if (ERROR_SUCCESS != lError && !fJustRemoveACLs)
        {
            TCHAR szMsg[256];
            DWORD cchMsg = sizeof(szMsg)/sizeof(TCHAR);
            if (0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, lError, 0, szMsg, cchMsg, 0))
                _tprintf(TEXT("   Error %d attempting to delete subkey: '%s'\n"), lError, szSubKey);
            else
                _tprintf(TEXT("   Could not delete subkey: %s\n      %s"), szSubKey, szMsg);

            return FALSE;
        }
    }

	// success!
    _tprintf(TEXT("   %s \\%s\n"), fJustRemoveACLs ? TEXT("Removed ACLs from") : TEXT("Removed "), szSubKey);
	g_fDataFound = true;
    return TRUE;
}

//==============================================================================================
// ClearWindowsUninstallKey function:
//  Removes all data for the product from the HKLM\SW\MS\Windows\CV\Uninstall key
//
bool ClearWindowsUninstallKey(bool fJustRemoveACLs, const TCHAR* szProduct)
{
	_tprintf(TEXT("Searching for product %s data in the HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall key. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    CRegHandle hUninstallKey;
    LONG lError;

    if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"),
                            0, KEY_ALL_ACCESS, &hUninstallKey)) != ERROR_SUCCESS)
    {
        if (ERROR_FILE_NOT_FOUND == lError)
            return true;
        else
        {
            _tprintf(TEXT("   Could not open HKLM\\%s. Error: %d\n"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"), lError);
            return false;
        }
    }

    TCHAR szBuf[256];
    DWORD cbBuf = sizeof(szBuf)/sizeof(TCHAR);

    // for each product 
    int iIndex = 0;
    while ((lError = RegEnumKeyEx(hUninstallKey, iIndex, szBuf, &cbBuf, 0, 0, 0, 0)) == ERROR_SUCCESS)
    {
        if (IsGUID(szBuf))
        {
            if (szProduct)
            {
                if (0 != lstrcmpi(szBuf, szProduct))
                {
                    iIndex++;
                    cbBuf = sizeof(szBuf);
                    continue;
                }
            }
 
			if (!DeleteTree(hUninstallKey, szBuf, fJustRemoveACLs))
                return false;
        
            if (fJustRemoveACLs)
                iIndex++;
        }
        else
        {
            iIndex++;
        }

        cbBuf = sizeof(szBuf)/sizeof(TCHAR);
    }
    return true;
}

//==============================================================================================
// IsProductInstalledByOthers function:
//  Returns whether another user has installed the specified product
//
bool IsProductInstalledByOthers(const TCHAR* szProductSQUID)
{
    CRegHandle hUserDataKey;

    bool fOtherUsers = false;
    // we look up the migrated per-user data key
    long lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData"),
                          0, KEY_READ, &hUserDataKey);
    if ( lError == ERROR_SUCCESS )
    {
        TCHAR szUser[MAX_PATH];
        DWORD cchUser = sizeof(szUser)/sizeof(TCHAR);
        for ( int iIndex = 0;
              (lError = RegEnumKeyEx(hUserDataKey, iIndex,
                                     szUser, &cchUser, 0, 0, 0, 0)) == ERROR_SUCCESS;
              iIndex++, cchUser = sizeof(szUser)/sizeof(TCHAR) )
        {
            if ( lstrcmp(szUser, GetCurrentUserStringSID(NULL)) )
            {
                // it's a different user.  Check if [s]he has szProductSQUID product installed
                TCHAR szKey[MAX_PATH];
                StringCchPrintf(szKey, sizeof(szKey)/sizeof(TCHAR), TEXT("%s\\Products\\%s"), szUser, szProductSQUID);
                CRegHandle hDummy;
                if ( RegOpen64bitKey(hUserDataKey, szKey, 0, KEY_READ, &hDummy) == ERROR_SUCCESS )
                {
                    fOtherUsers = true;
                    break;
                }
            }
        }
    }

    if ( !fOtherUsers && 
         ERROR_SUCCESS == (lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE,
                                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Managed"),
                                        0, KEY_READ, &hUserDataKey)) )
    {
        // we look up the managed user key too.
        TCHAR szUser[MAX_PATH];
        DWORD cchUser = sizeof(szUser)/sizeof(TCHAR);
        for ( int iIndex = 0;
              (lError = RegEnumKeyEx(hUserDataKey, iIndex,
                                     szUser, &cchUser, 0, 0, 0, 0)) == ERROR_SUCCESS;
              iIndex++, cchUser = sizeof(szUser)/sizeof(TCHAR) )
        {
            if ( lstrcmp(szUser, GetCurrentUserStringSID(NULL)) )
            {
                // it's a different user.  Check if [s]he has szProductSQUID product installed
                TCHAR szKey[MAX_PATH];
                StringCchPrintf(szKey, sizeof(szKey)/sizeof(TCHAR), TEXT("%s\\Installer\\Products\\%s"), szUser, szProductSQUID);
                CRegHandle hDummy;
                if ( RegOpen64bitKey(hUserDataKey, szKey, 0, KEY_READ, &hDummy) == ERROR_SUCCESS )
                {
                    fOtherUsers = true;
                    break;
                }
            }
        }
    }

    return fOtherUsers;
}

//==============================================================================================
// ClearUninstallKey function:
//  Handles deletion of the uninstall key in all of the correct cases
//
bool ClearUninstallKey(bool fJustRemoveACLs, const TCHAR* szProduct)
{
	_tprintf(TEXT("Searching for install property data for product %s. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    LONG lError;
    TCHAR rgchKeyBuf[MAX_PATH];
    DWORD dwRes;
    CRegHandle hUserProductsKey;

    bool fNotPerUserMigrated = false;
    StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR),
        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Products"),
        GetCurrentUserStringSID(&dwRes));
    if ( dwRes != ERROR_SUCCESS )
        return false;
    lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, rgchKeyBuf,
                          0, KEY_ALL_ACCESS, &hUserProductsKey);
    if ( lError != ERROR_SUCCESS )
    {
        if (ERROR_FILE_NOT_FOUND == lError)
            fNotPerUserMigrated = true;
        else
        {
            _tprintf(TEXT("   Could not open HKLM\\%s. Error: %d\n"), rgchKeyBuf, lError);
            return false;
        }
    }

    if ( fNotPerUserMigrated )
        return ClearWindowsUninstallKey(fJustRemoveACLs, szProduct);

    // in the migrated-per-user-data world, we remove the ...\\CurrentVersion\\Uninstall entry
    // only if there are no more installations of szProduct.

    TCHAR szRegProduct[MAX_PATH];
    DWORD cchRegProduct = sizeof(szRegProduct)/sizeof(TCHAR);

    TCHAR szProductSQUID[40] = {0};
    if ( szProduct )
        GetSQUID(szProduct, szProductSQUID);

    bool fError = false;
    // for each product in hUserProductsKey
    for ( int iIndex = 0;
          (lError = RegEnumKeyEx(hUserProductsKey, iIndex, szRegProduct, &cchRegProduct, 0, 0, 0, 0)) == ERROR_SUCCESS;
          cchRegProduct = sizeof(szRegProduct)/sizeof(TCHAR), iIndex++ )
    {
        if (*szProductSQUID && 0 != lstrcmpi(szRegProduct, szProductSQUID))
            continue;

        TCHAR szUninstallData[MAX_PATH];
        StringCchPrintf(szUninstallData, sizeof(szUninstallData)/sizeof(TCHAR), TEXT("%s\\InstallProperties"), szRegProduct);
        if (!DeleteTree(hUserProductsKey, szUninstallData, fJustRemoveACLs))
            return false;

        if ( !IsProductInstalledByOthers(szRegProduct) )
            fError |= !ClearWindowsUninstallKey(fJustRemoveACLs, szProduct);
    }

    return !fError;
}

bool GoOpenKey(HKEY hRoot, LPCTSTR szRoot, LPCTSTR szKey, REGSAM sam,
               CRegHandle& HKey, bool& fReturn)
{
    DWORD lResult = RegOpenKeyEx(hRoot, szKey, 0, sam, &HKey);
    if ( lResult == ERROR_SUCCESS )
    {
        fReturn = true;
        return true;
    }
    else
    {
        if ( lResult == ERROR_FILE_NOT_FOUND )
        {
            _tprintf(TEXT("   %s\\%s key is not present.\n"),
                     szRoot, szKey);
            fReturn = true;
        }
        else
        {
            _tprintf(TEXT("   Could not open %s\\%s. Error: %d\n"),
                    szRoot, szKey, lResult);
            fReturn = false;
        }
        return false;
    }
}

//==============================================================================================
// ClearSharedDLLCounts function:
//  Adjusts shared DLL counts for specified component of specified product
//
bool ClearSharedDLLCounts(TCHAR* szComponentsSubkey, const TCHAR* szProduct)
{
    _tprintf(TEXT("Searching for shared DLL counts for components tied to the product %s. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    CRegHandle HSubKey;
    CRegHandle HSharedDLLsKey;
    CRegHandle HSharedDLLsKey32;
    CRegHandle HComponentsKey;
    LONG lError;
    bool fError = false;
    bool fReturn;

    if ( !GoOpenKey(HKEY_LOCAL_MACHINE, TEXT("HKLM"), szComponentsSubkey,
                    KEY_READ | (g_fWinNT64 ? KEY_WOW64_64KEY : 0),
                    HComponentsKey, fReturn) )
        return fReturn;

    const TCHAR rgchSharedDll[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs");
    if ( g_fWinNT64 )
    {
        bool fRet1 = GoOpenKey(HKEY_LOCAL_MACHINE, TEXT("HKLM"), rgchSharedDll,
                               KEY_ALL_ACCESS | KEY_WOW64_64KEY, HSharedDLLsKey, fReturn);;
        bool fRet2 = GoOpenKey(HKEY_LOCAL_MACHINE, TEXT("HKLM32"), rgchSharedDll,
                               KEY_ALL_ACCESS | KEY_WOW64_32KEY, HSharedDLLsKey32, fReturn);
        if ( !fRet1 && !fRet2 )
            return false;
    }
    else
    {
        if ( !GoOpenKey(HKEY_LOCAL_MACHINE, TEXT("HKLM"), rgchSharedDll,
                        KEY_ALL_ACCESS, HSharedDLLsKey, fReturn) )
            return fReturn;
    }

    TCHAR szComponentCode[500];
    TCHAR szProductCode[40];
    TCHAR szKeyFile[MAX_PATH + 1];
    DWORD cbKeyFile = sizeof(szKeyFile);
    DWORD cbProductCode = sizeof(szProductCode)/sizeof(TCHAR);
    DWORD cbComponentCode = sizeof(szComponentCode)/sizeof(TCHAR);
    CRegHandle HComponentKey;

    // for each component 
    int iIndex = 0;
    while ((lError = RegEnumKeyEx(HComponentsKey, iIndex, szComponentCode, &cbComponentCode, 0, 0, 0, 0)) == ERROR_SUCCESS)
    {
        lError = RegOpen64bitKey(HComponentsKey, szComponentCode, 0, KEY_READ, &HComponentKey);
        if (ERROR_SUCCESS == lError)
        {
            int iValueIndex = 0;
            DWORD dwType;
            while (ERROR_SUCCESS == (lError = RegEnumValue(HComponentKey, iValueIndex++, szProductCode, &cbProductCode,
                                  0, &dwType, (LPBYTE)(TCHAR*)szKeyFile, &cbKeyFile)))
            {
                if ((!szProduct || 0==lstrcmpi(szProductCode, szProduct)) && (szKeyFile[0] && szKeyFile[1] == '?'))
                {
                    szKeyFile[1] = ':';
                    ieFolderType iType = ieftNotSpecial;
                    if ( g_fWinNT64 )
                    {
                        int iFolderIndex;
                        iType = IsInSpecialFolder(szKeyFile, &iFolderIndex);
                        if ( iType == ieft32bit && iFolderIndex == iefSystem )
                            // this is the 32-bit Syswow64 folder that
                            // gets recorded in the registry as System32,
                            // so we need to swap it.
                            SwapSpecialFolder(szKeyFile, iest32to64);
                    }
                    // on Win64, if we do not know that a file is in a
                    // definite 32 or 64-bit folder, we have no idea of
                    // its bitness, so we go and decrement its refcount
                    // in both SharedDll registry keys.
                    int iNumIter = g_fWinNT64 && iType == ieftNotSpecial ? 2 : 1;
                    for (int i = 0; i < iNumIter; i++)
                    {
                        HKEY hKey;
                        if ( g_fWinNT64 && (i == 0 || iType == ieft32bit) )
                            // it's either the first iteration on Win64 or the
                            // only one (since it's a known 32-bit file type)
                            hKey = HSharedDLLsKey32;
                        else
                            hKey = HSharedDLLsKey;
                        if ( !hKey )
                            continue;

                        DWORD dwRefCount;
                        DWORD cbRefCnt = sizeof(DWORD);
                        if (ERROR_SUCCESS == (lError = RegQueryValueEx(hKey, szKeyFile, 0, &dwType, (LPBYTE)&dwRefCount, &cbRefCnt)))
                        {
                            if (dwRefCount == 1)
                            {
                                lError = RegDeleteValue(hKey, szKeyFile);
                                if ( lError == ERROR_SUCCESS )
                                {
                                    g_fDataFound = true;
                                    _tprintf(TEXT("   Removed shared DLL entry: %s\n"), szKeyFile);
                                }
                                else
                                    _tprintf(TEXT("   Failed to remove shared DLL entry: %s. GetLastError returned %d.\n"),
                                             szKeyFile, GetLastError());
                            }
                            else
                            {
                                dwRefCount--;
                                lError = RegSetValueEx(hKey, szKeyFile, 0, REG_DWORD, (CONST BYTE*)&dwRefCount, cbRefCnt);
                                if ( lError == ERROR_SUCCESS )
                                {
                                    _tprintf(TEXT("   Reduced shared DLL count to %d for: %s\n"), dwRefCount, szKeyFile);
                                    g_fDataFound = true;
                                }
                                else
                                    _tprintf(TEXT("   Failed to reduce shared DLL count for: %s. GetLastError returned %d.\n"),
                                             szKeyFile, GetLastError());
                            }

                        }
                        else if (ERROR_FILE_NOT_FOUND != lError)
                        {
                            _tprintf(TEXT("   Error querying shared DLL key for client %s, keyfile %s\n"), szProductCode, szKeyFile);
                            fError = true;
                        }
                    }
                }
                cbProductCode = sizeof(szProductCode)/sizeof(TCHAR);
                cbKeyFile = sizeof(szKeyFile);
            }
            if (ERROR_NO_MORE_ITEMS != lError)
            {
                _tprintf(TEXT("   Error enumerating clients of component %s. Error: %d.\n"), szComponentCode, lError);
                fError = true;
            }
        }
        else
        {
            _tprintf(TEXT("   Error opening key for component %s. Error %d.\n"), szComponentCode, lError);
            fError = true;
        }

        cbComponentCode = sizeof(szComponentCode)/sizeof(TCHAR);
        iIndex++;
    }
    return fError == false;
}

//==============================================================================================
// ClearProductClientInfo function:
//
bool ClearProductClientInfo(TCHAR* szComponentsSubkey, const TCHAR *szProduct, bool fJustRemoveACLs)
{
	_tprintf(TEXT("  Searching for product %s client info data. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    CRegHandle HSubKey;
    CRegHandle HComponentsKey;
    LONG lError;
    bool fError = false;

    if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, szComponentsSubkey, 0, KEY_READ, &HComponentsKey)) != ERROR_SUCCESS)
    {
        if (ERROR_FILE_NOT_FOUND == lError)
            return true;
        else
        {
            _tprintf(TEXT("   Could not open HKLM\\%s. Error: %d\n"), szComponentsSubkey, lError);
            return false;
        }
    }

    TCHAR szComponentCode[500];
    DWORD cbComponentCode = sizeof(szComponentCode)/sizeof(TCHAR);
    CRegHandle HComponentKey;

    // for each component 
    int iIndex = 0;
    while ((lError = RegEnumKeyEx(HComponentsKey, iIndex++, szComponentCode, &cbComponentCode, 0, 0, 0, 0)) == ERROR_SUCCESS)
    {
        if (fJustRemoveACLs || (ERROR_SUCCESS != (lError = RegOpen64bitKey(HComponentsKey, szComponentCode, 0, KEY_READ|KEY_WRITE, &HComponentKey))))
        {
                if (fJustRemoveACLs || (ERROR_ACCESS_DENIED == lError))
                {
                    if (!fJustRemoveACLs ||
                        ((ERROR_SUCCESS == (lError = RegOpen64bitKey(HComponentsKey, szComponentCode, 0, KEY_READ, &HComponentKey)) &&
                         (ERROR_SUCCESS == (lError = RegQueryValueEx(HComponentKey, szProduct, 0, 0, 0, 0))))))
                    {
                        // see whether we're *really* denied access. 
                        // give the admin ownership and full control of the key and try again to delete it
                        char *pSecurityDescriptor;
                        if (AcquireTokenPrivilege(SE_TAKE_OWNERSHIP_NAME))
                        {
							if (ERROR_SUCCESS != (lError = MakeAdminRegKeyOwner(HComponentsKey, szComponentCode)))
							{
								_tprintf(TEXT("   Error %d setting BUILTIN\\Administrators as owner of key '%s'\n"), lError, szComponentCode);
								if (fJustRemoveACLs)
									return FALSE;
							}
							else if (ERROR_SUCCESS == (lError = RegOpen64bitKey(HComponentsKey, szComponentCode, 0, READ_CONTROL | WRITE_DAC, &HSubKey)))
							{
								if (ERROR_SUCCESS == (lError = AddAdminFullControlToRegKey(HSubKey)))
									_tprintf(TEXT("   ACLs changed to admin ownership and full control for key '%s'\n"), szComponentCode);
								else
								{
									_tprintf(TEXT("   Failed to add admin full control to key '%s'. Error: %d\n"), szComponentCode, lError);
									if (fJustRemoveACLs)
										return FALSE;
								}
								HSubKey = 0;
								if (!fJustRemoveACLs)
									lError = RegOpen64bitKey(HComponentsKey, szComponentCode, 0, KEY_READ|KEY_WRITE, &HComponentKey);
							}
							else
							{
								_tprintf(TEXT("   Error %d opening subkey: '%s'\n"), lError, szComponentCode);
								HSubKey = 0;
							}
                        }
                    }
                }

        }

        if (ERROR_SUCCESS == lError && !fJustRemoveACLs)
            lError = RegDeleteValue(HComponentKey, szProduct);

        if (ERROR_SUCCESS == lError && !fJustRemoveACLs)
        {
            TCHAR sz[1];
            DWORD cch = 1;
            if (ERROR_NO_MORE_ITEMS == RegEnumValue(HComponentKey, 0, sz, &cch, 0, 0, 0, 0))
            {
                if (ERROR_SUCCESS == RegDelete64bitKey(HComponentsKey, szComponentCode))
                    iIndex--;
            }
        }

        if (ERROR_SUCCESS == lError)
        {
            if (fJustRemoveACLs)
                _tprintf(TEXT("   Removed ACLs for component %s\n"), szComponentCode);
            else
                _tprintf(TEXT("   Removed client of component %s\n"), szComponentCode);
			g_fDataFound = true;
        }
        else if (ERROR_FILE_NOT_FOUND != lError)
        {
            _tprintf(TEXT("   Error deleting client of component %s. Error: %d\n"), szComponentCode, lError);
            fError = true;
        }
        
        cbComponentCode = sizeof(szComponentCode)/sizeof(TCHAR);
    }
	if (ERROR_NO_MORE_ITEMS != lError)
	{
		_tprintf(TEXT("   Unable to enumerate all product client info. Error: %d\n"), lError);
		return false;
	}
    return fError == false;
}

//==============================================================================================
// ClearFolders function:
//
bool ClearFolders(int iTodo, const TCHAR* szProduct, bool fOrphan)
{
	_tprintf(TEXT("Searching for Installer files and folders associated with the product %s. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    bool fError          = false;
    bool fJustRemoveACLs = (iTodo & iOnlyRemoveACLs) != 0;
    
    TCHAR szFolder[2*MAX_PATH+1];

    if (iTodo & iRemoveUserProfileFolder)
    {
		_tprintf(TEXT("  Searching for files and folders in the user's profile. . .\n"));

        if (!szProduct)
        {
            // delete %USERPROFILE%\msi
            if (GetEnvironmentVariable(TEXT("USERPROFILE"), szFolder, sizeof(szFolder)/sizeof(TCHAR)))
            {
                lstrcat(szFolder, TEXT("\\Msi"));
                if (!DeleteFolder(szFolder, fJustRemoveACLs))
                    return false;
            }
        }

        // delete {AppData}\Microsoft\Installer
        if (!fOrphan)
        {
            IMalloc* piMalloc = 0;
            LPITEMIDLIST pidlFolder; // NOT ITEMIDLIST*, LPITEMIDLIST is UNALIGNED ITEMIDLIST*

            if (SHGetMalloc(&piMalloc) == NOERROR)
            {
                if (SHGetSpecialFolderLocation(0, CSIDL_APPDATA, &pidlFolder) == NOERROR)
                {
                    if (SHGetPathFromIDList(pidlFolder, szFolder))
                    {
                        if (szFolder[lstrlen(szFolder) - 1] != '\\')
                        {
                            lstrcat(szFolder, TEXT("\\"));
                        }

                        lstrcat(szFolder, TEXT("Microsoft\\Installer"));

                        if (szProduct)
                        {
                            lstrcat(szFolder, TEXT("\\"));
                            lstrcat(szFolder, szProduct);
                        }

                        if (!DeleteFolder(szFolder, fJustRemoveACLs))
                            return false;
                    }
                    piMalloc->Free(pidlFolder);
                }
                piMalloc->Release();
                piMalloc = 0;
            }
        }
    }

    if (iTodo & iRemoveWinMsiFolder)
    {
		_tprintf(TEXT("  Searching for files and folders in the %%WINDIR%%\\Installer folder\n"));

        if (!szProduct)
        {
            // delete %WINDIR%\msi
            if (GetWindowsDirectory(szFolder, sizeof(szFolder)/sizeof(TCHAR)))
            {
                lstrcat(szFolder, TEXT("\\Msi"));
                if (!DeleteFolder(szFolder, fJustRemoveACLs))
                    return false;
            }
        }

        // delete %WINDIR%\Installer
        if (!fOrphan && GetWindowsDirectory(szFolder, sizeof(szFolder)/sizeof(TCHAR)))
        {
            lstrcat(szFolder, TEXT("\\Installer"));
            if (szProduct)
            {
                lstrcat(szFolder, TEXT("\\"));
                lstrcat(szFolder, szProduct);
            }

            if (!DeleteFolder(szFolder, fJustRemoveACLs))
                return false;
        }


    }

    if (iTodo & iRemoveConfigMsiFolder)
    {
		_tprintf(TEXT("  Searching for rollback folders. . .\n"));

        // delete X:\config.msi for all local drives
        TCHAR szDrive[MAX_PATH];

        for (int iDrive = 0; iDrive < 26; iDrive++)
        {
            StringCchPrintf(szDrive, sizeof(szDrive)/sizeof(TCHAR), TEXT("%c:\\"), iDrive+'A');
            if (DRIVE_FIXED == GetDriveType(szDrive))
            {
                StringCchPrintf(szDrive, sizeof(szDrive)/sizeof(TCHAR), TEXT("%c:\\%s"), iDrive+'A', TEXT("config.msi"));
                if (!DeleteFolder(szDrive, fJustRemoveACLs))
                    return false;
            }
        }
    }
    return fError == false;
}

//==============================================================================================
// ClearPublishComponents function:
//
//   (this started out as a function that cleared info on published components
//    but now it is used as well to clean .NET and Win32 assemblies, depending
//    on stClearingNow argument)
//
bool ClearPublishComponents(HKEY hKey, const TCHAR* szRoot, TCHAR* szSubKey,
                            const TCHAR* szProduct, const stClearingWhat& stClearingNow)
{
    // enumerate all keys beneath the szSubKey key
    // subkeys are packed GUIDs of ComponentIds from PublishComponent table
    // values of the subkeys are {Qualifier}={multi-sz list of (DD + app data)}
    LONG lError,lError2;
    CRegHandle hComponentsKey;
    if ((lError = RegOpen64bitKey(hKey, szSubKey, 0, KEY_READ|KEY_SET_VALUE, &hComponentsKey)) != ERROR_SUCCESS)
    {
        if (ERROR_FILE_NOT_FOUND == lError)
            return true;
        return false;
    }

    DWORD cSubKeys=0, dwMaxSubKey=0;
    if ((lError = RegQueryInfoKey(hComponentsKey, 0, 0, 0, &cSubKeys, &dwMaxSubKey, 0, 0, 0, 0, 0, 0)) != ERROR_SUCCESS)
        return false;
    if (!cSubKeys)
        return true;

    _tprintf(TEXT("  Searching %s\\%s for %s data for the product %s. . .\n"),
             szRoot, szSubKey, stClearingNow.szDisplayWhat,
             szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    bool fError = false;

    TCHAR* szPublishedComponent = new TCHAR[++dwMaxSubKey];
    DWORD cchPublishedComponent = dwMaxSubKey;

    DWORD dwValueLen;
    DWORD dwDataLen;
    DWORD dwType;

    TCHAR* szQualifier = NULL;
    LPTSTR lpData = NULL;
    TCHAR* pchData = NULL;

    TCHAR szPublishProductCode[40];

    int iIndex = 0;
    // for each published component
    while (!fError && ((lError = RegEnumKeyEx(hComponentsKey, iIndex, szPublishedComponent, &cchPublishedComponent, 0, 0, 0, 0)) == ERROR_SUCCESS))
    {
        // open the key
        CRegHandle hPubCompKey;
        if (ERROR_SUCCESS != (lError2 = RegOpen64bitKey(hComponentsKey, szPublishedComponent, 0, KEY_READ|KEY_SET_VALUE, &hPubCompKey)))
        {
            fError = true;
            break;
        }

        // determine max value and max value data length sizes
        if (ERROR_SUCCESS != (lError2 = RegQueryInfoKey(hPubCompKey, 0, 0, 0, 0, 0, 0, 0, &dwValueLen, &dwDataLen, 0, 0)))
        {
            fError = true;
            break;
        }
        
        szQualifier = new TCHAR[++dwValueLen];
        DWORD cchQualifier = dwValueLen;
        lpData = new TCHAR[++dwDataLen];
        DWORD cbData = dwDataLen * sizeof(TCHAR);
        
        // for each qualifier value of the published component
        int iIndex2 = 0;
        bool fMatchFound;
        int csz = 0;
        while ((lError2 = RegEnumValue(hPubCompKey, iIndex2, szQualifier, &cchQualifier, 0, &dwType, (LPBYTE)lpData, &cbData)) == ERROR_SUCCESS)
        {
            // init
            fMatchFound = false;
            csz = 0;

            if (REG_MULTI_SZ == dwType && lpData)
            {
                pchData = lpData; // store beginning

                // this is a multi-sz list of DD+AppData
                // with multi-sz, end of str signified by double null
                while (!fError && *lpData)
                {
                    // sz found
                    ++csz;

                    // grab product code from Darwin Descriptor in data arg
                    if (ERROR_SUCCESS == MsiDecomposeDescriptor(lpData, szPublishProductCode, 0, 0, 0))
                    {
                        // compare product codes
                        if (0 == lstrcmpi(szProduct, szPublishProductCode))
                        {
                            // match found -- delete this value (done below)

                            --csz; // we are removing this one
                            fMatchFound = true; // found a match

                            TCHAR* pch = lpData;
                            // adjust cbData for loss of this sz
                            cbData = cbData - (lstrlen(lpData) + 1) * sizeof(TCHAR);


                            if (!(*(lpData + lstrlen(lpData) + 1)))
                            {
                                // we are at the end of the multi-sz
                                // no shuffle occurs, so must manually incr the ptr
                                lpData = lpData + lstrlen(lpData) + 1;
                                // double null terminate at this location
                                *pch = 0;
                            }
                            else
                            {
                                // must reshuffle data
                                TCHAR* pchCur = lpData;

                                // skip over current string to remove
                                pchCur = pchCur + lstrlen(pchCur) + 1;
                                while (*pchCur)
                                {
                                    // copy next sz out of multi-sz
                                    while (*pchCur)
                                        *pch++ = *pchCur++;
                                    // copy null terminator
                                    *pch++ = *pchCur++;
                                }//while haven't reached end of multi-sz (2 nulls denote end)
                                
                                // copy 2nd null terminator denoting end of multi-sz
                                *pch = *pchCur; 
                            }
                            // set the new *revised* data
                            if (ERROR_SUCCESS != (RegSetValueEx(hPubCompKey, szQualifier, 0, REG_MULTI_SZ, (LPBYTE)pchData, cbData)))
                            {
                                fError = true;
                                break;
                            }
                            _tprintf(TEXT("   Removed product's %s value %s for %s %s\n"),
                                     stClearingNow.szDisplayValue, szQualifier,
                                     stClearingNow.szDisplayWhat, szPublishedComponent);
                            g_fDataFound = true;
                        }// if product codes match
                        else
                        {
                            // continue searching
                            lpData = lpData + lstrlen(lpData) + 1;
                        }
                    }// if MsiDecomposeDescriptor succeeds
                    else
                    {
                        // somehow publishcomponent information is corrupted
                        fError = true;
                        break;
                    }
                }//while (!fError && *lpData)
                lpData = pchData;
            }//if (REG_MULTI_SZ && lpData)

            if (fMatchFound && csz == 0)
            {
                // no multi-sz's remain, therefore delete the value
                if (ERROR_SUCCESS != RegDeleteValue(hPubCompKey, szQualifier))
                {
                    fError = true; // unable to delete it
                    iIndex2++;
                }
                _tprintf(TEXT("   Removed %s value %s\n"),
                         stClearingNow.szDisplayValue, szQualifier);
                g_fDataFound = true;
            }
            else // only increment if no delete of value occurred
                iIndex2++;

            // reset sizes
            cchQualifier = dwValueLen;
            cbData = dwDataLen * sizeof(TCHAR);

        }//while RegEnumValueEx
        if (ERROR_NO_MORE_ITEMS != lError2)
        {
            fError = true;
            break;
        }

        // if the published component's key is now empty, delete the key
        DWORD dwNumValues;
        if (ERROR_SUCCESS != (lError2 == RegQueryInfoKey(hPubCompKey, 0, 0, 0, 0, 0, 0, &dwNumValues, 0, 0, 0, 0)))
        {
            fError = true;
            break;
        }
        if (0 == dwNumValues)
        {
            // key is empty
            hPubCompKey = 0;
            if (ERROR_SUCCESS != (lError2 = RegDelete64bitKey(hComponentsKey, szPublishedComponent)))
            {
                // cannot delete the key
                fError = true;
                break;
            }
            _tprintf(TEXT("   Removed %s\\%s\\%s\n"), hKey == HKEY_LOCAL_MACHINE ? TEXT("HKLM") : TEXT("HKCU"), szSubKey, szPublishedComponent);
            g_fDataFound = true;
        }
        else
            iIndex++; // only increment index if key hasn't been deleted

        cchPublishedComponent = dwMaxSubKey; // reset
    }// while RegEnumKey
    if (ERROR_NO_MORE_ITEMS != lError)
        fError = true;

    if (szQualifier)
        delete [] szQualifier;
    if (lpData)
        delete [] lpData;
    if (szPublishedComponent)
        delete [] szPublishedComponent;

    return fError == false;
}

//==============================================================================================
// ClearRollbackKey function:
//
bool ClearRollbackKey(bool fJustRemoveACLs)
{
	_tprintf(TEXT("Searching for the Windows Installer Rollback key. . .\n"));

    bool fError = false;

    if (!DeleteTree(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Rollback"), fJustRemoveACLs))
        fError = true;

    return fError == false;
}

//==============================================================================================
// ClearInProgressKey function:
//
bool ClearInProgressKey(bool fJustRemoveACLs)
{
	_tprintf(TEXT("Searching for the Windows Installer InProgress key. . .\n"));
    
	bool fError = false;

    if (!DeleteTree(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\InProgress"), fJustRemoveACLs))
        fError = true;

    return fError == false;
}

//==============================================================================================
// ClearRegistry function:
//
bool ClearRegistry(bool fJustRemoveACLs)
{
	_tprintf(TEXT("Searching for all Windows Installer registry data. . .\n"));

    bool fError = false;

    if (!ClearInProgressKey(fJustRemoveACLs))
        fError = true;

    if (!DeleteTree(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), fJustRemoveACLs))
        fError = true;

    if (!DeleteTree(HKEY_LOCAL_MACHINE, TEXT("Software\\Classes\\Installer"), fJustRemoveACLs))
        fError = true;

	if (g_fWin9X)
	{
		// always an admin on Win9X so we are never the admin running this for the other user
		if (!DeleteTree(HKEY_CURRENT_USER, TEXT("Software\\Classes\\Installer"), fJustRemoveACLs))
			fError = true;

		if (!DeleteTree(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Installer"), fJustRemoveACLs))
			fError = true;
	}
	else // WinNT
	{
		// normal user can't run msizap so we need to open the proper hive
		DWORD dwResult = ERROR_SUCCESS;
		TCHAR* szUserSid = GetCurrentUserStringSID(&dwResult);
		if (ERROR_SUCCESS == dwResult && szUserSid)
		{
			// no per-user installs as local system (S-1-5-18)
			if (0 != lstrcmpi(szUserSid, szLocalSystemSID))
			{
				CRegHandle HUserHiveKey;
				LONG lError = ERROR_SUCCESS;

				if (ERROR_SUCCESS != (lError = RegOpenKeyEx(HKEY_USERS, szUserSid, 0, KEY_READ, &HUserHiveKey)))
				{
					// inability to access hive is not considered a fatal error
					_tprintf(TEXT("Unable to open the HKEY_USERS hive for user %s. The hive may not be loaded at this time. (LastError = %d)\n"), szUserSid, lError);
				}
				else
				{
					if (!DeleteTree(HUserHiveKey, TEXT("Software\\Classes\\Installer"), fJustRemoveACLs))
						fError = true;

					if (!DeleteTree(HUserHiveKey, TEXT("Software\\Microsoft\\Installer"), fJustRemoveACLs))
						fError = true;
				}
			}
		}
		else
		{
			_tprintf(TEXT("Attempt to obtain user's SID failed with error %d\n"), dwResult);
			fError = true;
		}
	}

    return fError == false;
}

//==============================================================================================
// RemoveCachedPackage function:
//
bool RemoveCachedPackage(const TCHAR* szProduct, bool fJustRemoveACLs)
{
	_tprintf(TEXT("Searching for the product %s cached package. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    CRegHandle HUninstallKey;
    LONG lError;
    TCHAR szKey[MAX_PATH];

    StringCchPrintf(szKey, sizeof(szKey)/sizeof(TCHAR), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\%s"), szProduct);

    if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                            szKey,
                            0, KEY_READ, &HUninstallKey)) == ERROR_SUCCESS)

    {
        TCHAR szPackage[MAX_PATH];
        DWORD cbPackage = sizeof(szPackage);
        DWORD dwType;
        if (ERROR_SUCCESS == (lError = RegQueryValueEx(HUninstallKey, TEXT("LocalPackage"), 0, &dwType, (LPBYTE)szPackage, &cbPackage)))
        {
            return RemoveFile(szPackage, fJustRemoveACLs);
        }
    }


    // clean up cached database copies as per new scheme (bug #9395)
    TCHAR szProductSQUID[40];
    GetSQUID(szProduct, szProductSQUID);

    StringCchPrintf(szKey, sizeof(szKey)/sizeof(TCHAR), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\LocalPackages\\%s"), szProductSQUID);
    if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                            szKey,
                            0, KEY_READ, &HUninstallKey)) == ERROR_SUCCESS)
    {
        // enumerate all the values under the key and delete the cached databases 1 by 1

        int iValueIndex = 0;
        DWORD dwType;
        TCHAR szPackage[MAX_PATH];
        DWORD cbPackage = sizeof(szPackage);

        TCHAR szSID[cchMaxSID + sizeof(TEXT("(Managed)"))/sizeof(TCHAR)];
        DWORD cbSID = sizeof(szSID)/sizeof(TCHAR);

        while (ERROR_SUCCESS == (lError = RegEnumValue(HUninstallKey, iValueIndex++, szSID, &cbSID,
                              0, &dwType, (LPBYTE)(TCHAR*)szPackage, &cbPackage)))
        {
            if(!RemoveFile(szPackage, fJustRemoveACLs))
                return false;

            cbPackage = sizeof(szPackage);
            cbSID = sizeof(szSID)/sizeof(TCHAR);
        }

        // remove the key
        if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\LocalPackages"),
                            0, KEY_READ, &HUninstallKey)) == ERROR_SUCCESS)
        {
            if (!DeleteTree(HUninstallKey, szProductSQUID, fJustRemoveACLs))
                return false;
        }
    }

    // as per post data-user migration
    DWORD dwRet;
    StringCchPrintf(szKey, sizeof(szKey)/sizeof(TCHAR), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Products\\%s\\InstallProperties"),
        GetCurrentUserStringSID(&dwRet), szProductSQUID);
    if ( dwRet != ERROR_SUCCESS )
        return false;

    if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                            szKey,
                            0, KEY_READ, &HUninstallKey)) == ERROR_SUCCESS)
    {
        DWORD dwType;
        TCHAR szPackage[MAX_PATH];
        DWORD cbPackage = sizeof(szPackage);
        lError = RegQueryValueEx(HUninstallKey, TEXT("LocalPackage"), 0, &dwType, (LPBYTE)szPackage, &cbPackage);
        if ( lError != ERROR_SUCCESS || dwType != REG_SZ )
            return false;

        if(!RemoveFile(szPackage, fJustRemoveACLs))
            return false;
    }

    return true;
}

//==============================================================================================
// ClearPatchReferences function:
//
bool ClearPatchReferences(HKEY hRoot, HKEY hProdPatchKey, TCHAR* szPatchKey, TCHAR* szProductsKey, TCHAR* szProductSQUID)
{
    LONG lError  = ERROR_SUCCESS;
	LONG lErr    = ERROR_SUCCESS;
    bool fReturn = false;
	int iTry     = 0;

    CRegHandle hProductsKey;
    CRegHandle hPatchCompKey;
    CRegHandle hPatchKey;
	CRegHandle hCachedPatchKey;

	TCHAR* szUserSID =  NULL;
	DWORD dwRes = ERROR_SUCCESS;

    
    /**************************************
    Find all patches for particular product
    ***************************************/
    struct Patch
    {
        TCHAR  szPatchSQUID[500];
        BOOL   fUsed;
    };
    // determine number of patches, note that # patches is 1 less than number of values under key
    // keep a multi-sz string list as one.  only want patch code SQUIDS
    DWORD cPatches;
    if ((lError = RegQueryInfoKey(hProdPatchKey, 0,0,0,0,0,0,&cPatches,0,0,0,0)) != ERROR_SUCCESS)
        return false;
    Patch* pPatches = new Patch[cPatches];
    int iIndex = 0;
    TCHAR szValue[500];
    DWORD cbValue = sizeof(szValue)/sizeof(TCHAR);
    DWORD dwValueType;
    int iPatchIndex = 0;
    // fill in patch data into list array
    while ((lError = RegEnumValue(hProdPatchKey, iIndex, szValue, &cbValue, 0, &dwValueType, 0, 0)) == ERROR_SUCCESS)
    {
        if (dwValueType != REG_MULTI_SZ)
        {
            _tcscpy(pPatches[iPatchIndex].szPatchSQUID, szValue);
            pPatches[iPatchIndex++].fUsed = FALSE;
        }
        iIndex++;
        cbValue = sizeof(szValue)/sizeof(TCHAR);
    }
    if (lError != ERROR_NO_MORE_ITEMS)
        goto Return;

	szUserSID = GetCurrentUserStringSID(&dwRes);
	if (ERROR_SUCCESS != dwRes || !szUserSID)
		goto Return;

    // store number of patches in array
    cPatches = iIndex; 
    /**************************************
    Enumerate all products, searching for
    products with patches for comparison
    ***************************************/
    if ((lError = RegOpen64bitKey(hRoot, szProductsKey, 0, KEY_READ, &hProductsKey)) != ERROR_SUCCESS)
        goto Return;
    iIndex = 0;
    cbValue = sizeof(szValue)/sizeof(TCHAR);
    while  ((lError = RegEnumKeyEx(hProductsKey, iIndex, szValue, &cbValue, 0, 0, 0, 0)) == ERROR_SUCCESS)
    {
        // ignore ourselves
        if (0 != lstrcmpi(szProductSQUID, szValue))
        {
            // see if product has patches
            TCHAR rgchKeyBuf[MAX_PATH];
            StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("%s\\%s\\Patches"), szProductsKey, szValue);
            if ((lError = RegOpen64bitKey(hRoot, rgchKeyBuf, 0, KEY_READ, &hPatchCompKey)) == ERROR_SUCCESS)
            {
                /*****************************
                search patch array for matches
                for each patch
                ******************************/
                TCHAR szPatchMatch[MAX_PATH];
                DWORD cbPatchMatch = sizeof(szPatchMatch)/sizeof(TCHAR);
                LONG lError2;
                DWORD iMatchIndex = 0;
                DWORD dwType;
                while ((lError2 = RegEnumValue(hPatchCompKey, iMatchIndex, szPatchMatch, &cbPatchMatch, 0, &dwType, 0, 0)) == ERROR_SUCCESS)
                {
                    // ignore multi-sz
                    if (dwType != REG_MULTI_SZ)
                    {
                        for (int i = 0; i < cPatches; i++)
                        {
                            if (!pPatches[i].fUsed && 0 == lstrcmpi(pPatches[i].szPatchSQUID, szPatchMatch))
                            {
                                pPatches[i].fUsed = TRUE;
                                break; // found, don't continue search
                            }
                        }
                    }
                    iMatchIndex++;
                    cbPatchMatch = sizeof(szPatchMatch)/sizeof(TCHAR);
                }
                if (ERROR_NO_MORE_ITEMS != lError2)
                    goto Return;

            }
            else if (lError != ERROR_FILE_NOT_FOUND)
                goto Return;
            // else no patches
        }
        iIndex++;
        cbValue = sizeof(szValue)/sizeof(TCHAR);
    }
    if (lError != ERROR_NO_MORE_ITEMS)
        goto Return;

    /**********************************
    Delete all patches not in use from
    main "Patches" key
    ***********************************/
    TCHAR rgchPatchCodeKeyBuf[MAX_PATH] = {0};
	TCHAR rgchLocalPatch[MAX_PATH] = {0};
	DWORD dwLocalPatch = MAX_PATH;
	DWORD dwType = 0;
    for (iPatchIndex = 0; iPatchIndex < cPatches; iPatchIndex++)
    {
        if (pPatches[iPatchIndex].fUsed == FALSE)
        {
            // remove patchcode key under Patches
            StringCchPrintf(rgchPatchCodeKeyBuf, sizeof(rgchPatchCodeKeyBuf)/sizeof(TCHAR), TEXT("%s\\%s"), szPatchKey, pPatches[iPatchIndex].szPatchSQUID);
            if (!DeleteTree(hRoot, rgchPatchCodeKeyBuf, false))
                goto Return;

			// remove cached patch
			//  try1 = old location HKLM\Software\Microsoft\Windows\CurrentVersion\Installer\Patches
			//  try2 = new location HKLM\Software\Microsoft\Windows\CurrentVersion\Installer\UserData\{user sid}\Patches
			for (iTry = 0; iTry < 2; iTry++)
			{
				if (0 == iTry)
				{
					StringCchPrintf(rgchPatchCodeKeyBuf, sizeof(rgchPatchCodeKeyBuf)/sizeof(TCHAR), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Patches\\%s"), pPatches[iPatchIndex].szPatchSQUID);
				}
				else
				{
					StringCchPrintf(rgchPatchCodeKeyBuf, sizeof(rgchPatchCodeKeyBuf)/sizeof(TCHAR), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Patches\\%s"), szUserSID, pPatches[iPatchIndex].szPatchSQUID);
				}

				if ((lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgchPatchCodeKeyBuf, 0, KEY_READ, &hCachedPatchKey)) != ERROR_SUCCESS)
				{
					if (ERROR_FILE_NOT_FOUND != lErr)
						goto Return;
				}
				else 
				{
					// read LocalPackage value
               dwLocalPatch = sizeof(rgchLocalPatch);
					if (ERROR_SUCCESS == (lErr = RegQueryValueEx(hCachedPatchKey, TEXT("LocalPackage"), NULL, &dwType, (BYTE*)rgchLocalPatch, &dwLocalPatch))
						&& REG_SZ == dwType && *rgchLocalPatch != 0)
					{
						RemoveFile(rgchLocalPatch, false);
					}
				}
				
				hCachedPatchKey = 0;

				DeleteTree(HKEY_LOCAL_MACHINE, rgchPatchCodeKeyBuf, false);
			}
        }
    }

    /************************
    clean-up empty keys
    *************************/
    DWORD dwNumKeys;
    if ((lError = RegOpen64bitKey(hRoot, szPatchKey, 0, KEY_READ, &hPatchKey)) != ERROR_SUCCESS)
        goto Return;
    if ((lError = RegQueryInfoKey(hPatchKey, 0, 0, 0, &dwNumKeys, 0, 0, 0, 0, 0, 0, 0)) != ERROR_SUCCESS)
        goto Return;
    if (0 == dwNumKeys)
    {
        // key is empty
        hPatchKey = 0; // enable delete
        DeleteTree(hRoot, szPatchKey, false);
    }

	TCHAR szInstallerPatchesKey[MAX_PATH];
	for (iTry = 0; iTry < 2; iTry++)
	{
		if (iTry == 0)
		{
			// try old location
			StringCchPrintf(szInstallerPatchesKey, sizeof(szInstallerPatchesKey)/sizeof(TCHAR), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Patches"));
		}
		else
		{
			// try new location Installer 2.0+
			StringCchPrintf(szInstallerPatchesKey, sizeof(szInstallerPatchesKey)/sizeof(TCHAR), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Patches"), szUserSID);
		}

		if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, szInstallerPatchesKey, 0, KEY_READ, &hPatchKey)) == ERROR_SUCCESS)
		{
			dwNumKeys = 0;
			if ((lError = RegQueryInfoKey(hPatchKey, 0, 0, 0, &dwNumKeys, 0, 0, 0, 0, 0, 0, 0)) == ERROR_SUCCESS
				&& 0 == dwNumKeys)
			{
				// key is empty
				hPatchKey = 0; // enable delete
				if (!DeleteTree(HKEY_LOCAL_MACHINE, szInstallerPatchesKey, false))
					goto Return;
			}
		}
	}

    fReturn = true;

Return:
    delete [] pPatches;
    return fReturn;
}

//==============================================================================================
// ClearUpgradeProductReference function:
//
bool ClearUpgradeProductReference(HKEY HRoot, const TCHAR* szSubKey, const TCHAR* szProductSQUID)
{
	_tprintf(TEXT("  Searching for product %s upgrade codes in %s...\n"), szProductSQUID, szSubKey);

    if ( szProductSQUID && *szProductSQUID && 
         IsProductInstalledByOthers(szProductSQUID) )
        return true;

    // upgrade codes stored as subkeys of UpgradeKey on HKLM and HKCU
    // product codes (SQUIDs) are values of particular upgrade code
    // product can only have 1 upgrade
    CRegHandle HKey;
    LONG lError;
    if ((lError = RegOpen64bitKey(HRoot, szSubKey, 0, KEY_READ, &HKey)) != ERROR_SUCCESS)
    {
        if (ERROR_FILE_NOT_FOUND == lError)
            return true;  // registry key not there
        else
        {
            _tprintf(TEXT("   Could not open %s\\%s"), HRoot == HKEY_LOCAL_MACHINE ? TEXT("HKLM") : TEXT("HKCU"), szSubKey);
            return false;
        }
    }

    TCHAR szName[500];
    DWORD cchName = sizeof(szName)/sizeof(TCHAR);
    unsigned int iIndex = 0;
    BOOL fUpgradeFound = FALSE;
    // for each upgrade code
    while ((lError = RegEnumKeyEx(HKey, iIndex, szName, &cchName, 0, 0, 0, 0)) == ERROR_SUCCESS)
    {
        // open sub key for enumeration
        CRegHandle HSubKey;
        if ((lError = RegOpen64bitKey(HKey, szName, 0, KEY_READ|KEY_SET_VALUE, &HSubKey)) != ERROR_SUCCESS)
            return false;

        // enumerate values of key
        long lError2;
        TCHAR szValue[500];
        DWORD cbValue = sizeof(szValue)/sizeof(TCHAR);
        unsigned int iValueIndex = 0;
        // for each product code
        while ((lError2 = RegEnumValue(HSubKey, iValueIndex, szValue, &cbValue, 0, 0, 0, 0)) == ERROR_SUCCESS)
        {
            // compare value to productSQUID
            if (0 == lstrcmpi(szValue, szProductSQUID))
            {
                // same, reference to product so remove the reference
                if ((lError2 = RegDeleteValue(HSubKey, szValue)) != ERROR_SUCCESS)
                    return false;
                _tprintf(TEXT("   Removed upgrade code '%s' at %s\\%s\n"), szValue, HRoot == HKEY_LOCAL_MACHINE ? TEXT("HKLM") : TEXT("HKCU"), szSubKey);
                // found it, this is the only one so we can break here and should break out of key entirely
                // since product allowed to have only one upgrade
                fUpgradeFound = TRUE;
                g_fDataFound = true;
                break;
            }
            iValueIndex++;
            cbValue = sizeof(szValue)/sizeof(TCHAR);
        }
        if (lError2 != ERROR_NO_MORE_ITEMS && lError2 != ERROR_SUCCESS)
            return false;
        // if no more values, key is empty so delete
        DWORD dwNumValues;
        if (ERROR_SUCCESS != RegQueryInfoKey(HSubKey, 0, 0, 0, 0, 0, 0, &dwNumValues, 0, 0, 0, 0))
            return false;
        if (0 == dwNumValues)
        {
            HSubKey = 0; // enable delete
            RegDelete64bitKey(HKey, szName);
			g_fDataFound = true;
        }
        if (fUpgradeFound)
            break; // product can only have 1 upgrade
        iIndex++;
        cchName = sizeof(szName)/sizeof(TCHAR);
    }

    if (lError != ERROR_NO_MORE_ITEMS && lError != ERROR_SUCCESS)
        return false;
    // if no more subkeys, UpgradeCodes key is empty so delete 
    DWORD dwNumKeys;
    if (ERROR_SUCCESS != RegQueryInfoKey(HKey, 0, 0, 0, &dwNumKeys, 0, 0, 0, 0, 0, 0, 0))
        return false;
    if (0 == dwNumKeys)
    {
        HKey = 0; // enable delete
        RegDelete64bitKey(HRoot, szSubKey);
		g_fDataFound = true;
    }
    return true;
}


//==============================================================================================
// ClearProduct function:
//
bool ClearProduct(int iTodo, const TCHAR* szProduct, bool fJustRemoveACLs, bool fOrphan)
{
    bool fError = false;
	LONG lError = ERROR_SUCCESS;

    fError = RemoveCachedPackage(szProduct, fJustRemoveACLs) != true;

    // remove uninstall key info

    if (!ClearUninstallKey(fJustRemoveACLs, szProduct))
        fError = true;


    // remove published info from all possible keys

    struct Key
    {
        const TCHAR* szKey;
        HKEY hRoot;
		bool fUserHive;
        const TCHAR* szRoot;
		const TCHAR* szInfo;
    };

	DWORD dwRes = ERROR_SUCCESS;
	TCHAR* szUserSID = GetCurrentUserStringSID(&dwRes);
	if (dwRes != ERROR_SUCCESS || !szUserSID)
	{
		_tprintf(TEXT("Unable to obtain the current user's SID (LastError = %d)"), dwRes);
		fError = true;
	}
	else
	{
		CRegHandle HUserHiveKey;
		bool fUserHiveAvailable = true;

		if (!g_fWin9X)
		{
			// only concerned about HKCU access via HKEY_USERS on NT
			if (ERROR_SUCCESS != (lError = RegOpenKeyEx(HKEY_USERS, szUserSID, 0, KEY_READ, &HUserHiveKey)))
			{
				_tprintf(TEXT("Unable to open the HKEY_USERS hive for user %s. HKCU data for this user will not be modified.  The hive may not be loaded at this time. (LastError = %d)\n"), szUserSID, lError);
				fUserHiveAvailable = false;
			}
		}

		TCHAR szPerUserGlobalConfig[MAX_PATH];
		StringCchPrintf(szPerUserGlobalConfig, sizeof(szPerUserGlobalConfig)/sizeof(TCHAR), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s"), szUserSID);

		TCHAR szPerMachineGlobalConfig[MAX_PATH] = {0};
		StringCchPrintf(szPerMachineGlobalConfig, sizeof(szPerMachineGlobalConfig)/sizeof(TCHAR), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s"), szLocalSystemSID);

		Key keysNT[] = 
			{szPerUserGlobalConfig,                                          HKEY_LOCAL_MACHINE,  false, g_szHKLM, TEXT("user's global config"),
			szPerMachineGlobalConfig,                                        HKEY_LOCAL_MACHINE,  false, g_szHKLM, TEXT("per-machine global config"),
			TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), HKEY_LOCAL_MACHINE,  false, g_szHKLM, TEXT("old global config"), // old location
			TEXT("Software\\Classes\\Installer"),                            HKEY_LOCAL_MACHINE,  false, g_szHKLM, TEXT("per-machine"),
			TEXT("Software\\Classes\\Installer"),                            HUserHiveKey,   true, g_szHKCU, TEXT("old per-user"),
			TEXT("Software\\Microsoft\\Installer"),                          HUserHiveKey,   true, g_szHKCU, TEXT("per-user"),
			0,0,0,0};
		Key keys9X[] = 
			{szPerUserGlobalConfig,                                          HKEY_LOCAL_MACHINE,  false, g_szHKLM, TEXT("user's global config"),
			TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), HKEY_LOCAL_MACHINE,  false, g_szHKLM, TEXT("global config"), // old location
			TEXT("Software\\Classes\\Installer"),                            HKEY_LOCAL_MACHINE,  false, g_szHKLM, TEXT("per-machine"),
			TEXT("Software\\Classes\\Installer"),                            HKEY_CURRENT_USER,   true, g_szHKCU, TEXT("old per-user"),
			TEXT("Software\\Microsoft\\Installer"),                          HKEY_CURRENT_USER,   true, g_szHKCU, TEXT("per-user"),
			0,0,0,0};
		Key *k = g_fWin9X ? keys9X : keysNT;


		TCHAR szProductSQUID[40];
		GetSQUID(szProduct, szProductSQUID);

		TCHAR rgchKeyBuf[MAX_PATH];
		for ( ; k->szKey; k++ )
		{
			if (k->fUserHive && !fUserHiveAvailable)
			{
				// can't access the user's hive so we can't delete any per-user data
				_tprintf(TEXT("Skipping search of %s location for product %s data since the registry hive is not available.\n"), k->szInfo, szProduct);
				continue;
			}

			if (k->fUserHive && 0 == lstrcmpi(szUserSID, szLocalSystemSID))
			{
				// no per-user installs as local system
				continue;
			}

			_tprintf(TEXT("Searching %s location for product %s data. . .\n"), k->szInfo, szProduct);

			// NOTE: patch and upgrades checks must come first or else we lose them
			// only remove upgrade and patch info if removing product (not just ACLs)
			// only remove Published Components information if removing product (not just ACLs)
			if (!fJustRemoveACLs)
			{
				// upgrade codes haven't moved to per-user locations
				TCHAR* szUserData = _tcsstr(k->szKey, TEXT("\\UserData"));  // a sophisticated 'strstr'
				if ( szUserData )
				{
					lstrcpyn(rgchKeyBuf, k->szKey, int(szUserData - k->szKey) + 1);
					lstrcat(rgchKeyBuf, TEXT("\\UpgradeCodes"));
				}
				else
					StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("%s\\UpgradeCodes"), k->szKey);
				if (!ClearUpgradeProductReference(k->hRoot, rgchKeyBuf, szProductSQUID))
					fError = true;

				// only remove patch refs if product has patches (i.e. Patches key under ProductCode)
				StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("%s\\Products\\%s\\Patches"), k->szKey, szProductSQUID);

				_tprintf(TEXT("  Searching for patches for product %s in %s\n"), szProductSQUID, rgchKeyBuf);

				CRegHandle hProdPatchesKey;
				if ((lError = RegOpenKeyEx(k->hRoot, rgchKeyBuf, 0, KEY_READ, &hProdPatchesKey)) == ERROR_SUCCESS)
				{
					// product has patches
					TCHAR rgchProdKeyBuf[MAX_PATH];
					StringCchPrintf(rgchProdKeyBuf, sizeof(rgchProdKeyBuf)/sizeof(TCHAR), TEXT("%s\\Products"), k->szKey);
					StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("%s\\Patches"), k->szKey);
					if (!ClearPatchReferences(k->hRoot, hProdPatchesKey, rgchKeyBuf, rgchProdKeyBuf, szProductSQUID))
						fError = true; 
				}
				else if (lError != ERROR_FILE_NOT_FOUND)
				{
					// ERROR_FILE_NOT_FOUND means product does not have patches
					_tprintf(TEXT("   Error opening %s\\%s\n"), k->hRoot == HKEY_LOCAL_MACHINE ? TEXT("HKLM") : TEXT("HKCU"), rgchKeyBuf);
					fError = true;
				}

				// HKLM\Software\Microsoft\Windows\CurrentVersion\Installer\[UserData\<User ID>\]Components is not a PublishComponents key
				// ('_tcsstr' is a sophisticated 'strstr')
				if (k->hRoot != HKEY_LOCAL_MACHINE || !_tcsstr(k->szKey, TEXT("Software\\Microsoft")))
				{
					for (int i = iePublishedComponents; i <= ieWin32Assemblies; i++)
					{
						StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("%s\\%s"), k->szKey,
									rgToClear[i].szRegSubkey);
						if (!ClearPublishComponents(k->hRoot, k->szRoot, rgchKeyBuf,
															 szProduct, rgToClear[i]))
							fError = true;
					}
				}
			}

			StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("%s\\Products\\%s"), k->szKey, szProductSQUID);
			_tprintf(TEXT("  Searching %s\\%s for product data. . .\n"), k->szRoot, rgchKeyBuf); 
			if (!DeleteTree(k->hRoot, rgchKeyBuf, fJustRemoveACLs))
				fError = true;

			StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("%s\\Features\\%s"), k->szKey, szProductSQUID);
			_tprintf(TEXT("  Searching %s\\%s for product feature data. . .\n"), k->szRoot, rgchKeyBuf); 
			if (!DeleteTree(k->hRoot, rgchKeyBuf, fJustRemoveACLs))
				fError = true;

		}

		// remove per-user managed information
		// patch and upgrades checks must come first or else we lose them

		_tprintf(TEXT("Searching for product %s in per-user managed location. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

		if (!fJustRemoveACLs)
		{
			StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("%s\\Managed\\%s\\Installer\\UpgradeCodes"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), szUserSID);
			if (!ClearUpgradeProductReference(HKEY_LOCAL_MACHINE, rgchKeyBuf, szProductSQUID))
				fError = true;

			// only remove patch refs if product has patches (i.e. Patches key under ProductCode)
			StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("%s\\Managed\\%s\\Installer\\Products\\%s\\Patches"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), szUserSID, szProductSQUID);
			_tprintf(TEXT("  Searching for patches for product %s in %s\n"), szProductSQUID, rgchKeyBuf);

			CRegHandle hProdPatchesKey;
            
			// ERROR_FILE_NOT_FOUND means product does not have patches
			if ((lError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgchKeyBuf, 0, KEY_READ, &hProdPatchesKey)) == ERROR_SUCCESS)
			{
				// product has patches
				TCHAR rgchProdKeyBuf[MAX_PATH];
				StringCchPrintf(rgchProdKeyBuf, sizeof(rgchProdKeyBuf)/sizeof(TCHAR), TEXT("%s\\Managed\\%s\\Installer\\Products"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), szUserSID);
				StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("%s\\Managed\\%s\\Installer\\Patches"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), szUserSID);
				if (!ClearPatchReferences(HKEY_LOCAL_MACHINE, hProdPatchesKey, rgchKeyBuf, rgchProdKeyBuf, szProductSQUID))
					fError = true; 
			}
			else if (lError != ERROR_FILE_NOT_FOUND)
			{
				_tprintf(TEXT("   Error opening HKLM\\%s\n"), rgchKeyBuf);
				fError = true;
			}

			// remove published component information
			for (int i = iePublishedComponents; i <= ieWin32Assemblies; i++)
			{
				StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("%s\\Managed\\%s\\Installer\\%s"),
							TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"),
							szUserSID, rgToClear[i].szRegSubkey);
				if (!ClearPublishComponents(HKEY_LOCAL_MACHINE, g_szHKLM, rgchKeyBuf,
													 szProduct, rgToClear[i]))
					fError = true;
			}
		}
		StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("%s\\Managed\\%s\\Installer\\Products\\%s"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), szUserSID, szProductSQUID);
		_tprintf(TEXT("  Searching %s\\%s for product data. . .\n"), TEXT("HKLM"), rgchKeyBuf); 
		if (!DeleteTree(HKEY_LOCAL_MACHINE, rgchKeyBuf, fJustRemoveACLs))
			fError = true;

		StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("%s\\Managed\\%s\\Installer\\Features\\%s"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), szUserSID, szProductSQUID);
		_tprintf(TEXT("  Searching %s\\%s for product feature data. . .\n"), TEXT("HKLM"), rgchKeyBuf); 
		if (!DeleteTree(HKEY_LOCAL_MACHINE, rgchKeyBuf, fJustRemoveACLs))
			fError = true;

		// remove component clients and feature usage metrics
		StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Products\\%s"), szProductSQUID);
		if (!DeleteTree(HKEY_LOCAL_MACHINE, rgchKeyBuf, fJustRemoveACLs))
			fError = true;

		if (!fJustRemoveACLs && !fOrphan && !ClearSharedDLLCounts(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components"), szProductSQUID))
			fError = true;

		StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Products\\%s"), szUserSID, szProductSQUID);
		if (dwRes == ERROR_SUCCESS && !DeleteTree(HKEY_LOCAL_MACHINE, rgchKeyBuf, fJustRemoveACLs))
			fError = true;

		StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Components"), szUserSID);
		if (dwRes == ERROR_SUCCESS && !fJustRemoveACLs && !fOrphan && !ClearSharedDLLCounts(rgchKeyBuf, szProductSQUID))
			fError = true;

		if (dwRes == ERROR_SUCCESS && !ClearProductClientInfo(rgchKeyBuf, szProductSQUID, fJustRemoveACLs))
			fError = true;

		if (!ClearProductClientInfo(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components"), szProductSQUID, fJustRemoveACLs))
			fError = true;

		int iFolders = iRemoveUserProfileFolder|iRemoveWinMsiFolder;
		if (fJustRemoveACLs)
			iFolders |= iOnlyRemoveACLs;
		if (!ClearFolders(iFolders, szProduct, fOrphan))
			fError = true;
	}

    return fError == false;
}

//==============================================================================================
// DisplayHelp function:
//  Outputs command line options for MsiZap
//
void DisplayHelp(bool fVerbose)
{
    // the O option, which works similar to the T option is undocumented at this time
    // it was added as an option for OEMs.
    _tprintf(TEXT("Copyright (C) Microsoft Corporation.  All rights reserved.\n")
             TEXT("MSIZAP - Zaps (almost) all traces of Windows Installer data from your machine.\n")
             TEXT("\n")
             TEXT("Usage: msizap T[WA!] {product code}\n")
             TEXT("       msizap T[WA!] {msi package}\n")
             TEXT("       msizap *[WA!] ALLPRODUCTS\n")
             TEXT("       msizap PWSA?!\n")
             TEXT("\n")
             TEXT("       * = remove all Windows Installer folders and regkeys;\n")
             TEXT("           adjust shared DLL counts; stop Windows Installer service\n")
             TEXT("       T = remove all info for given product code\n")
             TEXT("       P = remove In-Progress key\n")
             TEXT("       S = remove Rollback Information\n")
             TEXT("       A = for any specified removal, just change ACLs to Admin Full Control\n")
             TEXT("       W = for all users (by default, only for the current user)\n")
             TEXT("       G = remove orphaned cached Windows Installer data files (for all users)\n")
             TEXT("       ? = verbose help\n")
             TEXT("       ! = force 'yes' response to any prompt\n")
             TEXT("\n")
             TEXT("CAUTION: Products installed by the Windows Installer may fail to\n")
             TEXT("         function after using msizap\n")
			 TEXT("\n")
			 TEXT("NOTE: MsiZap requires admin privileges to run correctly. The W option requires that the profiles for all of the users be loaded.\n")
             );

    if (fVerbose)
    {
        _tprintf(TEXT("\n")
             TEXT("* Any published icons will be removed.\n")
             TEXT("\n")
             TEXT("* The following keys will be deleted:\n")
             TEXT("  HKCU\\Software\\Classes\\Installer\n")
             TEXT("  HKCU\\Software\\Microsoft\\Installer\n")
             TEXT("  HKLM\\Software\\Classes\\Installer\n")
             TEXT("  HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Installer\n")
             TEXT(" On NT:\n")
             TEXT("  HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\<User ID>\n")
             TEXT("  HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{ProductCode} - only if there are no more installations of {ProductCode}\n")
             TEXT(" On Win9x:\n")
             TEXT("  HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\CommonUser\n")
             TEXT("  HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{ProductCode}\n")
             TEXT("\n")
             TEXT("* Shared DLL refcounts for files refcounted by the Windows Installer will be adjusted.\n")
             TEXT("\n")
             TEXT("* The following folders will be deleted:\n")
             TEXT("  %%USERPROFILE%%\\MSI\n")
             TEXT("  {AppData}\\Microsoft\\Installer\n")
             TEXT("  %%WINDIR%%\\MSI\n")
             TEXT("  %%WINDIR%%\\Installer\n")
             TEXT("  X:\\config.msi (for each local drive)\n")
             TEXT("\n")
             TEXT("Notes/Warnings: MsiZap blissfully ignores ACL's if you're an Admin.\n")
            );
    }
}

//==============================================================================================
// SetPlatformFlags function:
//  Initializes the global Win9X & WinNT64 flag variables with the correct OS information
//
void SetPlatformFlags(void)
{
    // figure out what OS wer're running on
    OSVERSIONINFO osviVersion;
    osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osviVersion); // fails only if size set wrong
    if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        g_fWin9X = true;
    g_iMajorVersion = osviVersion.dwMajorVersion;
#ifdef _WIN64
    g_fWinNT64 = true;
#else
    g_fWinNT64 = false;
    if ( osviVersion.dwPlatformId == VER_PLATFORM_WIN32_NT &&
         (osviVersion.dwMajorVersion > 5 ||
         (osviVersion.dwMajorVersion == 5 && osviVersion.dwMinorVersion >= 1)) )
    {
        TCHAR rgchBuffer[MAX_PATH+1];
        HMODULE hModule = LoadLibrary(TEXT("kernel32.dll"));
        if( hModule == NULL )
        {
            StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR),
                     TEXT("MsiZap warning: failed to load Kernel32.dll, ")
                     TEXT("so we cannot access IsWow64Process API. ")
                     TEXT("GetLastError returned %d\n"),
                     GetLastError());
            OutputDebugString(rgchBuffer);
            return;
        }

        typedef BOOL(WINAPI *pIsWow64Process)(HANDLE hProcess, PBOOL Wow64Process);
        pIsWow64Process pFunc = (pIsWow64Process)GetProcAddress(hModule, "IsWow64Process");
        if( pFunc == NULL )
        {
            StringCchPrintf(rgchBuffer, sizeof(rgchBuffer)/sizeof(TCHAR),
                     TEXT("MsiZap info: failed to get pointer to IsWow64Process. ")
                     TEXT("GetLastError returned %d\n"),
                     GetLastError());
            OutputDebugString(rgchBuffer);
            FreeLibrary(hModule);
            return;
        }

        BOOL fRet = FALSE;
        pFunc(GetCurrentProcess(), &fRet);
        g_fWinNT64 = fRet ? true : false;
    }
#endif // _WIN64
}

//==============================================================================================
// ReadInUsers function:
//
bool ReadInUsers()
{
    if ( !g_fWin9X )
    {
        CRegHandle hUserDataKey(0);
        long lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE,
                              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData"),
                              0, KEY_READ, &hUserDataKey);
        DWORD cUsers = 0;
        if ( hUserDataKey )
            lError = RegQueryInfoKey(hUserDataKey, 0, 0, 0, &cUsers, 0, 0, 0, 0, 0, 0, 0);

        CRegHandle hManagedUserKey(0);
        lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE,
                              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Managed"),
                              0, KEY_READ, &hManagedUserKey);
        DWORD cManagedUsers = 0;
        if ( hManagedUserKey )
            lError = RegQueryInfoKey(hManagedUserKey, 0, 0, 0, &cManagedUsers, 0, 0, 0, 0, 0, 0, 0);

        int cSIDs = cUsers + cManagedUsers + 1 + 1; // one for the machine and one for the terminating NULL
        g_rgpszAllUsers = new TCHAR* [cSIDs];
        if ( !g_rgpszAllUsers )
            return false;

        g_rgpszAllUsers[0] = _tcsdup(szLocalSystemSID);  // a sophisticated 'strdup'
        for ( int i = 1; i < cSIDs; i++ )
            g_rgpszAllUsers[i] = NULL;
        int iArrayIndex = 1;

        int iIndex;
        TCHAR szUser[cchMaxSID];
        DWORD cchUser = sizeof(szUser)/sizeof(TCHAR);
        if ( cUsers )
            for ( iIndex = 0;
                  (lError = RegEnumKeyEx(hUserDataKey, iIndex,
                                         szUser, &cchUser, 0, 0, 0, 0)) == ERROR_SUCCESS;
                  iIndex++, iArrayIndex++, cchUser = sizeof(szUser)/sizeof(TCHAR) )
            {
                g_rgpszAllUsers[iArrayIndex] = _tcsdup(szUser);  // a sophisticated 'strdup'
            }

        if ( cManagedUsers )
            for ( iIndex = 0;
                  (lError = RegEnumKeyEx(hManagedUserKey, iIndex,
                                         szUser, &cchUser, 0, 0, 0, 0)) == ERROR_SUCCESS;
                  iIndex++, iArrayIndex++, cchUser = sizeof(szUser)/sizeof(TCHAR) )
            {
                g_rgpszAllUsers[iArrayIndex] = _tcsdup(szUser);  // a sophisticated 'strdup'
            }
    }
    else
    {
        g_rgpszAllUsers = new TCHAR* [2];
        if ( !g_rgpszAllUsers )
            return false;
        g_rgpszAllUsers[0] = _tcsdup(TEXT("CommonUser"));  // a sophisticated 'strdup'
        g_rgpszAllUsers[1] = NULL;
    }

    return true;
}

//==============================================================================================
// DoTheJob function:
//
bool DoTheJob(int iTodo, const TCHAR* szProduct)
{
	_tprintf(TEXT("MsiZapInfo: Performing operations for user %s\n"), GetCurrentUserStringSID(NULL));

    bool fError = false;

    if ((iTodo & iAdjustSharedDLLCounts) && ((iTodo & iOnlyRemoveACLs) == 0))
    {
        TCHAR rgchKeyBuf[MAX_PATH];
        DWORD dwRes;
        StringCchPrintf(rgchKeyBuf, sizeof(rgchKeyBuf)/sizeof(TCHAR), 
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Components"),
            GetCurrentUserStringSID(&dwRes));
        if ( dwRes != ERROR_SUCCESS )
            fError = true;
        else if (!ClearSharedDLLCounts(rgchKeyBuf))
            fError = true;

        if (!ClearSharedDLLCounts(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components")))
            fError = true;
    }
    
    if (iTodo & iRemoveAllRegKeys)
    {
        if (ClearRegistry((iTodo & iOnlyRemoveACLs) != 0) && ClearUninstallKey((iTodo & iOnlyRemoveACLs) != 0))
        {
            OutputDebugString(TEXT("Registry data cleared.\r\n"));
            if (iTodo & iOnlyRemoveACLs)
                _tprintf(TEXT("Registry ACLs cleared.\n"));
            else
                _tprintf(TEXT("Registry data cleared.\n"));
        }
        else
            fError = true;
    }
    else if ((iTodo & iRemoveInProgressRegKey) != 0)
    {
        if (!ClearInProgressKey((iTodo & iOnlyRemoveACLs) != 0))
            fError = true;
    }

    if ((iTodo & iRemoveUninstallKey) != 0)
    {
        if (!ClearUninstallKey((iTodo & iOnlyRemoveACLs) != 0))
            fError = true;
    }

    if ((iTodo & iRemoveRollback) != 0)
    {
        if (!ClearFolders(iTodo, szProduct, false /*fOrphan*/)) // del config.msi from all drives
			fError = true;
        if (!ClearRollbackKey((iTodo & iOnlyRemoveACLs) != 0))
            fError = true;
    }

    if ((iTodo & iRemoveAllFolders) == iRemoveAllFolders)
    {
        if (ClearFolders(iTodo, szProduct, false /*fOrphan*/))
		{
            OutputDebugString(TEXT("Folders cleared.\r\n"));
            if (iTodo & iOnlyRemoveACLs)
                _tprintf(TEXT("Folder ACLs cleared.\n"));
            else
                _tprintf(TEXT("Folders cleared.\n"));
		}
		else
			fError = true;
    }

    if (iTodo & iStopService)
    {
        if (!g_fWin9X && !StopService())
            fError = true;
    }

    if (((iTodo & iRemoveProduct) || (iTodo & iOrphanProduct)) && szProduct)
        if (!ClearProduct(iTodo, szProduct, (iTodo & iOnlyRemoveACLs) != 0, (iTodo & iOrphanProduct) ? true : false /*fOrphan*/))
            fError = true;

    if ( (iTodo & iRemoveGarbageFiles) == iRemoveGarbageFiles )
        if ( !ClearGarbageFiles() )
            fError = true;

    return !fError;
}


//==============================================================================================
// MAIN FUNCTION
//
extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
    unsigned int iTodo = 0;
    bool fVerbose = false;

    TCHAR* szProduct = 0;

    if (argc == 3 || argc == 2)
    {
        TCHAR ch;
        while ((ch = *(argv[1]++)) != 0)
        {
            switch (ch | 0x20)
            {
            case '*': iTodo |= iRemoveAllNonStateData | iRemoveInProgressRegKey | iRemoveRollback;break;
            case '!': iTodo |= iForceYes;                                                         break;
            case 'f': _tprintf(TEXT("Option 'F' is no longer supported. Action can be accomplished with remove all.\n"));        break;
            case 'r': _tprintf(TEXT("Option 'R' is no longer supported. Action can be accomplished with remove all.\n"));        break;
            case 'a': iTodo |= iOnlyRemoveACLs;                                                   break;
            case 'p': iTodo |= iRemoveInProgressRegKey;                                           break;
            case 's': iTodo |= iRemoveRollback;                                                   break;
            case 'v': _tprintf(TEXT("Option 'V' is no longer supported. Action can be accomplished with remove all.\n"));        break;
            case 'u': _tprintf(TEXT("Option 'U' is no longer supported. Action can be accomplished with remove all.\n"));        break;
            case 'n': _tprintf(TEXT("Option 'N' is no longer supported. Action can be accomplished with remove all.\n"));        break;
            case 't': iTodo |= iRemoveProduct;                                                    break;
            case 'o': iTodo |= iOrphanProduct;                                                    break;
            case 'w': iTodo |= iForAllUsers;                                                      break;
            case 'g': iTodo |= iRemoveGarbageFiles;                                                      break;
            case '?': fVerbose = true;                                                            // fall through
            default:
                DisplayHelp(fVerbose);
                return 1;
            }
        }

        if (argc == 3)
        {
            szProduct = argv[2];
            if (!IsGUID(szProduct))
            {
                if (0 == _tcsicmp(szProduct, szAllProductsArg) && ((iTodo & iRemoveAllNonStateData) == iRemoveAllNonStateData))
                {
                    // REMOVE ALL
                    szProduct = 0; // reset
                }
                else if ((iTodo & iRemoveAllNonStateData) == iRemoveAllNonStateData)
                {
                    // attempt to REMOVEALL w/out ALLPRODUCTS arg
                    DisplayHelp(fVerbose);
                    return 1;
                }
                else
                {
                    // assume msi package and attempt to open
                    UINT iStat;
                    PMSIHANDLE hDatabase = 0;
                    if (ERROR_SUCCESS == (iStat = MsiOpenDatabase(argv[1], TEXT("MSIDBOPEN_READONLY"), &hDatabase)))
                    {
                        // zapping product using msi - maybe, must get product code first
                        PMSIHANDLE hViewProperty = 0;
                        if (ERROR_SUCCESS == (iStat = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Value` FROM `Property` WHERE `Property`='ProductCode'"), &hViewProperty)))
                        {
                            MsiViewExecute(hViewProperty, 0);
                            szProduct = new TCHAR[40];
                            DWORD cchProduct = 40;
                            PMSIHANDLE hProperty = 0;
                            if (ERROR_SUCCESS == (iStat = MsiViewFetch(hViewProperty, &hProperty)))
                                MsiRecordGetString(hProperty, 1, szProduct, &cchProduct);
                        }
                    }
                    if (iStat != ERROR_SUCCESS)
                    {
                        DisplayHelp(fVerbose);
                        return 1;
                    }
                }
            }
            else if (iTodo & iRemoveAllNonStateData)
            {
                DisplayHelp(fVerbose);
                return 1;
            }
        }
        else if (iTodo & ~(iRemoveRollback | iOnlyRemoveACLs | iRemoveInProgressRegKey | iForceYes | iRemoveGarbageFiles))
        {
            // verify correct usage of 2 args -- only with installer state data
            DisplayHelp(fVerbose);
            return 1;
        }
    }
    else
    {
		// equivalent of msizap.exe with no args -- this is okay, maps to msizap ?
        DisplayHelp(false);
        return 0; // exit
    }

    SetPlatformFlags();

	// must be admin to run msizap for it to work properly (non-admin users generally do not have sufficient
	// permissions to modify files or change ownership on files)
	// NOTE: SetPlatformFlags must come before IsAdmin check!
	if (!IsAdmin())
	{
		_tprintf(TEXT("Administrator privileges are required to run MsiZap.\n"));
		return 1; // improper use
	}

    // if all of these are set then we'll prompt to confirm(unless we're told not to prompt)
	// no need to prompt if just adjusting ACLs
    const int iTodoRequiringPrompt = iRemoveAllFolders | iRemoveAllRegKeys | iAdjustSharedDLLCounts;

    if (!(iTodo & iForceYes) && !(iTodo & iOnlyRemoveACLs) && ((iTodo & iTodoRequiringPrompt) == iTodoRequiringPrompt))
    {
        _tprintf(TEXT("Do you want to delete all Windows installer configuration data? If you do, some programs might not run. (Y/N)?"));
        int i = getchar();
        if ((i != 'Y') && (i != 'y'))
        {
            _tprintf(TEXT("Aborted.\n"));
            return 1;
        }
    }

    bool fError = false;

    LoadSpecialFolders(iTodo);

    if ( iTodo & iForAllUsers )
    {
        fError = !ReadInUsers();
        for ( g_iUserIndex = 0; !fError && g_rgpszAllUsers[g_iUserIndex]; g_iUserIndex++ )
        {
            if ( iTodo & iOnlyRemoveACLs)
                _tprintf(TEXT("\n\n***** Adjusting ACLs on data for user %s for product %s *****\n"), g_rgpszAllUsers[g_iUserIndex], szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));
            else
                _tprintf(TEXT("\n\n***** Zapping data for user %s for product %s *****\n"), g_rgpszAllUsers[g_iUserIndex], szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));
            fError |= !DoTheJob(iTodo, szProduct);
            delete g_rgpszAllUsers[g_iUserIndex];
        }
        delete [] g_rgpszAllUsers;
    }
    else
        fError = !DoTheJob(iTodo, szProduct);

    if (fError)
    {
        _tprintf(TEXT("FAILED to clear all data.\n"));
        return 1;
    } 
    else
	{
		if (!g_fDataFound && !(iTodo & iOnlyRemoveACLs))
			_tprintf(TEXT("No product data was found.\n"));
        return 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\addtbld.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// AddTblD.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "AddTblD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddTableD dialog


CAddTableD::CAddTableD(CWnd* pParent /*=NULL*/)
	: CDialog(CAddTableD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddTableD)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_plistTables = NULL;
}


void CAddTableD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddTableD)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddTableD, CDialog)
	//{{AFX_MSG_MAP(CAddTableD)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddTableD message handlers

BOOL CAddTableD::OnInitDialog() 
{
	ASSERT(m_plistTables);
	CDialog::OnInitDialog();

	// subclass list box to a checkbox
	m_ctrlList.SubclassDlgItem(IDC_LIST_TABLES, this);
	
	while (m_plistTables->GetHeadPosition())
		m_ctrlList.AddString(m_plistTables->RemoveHead());

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CAddTableD::OnOK() 
{
	CString strTable;
	int cTables = m_ctrlList.GetCount();
	for (int i = 0; i < cTables; i++)
	{
		// if the table is checked add it back in the list
		if (1 == m_ctrlList.GetCheck(i))
		{
			m_ctrlList.GetText(i, strTable);
			m_plistTables->AddTail(strTable);
		}
	}

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\addrowd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// CAddRowD.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "AddRowD.h"
#include "folderd.h"

#include "..\common\utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ID_EDIT 666

/////////////////////////////////////////////////////////////////////////////
// CAddRowD dialog


CAddRowD::CAddRowD(CWnd* pParent /*=NULL*/)
	: CDialog(CAddRowD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddRowD)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_iOldItem = -1;

	m_fReadyForInput = false;
}

CAddRowD::~CAddRowD()
{
}

void CAddRowD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddRowD)
	DDX_Control(pDX, IDC_ITEMLIST, m_ctrlItemList);
	DDX_Control(pDX, IDC_EDITTEXT, m_ctrlEditText);
	DDX_Control(pDX, IDC_DESCRIPTION, m_ctrlDescription);
	DDX_Control(pDX, IDC_BROWSE, m_ctrlBrowse);
	DDX_Text(pDX, IDC_DESCRIPTION, m_strDescription);
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddRowD, CDialog)
	//{{AFX_MSG_MAP(CAddRowD)
	//}}AFX_MSG_MAP
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_ITEMLIST, OnItemchanged)
	ON_NOTIFY(NM_DBLCLK, IDC_ITEMLIST, OnDblclkItemList)
	ON_MESSAGE(WM_AUTOMOVE_PREV, OnPrevColumn)
	ON_MESSAGE(WM_AUTOMOVE_NEXT, OnNextColumn)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddRowD message handlers

BOOL CAddRowD::OnInitDialog() 
{
	CDialog::OnInitDialog();

	m_ctrlItemList.InsertColumn(1, TEXT("Name"), LVCFMT_LEFT, -1, 0);
	m_ctrlItemList.InsertColumn(1, TEXT("Value"), LVCFMT_LEFT, -1, 1);
	m_ctrlItemList.SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES);
		
    CImageList* m_pImageList = new CImageList();
	ASSERT(m_pImageList != NULL);    // serious allocation failure checking
	m_pImageList->Create(11, 22, ILC_COLOR | ILC_MASK, 4, 0);

	m_bmpKey.LoadBitmap(IDB_KEY);
	m_pImageList->Add(&m_bmpKey, RGB(0xC0, 0xC0, 0xC0));
	m_ctrlItemList.SetImageList(m_pImageList, LVSIL_SMALL);
	
	COrcaColumn* pColumn;
	UINT_PTR iColSize = m_pcolArray.GetSize();
	ASSERT(iColSize <= 31);
	// never more than 31 columns, so OK to cast down
	int cCols = static_cast<int>(iColSize);
	for (int i = 0; i < cCols; i++)
	{
		pColumn = m_pcolArray.GetAt(i);

		int iIndex = m_ctrlItemList.InsertItem(i, pColumn->m_strName, pColumn->IsPrimaryKey() ? 0 : 1);
		m_ctrlItemList.SetItemData(iIndex, reinterpret_cast<INT_PTR>(pColumn));
	}

	if (m_ctrlItemList.GetItemCount() > 0)
	{
		m_ctrlItemList.SetColumnWidth(0, LVSCW_AUTOSIZE);
		m_ctrlItemList.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);
	
		// call the item changed handler to populate the initial controls
		m_fReadyForInput = true;
		ChangeToItem(0, true, true);
	}

	return FALSE;  // return TRUE unless you set the focus to a control
}

void CAddRowD::OnOK() 
{
	// this is the command handler for IDOK WM_COMMAND, which also happens when somebody hits
	// ENTER on a control. Check to see if either edit box has focus. If so, don't dismiss
	// the dialog, just change the list control item to the next in sequence.
	CWnd* pFocusWnd = GetFocus();
	if (pFocusWnd == &m_ctrlEditText)
	{
		LRESULT fNoOp = SendMessage(WM_AUTOMOVE_NEXT, 0, 0);

		// if the "next item" op changed something, don't process the default command, 
		// but if it didn't do anything (already at the end of the list), try to 
		// end the dialog anyway.
		if (!fNoOp)
			return;
	}
	BOOL bGood = true;
	CString strPrompt;

	// save the currently edited value into the control
	SaveValueInItem();

	// clear the existing output list
	m_strListReturn.RemoveAll();

	for (int iItem = 0; iItem < m_ctrlItemList.GetItemCount(); iItem++)
	{
		COrcaColumn* pColumn = reinterpret_cast<COrcaColumn*>(m_ctrlItemList.GetItemData(iItem));

		// if there is no column pointer, skip this column
		if (pColumn == NULL)
			continue;

		// grab string from control
		CString strValue = m_ctrlItemList.GetItemText(iItem, 1);

		// check "Nullable" Attribute
		if (!(pColumn->m_bNullable) && strValue.IsEmpty())
		{
			strPrompt.Format(_T("Column '%s' must be filled in."), pColumn->m_strName);
			AfxMessageBox(strPrompt);
			bGood = FALSE;
			ChangeToItem(iItem, true, /*SetListControl*/true);
			break;
		}

		// if the column is binary, check that the path exists
		if (iColumnBinary == pColumn->m_eiType)
		{
			// if the file does not exist
			if (!strValue.IsEmpty() && !FileExists(strValue))
			{
				strPrompt.Format(_T("Binary file '%s' does not exist."), strValue);
				AfxMessageBox(strPrompt);
				bGood = FALSE;
				ChangeToItem(iItem, true, /*SetListControl*/true);
				break;
			}
		}

		m_strListReturn.AddTail(strValue);	// add to the end of the string list
	}

	if (bGood)
		CDialog::OnOK();
}

////
// pulls the current value from whatever edit control is active and stores the string
// in the currently active item from the item list
void CAddRowD::SaveValueInItem()
{
	if (m_iOldItem >= 0)
	{
		CString strValue;
	
		// save off the appropiate value
		m_ctrlEditText.GetWindowText(strValue);		
		m_ctrlItemList.SetItemText(m_iOldItem, 1, strValue);
	}
}

void CAddRowD::SetSelToString(CString& strValue)
{
	// set the appropiate value in the edit control
	m_ctrlEditText.SetWindowText(strValue);
}

LRESULT CAddRowD::ChangeToItem(int iItem, bool fSetFocus, bool fSetListControl)
{
	// if we're still populating the list control, don't bother doing anything
	if (!m_fReadyForInput)
		return 0;

	if (fSetListControl)
	{
		// this triggers a recursive call into this function (fSetListControl will
		// be false. Can't just exit after making this call because the recursive call
		// loses fSetFocus, so its still this call's job to set control focus
		m_ctrlItemList.SetItemState(iItem, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
		m_ctrlItemList.EnsureVisible(iItem, /*PartialOK=*/FALSE);
	}
	else
	{
		// if this is a "no-op change"
		if (m_iOldItem == iItem)
		{
			return 0;
		}
	
		// save the old value into the control
		SaveValueInItem();
	
		// save off new item as old item for next click
		m_iOldItem = iItem;
		
		COrcaColumn* pColumn = reinterpret_cast<COrcaColumn*>(m_ctrlItemList.GetItemData(iItem));
	
		if (pColumn)
		{
			CString strRequired = _T(", Required");
			if (pColumn->m_bNullable)
				strRequired = _T("");
	
			switch (pColumn->m_eiType)
			{
			case iColumnString:
				m_strDescription.Format(_T("%s - String[%d]%s"), pColumn->m_strName, pColumn->m_iSize, strRequired);
				break;
			case iColumnLocal:
				m_strDescription.Format(_T("%s - Localizable String[%d]%s"), pColumn->m_strName, pColumn->m_iSize, strRequired);
				break;
			case iColumnShort:
				m_strDescription.Format(_T("%s - Short%s"), pColumn->m_strName, strRequired);
				break;
			case iColumnLong:
				m_strDescription.Format(_T("%s - Long%s"), pColumn->m_strName, strRequired);
				break;
			case iColumnBinary:
				m_strDescription.Format(_T("%s - Binary (enter filename)%s"), pColumn->m_strName, strRequired);
				break;
			default:
				ASSERT(FALSE);
			}
	
		
			// show or hide the edit controls and browse button based on the column type
			switch (pColumn->m_eiType)
			{
			case iColumnNone:
				ASSERT(0);
				break;
			case iColumnBinary:
			case iColumnString:
			case iColumnLocal:
			{
				// enable browse button only for binary data columns
				m_ctrlBrowse.ShowWindow(pColumn->m_eiType == iColumnBinary ? SW_SHOW : SW_HIDE);
				break;
			}
			case iColumnShort:
			case iColumnLong:
			{
				m_ctrlBrowse.ShowWindow(SW_HIDE);
				break;
			}		
			}
	
			// set the edit control to the current value from the list control
			CString strDefault = m_ctrlItemList.GetItemText(m_iOldItem, 1);
			SetSelToString(strDefault);
		}

		// refresh the description
		UpdateData(FALSE);
	}
	
	// if asked to set focus, set the focus to the currently active edit control
	if (fSetFocus)
	{
		m_ctrlEditText.SetFocus();
	}
	return 0;
}

////
// message handler for private message from edit controls that 
// moves to the next item in the list. Returns 1 if we were
// already at the last item in the list
LRESULT CAddRowD::OnNextColumn(WPARAM wParam, LPARAM lParam)
{
	int iItem = m_ctrlItemList.GetNextItem(-1, LVNI_FOCUSED);

	// but if we're in the last item, close the dialog anyway
	if (iItem < m_ctrlItemList.GetItemCount()-1)
	{
		ChangeToItem(iItem+1, /*fSetFocus=*/true, /*fSetListCtrl=*/true);
		return 0;
	}
	return 1;
}

////
// message handler for private message from edit controls that 
// moves to the previous item in the list. Returns 1 if we were
// already at the first item in the list
LRESULT CAddRowD::OnPrevColumn(WPARAM wParam, LPARAM lParam)
{
	int iItem = m_ctrlItemList.GetNextItem(-1, LVNI_FOCUSED);

	// but if we're in the last item, close the dialog anyway
	if (iItem > 0)
	{
		ChangeToItem(iItem-1, /*fSetFocus=*/true, /*fSetListCtrl=*/true);
		return 0;
	}
	return 1;
}


////
//  refresh secondary controls on item change
void CAddRowD::OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	*pResult = ChangeToItem(pNMListView->iItem, false, /*SetListControl*/false);
}

////
//  Throws up a browse dialog for finding a path
void CAddRowD::OnBrowse() 
{
	CString strValue;

	// get current path 
	m_ctrlEditText.GetWindowText(strValue);
	
	// open the file open dialog
	CFileDialogEx dlg(TRUE, NULL, strValue, OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST, _T("All Files (*.*)|*.*||"), this);
	if (IDOK == dlg.DoModal())
	{
		SetSelToString(dlg.GetPathName());
	}
}

////
// when an item is double-clicked, set focus to the edit control 
void CAddRowD::OnDblclkItemList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NMITEMACTIVATE* pEvent = reinterpret_cast<NMITEMACTIVATE*>(pNMHDR);
	int iItem = m_ctrlItemList.HitTest(pEvent->ptAction);
	if (iItem != -1)
	{
		m_ctrlEditText.SetFocus();
	}
	*pResult = 0;
}




/////////////////////////////////////////////////////////////////////////////
// private CEdit class that traps some keys for use in navigating the 
// column list

BEGIN_MESSAGE_MAP(CAddRowEdit, CEdit)
	ON_WM_KEYDOWN( )
END_MESSAGE_MAP()

////
// the message handler for keydown filters out cursor messages of interest
// to the parent in navigating the row list.
void CAddRowEdit::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	UINT uiMessage = 0;
	switch (nChar)
	{
	case VK_UP:
		uiMessage = WM_AUTOMOVE_PREV;
		break;
	case VK_RETURN:
	case VK_DOWN:
		uiMessage = WM_AUTOMOVE_NEXT;
		break;
	default:
		CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
		return;
	}

	CWnd* pDialog = GetParent();
	if (pDialog)
	{
		LRESULT fNoOp = pDialog->SendMessage(uiMessage, 0, 0);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\addrowd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_ADDROWD_H__AF466B57_F97C_11D1_AD43_00A0C9AF11A6__INCLUDED_)
#define AFX_ADDROWD_H__AF466B57_F97C_11D1_AD43_00A0C9AF11A6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CAddRowD.h : header file
//

#include "Column.h"

class CAddRowEdit : public CEdit
{
protected:
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// messages for communicating between private edit box and dialog
const int WM_AUTOMOVE_NEXT = (WM_APP+0);
const int WM_AUTOMOVE_PREV = (WM_APP+1);

/////////////////////////////////////////////////////////////////////////////
// CAddRowD dialog

class CAddRowD : public CDialog
{
// Construction
public:
	CAddRowD(CWnd* pParent = NULL);   // standard constructor
	~CAddRowD();

// Dialog Data
	//{{AFX_DATA(CAddRowD)
	enum { IDD = IDD_ADD_ROW };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	CTypedPtrArray<CObArray, COrcaColumn*> m_pcolArray;
	CStringList m_strListReturn;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddRowD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddRowD)
	virtual BOOL OnInitDialog();
	virtual void OnOK();

	
	afx_msg void OnBrowse();
	afx_msg LRESULT OnPrevColumn(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnNextColumn(WPARAM wParam, LPARAM lParam);
	afx_msg void OnDblclkItemList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()


private:
	CAddRowEdit m_ctrlEditText;
	CStatic     m_ctrlDescription;
	CListCtrl   m_ctrlItemList;
	CButton     m_ctrlBrowse;
	CString	    m_strDescription;
	bool        m_fReadyForInput;
	int         m_iOldItem;
	CBitmap     m_bmpKey;

	void SaveValueInItem();
	void SetSelToString(CString& strValue);
	LRESULT ChangeToItem(int iItem, bool fSetFocus, bool fSetListControl);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDROWD_H__AF466B57_F97C_11D1_AD43_00A0C9AF11A6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\addtbld.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_ADDTBLD_H__AF466B56_F97C_11D1_AD43_00A0C9AF11A6__INCLUDED_)
#define AFX_ADDTBLD_H__AF466B56_F97C_11D1_AD43_00A0C9AF11A6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AddTblD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddTableD dialog

class CAddTableD : public CDialog
{
// Construction
public:
	CAddTableD(CWnd* pParent = NULL);   // standard constructor

	CStringList* m_plistTables;
	CCheckListBox m_ctrlList;

// Dialog Data
	//{{AFX_DATA(CAddTableD)
	enum { IDD = IDD_ADD_TABLE };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddTableD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddTableD)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDTBLD_H__AF466B56_F97C_11D1_AD43_00A0C9AF11A6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\celledit.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// CellEdit.cpp : implementation file
//

#include "stdafx.h"
#include "Orca.h"
#include "CellEdit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCellEdit

CCellEdit::CCellEdit()
{
	m_nRow = -1;
	m_nCol = -1;
}

CCellEdit::~CCellEdit()
{
}


BEGIN_MESSAGE_MAP(CCellEdit, CEdit)
	//{{AFX_MSG_MAP(CCellEdit)
	ON_WM_KILLFOCUS()
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCellEdit message handlers

void CCellEdit::OnKillFocus(CWnd* pNewWnd) 
{
	if (IsWindowVisible())
		// pretend user pressed return
		GetParent()->SendMessage(WM_CHAR, VK_RETURN, 1);
	CEdit::OnKillFocus(pNewWnd);
}

void CCellEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	if (VK_RETURN == nChar)
	{
		GetParent()->SendMessage(WM_CHAR, VK_RETURN, 1);	// looses the flags (oh well)
		TRACE(_T("CCellEdit::OnChar - ENTER pressed\n"));
	}
	else if (VK_ESCAPE == nChar)
	{
		// "reflect" the message
		GetParent()->SendMessage(WM_CHAR, VK_ESCAPE);	// looses the flags (oh well)
		TRACE(_T("CCellEdit::OnChar - ESC pressed\n"));
	}
	else
		CEdit::OnChar(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\celledit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

#if !defined(AFX_CELLEDIT_H__0E0A1774_F10D_11D1_A859_006097ABDE17__INCLUDED_)
#define AFX_CELLEDIT_H__0E0A1774_F10D_11D1_A859_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CellEdit.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCellEdit window

class CCellEdit : public CEdit
{
// Construction
public:
	CCellEdit();

// Attributes
public:
	int m_nRow;
	int m_nCol;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCellEdit)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCellEdit();

	// Generated message map functions
protected:
	//{{AFX_MSG(CCellEdit)
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CELLEDIT_H__0E0A1774_F10D_11D1_A859_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\cellerrd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// CellErrD.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "CellErrD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCellErrD dialog


CCellErrD::CCellErrD(CWnd* pParent /*=NULL*/)
	: CDialog(CCellErrD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCellErrD)
	m_strType = _T("");
	m_strICE = _T("");
	m_strDescription = _T("");
	//}}AFX_DATA_INIT
}

CCellErrD::CCellErrD(const CTypedPtrList<CObList, COrcaData::COrcaDataError *> *list, 
					 CWnd* pParent/* = NULL*/)
					 : CDialog(CCellErrD::IDD, pParent), m_Errors(list)
{
	m_strType = _T("");
	m_strICE = _T("");
	m_strDescription = _T("");
}

void CCellErrD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCellErrD)
	DDX_Text(pDX, IDC_TYPE, m_strType);
	DDX_Text(pDX, IDC_ICE, m_strICE);
	DDX_Text(pDX, IDC_DESC, m_strDescription);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCellErrD, CDialog)
	//{{AFX_MSG_MAP(CCellErrD)
	ON_BN_CLICKED(IDC_WEB_HELP, OnWebHelp)
	ON_BN_CLICKED(IDC_NEXT, OnNext)
	ON_BN_CLICKED(IDC_PREVIOUS, OnPrevious)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCellErrD message handlers

BOOL CCellErrD::OnInitDialog() 
{
	CDialog::OnInitDialog();
	m_iItem = 0;
	
	// hide web help if special registry value not set. (non-ms)
	if (AfxGetApp()->GetProfileInt(_T("Validation"), _T("EnableHelp"), 0)==0) 
		((CButton *)GetDlgItem(IDC_WEB_HELP))->ShowWindow(SW_HIDE);

	UpdateControls();
	return TRUE;  // return TRUE unless you set the focus to a control
}

void CCellErrD::OnWebHelp() 
{
	if(!m_strURL.IsEmpty())
	{
		if (32 >= (const INT_PTR)ShellExecute(AfxGetMainWnd()->m_hWnd, _T("open"), m_strURL, _T(""), _T(""), SW_SHOWNORMAL)) 
			AfxMessageBox(_T("There was an error opening your browser. Web help is not available."));
	}
	else
		AfxMessageBox(_T("There is no help associated with this ICE at this time."));
}

void CCellErrD::OnNext() 
{
	m_iItem++;
	UpdateControls();
}

void CCellErrD::OnPrevious() 
{
	m_iItem--;
	UpdateControls();
}

void CCellErrD::UpdateControls() 
{
    // we don't handle the possibility of MAX_INT or more errors
	int iMaxItems = static_cast<int>(m_Errors->GetCount());

	// set the window title
	CString strTitle;
	strTitle.Format(_T("Message %d of %d"), m_iItem+1, iMaxItems);
	SetWindowText(strTitle);

	// enable/disable next/prev controls
	((CButton *)GetDlgItem(IDC_NEXT))->EnableWindow(m_iItem < iMaxItems-1);
	((CButton *)GetDlgItem(IDC_PREVIOUS))->EnableWindow(m_iItem > 0);

	COrcaData::COrcaDataError *Error = m_Errors->GetAt(m_Errors->FindIndex(m_iItem));
	// set the text values
	m_strDescription = Error->m_strDescription;
	m_strICE = Error->m_strICE;
	m_strURL = Error->m_strURL;
	switch (Error->m_eiError) {
	case iDataError : m_strType = _T("ERROR"); break;
	case iDataWarning : m_strType = _T("Warning"); break;
	default: ASSERT(false);
	}
	UpdateData(FALSE);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\cmdline.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------
// cmdline.h - defines COrcaCommandLine class

#ifndef _ORCA_COMMAND_LINE_H_
#define _ORCA_COMMAND_LINE_H_

enum CommandTypes
{
	iNone,
	iMergeModule,
	iMsiDatabase,
	iOrcaDatabase,
	iSchema,
	iHelp,
	iLogFile,
	iExecuteMerge,
	iFeatures,
	iRedirect,
	iExtractDir,
	iLanguage,
	iExtractCAB,
	iExtractImage,
	iConfigureFile
};

int LocaleIndependentCompare(LPCTSTR lpString1, LPCTSTR lpString2)
{
	DWORD dwLCID = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
	// CompareString doesn't behave like a normal string comparison. Instead of returning
	// negative, 0, or positive, it returns 1, 2, or 3. Subtract CSTR_EQUAL to map the
	// return codes to the normal values.
	return (CompareString(dwLCID, NORM_IGNORECASE, lpString1, -1, lpString2, -1)-CSTR_EQUAL);
}

class COrcaCommandLine : public CCommandLineInfo
{
public:
	COrcaCommandLine();

	void ParseParam(const TCHAR* pszParam, BOOL bFlag, BOOL bLast);

	BOOL m_bQuiet;
	CommandTypes m_eiDo;
	CString m_strSchema;
	CString m_strLogFile;
	BOOL m_bUnknown;

	// valid only if compiling product
	bool m_bNoImage;

	// variables valid only if doing merge modules
	BOOL m_bCommit;
	bool m_bForceCommit;
	CString m_strExecuteModule;
	CString m_strFeatures;
	CString m_strRedirect;
	CString m_strExtractDir;
	CString m_strExtractCAB;
	CString m_strExtractImage;
	CString m_strLanguage;
	CString m_strConfigFile;
	bool m_bNoCab;
	bool m_bLFN;
};	// end of COrcaCommandLine


COrcaCommandLine::COrcaCommandLine()
{
	m_nShellCommand = CCommandLineInfo::FileNew;
	m_strSchema = _T("orca.dat");
	m_bQuiet = FALSE;
	m_bUnknown = FALSE;

	m_bNoCab = false;
	m_bNoImage = false;
	m_bCommit = FALSE;
	m_bForceCommit = FALSE;
	m_eiDo = iNone;
	m_bLFN = FALSE;
}	// end of constructor

void COrcaCommandLine::ParseParam(const TCHAR* pszParam, BOOL bFlag, BOOL bLast)
{
	static CommandTypes eiLastFlag = iNone;	// maintains state for this function

	// if we are doing help bail
	if (iHelp == m_eiDo)
		return;

	if (bFlag)
	{
		// if specifying schema
		if (0 == LocaleIndependentCompare(pszParam, _T("s")))
		{
			eiLastFlag = iSchema;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("l")))	// specifying log file
		{
			eiLastFlag = iLogFile;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("f")))	// specifying Features
		{
			eiLastFlag = iFeatures;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("m")))	// specifying execute merge module
		{
			eiLastFlag = iExecuteMerge;
			m_nShellCommand = CCommandLineInfo::FileNothing;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("r")))	// specifying Redirection Directory
		{
			eiLastFlag = 	iRedirect;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("c")))	// specifying commit mode
		{
			m_bCommit = TRUE;
			eiLastFlag = iNone;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("!")))	// specifying commit mode
		{
			m_bForceCommit = true;
			eiLastFlag = iNone;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("g")))	// specify language
		{;
			eiLastFlag = iLanguage;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("nocab")))	// specifying no CAB create
		{
			m_bNoCab = TRUE;
			eiLastFlag = iNone;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("noimage")))	// specifying no source image
		{
			m_bNoImage = TRUE;
			eiLastFlag = iNone;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("x")))	// merge module extraction dir
		{
			eiLastFlag = iExtractDir;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("q")))	// specifying quiet mode
		{
			m_bQuiet = TRUE;
			eiLastFlag = iNone;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("?")) ||
					0 == LocaleIndependentCompare(pszParam, _T("h")))	// specifying help mode
		{
			m_eiDo = iHelp;
			m_nShellCommand = CCommandLineInfo::FileNothing;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("LFN")))	// specifying log file
		{
			m_bLFN = TRUE;
			eiLastFlag = iNone;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("cab")))	// specifying cab path
		{
			eiLastFlag = iExtractCAB;
		}
		else if ((0 == LocaleIndependentCompare(pszParam, _T("i"))) ||	// specifying image path
			 (0 == LocaleIndependentCompare(pszParam, _T("image"))))
		{
			eiLastFlag = iExtractImage;
		}
		else if (0 == LocaleIndependentCompare(pszParam, _T("configure")))	// specifying image path
		{
			eiLastFlag = iConfigureFile;
		}

	}
	else	// database, module, or makefile
	{
		switch (eiLastFlag)
		{
		case iSchema:
			m_strSchema = pszParam;
			break;
		case iLogFile:
			eiLastFlag = iNone;
			m_strLogFile = pszParam;
			break;
		case iFeatures:
			m_strFeatures = pszParam;
			break;
		case iExecuteMerge:
			m_strExecuteModule = pszParam;
			m_eiDo = iExecuteMerge;
			m_nShellCommand = CCommandLineInfo::FileNothing;
			break;
		case iRedirect:
			m_strRedirect = pszParam;
			break;
		case iLanguage:
			m_strLanguage = pszParam;
			break;
		case iExtractDir:
			m_strExtractDir = pszParam;
			break;
		case iExtractCAB:
			m_strExtractCAB = pszParam;
			break;
		case iExtractImage:
			m_strExtractImage = pszParam;
			break;
		case iConfigureFile:
			m_strConfigFile = pszParam;
			break;
		default:
			int cchCount = lstrlen(pszParam);
			if (0 == LocaleIndependentCompare((pszParam + cchCount - 4), _T(".MSM")))
			{
				m_eiDo = iMergeModule;
				m_strFileName = pszParam;
				m_nShellCommand = CCommandLineInfo::FileOpen;
			}
			else	// any other file type, including unknown
			{
				// if we're not doing an execute merge just open
				if (m_eiDo != iExecuteMerge)
				{
					m_eiDo = iMsiDatabase;
					m_nShellCommand = CCommandLineInfo::FileOpen;
				}

				m_strFileName = pszParam;
			}
			break;
		}
		eiLastFlag = iNone;
	}
}	// end of ParseParam

#endif // _ORCA_COMMAND_LINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\cellerrd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_CELLERRD_H__25468EE4_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_)
#define AFX_CELLERRD_H__25468EE4_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CellErrD.h : header file
//

#include "stdafx.h"
#include "Orca.h"
#include "Data.h"

/////////////////////////////////////////////////////////////////////////////
// CCellErrD dialog

class CCellErrD : public CDialog
{
// Construction
public:
	CCellErrD(CWnd* pParent = NULL);   // standard constructor
	CCellErrD(const CTypedPtrList<CObList, COrcaData::COrcaDataError *> *list, CWnd* pParent = NULL);   // standard constructor
	CString m_strURL;

// Dialog Data
	//{{AFX_DATA(CCellErrD)
	enum { IDD = IDD_CELL_ERROR };
	CString	m_strType;
	CString	m_strICE;
	CString	m_strDescription;
	//}}AFX_DATA

	const CTypedPtrList<CObList, COrcaData::COrcaDataError *> *m_Errors;
	int m_iItem;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCellErrD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCellErrD)
	virtual BOOL OnInitDialog();
	afx_msg void OnWebHelp();
	afx_msg void OnNext();
	afx_msg void OnPrevious();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	void UpdateControls();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CELLERRD_H__25468EE4_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\cnfgmsmd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//--------------------------------------------------------------------------

// MergeD.cpp : merge module dialog implementation
//

#include "stdafx.h"
#include "Orca.h"
#include "cnfgmsmD.h"
#include "mergemod.h"
#include "table.h"
#include "..\common\utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigMsmD dialog

inline CString BSTRtoCString(const BSTR bstrValue)
{
#ifdef _UNICODE
		return CString(bstrValue);
#else
		size_t cchLen = ::SysStringLen(bstrValue);
		CString strValue;
		LPTSTR szValue = strValue.GetBuffer(cchLen);
		WideToAnsi(bstrValue, szValue, &cchLen);
		strValue.ReleaseBuffer();
		return strValue;
#endif
}

CConfigMsmD::CConfigMsmD(CWnd* pParent /*=NULL*/)
	: CDialog(CConfigMsmD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConfigMsmD)
	m_strDescription = "";
	m_bUseDefault = TRUE;
	//}}AFX_DATA_INIT

	m_iOldItem = -1;
	m_pDoc = NULL;
	m_fComboIsKeyItem = false;
	m_iKeyItemKeyCount = 0;

	m_fReadyForInput = false;
	m_eActiveControl = eTextControl;
}


void CConfigMsmD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConfigMsmD)
	DDX_Control(pDX, IDC_ITEMLIST, m_ctrlItemList);
	DDX_Control(pDX, IDC_EDITTEXT, m_ctrlEditText);
	DDX_Control(pDX, IDC_EDITNUMBER, m_ctrlEditNumber);
	DDX_Control(pDX, IDC_EDITCOMBO, m_ctrlEditCombo);
	DDX_Control(pDX, IDC_DESCRIPTION, m_ctrlDescription);
	DDX_Text(pDX, IDC_DESCRIPTION, m_strDescription);
	DDX_Check(pDX, IDC_FUSEDEFAULT, m_bUseDefault);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigMsmD, CDialog)
	//{{AFX_MSG_MAP(CConfigMsmD)
	ON_BN_CLICKED(IDC_FUSEDEFAULT, OnFUseDefault)
	ON_WM_DESTROY()
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_ITEMLIST, OnItemchanged)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigMsmD message handlers
BOOL CheckFeature(LPCTSTR szFeatureName);

#define MAX_GUID 38
TCHAR   g_szOrcaWin9XComponentCode[MAX_GUID+1] = _T("{406D93CF-00E9-11D2-AD47-00A0C9AF11A6}");
TCHAR   g_szOrcaWinNTComponentCode[MAX_GUID+1] = _T("{BE928E10-272A-11D2-B2E4-006097C99860}");
TCHAR   g_szOrcaWin64ComponentCode[MAX_GUID+1] = _T("{2E083580-AB1C-4D2F-AA18-54DCC8BA5A64}");
TCHAR   g_szFeatureName[] = _T("MergeModServer");


struct sItemData
{
	IMsmConfigurableItem *piItem;
	CString strValue;
};

BOOL CConfigMsmD::OnInitDialog() 
{
	CDialog::OnInitDialog();

	m_ctrlItemList.InsertColumn(1, TEXT("Name"), LVCFMT_LEFT, -1, 0);
	m_ctrlItemList.InsertColumn(1, TEXT("Value"), LVCFMT_LEFT, -1, 1);
	m_ctrlItemList.SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES);

	// create a Mergemod COM object
	IMsmMerge2* piExecute;
	HRESULT hResult = ::CoCreateInstance(CLSID_MsmMerge2, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
														  IID_IMsmMerge2, (void**)&piExecute);
	// if failed to create the object
	if (FAILED(hResult)) 
	{
		if (!CheckFeature(g_szFeatureName) || FAILED(::CoCreateInstance(CLSID_MsmMerge2, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
														  IID_IMsmMerge2, (void**)&piExecute)))
		EndDialog(-5);
		return TRUE;
	}

	// try to open the module
	WCHAR wzModule[MAX_PATH];
#ifndef _UNICODE
	size_t cchBuffer = MAX_PATH;
	::MultiByteToWideChar(CP_ACP, 0, m_strModule, -1, wzModule, cchBuffer);
#else
	lstrcpy(wzModule, m_strModule);
#endif	// _UNICODE
	BSTR bstrModule = ::SysAllocString(wzModule);
	hResult = piExecute->OpenModule(bstrModule, static_cast<short>(m_iLanguage));
	::SysFreeString(bstrModule);
	if (FAILED(hResult))
	{
		// module couldn't be open or doesn't support that language
    	piExecute->Release();
		if (hResult == HRESULT_FROM_WIN32(ERROR_OPEN_FAILED))
		{
			// file didn't exist or couldn't be opened
			EndDialog(-2);
		} 
		else if (hResult == HRESULT_FROM_WIN32(ERROR_INSTALL_LANGUAGE_UNSUPPORTED))
		{
			// unsupported language
			EndDialog(-3);
		}
		else
		{
			// general bad
			EndDialog(-4);
		}
		return TRUE;
	}
	
	// try to get the item enumerator
	int iFailed = 0;
	IMsmConfigurableItems* pItems;
	long cItems;
	hResult = piExecute->get_ConfigurableItems(&pItems);
	if (FAILED(hResult))
	{
		// malformed module or internal error
		piExecute->CloseModule();
		piExecute->Release();
		EndDialog(-4);
		return TRUE;
	}
	else 
	{
		if (FAILED(pItems->get_Count(&cItems)))
		{
			iFailed = -4;
		}
		else
		{
			if (cItems)
			{
				// get the enumerator, and immediately query it for the right type
				// of interface			
				IUnknown *pUnk;
				if (FAILED(pItems->get__NewEnum(&pUnk)))
				{
					iFailed = -4;
				}
				else
				{
					IEnumMsmConfigurableItem *pEnumItems;
					HRESULT hr = pUnk->QueryInterface(IID_IEnumMsmConfigurableItem, (void **)&pEnumItems);
					pUnk->Release();
	
					if (FAILED(hr))
					{
						iFailed = -4;
					}
					else
					{	
						// get the first error.
						unsigned long cItemFetched;
						IMsmConfigurableItem* pItem;
						if (FAILED(pEnumItems->Next(1, &pItem, &cItemFetched)))
							iFailed = -4;
	
						// while an item is fetched
						while (iFailed == 0 && cItemFetched && pItem)
						{
							// add the name
							BSTR bstrName;
							if (FAILED(pItem->get_DisplayName(&bstrName)))
							{
								iFailed = -4;
								break;
							}
							int iIndex = m_ctrlItemList.InsertItem(-1, BSTRtoCString(bstrName));
							::SysFreeString(bstrName);
							sItemData* pData = new sItemData;
							pData->piItem = pItem;
							pData->strValue = TEXT("");
							m_ctrlItemList.SetItemData(iIndex, reinterpret_cast<INT_PTR>(pData));
	
							// load the UI string for the default into the control
							if ((iFailed = SetToDefaultValue(iIndex)) < 0)
								break;
							
							// don't release the pItem, its stored in lParam
							if (FAILED(pEnumItems->Next(1, &pItem, &cItemFetched)))
								iFailed = -4;
						}
						pEnumItems->Release();
					}
				}
			}
		}
	}

	// close all the open files
	piExecute->CloseModule();

	// release and leave happy
	piExecute->Release();

	if (iFailed != 0)
		EndDialog(iFailed);

	ReadValuesFromReg();
	
	if (m_ctrlItemList.GetItemCount() > 0)
	{
		m_ctrlItemList.SetColumnWidth(0, LVSCW_AUTOSIZE);
		m_ctrlItemList.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);
		m_ctrlItemList.SetItemState(0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
		
		// call the item changed handler to populate the initial controls
		NM_LISTVIEW nmlvTemp;
		nmlvTemp.iItem = 0;
		nmlvTemp.iSubItem = 0;
		nmlvTemp.lParam = m_ctrlItemList.GetItemData(0);
		LRESULT lRes;

		// need to fake out "change to same item" check to force a UI refresh and correct
		// activation of the context-sensitive controls
		m_fReadyForInput = true;
		OnItemchanged(reinterpret_cast<NMHDR *>(&nmlvTemp), &lRes);
	}
	else
		EndDialog(IDOK);

	return TRUE;  // return TRUE unless you set the focus to a control
}


////
// Given an item and an index into the item list control, sets the 
// item plus any secondary controls (combo, etc) to the default value.
// Secondary controls must be pre-popluated. Returns < 0 on failure 
// (can be used in endDialog), 0 on success.
int CConfigMsmD::SetToDefaultValue(int iItem)
{
	sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(iItem));
	IMsmConfigurableItem *pItem = pData->piItem;

	BSTR bstrValue;
	if (FAILED(pItem->get_DefaultValue(&bstrValue)))
	{
		return -4;
	}
	CString strValue = BSTRtoCString(bstrValue);
	::SysFreeString(bstrValue);

	int iRes = SetItemToValue(iItem, strValue);
	SetSelToString(strValue);
	return iRes;
}


////
// Given an item and a string value, sets the item display string 
// plus any secondary controls (combo, etc) to the provided value.
// Secondary controls must be pre-popluated. Returns < 0 on failure 
// (can be used in endDialog), 0 on success.
int CConfigMsmD::SetItemToValue(int iItem, const CString strValue)
{
	sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(iItem));
	IMsmConfigurableItem *pItem = pData->piItem;

	CString strDisplayValue;

	// if this is an enum or bitfield, must get the display string
	// for the default value, otherwise just stick in the default
	// value
	msmConfigurableItemFormat eFormat;
	if (FAILED(pItem->get_Format(&eFormat)))
	{
		return -4;
	}
	switch (eFormat)
	{
	case msmConfigurableItemText:
	{
		BSTR bstrType;
		if (FAILED(pItem->get_Type(&bstrType)))
		{
			return -4;
		}
		CString strType = BSTRtoCString(bstrType);
		::SysFreeString(bstrType);
		if (strType != TEXT("Enum"))
		{
			strDisplayValue = strValue;
			break;
		}
		// fall through to parse enum value
	}			
	case msmConfigurableItemBitfield:
	{
		BSTR bstrContext;
		if (FAILED(pItem->get_Context(&bstrContext)))
		{
			return -4;
		}
		CString strContext = BSTRtoCString(bstrContext);
		::SysFreeString(bstrContext);
		strDisplayValue = GetNameByValue(strContext, strValue, eFormat == msmConfigurableItemBitfield);
		break;		
	}
	case msmConfigurableItemKey:
	{
		// for key, need to turn strValue into strDisplayValue somehow
		strDisplayValue = "";
		for (int i=0; i < strValue.GetLength(); i++)
		{
			if (strValue[i] == TEXT('\\'))
				i++;
			strDisplayValue += strValue[i];
		}
		break;
	}
	case msmConfigurableItemInteger:
	default:
		strDisplayValue = strValue;
		break;
	}

	m_ctrlItemList.SetItem(iItem, 1, LVIF_TEXT, strDisplayValue, 0, 0, 0, 0);
	pData->strValue = strValue;
	return 0;
}

////
// Given a semicolon-delimited Name=Value set, populates the combo
// box with the "Name" strings
void CConfigMsmD::PopulateComboFromEnum(const CString& strData, bool fIsBitfield)
{
	CString strName;
	CString *pstrValue = new CString;
	bool fReadingValue = false;
	int i=0;
	if (fIsBitfield)
	{
		// skip up to the first semicolon
		while (strData[i] != '\0')
		{
			if (strData[i] == ';')
			{
				if (i==0 || strData[i-1] != '\\')
				{
					// skip over semicolon after mask
					i++;
					break;
				}
			}
			i++;
		}
	}
	
	for (; i <= strData.GetLength(); i++)
	{
		TCHAR ch = strData[i];
		switch (ch)
		{
		case TEXT('\\'):
			(fReadingValue ? *pstrValue : strName) += strData[++i];
			break;
		case TEXT('='):
			fReadingValue = true;
			break;
		case TEXT('\0'):
		case TEXT(';'):
		{
			int iItem = m_ctrlEditCombo.AddString(strName);
			if (iItem != CB_ERR)
				m_ctrlEditCombo.SetItemDataPtr(iItem, pstrValue);
			strName = "";
			pstrValue = new CString;
			fReadingValue = false;
			break;
		}
		default:
			(fReadingValue ? *pstrValue : strName) += ch;
			break;
		}
	}		
	delete pstrValue;
}


////
// Empty the combo box
void CConfigMsmD::EmptyCombo()
{
	// key items have data pointers to OrcaRow objects that don't belong to it.
	// can't free those
	if (!m_fComboIsKeyItem)
	{
		for (int i=0; i < m_ctrlEditCombo.GetCount(); i++)
		{
			CString *pData = static_cast<CString *>(m_ctrlEditCombo.GetItemDataPtr(i));
			if (pData)
				delete pData;
		}
	}
	m_ctrlEditCombo.ResetContent();	
}

////
// Given a semicolon-delimited Name=Value set, returns the value
// associate with strName. If fBitfield is set, skips over the first
// string (mask in bitfield types)
CString CConfigMsmD::GetValueByName(const CString& strInfo, const CString& strName, bool fIsBitfield)
{
	CString strThisName;
	bool fReturnThisValue = false;
	int i=0;
	if (fIsBitfield)
	{
		// skip up to the first semicolon
		while (strInfo[i] != '\0')
		{
			if (strInfo[i] == ';')
			{
				if (i==0 || strInfo[i-1] != '\\')
				{
					// skip over semicolon after mask
					i++;
					break;
				}
			}
			i++;
		}
	}

	for (; i <= strInfo.GetLength(); i++)
	{
		TCHAR ch = strInfo[i];
		switch (ch)
		{
		case TEXT('\\'):
			strThisName += strInfo[++i];
			break;
		case TEXT('='):
		{
			if (strName == strThisName)
				fReturnThisValue = true;
			strThisName = TEXT("");
			break;
		}
		case TEXT('\0'):
		case TEXT(';'):
			if (fReturnThisValue)
				return strThisName;
			strThisName = TEXT("");
			break;
		default:
			strThisName += ch;
			break;
		}
	}

	// hit the end of the string
	return TEXT("");
}


////
// Given a semicolon-delimited Name=Value set, returns the value
// associate with strName. If fBitfield is set, skips over the first
// string (mask in bitfield types)
CString CConfigMsmD::GetNameByValue(const CString& strInfo, const CString& strValue, bool fIsBitfield)
{
	CString strThisName;
	CString strThisValue;
	int i=0;
	if (fIsBitfield)
	{
		// skip up to the first semicolon
		while (strInfo[i] != '\0')
		{
			if (strInfo[i] == ';')
			{
				if (i==0 || strInfo[i-1] != '\\')
				{
					// skip over semicolon after mask
					i++;
					break;
				}
			}
			i++;
		}
	}

	bool fWritingName = true;
	for (; i <= strInfo.GetLength(); i++)
	{
		TCHAR ch = strInfo[i];
		switch (ch)
		{
		case TEXT('\\'):
			(fWritingName ? strThisName : strThisValue) += strInfo[++i];
			break;
		case TEXT('='):
			fWritingName = false;
			break;
		case TEXT('\0'):
		case TEXT(';'):
			if (strValue == strThisValue)
				return strThisName;
			strThisValue = TEXT("");
			strThisName = TEXT("");
			fWritingName = true;
			break;
		default:
			(fWritingName ? strThisName : strThisValue) += ch;
			break;
		}
	}

	return TEXT("");
}

////
// Sets the current selection in whatever edit control is active to the specified
// string, adding it to the combo box if necessary.
void CConfigMsmD::SetSelToString(const CString& strValue)
{
	// check which window is visible and save off the appropiate value
	switch (m_eActiveControl)
	{
	case eComboControl:
	{
		bool fHaveDataPtr = m_ctrlEditCombo.GetItemDataPtr(0) ? true : false;
		for (int iIndex=0; iIndex < m_ctrlEditCombo.GetCount(); iIndex++)
		{
			CString strText;
			m_ctrlEditCombo.GetLBText(iIndex, strText);
			if (strText == strValue)
				break;
		}
		
		// if we couldn't find an exact match, select the first item
		if (iIndex >= m_ctrlEditCombo.GetCount())
		{
			iIndex = 0;
		}	

		// set current selection to match whats in the item list
		m_ctrlEditCombo.SetCurSel(iIndex);
	}
	case eNumberControl:
	{
		m_ctrlEditNumber.SetWindowText(strValue);
	}
	case eTextControl:
	{
		m_ctrlEditText.SetWindowText(strValue);
	}
	}
}

////
// pulls the current value from whatever edit control is active and stores the string
// in the currently active item from the item list
void CConfigMsmD::SaveValueInItem()
{
	if (m_iOldItem >= 0)
	{
		// if the "use default" box is checked, don't save off the value
		if (!m_bUseDefault)
		{
			CString strValue;
			CString strDisplayValue;
		
			// check which window is visible and save off the appropiate value
			switch (m_eActiveControl)
			{
			case eComboControl:
			{
				int iIndex = m_ctrlEditCombo.GetCurSel();
				if (iIndex != CB_ERR)
				{				
					// if this is a key item, we need to do special processing to turn the selection
					// into a properly escaped string. Otherwise its a bitfield or enum, which means
					// the literal string is good enough
					if (m_fComboIsKeyItem)
					{
						strValue = TEXT("");
						COrcaRow *pRow = static_cast<COrcaRow *>(m_ctrlEditCombo.GetItemDataPtr(iIndex));
						if (pRow)
						{	
							for (int i=0; i < m_iKeyItemKeyCount; i++)
							{
								CString strThisColumn = pRow->GetData(i)->GetString();
								for (int cChar=0; cChar < strThisColumn.GetLength(); cChar++)
								{
									if ((strThisColumn[cChar] == TEXT(';')) || 
										(strThisColumn[cChar] == TEXT('=')) || 
										(strThisColumn[cChar] == TEXT('\\')))
										strValue += TEXT('\\');			
									strValue += strThisColumn[cChar];
								}
								if (i != m_iKeyItemKeyCount-1)
									strValue += TEXT(';');
							}
						}
					}
					else
					{
						// get Bitfield or Combo value
						strValue = *static_cast<CString *>(m_ctrlEditCombo.GetItemDataPtr(iIndex));
					}
					m_ctrlEditCombo.GetLBText(iIndex, strDisplayValue);
				}
				break;
			}
			case eNumberControl:
			{
				m_ctrlEditNumber.GetWindowText(strValue);
				strDisplayValue = strValue;
				break;
			}
			case eTextControl:
			{
				m_ctrlEditText.GetWindowText(strValue);
				strDisplayValue = strValue;
				break;
			}
			}
			
			sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(m_iOldItem));
			m_ctrlItemList.SetItemText(m_iOldItem, 1, strDisplayValue);
			pData->strValue = strValue;
		}
	}
}

////
// Enables and disables the edit boxes for the item, and restores the default if
// turned on.
void CConfigMsmD::OnFUseDefault() 
{
	UpdateData(TRUE);
	EnableBasedOnDefault();
	m_ctrlItemList.SetItemState(m_iOldItem, m_bUseDefault ? 0 : INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);

	if (m_bUseDefault)
	{
		SetToDefaultValue(m_iOldItem);
	}
}

void CConfigMsmD::OnOK() 
{
	// run through the list placing name/value pairs into the callback object
	ASSERT(m_pCallback);

	// first save value in case any editing is in-progress
	SaveValueInItem();

	// clear out the combo box to avoid leaking the values
	EmptyCombo();

	// save values to the registry
	WriteValuesToReg();
	
	int iCount = m_ctrlItemList.GetItemCount();
	for (int i=0; i < iCount; i++)
	{
		// no addref, no release
		sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(i));
		BSTR bstrName;
		if (FAILED(pData->piItem->get_Name(&bstrName)))
		{
			// **** fail
			continue;
		}
		m_pCallback->m_lstData.AddTail(BSTRtoCString(bstrName));
		::SysFreeString(bstrName);
		
		// add value
		m_pCallback->m_lstData.AddTail(pData->strValue);
	}

	CDialog::OnOK();
}

void CConfigMsmD::OnDestroy() 
{
	EmptyCombo();
	int iCount = m_ctrlItemList.GetItemCount();
	for (int i=0; i < iCount; i++)
	{
		sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(i));
		pData->piItem->Release();
		delete pData;
	}
	
	CDialog::OnDestroy();
}


void CConfigMsmD::EnableBasedOnDefault()
{
	m_ctrlEditCombo.EnableWindow(!m_bUseDefault);
	m_ctrlEditNumber.EnableWindow(!m_bUseDefault);
	m_ctrlEditText.EnableWindow(!m_bUseDefault);
}

void CConfigMsmD::OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	// if we're still populating the list control, don't bother doing anything
	if (!m_fReadyForInput)
		return;
		
	// if this is a "no-op change"
	if (m_iOldItem == pNMListView->iItem)
	{
		*pResult = 0;
		return;
	}

	// save the old value into the control
	SaveValueInItem();

	// save off new item as old item for next click
	m_iOldItem = pNMListView->iItem;

	// retrieve the interface pointer. No AddRef, No Release.
	sItemData *pData = reinterpret_cast<sItemData *>(pNMListView->lParam);
	IMsmConfigurableItem* pItem = pData->piItem;

	// set the "default" checkbox based on the state image mask
	m_bUseDefault = m_ctrlItemList.GetItemState(m_iOldItem, LVIS_STATEIMAGEMASK) ? FALSE : TRUE;
	EnableBasedOnDefault();
	
	// set the description
	BSTR bstrString;
	if (FAILED(pItem->get_Description(&bstrString)))
		m_strDescription = "";
    else
		m_strDescription = BSTRtoCString(bstrString);
	if (bstrString)
		::SysFreeString(bstrString);

	// set the value
	msmConfigurableItemFormat eFormat;
	if (FAILED(pItem->get_Format(&eFormat)))
	{
		// if we couldn't get the format for some reason, assume text
		eFormat = msmConfigurableItemText;
	}
	switch (eFormat)
	{
	case msmConfigurableItemText:
	{
		BSTR bstrType = NULL;
		CString strType;
		if (FAILED(pItem->get_Type(&bstrType)))
		{
			// if we couldn't get the type, assume its an empty text type
			strType = "";
		}
		else
			strType = BSTRtoCString(bstrType);
		if (bstrType)
            ::SysFreeString(bstrType);
		if (strType == TEXT("Enum"))
		{
			EmptyCombo();
			m_ctrlEditNumber.ShowWindow(SW_HIDE);
			m_ctrlEditText.ShowWindow(SW_HIDE);
			BSTR bstrContext = NULL;
			CString strContext;
			if (FAILED(pItem->get_Context(&bstrContext)))
			{
				// an enum where we couldn't get the context. Any 
				// default is bound to be bad, so use an empty string
				strContext = "";
			}
			else
				strContext = BSTRtoCString(bstrContext);
			if (bstrContext)
				::SysFreeString(bstrContext);
			m_iKeyItemKeyCount = 0;
			m_fComboIsKeyItem = false;
			PopulateComboFromEnum(strContext, false);
			m_eActiveControl = eComboControl;
			m_ctrlEditCombo.ShowWindow(SW_SHOW);
		}
		else
		{
			// plain text
			m_eActiveControl = eTextControl;
			m_ctrlEditCombo.ShowWindow(SW_HIDE);
			m_ctrlEditNumber.ShowWindow(SW_HIDE);
			m_ctrlEditText.ShowWindow(SW_SHOW);
		}
		break;
	}
	case msmConfigurableItemInteger:
		m_eActiveControl = eNumberControl;
		m_ctrlEditCombo.ShowWindow(SW_HIDE);
		m_ctrlEditText.ShowWindow(SW_HIDE);
		m_ctrlEditNumber.ShowWindow(SW_SHOW);
		break;
	case msmConfigurableItemKey:
	{
		m_ctrlEditCombo.ResetContent();
		m_ctrlEditNumber.ShowWindow(SW_HIDE);
		m_ctrlEditText.ShowWindow(SW_HIDE);

		// populate the combo box with the keys in the appropriate table
		BSTR bstrTable = NULL;
		CString strTable;
		if (FAILED(pItem->get_Type(&bstrTable)))
		{
			// if we couldn't get the table name, anything we do is bad
			strTable = "";
		}
		else
			strTable = BSTRtoCString(bstrTable);
		if (bstrTable)
			::SysFreeString(bstrTable);
		
		COrcaTable* pTable = m_pDoc->FindAndRetrieveTable(strTable);
		if (pTable)
		{
			POSITION pos = pTable->GetRowHeadPosition();
			int cPrimaryKeys = pTable->GetKeyCount();
			while (pos)
			{
				CString strDisplayString = TEXT("");
				const COrcaRow* pRow = pTable->GetNextRow(pos);
				ASSERT(pRow);
				if (pRow)
				{
					const COrcaData* pCellData = pRow->GetData(0);
					ASSERT(pCellData);
					if (pCellData)
					{
						strDisplayString = pCellData->GetString();
					}
				}
				for (int i=1; i < cPrimaryKeys; i++)
				{
					strDisplayString += TEXT(";");
					ASSERT(pRow);
					if (pRow)
					{
						const COrcaData* pCellData = pRow->GetData(i);
						ASSERT(pCellData);
						if (pCellData)
							strDisplayString += pCellData->GetString();
					}
				}
				int iItem = m_ctrlEditCombo.AddString(strDisplayString);
				if (iItem != CB_ERR)
					m_ctrlEditCombo.SetItemDataPtr(iItem, const_cast<void *>(static_cast<const void *>(pRow)));
			}
			m_iKeyItemKeyCount = cPrimaryKeys;
		}
		
		// if the item is nullable, add the empty string
		long lAttributes = 0;
		if (FAILED(pItem->get_Attributes(&lAttributes)))
		{
			// couldn't get attributes, default is 0
			lAttributes = 0;
		}
		if ((lAttributes & msmConfigurableOptionNonNullable) == 0)
		{
			m_ctrlEditCombo.AddString(TEXT(""));
		}
		m_fComboIsKeyItem = true;
		
		m_eActiveControl = eComboControl;
		m_ctrlEditCombo.ShowWindow(SW_SHOW);
		break;
	}
	case msmConfigurableItemBitfield:
	{
		EmptyCombo();
		m_ctrlEditNumber.ShowWindow(SW_HIDE);
		m_ctrlEditText.ShowWindow(SW_HIDE);
		BSTR bstrContext = NULL;
		CString strContext;
		if (FAILED(pItem->get_Context(&bstrContext)))
		{
			// a bitfield where we couldn't get the context. Any 
			// default is bound to be bad, so use an empty string
			strContext = "";
		}
		else
			strContext = BSTRtoCString(bstrContext);
		if (bstrContext)
            ::SysFreeString(bstrContext);
		m_iKeyItemKeyCount = 0;
		m_fComboIsKeyItem = false;
		PopulateComboFromEnum(strContext, true);
		m_eActiveControl = eComboControl;
		m_ctrlEditCombo.ShowWindow(SW_SHOW);
		break;
	}
	}		

	// set the edit control to the current value
	CString strDefault = m_ctrlItemList.GetItemText(m_iOldItem, 1);
	SetSelToString(strDefault);

	UpdateData(FALSE);

	// m_ctrlDescription.ModifyStyle(WS_VSCROLL, 0);
	m_ctrlDescription.ShowScrollBar(SB_VERT, FALSE);

	// if EM_SCROLL returns non-zero in the lower word, it means that
	// the control scrolled a page down. Add a scrollbar and reflow the
	// text in the control.
	if (m_ctrlDescription.SendMessage(EM_SCROLL, SB_PAGEDOWN, 0) & 0xFFFF)
	{
		m_ctrlDescription.SendMessage(EM_SCROLL, SB_PAGEUP, 0);
		m_ctrlDescription.ShowScrollBar(SB_VERT, TRUE);
	}
	
	*pResult = 0;
}

void CConfigMsmD::ReadValuesFromReg()
{
	if (0 == AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("MemoryCount"), 0))
		return;

	CString strFileName;
	int iFirstChar = m_strModule.ReverseFind(TEXT('\\'));
	if (iFirstChar == -1)
		strFileName = m_strModule;
	else
		strFileName = m_strModule.Right(m_strModule.GetLength()-iFirstChar-1);
	strFileName.TrimRight();
	strFileName.MakeLower();

	HKEY hKey = 0;
	CString strKeyName;
	strKeyName.Format(TEXT("Software\\Microsoft\\Orca\\MergeMod\\CMSMInfo\\%s:%d"), strFileName, m_iLanguage);
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, strKeyName, 0, KEY_READ, &hKey))
	{
		int cItemCount = m_ctrlItemList.GetItemCount();
		ASSERT(cItemCount);
		for (int iItem = 0; iItem < cItemCount; iItem++)
		{
			sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(iItem));
			ASSERT(pData);
			BSTR bstrName = NULL;
			if (FAILED(pData->piItem->get_Name(&bstrName)))
			{
				ASSERT(0);
				// without a name we have no chance of finding the registry value
				continue;
			}
			CString strName = BSTRtoCString(bstrName);
			::SysFreeString(bstrName);
	
			DWORD cbBuffer = 0;
			if (ERROR_SUCCESS == RegQueryValueEx(hKey, strName, 0, NULL, NULL, &cbBuffer))
			{
				CString strValue;
				TCHAR *szBuffer = strValue.GetBuffer(cbBuffer/sizeof(TCHAR));
				if (ERROR_SUCCESS != RegQueryValueEx(hKey, strName, 0, NULL, reinterpret_cast<unsigned char *>(szBuffer), &cbBuffer))
				{
					// if we failed reading the registry, not much we can do
					ASSERT(0);
					continue;
				}
				strValue.ReleaseBuffer();  
	
				// if this is a key item, the key must be valid in the current database. If its not,
				// just use the module's default
				msmConfigurableItemFormat eFormat = msmConfigurableItemText;
				if ((S_OK == pData->piItem->get_Format(&eFormat)) && (eFormat == msmConfigurableItemKey))
				{
					BSTR bstrTable = NULL;
					if (FAILED(pData->piItem->get_Type(&bstrTable)))
					{
						// couldn't get the type for Key. No chance to load primary keys
						ASSERT(0);
						continue;
					}

					CString strTable = BSTRtoCString(bstrTable);
					if (bstrName)
						::SysFreeString(bstrName);
					COrcaTable *pTable = NULL;
					ASSERT(m_pDoc);
					if (m_pDoc)
					{
						pTable = m_pDoc->FindAndRetrieveTable(strTable);
					}
					if (!pTable)
					{
						continue;
					}

					// find the row that has primary keys that match this. 
					CString strThisKey=TEXT("");
					CStringArray rgstrRows;
					rgstrRows.SetSize(pTable->GetKeyCount());
					int iKey = 0;
					for (int i=0; i < strValue.GetLength(); i++)
					{
						switch (strValue[i])
						{
						case ';' :
							rgstrRows.SetAt(iKey++, strThisKey);
							strThisKey=TEXT("");
							break;
						case '\\' :
							i++;
							// fall through
						default:
							strThisKey += strValue[i];
						}
					}
					rgstrRows.SetAt(iKey, strThisKey);

					if (!pTable->GetData(pTable->ColArray()->GetAt(0)->m_strName, rgstrRows))
						continue;
				}
				
				// set this item to not use the default
				m_ctrlItemList.SetItemState(iItem, INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);

				// store the value, handles creation of display values as necessary
				SetItemToValue(iItem, strValue);

				// making this non-default enables the edit controls. Set the current state
				SetSelToString(strValue);
			}
		}
		RegCloseKey(hKey);
	}
}

void CConfigMsmD::WriteValuesToReg()
{
	int iMemoryLimit = 0;
	if (0 == (iMemoryLimit = AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("MemoryCount"), 0)))
		return;

	CString strFileName;
	int iFirstChar = m_strModule.ReverseFind(TEXT('\\'));
	if (iFirstChar == -1)
		strFileName = m_strModule;
	else
		strFileName = m_strModule.Right(m_strModule.GetLength()-iFirstChar-1);
	strFileName.TrimRight();
	strFileName.MakeLower();

	HKEY hBaseKey = 0;
	UINT uiRes = 0;

	// open the CMSM config key 
	if (ERROR_SUCCESS == (uiRes = RegCreateKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Orca\\MergeMod\\CMSMInfo"), 0, TEXT(""), 0, KEY_READ | KEY_WRITE, NULL, &hBaseKey, NULL)))
	{
		HKEY hModuleKey = 0;

		CString strKeyName;
		strKeyName.Format(TEXT("%s:%d"), strFileName, m_iLanguage);
		CString strOriginalName = strKeyName;
		
		if (ERROR_SUCCESS == (uiRes = RegCreateKeyEx(hBaseKey, strKeyName, 0, TEXT(""), 0, KEY_WRITE, NULL, &hModuleKey, NULL)))
		{
			int cItemCount = m_ctrlItemList.GetItemCount();
			for (int iItem = 0; iItem < cItemCount; iItem++)
			{
				sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(iItem));
				BSTR bstrName = NULL;
				if (FAILED(pData->piItem->get_Name(&bstrName)))
				{
					// no way to write into registry without the name
					continue;
				}
				CString strName = BSTRtoCString(bstrName);
				::SysFreeString(bstrName);
				
				// if not using the default, write to the registry, otherwise ensure its been deleted
				if (m_ctrlItemList.GetItemState(iItem, LVIS_STATEIMAGEMASK) == 0)
				{
					RegDeleteValue(hModuleKey, strName);
					continue;
				}
				else
				{		
					RegSetValueEx(hModuleKey, strName, 0, REG_SZ, reinterpret_cast<const unsigned char *>(static_cast<const TCHAR *>(pData->strValue)), (pData->strValue.GetLength()+1)*sizeof(TCHAR));
				}
			}
			RegCloseKey(hModuleKey);
		}

		// adjust the ordering of the MRU module list
		int iNext = 1;
		CString strName;
		strName.Format(TEXT("%d"), iNext);
		DWORD cbBuffer;

		// continue looping as long as we have more keys
		while (ERROR_SUCCESS == (uiRes = RegQueryValueEx(hBaseKey, strName, 0, NULL, NULL, &cbBuffer)))
		{
			CString strValue;
							
			TCHAR *szBuffer = strValue.GetBuffer(cbBuffer/sizeof(TCHAR));
			if (ERROR_SUCCESS != RegQueryValueEx(hBaseKey, strName, 0, NULL, reinterpret_cast<unsigned char *>(szBuffer), &cbBuffer))
			{
				// nothing we can do on registry failure
				continue;
			}
			strValue.ReleaseBuffer();

			// if this index is greater than the memory limit, delete the key
			if (iNext > iMemoryLimit)
				RegDeleteKey(hBaseKey, strValue);
			else
			{
				// if this value was the name of the module' being used, we can stop
				// shifting the order at this point
				if (strValue == strOriginalName)
					break;
					
				// otherwise set the value of this guy to the MRU module
				RegSetValueEx(hBaseKey, strName, 0, REG_SZ, reinterpret_cast<const unsigned char *>(static_cast<const TCHAR *>(strKeyName)), (strKeyName.GetLength()+1)*sizeof(TCHAR));

				// and set the previous value as the value to place in the next highest thing
				strKeyName = strValue;
			}

			iNext++;
			strName.Format(TEXT("%d"), iNext);
		}

		// if we finished everything and iNext isn't outside the memory limit, add a new index for this
		// module
		if (iNext <= iMemoryLimit)
			RegSetValueEx(hBaseKey, strName, 0, REG_SZ, reinterpret_cast<const unsigned char *>(static_cast<const TCHAR *>(strKeyName)), (strKeyName.GetLength()+1)*sizeof(TCHAR));
		else
			RegDeleteKey(hBaseKey, strKeyName);
			
		RegCloseKey(hBaseKey);
	}
}

///////////////////////////////////////////////////////////////////////
// This class implements the callback interface for the configurable
// merge system.


CMsmConfigCallback::CMsmConfigCallback()
{
	m_cRef = 1;
}

HRESULT CMsmConfigCallback::QueryInterface(const IID& iid, void** ppv)
{
	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<IMsmConfigureModule*>(this);
	if (iid == IID_IDispatch)
		*ppv = static_cast<IMsmConfigureModule*>(this);
	else if (iid == IID_IMsmConfigureModule)
		*ppv = static_cast<IMsmConfigureModule*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface

///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG CMsmConfigCallback::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef

///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG CMsmConfigCallback::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


/////////////////////////////////////////////////////////////////////////////
// IDispatch interface
HRESULT CMsmConfigCallback::GetTypeInfoCount(UINT* pctInfo)
{
	if(NULL == pctInfo)
		return E_INVALIDARG;

	*pctInfo = 0;
	return S_OK;
}

HRESULT CMsmConfigCallback::GetTypeInfo(UINT iTInfo, LCID /* lcid */, ITypeInfo** ppTypeInfo)
{
	if (NULL == ppTypeInfo)
		return E_INVALIDARG;

	*ppTypeInfo = NULL;
	return E_NOINTERFACE;
}

HRESULT CMsmConfigCallback::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
						 LCID lcid, DISPID* rgDispID)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	if (cNames == 0 || rgszNames == 0 || rgDispID == 0)
		return E_INVALIDARG;

	bool fError = false;
	for (UINT i=0; i < cNames; i++)
	{
		// CSTR_EQUAL == 2
		if(2 == CompareStringW(lcid, NORM_IGNORECASE, rgszNames[i], -1, L"ProvideTextData", -1))
		{
			rgDispID[i] = 1; // constant DispId for this interface
		}
		else if (2 == CompareStringW(lcid, NORM_IGNORECASE, rgszNames[i], -1, L"ProvideIntegerData", -1))
		{
			rgDispID[i] = 2;
		}
		else
		{
			fError = true;
			rgDispID[i] = -1;
		}
	}
	return fError ? DISP_E_UNKNOWNNAME : S_OK;
}

HRESULT CMsmConfigCallback::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
				  DISPPARAMS* pDispParams, VARIANT* pVarResult,
				  EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	if (wFlags & (DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
		return DISP_E_MEMBERNOTFOUND;

	HRESULT hRes = S_OK;
	switch (dispIdMember)
	{
	case 1:
		if (pDispParams->cArgs != 1)
			return E_INVALIDARG;

		return ProvideTextData(pDispParams->rgvarg[1].bstrVal, &pVarResult->bstrVal);
		break;
	case 2:
		if (pDispParams->cArgs != 1)
			return E_INVALIDARG;

		return ProvideIntegerData(pDispParams->rgvarg[1].bstrVal, &pVarResult->lVal);
		break;
	default:
		return DISP_E_MEMBERNOTFOUND;
	}
	return S_OK;
}

HRESULT CMsmConfigCallback::ProvideTextData(const BSTR Name, BSTR __RPC_FAR *ConfigData)
{
	CString strName = BSTRtoCString(Name);
	POSITION pos = m_lstData.GetHeadPosition();
	while (pos)
	{
		if (m_lstData.GetNext(pos) == strName)
		{
			ASSERT(pos);
			CString strValue = m_lstData.GetNext(pos);
#ifndef _UNICODE
            size_t cchBuffer = strValue.GetLength()+1;
            WCHAR* wzValue = new WCHAR[cchBuffer];
            ::MultiByteToWideChar(CP_ACP, 0, strValue, -1, wzValue, cchBuffer);
			*ConfigData = ::SysAllocString(wzValue);
            delete[] wzValue;
#else
			*ConfigData = ::SysAllocString(strValue);
#endif	// _UNICODE
			return S_OK;
		}

		// if the name doesn't match, skip over the value
		m_lstData.GetNext(pos);
	}

	// didn't find the name, so use the default
	return S_FALSE;
}

bool CMsmConfigCallback::ReadFromFile(const CString strFile)
{
	CStdioFile fileInput;
	if (!fileInput.Open(strFile, CFile::modeRead | CFile::shareDenyWrite | CFile::typeText))
		return false;

	CString strLine;
	while (fileInput.ReadString(strLine))
	{
		int iEqualsLoc = strLine.Find(TEXT('='));
		if (iEqualsLoc == -1)
			return false;

		m_lstData.AddTail(strLine.Left(iEqualsLoc));
		m_lstData.AddTail(strLine.Right(strLine.GetLength()-iEqualsLoc-1));
	}
	return true;
}


HRESULT CMsmConfigCallback::ProvideIntegerData(const BSTR Name, long __RPC_FAR *ConfigData)
{
	CString strName = BSTRtoCString(Name);
	POSITION pos = m_lstData.GetHeadPosition();
	while (pos)
	{
		if (m_lstData.GetNext(pos) == strName)
		{
			ASSERT(pos);
			CString strValue = m_lstData.GetNext(pos);
			*ConfigData = _ttol(strValue);
			return S_OK;
		}

		// if the name doesn't match, skip over the value
		m_lstData.GetNext(pos);
	}

	// didn't find the name, so use the default
	return S_FALSE;
}

///////////////////////////////////////////////////////////
// CheckFeature
// szFeatureName is a Feature that belongs to this product. 
// installs the feature if not present
BOOL CheckFeature(LPCTSTR szFeatureName)
{
#ifndef _WIN64
	// determine platform (Win9X or WinNT) -- EXE component code conditionalized on platform
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); // init structure
	if (!GetVersionEx(&osvi))
		return FALSE;

	bool fWin9X = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ? true : false;
#endif

	// get ProductCode -- Windows Installer can determine the product code from a component code.
	// Here we use the Orca main component (component containing orca.exe).  You must choose
	// a component that identifies the app, not a component that could be shared across products.
	// This is why we can't use the MergeMod component. EvalCom is shared between msival2 and orca
	// so the Windows Installer would be unable to determine to which product (if both were installed)
	// the component belonged.
	TCHAR szProductCode[MAX_GUID+1] = TEXT("");
	UINT iStat = 0;
	if (ERROR_SUCCESS != (iStat = MsiGetProductCode(
#ifdef _WIN64
		g_szOrcaWin64ComponentCode,
#else
		fWin9X ? g_szOrcaWin9XComponentCode : g_szOrcaWinNTComponentCode,
#endif
											szProductCode)))
	{
		// error obtaining product code (may not be installed or component code may have changed)
		return FALSE;
	}

	// Prepare to use the feature: check its current state and increase usage count.
	INSTALLSTATE iFeatureState = MsiUseFeature(szProductCode, szFeatureName);

	// If feature is not currently usable, try fixing it
	switch (iFeatureState) 
	{
	case INSTALLSTATE_LOCAL:
	case INSTALLSTATE_SOURCE:
		break;
	case INSTALLSTATE_ABSENT:
		// feature isn't installed, try installing it
		if (ERROR_SUCCESS != MsiConfigureFeature(szProductCode, szFeatureName, INSTALLSTATE_LOCAL))
			return FALSE;			// installation failed
		break;
	default:
		// feature is busted- try fixing it
		if (MsiReinstallFeature(szProductCode, szFeatureName, 
			REINSTALLMODE_FILEEQUALVERSION
			+ REINSTALLMODE_MACHINEDATA 
			+ REINSTALLMODE_USERDATA
			+ REINSTALLMODE_SHORTCUT) != ERROR_SUCCESS)
			return FALSE;			// we couldn't fix it
		break;
	}

	return TRUE;
}	// end of CheckFeature


BEGIN_MESSAGE_MAP(CStaticEdit, CEdit)
	ON_WM_NCHITTEST( )
END_MESSAGE_MAP()

UINT CStaticEdit::OnNcHitTest( CPoint point )
{
	UINT iRes = CEdit::OnNcHitTest(point);
	if (HTCLIENT == iRes)
		return HTTRANSPARENT;
	else
		return iRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\cnfgmsmd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//--------------------------------------------------------------------------

#if !defined(AFX_CNFGMSMD_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_)
#define AFX_CNFGMSMD_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include "orcadoc.h"
#include "mergemod.h"

/////////////////////////////////////////////////////////////////////////////
// CConfigMsmD dialog
class CMsmConfigCallback;

class CStaticEdit : public CEdit
{
protected:
	afx_msg UINT OnNcHitTest( CPoint point );
	DECLARE_MESSAGE_MAP()
};

class CConfigMsmD : public CDialog
{
// Construction
public:
	CConfigMsmD(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CConfigMsmD)
	enum { IDD = IDD_CONFIGUREMSM };
	CComboBox	m_ctrlEditCombo;
	CEdit       m_ctrlEditNumber;
	CEdit       m_ctrlEditText;
	CStaticEdit       m_ctrlDescription;
	CListCtrl   m_ctrlItemList;
	CString	m_strDescription;
	BOOL	m_bUseDefault;
	//}}AFX_DATA

	CString m_strModule;
	int     m_iLanguage;
	int     m_iOldItem;
	COrcaDoc* m_pDoc;
	CMsmConfigCallback *m_pCallback;
	
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigMsmD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfigMsmD)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnDestroy();
	afx_msg void OnFUseDefault();
	// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult);

private:
	void EnableBasedOnDefault();
	void SetSelToString(const CString& strValue);
	void SaveValueInItem();
	void PopulateComboFromEnum(const CString& strValue, bool fIsBitfield);
	CString GetValueByName(const CString& strInfo, const CString& strName, bool fIsBitfield);
	CString GetNameByValue(const CString& strInfo, const CString& strValue, bool fIsBitfield);
	void CConfigMsmD::EmptyCombo();
	int SetToDefaultValue(int iItem);
	int SetItemToValue(int iItem, const CString strValue);

	void ReadValuesFromReg();
	void WriteValuesToReg();

	bool m_fReadyForInput;
	bool m_fComboIsKeyItem;
	enum {
		eTextControl,
		eComboControl,
		eNumberControl
	} m_eActiveControl;
	int  m_iKeyItemKeyCount;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

// this class implements the callback interface
class CMsmConfigCallback : public IMsmConfigureModule
{
	
public:
	CMsmConfigCallback();
	
	// IUnknown interface
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID& iid, void** ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IDispatch methods
	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT* pctInfo);
	HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTI);
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
														 LCID lcid, DISPID* rgDispID);
	HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
											   DISPPARAMS* pDispParams, VARIANT* pVarResult,
												EXCEPINFO* pExcepInfo, UINT* puArgErr);
	HRESULT STDMETHODCALLTYPE InitTypeInfo();


	HRESULT STDMETHODCALLTYPE ProvideTextData(const BSTR Name, BSTR __RPC_FAR *ConfigData);
	HRESULT STDMETHODCALLTYPE ProvideIntegerData(const BSTR Name, long __RPC_FAR *ConfigData);

	// non-interface methods
	bool ReadFromFile(const CString strFile);
	
	CStringList m_lstData;

private:
	long m_cRef;
};

#endif // !defined(AFX_CNFGMSMD_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\column.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Column.cpp
//

#include "stdafx.h"
#include "Column.h"

///////////////////////////////////////////////////////////
// constructor
COrcaColumn::COrcaColumn(UINT iColumn, MSIHANDLE hColNames, MSIHANDLE hColTypes, BOOL bPrimaryKey)
{
	m_dwDisplayFlags = 0;
	m_iTransform = iTransformNone;
	m_iColumn = iColumn;

	DWORD cchBuffer = MAX_COLUMNNAME;
	MsiRecordGetString(hColNames, iColumn + 1, m_strName.GetBuffer(cchBuffer), &cchBuffer);
	m_strName.ReleaseBuffer();

	CString strBuffer;
	cchBuffer = MAX_COLUMNTYPE;
	MsiRecordGetString(hColTypes, iColumn + 1, strBuffer.GetBuffer(cchBuffer), &cchBuffer);
	strBuffer.ReleaseBuffer();

	// get the column type
	m_eiType = GetColumnType(strBuffer);

	// get the column size (_ttoi == atoi TCHAR)
	m_iSize = _ttoi(strBuffer.Mid(1));

	// if this is nuallable
	if (IsCharUpper(strBuffer[0]))
		m_bNullable = TRUE;
	else
		m_bNullable = FALSE;

	// set if primary key
	m_bPrimaryKey = (bPrimaryKey != 0);

	m_nWidth = -1;			// set the width invalid
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
COrcaColumn::~COrcaColumn()
{
}	// end of destructor

bool COrcaColumn::SameDefinition(UINT iColumn, MSIHANDLE hColNames, MSIHANDLE hColTypes, bool bPrimaryKey)
{
	m_iColumn = iColumn;
	OrcaColumnType eiType;
	int iSize;
	BOOL bNullable;
	CString strName;

	DWORD cchBuffer = MAX_COLUMNNAME;
	MsiRecordGetString(hColNames, iColumn + 1, strName.GetBuffer(cchBuffer), &cchBuffer);
	strName.ReleaseBuffer();

	CString strBuffer;
	cchBuffer = MAX_COLUMNTYPE;
	MsiRecordGetString(hColTypes, iColumn + 1, strBuffer.GetBuffer(cchBuffer), &cchBuffer);
	strBuffer.ReleaseBuffer();

	// get the column type
	eiType = GetColumnType(strBuffer);

	// get the column size (_ttoi == atoi TCHAR)
	iSize = _ttoi(strBuffer.Mid(1));

	// if this is nuallable
	if (IsCharUpper(strBuffer[0]))
		bNullable = TRUE;
	else
		bNullable = FALSE;

	// set if primary key
	if ((strName != m_strName) ||
		(eiType != m_eiType) || (iSize != m_iSize) || 
		(bNullable != m_bNullable) || (m_bPrimaryKey != bPrimaryKey))
		return false;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\column.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Column.h
//

#ifndef _ORCA_COLUMN_H_
#define _ORCA_COLUMN_H_

#define MAX_COLUMNNAME 64
#define MAX_COLUMNTYPE 64

#include "msiquery.h"
#include "data.h"

enum OrcaColumnType
{
	iColumnNone,
	iColumnString,
	iColumnLocal,
	iColumnShort,
	iColumnLong,
	iColumnBinary
};

class COrcaColumn : public CObject
{

public:
	COrcaColumn(UINT iColumn, MSIHANDLE hColNames, MSIHANDLE hColTypes, BOOL bPrimaryKey);
	~COrcaColumn();

	// transform information
	inline const OrcaTransformAction IsTransformed() const { return m_iTransform; };
	inline void Transform(const OrcaTransformAction iAction) { ASSERT(iAction != iTransformDrop); m_iTransform = iAction; }; 
	inline bool DisplayInHex() const { return (m_dwDisplayFlags & iDisplayFlagsHex) ? true : false; };
	inline void SetDisplayInHex(bool fHex) const { m_dwDisplayFlags = (m_dwDisplayFlags & ~iDisplayFlagsHex) | (fHex ? iDisplayFlagsHex : 0); };
	inline bool IsPrimaryKey() const { return m_bPrimaryKey; };
	bool SameDefinition(UINT iColumn, MSIHANDLE hColNames, MSIHANDLE hColTypes, bool bPrimaryKey);

	UINT m_iColumn;
	CString m_strName;
	OrcaColumnType m_eiType;
	int m_iSize;
	
	mutable int m_nWidth;
	mutable int m_dwDisplayFlags;

	BOOL m_bNullable;
	OrcaTransformAction m_iTransform;

private:
	bool m_bPrimaryKey;
};	// end of COrcaColumn

///////////////////////////////////////////////////////////
// GetColumnType
static OrcaColumnType GetColumnType(LPCTSTR szColumnType)
{
	OrcaColumnType iType;

	switch (*szColumnType)
	{
	case _T('s'):		// string
	case _T('S'):
		iType = iColumnString;
		break;
	case _T('l'):		// localizable string
	case _T('L'):
		iType = iColumnLocal;
		break;
	case _T('i'):		// integer
	case _T('I'):
		// if the number is a 2 use short
		if (_T('2') == *(szColumnType + 1))
			iType = iColumnShort;
		else if (_T('4') == *(szColumnType + 1))	// if 4 use LONG
			iType = iColumnLong;
		else	// don't know
			iType = iColumnNone;
		break;
	case L'v':	// binary
	case L'V':
	case L'o':
	case L'O':
		iType = iColumnBinary;
		break;
	default:	// unknown
		iType = iColumnNone;
	}

	return iType;
}

const int COLUMN_INVALID = 0xFFFFFF;

#endif	// _ORCA_COLUMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\data.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Data.cpp
//

#include "stdafx.h"
#include "Data.h"
#include "CellErrD.h"
#include "orcadoc.h"

///////////////////////////////////////////////////////////
// constructor
COrcaData::COrcaData()
{
	m_strData = "";
	m_dwFlags = 0;
	m_pErrors = NULL;
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
COrcaData::~COrcaData()
{
	ClearErrors();
}	// end of destructor


void COrcaData::AddError(int tResult, CString strICE, CString strDesc, CString strURL)
{
	COrcaDataError *newerror = new COrcaDataError();

	newerror->m_eiError = (OrcaDataError)tResult;
	newerror->m_strICE = strICE;
	newerror->m_strURL = strURL;
	newerror->m_strDescription = strDesc;

	if (!m_pErrors)
		m_pErrors = new CTypedPtrList<CObList, COrcaDataError *>;
	if (m_pErrors)
		m_pErrors->AddTail(newerror);
}

void COrcaData::ClearErrors()
{
	SetError(iDataNoError);
	if (m_pErrors)
	{
		POSITION pos = m_pErrors->GetHeadPosition();
		while (pos != NULL) {
			delete m_pErrors->GetNext(pos);
		};
		m_pErrors->RemoveAll();
		delete m_pErrors;
		m_pErrors = NULL;
	}
}

void COrcaData::ShowErrorDlg() const
{
	if (m_pErrors)
	{
		CCellErrD ErrorD(m_pErrors);
		ErrorD.DoModal();
	}
}



// retrieve the string representation of an integer. Display flags
// indicate hex or decimal. Value cached in m_strData, so only
// recalculated when the requested state changes.
const CString& COrcaIntegerData::GetString(DWORD dwFlags) const 
{
	if (IsNull())
	{
		if ((m_dwFlags & iDataFlagsCacheMask) != iDataFlagsCacheNull)
		{
			m_strData = TEXT("");
			m_dwFlags = (m_dwFlags & ~iDataFlagsCacheMask) | iDataFlagsCacheNull;
		}
	}
	else 
	{
		// check the requested format, Hex or Decimal
		if (dwFlags & iDisplayFlagsHex)
		{
			// check if recache required
			if ((m_dwFlags & iDataFlagsCacheMask) != iDataFlagsCacheHex)
			{
				m_strData.Format(TEXT("0x%08X"), m_dwValue);
				m_dwFlags = (m_dwFlags & ~iDataFlagsCacheMask) | iDataFlagsCacheHex;
			}
		}
		else
		{
			// check if recache required
			if ((m_dwFlags & iDataFlagsCacheMask) != iDataFlagsCacheDecimal)
			{
				m_strData.Format(TEXT("%d"), m_dwValue);
				m_dwFlags = (m_dwFlags & ~iDataFlagsCacheMask) | iDataFlagsCacheDecimal;
			}
		}
	}

	// return currently cached value
	return m_strData; 
};

////
// set integer data based on string. If the string is invalid,
// the cell doesn't change and false is returned
bool COrcaIntegerData::SetData(const CString& strData)
{
	if (strData.IsEmpty()) 
	{
		SetNull(true); 
		return true;
	} 
	else
	{
		DWORD dwValue = 0;
		if (ValidateIntegerValue(strData, dwValue))
		{
			SetIntegerData(dwValue);
			return true;
		}
	}
	return false;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\data.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Data.h
//

#ifndef _ORCA_DATA_H_
#define _ORCA_DATA_H_

#include "stdafx.h"
#include "msiquery.h"

enum OrcaDataError
{
	iDataNoError = 0,
	iDataError   = 1,
	iDataWarning = 2
};

enum OrcaTransformAction
{
	iTransformNone   = 0,
	iTransformChange = 1,
	iTransformAdd    = 2,
	iTransformDrop   = 3
};



// each cell has a DWORD of bit flags. The lower word is data cell
// flags. The high word is reserved for private display data that is not
// part of the real cell info.
//
// 31                           16                               0
// - - - - - - - - - - - - - C C C - - - - - - - - - - T T - N E E
// 
// C - cached format
// T - cell transform state
// N - null cell flag
// E - error bits

const DWORD iDataFlagsNull          = 0x0004;
const DWORD iDataFlagsErrorMask     = 0x0003;

const DWORD iDataFlagsTransformMask	= 0x0030;
const DWORD iDataFlagsDataMask      = 0xFFFF;

const DWORD iDataFlagsTransformShift = 4;
const DWORD iDataFlagsErrorShift     = 0;

const DWORD iDataFlagsCacheDecimal = 0x10000;
const DWORD iDataFlagsCacheHex     = 0x20000;
const DWORD iDataFlagsCacheNull    = 0x40000;
const DWORD iDataFlagsCacheMask    = 0x70000;

// flags passed to GetString to indicate desired format
const DWORD iDisplayFlagsDecimal = 0x00;
const DWORD iDisplayFlagsHex     = 0x01;

class COrcaDoc;

class OrcaFindInfo {
public:
	bool bWholeDoc;
	int iCount;
	bool bValid;
	CString strFindString;
	CString strUIFindString;
	bool bForward;
	bool bMatchCase;
	bool bWholeWord;

	////
	// operator== only checks the search options, not the results, so two queries
	// are equal even if they are in different states of the actual search
	inline bool operator==(OrcaFindInfo& b) {
		return ((strUIFindString == b.strUIFindString) && (b.bForward == bForward) &&
				(bMatchCase == b.bMatchCase) && (bWholeWord == b.bWholeWord));
	}
	inline bool operator!=(OrcaFindInfo& b) { return !operator==(b); };
};


class COrcaData : public CObject
{
	friend class CCellErrD;

public:
	COrcaData();
	~COrcaData();

	// retrieve display string.
	virtual const CString& GetString(DWORD dwFlags=0) const=0;

	// set/retrieve transform state
	inline const OrcaTransformAction IsTransformed() const { return static_cast<OrcaTransformAction>((m_dwFlags & iDataFlagsTransformMask) >> iDataFlagsTransformShift); };
	inline void  Transform(const OrcaTransformAction iAction) {	m_dwFlags = (m_dwFlags & ~iDataFlagsTransformMask) | (iAction << iDataFlagsTransformShift); };

	// set/retrieve error state
	inline void  SetError(const OrcaDataError eiError) { m_dwFlags = (m_dwFlags & ~iDataFlagsErrorMask) | (eiError << iDataFlagsErrorShift); };
	inline OrcaDataError GetError() const { return static_cast<OrcaDataError>((m_dwFlags & iDataFlagsErrorMask) >> iDataFlagsErrorShift); };
	
	// cell is null?
	inline bool IsNull() const { return (m_dwFlags & iDataFlagsNull) ? true : false; };
	
	// set data based on string.
	virtual bool SetData(const CString& strData)=0;

	// error manipulation
	void ClearErrors();
	void AddError(int tResult, CString strICE, CString strDesc, CString strURL);
	void ShowErrorDlg() const;

	// class to hold error information
	class COrcaDataError : public CObject
	{	
	public:
		OrcaDataError m_eiError;		// error type for message
		CString m_strICE;				// ice causing error
		CString m_strDescription;		// description of error
		CString m_strURL;				// URL top help with error
	};

protected:
	// set cell null flag
	inline void SetNull(bool fNullable) { m_dwFlags = (m_dwFlags & ~iDataFlagsNull) | (fNullable ? iDataFlagsNull : 0); };
	
	// see comments above for format of bitfield. Often contains
	// cache flags, so mutable
	mutable DWORD m_dwFlags;

	// string data. Often used as just a cache, so mutable.
	mutable CString m_strData;

	// pointer to list of errors for this cell. If NULL, no error.
	CTypedPtrList<CObList, COrcaDataError *> *m_pErrors;
};	// end of COrcaData


///////////////////////////////////////////////////////////////////////
// integer data cell. Stores data as DWORD. String in base class is 
// used to cache string representation (in hex or decimal)
class COrcaIntegerData : public COrcaData
{
public:
	COrcaIntegerData() : COrcaData(), m_dwValue(0) {};
	virtual ~COrcaIntegerData() {};

	virtual const CString& GetString(DWORD dwFlags=0) const;
	const DWORD GetInteger() const { return m_dwValue; };

	bool SetData(const CString& strData);
	inline void SetIntegerData(const DWORD dwData) { SetNull(false); m_dwValue = dwData; m_dwFlags = (m_dwFlags & ~iDataFlagsCacheMask);
};

private:
	DWORD m_dwValue;
};

class COrcaStringData : public COrcaData
{
public:
	virtual const CString& GetString(DWORD dwFlags=0) const { return m_strData; };

	bool SetData(const CString& strData) { SetNull(strData.IsEmpty() ? true : false); m_strData = strData; return true;};
private:
};

#endif	// _ORCA_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\displypp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// DisplayPropPage.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "DisplyPP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDisplayPropPage property page

IMPLEMENT_DYNCREATE(CDisplayPropPage, CPropertyPage)

CDisplayPropPage::CDisplayPropPage() : CPropertyPage(CDisplayPropPage::IDD)
{
	//{{AFX_DATA_INIT(CDisplayPropPage)
	m_sFontName = _T("");
	m_bCaseSensitive = FALSE;
	m_bForceColumns = FALSE;
	//}}AFX_DATA_INIT

	m_pbrshSelect = NULL;
	m_pbrshNormal = NULL;
	m_pbrshFocus = NULL;
	m_pbrshSelectT = NULL;
	m_pbrshNormalT = NULL;
	m_pbrshFocusT = NULL;
}

CDisplayPropPage::~CDisplayPropPage()
{
	delete m_pbrshSelect;	
	delete m_pbrshFocus;	
	delete m_pbrshNormal;	
	delete m_pbrshSelectT;	
	delete m_pbrshFocusT;	
	delete m_pbrshNormalT;	
}

void CDisplayPropPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDisplayPropPage)
	DDX_Text(pDX, IDC_FONTNAME, m_sFontName);
	DDX_Check(pDX, IDC_CASESENSITIVE, m_bCaseSensitive);
	DDX_Check(pDX, IDC_FORCECOLUMNS, m_bForceColumns);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDisplayPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CDisplayPropPage)
	ON_BN_CLICKED(IDC_CHFONT, OnChfont)
	ON_WM_DESTROY()
	ON_WM_CTLCOLOR()
	ON_BN_CLICKED(IDC_COLORSEL, OnColorsel)
	ON_BN_CLICKED(IDC_COLORFOCUS, OnColorfocus)
	ON_BN_CLICKED(IDC_COLORNORM, OnColornorm)
	ON_BN_CLICKED(IDC_TEXTSEL, OnTextsel)
	ON_BN_CLICKED(IDC_TEXTFOCUS, OnTextfocus)
	ON_BN_CLICKED(IDC_TEXTNORM, OnTextnorm)
	ON_BN_CLICKED(IDC_CASESENSITIVE, OnDataChange)
	ON_BN_CLICKED(IDC_FORCECOLUMNS, OnDataChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDisplayPropPage message handlers

void CDisplayPropPage::OnChfont() 
{
	// run the font dialog
	if (IDOK == m_pdFontDialog->DoModal()) 
	{
		m_bFontChange = true;
		m_strFontName = m_pdFontDialog->GetFaceName();
		m_iFontSize = m_pdFontDialog->GetSize();
		UpdateFontName();
		UpdateData(FALSE);
	}
}

BOOL CDisplayPropPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	m_pdFontDialog = new CFontDialog(&m_fSelectedFont, 
		CF_EFFECTS|CF_SCREENFONTS|CF_FORCEFONTEXIST|CF_INITTOLOGFONTSTRUCT, NULL, this);
	m_strFontName = m_pdFontDialog->GetFaceName();

	m_bColorChange = false;
	m_bFontChange = false;
	m_bMiscChange = false;
	UpdateFontName();
	UpdateData(FALSE);
	return TRUE;  
}

void CDisplayPropPage::OnDestroy() 
{
	CPropertyPage::OnDestroy();
	delete m_pdFontDialog;	
}

HBRUSH CDisplayPropPage::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{	
	if (nCtlColor == CTLCOLOR_STATIC)
	{
		pDC->SetBkMode(TRANSPARENT);
		switch (pWnd->GetDlgCtrlID())
		{
		case IDC_SELSAMP: pDC->SetTextColor(m_clrTextSel);
		case IDC_COLORSEL: return *m_pbrshSelect;
		case IDC_NORMSAMP: pDC->SetTextColor(m_clrTextNorm);
		case IDC_COLORNORM: return *m_pbrshNormal;
		case IDC_FOCSAMP: pDC->SetTextColor(m_clrTextFoc);
		case IDC_COLORFOCUS: return *m_pbrshFocus;
		case IDC_TEXTSEL: return *m_pbrshSelectT;
		case IDC_TEXTNORM: return *m_pbrshNormalT;
		case IDC_TEXTFOCUS: return *m_pbrshFocusT;
		default: break;
		}
	}
	return CPropertyPage::OnCtlColor(pDC, pWnd, nCtlColor);
}

void CDisplayPropPage::GetColors(COLORREF &norm, COLORREF &sel, COLORREF &foc)
{
	LOGBRUSH lbrshTemp;
	m_pbrshSelect->GetLogBrush(&lbrshTemp);
	sel = lbrshTemp.lbColor;
	m_pbrshNormal->GetLogBrush(&lbrshTemp);
	norm = lbrshTemp.lbColor;
	m_pbrshFocus->GetLogBrush(&lbrshTemp);
	foc = lbrshTemp.lbColor;
}

void CDisplayPropPage::GetColorsT(COLORREF &norm, COLORREF &sel, COLORREF &foc)
{
	norm = m_clrTextNorm;
	sel = m_clrTextSel;
	foc = m_clrTextFoc;
}

COLORREF CDisplayPropPage::OnColorDialog(CBrush **newBrush) 
{
	COLORREF clrRet;
	LOGBRUSH lbrshTemp;
	(*newBrush)->GetLogBrush(&lbrshTemp);
	clrRet = lbrshTemp.lbColor;
	CColorDialog *pdColorDialog = new CColorDialog(clrRet);

	if (IDOK == pdColorDialog->DoModal()) 
	{
		delete *newBrush;
		clrRet = pdColorDialog->GetColor();
		*newBrush = new CBrush(clrRet);
		m_bColorChange = true;
	};
	delete pdColorDialog;
	return clrRet;
}	

void CDisplayPropPage::UpdateFontName()
{
	m_sFontName.Format(_T("%s, %0.1fpt."), m_strFontName, (float)(m_iFontSize)/10.0);
}

void CDisplayPropPage::OnColorfocus() 
{
	OnColorDialog(&m_pbrshFocus);
	GetDlgItem(IDC_COLORFOCUS)->Invalidate();
	GetDlgItem(IDC_FOCSAMP)->Invalidate();	
}

void CDisplayPropPage::OnColornorm() 
{
	OnColorDialog(&m_pbrshNormal);
	GetDlgItem(IDC_COLORNORM)->Invalidate();	
	GetDlgItem(IDC_NORMSAMP)->Invalidate();
}

void CDisplayPropPage::OnColorsel() 
{
	OnColorDialog(&m_pbrshSelect);
	GetDlgItem(IDC_COLORSEL)->Invalidate();	
	GetDlgItem(IDC_SELSAMP)->Invalidate();	
}


void CDisplayPropPage::OnTextsel() 
{
	m_clrTextSel=OnColorDialog(&m_pbrshSelectT);
	GetDlgItem(IDC_TEXTSEL)->Invalidate();	
	GetDlgItem(IDC_SELSAMP)->Invalidate();	
}

void CDisplayPropPage::OnTextfocus() 
{
	m_clrTextFoc = OnColorDialog(&m_pbrshFocusT);
	GetDlgItem(IDC_TEXTFOCUS)->Invalidate();	
	GetDlgItem(IDC_FOCSAMP)->Invalidate();	
}

void CDisplayPropPage::OnTextnorm() 
{
	m_clrTextNorm = OnColorDialog(&m_pbrshNormalT);
	GetDlgItem(IDC_TEXTNORM)->Invalidate();	
	GetDlgItem(IDC_NORMSAMP)->Invalidate();	
}

void CDisplayPropPage::SetColors(COLORREF norm, COLORREF sel, COLORREF foc)
{
	m_pbrshSelect = new CBrush();
	m_pbrshFocus = new CBrush();
	m_pbrshNormal = new CBrush();
	m_pbrshSelect->CreateSolidBrush(sel);
	m_pbrshFocus->CreateSolidBrush(foc);
	m_pbrshNormal->CreateSolidBrush(norm);
}

void CDisplayPropPage::SetColorsT(COLORREF norm, COLORREF sel, COLORREF foc)
{
	m_pbrshSelectT = new CBrush();
	m_pbrshFocusT = new CBrush();
	m_pbrshNormalT = new CBrush();
	m_pbrshSelectT->CreateSolidBrush(sel);
	m_pbrshFocusT->CreateSolidBrush(foc);
	m_pbrshNormalT->CreateSolidBrush(norm);
	m_clrTextNorm = norm;
	m_clrTextSel = sel;
	m_clrTextFoc = foc;
}
void CDisplayPropPage::OnDataChange() 
{
	m_bMiscChange = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\displypp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_DISPLAYPROPPAGE_H__68AFD20E_2594_11D2_8888_00A0C981B015__INCLUDED_)
#define AFX_DISPLAYPROPPAGE_H__68AFD20E_2594_11D2_8888_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DisplayPropPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDisplayPropPage dialog

class CDisplayPropPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CDisplayPropPage)

// Construction
public:
	bool m_bMiscChange;
	void SetColors(COLORREF norm, COLORREF sel, COLORREF foc);
	void SetColorsT(COLORREF norm, COLORREF sel, COLORREF foc);
	bool m_bColorChange;
	void CDisplayPropPage::GetColors(COLORREF &norm, COLORREF &sel, COLORREF &foc);
	void CDisplayPropPage::GetColorsT(COLORREF &norm, COLORREF &sel, COLORREF &foc);
	CString m_strFontName;
	LOGFONT m_fSelectedFont;
	int m_iFontSize;
	bool m_bFontChange;
	CDisplayPropPage();
	~CDisplayPropPage();
	CFontDialog* m_pdFontDialog;

// Dialog Data
	//{{AFX_DATA(CDisplayPropPage)
	enum { IDD = ID_PAGE_FONT };
	CString	m_sFontName;
	BOOL	m_bCaseSensitive;
	BOOL    m_bForceColumns;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDisplayPropPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDisplayPropPage)
	afx_msg void OnChfont();
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnColorsel();
	afx_msg void OnColorfocus();
	afx_msg void OnColornorm();
	afx_msg void OnTextsel();
	afx_msg void OnTextfocus();
	afx_msg void OnTextnorm();
	afx_msg void OnDataChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void UpdateFontName();
	COLORREF OnColorDialog(CBrush **newBrush); 
	
	CBrush * m_pbrshSelect;
	CBrush * m_pbrshFocus;
	CBrush * m_pbrshNormal;
	CBrush * m_pbrshSelectT;
	CBrush * m_pbrshFocusT;
	CBrush * m_pbrshNormalT;
	COLORREF m_clrTextNorm;
	COLORREF m_clrTextSel;
	COLORREF m_clrTextFoc;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DISPLAYPROPPAGE_H__68AFD20E_2594_11D2_8888_00A0C981B015__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\domerge.h ===
/////////////////////////////////////////////////////////////////////////////
// domerge.h
//		A MergeMod client
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#ifndef _DOMERGE_H_
#define _DOMERGE_H_

#define WINDOWS_LEAN_AND_MEAN 
#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>

typedef void (* LPMERGEDISPLAY)(const BSTR);

enum eCommit_t { 
	commitNo = 0,
	commitYes = 1,
	commitForce = 2
};

struct IMsmConfigureModule;
struct IMsmErrors;
HRESULT ExecuteMerge(const LPMERGEDISPLAY pfnDisplay, const TCHAR *szDatabase, const TCHAR *szModule, 
					 const TCHAR *szFeatures, const int iLanguage = -1, const TCHAR *szRedirectDir = NULL, 
					 const TCHAR *szCABDir = NULL, const TCHAR *szExtractDir = NULL,  const TCHAR *szImageDir = NULL, 
					 const TCHAR *szLogFile = NULL, bool fLogAfterOpen = false, bool fLFN = false, 
					 IMsmConfigureModule* piConfig = NULL, IMsmErrors** ppiErrors = NULL, eCommit_t eCommit = commitNo);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\domerge.cpp ===
/////////////////////////////////////////////////////////////////////////////
// domerge.cpp
//		A MergeMod client
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#include "..\common\utils.h"
#include "msiquery.h"
#include <winerror.h>
#include <objbase.h>
#include <initguid.h>
#include "mergemod.h"
#include "msidefs.h"
#include "domerge.h"

///////////////////////////////////////////////////////////
// CheckFeature
// pre:	szFeatureName is a Feature that belongs to this product
// pos:	installs the feature if not present and we go
/*
BOOL CheckFeature(LPCTSTR szFeatureName)
{
	// Prepare to use the feature: check its current state and increase usage count.
	INSTALLSTATE iFeatureState = MSI::MsiUseFeature(g_szProductCode, szFeatureName);
	//MsiQueryFeatureState(g_szProductCode, szFeatureName);
	

	// If feature is not currently usable, try fixing it
	switch (iFeatureState) 
	{
	case INSTALLSTATE_LOCAL:
	case INSTALLSTATE_SOURCE:
		break;
	case INSTALLSTATE_ABSENT:
		// feature isn't installed, try installing it
		if (ERROR_SUCCESS != MSI::MsiConfigureFeature(g_szProductCode, szFeatureName, INSTALLSTATE_LOCAL))
			return FALSE;			// installation failed
		break;
	default:
		// feature is busted- try fixing it
		if (MsiReinstallFeature(g_szProductCode, szFeatureName, 
			REINSTALLMODE_FILEEQUALVERSION
			+ REINSTALLMODE_MACHINEDATA 
			+ REINSTALLMODE_USERDATA
			+ REINSTALLMODE_SHORTCUT) != ERROR_SUCCESS)
			return FALSE;			// we couldn't fix it
		break;
	}

	return TRUE;
}	// end of CheckFeature
*/

HRESULT ExecuteMerge(const LPMERGEDISPLAY pfnDisplay, const TCHAR *szDatabase, const TCHAR *szModule, 
			 const TCHAR *szFeatures, const int iLanguage, const TCHAR *szRedirectDir, const TCHAR *szCABDir, 
			 const TCHAR *szExtractDir, const TCHAR *szImageDir, const TCHAR *szLogFile, bool fLogAfterOpen,
			 bool fLFN, IMsmConfigureModule *piConfigureInterface, IMsmErrors** ppiErrors, eCommit_t eCommit)
{
	if ((!szDatabase) || (!szModule) || (!szFeatures))
		return E_INVALIDARG;

	if (ppiErrors)
		*ppiErrors = NULL;

	// create a Mergemod COM object
	IMsmMerge2* pIExecute;
	HRESULT hResult = ::CoCreateInstance(CLSID_MsmMerge2, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
														  IID_IMsmMerge2, (void**)&pIExecute);

	// if failed to create the object
	if (FAILED(hResult)) 
	{
		printf("Could not load Merge Module COM Server");
		return hResult;
	}

	if (!fLogAfterOpen && szLogFile && (szLogFile[0] != TEXT('\0')))
	{
		// open the log file
		WCHAR wzLogFile[MAX_PATH] = {0};
#ifndef _UNICODE
		int cchBuffer = MAX_PATH;
		::MultiByteToWideChar(CP_ACP, 0, szLogFile, -1, wzLogFile, cchBuffer);
#else
		lstrcpy(wzLogFile, szLogFile);
#endif
		BSTR bstrLogFile = ::SysAllocString(wzLogFile);
		pIExecute->OpenLog(bstrLogFile);
		::SysFreeString(bstrLogFile);
	}

	WCHAR wzModule[MAX_PATH] = L"";
	WCHAR wzFeature[91] = L"";
	WCHAR wzRedirect[91] = L"";


	// calculate the language to be used
	int iUseLang = -1;
	if (iLanguage == -1)
	{
		UINT iType;
		int iValue;
		FILETIME ftValue;
		UINT iResult;
		LPTSTR szValue = new TCHAR[100];
		DWORD cchValue = 100;


		PMSIHANDLE hSummary;
		::MsiGetSummaryInformation(0, szDatabase, 0, &hSummary);
		iResult = ::MsiSummaryInfoGetProperty(hSummary, PID_TEMPLATE, &iType, &iValue, &ftValue, szValue, &cchValue);
		if (ERROR_MORE_DATA == iResult) 
		{
			delete[] szValue;
			szValue = new TCHAR[++cchValue];
			iResult = ::MsiSummaryInfoGetProperty(hSummary, PID_TEMPLATE, &iType, &iValue, &ftValue, szValue, &cchValue);
		}
		if (ERROR_SUCCESS != iResult)
		{
			delete[] szValue;
			BSTR bstrLog = ::SysAllocString(L">> Unable to retrieve language from database SummaryInfo stream.\r\n");
			pIExecute->Log(bstrLog);
			if (pfnDisplay) pfnDisplay(bstrLog);
			::SysFreeString(bstrLog);
			pIExecute->Release();
			return E_FAIL;
		}

		// the string now contains the template property
		// parse it for the semicolon
		TCHAR *szSemi = _tcschr(szValue, _T(';'));
		TCHAR *szLanguage = (szSemi != NULL) ? szSemi+1 : szValue;
		if (_istdigit(*szLanguage)) 
			iUseLang = _ttoi(szLanguage);
		delete[] szValue;
	}
	else 
		iUseLang = iLanguage;

	// check that we have a language
	if (iUseLang == -1)
	{
		BSTR bstrLog = ::SysAllocString(L">> Unable to determine language to use for merge module. Specify a language on the command line.\r\n");
		pIExecute->Log(bstrLog);
		if (pfnDisplay) pfnDisplay(bstrLog);
		::SysFreeString(bstrLog);
		pIExecute->Release();
		return E_FAIL;
	}

	// open the database
	WCHAR wzDatabase[MAX_PATH];
#ifndef _UNICODE
	int cchBuffer = MAX_PATH;
	::MultiByteToWideChar(CP_ACP, 0, szDatabase, -1, wzDatabase, cchBuffer);
#else
	lstrcpy(wzDatabase, szDatabase);
#endif	// _UNICODE
	BSTR bstrDatabase = ::SysAllocString(wzDatabase);
	hResult = pIExecute->OpenDatabase(bstrDatabase);
	::SysFreeString(bstrDatabase);
	if (FAILED(hResult))
	{
		BSTR bstrLog = SysAllocString(L">> Fatal Error: Failed to open MSI Database.\r\n");
		pIExecute->Log(bstrLog);
		if (pfnDisplay) pfnDisplay(bstrLog);
		::SysFreeString(bstrLog);
		pIExecute->Release();
		return E_FAIL;
	}

	if (fLogAfterOpen && szLogFile && (szLogFile[0] != TEXT('\0')))
	{
		// open the log file
		WCHAR wzLogFile[MAX_PATH] = {0};
#ifndef _UNICODE
		int cchLogFile = MAX_PATH;
		::MultiByteToWideChar(CP_ACP, 0, szLogFile, -1, wzLogFile, cchLogFile);
#else
		lstrcpy(wzLogFile, szLogFile);
#endif
		BSTR bstrLogFile = ::SysAllocString(wzLogFile);
		pIExecute->OpenLog(bstrLogFile);
		::SysFreeString(bstrLogFile);
	}

	// try to open the module
#ifndef _UNICODE
	cchBuffer = MAX_PATH;
	::MultiByteToWideChar(CP_ACP, 0, szModule, -1, wzModule, cchBuffer);
#else
	lstrcpy(wzModule, szModule);
#endif	// _UNICODE
	BSTR bstrModule = ::SysAllocString(wzModule);
	hResult = pIExecute->OpenModule(bstrModule, static_cast<short>(iUseLang));
	::SysFreeString(bstrModule);
	if (FAILED(hResult))
	{
		BSTR bstrLog = ::SysAllocString(L">> Failed to open Merge Module.\r\n");
		pIExecute->Log(bstrLog);
		if (pfnDisplay) pfnDisplay(bstrLog);
		::SysFreeString(bstrLog);
		pIExecute->Release();
		return E_FAIL;
	}


	// if there is a colon
	TCHAR * szExtraFeatures = _tcschr(szFeatures, _T(':'));
	if (szExtraFeatures)
	{
		*szExtraFeatures = _T('\0');
		szExtraFeatures = _tcsinc(szExtraFeatures);
	}

#ifndef _UNICODE
	cchBuffer = 91;
	::MultiByteToWideChar(CP_ACP, 0, szFeatures, -1, wzFeature, cchBuffer);
#else
	lstrcpy(wzFeature, szFeatures);
#endif

	// create a wide version of the redirect dir
	if (szRedirectDir)
	{
#ifndef _UNICODE
		cchBuffer = 91;
		::MultiByteToWideChar(CP_ACP, 0, szRedirectDir, -1, wzRedirect, cchBuffer);
#else
		lstrcpy(wzRedirect, szRedirectDir);
#endif
	}

	bool fPerformExtraction = false;
	BSTR bstrFeature = ::SysAllocString(wzFeature);
	BSTR bstrRedirect = ::SysAllocString(wzRedirect);
	hResult = pIExecute->MergeEx(bstrFeature, bstrRedirect, piConfigureInterface);
	::SysFreeString(bstrFeature);
	::SysFreeString(bstrRedirect);
	if (FAILED(hResult))
	{
		fPerformExtraction = false;
		BSTR bstrLog = ::SysAllocString(L">> Failed to merge Merge Module.\r\n");
		pIExecute->Log(bstrLog);
		if (pfnDisplay) pfnDisplay(bstrLog);
		::SysFreeString(bstrLog);
	}
	else
	{
		fPerformExtraction = true;

		// while there is something to set the feature to the extra features
		while (szExtraFeatures)
		{
			*(szExtraFeatures-1) = _T(':');
			// if there is a colon
			TCHAR *szTemp = _tcschr(szExtraFeatures, _T(':'));
			if (szTemp) 
				*szTemp = _T('\0');
	
	#ifndef _UNICODE
			cchBuffer = 91;
			::MultiByteToWideChar(CP_ACP, 0, szExtraFeatures, -1, wzFeature, cchBuffer);
	#else
			lstrcpy(wzFeature, szExtraFeatures);
	#endif	// _UNICODE
			bstrFeature = ::SysAllocString(wzFeature);
			hResult = pIExecute->Connect(bstrFeature);
			::SysFreeString(bstrFeature);
	
			if (szTemp) 
			{
				*szTemp = _T(':');
				szExtraFeatures = _tcsinc(szTemp);
			} 
			else
				szExtraFeatures = NULL;
		}
	}

	// try to get the error enumerator
	if (ppiErrors)
		hResult = pIExecute->get_Errors(ppiErrors);

	IMsmErrors* pErrors;
	long cErrors;
	hResult = pIExecute->get_Errors(&pErrors);
	if (FAILED(hResult))
	{
		BSTR bstrLog = ::SysAllocString(L">> Error: Failed to retrieve errors.\n");
		pIExecute->Log(bstrLog);
		if (pfnDisplay) pfnDisplay(bstrLog);
		::SysFreeString(bstrLog);
		if (eCommit != commitForce) eCommit = commitNo;
	}
	else 
	{
		pErrors->get_Count(&cErrors);
		if (0 != cErrors)	// if there are a few errors
		{
			if (eCommit != commitForce) eCommit = commitNo;
		}
		// log the errors
		msmErrorType errType;							// error type returned
		UINT iErrorCount = 0;				// number of errors displayed

		TCHAR szLogError[1025];				// string to ready to display to log
		WCHAR wzDisplay[1025];				// string to actually display to log
#ifndef _UNICODE
		char szErrorBuffer[1025];			// buffer to display strings
		size_t cchErrorBuffer = 1025;
#endif	// !_UNICODE
		ULONG cErrorsFetched;				// number of errors returned
		IMsmError* pIError;

		// get the enumerator, and immediately query it for the right type
		// of interface
		IUnknown *pUnk;
		IEnumMsmError *pIEnumErrors;
		pErrors->get__NewEnum(&pUnk);	
		pUnk->QueryInterface(IID_IEnumMsmError, (void **)&pIEnumErrors);
		pUnk->Release();

		// get the next error.
		pIEnumErrors->Next(1, &pIError, &cErrorsFetched);

		IMsmStrings* pIDatabaseError;		// database error enumerator (strings)
		IMsmStrings* pIModuleError;		// module error enumerator (strings)
		BSTR bstrError;						// pointer to error string
		DWORD cErrorStrings;					// number of strings retrieved

		// while an error is fetched
		while (cErrorsFetched && pIError)
		{
			// get the error type
			pIError->get_Type(&errType);

			// if the errType is a merge/unmerge conflict
			if (msmErrorTableMerge == errType)
			{
				// get error collections
				pIError->get_DatabaseKeys(&pIDatabaseError);
				pIError->get_ModuleKeys(&pIModuleError);

				// fill up the error buffer with tables and rows
				pIError->get_DatabaseTable(&bstrError);
				lstrcpy(szLogError, _T(">> Error: Merge conflict in Database Table: `"));
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				::SysFreeString(bstrError);

				lstrcat(szLogError, _T("` & Module Table: `"));
				pIError->get_ModuleTable(&bstrError);
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				::SysFreeString(bstrError);
				lstrcat(szLogError, _T("` - Row(s): `"));

				// tack on the error strings
				IEnumMsmString *pIStrings;
				pIDatabaseError->get__NewEnum((IUnknown **)&pUnk);
				pUnk->QueryInterface(IID_IEnumMsmString, (void **)&pIStrings);
				pUnk->Release();

				pIStrings->Next(1, &bstrError, &cErrorStrings);
				while(cErrorStrings > 0)
				{
#ifdef _UNICODE
					lstrcat(szLogError, bstrError);
#else
					cchErrorBuffer = 1025;
					WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
					lstrcat(szLogError, szErrorBuffer);
#endif
					lstrcat(szLogError, _T("`, `"));
					SysFreeString(bstrError);
					pIStrings->Next(1, &bstrError, &cErrorStrings);
				}

				// tack on the ending error stuff
				lstrcat(szLogError, _T("`\r\n"));

#ifdef _UNICODE
				lstrcpy(wzDisplay, szLogError);
#else
				cchErrorBuffer = 1025;
				AnsiToWide(szLogError, (WCHAR*)wzDisplay, &cchErrorBuffer);
#endif
				BSTR bstrLog = ::SysAllocString(wzDisplay);
				pIExecute->Log(bstrLog);		// log error table and rows
				if (pfnDisplay) pfnDisplay(bstrLog);
				::SysFreeString(bstrLog);

				// release the enumerators/collections
				pIStrings->Release();
				pIDatabaseError->Release();
				pIModuleError->Release();

				// up the error count
				iErrorCount++;
			}
			else if (msmErrorResequenceMerge == errType)
			{
				// get error collections
				pIError->get_DatabaseKeys(&pIDatabaseError);
				pIError->get_ModuleKeys(&pIModuleError);

				// fill up the error buffer with tables and rows
				pIError->get_DatabaseTable(&bstrError);
				lstrcpy(szLogError, _T(">> Error: Merge conflict in Database Table: `"));
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				::SysFreeString(bstrError);

				lstrcat(szLogError, _T("` - Action: `"));
				pIDatabaseError->get_Item(1, &bstrError);
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				::SysFreeString(bstrError);
				lstrcat(szLogError, _T("`\r\n"));

#ifdef _UNICODE
				lstrcpy(wzDisplay, szLogError);
#else
				cchErrorBuffer = 1025;
				AnsiToWide(szLogError, (WCHAR*)wzDisplay, &cchErrorBuffer);
#endif
				BSTR bstrLog = ::SysAllocString(wzDisplay);
				pIExecute->Log(bstrLog);		// log error table and rows
				if (pfnDisplay) pfnDisplay(bstrLog);
				::SysFreeString(bstrLog);

				// release the enumerators
				pIDatabaseError->Release();
				pIModuleError->Release();

				// up the error count
				iErrorCount++;
			}
			else if (msmErrorExclusion == errType)
			{
				// could go either way, moduleerror or database error
				pIError->get_ModuleKeys(&pIModuleError);
				long lCount;
				pIModuleError->get_Count(&lCount);
				if (lCount == 0)
				{
					pIError->get_DatabaseKeys(&pIModuleError);
					pIModuleError->get_Count(&lCount);
				}

				// display error ModuleID
				lstrcpy(szLogError, _T(">> Error: Exclusion detected for Merge Module ID: "));
				pIModuleError->get_Item(1, &bstrError);
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				SysFreeString(bstrError);
				lstrcat(szLogError, _T(" "));

				
				pIModuleError->get_Item(2, &bstrError);
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				SysFreeString(bstrError);
				lstrcat(szLogError, _T(", "));

				pIModuleError->get_Item(3, &bstrError);
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				SysFreeString(bstrError);
				lstrcat(szLogError, _T("\r\n"));

				// create wide version for output log
#ifdef _UNICODE
				lstrcpy(wzDisplay, szLogError);
#else
				cchErrorBuffer = 1025;
				AnsiToWide(szLogError, (WCHAR*)wzDisplay, &cchErrorBuffer);
#endif
				BSTR bstrLog = ::SysAllocString(wzDisplay);
				pIExecute->Log(bstrLog);		// log error table and rows
				if (pfnDisplay) pfnDisplay(bstrLog);
				::SysFreeString(bstrLog);

				// release enumerator
				pIModuleError->Release();

				// up the error count
				iErrorCount++;
			}

			// release this error and get the next error
			pIError->Release();
			pIError = NULL;
			pIEnumErrors->Next(1, &pIError, &cErrorsFetched);
		}

		// set the buffer to print out all errors
		_stprintf(szLogError, _T("Total merge conflicts: %d\r\n"), iErrorCount);
#ifdef _UNICODE
		lstrcpy(wzDisplay, szLogError);
#else
		cchErrorBuffer = 1025;
		AnsiToWide(szLogError, (WCHAR*)wzDisplay, &cchErrorBuffer);
#endif
		BSTR bstrLog = ::SysAllocString(wzDisplay);
		pIExecute->Log(bstrLog);		// log error table and rows
		if (pfnDisplay) pfnDisplay(bstrLog);
		::SysFreeString(bstrLog);

		pIEnumErrors->Release();	// release the error enumerator now
	}

	if (fPerformExtraction)
	{
		if (szExtractDir && (szExtractDir[0] != '\0'))
		{
			// now do extraction
			WCHAR wzExtract[MAX_PATH];
#ifndef _UNICODE
			cchBuffer = MAX_PATH;
			::MultiByteToWideChar(CP_ACP, 0, szExtractDir, -1, wzExtract, cchBuffer);
#else
			lstrcpy(wzExtract, szExtractDir);
#endif	// _UNICODE
			BSTR bstrExtract = ::SysAllocString(wzExtract);
			pIExecute->ExtractFilesEx(bstrExtract, fLFN, NULL);
			::SysFreeString(bstrExtract);
			if (FAILED(hResult))
			{
				BSTR bstrLog = ::SysAllocString(L">> Failed to merge Merge Module.\r\n");
				pIExecute->Log(bstrLog);
				if (pfnDisplay) pfnDisplay(bstrLog);
				::SysFreeString(bstrLog);
				pIExecute->Release();
				return E_FAIL;
			}
		}
	
		if (szCABDir && (szCABDir[0] != '\0'))
		{
			// now do extraction
			WCHAR wzExtract[MAX_PATH];
#ifndef _UNICODE
			cchBuffer = MAX_PATH;
			::MultiByteToWideChar(CP_ACP, 0, szCABDir, -1, wzExtract, cchBuffer);
#else
			lstrcpy(wzExtract, szCABDir);
#endif	// _UNICODE
			BSTR bstrExtract = ::SysAllocString(wzExtract);
			pIExecute->ExtractCAB(bstrExtract);
			::SysFreeString(bstrExtract);
			if (FAILED(hResult))
			{
				BSTR bstrLog = ::SysAllocString(L">> Failed to merge Merge Module.\r\n");
				pIExecute->Log(bstrLog);
				if (pfnDisplay) pfnDisplay(bstrLog);
				::SysFreeString(bstrLog);
				pIExecute->Release();
				return E_FAIL;
			}
		}
		
		if (szImageDir && (szImageDir[0] != '\0'))
		{
			// now do extraction
			WCHAR wzExtract[MAX_PATH];
#ifndef _UNICODE
			cchBuffer = MAX_PATH;
			::MultiByteToWideChar(CP_ACP, 0, szImageDir, -1, wzExtract, cchBuffer);
#else
			lstrcpy(wzExtract, szImageDir);
#endif	// _UNICODE
			BSTR bstrExtract = ::SysAllocString(wzExtract);
			pIExecute->CreateSourceImage(bstrExtract, true, NULL);
			::SysFreeString(bstrExtract);
			if (FAILED(hResult))
			{
				BSTR bstrLog = ::SysAllocString(L">> Failed to merge Merge Module.\r\n");
				pIExecute->Log(bstrLog);
				if (pfnDisplay) pfnDisplay(bstrLog);
				::SysFreeString(bstrLog);
				pIExecute->Release();
				return E_FAIL;
			}
		}
	}

	// close all the open files
	pIExecute->CloseModule();
	if (fLogAfterOpen) 
		pIExecute->CloseLog();
	pIExecute->CloseDatabase(eCommit != commitNo);
	if (!fLogAfterOpen) 
		pIExecute->CloseLog();

	// release and leave happy
	pIExecute->Release();
	return (0 == cErrors) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\editbind.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_EDITBIND_H__28D3018A_0558_11D2_AD4E_00A0C9AF11A6__INCLUDED_)
#define AFX_EDITBIND_H__28D3018A_0558_11D2_AD4E_00A0C9AF11A6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// EditBinD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditBinD dialog

class CEditBinD : public CDialog
{
// Construction
public:
	CEditBinD(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEditBinD)
	enum { IDD = IDD_BINARY_EDIT };
	int		m_nAction;
    bool    m_fNullable;
	bool    m_fCellIsNull;
	CString	m_strFilename;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditBinD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEditBinD)
	virtual BOOL OnInitDialog();
	afx_msg void OnBrowse();
	virtual void OnOK();
	afx_msg void OnAction();
	afx_msg void OnRadio2();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EDITBIND_H__28D3018A_0558_11D2_AD4E_00A0C9AF11A6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\editbind.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// EditBinD.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "EditBinD.h"
#include "folderd.h"

#include "..\common\utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditBinD dialog


CEditBinD::CEditBinD(CWnd* pParent /*=NULL*/)
	: CDialog(CEditBinD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEditBinD)
	m_nAction = 0;
	m_strFilename = _T("");
    m_fNullable = false;
	//}}AFX_DATA_INIT
}


void CEditBinD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditBinD)
	DDX_Radio(pDX, IDC_ACTION, m_nAction);
	DDX_Text(pDX, IDC_PATH, m_strFilename);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEditBinD, CDialog)
	//{{AFX_MSG_MAP(CEditBinD)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	ON_BN_CLICKED(IDC_ACTION, OnAction)
	ON_BN_CLICKED(IDC_WRITETOFILE, OnRadio2)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditBinD message handlers

BOOL CEditBinD::OnInitDialog() 
{
	CDialog::OnInitDialog();

	if (m_fCellIsNull)
	{
		CButton* pButton = (CButton*)GetDlgItem(IDC_WRITETOFILE);
		if (pButton)
			pButton->EnableWindow(FALSE);
	}
	return TRUE;
}

void CEditBinD::OnBrowse() 
{
	CFileDialogEx dlgFile(TRUE, NULL, m_strFilename, OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, _T("All Files (*.*)|*.*||"), this);

	if (IDOK == dlgFile.DoModal()) 
	{
		m_strFilename = dlgFile.GetPathName();
		UpdateData(false);
	}
}

void CEditBinD::OnAction() 
{
	UpdateData(TRUE);
	GetDlgItem(IDC_BROWSE)->EnableWindow(m_nAction == 0);
}

void CEditBinD::OnRadio2() 
{
	UpdateData(TRUE);
	GetDlgItem(IDC_BROWSE)->EnableWindow(m_nAction == 0);
}

void CEditBinD::OnOK() 
{
	UpdateData(TRUE);

	BOOL bGood = TRUE;	// assume we will pass

	if ((0 != m_nAction || !m_fNullable) && m_strFilename.IsEmpty())
	{
		AfxMessageBox(_T("A filename must be specified."));
		return;
	}

	if (0 == m_nAction)	// if importing
	{
		if (!m_strFilename.IsEmpty() && !FileExists(m_strFilename))
		{
			CString strPrompt;
			strPrompt.Format(_T("File `%s` does not exist."), m_strFilename);
			AfxMessageBox(strPrompt);
			bGood = FALSE;
		}
		else	// found the file prepare an overwrite
		{
			// if they don't want to overwrite
			if (IDOK != AfxMessageBox(_T("This will overwrite the current contents of the stream.\nContinue?"), MB_OKCANCEL))
				bGood = FALSE;
		}
	}
	else	// exporting
	{
		int nFind = m_strFilename.ReverseFind(_T('\\'));

		// if found a `\`
		if (-1 != nFind)
		{
			CString strPath;
			strPath = m_strFilename.Left(nFind);

			// if the path does not exist forget it
			if (!PathExists(strPath))
			{
				CString strPrompt;
				strPrompt.Format(_T("Path `%s` does not exist."), strPath);
				AfxMessageBox(strPrompt);
				bGood = FALSE;
			}
		}
		// else file is going to current path
	}

	if (bGood)
		CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\iface.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       iface.h
//
//--------------------------------------------------------------------------

// iface.h - Evaluation COM Object Interfaces declarations

#ifndef _EVALUATION_COM_INTERFACES_H_
#define _EVALUATION_COM_INTERFACES_H_

#include <objbase.h>


// returned from IEvalResult::GetResultType
typedef enum RESULTTYPES	
{
	ieUnknown = 0,
	ieError,
	ieWarning,
	ieInfo,
};

// values passed to status callback
typedef enum STATUSTYPES
{
	ieStatusGetCUB,
	ieStatusMerge,
	ieStatusSummaryInfo,
	ieStatusCreateEngine,
	ieStatusStarting,
	ieStatusRunICE,
	ieStatusRunSequence,
	ieStatusShutdown,
	ieStatusSuccess,
	ieStatusFail
};

///////////////////////////////////////////////////////////
// IEvalResult
interface IEvalResult : IUnknown
{
	virtual HRESULT __stdcall GetResultType(UINT* puiResultType) = 0;
	virtual HRESULT __stdcall GetResult(IEnumString** pResult) = 0;
};	// end of IEvalResult


///////////////////////////////////////////////////////////
// IEnumEvalResult
interface IEnumEvalResult : IUnknown
{
	virtual HRESULT __stdcall Next(ULONG cResults, IEvalResult** rgpResult, ULONG* pcResultsFetched) = 0;
	virtual HRESULT __stdcall Skip(ULONG cResults) = 0;
	virtual HRESULT __stdcall Reset(void) = 0;
	virtual HRESULT __stdcall Clone(IEnumEvalResult** ppEnum) = 0;
};	// end of IEnumEvalResult


typedef BOOL (WINAPI* LPDISPLAYVAL)(LPVOID pContext, UINT uiType, LPCWSTR szwVal, LPCWSTR szwDescription, LPCWSTR szwLocation);
typedef HRESULT (WINAPI* LPEVALCOMCALLBACK)(STATUSTYPES iStatus, LPVOID pData, LPVOID pContext);

///////////////////////////////////////////////////////////
// IEval
interface IEval : IUnknown
{
	// open/close methods
	virtual HRESULT __stdcall OpenDatabase(LPCOLESTR szDatabase) = 0;				// database to evaluate
	virtual HRESULT __stdcall OpenEvaluations(LPCOLESTR szEvaluation) = 0;		// database that contains evaluations
	virtual HRESULT __stdcall CloseDatabase() = 0;
	virtual HRESULT __stdcall CloseEvaluations() = 0;

	// set methods
	virtual HRESULT __stdcall SetDisplay(LPDISPLAYVAL pDisplayFunction,			// function to handle display
													 LPVOID pContext) = 0;						// context passed back to display
	// evaluation methods
	virtual HRESULT __stdcall Evaluate(LPCOLESTR szRunEvaluations = NULL) = 0;	// internal consistency evaluations to run
	virtual HRESULT __stdcall GetResults(IEnumEvalResult** ppResults,				// result enumerator
													 ULONG* pcResults) = 0;						// number of results
};	// end of IEval

///////////////////////////////////////////////////////////
// ValCom GUIDs
// CLSID_EvalCom
//	IID_IEval
//	IID_IEvalResult
//	IID_IEnumEvalResult

// {DC550E10-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(CLSID_EvalCom, 
0xdc550e10, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);

// {DC550E11-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(IID_IEval, 
0xdc550e11, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);

// {DC550E12-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(IID_IEvalResult, 
0xdc550e12, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);

// {DC550E13-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(IID_IEnumEvalResult, 
0xdc550e13, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);

/*
// {DC550E14-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(<<name>>, 
0xdc550e14, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);
*/

#endif	// _EVALUATION_COM_INTERFACES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\exportd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// ExportD.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "ExportD.h"
#include "FolderD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CExportD dialog


CExportD::CExportD(CWnd* pParent /*=NULL*/)
	: CDialog(CExportD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CExportD)
	m_strDir = _T("");
	//}}AFX_DATA_INIT

	m_plistTables = NULL;
}


void CExportD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CExportD)
	DDX_Text(pDX, IDC_OUTPUT_DIR, m_strDir);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CExportD, CDialog)
	//{{AFX_MSG_MAP(CExportD)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	ON_BN_CLICKED(IDC_SELECT_ALL, OnSelectAll)
	ON_BN_CLICKED(IDC_CLEAR_ALL, OnClearAll)
	ON_BN_CLICKED(IDC_INVERT, OnInvert)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CExportD message handlers

BOOL CExportD::OnInitDialog() 
{
	ASSERT(m_plistTables);
	CDialog::OnInitDialog();

	// subclass list box to a checkbox
	m_ctrlList.SubclassDlgItem(IDC_LIST_TABLES, this);
	
	int nAddedAt;
	CString strAdd;
	while (m_plistTables->GetHeadPosition())
	{
		strAdd = m_plistTables->RemoveHead();
		nAddedAt = m_ctrlList.AddString(strAdd);

		if (strAdd == m_strSelect)
			m_ctrlList.SetCheck(nAddedAt, 1);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CExportD::OnBrowse() 
{
	UpdateData();

	CFolderDialog dlg(this->m_hWnd, _T("Select a directory to Export to."));

	if (IDOK == dlg.DoModal())
	{
		// update the dialog box
		m_strDir = dlg.GetPath();
		UpdateData(FALSE);
	}
}

void CExportD::OnSelectAll() 
{
	// set all to checks
	int cTables = m_ctrlList.GetCount();
	for (int i = 0; i < cTables; i++)
		m_ctrlList.SetCheck(i, 1);
}

void CExportD::OnClearAll() 
{
	// set all to checks
	int cTables = m_ctrlList.GetCount();
	for (int i = 0; i < cTables; i++)
		m_ctrlList.SetCheck(i, 0);
}

void CExportD::OnInvert() 
{
	// set all to checks
	int cTables = m_ctrlList.GetCount();
	for (int i = 0; i < cTables; i++)
		m_ctrlList.SetCheck(i, !m_ctrlList.GetCheck(i));
}

void CExportD::OnOK()
{
	UpdateData();

	if (m_strDir.IsEmpty())
	{
		AfxMessageBox(_T("A valid output directory must be specified"));
		GotoDlgCtrl(GetDlgItem(IDC_OUTPUT_DIR));
	}
	else 
	{
		DWORD dwAttrib = GetFileAttributes(m_strDir);
		if ((0xFFFFFFFF == dwAttrib) ||					// does not exist
			 !(FILE_ATTRIBUTE_DIRECTORY & dwAttrib))	// if not a directory
		{
			AfxMessageBox(_T("Output directory does not exist."));
			GotoDlgCtrl(GetDlgItem(IDC_OUTPUT_DIR));
		}
		else	// good to go
		{
			CString strTable;
			int cTables = m_ctrlList.GetCount();
			for (int i = 0; i < cTables; i++)
			{
				// if the table is checked add it back in the list
				if (1 == m_ctrlList.GetCheck(i))
				{
					m_ctrlList.GetText(i, strTable);
					m_plistTables->AddTail(strTable);
				}
			}

			CDialog::OnOK();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\exportd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_EXPORTD_H__25468EE2_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_)
#define AFX_EXPORTD_H__25468EE2_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ExportD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CExportD dialog

class CExportD : public CDialog
{
// Construction
public:
	CExportD(CWnd* pParent = NULL);   // standard constructor

	CStringList* m_plistTables;
	CString m_strSelect;
	CCheckListBox m_ctrlList;

// Dialog Data
	//{{AFX_DATA(CExportD)
	enum { IDD = IDD_EXPORT_TABLE };
	CString	m_strDir;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CExportD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CExportD)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnBrowse();
	afx_msg void OnSelectAll();
	afx_msg void OnClearAll();
	afx_msg void OnInvert();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXPORTD_H__25468EE2_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\folderd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// FolderD.h
//

#ifndef _FOLDER_DIALOG_H_
#define _FOLDER_DIALOG_H_

#include <shlobj.h>
#include <commdlg.h>

class CFolderDialog
{
public:
	CFolderDialog(HWND hWnd, LPCTSTR strTitle);

	UINT DoModal();
	LPCTSTR GetPath();

protected:
	BROWSEINFO m_bi;
	CString m_strFolder;
};	// end of CFolderDialog


///////////////////////////////////////////////////////////////////////////
// CFileDialogEx: Encapsulate Windows-2000 style open dialog.
class CFileDialogEx : public CFileDialog {
      DECLARE_DYNAMIC(CFileDialogEx)
public: 
      CFileDialogEx(BOOL bOpenFileDialog, // TRUE for open, 
                                          // FALSE for FileSaveAs
      LPCTSTR lpszDefExt = NULL,
      LPCTSTR lpszFileName = NULL,
      DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
      LPCTSTR lpszFilter = NULL,
      CWnd* pParentWnd = NULL);

   // override
   virtual INT_PTR DoModal();

protected:
	// new Windows 2000 version of OPENFILENAME, larger than the one used by MFC
	// so on OS < Win2K, set the size to ignore the extra members
   OPENFILENAME m_ofnEx;

   virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

   DECLARE_MESSAGE_MAP()
   //{{AFX_MSG(CFileDialogEx)
   //}}AFX_MSG
};

#endif	// _FOLDER_DIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\folderd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// FolderD.cpp
//

#include "stdafx.h"
#include "FolderD.h"

CFolderDialog::CFolderDialog(HWND hWnd, LPCTSTR szTitle)
{
	m_bi.hwndOwner = hWnd;
	m_bi.lpszTitle = szTitle;
	m_bi.ulFlags = 0;
	m_bi.pidlRoot = NULL;
	m_bi.lpfn = NULL;
	m_bi.lParam = 0;
	m_bi.iImage = 0;
}

UINT CFolderDialog::DoModal()
{
	UINT iResult = IDCANCEL;	// assume nothing will happen

	// open the dialog
	m_bi.pszDisplayName = m_strFolder.GetBuffer(MAX_PATH);
	LPITEMIDLIST pItemID = SHBrowseForFolder(&m_bi);
	m_strFolder.ReleaseBuffer();

	// if it was good
	if (pItemID)
	{
		// get the full path name
		if (SHGetPathFromIDList(pItemID, m_strFolder.GetBuffer(MAX_PATH))) 
			iResult = IDOK;

		m_strFolder.ReleaseBuffer();
	}

	return iResult;
}

LPCTSTR CFolderDialog::GetPath()
{
	return m_strFolder;
}


// CFileDialogEx code is based on "C++ Q&A" column from MSDN, August 2000.
// with some modifications to eliminate re-defining various structures in
// the header files.
static BOOL IsWin2000();

///////////////////////////////////////////////////////////////////////////
// CFileDialogEx

IMPLEMENT_DYNAMIC(CFileDialogEx, CFileDialog)

// constructor just passes all arguments to base version
CFileDialogEx::CFileDialogEx(BOOL bOpenFileDialog,
   LPCTSTR lpszDefExt,
   LPCTSTR lpszFileName,
   DWORD dwFlags, LPCTSTR lpszFilter, CWnd* pParentWnd) :
   CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName,
      dwFlags, lpszFilter, pParentWnd)
{
}

BEGIN_MESSAGE_MAP(CFileDialogEx, CFileDialog)
   //{{AFX_MSG_MAP(CFileDialogEx)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// window creation hooking
void AFXAPI AfxHookWindowCreate(CWnd* pWnd);
BOOL AFXAPI AfxUnhookWindowCreate();

BOOL IsWin2000() 
{
	OSVERSIONINFO osvi;
	ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	
	if( ! GetVersionEx ((OSVERSIONINFO *) &osvi))
		return FALSE;
	
	switch (osvi.dwPlatformId)
	{
		case VER_PLATFORM_WIN32_NT:
		{
			if ( osvi.dwMajorVersion >= 5 )
				return TRUE;
			break;
		}
	}
	return FALSE; 
}

INT_PTR CFileDialogEx::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_ofn.Flags & OFN_ENABLEHOOK);
	ASSERT(m_ofn.lpfnHook != NULL); // can still be a user hook
	
	// zero out the file buffer for consistent parsing later
	ASSERT(AfxIsValidAddress(m_ofn.lpstrFile, m_ofn.nMaxFile));
	DWORD nOffset = lstrlen(m_ofn.lpstrFile)+1;
	ASSERT(nOffset <= m_ofn.nMaxFile);
	memset(m_ofn.lpstrFile+nOffset, 0, (m_ofn.nMaxFile-nOffset)*sizeof(TCHAR));
	
	// WINBUG: This is a special case for the file open/save dialog,
	//  which sometimes pumps while it is coming up but before it has
	//  disabled the main window.
	HWND hWndFocus = ::GetFocus();
	BOOL bEnableParent = FALSE;
	m_ofn.hwndOwner = PreModal();
	AfxUnhookWindowCreate();
	if (m_ofn.hwndOwner != NULL && ::IsWindowEnabled(m_ofn.hwndOwner))
	{
		bEnableParent = TRUE;
		::EnableWindow(m_ofn.hwndOwner, FALSE);
	}
	
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	ASSERT(pThreadState->m_pAlternateWndInit == NULL);
	
	if (m_ofn.Flags & OFN_EXPLORER)
		pThreadState->m_pAlternateWndInit = this;
	else
		AfxHookWindowCreate(this);
	
	memset(&m_ofnEx, 0, sizeof(m_ofnEx));
	memcpy(&m_ofnEx, &m_ofn, sizeof(m_ofn));
	if (IsWin2000())
		m_ofnEx.lStructSize = sizeof(m_ofnEx);
	else
		m_ofnEx.lStructSize = OPENFILENAME_SIZE_VERSION_400;
	
	
	int nResult;
	if (m_bOpenFileDialog)
		nResult = ::GetOpenFileName((OPENFILENAME*)&m_ofnEx);
	else
		nResult = ::GetSaveFileName((OPENFILENAME*)&m_ofnEx);
	
	memcpy(&m_ofn, &m_ofnEx, sizeof(m_ofn));
	m_ofn.lStructSize = sizeof(m_ofn);
	
	if (nResult)
		ASSERT(pThreadState->m_pAlternateWndInit == NULL);
		pThreadState->m_pAlternateWndInit = NULL;
	
	// WINBUG: Second part of special case for file open/save dialog.
	if (bEnableParent)
		::EnableWindow(m_ofnEx.hwndOwner, TRUE);
	if (::IsWindow(hWndFocus))
		::SetFocus(hWndFocus);
	
	PostModal();
	return nResult ? nResult : IDCANCEL;
}

BOOL CFileDialogEx::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	memcpy(&m_ofn, &m_ofnEx, sizeof(m_ofn));
	m_ofn.lStructSize = sizeof(m_ofn);
	
	return CFileDialog::OnNotify( wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\helpd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// HelpD.cpp : implementation file
//

#include "stdafx.h"
#include "Orca.h"
#include "HelpD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelpD dialog


CHelpD::CHelpD(CWnd* pParent /*=NULL*/)
	: CDialog(CHelpD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CHelpD)
	m_strVersion = _T("Orca Version ");
	//}}AFX_DATA_INIT
	m_strVersion += static_cast<COrcaApp *>(AfxGetApp())->GetOrcaVersion();
}


void CHelpD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHelpD)
	DDX_Text(pDX, IDC_VERSIONSTRING, m_strVersion);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHelpD, CDialog)
	//{{AFX_MSG_MAP(CHelpD)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelpD message handlers

BOOL CHelpD::OnInitDialog() 
{
	CDialog::OnInitDialog();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\helpd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

#if !defined(AFX_HELPD_H__20272D55_EADD_11D1_A857_006097ABDE17__INCLUDED_)
#define AFX_HELPD_H__20272D55_EADD_11D1_A857_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// HelpD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHelpD dialog

class CHelpD : public CDialog
{
// Construction
public:
	CHelpD(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CHelpD)
	enum { IDD = IDD_HELP_DIALOG };
	CString	m_strVersion;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHelpD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CHelpD)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HELPD_H__20272D55_EADD_11D1_A857_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\imprtdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// ImprtDlg.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include <cderr.h>
#include "ImprtDlg.h"
#include "..\common\query.h"
#include "folderd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CImportDlg dialog
const TCHAR *CImportDlg::rgszAction[4] = {
	_T("Import"),
	_T("Replace"),
	_T("Merge"),
	_T("Skip"),
};

CImportDlg::CImportDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CImportDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CImportDlg)
	m_iAction = -1;
	//}}AFX_DATA_INIT
}


void CImportDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CImportDlg)
	DDX_Control(pDX, IDC_IMPORT, m_bImport);
	DDX_Control(pDX, IDC_MERGE, m_bMerge);
	DDX_Control(pDX, IDC_REPLACE, m_bReplace);
	DDX_Control(pDX, IDC_SKIP, m_bSkip);
	DDX_Control(pDX, IDC_TABLELIST, m_ctrlTableList);
	DDX_Radio(pDX, IDC_IMPORT, m_iAction);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CImportDlg, CDialog)
	//{{AFX_MSG_MAP(CImportDlg)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_TABLELIST, OnItemchangedTablelist)
	ON_BN_CLICKED(IDC_IMPORT, OnActionChange)
	ON_BN_CLICKED(IDC_MERGE, OnActionChange)
	ON_BN_CLICKED(IDC_REPLACE, OnActionChange)
	ON_BN_CLICKED(IDC_SKIP, OnActionChange)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CImportDlg message handlers

BOOL CImportDlg::OnInitDialog() 
{
	CWaitCursor curWait;
	CDialog::OnInitDialog();

	// add columns to the list ctrl
	m_ctrlTableList.InsertColumn(1, _T("Table"), LVCFMT_LEFT, -1, 0);  
	m_ctrlTableList.InsertColumn(2, _T("Action"), LVCFMT_LEFT, -1, 1); 
//	m_ctrlTableList.SetWindowLong(0, LVS_EX_FULLROWSELECT, 0);
//	SetWindowLong(m_ctrlTableList.m_hWnd, GWL_EXSTYLE, LVS_EX_FULLROWSELECT);

	// open a temporary import database
	DWORD cchPath;
	TCHAR *szPath = m_strTempPath.GetBuffer(MAX_PATH);
	cchPath = GetTempPath(MAX_PATH, szPath);
	if (cchPath > MAX_PATH) 
	{
		m_strTempPath.ReleaseBuffer();
		szPath = m_strTempPath.GetBuffer(cchPath+1);
		cchPath++;
		GetTempPath(cchPath, szPath);
	}
	m_strTempPath.ReleaseBuffer();
	TCHAR *szFilename = m_strTempFilename.GetBuffer(MAX_PATH);
	GetTempFileName(m_strTempPath, _T("ORC"), 0, szFilename);
	m_strTempFilename.ReleaseBuffer();
	::MsiOpenDatabase(m_strTempFilename, MSIDBOPEN_CREATE, &m_hImportDB);

	// run the File Browse Dialog, import, and add selections to the list view control
	OnBrowse();

	// if we don't need any user input, don't show the dialog
	if (m_cNeedInput == 0)
		OnOK();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CImportDlg::OnBrowse() 
{
	m_cNeedInput = 0;

	// set to true if one or more tables has a merge table.
	bool bMergeConflict = false;

	CFileDialogEx FileD(true, _T("idt"), NULL, 
		OFN_ALLOWMULTISELECT | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, 
		_T("IDT files (*.idt)|*.idt|All Files (*.*)|*.*||"), this);

	TCHAR rgchBuffer[2048] = _T("");
	FileD.m_ofn.lpstrFile = rgchBuffer;
	FileD.m_ofn.nMaxFile = 2048;
	FileD.m_ofn.lpstrInitialDir = m_strImportDir;

	if (IDOK == FileD.DoModal())
	{
		// throw up a wait cursor
		CWaitCursor curWait;

		// retrieve the directory
		m_strImportDir = FileD.GetPathName();

		// open a temporary database which holds each individual table as imported. 
		// merge all data from the real database into this database, then drop it all.
		// this sets the code page so that CP conflicts can be detected as early as
		// possible.
		CString strTempFilename;
		PMSIHANDLE hTempDB;
		TCHAR *szFilename = strTempFilename.GetBuffer(MAX_PATH);
		::GetTempFileName(m_strTempPath, _T("ORC"), 0, szFilename);
		strTempFilename.ReleaseBuffer();
		::MsiOpenDatabase(strTempFilename, MSIDBOPEN_CREATE, &hTempDB);
		::MsiDatabaseMerge(hTempDB, m_hFinalDB, NULL);
		// drop all tables
		{
			CQuery qTables;
			CQuery qDrop;
			PMSIHANDLE hTable;
			qTables.OpenExecute(hTempDB, NULL, _T("SELECT * FROM _Tables"));
			while (ERROR_SUCCESS == qTables.Fetch(&hTable))
			{
				CString strTable;
				RecordGetString(hTable, 1, strTable);
				qDrop.OpenExecute(hTempDB, 0, _T("DROP TABLE `%s`"), strTable);
			}
		}

		// open a second temporary database which holds all of the individual tables
		// collectively as they are imported. This table is used to detect merge conflicts
		// before actually modifying the target database.
		PMSIHANDLE hTempDB2;
		CString strTempFilename2;
		szFilename = strTempFilename2.GetBuffer(MAX_PATH);
		::GetTempFileName(m_strTempPath, _T("ORC"), 0, szFilename);
		strTempFilename2.ReleaseBuffer();
		::MsiOpenDatabase(strTempFilename2, MSIDBOPEN_CREATE, &hTempDB2);
		::MsiDatabaseMerge(hTempDB2, m_hFinalDB, NULL);

		// add the imported tables to the listview control. If table name already exists,
		// overwrite what exists.
		CQuery qCollide;
		CQuery qExists;
		CQuery qConflict;
		PMSIHANDLE hTableRec;
		LVITEM itemTable;
		TCHAR szTableName[255];
		unsigned long cchTableName = 255;

		itemTable.mask = LVIF_TEXT;
		itemTable.iItem = 0;
		itemTable.iSubItem = 0;
		itemTable.state = 0;
		itemTable.stateMask = 0;
		itemTable.pszText = NULL;
		itemTable.cchTextMax = 0;
		itemTable.iImage = 0;
		itemTable.lParam = 0;
		itemTable.iIndent = 0;

		// import the files into this temporary database, as well as the import database.
		POSITION posFile = FileD.GetStartPosition();
		while (posFile)
		{

			CString strPath = FileD.GetNextPathName(posFile);
			int pos = strPath.ReverseFind(_T('\\'));
			if (ERROR_SUCCESS != ::MsiDatabaseImport(hTempDB, strPath.Left(pos+1), strPath.Right(strPath.GetLength()-pos-1)))
			{
				PMSIHANDLE hError = MsiGetLastErrorRecord();
				CString strError;
				if (MsiRecordGetInteger(hError, 1) == 2221) // idbgDbCodepageConflict
				{
					strError.Format(_T("The code page of the file %s is not compatible with the current database.\n\nThe file will be skipped."), strPath);
				}
				else
				{
					strError.Format(_T("The file %s is not a valid IDT file.\n\nThe file will be skipped."), strPath);
				}
				AfxMessageBox(strError, MB_OK);
				continue;
			}
			if (ERROR_SUCCESS != ::MsiDatabaseImport(m_hImportDB, strPath.Left(pos+1), strPath.Right(strPath.GetLength()-pos-1)))
			{
				CString strError;
				strError.Format(_T("The file %s is not a valid IDT file."), strPath);
				AfxMessageBox(strError, MB_OK);
				continue;
			}

			// add on to end of list.
			int iNextItem = m_ctrlTableList.GetItemCount();

			qExists.Open(m_hFinalDB, _T("SELECT * FROM `_Tables` WHERE `Name`=?"));

			if (ERROR_SUCCESS == qCollide.FetchOnce(hTempDB, NULL, &hTableRec, _T("SELECT * FROM `_Tables`")))
			{
				cchTableName = 255;
				::MsiRecordGetString(hTableRec, 1, szTableName, &cchTableName);

				// assign an item number to the entry, reusing an existing one if
				// the table name is the same.
				LVFINDINFO findTable;
				findTable.flags = LVFI_STRING;
				findTable.psz = szTableName;
				itemTable.iItem = m_ctrlTableList.FindItem(&findTable, -1);
				if (itemTable.iItem != -1)
					m_ctrlTableList.DeleteItem(itemTable.iItem);

				// add to list control
				itemTable.mask = LVIF_TEXT;
				itemTable.lParam = 0;
				itemTable.iSubItem = 0;
				itemTable.pszText = szTableName;
				itemTable.cchTextMax = cchTableName+1;
				itemTable.iItem = m_ctrlTableList.InsertItem(&itemTable);

				// now decide if it doesn't exist or not and add
				// our best guess for the state
				itemTable.iSubItem = 1;
				qExists.Execute(hTableRec);
				PMSIHANDLE hDummyRec;
				DWORD iData;
				switch (qExists.Fetch(&hDummyRec)) 
				{
				case ERROR_SUCCESS:
				{
					// already exists in our database.
					bool fMergeOK = true;
					bool fExtraColumns = false;
					m_cNeedInput++;

   					// if the number of columns is different, we can only merge
					// if all of the new columns are nullable and there are no merge
					// conficts
					PMSIHANDLE hColInfo;
					CQuery qColumns;
					int cTargetColumns = 0;
					int cSourceColumns = 0;
					if (ERROR_SUCCESS != qColumns.OpenExecute(m_hFinalDB, 0, TEXT("SELECT * FROM %s"), szTableName) ||
						ERROR_SUCCESS != qColumns.GetColumnInfo(MSICOLINFO_TYPES, &hColInfo))
					{
						CString strPrompt;
						strPrompt.Format(TEXT("Orca was unable to determine the number of columns in the new %s table."), szTableName);
						AfxMessageBox(strPrompt, MB_ICONSTOP);
						fMergeOK = false;
					}
					else
					{
						cTargetColumns = MsiRecordGetFieldCount(hColInfo);

						if (ERROR_SUCCESS != qColumns.OpenExecute(hTempDB, 0, TEXT("SELECT * FROM %s"), szTableName) ||
							ERROR_SUCCESS != qColumns.GetColumnInfo(MSICOLINFO_TYPES, &hColInfo))
						{
							CString strPrompt;
							strPrompt.Format(TEXT("Orca was unable to determine the number of columns in the %s table."), szTableName);
							AfxMessageBox(strPrompt, MB_ICONSTOP);
							fMergeOK = false;
						}
						else
						{
							cSourceColumns = MsiRecordGetFieldCount(hColInfo);
						}
					}

					if (fMergeOK && cSourceColumns != cTargetColumns)
					{					
						fExtraColumns = true;
						for (int iCol = cTargetColumns+1; iCol <= cSourceColumns; iCol++)
						{
							TCHAR szType[5];
							DWORD cchType = 5;
							MsiRecordGetString(hColInfo, iCol, szType, &cchType);
							if (!_istupper(szType[0]))
							{
								fMergeOK = false;
								break;
							}
						}

						// need to add the extra columns to our temporary database before
						// checking if merging is allowed
						if (!AddExtraColumns(hTempDB, szTableName, hTempDB2))
						{
							fMergeOK = false;
						}
					}


					// try to merge into our database. If successful, set to "Merge"
					if (fMergeOK && ERROR_SUCCESS != ::MsiDatabaseMerge(hTempDB2, hTempDB, NULL)) 
					{
						fMergeOK = false;
					}				

					if (fMergeOK)
					{
						itemTable.pszText = (TCHAR *)rgszAction[actMerge];
						iData = actMerge | allowMerge | allowReplace;
					}
					else
					{
						itemTable.pszText = (TCHAR *)rgszAction[actReplace];
						iData = actReplace | allowReplace;
					}

					// mark that this table has extra columns
					if (fExtraColumns)
						iData |= hasExtraColumns;

					break;
				}
				case ERROR_NO_MORE_ITEMS:
					// doesn't exist in our database, set to "Import"
					itemTable.pszText = (TCHAR *)rgszAction[actImport];
					iData = actImport | allowImport;
					break;
				default:
					// not good.
					AfxMessageBox(_T("Internal Error."), MB_OK);
					return;
				}
				m_ctrlTableList.SetItem(&itemTable);

				// set the lparam value
				m_ctrlTableList.SetItemData(itemTable.iItem, iData);

				// drop the table so the temp database is clean again
				CQuery qDrop;
				qDrop.OpenExecute(hTempDB, NULL, _T("DROP TABLE `%s`"), szTableName);
			}
			else
			{
				CString strError;
				strError.Format(_T("The file %s is not a valid IDT file."), strPath);
				AfxMessageBox(strError, MB_OK);
			}
		} // while posFile

		// we might need input, so adjust the column widths to allow space for the 
		// "Replace..." string, guaranteed at least one item in the listbox
		CString strTemp = m_ctrlTableList.GetItemText(0, 1);
		m_ctrlTableList.SetItemText(0, 1, rgszAction[actReplace]);
		m_ctrlTableList.SetColumnWidth(1, LVSCW_AUTOSIZE);
		CRect rTemp;
		m_ctrlTableList.GetClientRect(&rTemp);
		m_ctrlTableList.SetColumnWidth(0, rTemp.Width()-m_ctrlTableList.GetColumnWidth(1));
		m_ctrlTableList.SetItemText(0, 1, strTemp);

		// clean up temporary files
		::MsiCloseHandle(hTempDB);
		::MsiCloseHandle(hTempDB2);
		::DeleteFile(strTempFilename2);
		::DeleteFile(strTempFilename);
	}
	else
	{
		if (FNERR_BUFFERTOOSMALL == ::CommDlgExtendedError()) 
			AfxMessageBox(_T("Too many files were selected at once. Try choosing fewer files."), MB_OK);
	}
}

void CImportDlg::OnItemchangedTablelist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	int iItem = pNMListView->iItem;

	// determine if the selection state is being set.
	if (pNMListView->uChanged & LVIF_STATE) 
	{
		if (pNMListView->uNewState & LVIS_SELECTED)
		{
			// enable or disable controls based on the status of the item
			int iData = static_cast<int>(m_ctrlTableList.GetItemData(iItem));
			m_iAction = iData & 0x0F;
			iData &= 0xF0;
			m_bImport.EnableWindow(iData & allowImport);
			m_bMerge.EnableWindow(iData & allowMerge);
			m_bReplace.EnableWindow(iData & allowReplace);
			m_bSkip.EnableWindow(TRUE);
			UpdateData(FALSE);
		} 
		else
		{
			m_bSkip.EnableWindow(FALSE);
			m_bImport.EnableWindow(FALSE);
			m_bMerge.EnableWindow(FALSE);
			m_bReplace.EnableWindow(FALSE);
		}
	}
	*pResult = 0;
}

void CImportDlg::OnActionChange() 
{
	// pull the new value out of the Radio group.
	UpdateData(TRUE);

	ASSERT(m_ctrlTableList.GetSelectedCount()==1);

	// get currently selected table, we only allow single sel, so brute search
	// is all we can do
	int iItem;
	int iMax = m_ctrlTableList.GetItemCount();
	for (iItem =0; iItem < iMax; iItem++)
		if (m_ctrlTableList.GetItemState(iItem, LVIS_SELECTED)) break;

	m_ctrlTableList.SetItemData(iItem, m_ctrlTableList.GetItemData(iItem) & 0xF0 | m_iAction);
	m_ctrlTableList.SetItemText(iItem, 1, rgszAction[m_iAction]);
}

void CImportDlg::OnOK() 
{
	bool fModified = false;
	const TCHAR sqlDrop[] = _T("DROP TABLE `%s`");
	CQuery qDrop;
	CString strTable;

	// loop through all entries in the tree control
	int iMaxItem = m_ctrlTableList.GetItemCount();
	for (int i=0; i < iMaxItem; i++) 
	{
		strTable = m_ctrlTableList.GetItemText(i, 0);
		switch (m_ctrlTableList.GetItemData(i) & 0x0F)
		{
		case actReplace:
			// drop from base table.
			qDrop.OpenExecute(m_hFinalDB, NULL, sqlDrop, strTable);
			qDrop.Close();
			m_lstRefreshTables.AddTail(strTable);
			fModified = true;
			break;
		case actMerge:
			// need to add the extra columns from the sources, because merging 
			// won't set that up automatically.
			if ((m_ctrlTableList.GetItemData(i) & hasExtraColumns) == hasExtraColumns)
			{
				if (!AddExtraColumns(m_hImportDB, strTable, m_hFinalDB))
				{
					CString strPrompt;
					strPrompt.Format(TEXT("Orca was unable to add the additional columns to the %s table."), strTable);
					AfxMessageBox(strPrompt, MB_ICONSTOP);
					break;
				}
			}

			m_lstRefreshTables.AddTail(strTable);
			fModified = true;
			break;
		case actImport:
			// no special action required, just save refresh
			m_lstNewTables.AddTail(strTable);
			fModified = true;
			break;
		case actSkip:
			// drop from import table.
			qDrop.OpenExecute(m_hImportDB, NULL, sqlDrop, strTable);
			qDrop.Close();
			break;
		}
	}

	// now merge into our database
	if (ERROR_SUCCESS != ::MsiDatabaseMerge(m_hFinalDB, m_hImportDB, NULL))
	{
		AfxMessageBox(_T("One or more tables could not be imported into the database.\nThe IDT files may have been partially imported, and tables that were to be completely replaced with the imported data may have been dropped without the new data being added."));
		EndDialog(IDABORT);
	}
	else
	{
		if (fModified)
			CDialog::OnOK();
		else
			EndDialog(IDCANCEL);
	}
}

void CImportDlg::OnDestroy() 
{
	CDialog::OnDestroy();

	MsiCloseHandle(m_hImportDB);
	m_hImportDB = 0;

	// delete the temporary file
	DeleteFile(m_strTempFilename);
}


bool CImportDlg::AddExtraColumns(MSIHANDLE hImportDB, const CString strTable, MSIHANDLE hFinalDB)
{
	PMSIHANDLE hColInfo;
	PMSIHANDLE hColNames;
	CQuery qColumns;
	if (ERROR_SUCCESS != qColumns.OpenExecute(hFinalDB, 0, TEXT("SELECT * FROM %s"), strTable))
		return false;
	if (ERROR_SUCCESS != qColumns.GetColumnInfo(MSICOLINFO_TYPES, &hColInfo))
		return false;
	int cTargetColumns = MsiRecordGetFieldCount(hColInfo);

	if (ERROR_SUCCESS != qColumns.OpenExecute(hImportDB, 0, TEXT("SELECT * FROM %s"), strTable))
		return false;
	if (ERROR_SUCCESS != qColumns.GetColumnInfo(MSICOLINFO_TYPES, &hColInfo))
		return false;
	if (ERROR_SUCCESS != qColumns.GetColumnInfo(MSICOLINFO_NAMES, &hColNames))
		return false;
	int cSourceColumns = MsiRecordGetFieldCount(hColInfo);

	if (cSourceColumns != cTargetColumns)
	{
		for (int iCol = cTargetColumns+1; iCol <= cSourceColumns; iCol++)
		{
			TCHAR szType[5] = TEXT("");
			DWORD cchType = 5;
			if (ERROR_SUCCESS != MsiRecordGetString(hColInfo, iCol, szType, &cchType))
				return false;

			CString strName;
			DWORD dwResult = RecordGetString(hColNames, iCol, strName);
			if (ERROR_SUCCESS != dwResult)
				return false;

			CString strAdd;
			switch (szType[0])
			{
			case 'S':
			case 'L':
				strAdd.Format(_T("`%s` CHAR(%s)"), strName, &szType[1]);
				if (szType[0] == 'L')
					strAdd += " LOCALIZABLE";
				break;
			case 'I':
				if (szType[1] == '2')
					strAdd.Format(_T("`%s` SHORT"), strName);
				else
					strAdd.Format(_T("`%s` LONG"), strName);
				break;
			case 'V':
				strAdd.Format(_T("`%s` OBJECT"), strName);
			}
			CQuery qAdd;
			if (ERROR_SUCCESS != qAdd.OpenExecute(hFinalDB, 0, _T("ALTER TABLE %s ADD %s"), strTable, strAdd))
				return false;
		}
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\imprtdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_IMPRTDLG_H__F424160C_4C5B_11D2_8896_00A0C981B015__INCLUDED_)
#define AFX_IMPRTDLG_H__F424160C_4C5B_11D2_8896_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ImprtDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CImportDlg dialog

class CImportDlg : public CDialog
{
// Construction
public:
	CString m_strImportDir;
	CStringList m_lstRefreshTables;
	CStringList m_lstNewTables;
	CString m_strTempFilename;
	MSIHANDLE m_hFinalDB;
	CImportDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CImportDlg)
	enum { IDD = IDD_IMPORT_TABLE };
	CButton	m_bImport;
	CButton	m_bMerge;
	CButton	m_bSkip;
	CButton	m_bReplace;
	CListCtrl	m_ctrlTableList;
	int		m_iAction;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CImportDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CImportDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnBrowse();
	afx_msg void OnItemchangedTablelist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnActionChange();
	virtual void OnOK();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

	bool AddExtraColumns(MSIHANDLE hImportDB, const CString strTable, MSIHANDLE hFinalDB);

	int m_cNeedInput;
	CString m_strTempPath;
	PMSIHANDLE m_hImportDB;

	enum eAction {
		actImport = 0x00,
		actReplace = 0x01,
		actMerge = 0x02,
		actSkip = 0x04,
	};

	enum eAllowAction {
		allowImport = 0x10,
		allowMerge = 0x20,
		allowReplace = 0x40,
	};

	enum eTableAttributes {
		hasExtraColumns = 0x100,
	};

	static const TCHAR *rgszAction[4];
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_IMPRTDLG_H__F424160C_4C5B_11D2_8896_00A0C981B015__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\mainfrm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__C3EDC1AC_E506_11D1_A856_006097ABDE17__INCLUDED_)
#define AFX_MAINFRM_H__C3EDC1AC_E506_11D1_A856_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "Table.h"
#include "Column.h"
#include "valpane.h"
    			
class CTableList;
class CTableView;

class COrcaSplitterWnd : public CSplitterWnd
{
public: 
	COrcaSplitterWnd();
	void HideSecondRow();
	void ShowSecondRow();
};


class CSplitterView : public CWnd
{
	DECLARE_DYNCREATE(CSplitterView)

public:
	CSplitterWnd m_wndSplitter;

protected:
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd( CDC* pDC );

	DECLARE_MESSAGE_MAP();
};

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:
	void SetStatusBarWidth(int nWidth);
	void SetTableCount(int cTables);
	void SetTableName(LPCTSTR szName, int cRows);
	void SetColumnType(LPCTSTR szName, OrcaColumnType eiType, UINT iSize, BOOL bNullable, BOOL bKey);
	void ResetStatusBar();
	void ExportTables(bool bUseSelections);
	void HideValPane();
	void ShowValPane();

	inline bool IsCaseSensitiveSort() const { return m_bCaseSensitiveSort; };

	COrcaTable* GetCurrentTable();
	CString m_strExportDir;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;
	COrcaSplitterWnd m_wndValSplitter;

// Generated message map functions
protected:
    afx_msg LONG OnFindReplace(WPARAM wParam, LPARAM lParam);

	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnTablesExport();
	afx_msg void OnToolsOptions();
	afx_msg void OnToolsDlgprv();
	afx_msg void OnUpdateToolsDlgprv(CCmdUI* pCmdUI);
	afx_msg void OnEditFind();
	afx_msg void OnEditFindnext();
	afx_msg void OnViewValPane();
	afx_msg void OnUpdateEditFindnext(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditFind(CCmdUI* pCmdUI);
	afx_msg void OnUpdateViewValPane(CCmdUI* pCmdUI);
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CTableView* CMainFrame::GetTableView() const;
	CTableList* CMainFrame::GetTableList() const;
	bool m_bCaseSensitiveSort;
	CFindReplaceDialog * m_dlgFindReplace;
	OrcaFindInfo m_FindInfo;
	OrcaFindInfo m_LastFindInfo;
	
	int m_iValPaneHeight;
	bool m_bChildPanesReady;
	bool m_bValPaneVisible;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__C3EDC1AC_E506_11D1_A856_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\odbutils.cpp ===
#include "..\common\dbutils.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\mainfrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "Orca.h"

#include "MainFrm.h"
#include "OrcaDoc.h"
#include "TableLst.h"
#include "TableVw.h"
#include "ExportD.h"
#include "DisplyPP.h"
#include "PathPP.h"
#include "ValPP.h"
#include "PrvwDlg.h"
#include "ImprtDlg.h"
#include "..\common\utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COLUMNTYPEWIDTH 200

static UINT WM_FINDREPLACE = ::RegisterWindowMessage(FINDMSGSTRING);

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_COMMAND(ID_TABLES_EXPORT, OnTablesExport)
	ON_COMMAND(ID_TOOLS_OPTIONS, OnToolsOptions)
	ON_COMMAND(ID_TOOLS_DLGPRV, OnToolsDlgprv)
	ON_UPDATE_COMMAND_UI(ID_TOOLS_DLGPRV, OnUpdateToolsDlgprv)
	ON_COMMAND(ID_EDIT_FIND, OnEditFind)
	ON_COMMAND(ID_EDIT_FINDNEXT, OnEditFindnext)
	ON_UPDATE_COMMAND_UI(ID_EDIT_FINDNEXT, OnUpdateEditFindnext)
	ON_UPDATE_COMMAND_UI(ID_EDIT_FIND, OnUpdateEditFind)
	ON_UPDATE_COMMAND_UI(ID_VIEW_VALPANE, OnUpdateViewValPane)
	ON_COMMAND(ID_VIEW_VALPANE, OnViewValPane)
	ON_WM_SIZE()
	ON_WM_DROPFILES()
	//}}AFX_MSG_MAP
    ON_REGISTERED_MESSAGE( WM_FINDREPLACE, OnFindReplace )
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_TABLE_COUNT,
	ID_TABLE_NAME,
	ID_COLUMN_TYPE,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame() : m_iValPaneHeight(0), m_bChildPanesReady(false), m_bValPaneVisible(true)
{
	// TODO: add member initialization code here
	m_dlgFindReplace = NULL;
}

CMainFrame::~CMainFrame()
{
}

inline CTableView* CMainFrame::GetTableView() const { return static_cast<CTableView *>(static_cast<CSplitterView*>(m_wndValSplitter.GetPane(0,0))->m_wndSplitter.GetPane(0,1)); };
inline CTableList* CMainFrame::GetTableList() const { return static_cast<CTableList *>(static_cast<CSplitterView*>(m_wndValSplitter.GetPane(0,0))->m_wndSplitter.GetPane(0,0)); };

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	// create the status bar
	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("Failed to create TableList status bar\n");
		return -1;      // fail to create
	}
	else	// splitter window created
	{
		m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

		m_wndStatusBar.SetPaneInfo(0, ID_TABLE_COUNT, SBPS_NOBORDERS, 100);
		m_wndStatusBar.SetPaneInfo(1, ID_TABLE_NAME, SBPS_STRETCH, 0);
		m_wndStatusBar.SetPaneInfo(2, ID_COLUMN_TYPE, SBPS_NORMAL, COLUMNTYPEWIDTH);
	}

	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// enable docking of toolbars
	EnableDocking(CBRS_ALIGN_ANY);
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	m_strExportDir = AfxGetApp()->GetProfileString(_T("Path"), _T("Export"));
	m_bCaseSensitiveSort = AfxGetApp()->GetProfileInt(_T("Settings"), _T("CaseSensitiveSort"), 1) == 1;

	if (m_strExportDir.IsEmpty()) {
		// take a crack at getting the current directory for
		int iBufLen = 128;
		LPTSTR szTemp = m_strExportDir.GetBufferSetLength(iBufLen);
		iBufLen = GetCurrentDirectory(iBufLen, szTemp);
		m_strExportDir.ReleaseBuffer();

		// if buffer wasn't big enough, try again
		if (iBufLen >= 128) {
			szTemp = m_strExportDir.GetBufferSetLength(iBufLen);
			::GetCurrentDirectory(iBufLen, szTemp);
			m_strExportDir.ReleaseBuffer();
		}
	};

	// set the find structure to be invalid
	m_FindInfo.bValid = false;
	m_FindInfo.strFindString = _T("");
	m_FindInfo.strUIFindString = _T("");
	m_FindInfo.bForward = true;
	m_FindInfo.bMatchCase = false;
	m_FindInfo.bWholeWord = false;

	m_bValPaneVisible = false;
	m_bChildPanesReady = true;
	m_wndValSplitter.HideSecondRow();
	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) 
{

	if (m_wndValSplitter.CreateStatic(this, 2, 1) == 0)
		return -1;
	
	// set the initial size to 2/3 for the top.
	CSize sizeInit;
	CRect rTemp;
	GetClientRect(&rTemp);
	sizeInit.cx = 125;
	sizeInit.cy = rTemp.bottom*2/3;
	m_wndValSplitter.CreateView(0, 0, RUNTIME_CLASS(CSplitterView), sizeInit, pContext);
	m_wndValSplitter.SetRowInfo(0, sizeInit.cy, 10);

	sizeInit.cy = rTemp.bottom-sizeInit.cy;
	m_iValPaneHeight = sizeInit.cy;
	m_wndValSplitter.CreateView(1, 0, RUNTIME_CLASS(CValidationPane), sizeInit, pContext);
	m_wndValSplitter.SetRowInfo(1, sizeInit.cy, 10);

	return TRUE;
}

void CMainFrame::SetStatusBarWidth(int nWidth)
{
	// can't set width to 0
	if (nWidth < 1) nWidth = 1;

	CString strStore = m_wndStatusBar.GetPaneText(0);
	m_wndStatusBar.SetPaneInfo(0, ID_TABLE_COUNT,  SBPS_NOBORDERS, nWidth - 1);
	m_wndStatusBar.SetPaneText(0, strStore);
}

void CMainFrame::SetTableCount(int cTables)
{
	CString strDisplay;

	strDisplay.Format(_T("Tables: %d"), cTables);
	m_wndStatusBar.SetPaneText(0, strDisplay);
}

void CMainFrame::SetTableName(LPCTSTR szName, int cRows)
{
	CString strDisplay;

	if (1 == cRows)
		strDisplay.Format(_T("%s - %d row"), szName, cRows);
	else // (cRows > 1 || cRows == 0)
		strDisplay.Format(_T("%s - %d rows"), szName, cRows);

	m_wndStatusBar.SetPaneText(1, strDisplay);
}

void CMainFrame::SetColumnType(LPCTSTR szName, OrcaColumnType eiType, UINT iSize, BOOL bNullable, BOOL bKey)
{
	CString strDisplay;

	switch (eiType)
	{
	case iColumnNone:
		strDisplay.Format(_T("%s - Unknown[%d]"), szName, iSize);
		break;
	case iColumnString:
		strDisplay.Format(_T("%s - String[%d]"), szName, iSize);
		break;
	case iColumnLocal:
		strDisplay.Format(_T("%s - Localizable[%d]"), szName, iSize);
		break;
	case iColumnShort:
		strDisplay.Format(_T("%s - Short"), szName);
		break;
	case iColumnLong:
		strDisplay.Format(_T("%s - Long"), szName);
		break;
	case iColumnBinary:
		strDisplay.Format(_T("%s - Binary[%d]"), szName, iSize);
		break;
	default:
		ASSERT(FALSE);	// shouldn't get this
	}

	if (bKey)
		strDisplay += _T(", Key");
	if (bNullable)
		strDisplay += _T(", Nullable");

	m_wndStatusBar.SetPaneInfo(2, ID_COLUMN_TYPE,  SBPS_NORMAL, COLUMNTYPEWIDTH);
	m_wndStatusBar.SetPaneText(2, strDisplay);
}

void CMainFrame::ResetStatusBar()
{
	m_wndStatusBar.SetPaneText(1, _T("No table is selected."));
	m_wndStatusBar.SetPaneText(2, _T("No column is selected."));
}

COrcaTable* CMainFrame::GetCurrentTable()
{
	// get the table view
	CTableView* pView = static_cast<CTableView *>(static_cast<CSplitterView*>(m_wndValSplitter.GetPane(0,0))->m_wndSplitter.GetPane(0, 1));
	
	if (!pView)
		return NULL;
	else
		return pView->m_pTable;
}

//////
// handler for menu..Tables...Export, dosen't use current selections in Table View
void CMainFrame::OnTablesExport() {
	ExportTables(false);
};

////
// Creates a dialog box and allows the user to choose which tables to export. In CMainFrame
// because it must be handled regardless of the currently selected view
void CMainFrame::ExportTables(bool bUseSelections)
{
	COrcaTable* pTable = GetCurrentTable();

	CStringList strTableList;

	// get a list of all tables
	
	COrcaDoc *pCurrentDoc = static_cast<COrcaDoc *>(GetActiveDocument());
	ASSERT(pCurrentDoc);
	if (!pCurrentDoc)
		return;

	pCurrentDoc->FillTableList(&strTableList, /*fShadow=*/false, /*fTargetOnly=*/true);

	// create the export dialog box
	CExportD dlg;
	dlg.m_plistTables = &strTableList;
	dlg.m_strDir = m_strExportDir;

	CString strPrompt;
	CString strFilename;
	if (IDOK == dlg.DoModal())
	{
		m_strExportDir = dlg.m_strDir;
		UINT cTables = 0;
		CString strTable;
		POSITION pos = strTableList.GetHeadPosition();
		while (pos)
		{
			strTable = strTableList.GetNext(pos);

			strFilename.Format(_T("%s.idt"), strTable.Left(8));
			if (!pCurrentDoc->ExportTable(&strTable, &m_strExportDir)) 
			{
				strPrompt.Format(_T("`%s` failed to export."), strTable);
				AfxMessageBox(strPrompt);
			}
			else
				cTables++;
		}

		if (1 == cTables)
			strPrompt.Format(_T("Exported %d table."), cTables);
		else
			strPrompt.Format(_T("Exported %d tables."), cTables);
		AfxMessageBox(strPrompt, MB_ICONINFORMATION);
	}
}

void CMainFrame::OnToolsOptions() 
{
	CPropertySheet dOptions(_T("Options"));
	CDisplayPropPage dDisplay;
	CPathPropPage dPaths;
	CValPropPage dValidate;
	CMsmPropPage dMSM;
	CTransformPropPage dTransform;
	CTableView *pTableView = GetTableView();
	CTableList *pTableLst = GetTableList();
	CValidationPane *pValPane = static_cast<CValidationPane*>(m_wndValSplitter.GetPane(1,0));

	// initialize the display page
	pTableView->GetFontInfo(&dDisplay.m_fSelectedFont);
	dDisplay.SetColors(pTableView->m_clrNormal, pTableView->m_clrSelected, pTableView->m_clrFocused);
	dDisplay.SetColorsT(pTableView->m_clrNormalT, pTableView->m_clrSelectedT, pTableView->m_clrFocusedT);
	dDisplay.m_bCaseSensitive = m_bCaseSensitiveSort;
	dDisplay.m_iFontSize = AfxGetApp()->GetProfileInt(_T("Font"),_T("Size"), 100);
	dDisplay.m_bForceColumns = AfxGetApp()->GetProfileInt(_T("Settings"), _T("ForceColumnsToFit"), 1) == 1;

	// init the path page
	dPaths.m_strExportDir = m_strExportDir;
	dPaths.m_strOrcaDat = AfxGetApp()->GetProfileString(_T("Path"),_T("OrcaDat"));

	// init the Validation page
	dValidate.m_strCUBFile = AfxGetApp()->GetProfileString(_T("Validation"),_T("Location"));
	dValidate.m_strICEs = AfxGetApp()->GetProfileString(_T("Validation"),_T("ICEs"));
	dValidate.m_bSuppressWarn = AfxGetApp()->GetProfileInt(_T("Validation"),_T("SuppressWarn"), 0);
	dValidate.m_bSuppressInfo = AfxGetApp()->GetProfileInt(_T("Validation"),_T("SuppressInfo"), 0);
	dValidate.m_bClearResults = AfxGetApp()->GetProfileInt(_T("Validation"),_T("ClearResults"), 1);

	// init the MSM page
	dMSM.m_iMemoryCount = AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("MemoryCount"), 0);
	dMSM.m_bAlwaysConfig = AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("AlwaysConfigure"), 0);
	dMSM.m_bWatchLog = AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("ShowMergeLog"), 0);

	// init the Transform page
	dTransform.m_iValidationOptions = AfxGetApp()->GetProfileInt(_T("Transforms"),_T("ValidationOptions"), 0);
	dTransform.m_iErrorOptions = AfxGetApp()->GetProfileInt(_T("Transforms"),_T("ErrorOptions"), 1);

	// add everything to the sheet
	dOptions.AddPage(&dDisplay);
	dOptions.AddPage(&dPaths);
	dOptions.AddPage(&dValidate);
	dOptions.AddPage(&dMSM);
	dOptions.AddPage(&dTransform);

	// execute
	if (IDOK == dOptions.DoModal()) 
	{
		if (dDisplay.m_bMiscChange)
		{
			m_bCaseSensitiveSort = (dDisplay.m_bCaseSensitive == TRUE);
			::AfxGetApp()->WriteProfileInt(_T("Settings"),_T("CaseSensitiveSort"), m_bCaseSensitiveSort);
			::AfxGetApp()->WriteProfileInt(_T("Settings"), _T("ForceColumnsToFit"), dDisplay.m_bForceColumns == TRUE);
		}
		if (dDisplay.m_bFontChange) 
		{
			pTableView->SwitchFont(dDisplay.m_strFontName, dDisplay.m_iFontSize);
			pTableLst->SwitchFont(dDisplay.m_strFontName, dDisplay.m_iFontSize);
			pValPane->SwitchFont(dDisplay.m_strFontName, dDisplay.m_iFontSize);
			::AfxGetApp()->WriteProfileInt(_T("Font"),_T("Size"), dDisplay.m_iFontSize);
			::AfxGetApp()->WriteProfileString(_T("Font"),_T("Name"), dDisplay.m_strFontName);
			GetActiveDocument()->UpdateAllViews(NULL, HINT_REDRAW_ALL);
		}
		if (dDisplay.m_bColorChange) 
		{
			COLORREF norm, sel, foc;
			dDisplay.GetColorsT(norm, sel, foc);
			pTableView->SetFGColors(norm, sel, foc);
			pTableLst->SetFGColors(norm, sel, foc);
			::AfxGetApp()->WriteProfileInt(_T("Colors"),_T("SelectFg"), sel);
			::AfxGetApp()->WriteProfileInt(_T("Colors"),_T("FocusFg"), foc);
			::AfxGetApp()->WriteProfileInt(_T("Colors"),_T("NormalFg"), norm);
			dDisplay.GetColors(norm, sel, foc);
			pTableView->SetBGColors(norm, sel, foc);
			pTableLst->SetBGColors(norm, sel, foc);
			::AfxGetApp()->WriteProfileInt(_T("Colors"),_T("SelectBg"), sel);
			::AfxGetApp()->WriteProfileInt(_T("Colors"),_T("FocusBg"), foc);
			::AfxGetApp()->WriteProfileInt(_T("Colors"),_T("NormalBg"), norm);
			GetActiveDocument()->UpdateAllViews(NULL, HINT_REDRAW_ALL);
		};
		if (dPaths.m_bPathChange) 
		{
			m_strExportDir = dPaths.m_strExportDir;
			::AfxGetApp()->WriteProfileString(_T("Path"),_T("Export"), m_strExportDir);
			AfxGetApp()->WriteProfileString(_T("Path"),_T("OrcaDat"), dPaths.m_strOrcaDat);
		};
		if (dValidate.m_bValChange) 
		{
			AfxGetApp()->WriteProfileString(_T("Validation"),_T("Location"), dValidate.m_strCUBFile);
			AfxGetApp()->WriteProfileString(_T("Validation"),_T("ICEs"), dValidate.m_strICEs);
			static_cast<COrcaDoc *>(GetActiveDocument())->m_strICEsToRun = dValidate.m_strICEs;
			AfxGetApp()->WriteProfileInt(_T("Validation"),_T("SuppressWarn"), dValidate.m_bSuppressWarn);
			AfxGetApp()->WriteProfileInt(_T("Validation"),_T("SuppressInfo"), dValidate.m_bSuppressInfo);
			AfxGetApp()->WriteProfileInt(_T("Validation"),_T("ClearResults"), dValidate.m_bClearResults);
		}
		if (dMSM.m_bMSMChange)
		{
			AfxGetApp()->WriteProfileInt(_T("MergeMod"),_T("MemoryCount"), dMSM.m_iMemoryCount);
			AfxGetApp()->WriteProfileInt(_T("MergeMod"),_T("AlwaysConfigure"), dMSM.m_bAlwaysConfig);
			AfxGetApp()->WriteProfileInt(_T("MergeMod"),_T("ShowMergeLog"), dMSM.m_bWatchLog);
		}
		if (dTransform.m_bTransformChange)
		{
			AfxGetApp()->WriteProfileInt(_T("Transforms"),_T("ValidationOptions"), dTransform.m_iValidationOptions);
			AfxGetApp()->WriteProfileInt(_T("Transforms"),_T("ErrorOptions"), dTransform.m_iErrorOptions);
		}
	}
	
}

void CMainFrame::OnToolsDlgprv() 
{
	CPreviewDlg dPreview(this);

	COrcaDoc *pDoc = static_cast<COrcaDoc *>(GetActiveDocument());
	ASSERT(pDoc);
	if (pDoc)
	{
		dPreview.m_hDatabase = pDoc->GetTargetDatabase();
		
		dPreview.DoModal();	
	}
}

void CMainFrame::OnUpdateToolsDlgprv(CCmdUI* pCmdUI) 
{
	COrcaDoc* pDoc = static_cast<COrcaDoc *>(GetActiveDocument());
	ASSERT(pDoc);
	if (pDoc)
	{
		COrcaTable *pTable = pDoc->FindAndRetrieveTable(_T("Dialog"));
		pCmdUI->Enable((pTable != NULL) && (pTable->GetRowCount() != 0));
	}
	else
		pCmdUI->Enable(FALSE);
}

void CMainFrame::OnEditFind() 
{
	if (m_dlgFindReplace)
		return;

	m_dlgFindReplace = new CFindReplaceDialog;
 	m_dlgFindReplace->Create(TRUE, m_FindInfo.strUIFindString, _T(""), 
		(m_FindInfo.bForward ? FR_DOWN : 0) |
		(m_FindInfo.bMatchCase ? FR_MATCHCASE : 0) |
		(m_FindInfo.bWholeWord ? FR_WHOLEWORD : 0));

}

afx_msg LONG CMainFrame::OnFindReplace(WPARAM wParam, LPARAM lParam)
{
	// throw up a wait cursor
	CWaitCursor curWait;

	if (m_dlgFindReplace->IsTerminating()) 
	{
		m_dlgFindReplace = NULL;
		CTableView *pTableView = GetTableView();
		pTableView->SetFocus();
		return 0L;
	};
	if (m_dlgFindReplace->FindNext()) 
	{
		// retrieve data from the dialog box
		m_FindInfo.bWholeWord = (m_dlgFindReplace->MatchWholeWord() != 0);
		m_FindInfo.bForward = (m_dlgFindReplace->SearchDown() != 0);
		m_FindInfo.bMatchCase = (m_dlgFindReplace->MatchCase() != 0);
		m_FindInfo.strFindString = m_dlgFindReplace->GetFindString();
		m_FindInfo.strUIFindString = m_FindInfo.strFindString;
		// if our find info was still valid and we havn't changed anything
		if (m_FindInfo.bValid && (m_FindInfo == m_LastFindInfo))
		{
			// keep running the same query
			m_FindInfo = m_LastFindInfo;
		}
		else
		{
			// otherwise reset the query
			m_FindInfo.bValid = true;
			m_FindInfo.bWholeDoc = false;
			m_FindInfo.iCount = 0;
			m_LastFindInfo = m_FindInfo;
		}

		// if case-insensitive, convert the find string to all uppercase
		if (!m_FindInfo.bMatchCase)
			m_FindInfo.strFindString.MakeUpper();

		OnEditFindnext();
		return 0L;
	}
	return 0L;
}

///////////////////////////////////////////////////////////////////////
// command handler for the find next command, but also the find engine
// once the Find dialog sets up a search.
void CMainFrame::OnEditFindnext() 
{
	if (!m_FindInfo.bValid) return;

	CTableView *pTableView = GetTableView();
	CTableList *pTableList = GetTableList();


	// take advantage of short-circuit evaluation to check first visible table
	// then if not found, other tables

	if ((!m_FindInfo.bWholeDoc && pTableView->Find(m_FindInfo)) ||
		pTableList->Find(m_FindInfo))
	{
		pTableView->SetFocus();
		// since we found one, we are want to start the next search from here
		m_FindInfo.bWholeDoc = false;
		return;
	}

	if (m_FindInfo.bWholeDoc && (m_FindInfo.iCount == 0)) {
		CString strPrompt;
		strPrompt.Format(_T("No occurrences of \"%s\" were found."), m_FindInfo.strUIFindString);
		AfxMessageBox(strPrompt, MB_OK);
		m_FindInfo.bValid = false;
		if (m_dlgFindReplace) 
		{
			m_dlgFindReplace->DestroyWindow();
			m_dlgFindReplace = NULL;
			pTableView->SetFocus();
		}
		return;
	};

	CString strPrompt;
	strPrompt.Format(_T("No more occurrences of \"%s\" were found. Continue searching at the %s?"), 
		m_FindInfo.strUIFindString, m_FindInfo.bForward ? _T("beginning") : _T("end"));
	if (IDYES == AfxMessageBox(strPrompt, MB_YESNO)) 
	{
		// must set to whole doc and none found or we could go forever
		m_FindInfo.bWholeDoc = true;
		m_FindInfo.iCount = 0;
		OnEditFindnext();
		return;
	};
	m_FindInfo.bValid = false;
	if (m_dlgFindReplace) 
	{
		m_dlgFindReplace->DestroyWindow();
		m_dlgFindReplace = NULL;
		pTableView->SetFocus();
	}
}


void CMainFrame::OnUpdateEditFindnext(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable((static_cast<COrcaDoc *>(GetActiveDocument())->m_eiType != iDocNone) &&
					m_FindInfo.bValid);	
}

void CMainFrame::OnUpdateEditFind(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable((static_cast<COrcaDoc *>(GetActiveDocument())->m_eiType != iDocNone) && !m_dlgFindReplace);
}

#include <initguid.h>
DEFINE_GUID(STGID_MsiDatabase1,  0xC1080, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);
DEFINE_GUID(STGID_MsiDatabase2,  0xC1084, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);
DEFINE_GUID(STGID_MsiTransform1, 0xC1081, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);
DEFINE_GUID(STGID_MsiTransform2, 0xC1082, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);
DEFINE_GUID(STGID_MsiTransform3, 0xC1085, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);
DEFINE_GUID(STGID_MsiPatch1,     0xC1083, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);
DEFINE_GUID(STGID_MsiPatch2,     0xC1086, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);

////
// drag-and-drop processing that will also accept patches and 
// transforms if a document is already open. Based on default
// implementation from MFC CFrameWnd
void CMainFrame::OnDropFiles(HDROP hDropInfo)
{
	SetActiveWindow();      // activate us first !
	UINT nFiles = ::DragQueryFile(hDropInfo, (UINT)-1, NULL, 0);

	CWinApp* pApp = AfxGetApp();
	ASSERT(pApp != NULL);
	for (UINT iFile = 0; iFile < nFiles; iFile++)
	{
		TCHAR szFileName[_MAX_PATH] = TEXT("");
		::DragQueryFile(hDropInfo, iFile, szFileName, _MAX_PATH);


		// open the file as IStorage to get CLSID. Although this is not publicly
		// exposed information, we use it for perf gain. Otherwise we'd have to try 
		// all three possibilities one right after the other and see which possibility
		// "sticks"

		IStorage *pStorage = 0;
		WCHAR *wzFileName = NULL;
#ifdef UNICODE
		wzFileName = szFileName;
#else
		size_t cchWide = lstrlen(szFileName)+1;
		wzFileName = new WCHAR[cchWide];
		if (!wzFileName)
			return;
		AnsiToWide(szFileName, wzFileName, &cchWide);
#endif
		HRESULT hRes = StgOpenStorage(wzFileName, NULL, STGM_READ | STGM_SHARE_DENY_WRITE | STGM_DIRECT, NULL, 0, &pStorage);
#ifndef UNICODE
		delete[] wzFileName;
#endif
		if (hRes != S_OK || !pStorage)
			continue;

		STATSTG statstg;
		HRESULT hres = pStorage->Stat(&statstg, STATFLAG_NONAME);
		if (hres != S_OK)
		{
			pStorage->Release();
			continue;
		}

		// check the STGIDs
		if ((statstg.clsid == STGID_MsiDatabase2) ||
			(statstg.clsid == STGID_MsiDatabase1))
		{
			pStorage->Release();
			pApp->OpenDocumentFile(szFileName);
		}
		else if ((statstg.clsid == STGID_MsiTransform2) ||
				 (statstg.clsid == STGID_MsiTransform1) ||
				 (statstg.clsid == STGID_MsiTransform3))
		{
			pStorage->Release();
			COrcaDoc* pDoc = static_cast<COrcaDoc*>(GetActiveDocument());
			if (pDoc)
			{
				// can only apply patches if a DB is already open
				if (pDoc->GetOriginalDatabase())
				{
					pDoc->ApplyTransform(szFileName, false);
				}
			}
		}
		else if ((statstg.clsid == STGID_MsiPatch2) ||
				 (statstg.clsid == STGID_MsiPatch1))
		{
			pStorage->Release();
			COrcaDoc* pDoc = static_cast<COrcaDoc*>(GetActiveDocument());
			if (pDoc)
			{
				// can only apply patches if a DB is already open
				if (pDoc->GetOriginalDatabase())
				{
					pDoc->ApplyPatch(szFileName);
				}
			}
		}
		else
		{
			pStorage->Release();
			// unknown OLE storage identifier. Assume MSI
			pApp->OpenDocumentFile(szFileName);
		}
	}
	::DragFinish(hDropInfo);
}


void CMainFrame::OnSize(UINT nType, int cx, int cy) 
{
	CFrameWnd::OnSize(nType, cx, cy);
	if (m_bChildPanesReady)
	{
		m_wndValSplitter.SetRowInfo(0, cy-m_iValPaneHeight, 10);
		m_wndValSplitter.SetRowInfo(1, m_iValPaneHeight, 10);
	}
}

void CMainFrame::OnViewValPane() 
{
	m_bValPaneVisible = !m_bValPaneVisible;
	if (m_bValPaneVisible)
	{
		m_wndValSplitter.ShowSecondRow();
	}
	else
	{
		m_wndValSplitter.HideSecondRow();
	}
}

void CMainFrame::ShowValPane()
{
	m_bValPaneVisible = true;
	m_wndValSplitter.ShowSecondRow();
}

void CMainFrame::HideValPane()
{
	m_bValPaneVisible = false;
	m_wndValSplitter.HideSecondRow();
}

void CMainFrame::OnUpdateViewValPane(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_bValPaneVisible);
}


///////////////////////////////////////////////////////////////////////
// the splitter view is really just a wrapper window for the child
// splitter window. It does not derive from CView since views have 
// lots of extra semantics and implicit message handling). 

IMPLEMENT_DYNCREATE(CSplitterView, CWnd);

BEGIN_MESSAGE_MAP(CSplitterView, CWnd)
	//{{AFX_MSG_MAP(CSplitterView)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////
// on creation of the splitter view window, create a child splitter
// window with two panes that completely fills the window area. The 
// child panes manage their own size.
int CSplitterView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// create a splitter window with two horizontal panes.
	m_wndSplitter.CreateStatic(this, 1, 2, WS_CHILD|WS_VISIBLE, AFX_IDW_PANE_FIRST+2);

	// grab the creation context from the parent
	CCreateContext *pContext = (CCreateContext*) lpCreateStruct->lpCreateParams;

	// initial size of child columns is irrelevant, they manage their own size 
	// based on their content.
	CSize sizeInit(100,100);
	m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS(CTableList), sizeInit, pContext);
	m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS(CTableView), sizeInit, pContext);
	return 0;
}

// when resizing a splitter view, resize the child to ensure it completely fills the area.
// expand the window sit 2 pixels outside the visible window to hide the border (2 is
// hardcoded in the MFC source)
void CSplitterView::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
	m_wndSplitter.SetWindowPos(NULL, -2, -2, cx+4, cy+4, SWP_NOACTIVATE | SWP_NOZORDER);
}

///////////////////////////////////////////////////////////////////////
// the splitter view is completely covered by its splitter window. 
// there is no need to erase the background ever, it just causes 
// flicker when redrawing the window.
afx_msg BOOL CSplitterView::OnEraseBkgnd( CDC* pDC )
{
	return 1;
}


///////////////////////////////////////////////////////////////////////
// the COrcaSplitterWnd is a derived class from CSplitterWnd whose sole
// purpose is to allow us to manipulate the protected data in the base
// class to allow dynamic control over the visibility of the child panes. 
COrcaSplitterWnd::COrcaSplitterWnd() : CSplitterWnd()
{
}

void COrcaSplitterWnd::HideSecondRow()
{ 
	GetPane(1,0)->ShowWindow(SW_HIDE);
	m_nRows = 1; 
	RecalcLayout();
}

void COrcaSplitterWnd::ShowSecondRow()
{ 
	m_nRows = 2; 
	GetPane(1,0)->ShowWindow(SW_SHOW);
	RecalcLayout();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\merged.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//--------------------------------------------------------------------------

// MergeD.cpp : merge module dialog implementation
//

#include "stdafx.h"
#include "Orca.h"
#include "mergeD.h"
#include "FolderD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMergeD dialog


CMergeD::CMergeD(CWnd* pParent /*=NULL*/)
	: CDialog(CMergeD::IDD, pParent)
{
	m_plistFeature = NULL;
	m_plistDirectory = NULL;

	//{{AFX_DATA_INIT(CMergeD)
	m_strModule = "";
	m_strFilePath = "";
	m_strCABPath = "";
	m_strImagePath = "";
	m_strRootDir = "";
	m_strMainFeature = "";
	m_strLanguage = "";
	m_strAddFeature = "";
	m_bExtractCAB = FALSE;
	m_bExtractFiles = FALSE;
	m_bExtractImage = FALSE;
	m_bConfigureModule = FALSE;
	m_bLFN = FALSE;
	//}}AFX_DATA_INIT

	m_plistDirectory = NULL;
}


void CMergeD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMergeD)
	DDX_Control(pDX, IDC_ADDFEATURE, m_ctrlAddFeature);
	DDX_Control(pDX, IDC_MAINFEATURE, m_ctrlMainFeature);
	DDX_Control(pDX, IDC_ROOTDIR, m_ctrlRootDir);
	DDX_Text(pDX, IDC_MODULE, m_strModule);
	DDX_Text(pDX, IDC_EXTRACTPATH, m_strFilePath);
	DDX_Text(pDX, IDC_EXTRACTCAB, m_strCABPath);
	DDX_Text(pDX, IDC_EXTRACTIMAGE, m_strImagePath);
	DDX_Text(pDX, IDC_ROOTDIR, m_strRootDir);
	DDX_Text(pDX, IDC_MAINFEATURE, m_strMainFeature);
	DDX_Text(pDX, IDC_LANGUAGE, m_strLanguage);
	DDX_Check(pDX, IDC_FEXTRACTFILES, m_bExtractFiles);
	DDX_Check(pDX, IDC_FEXTRACTCAB, m_bExtractCAB);
	DDX_Check(pDX, IDC_FEXTRACTIMAGE, m_bExtractImage);
	DDX_Check(pDX, IDC_CONFIGUREMODULE, m_bConfigureModule);
	DDX_Check(pDX, IDC_USELFN, m_bLFN);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMergeD, CDialog)
	//{{AFX_MSG_MAP(CMergeD)
	ON_BN_CLICKED(IDC_MODULEBROWSE, OnModuleBrowse)
	ON_BN_CLICKED(IDC_CABBROWSE, OnCABBrowse)
	ON_BN_CLICKED(IDC_FILESBROWSE, OnFilesBrowse)
	ON_BN_CLICKED(IDC_IMAGEBROWSE, OnImageBrowse)
	ON_BN_CLICKED(IDC_FEXTRACTCAB, OnFExtractCAB)
	ON_BN_CLICKED(IDC_FEXTRACTFILES, OnFExtractFiles)
	ON_BN_CLICKED(IDC_FEXTRACTIMAGE, OnFExtractImage)
	ON_EN_CHANGE(IDC_MODULE, OnChangeModulePath)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMergeD message handlers

BOOL CMergeD::OnInitDialog() 
{
	ASSERT(m_plistFeature);
	ASSERT(m_plistDirectory);
	CDialog::OnInitDialog();

	while (m_plistDirectory->GetHeadPosition())
	{
		m_ctrlRootDir.AddString(m_plistDirectory->RemoveHead());
	}

	// subclass additional feature list box to a checkbox
	m_ctrlAddFeature.SubclassDlgItem(IDC_ADDFEATURE, this);
	
	CString strAdd;
	while (m_plistFeature->GetHeadPosition())
	{
		strAdd = m_plistFeature->RemoveHead();
		m_ctrlMainFeature.AddString(strAdd);
		m_ctrlAddFeature.AddString(strAdd);
	}

	m_ctrlMainFeature.SetCurSel(0);
	m_ctrlRootDir.SetCurSel(0);

	GetDlgItem(IDOK)->EnableWindow(!m_strModule.IsEmpty());

	return TRUE;  // return TRUE unless you set the focus to a control
}


////
//  Throws up a browse dialog for finding a module
void CMergeD::OnModuleBrowse() 
{
	// open the file open dialog
	CFileDialogEx dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY|OFN_FILEMUSTEXIST,
						 _T("Merge Module (*.msm)|*.msm|All Files (*.*)|*.*||"), this);

	if (IDOK == dlg.DoModal())
	{
		m_strModule = dlg.GetPathName();
		UpdateData(FALSE);
		GetDlgItem(IDOK)->EnableWindow(!m_strModule.IsEmpty());
	}
}

////
//  Throws up a browse dialog for finding a cab extraction path
void CMergeD::OnCABBrowse() 
{
	// open the file open dialog
	CFileDialogEx dlg(FALSE, _T("cab"), NULL, OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,
						 _T("Cabinet (*.cab)|*.cab|All Files (*.*)|*.*||"), this);
	if (IDOK == dlg.DoModal())
	{
		m_strCABPath = dlg.GetPathName();
		UpdateData(FALSE);
	}

}

////
//  Throws up a browse dialog for finding root tree path
void CMergeD::OnFilesBrowse() 
{
	UpdateData();

	CFolderDialog dlg(this->m_hWnd, _T("Select a root path for the module source image."));

	if (IDOK == dlg.DoModal())
	{
		// update the dialog box
		m_strFilePath = dlg.GetPath();
		UpdateData(FALSE);
	}
}


////
//  Throws up a browse dialog for finding root tree path
void CMergeD::OnImageBrowse() 
{
	UpdateData();

	CFolderDialog dlg(this->m_hWnd, _T("Select a root path for the product source image."));

	if (IDOK == dlg.DoModal())
	{
		// update the dialog box
		m_strImagePath = dlg.GetPath();
		UpdateData(FALSE);
	}
}


////
//  Enables and disables the edit and browse boxes for CAB extraction
void CMergeD::OnFExtractCAB() 
{
	UpdateData(TRUE);
	GetDlgItem(IDC_CABSTATIC)->EnableWindow(m_bExtractCAB);
	GetDlgItem(IDC_EXTRACTCAB)->EnableWindow(m_bExtractCAB);
	GetDlgItem(IDC_CABBROWSE)->EnableWindow(m_bExtractCAB);
}

////
//  Enables and disables the edit and browse boxes for CAB extraction
void CMergeD::OnFExtractFiles() 
{
	UpdateData(TRUE);
	GetDlgItem(IDC_FILESTATIC)->EnableWindow(m_bExtractFiles);
	GetDlgItem(IDC_EXTRACTPATH)->EnableWindow(m_bExtractFiles);
	GetDlgItem(IDC_FILESBROWSE)->EnableWindow(m_bExtractFiles);
}

////
//  Enables and disables the edit and browse boxes for Image extraction
void CMergeD::OnFExtractImage() 
{
	UpdateData(TRUE);
	GetDlgItem(IDC_IMAGESTATIC)->EnableWindow(m_bExtractImage);
	GetDlgItem(IDC_EXTRACTIMAGE)->EnableWindow(m_bExtractImage);
	GetDlgItem(IDC_IMAGEBROWSE)->EnableWindow(m_bExtractImage);
}


////
//  Enables and disables the OK button based on the module path
void CMergeD::OnChangeModulePath() 
{
	CString strValue;
	GetDlgItem(IDC_MODULE)->GetWindowText(strValue);
	GetDlgItem(IDOK)->EnableWindow(!strValue.IsEmpty());
}


void CMergeD::OnOK() 
{
	CString strFeature;

	int cFeature = m_ctrlAddFeature.GetCount();
	m_strAddFeature = TEXT("");
	for (int i = 0; i < cFeature; i++)
	{
		// if the feature is checked, append it to the feature list
		// unless it is the same as the main feature
		if (1 == m_ctrlAddFeature.GetCheck(i))
		{
			m_ctrlAddFeature.GetText(i, strFeature);
			if (strFeature != m_strMainFeature)
			{
				m_strAddFeature += CString(TEXT(":"));
				m_strAddFeature += strFeature;
			}
		}
	}

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\oquery.cpp ===
#include "..\common\query.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\make.inc ===
BuiltHeaders: \
	$(O)\mergemod.h

!ifndef INCVER
INCVER = 0
!endif

$(O)\Mergemod.h: $(INC_DIR)\Mergemod.w
	wcshdr.exe < $(INC_DIR)\Mergemod.w > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\merged.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//--------------------------------------------------------------------------

#if !defined(AFX_MERGED_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_)
#define AFX_MERGED_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CMergeD dialog

class CMergeD : public CDialog
{
// Construction
public:
	CMergeD(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CMergeD)
	enum { IDD = IDD_MERGE };
	CCheckListBox	m_ctrlAddFeature;
	CComboBox	m_ctrlMainFeature;
	CComboBox	m_ctrlRootDir;
	CString	m_strModule;
	CString	m_strFilePath;
	CString	m_strCABPath;
	CString	m_strImagePath;
	CString	m_strRootDir;
	CString	m_strLanguage;
	CString	m_strMainFeature;
	BOOL	m_bExtractCAB;
	BOOL	m_bExtractFiles;
	BOOL	m_bExtractImage;
	BOOL	m_bConfigureModule;
	BOOL	m_bLFN;
	//}}AFX_DATA

	CStringList *m_plistDirectory;
	CStringList *m_plistFeature;
	CString	m_strAddFeature;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMergeD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMergeD)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnModuleBrowse();
	afx_msg void OnCABBrowse();
	afx_msg void OnFilesBrowse();
	afx_msg void OnImageBrowse();
	afx_msg void OnFExtractCAB();
	afx_msg void OnFExtractFiles();
	afx_msg void OnFExtractImage();
	afx_msg void OnChangeModulePath();

	// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MERGED_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\msmresd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// MsmResD.cpp : implementation file
//

#include "stdafx.h"
#include "Orca.h"
#include "MsmResD.h"
#include "domerge.h"
#include "mergemod.h"
#include "..\common\utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


inline CString BSTRtoCString(const BSTR bstrValue)
{
#ifdef _UNICODE
		return CString(bstrValue);
#else
		size_t cchLen = ::SysStringLen(bstrValue);
		CString strValue;
		LPTSTR szValue = strValue.GetBuffer(cchLen);
 		WideToAnsi(bstrValue, szValue, &cchLen);
		strValue.ReleaseBuffer();
		return strValue;
#endif
}


/////////////////////////////////////////////////////////////////////////////
// CMsmResD dialog


CMsmResD::CMsmResD(CWnd* pParent /*=NULL*/)
	: CDialog(CMsmResD::IDD, pParent)
{
	m_hPipe = INVALID_HANDLE_VALUE;
	m_hPipeThread = INVALID_HANDLE_VALUE;
	m_hExecThread = INVALID_HANDLE_VALUE;
	m_hRes = ERROR_FUNCTION_FAILED;
	//{{AFX_DATA_INIT(CMsmResD)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

}


void CMsmResD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMsmResD)
	DDX_Control(pDX, IDC_MERGERESULTS, m_ctrlResults);
	// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMsmResD, CDialog)
	//{{AFX_MSG_MAP(CMsmResD)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMsmResD message handlers


const TCHAR szLogFile[] = TEXT("\\\\.\\pipe\\MergeModLog");

DWORD WINAPI CMsmResD::WatchPipeThread(CMsmResD *pThis)
{
	char buffer[1025];
	unsigned long uiBytesRead = 0;
	if (!ConnectNamedPipe(pThis->m_hPipe, NULL))
	{
		// can return 0 if already connected. Thats OK
		if (ERROR_PIPE_CONNECTED != GetLastError())
			return 0;
	}
	
	while (ReadFile(pThis->m_hPipe, buffer, 1024, &uiBytesRead, NULL))
	{
		buffer[uiBytesRead] = 0;
#ifdef _UNICODE
		WCHAR wzBuffer[1025];
		DWORD cchBuffer = 1025;
		::MultiByteToWideChar(CP_ACP, 0, buffer, -1, wzBuffer, cchBuffer);
		pThis->m_ctrlResults.ReplaceSel(wzBuffer);
#else
		pThis->m_ctrlResults.ReplaceSel(buffer);
#endif
	}
	CloseHandle(pThis->m_hPipe);
	pThis->m_hPipe = INVALID_HANDLE_VALUE;
	return 0;
};

BOOL CMsmResD::OnInitDialog() 
{
	CDialog::OnInitDialog();
	m_ctrlResults.SetLimitText(0);
	m_hPipe = CreateNamedPipe(szLogFile, PIPE_ACCESS_INBOUND, PIPE_TYPE_BYTE | PIPE_WAIT, 
		PIPE_UNLIMITED_INSTANCES, 1024, 1024, /*timeout=*/1000, NULL);

	// win95/nt don't like NULL for threadId argument to CreateThread;
	DWORD dwThreadId = 0;
	m_hPipeThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE )WatchPipeThread, this, 0, &dwThreadId);
	m_hExecThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE )ExecuteMergeThread, this, 0, &dwThreadId);

	return TRUE;  // return TRUE unless you set the focus to a control
}


void CMsmResD::OnDestroy() 
{
	DWORD dwRes = 0;
	CloseHandle(m_hExecThread);
	CloseHandle(m_hPipeThread);
	if (INVALID_HANDLE_VALUE != m_hPipe)
		CloseHandle(m_hPipe);

}

// this thread performs the actual merge action. The logfile is the pipe name, which causes log writes to 
// wake up the WatchPipe thread and send a dialog message to the edit box. The main thread then pumps messages
// to the control, which appends the information to the log.
DWORD WINAPI CMsmResD::ExecuteMergeThread(CMsmResD *pThis)
{
	CoInitialize(NULL);
	pThis->m_hRes = ::ExecuteMerge(
				(LPMERGEDISPLAY)NULL,         // no log callback
				pThis->strHandleString,       // db handle as string
				pThis->m_strModule,           // module path
				pThis->m_strFeature,
				_ttoi(pThis->m_strLanguage),  // language
				pThis->m_strRootDir,          // redirection directory
				pThis->m_strCABPath,          // extract CAB path
				pThis->m_strFilePath,
				pThis->m_strImagePath,
				szLogFile,                    // log file path
				true,                         // don't log open/close of DB handle
				pThis->m_fLFN,                // long file names
				pThis->CallbackObj,           // callback interface,
				NULL,
				commitNo);                    // don't auto-save
	CoUninitialize();

	pThis->GetDlgItem(IDOK)->EnableWindow(TRUE);
	pThis->GetDlgItem(IDCANCEL)->EnableWindow(TRUE);
	return pThis->m_hRes;
};



inline void MSMStringstoCStringArray(IMsmStrings *piStrings, CStringArray &strArray)
{
	strArray.RemoveAll();

	IUnknown *pUnk = NULL;
	IEnumMsmString *piEnumString = NULL;
	if (S_OK != piStrings->get__NewEnum(&pUnk))
		return;

	HRESULT hRes = pUnk->QueryInterface(IID_IEnumMsmString, reinterpret_cast<void **>(&piEnumString));
	pUnk->Release();
	if (S_OK != hRes)
		return;

	BSTR bstr;
	unsigned long cRead = 0;
	while ((S_OK == piEnumString->Next(1, &bstr, &cRead)) && cRead)
	{
		strArray.Add(BSTRtoCString(bstr));
		::SysFreeString(bstr);
	}
	return;
}



/////////////////////////////////////////////////////////////////////////////
// CMsmFailD dialog


CMsmFailD::CMsmFailD(CWnd* pParent /*=NULL*/)
	: CDialog(CMsmFailD::IDD, pParent)
{
	m_piErrors = NULL;
	//{{AFX_DATA_INIT(CMsmFailD)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

}


void CMsmFailD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMsmResD)
	DDX_Control(pDX, IDC_MERGEFAILURE, m_ctrlResults);
	// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMsmFailD, CDialog)
	//{{AFX_MSG_MAP(CMsmResD)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMsmFailD message handlers

BOOL CMsmFailD::OnInitDialog() 
{
	CDialog::OnInitDialog();

	if (!m_piErrors)
		return TRUE;
 	
	m_ctrlResults.SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES);

    m_ctrlResults.InsertColumn(0, _T("Type"), LVCFMT_LEFT, -1, 0);
    m_ctrlResults.InsertColumn(1, _T("Description"), LVCFMT_LEFT, -1, 1);

    CString strType;
    CString strDescription;
    IMsmError* piError;
	IEnumMsmError* piEnumError;

	IUnknown *pUnk = NULL;
	bool fFailed = FAILED(m_piErrors->get__NewEnum(&pUnk));
	m_piErrors->Release();

	if (!fFailed && pUnk)
	{
		fFailed = FAILED(pUnk->QueryInterface(IID_IEnumMsmError, (void **)&piEnumError));
		pUnk->Release();
	}

	if (!fFailed)
	{
		unsigned long cRead = 0;
		while ((S_OK == piEnumError->Next(1, &piError, &cRead)) && cRead)
		{
			msmErrorType eType;
			if (FAILED(piError->get_Type(&eType)))
			{
				fFailed = true;
				continue;
			}
			switch (eType) 
			{
			case msmErrorLanguageUnsupported:
			{
				strType = TEXT("Unsupported Language");
				short iLanguage;
				if (FAILED(piError->get_Language(&iLanguage)))
				{
					fFailed = true;
					continue;
				}
				strDescription.Format(TEXT("The language %d is not supported by this module."), iLanguage);
				break;
			}
			case msmErrorLanguageFailed:
			{
				strType = TEXT("Language Failure");
				short iLanguage;
				if (FAILED(piError->get_Language(&iLanguage)))
				{
					fFailed = true;
					continue;
				}

				strDescription.Format(TEXT("The module could not be opened in language %d."), iLanguage);
				break;
			}
			case msmErrorExclusion:
			{
				strType = TEXT("Exclusion");
		
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_DatabaseKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}

				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}
					
				if (!rgstrModule.GetSize())
				{
					if (FAILED(piError->get_ModuleKeys(&piStrings)))
					{
						fFailed = true;
						continue;
					}

					if (piStrings)
					{
						MSMStringstoCStringArray(piStrings, rgstrModule);
						piStrings->Release();
					}
				}
		
				strDescription.Format(TEXT("The module can not coexist with module %s v%s (%s). "), rgstrModule.GetAt(0), rgstrModule.GetAt(2), rgstrModule.GetAt(1));
				break;
			}
			case msmErrorTableMerge:
			{
				strType = TEXT("Merge Conflict");
				
				BSTR bstr=NULL;
				if (FAILED(piError->get_ModuleTable(&bstr)))
				{
					fFailed = true;
					continue;
				}
				CString strTable = BSTRtoCString(bstr);
				if (bstr)
					SysFreeString(bstr);
		
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}

				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}
					
				strDescription.Format(TEXT("Conflict in %s table, Row: %s"), strTable, rgstrModule.GetAt(0));
				for (int i=1; i < rgstrModule.GetSize(); i++)
				{
					strDescription += TEXT(", ");
					strDescription += rgstrModule.GetAt(i);
				}
				
				break;
			}
			case msmErrorResequenceMerge:
			{
				strType = TEXT("Sequencing Conflict");
				
				BSTR bstr=NULL;
				if (FAILED(piError->get_ModuleTable(&bstr)))
				{
					fFailed = true;
					continue;
				}
				CString strTable = BSTRtoCString(bstr);
				if (bstr)
					SysFreeString(bstr);
		
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}
				
				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}

				strDescription.Format(TEXT("Sequence conflict for %s action in %s table."), (LPCTSTR)rgstrModule.GetAt(0), (LPCTSTR)strTable);
				
				break;
			}
			case msmErrorFileCreate:
			{
				strType = TEXT("File Creation");
										
				BSTR bstr = NULL;
				if (FAILED(piError->get_Path(&bstr)))
				{
					fFailed = true;
					continue;
				}

				CString strPath = BSTRtoCString(bstr);
				if (bstr)
					SysFreeString(bstr);
	
				if (strPath.IsEmpty())
					strDescription = TEXT("Could not create file.");
				else
					strDescription.Format(TEXT("Could not create file: %s"), strPath);
				break;
			}
			case msmErrorDirCreate:
			{
				strType = TEXT("Directory Creation");
							
				BSTR bstr = NULL;
				if (FAILED(piError->get_Path(&bstr)))
				{
					fFailed = true;
					continue;
				}

				CString strPath = BSTRtoCString(bstr);
				if (bstr)
					SysFreeString(bstr);
	
				strDescription.Format(TEXT("Could not create path: %s"), strPath);
				break;
			}
			case msmErrorFeatureRequired:
			{
				strType = TEXT("Feature Required");
				
				BSTR bstr = NULL;
				if (FAILED(piError->get_ModuleTable(&bstr)))
				{
					fFailed = true;
					continue;
				}
				CString strTable = BSTRtoCString(bstr);
				if (bstr)
					SysFreeString(bstr);
						
				strDescription.Format(TEXT("A feature is required by the %s table."), strTable);
				break;
			}
			case msmErrorBadNullSubstitution:
			{
				strType = TEXT("Invalid NULL");
				
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}

				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}

				strDescription.Format(TEXT("Module configuration attempted to place a NULL value in the %s column of the %s table."), rgstrModule.GetAt(2), rgstrModule.GetAt(0));
				break;
			}
			case msmErrorBadSubstitutionType:
			{
				strType = TEXT("Configuration Error");
				
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}

				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}

				strDescription.Format(TEXT("The type of value in the %s column of the %s table did not match the column type."), rgstrModule.GetAt(2), rgstrModule.GetAt(0));
				break;
			}
			case msmErrorMissingConfigItem:
			{
				strType = TEXT("Configuration Error");
				
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}

				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}

				strDescription.Format(TEXT("Unknown configuration value requested for the %s column of the %s table."), rgstrModule.GetAt(2), rgstrModule.GetAt(0));
				break;
			}
			case msmErrorBadNullResponse:
			{
				strType = TEXT("Invalid NULL");
				
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}

				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}
				
				strDescription.Format(TEXT("NULL is not a valid response for module configuration parameter %s."), rgstrModule.GetAt(0));
				break;
			}
			case msmErrorDataRequestFailed:
			{
				strType = TEXT("Internal Orca Error");
				
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}
				
				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}

				strDescription.Format(TEXT("Internal failure providing data for the %s configuration parameter."), rgstrModule.GetAt(0));
				break;
			}
			default:
			{
				strType = TEXT("Unknown Error");
				
				strDescription = TEXT("Unknown failure.");
				break;
			}
			}
		
			// insert item
			int iIndex = m_ctrlResults.InsertItem(1, strType);
			m_ctrlResults.SetItem(iIndex, 1, LVIF_TEXT, strDescription, 0, 0, 0, 0);
		}
	}
	if (fFailed)
	{
		int iIndex = m_ctrlResults.InsertItem(1, TEXT("Failure"));
		m_ctrlResults.SetItem(iIndex, 1, LVIF_TEXT,  TEXT("Orca was unable to retrieve all error data."), 0, 0, 0, 0);
	}

    m_ctrlResults.SetColumnWidth(0, LVSCW_AUTOSIZE);
    m_ctrlResults.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);

	if (!m_ctrlResults.GetItemCount())
		EndDialog(IDOK);

    return TRUE;  // return TRUE unless you set the focus to a control
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\msmresd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_MsmResD_H__20272D54_EADD_11D1_A857_006097ABDE17__INCLUDED_)
#define AFX_MsmResD_H__20272D54_EADD_11D1_A857_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// MsmResD.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CMsmResD dialog
struct IMsmConfigureModule;
struct IMsmErrors;

class CMsmResD : public CDialog
{
// Construction
public:
	CMsmResD(CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CMsmResD)
	enum { IDD = IDD_MERGERESULTS };
		// NOTE: the ClassWizard will add data members here
	CEdit m_ctrlResults;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMsmResD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	CString strHandleString;             // db handle as string
	CString m_strModule;             // module path
	CString m_strFeature;
	CString m_strLanguage;    // language
	CString m_strRootDir;            // redirection directory
	CString m_strCABPath;   // extract CAB path
	CString m_strFilePath;
	CString m_strImagePath;
	bool    m_fLFN;
	struct IMsmConfigureModule *CallbackObj;       // callback interface

	HRESULT m_hRes;
				
// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMsmResD)
	virtual BOOL OnInitDialog();
	virtual void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	HANDLE m_hPipeThread;
	HANDLE m_hExecThread;
	HANDLE m_hPipe;

	static DWORD __stdcall WatchPipeThread(CMsmResD *pThis);
	static DWORD __stdcall ExecuteMergeThread(CMsmResD *pThis);
};


class CMsmFailD : public CDialog
{
// Construction
public:
	CMsmFailD(CWnd* pParent = NULL);

	// Dialog Data
	//{{AFX_DATA(CMsmFailD)
	enum { IDD = IDD_MERGEFAILURE };
		// NOTE: the ClassWizard will add data members here
	CListCtrl m_ctrlResults;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMsmFailD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	IMsmErrors* m_piErrors;
				
// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMsmFailD)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
 #endif // !defined(AFX_MsmResD_H__20272D54_EADD_11D1_A857_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\orcadoc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// OrcaDoc.cpp : implementation of the COrcaDoc class
//

#include "stdafx.h"
#include "Orca.h"
#include "MainFrm.h"
#include "Imprtdlg.h"

#include <afxdisp.h>

#include "OrcaDoc.h"

#include "SummaryD.h"
#include "ValD.h"
#include "AddTblD.h"
#include "AddRowD.h"
#include "merged.h"
#include "cnfgmsmd.h"
#include "msmresd.h"
#include "trnpropd.h"
#include "..\common\query.h"
#include "..\common\dbutils.h"
#include "..\common\utils.h"
#include "domerge.h"
#include "msidefs.h"
#include "folderd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COrcaDoc

IMPLEMENT_DYNCREATE(COrcaDoc, CDocument)

BEGIN_MESSAGE_MAP(COrcaDoc, CDocument)
	//{{AFX_MSG_MAP(COrcaDoc)
	ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
	ON_COMMAND(ID_FILE_SAVE_TRANSFORMED, OnFileSaveTransformed)
	ON_COMMAND(ID_SUMMARY_INFORMATION, OnSummaryInformation)
	ON_COMMAND(ID_FILE_CLOSE, OnFileClose)
	ON_COMMAND(ID_TABLE_ADD, OnTableAdd)
	ON_COMMAND(ID_ROW_ADD, OnRowAdd)
	ON_COMMAND(ID_TABLE_DROP, OnTableDrop)
	ON_COMMAND(ID_TABLES_IMPORT, OnTablesImport)
	ON_COMMAND(ID_VALIDATOR, OnValidator)
	ON_COMMAND(ID_TRANSFORM_APPLYTRANSFORM, OnApplyTransform)
	ON_COMMAND(ID_TRANSFORM_NEWTRANSFORM, OnNewTransform)
	ON_COMMAND(ID_TRANSFORM_GENERATETRANSFORM, OnGenerateTransform)
	ON_COMMAND(ID_TRANSFORM_TRANSFORMPROPERTIES, OnTransformProperties)
	ON_COMMAND(ID_TRANSFORM_CLOSETRANSFORM, OnCloseTransform)
	ON_COMMAND(ID_TRANSFORM_VIEWPATCH, OnTransformViewPatch)
	ON_UPDATE_COMMAND_UI(ID_FILE_CLOSE, OnUpdateFileClose)
	ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSave)
	ON_UPDATE_COMMAND_UI(ID_FILE_SAVE_AS, OnUpdateFileSaveAs)
	ON_UPDATE_COMMAND_UI(ID_FILE_SAVE_TRANSFORMED, OnUpdateFileSaveTransformed)
	ON_UPDATE_COMMAND_UI(ID_FILE_PRINT, OnUpdateFilePrint)
	ON_UPDATE_COMMAND_UI(ID_TABLE_ADD, OnUpdateTableAdd)
	ON_UPDATE_COMMAND_UI(ID_ROW_ADD, OnUpdateRowAdd)
	ON_UPDATE_COMMAND_UI(ID_VALIDATOR, OnUpdateValidator)
	ON_UPDATE_COMMAND_UI(ID_TRANSFORM_APPLYTRANSFORM, OnUpdateApplyTransform)
	ON_UPDATE_COMMAND_UI(ID_TRANSFORM_NEWTRANSFORM, OnUpdateNewTransform)
	ON_UPDATE_COMMAND_UI(ID_TRANSFORM_GENERATETRANSFORM, OnUpdateGenerateTransform)
	ON_UPDATE_COMMAND_UI(ID_TRANSFORM_CLOSETRANSFORM, OnUpdateCloseTransform)
	ON_UPDATE_COMMAND_UI(ID_TRANSFORM_VIEWPATCH, OnUpdateTransformViewPatch)
	ON_UPDATE_COMMAND_UI(ID_TABLE_DROP, OnUpdateTableDrop)
	ON_UPDATE_COMMAND_UI(ID_SUMMARY_INFORMATION, OnUpdateSummaryInformation)
	ON_UPDATE_COMMAND_UI(ID_TABLES_EXPORT, OnUpdateTablesExport)
	ON_UPDATE_COMMAND_UI(ID_TABLES_IMPORT, OnUpdateTablesImport)
	ON_COMMAND(ID_TABLES_IMPORT, OnTablesImport)
	ON_UPDATE_COMMAND_UI(ID_VALIDATOR, OnUpdateValidator)
	ON_COMMAND(ID_VALIDATOR, OnValidator)
	ON_COMMAND(ID_TOOLS_MERGEMOD, OnMergeMod)
	ON_UPDATE_COMMAND_UI(ID_TOOLS_MERGEMOD, OnUpdateMergeMod)
	ON_UPDATE_COMMAND_UI(ID_TRANSFORM_TRANSFORMPROPERTIES, OnUpdateTransformProperties)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COrcaDoc construction/destruction

COrcaDoc::COrcaDoc() : 
	m_dwTransformErrFlags(0), 
	m_dwTransformValFlags(0),
	m_bTransformReadOnly(false),
	m_hDatabase(0),
	m_hTransformDB(0),
	m_bTransformModified(false),
	m_bTransformIsPatch(false),
	m_strTransformFile(TEXT(""))
{
	m_eiType = iDocNone;
	m_bReadOnly = false;
	m_strICEsToRun = AfxGetApp()->GetProfileString(_T("Validation"), _T("ICEs"), _T(""));
	m_strCUBFile = AfxGetApp()->GetProfileString(_T("Validation"),_T("Location"));
	m_bShowValInfo = ::AfxGetApp()->GetProfileInt(_T("Validation"), _T("SuppressInfo"), 0) != 1;
	m_strStoredModuleLanguage = TEXT("1033");
	m_strStoredModuleName = TEXT("");
}

COrcaDoc::~COrcaDoc()
{
	// if a database is open close it
	if (m_hDatabase)
		MsiCloseHandle(m_hDatabase);

	if (m_hTransformDB)
	{
		MsiCloseHandle(m_hTransformDB);
		m_hTransformDB=0;
		if (!m_strTransformTempDB.IsEmpty())
		{
			DeleteFile(m_strTransformTempDB);
			m_strTransformTempDB = _T("");
		}
	}

	while (!m_lstPatchFiles.IsEmpty())
		m_lstPatchFiles.RemoveHead();

	// just in case
	DestroyTableList();
	m_eiType = iDocNone;
}

/////////////////////////////////////////////////////////////////////////////
// COrcaDoc diagnostics

#ifdef _DEBUG
void COrcaDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void COrcaDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COrcaDoc commands

BOOL COrcaDoc::OnNewDocument()
{
	CWaitCursor curWait;

	TRACE(_T("COrcaDoc::OnNewDocument - called.\n"));

	// if a database is open close it
	if (m_hDatabase)
	{
		MsiCloseHandle(m_hDatabase);
		m_hDatabase = NULL;
	}

	// if a transform is open close it
	if (m_hTransformDB)
	{
		MsiCloseHandle(m_hTransformDB);
		m_hTransformDB = 0;
		if (!m_strTransformTempDB.IsEmpty())
		{
			DeleteFile(m_strTransformTempDB);
			m_strTransformTempDB = _T("");
		}
	}

	// send a hint to change to no table. This cleans up the window
	// and makes it safe to have a refresh in the middle of this call.
	UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
	UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);

	// destroy all of the tables, mark no document loaded until regenerated
	DestroyTableList();	
	m_eiType = iDocNone;

	// blank all the summary information
	m_strTitle = _T("Installation Database");
	m_strSubject = _T("");
	m_strAuthor = _T("");
	m_strLastSaved = _T("");
	m_strKeywords = _T("Install,MSI");
	m_strComments = _T("This installer database contains the logic and data required to install <product name>.");
	m_strPlatform = _T("");
	m_strLanguage = _T("0");

	GUID prodGUID;
	int cchGuid = 50;
	m_strProductGUID = _T("");
	CoCreateGuid(&prodGUID);
	m_strProductGUID.Format(_T("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), 
				  prodGUID.Data1, prodGUID.Data2, prodGUID.Data3,
				  prodGUID.Data4[0], prodGUID.Data4[1],
				  prodGUID.Data4[2], prodGUID.Data4[3], prodGUID.Data4[4],
				  prodGUID.Data4[5], prodGUID.Data4[6], prodGUID.Data4[7]);
	m_nSchema = 100;
	m_nFilenameType = 0;
	m_nSecurity = 0;

	m_bTransformIsPatch = false;
	m_bTransformReadOnly = false;
	m_bReadOnly = false;

	m_dwTransformErrFlags = 0;
	m_dwTransformValFlags = 0;
	SetModifiedFlag(FALSE);

	// wipe everything
	UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);

	// do the base document's clean up
	if (!CDocument::OnNewDocument())
		return FALSE;

	// get a temp path
	DWORD cchTempPath = MAX_PATH;
	TCHAR szTempPath[MAX_PATH];
	::GetTempPath(cchTempPath, szTempPath);

	// get a temp filename
	TCHAR szTempFilename[MAX_PATH];
	UINT iResult = ::GetTempFileName(szTempPath, _T("ODB"), 0, szTempFilename);

	// try to open the database for read/write
	if (ERROR_SUCCESS != MsiOpenDatabase(szTempFilename, MSIDBOPEN_CREATE, &m_hDatabase))
		return FALSE;

	m_eiType = iDocDatabase;
	SetTitle(m_strPathName);

	return TRUE;
}

///////////////////////////////////////////////////////////
// OnFileOpen
void COrcaDoc::OnFileOpen() 
{
	// open the file open dialog
	CFileDialogEx dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST,
						 _T("Installer Database Files (*.msi, *.msm, *.pcp)|*.msi;*.msm;*.pcp|Windows Installer (*.msi)|*.msi|Merge Module (*.msm)|*.msm|Patch Creation Properties (*.pcp)|*.pcp|All Files (*.*)|*.*||"), AfxGetMainWnd());

	if (IDOK == dlg.DoModal())
	{
		bool bReadOnly = (FALSE != dlg.GetReadOnlyPref());
		OpenDocument(dlg.GetPathName(), bReadOnly);
	}
}	// end of OnFileOpen

///////////////////////////////////////////////////////////////////////
// OnOpenDocument
// bReadOnly should be set to true if this function should NOT try
// to open the document for read/write. After this function, it will
// be set to the actual state of the file.
BOOL COrcaDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
	return OpenDocument(lpszPathName, false);
}

///////////////////////////////////////////////////////////////////////
// OnOpenDocument
// bReadOnly should be set to true if this function should NOT try
// to open the document for read/write. After this function, it will
// be set to the actual state of the file.
BOOL COrcaDoc::OpenDocument(LPCTSTR lpszPathName, bool bReadOnly) 
{
	TRACE(_T("Opening file: %s\n"), lpszPathName);

	CString strPrompt;	// generic prompt string
	BOOL bResult = TRUE;	// assume everything will be okay

	int cchCount = lstrlen(lpszPathName);

	// if a database is open close it
	if (m_hDatabase)
	{
		MsiCloseHandle(m_hDatabase);
		m_hDatabase = NULL;
	}

	// if a transform is open close it
	if (m_hTransformDB)
	{
		MsiCloseHandle(m_hTransformDB);
		m_hTransformDB = 0;
		if (!m_strTransformTempDB.IsEmpty())
		{
			DeleteFile(m_strTransformTempDB);
			m_strTransformTempDB = _T("");
		}
	}
	m_dwTransformErrFlags = 0;
	m_dwTransformValFlags = 0;
	m_bTransformIsPatch = false;
	m_bTransformReadOnly = false;
	m_bReadOnly = false;
	
	// if given file on the command line, the window won't exist yet, so no update.
	// Its handled by InitInstance after the window is created.
	if (NULL != ::AfxGetMainWnd()) 
	{
		// clear any pending validation errors
		UpdateAllViews(NULL, HINT_CLEAR_VALIDATION_ERRORS, NULL);
		((CMainFrame*)AfxGetMainWnd())->HideValPane();

		// update the views that everything is gone (prevents redraws from accessing destroyed memory)
		UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
		UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);
	}
	DestroyTableList();				// destroy the old table
	m_eiType = iDocNone;

	// try to open the database for read/write, unless told not to
	UINT iResult;
	if (!bReadOnly &&
		(ERROR_SUCCESS == (iResult = MsiOpenDatabase(lpszPathName, MSIDBOPEN_TRANSACT, &m_hDatabase))))
	{
		// set the database as read/write
		m_bReadOnly = false;
		bResult = true;
	}
	else if (ERROR_SUCCESS == (iResult = MsiOpenDatabase(lpszPathName, MSIDBOPEN_READONLY, &m_hDatabase)))
	{			
		// set the database as read only
		m_bReadOnly = true;
		bResult = true;
	}
	else
	{
		bResult = false;

		strPrompt.Format(_T("Failed to open MSI Database: `%s`"), lpszPathName);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
	}

	// if succeeded
	if (bResult)
	{
		// mark that a file is open
		m_eiType = iDocDatabase;
	
		// read the summary information
		iResult = ReadSummary(m_hDatabase);
		ASSERT(ERROR_SUCCESS == iResult);

		// read the table list
		iResult = BuildTableList(/*AllowLazyLoad=*/true);
		ASSERT(ERROR_SUCCESS == iResult);

		// add this file to recently open files
		SetPathName(lpszPathName, TRUE);
	}
	else	// nothing is open
	{
		SetPathName(_T(""), FALSE);
	}

	// new document open, so there shouldn't be any changes yet
	SetModifiedFlag(FALSE);

	// if given file on the command line, the window won't exist yet, so no update.
	// Its handled by InitInstance after the window is created.
	if (NULL != ::AfxGetMainWnd()) 
	{
		// clear anything existing
		UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
		UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);
	}

	return bResult;
}	// end of OpenDocument

///////////////////////////////////////////////////////////
// OnFileSave
void COrcaDoc::OnFileSave() 
{
	ASSERT(!m_bReadOnly);
	CString strPath = GetPathName();
	UpdateAllViews(NULL, HINT_COMMIT_CHANGES);
	OnSaveDocument(strPath);
}	// end of OnFileSave

///////////////////////////////////////////////////////////
// OnFileSaveAs
void COrcaDoc::OnFileSaveAs() 
{
	// open the file open dialog
	CFileDialogEx dlg(FALSE, NULL, NULL, OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,
						 _T("Windows Installer (*.msi)|*.msi|Merge Module (*.msm)|*.msm|Patch Creation Properties (*.pcp)|*.pcp|All Files (*.*)|*.*||"), AfxGetMainWnd());

	UpdateAllViews(NULL, HINT_COMMIT_CHANGES);
	if (IDOK == dlg.DoModal())
	{
		CString strPath = dlg.GetPathName();
		CString strExt = dlg.GetFileExt();

		if (strPath.IsEmpty())
			return;

		// if there is no extension add one
		if (strExt.IsEmpty())
		{
			switch(dlg.m_ofn.nFilterIndex)
			{
			case 1:
				strExt = _T(".msi");
				break;
			case 2:
				strExt = _T(".msm");
				break;
			case 3:
				strExt = _T(".pcp");
				break;
			default:
				strExt = _T(".msi");
				break;
			}

			strPath += strExt;
		}
		
		// if saved document open it up
		if (!OnSaveDocument(strPath))
			AfxMessageBox(_T("Failed to save document."), MB_ICONSTOP);
		else
		{
			// no longer read only
			m_bReadOnly = false;

			// add this file to recently open files
			SetPathName(strPath, TRUE);
		}

	}
}	// end of OnFileSaveAs


///////////////////////////////////////////////////////////
// OnFileSaveAs
void COrcaDoc::OnFileSaveTransformed() 
{
	ASSERT(m_hTransformDB);
	if (!m_hTransformDB)
		return;

	// open the file open dialog
	CFileDialogEx dlg(FALSE, NULL, NULL, OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,
						 _T("Windows Installer (*.msi)|*.msi|Merge Module (*.msm)|*.msm|Patch Creation Properties (*.pcp)|*.pcp|All Files (*.*)|*.*||"), AfxGetMainWnd());

	UpdateAllViews(NULL, HINT_COMMIT_CHANGES);
	if (IDOK == dlg.DoModal())
	{
		CString strPath = dlg.GetPathName();
		CString strExt = dlg.GetFileExt();

		if (strPath.IsEmpty())
			return;

		// if there is no extension add one
		if (strExt.IsEmpty())
		{
			switch(dlg.m_ofn.nFilterIndex)
			{
			case 1:
				strExt = _T(".msi");
				break;
			case 2:
				strExt = _T(".msm");
				break;
			case 3:
				strExt = _T(".pcp");
				break;
			default:
				strExt = _T(".msi");
				break;
			}

			strPath += strExt;
		}
		
		// create the database to persist to
		PMSIHANDLE hPersist;
		if (ERROR_SUCCESS != MsiOpenDatabase(strPath, MSIDBOPEN_CREATE, &hPersist))
		{
			AfxMessageBox(_T("Failed to save document."), MB_ICONSTOP);
			return;
		}

		if (ERROR_SUCCESS == PersistTables(hPersist, GetTransformedDatabase(), /*fCommit=*/true))
		{
			SetModifiedFlag(FALSE);
		}
	}
}	// end of OnFileSaveAs

///////////////////////////////////////////////////////////
// OnSaveDocument
BOOL COrcaDoc::OnSaveDocument(LPCTSTR lpszPathName) 
{
	TRACE(_T("COrcaDoc::OnSaveDocument - called[%s]\n"), lpszPathName);

	// if the path name is empty call on OnSaveAs
	if (0 == lstrlen(lpszPathName))
	{
		OnFileSaveAs();
		return TRUE;
	}

	// pop up the wait cursor
	CWaitCursor cursor;

	BOOL bResult = FALSE;		// assume we won't save

	// assume everything is good
	UINT iResult = ERROR_SUCCESS;	

	// if these are not the same databases
	MSIHANDLE hPersist = NULL;
	if (0 != m_strPathName.CompareNoCase(lpszPathName))
	{
		// create the database to persist to
		iResult = MsiOpenDatabase(lpszPathName, MSIDBOPEN_CREATE, &hPersist);
	}
	else	// saving to the same database
		hPersist = m_hDatabase;

	// if tables are persisted (and saved)
	if (ERROR_SUCCESS == PersistTables(hPersist, GetOriginalDatabase(), /*fCommit=*/true))
	{
		SetModifiedFlag(FALSE);
		bResult = TRUE;
	}

	// if the persisted database is valid and not the main database
	if (NULL != hPersist && 
		hPersist != m_hDatabase)
	{
		// close the current database, because SaveAs leaves you
		// with the new one
		MsiCloseHandle(m_hDatabase);	// close it
		m_hDatabase = hPersist;
	}

	return bResult;
}	// end of OnSaveDocument

///////////////////////////////////////////////////////////
// OnFileClose
void COrcaDoc::OnFileClose() 
{
	// commit any changes pending in the edit window
	UpdateAllViews(NULL, HINT_COMMIT_CHANGES);

	// if the document is modified ask to save
	if (IsModified())
	{
		CString strPrompt;
		strPrompt.Format(_T("Save changes to %s?"), m_strPathName);

		UINT iResult = AfxMessageBox(strPrompt, MB_YESNOCANCEL);

		if (IDYES == iResult)
		{
			// if the path name is empty call on OnSaveAs
			if (m_strPathName.IsEmpty())
			{
				OnFileSaveAs();
			}
			else	// already have a path to save to
			{
				// if fail to save as bail
				if (!OnSaveDocument(m_strPathName))
					return;
			}
		}
		else if (IDCANCEL == iResult)
			return;
	}

	// clear any pending validation errors
	UpdateAllViews(NULL, HINT_CLEAR_VALIDATION_ERRORS, NULL);
	((CMainFrame*)AfxGetMainWnd())->HideValPane();

	// switch the table list to point to nothing, so that when we destroy the 
	// table list and its corresponding rows, we won't have the view try to 
	// refresh the display of the deleted table
	UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
	UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);

	// pop up a wait cursor
	CWaitCursor cursor;

	m_dwTransformErrFlags = 0;
	m_dwTransformValFlags = 0;
	DestroyTableList();				// destroy the tables
	m_eiType = iDocNone;

	if (DoesTransformGetEdit())
		CloseTransform();

	// if a database is open close it
	if (m_hDatabase)
	{
		MsiCloseHandle(m_hDatabase);
		m_hDatabase = NULL;
	}

	m_bReadOnly = false;
	SetModifiedFlag(FALSE);
	SetPathName(_T(""), FALSE);

	UpdateAllViews(NULL, HINT_RELOAD_ALL);

}	// end of OnFileClose

///////////////////////////////////////////////////////////
// OnTableAdd
void COrcaDoc::OnTableAdd() 
{	
	// get the app
	COrcaApp* pApp = (COrcaApp*)AfxGetApp();

	// get all the table names
	CQuery querySchema;
	if (ERROR_SUCCESS != querySchema.Open(pApp->m_hSchema, _T("SELECT `Name` FROM `_Tables`")))
		return;
	if (ERROR_SUCCESS != querySchema.Execute())
		return;

	CString strTable;
	CStringList strTableList;

	UINT iResult;
	PMSIHANDLE hTable;
	do
	{
		iResult = querySchema.Fetch(&hTable);

		if (ERROR_SUCCESS == iResult)
		{
			// get the table name
			DWORD cchBuffer = 256 * sizeof(TCHAR);
			MsiRecordGetString(hTable, 1, strTable.GetBuffer(cchBuffer), &cchBuffer);
			strTable.ReleaseBuffer();

			// add this table to the list
			strTableList.AddTail(strTable);
		}
		else if (ERROR_NO_MORE_ITEMS != iResult)
		{
			TRACE(_T(">> Unknown error.  #%d\n"), iResult);
			break;
		}
	} while (hTable);

	if (strTableList.GetCount() > 0)
	{
		// get all of the tables from the current database
		CQuery queryDatabase;
		if (ERROR_SUCCESS != queryDatabase.Open(GetTargetDatabase(), _T("SELECT `Name` FROM `_Tables`")))
			return;
		if (ERROR_SUCCESS != queryDatabase.Execute())
			return;

		POSITION posFound;
		do
		{
			iResult = queryDatabase.Fetch(&hTable);

			if (ERROR_SUCCESS == iResult)
			{
				// get the table name
				DWORD cchBuffer = 256 * sizeof(TCHAR);
				MsiRecordGetString(hTable, 1, strTable.GetBuffer(cchBuffer), &cchBuffer);
				strTable.ReleaseBuffer();

				// if this table is in the table list
				posFound = strTableList.Find(strTable);
				if (posFound)
				{
					// remove the string from the list to add
					strTableList.RemoveAt(posFound);
				}
				else	// I don't think I should get here
					ASSERT(FALSE);	// will fail on the flags table
			}
			else if (ERROR_NO_MORE_ITEMS != iResult)
			{
				TRACE(_T(">> Unknown error.  #%d\n"), iResult);
				break;
			}
		} while (hTable);

		// create the add dialog box
		CAddTableD dlg;
		dlg.m_plistTables = &strTableList;

		if (IDOK == dlg.DoModal())
		{
			CString strPrompt;
			POSITION pos = strTableList.GetHeadPosition();
			while (pos)
			{
				strTable = strTableList.GetNext(pos);
				if (ERROR_SUCCESS == MsiDBUtils::CreateTable(strTable, GetTargetDatabase(), pApp->m_hSchema))
				{
					// the document is definitely modified
					SetModifiedFlag(TRUE);
					/// ***********************
					CreateAndLoadNewlyAddedTable(strTable);
				}					
				else	// failed to create the table
				{
					strPrompt.Format(_T("Failed to create table: '%s'"), strTable);
					AfxMessageBox(strPrompt, MB_ICONSTOP);
				}
			}
		}
	}
}	// end of OnTableAdd


///////////////////////////////////////////////////////////////////////
// adds a new table by name. Checks for existing tables. May add a 
// new table to the UI or may not, depending on schema differences
// between the two databasases. Returns pointer to new table.
COrcaTable *COrcaDoc::CreateAndLoadNewlyAddedTable(CString strTable)
{
	// if this table already exists in the UI, it either:
	//  1) is a shadow table
	//  2) is non-split with a compatible schema
	//  3) is non-split with an incompatible schema
	
	// what to do for shadow tables *****************
	// look for the table in the UI. Since this is a new table, we're looking for
	// the opposite database UI entry.
	COrcaTable *pTable = FindTable(strTable, DoesTransformGetEdit() ? odlSplitOriginal : odlSplitTransformed);
	if (pTable && !pTable->IsShadow())
	{
		ASSERT(MSICONDITION_NONE != ::MsiDatabaseIsTablePersistent(GetOriginalDatabase(), strTable));
		ASSERT(!pTable->IsSplitSource());
		
		// check to see if the schema is compatible.
		bool fExact = false;
		bool fCompatible = !pTable->IsSchemaDifferent(GetTargetDatabase(), false, fExact);

		// if the schemas are not compatible, the existing table becomes a drop, but we
		// also need to add a NEW table with the new column definitions. Both tables are now
		// split-source tables
		if (!fCompatible)
		{
			pTable->SetSplitSource(odlSplitOriginal);
			pTable->Transform(iTransformDrop);
			ASSERT(pTable->IsTransformed());
			
			COrcaTable *pNewTable = CreateAndLoadTable(GetTargetDatabase(), strTable);
			pNewTable->SetSplitSource(odlSplitTransformed);
			pNewTable->Transform(iTransformAdd);

			UpdateAllViews(NULL, HINT_ADD_TABLE, pNewTable);
			UpdateAllViews(NULL, HINT_REDRAW_TABLE, pTable);
		}
		else
		{
			// but if the schemas are compatible, the "drop" or "add" is erased, so we clear the 
			// transform on this table
			pTable->Transform(iTransformNone);

			// and redraw the ui in the table list
			UpdateAllViews(NULL, HINT_REDRAW_TABLE, pTable);

			// if the tables aren't exactly the same, we need to do some schema work, 
			// but if they are exactly the same, a simple data reload will do 
			if (!fExact)
			{
				// when adding a table to a transform, its a superset, so we
				// need to add the additional columns
				pTable->LoadTableSchema(GetTransformedDatabase(), strTable);
				UpdateAllViews(NULL, HINT_TABLE_REDEFINE, pTable);
			}
			else
			{
				// we need to do a data reload in case the newly added table's data differs from
				// the existing table (which it almost always will)
				pTable->EmptyTable();
				
				// and redraw the ui in the table list
				UpdateAllViews(NULL, HINT_TABLE_DATACHANGE, pTable);
			}
		}
	}
	else
	{
		// doesn't exist in the non-target, so this is a "clean add" load the table
		pTable = CreateAndLoadTable(GetTargetDatabase(), strTable);
		if (pTable && DoesTransformGetEdit())
		{
			pTable->Transform(iTransformAdd);
		}
		SetModifiedFlag(TRUE);
		UpdateAllViews(NULL, HINT_ADD_TABLE, pTable);
	}
	return pTable;
}


///////////////////////////////////////////////////////////
// Export Tables, called by messagehandlers of TableList and the menu
// to export a table
bool COrcaDoc::ExportTable(const CString* pstrTableName, const CString *pstrDirName) 
{

	UINT iResult;
	CString strPrompt;
	CString strFilename;
			
	strFilename.Format(_T("%s.idt"), pstrTableName->Left(8));
	iResult = ::MsiDatabaseExport(GetTargetDatabase(), *pstrTableName, *pstrDirName, strFilename);

	return (ERROR_SUCCESS == iResult);
}

///////////////////////////////////////////////////////////
// OnRowAdd - message handler for "add row". Throws UI
// and creates a row from the results, then adds it to
// the table.
void COrcaDoc::OnRowAdd() 
{
	// if read only, do nothing.
	if (TargetIsReadOnly()) return;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	COrcaTable* pTable = pFrame->GetCurrentTable();
	ASSERT(pTable);
	if (!pTable)
		return;


	CAddRowD dlg;
	pTable->FillColumnArray(&dlg.m_pcolArray, DoesTransformGetEdit());

	if (IDOK == dlg.DoModal())
	{
		CString strPrompt;
		if (ERROR_SUCCESS != AddRow(pTable, &dlg.m_strListReturn))
		{
			strPrompt.Format(_T("Failed to add row to the %s table."), pTable->Name());
			AfxMessageBox(strPrompt);
		}
	}
}	// end of OnRowAdd

void COrcaDoc::OnTableDrop() 
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	COrcaTable* pTable = pFrame->GetCurrentTable();
	ASSERT (pTable && pFrame);
	if (!pTable || ! pFrame)
		return;

	CString strPrompt;
	strPrompt.Format(_T("Drop table '%s'?"), pTable->Name());
	if (IDYES == AfxMessageBox(strPrompt, MB_ICONINFORMATION|MB_YESNO))
	{
		POSITION pos = m_tableList.Find(pTable);
		if (pos)
		{
			pTable->DropTable(GetTargetDatabase());
			SetModifiedFlag(TRUE);

			// the table is removed from the UI if there are no transforms, if the table
			// doesn't exist in the target database, or if the table is marked as
			// a single source table. Otherwise its just a transform op.
			MSIHANDLE hNonTarget = GetOriginalDatabase();
			if (!DoesTransformGetEdit() || (MSICONDITION_NONE == MsiDatabaseIsTablePersistent(hNonTarget, pTable->Name())) ||
			    pTable->IsSplitSource())
			{
				// update the views before yanking the data
				UpdateAllViews(NULL, HINT_DROP_TABLE, pTable);
				m_tableList.RemoveAt(pos);

				if (pTable->IsSplitSource())
				{	
					// doesn't matter what split source we search for, as we just removed this 
					// half from the split table list
					COrcaTable *pOtherTable = FindTable(pTable->Name(), DoesTransformGetEdit() ? odlSplitOriginal : odlSplitTransformed);
					ASSERT(pOtherTable);
					if (pOtherTable)
						pOtherTable->SetSplitSource(odlNotSplit);
				}

				// finally delete the table object
				pTable->DestroyTable();
				delete pTable;
				pTable = NULL;
			}
			else
			{
				// otherwise we're actually transforming the object to signify the drop. The table
				// will take care of any UI changes that need to be done during the drop.
				pTable->Transform(iTransformDrop);
			}
		}
		else	// shouldn't get here
		{
			AfxMessageBox(_T("Error: Attempted to drop non-existant table."), MB_ICONSTOP);
		}
	}
}

///////////////////////////////////////////////////////////
// CmdSetters
void COrcaDoc::OnUpdateFileClose(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone);
}

void COrcaDoc::OnUpdateFileSave(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone && m_bModified && !DoesTransformGetEdit());
}

void COrcaDoc::OnUpdateFileSaveAs(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone && !DoesTransformGetEdit());
}

void COrcaDoc::OnUpdateFileSaveTransformed(CCmdUI* pCmdUI) { pCmdUI->Enable(DoesTransformGetEdit() && !m_bTransformIsPatch); }

void COrcaDoc::OnUpdateFilePrint(CCmdUI* pCmdUI) 
{
	// disable printing forever
	pCmdUI->Enable(FALSE);
}

void COrcaDoc::OnUpdateTableAdd(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(!TargetIsReadOnly() && m_eiType != iDocNone);
}

void COrcaDoc::OnUpdateTableDrop(CCmdUI* pCmdUI) 
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!pFrame)
		pCmdUI->Enable(FALSE);
	else
	{
		COrcaTable *pTable = pFrame->GetCurrentTable();
		if (DoesTransformGetEdit())
		{
			pCmdUI->Enable(NULL != pTable && !m_bTransformReadOnly && !pTable->IsShadow() && (pTable->IsTransformed() != iTransformDrop));
		}
		else
		{
			pCmdUI->Enable(NULL != pTable && !m_bReadOnly && !pTable->IsShadow());
		}
	}
}

void COrcaDoc::OnUpdateRowAdd(CCmdUI* pCmdUI) 
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!pFrame)
		pCmdUI->Enable(FALSE);
	else
	{
		// if there is an active non-shadow table enable it
		COrcaTable *pTable = pFrame->GetCurrentTable();
		if (DoesTransformGetEdit())
			pCmdUI->Enable(!m_bTransformReadOnly && NULL != pTable && !pTable->IsShadow() && (pTable->IsTransformed() != iTransformDrop));
		else
			pCmdUI->Enable(!m_bReadOnly && NULL != pTable && !pTable->IsShadow());

	}
}

void COrcaDoc::OnUpdateValidator(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone);
}

void COrcaDoc::OnUpdateMergeMod(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone);
}

void COrcaDoc::OnUpdateSummaryInformation(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone);
}

void COrcaDoc::OnUpdateTablesExport(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone);
}

///////////////////////////////////////////////////////////
// BuildTableList
// populate the table list with all tables in the orinigal database or
// the transformed database.
UINT COrcaDoc::BuildTableList(bool fAllowLazyDataLoad)
{
	ASSERT(m_hDatabase);
	ASSERT(iDocDatabase == m_eiType);

	// get all the table names
	CQuery queryTables;
	if (ERROR_SUCCESS != queryTables.Open(GetOriginalDatabase(), _T("SELECT `Name` FROM `_Tables`")))
		return ERROR_FUNCTION_FAILED;
	if (ERROR_SUCCESS != queryTables.Execute())
		return ERROR_FUNCTION_FAILED;

	CString strTable;

	// this query is used to see if an existing table has been dropped from the opposing database.
	CQuery qDroppedTable;
	if (m_hTransformDB)
	{
		if (ERROR_SUCCESS != qDroppedTable.Open(m_hTransformDB, _T("SELECT `Name` FROM `_Tables` WHERE `Name`=?")))
			return ERROR_FUNCTION_FAILED;
	}
	
	PMSIHANDLE hTable;
	UINT iResult = ERROR_SUCCESS;
	do
	{
		iResult = queryTables.Fetch(&hTable);

		if (ERROR_SUCCESS == iResult)
		{
			// get the table name
			DWORD cchBuffer = 256 * sizeof(TCHAR);
			MsiRecordGetString(hTable, 1, strTable.GetBuffer(cchBuffer), &cchBuffer);
			strTable.ReleaseBuffer();
			
			COrcaTable* pTable = CreateAndLoadTable(GetOriginalDatabase(), strTable);
			ASSERT(pTable);
			if (!pTable)
				continue;

			// check to see if the table has been dropped (incompatible schema changes will be
			// handled when the new schema is loaded
			if (m_hTransformDB)
			{
				PMSIHANDLE hRec = MsiCreateRecord(1);
				MsiRecordSetString(hRec, 1, strTable);
				if (ERROR_SUCCESS != qDroppedTable.Execute(hRec))
					return ERROR_FUNCTION_FAILED;

				switch (qDroppedTable.Fetch(&hRec))
				{
				case ERROR_SUCCESS:
					// table exists in the transformed DB, so was not dropped
					break;
				case ERROR_NO_MORE_ITEMS:
					// table does not exist
					pTable->Transform(iTransformDrop);
					break;
				default:
					return ERROR_FUNCTION_FAILED;
				}
			}			
		}
		else if (ERROR_NO_MORE_ITEMS != iResult)
		{
			break;
		}
	} while (hTable);

	// if no more items that's okay
	if (ERROR_NO_MORE_ITEMS == iResult)
		iResult = ERROR_SUCCESS;
	else
	{
		CString strPrompt;
		strPrompt.Format(_T("MSI Error %d while retrieving tables from the database."), iResult);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		return ERROR_FUNCTION_FAILED;
	}

	// next check the transformed database for tables that are not in the original database
	if (m_hTransformDB)
	{
		if (ERROR_SUCCESS != queryTables.Open(m_hTransformDB, _T("SELECT `Name` FROM `_Tables`")))
			return ERROR_FUNCTION_FAILED;
		if (ERROR_SUCCESS != queryTables.Execute())
			return ERROR_FUNCTION_FAILED;
		do
		{
			iResult = queryTables.Fetch(&hTable);

			if (ERROR_SUCCESS == iResult)
			{
				// get the table name
				iResult = RecordGetString(hTable, 1, strTable);
				if (ERROR_SUCCESS != iResult)
				{
					CString strPrompt;
					strPrompt.Format(_T("MSI Error %d while retrieving table names from the transformed database."), iResult);
					AfxMessageBox(strPrompt, MB_ICONSTOP);
					return ERROR_FUNCTION_FAILED;
				}

				// search for an existing table object. If one doesn't exist, load
				// this table into a new object (possibly replacing shadow)
				COrcaTable* pTable = NULL;
				if (NULL == (pTable = FindTable(strTable, odlSplitOriginal)))
				{
					pTable = CreateAndLoadTable(GetTransformedDatabase(), strTable);
					if (!pTable)
					{
						CString strPrompt;
						strPrompt.Format(_T("Error loading the %s table from the transformed database."), strTable);
						AfxMessageBox(strPrompt, MB_ICONSTOP);
						return ERROR_FUNCTION_FAILED;
					}
					pTable->Transform(iTransformAdd);
				}
				else
				{				
					// if an existing table of the same name already exists, we have to check the 
					// transformed database schema to determine if we can share the existing object
					// across both databases. If so, we can just add the colums, otherwise
					// we need to create a new object.
					bool fExact = false;
					if (pTable->IsSchemaDifferent(GetTransformedDatabase(), /*fStrict=*/false, fExact))
					{
						pTable->SetSplitSource(odlSplitOriginal);
						pTable->Transform(iTransformDrop);
						
						COrcaTable *pNewTable = CreateAndLoadTable(GetTransformedDatabase(), strTable);
						if (!pNewTable)
							return ERROR_OUTOFMEMORY;
						pNewTable->SetSplitSource(odlSplitTransformed);
						pNewTable->Transform(iTransformAdd);
					}
					else
					{
						// object can be shared. Only need to reload the schema if its not exactly the same
						if (!fExact)
							pTable->LoadTableSchema(GetTransformedDatabase(), strTable);
					}
				}
			}
			else if (ERROR_NO_MORE_ITEMS != iResult)
			{
				break;
			}
		} while (ERROR_SUCCESS == iResult);
    
		// if no more items that's okay
		if (ERROR_NO_MORE_ITEMS == iResult)
		{
			iResult = ERROR_SUCCESS;
		}
		else
		{
			CString strPrompt;
			strPrompt.Format(_T("MSI Error %d while retrieving tables from the transformed database."), iResult);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			return ERROR_FUNCTION_FAILED;
		}
	}

	// for lazy-loads we can retrieve the table transform state
	// if no lazy data load or if lazy-load failed, retrieve all data
	if (!fAllowLazyDataLoad)
	{
		POSITION pos = m_tableList.GetHeadPosition();
		while (pos)
		{
			COrcaTable *pTable = m_tableList.GetNext(pos);

			if (pTable)
				pTable->RetrieveTableData();
		}
	}

	return iResult;
}	// end of BuildTableList

///////////////////////////////////////////////////////////
// DestroyTableList
void COrcaDoc::DestroyTableList()
{
	// empty out table list
	while (!m_tableList.IsEmpty())
	{
		COrcaTable* pTable = m_tableList.RemoveHead();
		if (pTable)
			pTable->DestroyTable();
		delete pTable;
	}

	// reset the status bar
	CMainFrame* pFrame = (CMainFrame*) AfxGetMainWnd();
	if (pFrame)
	{
		pFrame->SetTableCount(0);
		pFrame->ResetStatusBar();
	}
}	// end of DestroyTableList

///////////////////////////////////////////////////////////
// LoadTable
// loads the column definitions of a table from the database
// if a shadow table exists with the same name, clobber it
// with the new data and refresh the view of this table.
COrcaTable* COrcaDoc::CreateAndLoadTable(MSIHANDLE hDatabase, CString strTable)
{
	// if we have a shadow table with the same name, use it
	bool fWasShadow = false;
	COrcaTable* pTable = FindAndRetrieveTable(strTable);
	if (pTable)
	{
		fWasShadow = true;
		ASSERT(pTable->IsShadow());
	}
	else
	{
		pTable = new COrcaTable(this);
		if (!pTable)
			return NULL;
		m_tableList.AddTail(pTable);	
	}
	ASSERT(pTable);
	pTable->LoadTableSchema(hDatabase, strTable);

	if (fWasShadow)
		UpdateAllViews(NULL, HINT_TABLE_REDEFINE, pTable);
	return pTable;
}	// end of LoadTable

///////////////////////////////////////////////////////////
// DropTable
UINT COrcaDoc::DropOrcaTable(COrcaTable* pTable)
{
	ASSERT(!TargetIsReadOnly());
	// drop the table from the database
	return pTable->DropTable(m_hDatabase);
}	// end of DropTable

///////////////////////////////////////////////////////////
// AddRow
UINT COrcaDoc::AddRow(COrcaTable* pTable, CStringList* pstrDataList)
{
	ASSERT(pTable && pstrDataList);
	if (!pTable || !pstrDataList)
		return ERROR_FUNCTION_FAILED;

	ASSERT(!TargetIsReadOnly());

	return pTable->AddRow(pstrDataList);
}	// end of AddRow

///////////////////////////////////////////////////////////
// DropRow
bool COrcaDoc::DropRow(COrcaTable* pTable, COrcaRow* pRow)
{
	ASSERT(pTable);
	if (!pTable)
		return false;
	if (TargetIsReadOnly())
		return false;

	return pTable->DropRow(pRow, true);
}	// end of DropRow

UINT COrcaDoc::WriteBinaryCellToFile(COrcaTable* pTable, COrcaRow* pRow, UINT iCol, CString strFile)
{
	UINT iResult;
	ASSERT(pRow && pTable);
	
	// get the data item we're working with
	COrcaData* pData = pRow->GetData(iCol);
	if (!pData)
		return ERROR_FUNCTION_FAILED;

	// if its null, do nothing
	if (pData->IsNull())
		return ERROR_SUCCESS;

	// setup the query
	CString strQuery;
	strQuery.Format(_T("SELECT * FROM `%s` WHERE "), pTable->Name());

	// add the key strings to queyr to do the exact look up
	strQuery += pTable->GetRowWhereClause();

	// get the one row out of the database
	CQuery queryReplace;
	PMSIHANDLE hQueryRec = pRow->GetRowQueryRecord();
	if (ERROR_SUCCESS != (iResult = queryReplace.OpenExecute(GetTargetDatabase(), hQueryRec, strQuery)))
		return iResult;	
	// we have to get that one row, or something is very wrong
	PMSIHANDLE hRec;
	if (ERROR_SUCCESS != (iResult = queryReplace.Fetch(&hRec)))
		return iResult;	
	
	// don't use iCol+1, because WriteStreamToFile already does
	iResult = WriteStreamToFile(hRec, iCol, strFile) ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;

	return iResult;
}	// end of WriteBinaryCellToFile

///////////////////////////////////////////////////////////////////////
// PersistTables - save the database in hSource to hPersist. hSource
// can be the same as hPersist. bCommit of true will call MsiDBCommit 
// after any necessary updates.
UINT COrcaDoc::PersistTables(MSIHANDLE hPersist, MSIHANDLE hSource, bool bCommit)
{
	bool bSame = false;
	UINT iResult = ERROR_SUCCESS;

	if (m_hDatabase == hPersist)
		bSame = true;

	if (!bSame)
	{
		if (ERROR_SUCCESS != MsiDatabaseMerge(hPersist, hSource, NULL))
		{
			return ERROR_FUNCTION_FAILED;
		}
		
		// copy the summaryinfo stream
		CQuery qRead;
		PMSIHANDLE hCopyRec;
		iResult = qRead.FetchOnce(hSource, 0, &hCopyRec, TEXT("SELECT `Name`, `Data` FROM `_Streams` WHERE `Name`='\005SummaryInformation'"));
		if (ERROR_SUCCESS == iResult)
		{
			CQuery qInsert;
			if ((ERROR_SUCCESS != qInsert.OpenExecute(hPersist, 0, TEXT("SELECT `Name`, `Data` FROM `_Streams` WHERE `Name`='\005SummaryInformation'"))) ||
				(ERROR_SUCCESS != qInsert.Modify(MSIMODIFY_INSERT, hCopyRec)))
			{
				return ERROR_FUNCTION_FAILED;
			}
		}
		else if (ERROR_NO_MORE_ITEMS == iResult)
		{
			// SummaryInfo stream may not exist, but this is OK if doing a "save as", because
			// we can generate one from the current summary info variables.
			if (hSource == m_hDatabase)
				iResult = ERROR_SUCCESS;
		}
	}

	// if no errors write the summary information
	if (ERROR_SUCCESS == iResult && hSource == m_hDatabase)
	{
		iResult = PersistSummary(hPersist, !bSame);
	}

	// if no errors save the database
	if (bCommit && ERROR_SUCCESS == iResult)
	{
		iResult = MsiDatabaseCommit(hPersist);
	}

	return iResult;
}	// end of PersistTables


/////////////////////////////////////////////////////////////////////
// ReadSummary
UINT COrcaDoc::ReadSummary(MSIHANDLE hSource)
{
	UINT iResult;

	// get the summary information streams
	PMSIHANDLE hSummary;
	if (ERROR_SUCCESS != (iResult = ::MsiGetSummaryInformation(hSource, NULL, 0, &hSummary)))
		return iResult;
	
	UINT iType;
	TCHAR szBuffer[1024];
	DWORD cchBuffer = 1024;

	// fill in the module summary information
	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_TITLE, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strTitle = _T("");
	else
		m_strTitle = szBuffer;

	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_SUBJECT, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strSubject = _T("");
	else
		m_strSubject = szBuffer;

	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_AUTHOR, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strAuthor = _T("");
	else
		m_strAuthor = szBuffer;

	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_KEYWORDS, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strKeywords = _T("");
	else
		m_strKeywords = szBuffer;

	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_COMMENTS, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strComments = _T("");
	else
		m_strComments = szBuffer;

	// set the platform and language
	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_TEMPLATE, &iType, 0, NULL, szBuffer, &cchBuffer);
	CString strLanguage = szBuffer;
	if (VT_LPSTR != iType)
	{
			m_strPlatform = _T("");
			m_strLanguage = _T("");
	}
	else	// type is right
	{
		int nFind = strLanguage.Find(_T(";"));
		if (nFind > -1)
		{
			m_strPlatform = strLanguage.Left(nFind);
			m_strLanguage = strLanguage.Mid(nFind + 1);
		}
		else
		{
			m_strPlatform = _T("");
			m_strLanguage = _T("");
		}
	}

	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_LASTAUTHOR, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strLastSaved = _T("");
	else
		m_strLastSaved = szBuffer;

	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_REVNUMBER, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strProductGUID = _T("");
	else
		m_strProductGUID = szBuffer;

	MsiSummaryInfoGetProperty(hSummary, PID_PAGECOUNT, &iType, &m_nSchema, NULL, szBuffer, &cchBuffer);
	if (VT_I4 != iType)
		m_nSchema = 100;

	MsiSummaryInfoGetProperty(hSummary, PID_WORDCOUNT, &iType, &m_nFilenameType, NULL, szBuffer, &cchBuffer);
	if (VT_I4 != iType)
		m_nFilenameType = 0;

	MsiSummaryInfoGetProperty(hSummary, PID_SECURITY, &iType, &m_nSecurity, NULL, szBuffer, &cchBuffer);
	if (VT_I4 != iType)
		m_nSecurity = 1;

	return iResult;
}	// end of ReadSummary

/////////////////////////////////////////////////////////////////////
// PersistSummary
UINT COrcaDoc::PersistSummary(MSIHANDLE hTarget, bool bCreate)
{
	UINT iResult;

	// get the summary information streams
	PMSIHANDLE hSummary;
	if (ERROR_SUCCESS != (iResult = ::MsiGetSummaryInformation(hTarget, NULL, MAX_SUMMARY, &hSummary)))
		return iResult;
	
	FILETIME filetime;
	DWORD cchBufDiscard = 1024;

	// fill in the module summary information
	MsiSummaryInfoSetProperty(hSummary, PID_TITLE,		VT_LPSTR, 0, NULL, m_strTitle);
	MsiSummaryInfoSetProperty(hSummary, PID_SUBJECT,	VT_LPSTR, 0, NULL, m_strSubject);
	MsiSummaryInfoSetProperty(hSummary, PID_AUTHOR,		VT_LPSTR, 0, NULL, m_strAuthor);
	MsiSummaryInfoSetProperty(hSummary, PID_KEYWORDS,	VT_LPSTR, 0, NULL, m_strKeywords);
	MsiSummaryInfoSetProperty(hSummary, PID_COMMENTS,	VT_LPSTR, 0, NULL, m_strComments);

	// set the platform and language
	CString strLanguage;
	strLanguage.Format(_T("%s;%s"), m_strPlatform, m_strLanguage);
	MsiSummaryInfoSetProperty(hSummary, PID_TEMPLATE,	VT_LPSTR, 0, NULL, strLanguage);

	// get the current username for summaryinfo stream
	DWORD cchUserName = 255;
	LPTSTR szUserName = m_strLastSaved.GetBuffer(cchUserName);
	GetUserName(szUserName, &cchUserName);
	m_strLastSaved.ReleaseBuffer();
	MsiSummaryInfoSetProperty(hSummary, PID_LASTAUTHOR, VT_LPSTR, 0, NULL, m_strLastSaved);
	MsiSummaryInfoSetProperty(hSummary, PID_REVNUMBER,	VT_LPSTR, 0, NULL, m_strProductGUID);

	// get the current time and set the creation and last saved time to that
	SYSTEMTIME sysTime;
	GetSystemTime(&sysTime);
	SystemTimeToFileTime(&sysTime, &filetime);
	if (bCreate) 
	{
		// only write these values if we are creating the MSI
		MsiSummaryInfoSetProperty(hSummary, PID_CODEPAGE,	VT_I2, 1252, NULL, NULL);
		MsiSummaryInfoSetProperty(hSummary, PID_LASTPRINTED,	VT_FILETIME, 0, &filetime, NULL);
		MsiSummaryInfoSetProperty(hSummary, PID_CREATE_DTM,		VT_FILETIME, 0, &filetime, NULL);
		MsiSummaryInfoSetProperty(hSummary, PID_APPNAME, VT_LPSTR, 0, NULL, _T("Windows Installer"));
	}

	MsiSummaryInfoSetProperty(hSummary, PID_LASTSAVE_DTM,	VT_FILETIME, 0, &filetime, NULL);

	MsiSummaryInfoSetProperty(hSummary, PID_PAGECOUNT,	VT_I4, m_nSchema, NULL, NULL);

	MsiSummaryInfoSetProperty(hSummary, PID_WORDCOUNT, VT_I4, m_nFilenameType, NULL, NULL);
	MsiSummaryInfoSetProperty(hSummary, PID_SECURITY, VT_I4, m_nSecurity, NULL, NULL);

	iResult = ::MsiSummaryInfoPersist(hSummary);

	return iResult;
}	// end of PersistSummary

/////////////////////////////////////////////////////////////////////
// OnSummaryInformation
void COrcaDoc::OnSummaryInformation() 
{
	CSummaryD dlg;

	dlg.m_strTitle = m_strTitle;
	dlg.m_strSubject = m_strSubject;
	dlg.m_strAuthor = m_strAuthor;
	dlg.m_strKeywords = m_strKeywords;
	dlg.m_strComments = m_strComments;
	dlg.m_strPlatform = m_strPlatform;
	dlg.m_strLanguages = m_strLanguage;
	dlg.m_strProductID = m_strProductGUID;
	dlg.m_nSchema = m_nSchema;
	dlg.m_nSecurity = m_nSecurity;
	dlg.m_iFilenames = ((m_nFilenameType & msidbSumInfoSourceTypeSFN) != 0) ? 0 : 1;
	dlg.m_bAdmin = (m_nFilenameType & msidbSumInfoSourceTypeAdminImage) != 0;
	dlg.m_bCompressed = (m_nFilenameType & msidbSumInfoSourceTypeCompressed) != 0;
	dlg.m_bReadOnly = DoesTransformGetEdit() || TargetIsReadOnly();
        
	if ((IDOK == dlg.DoModal()) && !m_bReadOnly && !DoesTransformGetEdit())
	{
		m_strTitle = dlg.m_strTitle;
		m_strSubject = dlg.m_strSubject;
		m_strAuthor = dlg.m_strAuthor;
		m_strKeywords = dlg.m_strKeywords;
		m_strComments = dlg.m_strComments;
		m_strPlatform = dlg.m_strPlatform;
		m_strLanguage = dlg.m_strLanguages;
		m_strProductGUID = dlg.m_strProductID;
		m_nSchema = dlg.m_nSchema;
		m_nSecurity = dlg.m_nSecurity;
		m_nFilenameType = (dlg.m_bAdmin ? msidbSumInfoSourceTypeAdminImage : 0) |
			(dlg.m_bCompressed ? msidbSumInfoSourceTypeCompressed : 0) |
			((dlg.m_iFilenames == 1) ? 0 : msidbSumInfoSourceTypeSFN); 

		// don't save the create-only values
		PersistSummary(m_hDatabase, false);
		SetModifiedFlag(TRUE);
	}
}	// end of OnSummaryInformation


/////////////////////////////////////////////////////////////////////
// OnMergeModules
void COrcaDoc::OnMergeMod() 
{
	CMergeD dlg;
	CStringList lstDir;
	dlg.m_plistDirectory = &lstDir;
	{
		COrcaTable* pTable = FindAndRetrieveTable(TEXT("Directory"));
		if (pTable)
		{
			POSITION pos = pTable->GetRowHeadPosition();
			while (pos)
			{
				const COrcaRow *pRow = pTable->GetNextRow(pos);
				if (pRow)
				{
					COrcaData *pData = pRow->GetData(0);
					if (pData)
						lstDir.AddTail(pData->GetString());
				}
			}
		}
	}

	CStringList lstFeature;
	dlg.m_plistFeature = &lstFeature;
	{
		COrcaTable* pTable = FindAndRetrieveTable(TEXT("Feature"));
		if (pTable)
		{
			POSITION pos = pTable->GetRowHeadPosition();
			while (pos)
			{
				const COrcaRow *pRow = pTable->GetNextRow(pos);
				if (pRow)
				{
					COrcaData *pData = pRow->GetData(0);
					if (pData)
						lstFeature.AddTail(pData->GetString());
				}
			}
		}
	}
	dlg.m_strModule = m_strStoredModuleName;
	dlg.m_strLanguage = m_strStoredModuleLanguage;
	dlg.m_bConfigureModule = (1 == AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("AlwaysConfigure"), 0));

	if ((IDOK == dlg.DoModal()) && !TargetIsReadOnly())
	{
		if (dlg.m_strModule.IsEmpty())
			return;

		m_strStoredModuleName = dlg.m_strModule;
		m_strStoredModuleLanguage = dlg.m_strLanguage;
		CConfigMsmD dlgConfig;
		CMsmConfigCallback CallbackObj;
		if (dlg.m_bConfigureModule)
		{
			// need a wait cursr
			CWaitCursor cursor;
			
			// throw the configurable dialog if necessary
			dlgConfig.m_pDoc = this;
			dlgConfig.m_strModule = dlg.m_strModule;
			dlgConfig.m_pCallback = &CallbackObj;

			dlgConfig.m_iLanguage = _ttoi(dlg.m_strLanguage);
			INT_PTR iResult = IDOK;
			switch (iResult = dlgConfig.DoModal())
			{
			case -2:
				// module couldn't be opened
				AfxMessageBox(_T("The specified module could not be opened. Verify that the file exists and is accessible."), MB_OK);
				break;
			case -3:
				// unsupported language
				AfxMessageBox(_T("The specified language is not supported by the module."), MB_OK);
				break;
			case -4:
				// general failure/malformed module
				AfxMessageBox(_T("The module could not be configured. The specified file may not be a valid module."), MB_OK);
				break;
			default:
				break;
				// success and other failures, no message box
			}
			if (IDOK != iResult)
				return;
		}

		{
			// need a wait cursr
			CWaitCursor cursor;
			
			// when a module is merged, we have to have a temp database to apply the module to.
			// This allows Orca to "rollback" the merge if there are conflicts or something goes
			// wrong during the merge itself
			// get a temp path
			DWORD cchTempPath = MAX_PATH;
			TCHAR szTempPath[MAX_PATH];
			::GetTempPath(cchTempPath, szTempPath);

			// get a temp filename
			CString strTempDatabase;
			TCHAR *szTempFilename = strTempDatabase.GetBuffer(MAX_PATH);
			UINT iResult = ::GetTempFileName(szTempPath, _T("ODB"), 0, szTempFilename);
			strTempDatabase.ReleaseBuffer();

			PMSIHANDLE hModuleDB;
			if (ERROR_SUCCESS != MsiOpenDatabase(szTempFilename, MSIDBOPEN_CREATEDIRECT, &hModuleDB))
			{
				AfxMessageBox(_T("Orca was unable to create a database for merging the module. Ensure that the TEMP directory exists and is writable."), MB_ICONSTOP);
				return;
			}
			if (ERROR_SUCCESS != MsiDatabaseMerge(hModuleDB, GetTargetDatabase(), NULL))
			{
				AfxMessageBox(_T("Orca was unable to merge the module."), MB_ICONSTOP);
				MsiCloseHandle(hModuleDB);
				hModuleDB=0;
				DeleteFile(strTempDatabase);
				return;
			}

			// copy the summary information stream to the new database
			{
				CQuery qRead;
				PMSIHANDLE hCopyRec;
				if (ERROR_SUCCESS == qRead.FetchOnce(GetTargetDatabase(), 0, &hCopyRec, TEXT("SELECT `Name`, `Data` FROM `_Streams` WHERE `Name`='\005SummaryInformation'")))
				{
					CQuery qInsert;
					if (ERROR_SUCCESS == qInsert.OpenExecute(hModuleDB, 0, TEXT("SELECT `Name`, `Data` FROM `_Streams` WHERE `Name`='\005SummaryInformation'")))
						qInsert.Modify(MSIMODIFY_INSERT, hCopyRec);
				}
			}
			
			CString strHandleString;
			strHandleString.Format(TEXT("#%d"), hModuleDB);

			// can't watch the merge log on Win9X due to lack of pipe support.
			OSVERSIONINFOA osviVersion;
			bool g_fWin9X = false;
			osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
			::GetVersionExA(&osviVersion); // fails only if size set wrong
			if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
				g_fWin9X = true;

			// if the users profile says to display the log output, the ExecuteMerge call comes from
			// a thread inside the dialog with the log file redirected to a pipe. Otherwise the dialog
			// is not created and ExecuteMerge is called directly.
			if (!g_fWin9X && 1 == AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("ShowMergeLog"), 0))
			{
				CMsmResD ResultsDialog;
				ResultsDialog.strHandleString = strHandleString;
				ResultsDialog.m_strModule = dlg.m_strModule;
				ResultsDialog.m_strFeature = dlg.m_strMainFeature +	dlg.m_strAddFeature;
				ResultsDialog.m_strLanguage = dlg.m_strLanguage;
				ResultsDialog.m_strRootDir = dlg.m_strRootDir;
				ResultsDialog.m_strCABPath = dlg.m_bExtractCAB ? dlg.m_strCABPath : "";
				ResultsDialog.m_strFilePath = dlg.m_bExtractFiles ? dlg.m_strFilePath : "";
				ResultsDialog.m_strImagePath = dlg.m_bExtractImage ? dlg.m_strImagePath : "";
				ResultsDialog.m_fLFN = (dlg.m_bLFN != 0);
				ResultsDialog.CallbackObj = &CallbackObj;
				if (IDOK == ResultsDialog.DoModal())
					iResult = ResultsDialog.m_hRes;
				else
					iResult = ERROR_FUNCTION_FAILED;
			}
			else
			{
				CMsmFailD FailDialog;
				iResult = ::ExecuteMerge(
					(LPMERGEDISPLAY)NULL,        // no log callback
					strHandleString,             // db handle as string
					dlg.m_strModule,             // module path
					dlg.m_strMainFeature +       // primary feature 
						dlg.m_strAddFeature,     //   + additional features
					_ttoi(dlg.m_strLanguage),    // language
					dlg.m_strRootDir,            // redirection directory
					dlg.m_bExtractCAB ? 
						dlg.m_strCABPath : "",   // extract CAB path
					dlg.m_bExtractFiles ? 
						dlg.m_strFilePath : "",  // extract file path
					dlg.m_bExtractImage ? 
						dlg.m_strImagePath : "", // extract image path
					NULL,                        // no log file path
					false,						 // log option is irrelevant with no log
					dlg.m_bLFN != 0,             // long file names
					&CallbackObj,                // callback interface,
					&FailDialog.m_piErrors,      // errors collection
					commitNo);                   // don't auto-save
				if (iResult != S_OK)
					iResult = (IDOK == FailDialog.DoModal()) ? S_OK : E_FAIL;
			}

			if (S_OK == iResult || S_FALSE == iResult)
			{
				// need a wait cursr
				CWaitCursor cursor;
				
				// get the name of the current table
				CString strTableName;
				CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
				if (pFrame) 
				{
					COrcaTable *pTable = pFrame->GetCurrentTable();
					if (pTable)
						strTableName = pTable->Name();
				}
				
				// clear anything existing
				UpdateAllViews(NULL, HINT_CLEAR_VALIDATION_ERRORS, NULL);
				((CMainFrame*)AfxGetMainWnd())->HideValPane();
				UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
				UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);

				// drop all of the tables. If the merge changed any existing rows,
				// we'll get a merge conflict if we try to merge without dropping the table
				// first
				POSITION pos = m_tableList.GetHeadPosition();
				while (pos)
				{
					COrcaTable *pTable = m_tableList.GetNext(pos);
					if (pTable)
						pTable->DropTable(GetTargetDatabase());
				}

				DestroyTableList();
				
				if (ERROR_SUCCESS != MsiDatabaseMerge(GetTargetDatabase(), hModuleDB, NULL))
				{
					// this is very, very bad.
					AfxMessageBox(_T("Orca was unable to merge the module."), MB_ICONSTOP);
					MsiCloseHandle(hModuleDB);
					hModuleDB=0;
					DeleteFile(strTempDatabase);
					return;
				}

				BuildTableList(/*fAllowLazyLoad=*/false);
				UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);
				SetModifiedFlag(TRUE);

				if (!strTableName.IsEmpty())
				{
					// since we're changing to this table, we can call FindAndRetrieve without
					// sacrificing performance (and we don't need to know what DB is active)
					COrcaTable *pTable = FindAndRetrieveTable(strTableName);
					if (pTable)
						UpdateAllViews(NULL, HINT_CHANGE_TABLE, pTable);
				}			
			}
			
			::MsiCloseHandle(hModuleDB);
			DeleteFile(strTempDatabase);
		}
	}
	
}	// end of OnMergeMod

/////////////////////////////////////////////////////////////////////
// OnSummaryInformation
void COrcaDoc::OnTransformProperties() 
{
	CTransformPropDlg dlg;
	dlg.m_bValAddExistingRow   = (m_dwTransformErrFlags & MSITRANSFORM_ERROR_ADDEXISTINGROW) ? TRUE : FALSE;
	dlg.m_bValAddExistingTable = (m_dwTransformErrFlags & MSITRANSFORM_ERROR_ADDEXISTINGTABLE) ? TRUE : FALSE;
	dlg.m_bValDelMissingRow    = (m_dwTransformErrFlags & MSITRANSFORM_ERROR_DELMISSINGROW) ? TRUE : FALSE;
	dlg.m_bValDelMissingTable  = (m_dwTransformErrFlags & MSITRANSFORM_ERROR_DELMISSINGTABLE) ? TRUE : FALSE;
	dlg.m_bValUpdateMissingRow = (m_dwTransformErrFlags & MSITRANSFORM_ERROR_UPDATEMISSINGROW) ? TRUE : FALSE;
	dlg.m_bValChangeCodepage   = (m_dwTransformErrFlags & MSITRANSFORM_ERROR_CHANGECODEPAGE) ? TRUE : FALSE;

	dlg.m_bValLanguage     = (m_dwTransformValFlags & MSITRANSFORM_VALIDATE_LANGUAGE) ? TRUE : FALSE;
	dlg.m_bValProductCode  = (m_dwTransformValFlags & MSITRANSFORM_VALIDATE_PRODUCT) ? TRUE : FALSE;
	dlg.m_bValUpgradeCode  = (m_dwTransformValFlags & MSITRANSFORM_VALIDATE_UPGRADECODE) ? TRUE : FALSE;

	if (m_dwTransformValFlags & MSITRANSFORM_VALIDATE_MAJORVERSION)
		dlg.m_iVersionCheck = 0;
	else if (m_dwTransformValFlags & MSITRANSFORM_VALIDATE_MINORVERSION)
		dlg.m_iVersionCheck = 1;
	else if (m_dwTransformValFlags & MSITRANSFORM_VALIDATE_UPDATEVERSION)
		dlg.m_iVersionCheck = 2;
		
	dlg.m_bValGreaterVersion = (m_dwTransformValFlags & (MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION | MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION)) ? TRUE : FALSE;
	dlg.m_bValLowerVersion = (m_dwTransformValFlags & (MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION | MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION)) ? TRUE : FALSE;
	dlg.m_bValEqualVersion = (m_dwTransformValFlags & (MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION | MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION | MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION)) ? TRUE : FALSE;

	if ((IDOK == dlg.DoModal()) && !m_bTransformReadOnly)
	{
		m_dwTransformErrFlags = 0;
		if (dlg.m_bValAddExistingRow)
			m_dwTransformErrFlags |= MSITRANSFORM_ERROR_ADDEXISTINGROW;
		if (dlg.m_bValAddExistingTable)
			m_dwTransformErrFlags |= MSITRANSFORM_ERROR_ADDEXISTINGTABLE;
		if (dlg.m_bValDelMissingRow)
			m_dwTransformErrFlags |= MSITRANSFORM_ERROR_DELMISSINGROW;
		if (dlg.m_bValDelMissingTable)
			m_dwTransformErrFlags |= MSITRANSFORM_ERROR_DELMISSINGTABLE;
		if (dlg.m_bValUpdateMissingRow)
			m_dwTransformErrFlags |= MSITRANSFORM_ERROR_UPDATEMISSINGROW;
		if (dlg.m_bValChangeCodepage)
			m_dwTransformErrFlags |= MSITRANSFORM_ERROR_CHANGECODEPAGE;

		m_dwTransformValFlags = 0;
		if (dlg.m_bValLanguage)
			m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_LANGUAGE;
		if (dlg.m_bValProductCode)
			m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_PRODUCT;
		if (dlg.m_bValUpgradeCode)
			m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_UPGRADECODE;

		if (dlg.m_bValGreaterVersion || dlg.m_bValLowerVersion || dlg.m_bValEqualVersion)
		{
			switch (dlg.m_iVersionCheck)
			{
			case 0: 
				m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_MAJORVERSION;
				break;
			case 1:
				m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_MINORVERSION;
				break;
			case 2:
				m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_UPDATEVERSION;
				break;
			default:
				break;
			}
		}
		
		if (dlg.m_bValGreaterVersion)
		{
			if (dlg.m_bValEqualVersion)
				m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION;
			else
				m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION;
		}		
		else if (dlg.m_bValLowerVersion)
		{
 			if (dlg.m_bValEqualVersion)
				m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION;
			else
				m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION;
		}
		else if (dlg.m_bValEqualVersion)
			m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION;
	}
}	// end of OnTransformProperties

/////////////////////////////////////////////////////////////////////
// OnValidator
void COrcaDoc::OnValidator() 
{
	bool bSummWarned = false;
	CValD dlg;
	dlg.m_hDatabase = GetTargetDatabase();
	dlg.m_strICE = m_strICEsToRun;
	dlg.m_strEvaluation = m_strCUBFile;
	dlg.m_bShowInfo = m_bShowValInfo;

	dlg.DoModal();
	m_strICEsToRun = dlg.m_strICE;
	m_strCUBFile = dlg.m_strEvaluation;
	m_bShowValInfo = (dlg.m_bShowInfo ? true : false);
	CWaitCursor curWait;
	// clear out the old errors
	POSITION pos = m_tableList.GetHeadPosition();
	while (pos)
	{
		POSITION pos2 = pos;
		COrcaTable *pTable = m_tableList.GetNext(pos);
		if (pTable->IsShadow())
		{
			UpdateAllViews(NULL, HINT_DROP_TABLE, pTable);
			m_tableList.RemoveAt(pos2);
			delete pTable;
		}
		else
		{
			pTable->ClearErrors();
		}

	}
	UpdateAllViews(NULL, HINT_CLEAR_VALIDATION_ERRORS, NULL);

	// if there are any results
	if (dlg.m_pIResults)
	{
		RESULTTYPES tResult;			// type of result
		LPOLESTR rgErrorInfo[3];	// array to hold error information
		CString strICE;				// ice causing error
		CString strDescription;		// description of error
		CString strURL;				// url to help with error
		LPOLESTR rgErrorLoc[2];		// array to hold error location
		CString strColumn;			// column causing error
		CString strTable;				// table causing error
		IEnumString* pIErrors;

		// loop through all the results
		ULONG cFetched;
		IEvalResult* pIResult;
		for (ULONG cResults = 0; cResults < dlg.m_cResults; cResults++)
		{
			// get the next result
			dlg.m_pIResults->Next(1, &pIResult, &cFetched);
			ASSERT(1 == cFetched);	// insure we fetched one result

			// determine result type
			pIResult->GetResultType((UINT*)&tResult);

			// get the string of errors
			pIResult->GetResult(&pIErrors);

			// get the ICE and Description and URL
			pIErrors->Next(3, rgErrorInfo, &cFetched);

			// if we cannot fetch a full error result
			if (cFetched < 2)
			{
				continue;
			}

#ifndef _UNICODE
			// convert the ice string
			int cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, rgErrorInfo[0], -1, NULL, 0, NULL, NULL);
			::WideCharToMultiByte(CP_ACP, 0, rgErrorInfo[0], -1, strICE.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
			strICE.ReleaseBuffer();
			// now convert the description string
			cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, rgErrorInfo[1], -1, NULL, 0, NULL, NULL);
			::WideCharToMultiByte(CP_ACP, 0, rgErrorInfo[1], -1, strDescription.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
			strDescription.ReleaseBuffer();
#else
			strICE = rgErrorInfo[0];
			strDescription = rgErrorInfo[1];
#endif

			// if at least the ICE and description are valid, we can add something
			// to the pane
			if (2 == cFetched)
			{
				// anything other than an info message gets logged in the pane
				if (tResult != ieInfo)
				{
					CValidationError pError(&strICE, tResult, &strDescription, NULL, NULL, 0);
					UpdateAllViews(NULL, HINT_ADD_VALIDATION_ERROR, &pError);
				}
				continue;
			}

#ifndef _UNICODE
			// now convert the URL string
			cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, rgErrorInfo[2], -1, NULL, 0, NULL, NULL);
			::WideCharToMultiByte(CP_ACP, 0, rgErrorInfo[2], -1, strURL.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
			strURL.ReleaseBuffer();
#else
			strURL = rgErrorInfo[2];
#endif

			// if this is an error message or warning message
			if (ieError == tResult || ieWarning == tResult)
			{
				TRACE(_T("-- Error, ICE: %s, Desc: %s, URL: %s\n"), strICE, strDescription, strURL);

				// get the Table and Column
				pIErrors->Next(2, rgErrorLoc, &cFetched);

				// if we fetched table and column
				if (2 == cFetched)
				{
#ifndef _UNICODE
					// convert the table string
					cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, rgErrorLoc[0], -1, NULL, 0, NULL, NULL);
					::WideCharToMultiByte(CP_ACP, 0, rgErrorLoc[0], -1, strTable.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
					strTable.ReleaseBuffer();
					// convert the column string
					cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, rgErrorLoc[1], -1, NULL, 0, NULL, NULL);
					::WideCharToMultiByte(CP_ACP, 0, rgErrorLoc[1], -1, strColumn.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
					strColumn.ReleaseBuffer();
#else
					strTable= rgErrorLoc[0];
					strColumn = rgErrorLoc[1];
#endif
					// if the table name is an empty string, there is no point in adding a table to the DB
					// with no name. The UI for that is just confusing.
					if (strTable.IsEmpty())
						continue;

					CStringArray strArray;
					BOOL bCheck = FALSE;	// assume we won't check

					// get the table, shadow tables OK, split tables must match current edit
					// state.
					COrcaTable* pTable = FindAndRetrieveTable(strTable);
					if (!pTable)
					{
						// if the table does not exist, create a shadow table to hold this error
						pTable = new COrcaTable(this);
						pTable->ShadowTable(strTable);

						// a table is normally not added to the list until it is first fetched 
						m_tableList.AddTail(pTable);	
						UpdateAllViews(NULL, HINT_ADD_TABLE_QUIET, pTable);
					}
					
					if (pTable->IsShadow())
					{
						// add the ICE and description to this table's list of errors
						pTable->SetError(iTableError);
						pTable->AddError(strICE, strDescription, strURL);					
					
						// add to the validation pane
						CValidationError pError(&strICE, tResult, &strDescription, pTable, NULL, 0);
						UpdateAllViews(NULL, HINT_ADD_VALIDATION_ERROR, &pError);
					}
					else
					{
						// get the number of primary keys in table
						UINT cKeys = pTable->GetKeyCount();
						LPOLESTR szErrorRow;
						strArray.SetSize(cKeys);

						bCheck = TRUE;	// now assume we will do a check

						// get the strings defining the error row into the array
						CString strBuffer;
						for (UINT j = 0; j < cKeys; j++)
						{
							pIErrors->Next(1, &szErrorRow, &cFetched);
							if (1 != cFetched)
							{
								bCheck = FALSE;	// didn't get all the keys needed to find this error
								break;
							}

#ifndef _UNICODE
							// set the array
							cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, szErrorRow, -1, NULL, 0, NULL, NULL);
							::WideCharToMultiByte(CP_ACP, 0, szErrorRow, -1, strBuffer.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
							strBuffer.ReleaseBuffer();
							strArray.SetAt(j, strBuffer);
#else
							strArray.SetAt(j, szErrorRow);
#endif
						}
					}

					if (bCheck)
					{
						// get the data cell that caused the error
						COrcaRow* pRow = pTable->FindRowByKeys(strArray);
						COrcaData* pData = NULL;
						int iColumn = pTable->FindColumnNumberByName(strColumn);

						if (pRow)
							pData = pRow->GetData(iColumn);

						if (pRow && pData)
						{
							pTable->SetContainsValidationErrors(true);
							pData->AddError(tResult, strICE, strDescription, strURL);
							switch (tResult)
							{
							case ieError:
								// always flag errors
								pData->SetError(iDataError);
								break;
							case ieWarning:
								// only flag as warning if no errors
								if (pData->GetError() != iDataError)
									pData->SetError(iDataWarning);
								break;
							default:
								ASSERT(FALSE);
							}

							// add to the validation pane
							CValidationError pError(&strICE, tResult, &strDescription, pTable, pRow, iColumn);
							UpdateAllViews(NULL, HINT_ADD_VALIDATION_ERROR, &pError);
						}
						else	// ICE didn't give a good row location
						{
							CString strPrompt;
							strPrompt.Format(_T("%s failed to give a valid row in the database.\nDesc: %s\nURL: %s\nColumn: %s\nLocation: "), strICE, strDescription, strURL, strColumn);
							for (int i = 0; i < strArray.GetSize(); i++)
							{
								strPrompt += strArray.GetAt(i);

								if (i + 1 < strArray.GetSize())
									strPrompt += _T(", ");
							}
							AfxMessageBox(strPrompt, MB_ICONSTOP);
						}
					}
				}
				else if (1 == cFetched)	// fetched only the table name
				{
#ifndef _UNICODE
					// convert the column string
					cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, rgErrorLoc[0], -1, NULL, 0, NULL, NULL);
					::WideCharToMultiByte(CP_ACP, 0, rgErrorLoc[0], -1, strTable.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
					strColumn.ReleaseBuffer();
#else
					strTable= rgErrorLoc[0];
#endif
					// if the table name is an empty string, there is no point in adding a table to the DB
					// with no name. The UI for that is just confusing.
					if (strTable.IsEmpty())
						continue;

					// get the table. Shadow tables OK, split tables must match current state
					COrcaTable* pTable = FindTable(strTable, DoesTransformGetEdit() ? odlSplitTransformed : odlSplitOriginal);
					if (!pTable)
					{
						// if the table does not exist, create a shadow table to hold this error
						pTable = new COrcaTable(this);
						pTable->ShadowTable(strTable);

						// a table is normally not added to the list until it is first fetched 
						m_tableList.AddTail(pTable);	
						UpdateAllViews(NULL, HINT_ADD_TABLE_QUIET, pTable);
					}
					// add the ICE and description to this table's list of errors
					pTable->SetError(iTableError);
					pTable->AddError(strICE, strDescription, strURL);				 

					// and to the validation pane
					CValidationError pError(&strICE, tResult, &strDescription, pTable, NULL, 0);
					UpdateAllViews(NULL, HINT_ADD_VALIDATION_ERROR, &pError);
				}
				else	// didn't get a full location
				{
					CValidationError pError(&strICE, tResult, &strDescription, NULL, NULL, 0);
					UpdateAllViews(NULL, HINT_ADD_VALIDATION_ERROR, &pError);
					TRACE(_T("Could not locate the exact position of the error.\n"));
				}
			}
			else if (ieInfo != tResult)
			{
				// anything other than an info message gets logged in the pane
				CValidationError pError(&strICE, tResult, &strDescription, NULL, NULL, 0);
				UpdateAllViews(NULL, HINT_ADD_VALIDATION_ERROR, &pError);
			}
		}

		// just have the views refresh
		((CMainFrame*)AfxGetMainWnd())->ShowValPane();
		UpdateAllViews(NULL, HINT_REDRAW_ALL);
	}
	else
	{
		((CMainFrame*)AfxGetMainWnd())->HideValPane();
	}

}	// end of OnValidator

/////////////////////////////////////////////////////////////////////////
// fills the provided new list with a list of all tables in the target 
// database. Shadow tables are optional.
bool COrcaDoc::FillTableList(CStringList *pslNewList, bool fShadow, bool fTargetOnly) const
{
	ASSERT(pslNewList != NULL);
	ASSERT(fTargetOnly); // don't support getting list from both places yet.

	pslNewList->RemoveAll();

	// add all of the tables currently loaded to the list
	POSITION pos = m_tableList.GetHeadPosition();
	while (pos)
	{
		COrcaTable *pTable = m_tableList.GetNext(pos);
		if (!pTable)
			continue;

		// don't add shadow tables unless asked
		if (!fShadow && pTable->IsShadow()) 
			continue;

		// don't add split source tables from the other database
		if (fTargetOnly && pTable->IsSplitSource() && pTable->GetSplitSource() == (DoesTransformGetEdit() ? odlSplitOriginal : odlSplitTransformed))
			continue;

		// don't add tables that don't actually exist in this database
		if(fTargetOnly && pTable->IsTransformed() == (DoesTransformGetEdit() ? iTransformDrop : iTransformAdd))
			continue;

		pslNewList->AddTail(pTable->Name());
	}

	return true;
}


void COrcaDoc::OnUpdateTablesImport(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(!TargetIsReadOnly() && m_eiType != iDocNone);	
}

void COrcaDoc::OnTablesImport() 
{
	ASSERT(!TargetIsReadOnly());
	CImportDlg ImportD;
	
	// set the import directory
	ImportD.m_strImportDir = ((CMainFrame *)::AfxGetMainWnd())->m_strExportDir;
	ImportD.m_hFinalDB = GetTargetDatabase();

	switch (ImportD.DoModal())
	{
		case IDOK:
		{
			CString strTable;
			while (!ImportD.m_lstRefreshTables.IsEmpty())
			{
				strTable = ImportD.m_lstRefreshTables.RemoveHead();
				RefreshTableAfterImport(strTable);
			}

			while (!ImportD.m_lstNewTables.IsEmpty())
			{
				strTable = ImportD.m_lstNewTables.RemoveHead();
				CreateAndLoadNewlyAddedTable(strTable);
			}
			
			// mark document as dirty
			SetModifiedFlag(TRUE);

			// retrieve the import directory
			((CMainFrame *)::AfxGetMainWnd())->m_strExportDir = ImportD.m_strImportDir;
			break;
		}
		case IDABORT:
		{
			// if the import failed for some reason, its impossible to know what kind of state
			// the target database is in. In order not to get the UI out of sync with the 
			// actual database state, everything needs to be destroyed and reloaded.

			// send hints to all the windows to flush out any references to existing objects
			// so they can be destroyed.
			UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
			UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);

			// destroy all of the tables
			DestroyTableList();	

			// rebuild the table list. Only allow lazy-loading of no transform is active.
			BuildTableList(/*fAllowLazyLoad=*/DoesTransformGetEdit());
			UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);

			break;
		}
		default:
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////////////////
// What differentiates a refresh/replace after import from an add after import is the
// posibility that a split table already exists for this table name or that the existing
// shared table has extra columns that are no longer necessary. This function just
// destroys the appropriate table object and then calls the Create function, which does
// all of the fancy schema logic.
void COrcaDoc::RefreshTableAfterImport(CString strTable)
{
	COrcaTable *pTable;

	// because we are replacing an existing database in the table, there are several possibilities:
	// 1) a shared table holds the data and the schema is compatible
	// 2) a shared table holds the data and the schema is not compatible
	// 3) a pair of split tables holds the data and the schema is 

	// check if the table already exists.
	if (NULL != (pTable = FindTable(strTable, DoesTransformGetEdit() ? odlSplitTransformed : odlSplitOriginal))) 
	{
		// table already exists. check if its a single source table
		if (pTable->IsSplitSource())
		{
			// if there is a split table, we simply find the source from this table and 
			// drop it. Must update the views before yanking the data
			//!!future: We should check the schema to see if its exactly the same or is a
			//!!future: superset. If so, we can re-use the object, preserving settings
			POSITION pos = m_tableList.Find(pTable);
			UpdateAllViews(NULL, HINT_DROP_TABLE, pTable);
			m_tableList.RemoveAt(pos);
			pTable->DestroyTable();
			delete pTable;

			// need to find the opposing split table and mark it as non-split
			pTable = FindTable(strTable, odlSplitOriginal);
			ASSERT(pTable);
			if (pTable)
				pTable->SetSplitSource(odlNotSplit);

			// CreateAndLoadNewlyAddedTable will re-split the table if necessary based
			// on schema.
			CreateAndLoadNewlyAddedTable(strTable);
		}
		else
		{
			bool fExact = false;
			// the object must have exactly the same schema as the new table or a schema 
			// reload is necessary
			//!!future: actually, if its not exact but compatible, for perf we can just add
			//!!future: the added column information and then do a UI reload
			if (DoesTransformGetEdit() && pTable->IsSchemaDifferent(GetTargetDatabase(), /*fStrict=*/false, fExact))
			{
				CreateAndLoadNewlyAddedTable(strTable);
			}
			else if (!fExact)
			{
				UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
				pTable->DestroyTable();
				pTable->LoadTableSchema(GetOriginalDatabase(), strTable);
				pTable->LoadTableSchema(GetTransformedDatabase(), strTable);
				UpdateAllViews(NULL, HINT_CHANGE_TABLE, pTable);
			}
			else
			{
				pTable->EmptyTable();
			}
		}
	}
	else
	{
		// UI doesn't already exist. Because this is an import refresh, this should never happen
		ASSERT(0);
	}
}

///////////////////////////////////////////////////////////////////////
// searches for a table by name. Returns table if found, NULL if not.
// If odlLocation is odlSplitXXXX, the table must lie in that database
// (as that split or as non-split). If odlLocation is odlNotSplit,
// the table must not be split
COrcaTable * COrcaDoc::FindTable(const CString strTable, odlOrcaDataLocation odlLocation) const
{
	COrcaTable* pTable;
	POSITION pos = m_tableList.GetHeadPosition();
	while (pos)
	{
		pTable = m_tableList.GetNext(pos);
		if (!pTable)
			continue;

		if (pTable->Name() == strTable)
		{
			// if table is not split, return it
			if (!pTable->IsSplitSource())
				return pTable;

			// otherwise it must match the type we are requesting
			if (odlLocation == pTable->GetSplitSource())
				return pTable;
		}
	}
	return NULL;
}

///////////////////////////////////////////////////////////
// FindAndRetrieveTable - finds a specific table and loads
// both schema and data into memory
COrcaTable* COrcaDoc::FindAndRetrieveTable(CString strTable)
{
	COrcaTable* pTable = FindTable(strTable, DoesTransformGetEdit() ? odlSplitTransformed : odlSplitOriginal);

	if (pTable != NULL)	
	{
		// if the table is not retrieved, get it
		pTable->RetrieveTableData();
	}

	return pTable;
}	// end of FindAndRetrieveTable


bool COrcaDoc::WriteStreamToFile(MSIHANDLE hRec, const int iCol, CString &strFilename)
{
	CString strPath;

	// 
	if (strFilename.IsEmpty()) 
	{
		// get a temp path
		::GetTempPath(MAX_PATH, strPath.GetBuffer(MAX_PATH));
		strPath.ReleaseBuffer();
		::GetTempFileName(strPath, _T("ORC"), 0, strFilename.GetBuffer(MAX_PATH));
		strFilename.ReleaseBuffer();
	}

	// allocate the buffer to hold data
	DWORD cchBuffer;
	char pszBuffer[1024];

	// create output file
	HANDLE hOutputFile;
	hOutputFile = ::CreateFile(strFilename, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	// if there is a file
	if (INVALID_HANDLE_VALUE != hOutputFile)
	{
		// write to a buffer file
		DWORD cchWritten;

		cchBuffer = 1024;
		if(ERROR_SUCCESS == MsiRecordReadStream(hRec, iCol + 1, pszBuffer, &cchBuffer))
		{
			while (cchBuffer)
			{
				WriteFile(hOutputFile, pszBuffer, cchBuffer, &cchWritten, NULL);
				ASSERT(cchWritten == cchBuffer);
				cchBuffer = 1024;					
				MsiRecordReadStream(hRec, iCol + 1, pszBuffer, &cchBuffer);
			}
			CloseHandle(hOutputFile);
		}
		else
		{
			CloseHandle(hOutputFile);
			return false;
		}
	}
	else
		return false;

	return true;
}

void COrcaDoc::OnNewTransform() 
{
	NewTransform(/*fSetTitle=*/true);
}

void COrcaDoc::NewTransform(bool fSetTitle) 
{
	CWaitCursor cursor;
	TCHAR *szTempFilename;

	// when a transform is applied, we have to have a temp database to apply the transform to.
	// This allows Orca to selectively apply changes to the transform, database, or both.
	// it also allows us to get old values out. 
	// get a temp path
	DWORD cchTempPath = MAX_PATH;
	TCHAR szTempPath[MAX_PATH];
	if (0 == ::GetTempPath(cchTempPath, szTempPath))
	{
		 CString strPrompt;
		 strPrompt.Format(_T("Error %d while retrieving temporary file path."), GetLastError());
		 AfxMessageBox(strPrompt, MB_ICONSTOP);
		 return;
	}

 	m_strTransformFile = TEXT("");

	// get a temp filename
	szTempFilename = m_strTransformTempDB.GetBuffer(MAX_PATH);
	UINT iResult = 0;
	if (0 == ::GetTempFileName(szTempPath, _T("ODB"), 0, szTempFilename))
	{
		CString strPrompt;
		strPrompt.Format(_T("Error %d while retrieving temporary file name."), GetLastError());
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		return;
	}

	m_strTransformTempDB.ReleaseBuffer();
	if (ERROR_SUCCESS != (iResult = MsiOpenDatabase(szTempFilename, MSIDBOPEN_CREATE, &m_hTransformDB)))
	{
		CString strPrompt;
		strPrompt.Format(_T("Orca was unable to create a new transform. Ensure that the TEMP directory exists and is writable. (MSI Error %d)"), iResult);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		return;
	}


	if (ERROR_SUCCESS != (iResult = MsiDatabaseMerge(m_hTransformDB, m_hDatabase, NULL)))
	{
		CString strPrompt;
		strPrompt.Format(_T("Orca was unable to create a new transform. (MSI Error %d)"), iResult);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		CloseTransform();
		return;
	}

	// copy the summaryinfo stream, or validation will fail
	CQuery qRead;
	DWORD dwResult = 0;
	PMSIHANDLE hCopyRec;
	dwResult = qRead.FetchOnce(m_hDatabase, 0, &hCopyRec, TEXT("SELECT `Name`, `Data` FROM `_Streams` WHERE `Name`='\005SummaryInformation'"));
	if (ERROR_SUCCESS == dwResult)
	{
		CQuery qInsert;
		if ((ERROR_SUCCESS != (iResult = qInsert.OpenExecute(m_hTransformDB, 0, TEXT("SELECT `Name`, `Data` FROM `_Streams` WHERE `Name`='\005SummaryInformation'")))) ||
			(ERROR_SUCCESS != (iResult = qInsert.Modify(MSIMODIFY_INSERT, hCopyRec))))
		{
			CString strPrompt;
			strPrompt.Format(_T("Orca was unable to create the SummaryInformation for the transformed database. (MSI Error %d)"), iResult);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			CloseTransform();
			return;
		}
	}
	else if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		CString strPrompt;
		strPrompt.Format(_T("Orca was unable to read the SummaryInformation from the database. (MSI Error %d)"), iResult);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		CloseTransform();
		return;
	}

	// if we don't commit the transformed database, streams are not persisted.
	MsiDatabaseCommit(m_hTransformDB);

	// mark the new transform as unmodified
	m_bTransformModified = false;
	m_bTransformIsPatch = false;
	m_bTransformReadOnly = false;

	m_strTransformFile = _T("Untitled");
	if (fSetTitle)
		SetTitle(m_strPathName);
}


void COrcaDoc::OnUpdateNewTransform(CCmdUI* pCmdUI) { pCmdUI->Enable(m_eiType != iDocNone &&  !DoesTransformGetEdit()); }
void COrcaDoc::OnUpdateTransformViewPatch(CCmdUI* pCmdUI) { pCmdUI->Enable(m_eiType != iDocNone && (!DoesTransformGetEdit() || m_bTransformIsPatch)); }
void COrcaDoc::OnUpdateApplyTransform(CCmdUI* pCmdUI) { pCmdUI->Enable(m_eiType != iDocNone &&  !DoesTransformGetEdit()); }
void COrcaDoc::OnUpdateGenerateTransform(CCmdUI* pCmdUI) { pCmdUI->Enable(m_eiType != iDocNone && DoesTransformGetEdit()); }
void COrcaDoc::OnUpdateTransformProperties(CCmdUI* pCmdUI) { pCmdUI->Enable(m_eiType != iDocNone && DoesTransformGetEdit() && !m_bTransformIsPatch); }

void COrcaDoc::OnUpdateCloseTransform(CCmdUI* pCmdUI) 
{ 
	ASSERT(pCmdUI);
	if (DoesTransformGetEdit())
	{
		pCmdUI->Enable(TRUE); 
		pCmdUI->SetText(m_bTransformIsPatch ? _T("&Close Patch") : _T("&Close Transform"));
	}
	else
	{
		pCmdUI->Enable(FALSE); 
		pCmdUI->SetText(_T("&Close Transform..."));
	}
}


void COrcaDoc::OnApplyTransform() 
{
	// open the file open dialog
	CFileDialogEx dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST,
						 _T("Installer Transforms (*.mst)|*.mst|All Files (*.*)|*.*||"), AfxGetMainWnd());
	CString strCaption = _T("Open Transform");

	if (IDOK == dlg.DoModal())
	{
		ApplyTransform(dlg.GetPathName(), dlg.GetReadOnlyPref() != FALSE);
	}
}
		
const CString strTransformApplyErrorString =
		_T("The transform could not be applied.\n\nThere were errors applying the transform to that were not suppressed via the transform's error flags. ")
		_T("You can force the suppression of most errors via the \"Options...\" dialog, however the ignored instructions will be lost if a new transform is generated.");

const CString strTransValFailureErrorString =
		_T("The transform could not be applied because one or more of the transform's validation requirements could not be satisfied.")
		_T("You can force the application of transforms via the \"Options...\" dialog.");

void COrcaDoc::ApplyTransform(const CString strFileName, bool fReadOnly)
{
	// need a wait cursr
	CWaitCursor cursor;

	NewTransform(/*fSetTitle=*/false);
	
	// get the summary information stream to retrieve the transform error flag values.
	m_strTransformFile = strFileName;
	{
		UINT iResult = ERROR_SUCCESS;
		PMSIHANDLE hSummary;
		if (ERROR_SUCCESS == (iResult = ::MsiGetSummaryInformation(NULL, m_strTransformFile, 0, &hSummary)))
		{	
			UINT iType = 0;
			TCHAR szBuffer[1024];
			DWORD cchBuffer = 1024;

			int iBuffer = 0;

			if (ERROR_SUCCESS != (iResult = MsiSummaryInfoGetProperty(hSummary, PID_CHARCOUNT, &iType, &iBuffer, NULL, szBuffer, &cchBuffer)))
			{
				CString strPrompt;
				strPrompt.Format(_T("Orca was unable to read the validation flags from the transform. The transform can not be applied. (MSI Error %d)"), iResult);
				AfxMessageBox(strPrompt, MB_ICONSTOP);
				CloseTransform();
				return;
			}
			if (VT_I4 != iType)
			{
				m_dwTransformErrFlags = 0;
				m_dwTransformValFlags = 0;
			}
			else
			{
				m_dwTransformErrFlags = iBuffer & 0xFFFF;
				m_dwTransformValFlags = (iBuffer >> 16) & 0xFFFF;
			}
		}
		else
		{
			CString strPrompt;
			strPrompt.Format(_T("Orca was unable to read the SummaryInformation from the transform. The transform can not be applied. (MSI Error %d)"), iResult);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			CloseTransform();
			return;
		}

	}
	
	// having retrieved the transform error and validation flags, check the system-wide options to see whether we should
	// respect them or suppress all errors
	int iValOptions = AfxGetApp()->GetProfileInt(_T("Transforms"),_T("ValidationOptions"), 0);
	if (iValOptions != 0)
	{
		int iDesiredFailureFlags = 0;
		bool fTransformApplies = ValidateTransform(m_strTransformFile, iDesiredFailureFlags);
		if (!fTransformApplies)
		{
			// transform does not apply. Either prompt or reject based on options
			if (iValOptions == 1)
			{
				if (IDNO == AfxMessageBox(_T("The transform will not apply because it fails one or more of the application validation checks.\n\nDo you want to ignore the validation failures and apply the transform anyway?"), MB_YESNO | MB_ICONQUESTION))
				{
					CloseTransform();
					return;
				}
			}
			else
			{
				AfxMessageBox(strTransValFailureErrorString, MB_ICONSTOP);
				CloseTransform();
				return;
			}
		}
	}

	DWORD dwApplicationErrorFlags = m_dwTransformErrFlags;
	if (AfxGetApp()->GetProfileInt(_T("Transforms"),_T("ErrorOptions"), 1) == 0)
	{
		dwApplicationErrorFlags = MSITRANSFORM_ERROR_ADDEXISTINGROW | MSITRANSFORM_ERROR_DELMISSINGROW | MSITRANSFORM_ERROR_ADDEXISTINGTABLE |
			MSITRANSFORM_ERROR_DELMISSINGTABLE | MSITRANSFORM_ERROR_UPDATEMISSINGROW;
	}

	UINT iResult = 0;
	switch (iResult = MsiDatabaseApplyTransform(m_hTransformDB, m_strTransformFile, dwApplicationErrorFlags))
	{
	case ERROR_OPEN_FAILED:
		// the storage file did not exist.
		AfxMessageBox(_T("The specified transform file could not be opened."), MB_ICONSTOP);
		CloseTransform();
		return;
	case ERROR_INSTALL_TRANSFORM_FAILURE:
		{
			PMSIHANDLE hErrorRec = MsiGetLastErrorRecord();
			DWORD dwError = MsiRecordGetInteger(hErrorRec,1);
			if ((dwError == 2252 || dwError == 2253))
				AfxMessageBox(strTransformApplyErrorString, MB_ICONSTOP);
		
			else
				AfxMessageBox(_T("The specified transform could not be applied."), MB_ICONSTOP);
		}		
		CloseTransform();
		return;
	case ERROR_SUCCESS:
		break;
	default:
	{
		CString strPrompt;
		strPrompt.Format(_T("Orca was unable to apply the transform. (MSI Error %d)"), iResult);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		CloseTransform();
		return;
	}
	}

	m_bTransformReadOnly = fReadOnly;

	// necessary to commit temp DB so streams are persisted and can be accessed
	// independently
	MsiDatabaseCommit(m_hTransformDB);

	// after the transform has been applied, load every table to force transform application immediately.
	// This load happens anyway to generate the green-bar UI, so no big perf hit. Here we just slap a hold
	// on the table and check if the table was loaded OK. Then BuildTableList actually loads and retrieves
	// the data into the UI and places the Table object's HOLD on the table. This HOLD can then be released.
	bool fTransformErrorDetected = false;
	CQuery queryTables;
	if ((ERROR_SUCCESS != queryTables.Open(m_hTransformDB, _T("SELECT `Name` FROM `_Tables`"))) ||
		(ERROR_SUCCESS != queryTables.Execute()))
	{
		CString strPrompt;
		strPrompt.Format(_T("MSI Error %d while retrieving tables from the transformed database."), iResult);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		CloseTransform();
		return;
	}

	PMSIHANDLE hTable;
	while (ERROR_SUCCESS == (iResult = queryTables.Fetch(&hTable)))
	{
		CString strTable;
		RecordGetString(hTable, 1, strTable);
		CQuery queryHold;
		
		if (ERROR_SUCCESS != queryHold.OpenExecute(m_hTransformDB, 0, _T("ALTER TABLE `%s` HOLD"), strTable))
		{
			fTransformErrorDetected = true;
		}
	};
	if (ERROR_NO_MORE_ITEMS != iResult)
	{
		CString strPrompt;
		strPrompt.Format(_T("MSI Error %d while retrieving tables from the transformed database."), iResult);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		CloseTransform();
		return;
	}

	if (!fTransformErrorDetected)
	{
		// send a hint to change to no table. This cleans up the window
		// and makes it safe to have a UI refresh in the middle of this call.
		UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
	
		// clear the UI table list
		UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);
	
		// destroy all of the tables
		DestroyTableList();	
	
		// rebuild the table list
		BuildTableList(/*fAllowLazyLoad=*/false);
	}

	// at this point, the tables have been loaded and a HOLD placed on them. 
	// so we can free the temporary HOLD.
	if (ERROR_SUCCESS != queryTables.Execute())
		return;
	while (ERROR_SUCCESS == queryTables.Fetch(&hTable))
	{
		CString strTable;
		RecordGetString(hTable, 1, strTable);
		CQuery queryHold;
		queryHold.OpenExecute(m_hTransformDB, 0, _T("ALTER TABLE `%s` FREE"), strTable);
	}

	// if we detected a transform error, generate a message and refuse to load the
	// transform
	if (fTransformErrorDetected)
	{
		AfxMessageBox(strTransformApplyErrorString, MB_ICONSTOP);
		CloseTransform();
		return;
	}

	// reload table list into UI
	UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);

	// set frame title
	SetTitle(m_strPathName);
}

void COrcaDoc::OnGenerateTransform() 
{
	GenerateTransform();
}

int COrcaDoc::GenerateTransform()
{
	UpdateAllViews(NULL, HINT_COMMIT_CHANGES);

	// open the file open dialog
	CFileDialogEx dlg(FALSE, _T("mst"), (m_bTransformIsPatch ? _T("") : m_strTransformFile), OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,
						 _T("Windows Installer Transform (*.mst)|*.mst|All Files (*.*)|*.*||"), AfxGetMainWnd());

	CString strCaption = _T("Save Transform As");
	dlg.m_ofn.lpstrTitle = strCaption;
	if (IDOK == dlg.DoModal())
	{
		CString strPath = dlg.GetPathName();
		CString strExt = dlg.GetFileExt();

		if (strPath.IsEmpty())
			return IDCANCEL;

		// if there is no extension add one
		if (strExt.IsEmpty())
		{
			switch(dlg.m_ofn.nFilterIndex)
			{
			case 1:
				strExt = _T(".mst");
				break;
			default:
				strExt = _T(".mst");
				break;
			}

			strPath += strExt;
		}
		
		UINT iResult = 0;
		switch (iResult = MsiDatabaseGenerateTransform(m_hTransformDB, m_hDatabase, strPath, 0, 0))
		{
		case ERROR_NO_DATA:
			AfxMessageBox(_T("The transformed database is identical to the original database. No transform file was generated."), MB_ICONINFORMATION);
			break;
        case ERROR_SUCCESS:
			break;
		default:
		{
			CString strPrompt;
			strPrompt.Format(_T("Orca was unable to generate the transform. (MSI Error %d)"), iResult);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			return IDCANCEL;
		}
		}

		// next generate the transform summary information
        switch (iResult = MsiCreateTransformSummaryInfo(m_hTransformDB, m_hDatabase, strPath, m_dwTransformErrFlags, m_dwTransformValFlags))
		{
        case ERROR_SUCCESS:
			break;
		case ERROR_INSTALL_PACKAGE_INVALID:
		{
			CString strPrompt;
			strPrompt.Format(_T("Orca was unable to set all transform validation flags for the transform."));
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			return IDCANCEL;
		}
		default:
		{
			CString strPrompt;
			strPrompt.Format(_T("Orca was unable to generate the transform. (MSI Error %d)"), iResult);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			return IDCANCEL;
		}
		}

    
		// transform has been saved and is no longer modified
		m_bTransformModified = false;	
		if (!m_bTransformIsPatch)
			m_strTransformFile = strPath;
		SetTitle(m_strPathName);
		return IDOK;
	}
	return IDCANCEL;
}



DWORD GetSummaryInfoString(MSIHANDLE hSummary, int PID, CString &strValue)
{
	DWORD dwBuffer = 255;
	DWORD dwResult = MsiSummaryInfoGetProperty(hSummary, PID, NULL, NULL, NULL, strValue.GetBuffer(dwBuffer), &dwBuffer);
	if (ERROR_MORE_DATA == dwResult)
	{
		strValue.ReleaseBuffer();
		dwBuffer++;
		dwResult = MsiSummaryInfoGetProperty(hSummary, PID, NULL, NULL, NULL, strValue.GetBuffer(dwBuffer), &dwBuffer);
	}
	strValue.ReleaseBuffer();
	return dwResult;
}


DWORD RecordGetString(MSIHANDLE hRec, int iField, CString &strValue)
{
	DWORD dwBuffer = 255;
	DWORD dwResult = MsiRecordGetString(hRec, iField, strValue.GetBuffer(dwBuffer), &dwBuffer);
	if (ERROR_MORE_DATA == dwResult)
	{
		strValue.ReleaseBuffer();
		dwBuffer++;
		dwResult = MsiRecordGetString(hRec, iField, strValue.GetBuffer(dwBuffer), &dwBuffer);
	}
	strValue.ReleaseBuffer();
	return dwResult;
}

///////////////////////////////////////////////////////////////////////
// enables the viewing of patches. Opens a browse dialog, gets the file
// list, cracks the patch and validates the product code, then saves
// each transform to disk, validates the ones that apply, pops a dialog
// allowing the user to select a greater subset, then applies each 
// transform
void COrcaDoc::OnTransformViewPatch() 
{
	// open the file open dialog
	CFileDialogEx dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST,
						 _T("Installer Patches (*.msp)|*.msp|All Files (*.*)|*.*||"), AfxGetMainWnd());
	CString strCaption = _T("Open Patch");

	if (IDOK == dlg.DoModal())
	{
		ApplyPatch(dlg.GetPathName());
	}
}
		
void COrcaDoc::ApplyPatch(const CString strFileName) 
{	
	// need a wait cursor
	CWaitCursor cursor;

	CString strTransformList;
	CString strProductCodeList;
	
	// scope to ensure all handles to patch summaryinfo are closed before opening it with IStorage
	{
		////
		// open the summaryinfo of the patch and verify the productcode
		PMSIHANDLE hSummary;
		if (ERROR_SUCCESS != MsiGetSummaryInformation(0, strFileName, 0, &hSummary))
		{
			AfxMessageBox(_T("The patch does not contain a valid SummaryInformation stream."), MB_ICONSTOP);
			return;
		}

		if (ERROR_SUCCESS != GetSummaryInfoString(hSummary, PID_TEMPLATE, strProductCodeList))
		{
			AfxMessageBox(_T("The ProductCode list could not be retrieved from the specified patch."), MB_ICONSTOP);
			return;
		}

		////
		// grab the transform list from the patch summaryinfo
		if (ERROR_SUCCESS != GetSummaryInfoString(hSummary, PID_LASTAUTHOR, strTransformList))
		{
			AfxMessageBox(_T("The transform list could not be retrieved from the specified patch."), MB_ICONSTOP);
			return;
		}
	}

	CQuery qRetrieve;
	PMSIHANDLE hRec;
	CString strProductCode;
	if (ERROR_SUCCESS == qRetrieve.FetchOnce(GetTargetDatabase(), 0, &hRec, _T("SELECT `Value` FROM `Property` WHERE `Property`='ProductCode'")))
	{
		RecordGetString(hRec, 1, strProductCode);
	}
	if (strProductCodeList.Find(strProductCode) == -1)
	{
		AfxMessageBox(_T("This patch can not be applied to packages with the current Product Code."), MB_ICONSTOP);
		return;
	}

	// open the patch as IStorage so we can get embedded transforms
	IStorage *piPatchStorage = 0;
	WCHAR *wzFileName = NULL;
#ifdef UNICODE
	wzFileName = const_cast<WCHAR*>(static_cast<const WCHAR*>(strFileName));
#else
	size_t cchWide = strFileName.GetLength()+1;
	wzFileName = new WCHAR[cchWide];
	if (!wzFileName)
		return;
	AnsiToWide(strFileName, wzFileName, &cchWide);
#endif
	HRESULT hRes = StgOpenStorage(wzFileName, NULL, STGM_READ | STGM_SHARE_DENY_WRITE | STGM_DIRECT, NULL, 0, &piPatchStorage);
#ifndef UNICODE
	delete[] wzFileName;
#endif
	if (hRes != S_OK)
	{
		AfxMessageBox(_T("The patch could not be opened. Verify that the file is not in use."), MB_ICONSTOP);
		return;
	}

	// add the patch to the list of applied patches
	m_strTransformFile = _T("");
	m_lstPatchFiles.AddTail(strFileName);

	// if we are not already set up for difference tracking, perform transform init
	// operations now.
	if (!DoesTransformGetEdit())
	{
		NewTransform(false);	
		m_bTransformReadOnly = true;
		m_bTransformIsPatch = true;
	}

	////
	// ensure that the patch table schema has the latest schema to avoid
	// application problems.
	COrcaTable* pPatchTable = FindTable(L"Patch", odlSplitTransformed);

	// if there is no patch table, the correct schema will be added
	// otherwise verify that the column schema is correct
	bool fCreatePatchTable = false;
	if (!pPatchTable)
	{
		fCreatePatchTable = true;
	}
	else
	{
		int iHeaderColumn = -1;
		for (int iColumn = 0; iColumn < pPatchTable->GetColumnCount(); iColumn++)
		{
   			const COrcaColumn* pColumn = pPatchTable->GetColumn(iColumn);
			if (!pColumn)
				continue;
			if (pColumn->m_strName == TEXT("Header"))
			{
				iHeaderColumn = iColumn;
				break;
			}
		}
		if (iHeaderColumn == -1)
		{
			// header column is missing. Definitely the wrong schema
			fCreatePatchTable = true;
		}
		else
		{
			// if the column is nullable, the schema is already correct
			const COrcaColumn* pColumn = pPatchTable->GetColumn(iHeaderColumn);
			if (pColumn && !pColumn->m_bNullable)
				fCreatePatchTable = true;
		}
	}

	if (fCreatePatchTable)
	{
		// try to generate a temporary table name.
		WCHAR wzTempTable[40] = L"_ORCA0000";
		bool fCopyData = false;
		
		CQuery qTempTable;
		CQuery qPatchTable;

		// drop the existing patch table, saving data if necessary
		if (pPatchTable)
		{
			// if there is already data in the patch table, copy it to a temp table. Need to
			// retrieve any table data to ensure an accurrate row count
			pPatchTable->RetrieveTableData();
			if (pPatchTable->GetRowCount())
			{
				int i = 0;
				for (i=1; i < 0xFFFF; i++)
				{
					wzTempTable[5] = L'A'+((i & 0xF000) >> 12);
					wzTempTable[6] = L'A'+((i & 0x0F00) >> 8);
					wzTempTable[7] = L'A'+((i & 0x00F0) >> 4);
					wzTempTable[8] = L'A'+((i & 0x000F));
					if (MSICONDITION_NONE == MsiDatabaseIsTablePersistentW(GetTransformedDatabase(), wzTempTable))
						break;
				}
				if (i == 0xFFFF)
				{
					piPatchStorage->Release();
					return;
				}

				// duplicate the table schema into the temporary table
				MsiDBUtils::DuplicateTableW(GetTransformedDatabase(), L"Patch", GetTransformedDatabase(), wzTempTable, false);

				// copy the data from the Patch table to the temp table
				fCopyData = true;
				if (ERROR_SUCCESS == qPatchTable.OpenExecute(GetTransformedDatabase(), 0, TEXT("SELECT * FROM `Patch`")) &&
				   (ERROR_SUCCESS == qTempTable.OpenExecute(GetTransformedDatabase(), 0, TEXT("SELECT * FROM `%ls`"), wzTempTable)))
				{
					PMSIHANDLE hRec;
					while (ERROR_SUCCESS == qPatchTable.Fetch(&hRec))
						qTempTable.Modify(MSIMODIFY_INSERT, hRec);

					// slow, but necessary to commit before dropping patch table or the binary
					// objects will become lost
					::MsiDatabaseCommit(GetTransformedDatabase());
				}
				else
					fCopyData = false;
			}

			// drop the patch table
			pPatchTable->DropTable(GetTransformedDatabase());
		}

		// create the new patch table
		CQuery qPatchQuery;
		qPatchQuery.OpenExecute(GetTransformedDatabase(), 0, TEXT("CREATE TABLE `Patch` ( `File_` CHAR(72) NOT NULL, `Sequence` INTEGER NOT NULL, `PatchSize` LONG NOT NULL, `Attributes` INTEGER NOT NULL, `Header` OBJECT, `StreamRef_` CHAR(72)  PRIMARY KEY `File_`, `Sequence`)"));

		if (fCopyData)
		{
			// restart query to read from the temporary table
			qTempTable.Execute(0);

			// re-init the patch table schema to retrieve the new columns
			qPatchTable.OpenExecute(GetTransformedDatabase(), 0, TEXT("SELECT * FROM `Patch`"));
			while (ERROR_SUCCESS == qTempTable.Fetch(&hRec))
				qPatchTable.Modify(MSIMODIFY_MERGE, hRec);

			// slow, but necessary to keep streams in the Header column from becoming lost
			::MsiDatabaseCommit(GetTransformedDatabase());

			// drop the table used for storage
			CQuery qFree;
			qFree.OpenExecute(GetTransformedDatabase(), 0, TEXT("DROP TABLE `%ls`"), wzTempTable);
		}
	}

	////
	// parse the transform list, validate each transform, and apply the transforms in order.
	int iSemicolon = 0;
	bool fError = false;

	CString strTransformFile;		
	do
	{
		// determine the name of the next embedded transform
		CString strTransform;
		iSemicolon = strTransformList.Find(';');
		if (iSemicolon != -1)
		{
			// transform name begins with ':', so strip the first character
			strTransform = strTransformList.Left(iSemicolon);
			strTransformList = strTransformList.Mid(iSemicolon+1);
		}
		else
			strTransform = strTransformList;
		strTransform = strTransform.Mid(1);
		if (strTransform.IsEmpty())
			break;

		// generate a temporary file name
		DWORD cchTempPath = MAX_PATH;
		TCHAR szTempPath[MAX_PATH] = TEXT("");
		if (0 == ::GetTempPath(cchTempPath, szTempPath))
		{
			fError = true;
			CString strPrompt;
			strPrompt.Format(_T("Error %d while retrieving temporary file path."), GetLastError());
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			break;
		}
		if (0 == ::GetTempFileName(szTempPath, _T("ODB"), 0, strTransformFile.GetBuffer(MAX_PATH)))
		{
			fError = true;
			CString strPrompt;
			strPrompt.Format(_T("Error %d while retrieving temporary file name."), GetLastError());
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			break;
		}
		strTransformFile.ReleaseBuffer();

		IStorage *piSourceStorage = NULL;
		IStorage *piNewStorage = NULL;

		WCHAR *wzTransform = NULL;
#ifdef UNICODE
		wzTransform = const_cast<WCHAR*>(static_cast<const WCHAR*>(strTransform));
#else
		cchWide = strTransform.GetLength()+1;
		wzTransform = new WCHAR[cchWide];
		if (!wzTransform)
			return;
		AnsiToWide(strTransform, wzTransform, &cchWide);
#endif
		hRes = piPatchStorage->OpenStorage(wzTransform, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, NULL, 0, &piSourceStorage);
#ifndef UNICODE
		delete[] wzTransform;
#endif
		if (hRes != S_OK)
		{
			AfxMessageBox(_T("The transforms inside the patch could not be opened. The patch may be invalid, or the SummaryInformation may reference a non-existent transform."), MB_ICONSTOP);
			fError = true;
			break;
		}

		WCHAR* wzTransformFile = NULL;
#ifdef UNICODE
		wzTransformFile = const_cast<WCHAR*>(static_cast<const WCHAR*>(strTransformFile));
#else
		cchWide = strTransformFile.GetLength()+1;
		wzTransformFile = new WCHAR[cchWide];
		if (!wzTransformFile)
			return;
		AnsiToWide(strTransformFile, wzTransformFile, &cchWide);
#endif
		hRes = StgCreateDocfile(wzTransformFile, STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE | STGM_DIRECT, 0, &piNewStorage);
#ifndef UNICODE
		delete[] wzTransformFile;
#endif
		if (hRes != S_OK)
		{
			AfxMessageBox(_T("The transforms inside the patch could not be accessed. Verify that the TEMP directory is writable."), MB_ICONSTOP);
			piSourceStorage->Release();
			fError = true;
			break;
		}

		COrcaApp *pApp = (static_cast<COrcaApp *>(AfxGetApp()));
		ASSERT(pApp);
		if (pApp)
			pApp->m_lstTempCleanup.AddTail(strTransformFile);

		hRes = piSourceStorage->CopyTo(NULL, NULL, NULL, piNewStorage);
		if (hRes != S_OK)
		{
			AfxMessageBox(_T("The transforms inside patch could not be read. The patch may be invalid."), MB_ICONSTOP);
			piSourceStorage->Release();
			fError = true;
			break;
		}

		piSourceStorage->Release();
		piNewStorage->Release();

		// determine if this transform can be applied to this package
		int iValidateFlags = 0;
		if (ValidateTransform(strTransformFile, iValidateFlags))
		{
			UINT iResult = 0;
			switch (iResult = MsiDatabaseApplyTransform(m_hTransformDB, strTransformFile, iValidateFlags))
			{
			case ERROR_OPEN_FAILED:
				// the storage file did not exist.
				AfxMessageBox(_T("The specified transform file could not be opened."), MB_ICONSTOP);
				fError = true;
				break;
			case ERROR_INSTALL_TRANSFORM_FAILURE:
				AfxMessageBox(_T("The specified transform could not be applied."), MB_ICONSTOP);
				fError = true;
				break;
			case ERROR_SUCCESS:
				break;
			default:
			{
				CString strPrompt;
				strPrompt.Format(_T("Orca was unable to apply a transform from the patch. (MSI Error %d)"), iResult);
				AfxMessageBox(strPrompt, MB_ICONSTOP);
				fError = true;
				break;
			}
			}

			if (fError)
				break;
		}

		if (fError)
			break;
	} while (iSemicolon != -1);

	// free the patch
	piPatchStorage->Release();

	if (!fError)
	{	
		// commit the database so future patches can be applied
		MsiDatabaseCommit(m_hTransformDB);

		// send a hint to change to no table. This cleans up the window
		// and makes it safe to have a UI refresh in the middle of this call.
		UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);

		// clear the UI table list
		UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);

		// destroy all of the tables
		DestroyTableList();	

		// rebuild the table list
		BuildTableList(/*AllowLazyLoad=*/false);

		// reload table list into UI
		UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);

		// set frame title
		SetTitle(m_strPathName);
	}
	else
		CloseTransform();
}

void COrcaDoc::CloseTransform()
{
	// clean up internal state
	if (m_hTransformDB)
		MsiCloseHandle(m_hTransformDB);
	m_hTransformDB=0;	
	m_bTransformModified = false;
	m_bTransformIsPatch = false;
	m_bTransformReadOnly = false;
	m_strTransformFile = _T("Untitled");
	while (!m_lstPatchFiles.IsEmpty())
		m_lstPatchFiles.RemoveHead();

	// delete temporary files
	if (m_strTransformTempDB.IsEmpty())
		DeleteFile(m_strTransformTempDB);
	
	// clear any pending validation errors
	UpdateAllViews(NULL, HINT_CLEAR_VALIDATION_ERRORS, NULL);
	((CMainFrame*)AfxGetMainWnd())->HideValPane();

	// send a hint to change to no table. This cleans up the window
	// and makes it safe to have a UI refresh in the middle of this call.
	UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);

	// clear the UI table list
	UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);

	// destroy all of the tables
	DestroyTableList();	

	// rebuild the table list.
	BuildTableList(/*fAllowLazyLoad=*/true);

	// reload table list into UI
	UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);
	
	// set window title
	SetTitle(m_strPathName);

	// try cleaning up any temp files
	CStringList *pList = &((static_cast<COrcaApp *>(AfxGetApp()))->m_lstTempCleanup);
	if (pList)
	{
		INT_PTR iMax = pList->GetCount();
		for (INT_PTR i=0; i < iMax; i++)
		{
			CString strFile = pList->RemoveHead();
			if (!strFile.IsEmpty())
			{
				if (!DeleteFile(strFile))
					pList->AddTail(strFile);
			}
		}
	}
}

void COrcaDoc::OnCloseTransform() 
{
	if (m_bTransformModified)
	{
		CString strPrompt;
		strPrompt.Format(_T("Save changes to transform %s?"), m_strTransformFile.IsEmpty() ? _T("Untitled") : m_strTransformFile);
		switch (AfxMessageBox(strPrompt, MB_YESNOCANCEL | MB_ICONEXCLAMATION))
		{
		case IDYES:
			if (IDCANCEL == GenerateTransform())
				return;
			break;
		case IDNO:
			break;
		case IDCANCEL:
		default:
			return;
		}
	}

	CloseTransform();
}



void COrcaDoc::SetModifiedFlag(BOOL fModified)
{
	if (DoesTransformGetEdit())
		m_bTransformModified = (fModified != 0);
	else
		CDocument::SetModifiedFlag(fModified);
}


////
// override of SetPathName to handle an empty path when no document is
// actually loaded.
void COrcaDoc::SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU)
{
	if ((lpszPathName == NULL) || (!*lpszPathName))
	{
		// store the path fully qualified
		m_strPathName = _T("");
		m_bEmbedded = FALSE;
		SetModifiedFlag(FALSE);
		SetTitle(m_strPathName);
		return;	
	}

	CDocument::SetPathName(lpszPathName, bAddToMRU);
}

// sets the window title appropriately
void COrcaDoc::SetTitle(LPCTSTR szTitle)
{
	CString strTitle;
	if (m_strPathName.IsEmpty())
		strTitle = _T("Untitled");
	else
	{
		int nFind = m_strPathName.ReverseFind(_T('\\'));
		if (nFind > -1)
			strTitle = m_strPathName.Mid(nFind + 1);
		else
			strTitle = m_strPathName;
	}

	if (DoesTransformGetEdit())
	{
		strTitle += (m_bTransformIsPatch ? _T(" (patched by ") : _T(" (transformed by "));

		if (m_bTransformIsPatch)
		{
			POSITION pos = m_lstPatchFiles.GetHeadPosition();
			while (pos)
			{
				CString strTransformFile = m_lstPatchFiles.GetNext(pos);
				int nFind = strTransformFile.ReverseFind(_T('\\'));
				if (nFind > -1)
					strTitle += strTransformFile.Mid(nFind + 1);
				else
					strTitle += strTransformFile;

				if (pos != NULL)
					strTitle += _T(", ");
			}
		}
		else
		{
			int nFind = m_strTransformFile.ReverseFind(_T('\\'));
			if (nFind > -1)
				strTitle += m_strTransformFile.Mid(nFind + 1);
			else
				strTitle += m_strTransformFile;
		}

		strTitle += _T(")");
	}

	if (TargetIsReadOnly())
		strTitle += _T(" (Read Only)");

	CDocument::SetTitle(strTitle);
}

///////////////////////////////////////////////////////////////////////
// returns true if the specified transform is valid basaed on the
// validation options 

DWORD ProductVersionStringToInt(const CString strVersion)
{
	DWORD dwVersion = 0;

	dwVersion = _ttoi(strVersion) << 24;

	int iDot = strVersion.Find('.');
	if (iDot == -1)
		return dwVersion;

	dwVersion |= (_ttoi(strVersion.Mid(iDot+1)) << 16);
	int iNewDot = strVersion.Find('.', iDot+1);

	if (iNewDot == -1)
		return dwVersion;
	iDot += iNewDot;

	dwVersion |= _ttoi(strVersion.Mid(iDot));
	return dwVersion;
}

 
bool COrcaDoc::ValidateTransform(const CString strTransform, int& iDesiredFailureFlags)
{
	// values read from current database
	CString strProductCode;
    CString strProductVersion;
	CString strUpgradeCode;

	// retrieve product code, product verison, upgrade code for validation. Each transform can modify these
	// values, so we must requery before every transform in the patch.
	CQuery qRetrieve;
	PMSIHANDLE hRec;
	if (ERROR_SUCCESS == qRetrieve.FetchOnce(GetTargetDatabase(), 0, &hRec, _T("SELECT `Value` FROM `Property` WHERE `Property`='ProductVersion'")))
	{
		RecordGetString(hRec, 1, strProductVersion);
	}
	if (ERROR_SUCCESS == qRetrieve.FetchOnce(GetTargetDatabase(), 0, &hRec, _T("SELECT `Value` FROM `Property` WHERE `Property`='UpgradeCode'")))
	{
		RecordGetString(hRec, 1, strUpgradeCode);
	}
	if (ERROR_SUCCESS == qRetrieve.FetchOnce(GetTargetDatabase(), 0, &hRec, _T("SELECT `Value` FROM `Property` WHERE `Property`='ProductCode'")))
	{
		RecordGetString(hRec, 1, strProductCode);
	}

	// get summaryinfo of the transform
	PMSIHANDLE hSummary;
	if (ERROR_SUCCESS != MsiGetSummaryInformation(0, strTransform, 0, &hSummary))
		return false;

	
	// get the summary info properties
	CString strTransTemplate;
	CString strTransRevNumber;

	int iTransRestrictions = 0;

	GetSummaryInfoString(hSummary, PID_TEMPLATE, strTransTemplate);
	GetSummaryInfoString(hSummary, PID_REVNUMBER, strTransRevNumber);
	MsiSummaryInfoGetProperty(hSummary, PID_CHARCOUNT, NULL, &iTransRestrictions, NULL, NULL, NULL);

	// desired failure flags are in the lower word, actual validation checks are in upper
	// word.
	iDesiredFailureFlags = iTransRestrictions & 0xFFFF;
	iTransRestrictions >>= 16;
		
	// validate language
	// ********** what to do here, this is highly runtime dependant
	if (iTransRestrictions & MSITRANSFORM_VALIDATE_LANGUAGE)
	{
/*		strTransLanguage == strTransTemplate;
		int iSemicolon = strTransTemplate.Find(';');
		if (iSemicolon != -1)
			strTransLanguage = strTransTemplate.Right(strTransTemplate.GetLength()-iSemicolon);
		 
		if ((int)istrTransLanguage != GetLanguage())
		{
			return false
		}*/
	}

	// validate productcode
	if (iTransRestrictions & MSITRANSFORM_VALIDATE_PRODUCT)
	{
		CString strTransProductCode = strTransRevNumber.Left(38);
		if (strTransProductCode != strProductCode)
		{
			return false;
		}
	}

	// validate upgrade code
	if (iTransRestrictions & MSITRANSFORM_VALIDATE_UPGRADECODE)
	{
		CString strTransUpgradeCode = strTransRevNumber;
		int iSemicolon = strTransUpgradeCode.Find(';');
		if (iSemicolon == -1)
			return false;
		iSemicolon = strTransUpgradeCode.Find(';', iSemicolon+1);
		// if theres no second semicolon, there is no upgrade code validation
		if (iSemicolon != -1)
		{
			strTransUpgradeCode = strTransUpgradeCode.Mid(iSemicolon+1);
			
			if (strTransUpgradeCode != strUpgradeCode)
			{
				return false;
			}
		}
	}

	// check version numbers
	if ((iTransRestrictions & (MSITRANSFORM_VALIDATE_MAJORVERSION|MSITRANSFORM_VALIDATE_MINORVERSION|MSITRANSFORM_VALIDATE_UPDATEVERSION)) != 0)
	{
		CString strVersion  = strTransRevNumber.Mid(38);
		int iSemicolon = strVersion.Find(';');
		if (iSemicolon != -1)
			strVersion = strVersion.Left(iSemicolon);

		// convert version strings into integers
		int iAppVersion      = ProductVersionStringToInt(strProductVersion);
		int iTransAppVersion = ProductVersionStringToInt(strVersion);

		if(iTransRestrictions & MSITRANSFORM_VALIDATE_MAJORVERSION)
		{
			iAppVersion &= 0xFF000000;
			iTransAppVersion &= 0xFF000000;
		}
		else if(iTransRestrictions & MSITRANSFORM_VALIDATE_MINORVERSION)
		{
			iAppVersion &= 0xFFFF0000;
			iTransAppVersion &= 0xFFFF0000;
		}
		// else itvUpdVer: don't need to mask off bits

		switch (iTransRestrictions & 
				(MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION | MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION |
				 MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION | MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION |
				 MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION))
		{
		case MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION:
			if (!(iAppVersion < iTransAppVersion))
				return false;
			break;
		case MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION:
			if (!(iAppVersion <= iTransAppVersion))
				return false;
			break;
		case MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION:			
			if (!(iAppVersion == iTransAppVersion))
				return false;
			break;
		case MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION:
			if (!(iAppVersion >= iTransAppVersion))
				return false;
			break;
		case MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION:
			if (!(iAppVersion > iTransAppVersion))
				return false;
			break;
		default:
			break;
		}
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\orca.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Orca.h : main header file for the ORCA application
//

#if !defined(AFX_ORCA_H__C3EDC1A8_E506_11D1_A856_006097ABDE17__INCLUDED_)
#define AFX_ORCA_H__C3EDC1A8_E506_11D1_A856_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include <objbase.h>
#include "msiquery.h"
#include "orca_res.h"       // main symbols

// forward declaration
class COrcaCommandLine;

/////////////////////////////////////////////////////////////////////////////
// COrcaApp:
// See Orca.cpp for the implementation of this class
//
class COrcaApp : public CWinApp
{
public:
	CStringList m_lstClipCleanup;
	CStringList m_lstTempCleanup;
	CString GetOrcaVersion();
	static void OutputMergeDisplay(const BSTR bstrOut);
	COrcaApp();

	CString m_strSchema;
	MSIHANDLE m_hSchema;

	UINT FindSchemaDatabase(CString& rstrSchema);
	UINT ExecuteMergeModule(COrcaCommandLine &cmdInfo);
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COrcaApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(COrcaApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

DWORD RecordGetString(MSIHANDLE hRec, int iField, CString &strValue);

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ORCA_H__C3EDC1A8_E506_11D1_A856_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\orca.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// Orca.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "Orca.h"

#include "MainFrm.h"
#include "OrcaDoc.h"
#include "TableVw.h"

#include "cmdline.h"
#include "HelpD.h"
#include "cnfgmsmd.h"

#include <initguid.h>

#include "..\common\utils.h"
#include "..\common\query.h"
#include "domerge.h"

#include "version.h"
                                 
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// updates media table
UINT UpdateMediaTable(LPCTSTR szDatabase);

/////////////////////////////////////////////////////////////////////////////
// COrcaApp

BEGIN_MESSAGE_MAP(COrcaApp, CWinApp)
	//{{AFX_MSG_MAP(COrcaApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COrcaApp construction

COrcaApp::COrcaApp()
{
	m_hSchema = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only COrcaApp object

COrcaApp theApp;

/////////////////////////////////////////////////////////////////////////////
// COrcaApp initialization



BOOL COrcaApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// allow COM
	::CoInitialize(NULL);

	// Change the registry key under which our settings are stored.
	// You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Microsoft"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(COrcaDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CTableView));
	AddDocTemplate(pDocTemplate);

	EnableShellOpen();
	RegisterShellFileTypes(FALSE);
	
	// Parse command line for standard shell commands, DDE, file open
	COrcaCommandLine cmdInfo;
	ParseCommandLine(cmdInfo);

	UINT iResult = ERROR_SUCCESS;
	if (cmdInfo.m_nShellCommand == CCommandLineInfo::FileNothing)
	{
		 if (iExecuteMerge == cmdInfo.m_eiDo)
		{
			if (cmdInfo.m_strFileName.IsEmpty())
			{
				AfxMessageBox(_T("A MSI Database must be specifed to merge into."), MB_ICONSTOP);
				return FALSE;
			}

			if (cmdInfo.m_strExecuteModule.IsEmpty())
			{
				AfxMessageBox(_T("You must specify a Merge Module to merge in."), MB_ICONSTOP);
				return FALSE;
			}

			if (cmdInfo.m_strFeatures.IsEmpty())
			{
				AfxMessageBox(_T("A Feature must be specified to Merge Module to."), MB_ICONSTOP);
				return FALSE;
			}

			iResult = ExecuteMergeModule(cmdInfo);

			// if we're good and not quite and we were to commit
			if (!cmdInfo.m_bQuiet &&
				((ERROR_SUCCESS == iResult && cmdInfo.m_bCommit) || cmdInfo.m_bForceCommit))
			{
				if (IDYES == AfxMessageBox(_T("Would you like to open the new MSI Database in Orca?"), MB_YESNO|MB_ICONINFORMATION))
					cmdInfo.m_nShellCommand = CCommandLineInfo::FileOpen;
			}
		}
		else if (iHelp == cmdInfo.m_eiDo)	// show help
		{
			CHelpD dlg;
			dlg.DoModal();
		}
		else
			AfxMessageBox(_T("Unknown command line operation."), MB_ICONSTOP);
	}

	// if command line has been set to do something
	if (cmdInfo.m_nShellCommand != CCommandLineInfo::FileNothing)
	{
		CString strPrompt;
		m_strSchema = cmdInfo.m_strSchema;

		// find the schema database
		iResult = FindSchemaDatabase(m_strSchema);
		if (ERROR_SUCCESS != iResult)
		{
			strPrompt.Format(_T("Fatal Error: Failed to locate schema database: '%s'"), m_strSchema);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			return FALSE;
		}

		// open the schema database
		iResult = MsiOpenDatabase(m_strSchema, MSIDBOPEN_READONLY, &m_hSchema);
		if (ERROR_SUCCESS != iResult)
		{
			strPrompt.Format(_T("Fatal Error: Failed to load schema database: '%s'"), m_strSchema);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			return FALSE;
		}

		// Dispatch commands specified on the command line
		if (!ProcessShellCommand(cmdInfo))
			return FALSE;

		// if we have open a document from the command line and it is read only,
		// we have to manually set the title, because the MFC framework will
		// override what we did in OpenDocument()
		if (m_pMainWnd)
		{
			COrcaDoc *pDoc = static_cast<COrcaDoc *>(static_cast<CMainFrame *>(m_pMainWnd)->GetActiveDocument());
			ASSERT(pDoc);
			if (pDoc)
			{
				if ((pDoc->m_eiType == iDocDatabase) && pDoc->TargetIsReadOnly())
					pDoc->SetTitle(pDoc->GetTitle() + _T(" (Read Only)"));
			}

			// allowthe main window to accept files
			m_pMainWnd->DragAcceptFiles(TRUE);
		
			// The one and only window has been initialized, so show and update it.
			m_pMainWnd->ShowWindow(SW_SHOW);
			if (pDoc)
				pDoc->UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);
			m_pMainWnd->UpdateWindow();
		}
	}

	return (cmdInfo.m_nShellCommand != CCommandLineInfo::FileNothing);
}	// end of InitInstance

int COrcaApp::ExitInstance() 
{
	// if the schema database is open close it
	if (m_hSchema)
	{
		MsiCloseHandle(m_hSchema);
		m_strSchema = _T("");
	}

	// if any binary data has been placed in temp file, we can remove it because
	// no other app knows what to do with it.
	while (m_lstClipCleanup.GetCount())
		DeleteFile(m_lstClipCleanup.RemoveHead());

	// also cleanup any temporary files possibly left over
	while (m_lstTempCleanup.GetCount())
		DeleteFile(m_lstTempCleanup.RemoveHead());

	::CoUninitialize();	// uninitialize COM
	
	return CWinApp::ExitInstance();
}

///////////////////////////////////////////////////////////
// FindSchemaDatabase
UINT COrcaApp::FindSchemaDatabase(CString& rstrSchema)
{
	UINT iResult = ERROR_FUNCTION_FAILED;	// assume it won't be found
	DWORD dwAttrib;

	// if something was specified on the command line, check there
	if (!rstrSchema.IsEmpty())
	{
		dwAttrib = GetFileAttributes(rstrSchema);

		// if its a directory, look in there 
		if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)
		{
			rstrSchema += _T("\\Orca.Dat");
			dwAttrib = GetFileAttributes(rstrSchema);
		}

		// if not a directory and not invalid
		if (!(0xFFFFFFFF == dwAttrib || (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)))
			return ERROR_SUCCESS;
	}

	// either the above failed or nothing was given to us. Try the registry
	rstrSchema = GetProfileString(_T("Path"), _T("OrcaDat"), _T(""));
	if (!rstrSchema.IsEmpty())
	{
		dwAttrib = GetFileAttributes(rstrSchema);

		// if its a directory, look in there 
		if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)
		{
			rstrSchema += _T("\\Orca.DAT");
			dwAttrib = GetFileAttributes(rstrSchema);
		}

		// if not a directory and not invalid
		if (0xFFFFFFFF == dwAttrib || (dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
			return ERROR_SUCCESS;
	}

	// so far, no luck. Now search the search path.
	TCHAR *strPath = rstrSchema.GetBuffer(MAX_PATH);
	TCHAR *unused;
	DWORD length = SearchPath(NULL, _T("ORCA.DAT"), NULL, MAX_PATH, strPath, &unused);
	if (length > MAX_PATH) {
		strPath = rstrSchema.GetBuffer(MAX_PATH);
		SearchPath(NULL, _T("ORCA.DAT"), NULL, MAX_PATH, strPath, &unused);
	}
	if (length != 0) {
		rstrSchema.ReleaseBuffer();
		return ERROR_SUCCESS;
	}

	// not found
	return ERROR_FUNCTION_FAILED;
}	// end of FindSchemaDatabase

///////////////////////////////////////////////////////////
// ExecuteMergeModule
UINT COrcaApp::ExecuteMergeModule(COrcaCommandLine &cmdInfo) 
{
	short iLanguage = -1;

	// determine what language to use. If specified, use it, otherwise 
	// get from summaryinfo stream
	if (!cmdInfo.m_strLanguage.IsEmpty())
	{
		// parse for the number
		if (_istdigit(cmdInfo.m_strLanguage[0]))
			iLanguage = static_cast<short>(_ttoi(cmdInfo.m_strLanguage));
		
		// if no language specified
		if (iLanguage == -1)
			return ERROR_FUNCTION_FAILED;
	}
	
	CMsmConfigCallback CallbackInfo;
	if (!cmdInfo.m_strConfigFile.IsEmpty())
	{
		if (!CallbackInfo.ReadFromFile(cmdInfo.m_strConfigFile))
		{
			AfxMessageBox(_T("Could not open or read the configuration file."), MB_ICONSTOP);
			return ERROR_FUNCTION_FAILED;
		}
	}

	eCommit_t eCommit = (cmdInfo.m_bForceCommit ? commitForce : (cmdInfo.m_bCommit ? commitYes : commitNo));
	UINT iResult = ::ExecuteMerge(cmdInfo.m_bQuiet ? (LPMERGEDISPLAY)NULL : &OutputMergeDisplay, 
		cmdInfo.m_strFileName, cmdInfo.m_strExecuteModule, cmdInfo.m_strFeatures, iLanguage, 
		cmdInfo.m_strRedirect, cmdInfo.m_strExtractCAB, cmdInfo.m_strExtractDir, cmdInfo.m_strExtractImage, 
		cmdInfo.m_strLogFile, false, cmdInfo.m_bLFN, &CallbackInfo, NULL, eCommit);

	// update the media table real quick
	if (SUCCEEDED(iResult) &&
		(ERROR_SUCCESS != UpdateMediaTable(cmdInfo.m_strFileName)))
		return ERROR_SUCCESS;

	return iResult;
}	// end of ExecuteMergeModule

///////////////////////////////////////////////////////////
// UpdateMediaTable
UINT UpdateMediaTable(LPCTSTR szDatabase)
{
	UINT iResult;
	PMSIHANDLE hDatabase;
	if (ERROR_SUCCESS != (iResult = MsiOpenDatabase(szDatabase, MSIDBOPEN_TRANSACT, &hDatabase)))
		return iResult;

	int iMaxSequence = -1;
	CQuery queryDatabase;
	if (ERROR_SUCCESS != (iResult = queryDatabase.OpenExecute(hDatabase, NULL, _T("SELECT `Sequence` FROM `File`"))))
		return iResult;

	int iSequence;
	PMSIHANDLE hRecFile;
	while (ERROR_SUCCESS == (iResult = queryDatabase.Fetch(&hRecFile)))
	{
		iSequence = MsiRecordGetInteger(hRecFile, 1);

		if (iSequence > iMaxSequence)
			iMaxSequence = iSequence;
	}

	// if something went wrong bail
	if (ERROR_NO_MORE_ITEMS != iResult)
		return iResult;

	// close the query to prepare for the next one
	queryDatabase.Close();

	if (ERROR_SUCCESS != (iResult = queryDatabase.OpenExecute(hDatabase, NULL, _T("SELECT `LastSequence` FROM `Media`"))))
		return iResult;

	PMSIHANDLE hRecMedia;
	iResult = queryDatabase.Fetch(&hRecMedia);

	// if a record was retrieved
	if (hRecMedia)
	{
		MsiRecordSetInteger(hRecMedia, 1, iMaxSequence);
		iResult = queryDatabase.Modify(MSIMODIFY_UPDATE, hRecMedia);
	}

	if (ERROR_SUCCESS == iResult)
		iResult = MsiDatabaseCommit(hDatabase);

	return iResult;
}	// end of UpdateMediaTable

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	CString	m_strVersion;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	m_strVersion = _T("");
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	DDX_Text(pDX, IDC_VERSIONSTRING, m_strVersion);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void COrcaApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.m_strVersion = CString(_T("Orca Version ")) + GetOrcaVersion();
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// COrcaApp commands

void COrcaApp::OutputMergeDisplay(const BSTR bstrOut)
{
    fputws(bstrOut, stdout);
}

CString COrcaApp::GetOrcaVersion()
{
	// create string containing the version number
	CString strVersion;
	strVersion.Format(_T("%d.%2d.%4d.%d"), rmj, rmm, rup, rin);
	return strVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\orcalstv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// OrcaListView.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "OrcaLstV.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// can't use MFC's SubclassWindow due to a macro defined in windowsx
#undef SubclassWindow

/////////////////////////////////////////////////////////////////////////////
// COrcaListView

IMPLEMENT_DYNCREATE(COrcaListView, CListView)

COrcaListView::COrcaListView() : m_ctrlHeader(10)

{
	m_pfDisplayFont = NULL;
	m_cColumns = 0;
	m_nSelCol = -1;
	m_iRowHeight = 1;
	m_clrFocused = RGB(0,255,255);
	m_clrSelected = RGB(0,0,255);
	m_clrNormal = RGB(255,255,255);
	m_clrTransform = RGB(0, 128, 0);
	m_bDrawIcons = false;
}

COrcaListView::~COrcaListView()
{
	if (m_pfDisplayFont)
		delete m_pfDisplayFont;
}


BEGIN_MESSAGE_MAP(COrcaListView, CListView)
	//{{AFX_MSG_MAP(COrcaListView)
	ON_WM_CREATE()
	ON_WM_ERASEBKGND()
	ON_WM_MEASUREITEM_REFLECT()
	ON_UPDATE_COMMAND_UI(IDM_ERRORS, OnUpdateErrors)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#define CELL_BORDER 3

/////////////////////////////////////////////////////////////////////////////
// COrcaListView drawing

void COrcaListView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// COrcaListView diagnostics

#ifdef _DEBUG
void COrcaListView::AssertValid() const
{
	CListView::AssertValid();
}

void COrcaListView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}

COrcaDoc* COrcaListView::GetDocument() const // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(COrcaDoc)));
	return (COrcaDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COrcaListView message handlers

COrcaListView::ErrorState COrcaListView::GetErrorState(const void *data, int iColumn) const
{
	return OK;
}

OrcaTransformAction COrcaListView::GetItemTransformState(const void *data) const
{
	return iTransformNone;
}

bool COrcaListView::ContainsTransformedData(const void *data) const
{
	return false;
}

bool COrcaListView::ContainsValidationErrors(const void *data) const
{
	return false;
}

OrcaTransformAction COrcaListView::GetCellTransformState(const void *data, int iColumn) const
{
	return iTransformNone;
}

OrcaTransformAction COrcaListView::GetColumnTransformState(int iColumn) const
{
	return iTransformNone;
}

///////////////////////////////////////////////////////////
// retrieve maximum width for one or more columns based
// on the mask.	If a table is provided, it is used and the
// list control itself is never queried except to get the
// font and DC. If a table is not provided, everything
// is retrieved from the current state of the list control.
void COrcaListView::GetAllMaximumColumnWidths(const COrcaTable* pTable, int rgiMaxWidths[32], DWORD dwMask) const
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// determine the number of columns
	int cColumns = 0;
	if (pTable)
		cColumns = pTable->GetColumnCount();
	else
		cColumns = m_cColumns;

	// initialize all widths to 0.
	for (int iColumn =0; iColumn < cColumns; iColumn++)
		rgiMaxWidths[iColumn] = 0;
	
	// obtain the DC from the list control
	CDC* pDC = rctrlList.GetDC();
	if (pDC)
	{
		// select the font into the DC to ensure that the correct
		// character widths are used.
		if (m_pfDisplayFont)
			pDC->SelectObject(m_pfDisplayFont);

		// check the widths of the column names
		for (int iColumn = 0; iColumn < cColumns; iColumn++)
		{
			// if this column is selected, OK to check width
			if (dwMask & (1 << iColumn))
			{
				LPCTSTR szColumnName = NULL;
				TCHAR szName[72];

				// if a table is provided, the name is retrieved from the 
				// column structures of that table
				if (pTable)
				{
					const COrcaColumn* pColumn = pTable->GetColumn(iColumn);
					if (pColumn)
						szColumnName = pColumn->m_strName;
				}
				else
				{
					// otherwise the table name is retrieved from the list 
					// control header
					LVCOLUMN ColumnInfo;
					ColumnInfo.mask = LVCF_TEXT;
					ColumnInfo.cchTextMax = 72;
					ColumnInfo.pszText = szName;

					if (rctrlList.GetColumn(iColumn, &ColumnInfo))
					{
						szColumnName = ColumnInfo.pszText;
					}
				}
				if (szColumnName)
					rgiMaxWidths[iColumn] = pDC->GetTextExtent(szColumnName).cx;
			}
		}

		// enumerate all data items, either from the table or 
		// the list control
		POSITION pos = pTable ? pTable->GetRowHeadPosition() : NULL;
		int iMaxItems = rctrlList.GetItemCount();
		int iRow = 0;

		// continue looping as long as the position is not NULL (for table)
		// or the count is less than the number of items (for non-table)
		while (pTable ? (pos != NULL) : (iRow < iMaxItems))
		{
			// row pointer is stored in data of column 0 for list control, and
			// is explicitly provided in enumerating the table
			const COrcaRow* pRow = NULL;
			if (pTable)
			{
				pRow = pTable->GetNextRow(pos);
			}
			else 
				pRow = reinterpret_cast<COrcaRow*>(rctrlList.GetItemData(iRow));

			if (pRow)
			{
				// check every column where the mask bit is set
				for (int iColumn = 0; iColumn < m_cColumns; iColumn++)
				{
					if (dwMask & (1 << iColumn))
					{
						const CString* pstrText = NULL;
						
						// if a table is provided, grab the string from the row
						// explicitly. If a table is not provided, use the abstraction
						// of GetOutputText to handle scenarios where the pRow pointer
						// is not actually a row.
						if (pTable)
						{
							const COrcaData* pData = pRow->GetData(iColumn);
							if (pData)
								pstrText = &(pData->GetString());
						}
						else
							pstrText = GetOutputText(pRow, iColumn);
					
						// if there is text in this cell, get the horizontal extent
						// and check against the maximum
						if (pstrText)
						{
							int iWidth = pDC->GetTextExtent(*pstrText).cx;
							if (iWidth > rgiMaxWidths[iColumn])
								rgiMaxWidths[iColumn] = iWidth;
						}
					}
				}
			}

			// increment row counter in non-table case.
			iRow++;
		}

		// select away the font to free resources
		pDC->SelectObject(static_cast<CFont *>(NULL));
		rctrlList.ReleaseDC(pDC);
	}
	
	// add border amount to each column, plus bar margin for first.
	for (iColumn=0; iColumn < m_cColumns; iColumn++)
	{
		rgiMaxWidths[iColumn] += (2*CELL_BORDER)+((m_bDrawIcons && iColumn == 0) ? g_iMarkingBarMargin : 0);
	}		  	
}

///////////////////////////////////////////////////////////
// retrieve maximum width for a column
int COrcaListView::GetMaximumColumnWidth(int iColumn) const
{
	int rgiColumnWidths[32];

	GetAllMaximumColumnWidths(NULL, rgiColumnWidths, 1 << iColumn);

	return rgiColumnWidths[iColumn];
}


///////////////////////////////////////////////////////////
// notification messages from the list view and header control
BOOL COrcaListView::OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult )
{
	NMHEADER* pHDR = reinterpret_cast<NMHEADER*>(lParam);
	switch (pHDR->hdr.code)
	{
	case HDN_DIVIDERDBLCLICK:
	{
		// get list control
		CListCtrl& rctrlList = GetListCtrl();

		int iMaxWidth = GetMaximumColumnWidth(pHDR->iItem);
		if (iMaxWidth > 0x7FFF)
			iMaxWidth = 0x7FFF;
		rctrlList.SetColumnWidth(pHDR->iItem, iMaxWidth);
		return 1;
	}
	default:
		break;
	}
	return CListView::OnNotify(wParam, lParam, pResult);
}

///////////////////////////////////////////////////////////
// DrawItem
void COrcaListView::DrawItem(LPDRAWITEMSTRUCT pDraw)
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	CDC dc;
	dc.Attach(pDraw->hDC);
	if (m_pfDisplayFont)
		dc.SelectObject(m_pfDisplayFont);

	// loop through all the columns
	void* pRowData = reinterpret_cast<void*>(rctrlList.GetItemData(pDraw->itemID));
	ASSERT(pRowData);
	if (!pRowData)
		return;

	int iTextOut = pDraw->rcItem.left;		// position to place first word (in pixels)

	RECT rcArea;
	rcArea.top = pDraw->rcItem.top;
	rcArea.bottom = pDraw->rcItem.bottom;
	
	OrcaTransformAction iRowTransformed = GetItemTransformState(pRowData);
	for (int i = 0; i < m_cColumns; i++)
	{
		
		int iColumnWidth = rctrlList.GetColumnWidth(i);
		// area box to redraw
		rcArea.left = iTextOut;
		iTextOut += iColumnWidth;
		rcArea.right = iTextOut;
		COLORREF clrRect = 0;
		CBrush *pbrshRect = NULL;
		
		// if we are in the focused state, set yellow
		if ((i == m_nSelCol) && (this == GetFocus()) && (pDraw->itemState & ODS_FOCUS))
		{
			dc.SetTextColor(m_clrFocusedT);
			pbrshRect = &m_brshFocused;
			clrRect = m_clrFocused;
		}
		// if we are selected, set blue
		else if ( (pDraw->itemState & ODS_SELECTED) )
		{
			dc.SetTextColor(m_clrSelectedT);
			pbrshRect = &m_brshSelected;
			clrRect = m_clrSelected;
		}
		else	// otherwise normal state
		{
			dc.SetTextColor(m_clrNormalT);
			pbrshRect = &m_brshNormal;
			clrRect = m_clrNormal;
		}

		// fill the background with the right color, we can draw a 
		// border around transformed cells. Row transforms override this, so
		// no need to do this check in that case.
		if ((iRowTransformed == iTransformNone) && (GetCellTransformState(pRowData, i) == iTransformChange))
		{
			RECT rcBorder = rcArea;
			if (i)
				rcBorder.left+=1;
			rcBorder.bottom-=1;
			dc.SelectObject(m_penTransform);
			dc.SelectObject(pbrshRect);
			dc.Rectangle(&rcBorder);
			dc.SelectObject((CPen *)NULL);
			dc.SelectObject((CBrush *)NULL);
		}
		else
		{
			dc.FillSolidRect(&rcArea, clrRect);
		}

		// draw the "marking bars" on the left of the table list
		if (m_bDrawIcons)
		{
			// incrementing the width of these bars requires increasing
			// g_iMarkingBarMargin
			if (ContainsValidationErrors(pRowData))
			{
				RECT rcBlockArea = rcArea;
				rcBlockArea.left = pDraw->rcItem.left + 3;
				rcBlockArea.right = pDraw->rcItem.left + 6;
				dc.FillSolidRect(&rcBlockArea, RGB(255, 0, 0));
			}

			if (ContainsTransformedData(pRowData))
			{
				RECT rcBlockArea = rcArea;
				rcBlockArea.left = pDraw->rcItem.left + 8;
				rcBlockArea.right = pDraw->rcItem.left + 11;
				dc.FillSolidRect(&rcBlockArea, RGB(0, 128, 0));
			}
		}

		// if there is an error
		switch (GetErrorState(pRowData, i)) {
		case ShadowError:
			dc.SetTextColor(RGB(255, 128, 128));
			break;
		case Error:	
			dc.SetTextColor(RGB(255, 0, 0)); 
			break;
		case Warning:
			dc.SetTextColor(RGB(255, 96, 0));
			break;
		default:
			break;
		};

		RECT rcTextArea = rcArea;
		rcTextArea.left = rcArea.left + (m_bDrawIcons ? g_iMarkingBarMargin : 0) + CELL_BORDER;
		rcTextArea.right = rcArea.right - CELL_BORDER;
		dc.DrawText(*GetOutputText(pRowData, i), &rcTextArea, DT_LEFT|DT_VCENTER|DT_NOPREFIX|DT_SINGLELINE|DT_END_ELLIPSIS);

		// and draw column transform
		if (GetColumnTransformState(i) == iTransformAdd)
		{
			RECT rcBorder = rcArea;
			if (i)
				rcBorder.left+=1;
			rcBorder.bottom-=1;
			dc.SelectObject(m_penTransform);
			dc.MoveTo(rcBorder.left, rcBorder.top);
			dc.LineTo(rcBorder.left, rcBorder.bottom);
			dc.MoveTo(rcBorder.right, rcBorder.top);
			dc.LineTo(rcBorder.right, rcBorder.bottom);
			dc.SelectObject((CPen *)NULL);
		}
	}

	// after the text is drawn, strikethrough in transform color for dropped rows
	if (iRowTransformed == iTransformDrop)
	{
		dc.SelectObject(m_penTransform);
		dc.MoveTo(pDraw->rcItem.left,  (pDraw->rcItem.top+pDraw->rcItem.bottom)/2);
		dc.LineTo(pDraw->rcItem.right, (pDraw->rcItem.top+pDraw->rcItem.bottom)/2);
		dc.SelectObject((CPen *)NULL);
	}
	else if (iRowTransformed == iTransformAdd)
	{
		RECT rcBorder = pDraw->rcItem;
		rcBorder.bottom-=1;
		CBrush brshNull;
		brshNull.CreateStockObject(NULL_BRUSH);
		dc.SetBkMode(TRANSPARENT);
		dc.SelectObject((CBrush*)&brshNull);
		dc.SelectObject(m_penTransform);
		dc.Rectangle(&rcBorder);
		dc.SelectObject((CPen *)NULL);
		dc.SelectObject((CBrush *)NULL);
	}

	dc.SelectObject((CFont *)NULL);
	dc.Detach();
}	// end of DrawItem

const CString* COrcaListView::GetOutputText(const void *rowdata, int iColumn) const
{
	return NULL;
}

int COrcaListView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	lpCreateStruct->style |= WS_CLIPCHILDREN;
	if (CListView::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	CString strFacename = ::AfxGetApp()->GetProfileString(_T("Font"), _T("Name"));
	int iFontSize = ::AfxGetApp()->GetProfileInt(_T("Font"),_T("Size"), 0);
	if (strFacename.IsEmpty() || iFontSize == 0) 
	{
		m_pfDisplayFont = NULL;
	} 
	else
	{
		m_pfDisplayFont = new CFont();
		m_pfDisplayFont->CreatePointFont( iFontSize, strFacename);
	}

	// get list control and subclass to replace layout code for item
	// height determination
	CListCtrl& rctrlList = GetListCtrl();

	HWND hHeader = ListView_GetHeader(rctrlList.GetSafeHwnd());
	if (hHeader)
		m_ctrlHeader.SubclassWindow(hHeader);
	
	return 0;
}

void COrcaListView::SwitchFont(CString name, int size)
{
	if (m_pfDisplayFont)
		delete m_pfDisplayFont;
	m_pfDisplayFont = new CFont();
	int iLogicalUnits = MulDiv(size, GetDC()->GetDeviceCaps(LOGPIXELSY), 720);
	m_pfDisplayFont->CreateFont(
		-iLogicalUnits,       // logical height of font 
 		0,                  // logical average character width 
 		0,                  // angle of escapement 
 		0,                  // base-line orientation angle 
 		FW_NORMAL,          // FW_DONTCARE??, font weight 
 		0,                  // italic attribute flag 
 		0,                  // underline attribute flag 
	 	0,                  // strikeout attribute flag 
 		0,                  // character set identifier
 		OUT_DEFAULT_PRECIS, // output precision
 		0x40,               // clipping precision (force Font Association off)
 		DEFAULT_QUALITY,    // output quality
 		DEFAULT_PITCH,      // pitch and family
		name);              // pointer to typeface name string

	m_ctrlHeader.SetFont(m_pfDisplayFont, TRUE);
	RecalculateItemHeight();
}


void COrcaListView::RecalculateItemHeight()
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	TEXTMETRIC tm;
	// select the font into a window DC retrieved
	CDC* pDC = rctrlList.GetDC();
	pDC->SelectObject(m_pfDisplayFont);
	
	// grab text information
	pDC->GetTextMetrics(&tm);
	
	// select away the font to free resources
	pDC->SelectObject(static_cast<CFont *>(NULL));
	rctrlList.ReleaseDC(pDC);
	
	// determine the optimal height for a header row
	m_iRowHeight = ((tm.tmHeight + tm.tmExternalLeading + GetSystemMetrics(SM_CYBORDER)) & 0xFFFE) - 1;
	m_ctrlHeader.SetHeight(m_iRowHeight);

	// now we force the CListCtrl to change its row height. Because its fixed owner draw, 
	// it only asks for item sizes on initialization. It doesn't do it on a WM_SIZE message
	// either, only on WM_WINDOWPOSCHANGED. So we fire off two messages. In the first, we shrink
	// the window by one pixel, but deny a redraw. Then we resize back to what it is supposed to
	// be and ask for a redraw.
	// get current window size
	CRect rectListCtrl;
	rctrlList.GetWindowRect(&rectListCtrl);
	rctrlList.SetWindowPos(this, 0, 0, rectListCtrl.Width(), rectListCtrl.Height()-1, 
		SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW);
	rctrlList.SetWindowPos(this, 0, 0, rectListCtrl.Width(), rectListCtrl.Height(), 
		SWP_NOZORDER | SWP_NOMOVE);
};

void COrcaListView::GetFontInfo(LOGFONT *data)
{
	ASSERT(data);
	if (m_pfDisplayFont)
		m_pfDisplayFont->GetLogFont(data);
	else
		GetListCtrl().GetFont()->GetLogFont(data);
}


afx_msg void COrcaListView::MeasureItem ( LPMEASUREITEMSTRUCT lpMeasureItemStruct )
{
	lpMeasureItemStruct->itemHeight = m_iRowHeight;
}

void COrcaListView::OnInitialUpdate() 
{
	CListView::OnInitialUpdate();
	
	// try to set full row select
	// add gridlines and full row select
	GetListCtrl().SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES);

	m_clrSelected =	::AfxGetApp()->GetProfileInt(_T("Colors"),_T("SelectBg"), RGB(0,0,255));
	m_clrFocused = ::AfxGetApp()->GetProfileInt(_T("Colors"),_T("FocusBg"), RGB(255,255,0));
	m_clrNormal = ::AfxGetApp()->GetProfileInt(_T("Colors"),_T("NormalBg"), RGB(255,255,255));
	m_clrSelectedT =	::AfxGetApp()->GetProfileInt(_T("Colors"),_T("SelectFg"), RGB(255,255,255));
	m_clrFocusedT = ::AfxGetApp()->GetProfileInt(_T("Colors"),_T("FocusFg"), RGB(0,0,0));
	m_clrNormalT = ::AfxGetApp()->GetProfileInt(_T("Colors"),_T("NormalFg"), RGB(0,0,0));
	m_brshNormal.Detach();
	m_brshNormal.CreateSolidBrush(m_clrNormal);
	m_brshSelected.CreateSolidBrush(m_clrSelected);
	m_brshFocused.CreateSolidBrush(m_clrFocused);
	m_penTransform.CreatePen(PS_SOLID | PS_INSIDEFRAME, 2, m_clrTransform);
	GetListCtrl().SetBkColor(m_clrNormal);

	m_ctrlHeader.SetFont(m_pfDisplayFont, TRUE);
	RecalculateItemHeight();
}

void COrcaListView::SetBGColors(COLORREF norm, COLORREF sel, COLORREF focus)
{
	CListCtrl& rctrlList = GetListCtrl();
	rctrlList.SetBkColor(norm);
	m_clrNormal = norm;
	m_clrSelected = sel;
	m_clrFocused = focus;
	m_brshNormal.Detach();
	m_brshNormal.CreateSolidBrush(m_clrNormal);
	m_brshSelected.CreateSolidBrush(m_clrSelected);
	m_brshFocused.CreateSolidBrush(m_clrFocused);
}

void COrcaListView::SetFGColors(COLORREF norm, COLORREF sel, COLORREF focus)
{
	CListCtrl& rctrlList = GetListCtrl();
	rctrlList.SetBkColor(norm);
	m_clrNormalT = norm;
	m_clrSelectedT = sel;
	m_clrFocusedT = focus;	
}

// these functions emulate VC6.0 functionality in VC5.0 or earlier
// these position pointers are NOT compatible with CListCtrl POSITION
// values.
POSITION COrcaListView::GetFirstSelectedItemPosition( ) const 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();
#if _MFC_VER >= 0x0600
	return rctrlList.GetFirstSelectedItemPosition();
#else

	if (rctrlList.GetSelectedCount() == 0) return NULL;
	int iMaxItems = rctrlList.GetItemCount();
	for (int i=0; i < iMaxItems; i++) {
		if (rctrlList.GetItemState(i, LVIS_SELECTED))
		{
			return (POSITION)(i+1);
		};
	};
	return NULL;
#endif
}

int COrcaListView::GetNextSelectedItem( POSITION& pos ) const 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

#if _MFC_VER >= 0x0600
	return rctrlList.GetNextSelectedItem(pos);
#else

	int iSelItem = (int)pos - 1;
	int iMaxItems = rctrlList.GetItemCount();
	for (int i=(int)pos; i < iMaxItems; i++) {
		if (rctrlList.GetItemState(i, LVIS_SELECTED))
		{
			pos = (POSITION)(i+1);
			return iSelItem;
		};
	};
	pos = NULL;
	return iSelItem;	
#endif
}

BOOL COrcaListView::PreCreateWindow(CREATESTRUCT& cs) 
{												   
	cs.style = (cs.style | LVS_REPORT | LVS_OWNERDRAWFIXED | LVS_SHOWSELALWAYS) & ~LVS_ICON;
	return CListView::PreCreateWindow(cs);
}

///////////////////////////////////////////////////////////////////////
// OnUpdateErrors
// GetErrorState() is virtual, so the same check will work for both
// the list view and the table view. 
void COrcaListView::OnUpdateErrors(CCmdUI* pCmdUI) 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get the row and data
	int iFocusedItem = GetFocusedItem();
	if ((iFocusedItem < 0) || (m_nSelCol < 0))
		pCmdUI->Enable(FALSE);
	else
	{
		void* pData = reinterpret_cast<void *>(rctrlList.GetItemData(iFocusedItem));
		ASSERT(pData);
		pCmdUI->Enable(OK != GetErrorState(pData, m_nSelCol));
	};
}

///////////////////////////////////////////////////////////////////////
// GetFocusedItem()
// searches the list for the item which currently has the focus
const int COrcaListView::GetFocusedItem() const
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	int iNumItems = rctrlList.GetItemCount();

	for (int i=0; i < iNumItems; i++) {
		if (rctrlList.GetItemState(i, LVIS_FOCUSED) != 0)
			return i;
	}
	return -1;
}

///////////////////////////////////////////////////////////////////////
// each row in the list view is owner draw and fills the entire client
// rectangle for the item. The only background that needs to be erased
// is what is below and to the right of the item areas.
afx_msg BOOL COrcaListView::OnEraseBkgnd( CDC* pDC )
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	
	// determine client window size
	RECT rClientWnd;
	GetClientRect(&rClientWnd);

	// calculate how far over the control will draw
	int iColumnWidth = 0;
	for (int i = 0; i < m_cColumns; i++)
		iColumnWidth += rctrlList.GetColumnWidth(i);

	// if there is still extra space on the right, draw there
	if (iColumnWidth < rClientWnd.right)
	{
		rClientWnd.left = iColumnWidth;

		// Set brush to desired background color and fill the space
		pDC->FillRect(&rClientWnd, &m_brshNormal);
	}

	// check for extra space on the bottom
	int iHeight = (rctrlList.GetItemCount()-GetScrollPos(SB_VERT))*m_iRowHeight;

	// reset the rectangle to paint below the active items, but
	// only as far over as the items would have drawn
	if (iHeight < rClientWnd.bottom)
	{
		rClientWnd.left = 0;
		rClientWnd.right = iColumnWidth;
		rClientWnd.top = iHeight;

		// Set brush to desired background color and fill the space
		pDC->FillRect(&rClientWnd, &m_brshNormal);
	}

	return 1;
}



/////////////////////////////////////////////////////////////////////////////
// Due to a bug in the header control, it doesn't correctly size itself
// when the font changes. Thus this control subclasses the control and 
// overrides the layout code to determine the correct height
BEGIN_MESSAGE_MAP(COrcaHeaderCtrl, CHeaderCtrl)
	ON_MESSAGE(HDM_LAYOUT, OnLayout)
END_MESSAGE_MAP()

LRESULT COrcaHeaderCtrl::OnLayout(WPARAM wParam, LPARAM lParam)
{
	LRESULT lRes = DefWindowProc(HDM_LAYOUT, wParam, lParam);
	reinterpret_cast<HDLAYOUT*>(lParam)->pwpos->cy = m_iDesiredHeight;
	reinterpret_cast<HDLAYOUT*>(lParam)->prc->top = m_iDesiredHeight;
	return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\orcadoc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// OrcaDoc.h : interface of the COrcaDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_ORCADOC_H__C3EDC1AE_E506_11D1_A856_006097ABDE17__INCLUDED_)
#define AFX_ORCADOC_H__C3EDC1AE_E506_11D1_A856_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "msiquery.h"
#include "Table.h"
#include "valpane.h"

#define MAX_SUMMARY 19

enum DocType
{
	iDocNone,
	iDocDatabase,
};

enum OrcaDocHints {
	HINT_NULL_UPDATE,
	HINT_RELOAD_ALL,
	HINT_ADD_TABLE,
	HINT_ADD_TABLE_QUIET,

	HINT_ADD_ROW,
		// adds a row to the UI control. Refreshes window to show new row and updates status bar with new row count.
		// The schema must match the current control UI schema. pHint is COrcaRow* to the new row.
		
	HINT_ADD_ROW_QUIET,
		// adds a row to the UI control, but does not refresh window or status bar. Used for bulk-adds (such as paste)
		// where the window will be refreshed later. The schema must match the current control UI schema. 
		// pHint is COrcaRow* to the new row.

	HINT_DROP_TABLE,
	HINT_DROP_ROW,
	HINT_REDRAW_ALL,
	HINT_COMMIT_CHANGES,

	HINT_SET_ROW_FOCUS,
		// ensures that a row is visible in the window, scrolling if necessary. pHint is COrcaRow* to a 
		// row that must exist in the current table

	HINT_SET_COL_FOCUS,
		// ensure that column N of the current table is in the viewscreen, scrolling if necessary. pHint is 
		// integer column number
	
	HINT_CHANGE_TABLE,
		// changes from one selected table to another. Completely destroys table view UI and reloads
		// with new table data. Updates status bar for table name and row count. Saves existing column
		// widths if a table is selected. pHint is new COrcaTable* to new table.
	
	HINT_TABLE_DATACHANGE,
		// erases and reloads all rows in the table without reloading the column information. The schema must
		// match the existing objects schema. pHint is COrcaTable* to the target table
		
	HINT_TABLE_REDEFINE,
		// erases and reloads all columns and rows in the table. pHint is COrcaTable* to the target table

	HINT_CELL_RELOAD,
		// refreshes the UI for a row from the COrcaRow object and redraws that item in the list view. 
		// pHint is COrcaRow* to the row to be refreshed

	HINT_REDRAW_TABLE,
		// redraws a single cell in the Table List and ensures that it is visible. pHint is COrcaTabl* to the
		// target table

	HINT_TABLE_DROP_ALL,

	HINT_ADD_VALIDATION_ERROR,
		// adding a validation error result to the current database. pHint is CValidationError*, must be 
		// copied by any table that wants to persist the data.
	
	HINT_CLEAR_VALIDATION_ERRORS,
		// the database is about to be re-validated, dispose of any stored validation results. pHint is
		// ignored.
};

class COrcaDoc : public CDocument
{
protected: // create from serialization only
	COrcaDoc();
	DECLARE_DYNCREATE(COrcaDoc)

// Attributes
public:
	DocType m_eiType;
	CTypedPtrList<CObList, COrcaTable*> m_tableList;

	// summary information
	CString m_strTitle;
	CString m_strSubject;
	CString m_strAuthor;
	CString m_strLastSaved;
	CString m_strKeywords;
	CString m_strComments;
	CString m_strPlatform;
	CString m_strLanguage;
	CString m_strProductGUID;
	int m_nSchema;
	int m_nFilenameType;
	int m_nSecurity;
	CString m_strICEsToRun;

// Operations
public:
	static bool WriteStreamToFile(MSIHANDLE hRec, const int iCol, CString &strFilename);

	void DestroyTableList();
	UINT DropOrcaTable(COrcaTable* pTable);
	UINT AddRow(COrcaTable* pTable, CStringList* pstrDataList);
	bool DropRow(COrcaTable* pTable, COrcaRow* pRow);
	UINT WriteBinaryCellToFile(COrcaTable* pTable, COrcaRow* pRow, UINT iCol, CString strFile);
	bool ExportTable(const CString* tablename, const CString *dirname);

	inline bool DoesTransformGetEdit() const { return (m_hTransformDB != 0); };
	inline bool TargetIsReadOnly() { return DoesTransformGetEdit() ? m_bTransformReadOnly : m_bReadOnly; }; 

	// database handle functions. Both relative (target/non-target) and absolute (original/transformed) are
	// available. All return 0 if not available.
	inline MSIHANDLE GetOriginalDatabase() const { return m_hDatabase; };
	inline MSIHANDLE GetTransformedDatabase() const { return m_hTransformDB; };
	inline MSIHANDLE GetTargetDatabase() const { return DoesTransformGetEdit() ? m_hTransformDB : m_hDatabase; };
	
	inline bool IsRowInTargetDB(const COrcaRow *pRow) const {
		return ((DoesTransformGetEdit() &&  (pRow->IsTransformed() != iTransformDrop)) ||
				(!DoesTransformGetEdit() && (pRow->IsTransformed() != iTransformAdd))); };
	inline bool IsColumnInTargetDB(const COrcaColumn *pColumn) const {
		return ((DoesTransformGetEdit() &&  (pColumn->IsTransformed() != iTransformDrop)) ||
				(!DoesTransformGetEdit() && (pColumn->IsTransformed() != iTransformAdd))); };

	void ApplyTransform(const CString strFilename, bool fReadOnly);
	void ApplyPatch(const CString strFilename);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COrcaDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual void SetTitle(LPCTSTR lpszTitle);
	virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU);
	//}}AFX_VIRTUAL

	void SetModifiedFlag(BOOL fModified);


// Implementation
public:
	virtual ~COrcaDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	COrcaTable* CreateAndLoadTable(MSIHANDLE hDatabase, CString strTable);
	COrcaTable* CreateAndLoadNewlyAddedTable(CString strTable);
	UINT ReadSummary(MSIHANDLE hSource);
	UINT PersistSummary(MSIHANDLE hTarget, bool bCreate);

// Generated message map functions
public:	
	COrcaTable* FindTable(const CString strTable, odlOrcaDataLocation odlLocation) const;
	COrcaTable* FindAndRetrieveTable(CString strTable);

	void RefreshTableAfterImport(CString strTable);
	bool FillTableList(CStringList *newlist, bool fShadow, bool fTargetOnly) const;

	//{{AFX_MSG(COrcaDoc)
	afx_msg void OnApplyTransform();
	afx_msg void OnFileOpen();
	afx_msg void OnFileSave();
	afx_msg void OnFileSaveAs();
	afx_msg void OnFileSaveTransformed();
	afx_msg void OnSummaryInformation();
	afx_msg void OnValidator();
	afx_msg void OnMergeMod();
	afx_msg void OnUpdateMergeMod(CCmdUI* pCmdUI);
	afx_msg void OnFileClose();
	afx_msg void OnTableAdd();
	afx_msg void OnRowAdd();
	afx_msg void OnTableDrop();
	afx_msg void OnFileNew();
	afx_msg void OnTablesImport();
	afx_msg void OnNewTransform();
	afx_msg void OnEditTransform();
	afx_msg void OnEditDatabase();
	afx_msg void OnGenerateTransform();
	afx_msg void OnTransformProperties();
	afx_msg void OnCloseTransform();
	afx_msg void OnTransformViewPatch();
	afx_msg void OnUpdateFilePrint(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTableAdd(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTableDrop(CCmdUI* pCmdUI);
	afx_msg void OnUpdateValidator(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRowAdd(CCmdUI* pCmdUI);
	afx_msg void OnUpdateSummaryInformation(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileClose(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileSave(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileSaveAs(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileSaveTransformed(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTablesExport(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTablesImport(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNewTransform(CCmdUI* pCmdUI);
	afx_msg void OnUpdateApplyTransform(CCmdUI* pCmdUI);
	afx_msg void OnUpdateGenerateTransform(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditTransform(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditDatabase(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTransformProperties(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTransformViewPatch(CCmdUI* pCmdUI);
	afx_msg void OnUpdateCloseTransform(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool m_bReadOnly;
	bool m_bTransformReadOnly;

	CString m_strCUBFile;
	CString m_strStoredModuleName;
	CString m_strStoredModuleLanguage;
	bool m_bShowValInfo;

	MSIHANDLE m_hDatabase;	// handle to active MSI database or Merge Module

	// transform information
	bool m_bTransformModified;
	bool m_bTransformIsPatch;
	MSIHANDLE m_hTransformDB;	// handle to temporary transformed DB
	CString m_strTransformTempDB;
	CString m_strTransformFile;

	CStringList m_lstPatchFiles;

	DWORD m_dwTransformValFlags;
	DWORD m_dwTransformErrFlags;

	// private worker functions
	BOOL OpenDocument(LPCTSTR lpszPathName, bool bReadOnly);

	// private functions for maintaining data lists
	UINT BuildTableList(bool fNoLazyDataLoad);

	// private transform functions
	void NewTransform(bool fSetTitle);
	void CloseTransform();
	int  GenerateTransform();

	UINT PersistTables(MSIHANDLE hPersist, MSIHANDLE hSource, bool bCommit);
	bool ValidateTransform(const CString strTransform, int& iDesiredFailureFlags);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ORCADOC_H__C3EDC1AE_E506_11D1_A856_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\outils.cpp ===
#include "..\common\utils.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\otrace.cpp ===
#include "..\common\trace.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\orca_res.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Orca.rc
//
#define IDD_ABOUTBOX                    100
#define ID_PAGE_FONT                    106
#define IDR_MAINFRAME                   128
#define IDR_ORCATYPE                    129
#define IDR_MAINFRAME2                  129
#define IDD_HELP_DIALOG                 131
#define IDD_SUMMARY_INFORMATION         132
#define IDD_VALIDATION                  134
#define IDD_ADD_TABLE                   135
#define IDD_ADD_ROW                     136
#define IDR_POPUP_MENU                  138
#define IDD_EXPORT_TABLE                138
#define IDD_TABLE_ERROR                 139
#define IDD_CELL_ERROR                  140
#define IDD_BINARY_EDIT                 141
#define IDD_PAGE_VALIDATION             142
#define IDD_PAGE_PATHS                  143
#define IDB_KEY                         145
#define IDD_DLGPREVIEW                  148
#define IDB_PRVWIMAGES                  150
#define IDB_REQUIRED                    151
#define IDD_IMPORT_TABLE                152
#define IDR_CELL_POPUP                  153
#define IDR_LIST_POPUP                  154
#define IDD_MERGE                       155
#define IDD_CONFIGUREMSM                156
#define IDD_MERGERESULTS                157
#define IDD_PAGE_MSM                    158
#define IDD_MERGEFAILURE                159
#define IDD_TRANSFORM_PROPERTIES        160
#define IDR_HEADER_POPUP                161
#define IDD_PAGE_TRANSFORM              162
#define IDC_OPEN                        1002
#define IDC_TITLE                       1003
#define IDC_SUBJECT                     1004
#define IDC_PLATFORM                    1005
#define IDC_COMMENTS                    1006
#define IDC_TYPE                        1007
#define IDC_LANGUAGES                   1008
#define IDC_OUTPUT                      1008
#define IDC_AUTHOR                      1009
#define IDC_EVALUATION_FILE             1009
#define IDC_KEYWORDS                    1010
#define IDC_GO                          1010
#define IDC_PRODUCTID                   1011
#define IDC_LIST_TABLES                 1011
#define IDC_SCHEMA                      1012
#define IDC_WRITETOFILE                 1013
#define IDC_SECURITY                    1014
#define IDC_VALMINOR                    1014
#define IDC_SHOW_INFO                   1015
#define IDC_VALUPDATE                   1015
#define IDC_OUTPUT_DIR                  1016
#define IDC_BROWSE                      1017
#define IDC_SELECT_ALL                  1018
#define IDC_TABLE_LIST                  1019
#define IDC_TABLE                       1020
#define IDC_ERRORS                      1021
#define IDC_WARNINGS                    1022
#define IDC_ICE                         1023
#define IDC_DESC                        1028
#define IDC_WEB_HELP                    1029
#define IDC_PATH                        1030
#define IDC_ACTION                      1032
#define IDC_CLEAR_ALL                   1033
#define IDC_INVERT                      1034
#define IDC_FONTNAME                    1036
#define IDC_CHFONT                      1037
#define IDC_COLORSEL                    1040
#define IDC_COLORFOCUS                  1041
#define IDC_COLORNORM                   1042
#define IDC_CHECK2                      1043
#define IDC_SUPPRESSINFO                1043
#define IDC_ADMIN                       1043
#define IDC_VALLANGUAGE                 1043
#define IDC_SUPPRESSWARNING             1044
#define IDC_VALPRODUCT                  1044
#define IDC_TEXTNORM                    1045
#define IDC_VALDIRB                     1046
#define IDC_ORCADATB                    1046
#define IDC_EXPORTDIR                   1047
#define IDC_VALDIR                      1048
#define IDC_ORCADAT                     1048
#define IDC_VALUPGRADE                  1048
#define IDC_NORMSAMP                    1049
#define IDC_RUNICE                      1049
#define IDC_VALLESS                     1049
#define IDC_SELSAMP                     1050
#define IDC_VALEQUAL                    1050
#define IDC_FOCSAMP                     1051
#define IDC_VALGREATER                  1051
#define IDC_TEXTSEL                     1052
#define IDC_TEXTFOCUS                   1053
#define IDC_CHECK1                      1054
#define IDC_WARNSUMM                    1054
#define IDC_CASESENSITIVE               1054
#define IDC_COMPRESSED                  1054
#define IDC_ADDEXISTINGROW              1054
#define IDC_PREVIEW                     1055
#define IDC_DELMISSINGROW               1055
#define IDC_ADDEXISTINGTABLE            1056
#define IDC_DIALOGLST                   1057
#define IDC_DELMISSINGTABLE             1057
#define IDC_UPDATEMISSINGROW            1058
#define IDC_CHANGECODEPAGE              1059
#define IDC_PREVIOUS                    1060
#define IDC_NEXT                        1061
#define IDC_EXPORTDIRB                  1064
#define IDC_TABLELIST                   1065
#define IDC_REPLACE                     1066
#define IDC_MERGE                       1067
#define IDC_SKIP                        1068
#define IDC_IMPORT                      1070
#define IDC_SHORT                       1070
#define IDC_CLEARRESULTS                1071
#define IDC_LONG                        1071
#define IDC_ICES                        1072
#define IDC_VERSIONSTRING               1073
#define IDC_CLIPBOARD                   1075
#define IDC_COMPILETEXT                 1076
#define IDC_COMPILEBOX                  1077
#define IDC_FEXTRACTFILES               1078
#define IDC_LANGUAGE                    1079
#define IDC_MAINFEATURE                 1080
#define IDC_MODULE                      1081
#define IDC_MODULEBROWSE                1082
#define IDC_ADDFEATURE                  1083
#define IDC_EXTRACTPATH                 1084
#define IDC_EXTRACTCAB                  1085
#define IDC_FILESBROWSE                 1086
#define IDC_CABBROWSE                   1087
#define IDC_ROOTDIR                     1088
#define IDC_FEXTRACTCAB                 1089
#define IDC_FILESTATIC                  1090
#define IDC_CABSTATIC                   1091
#define IDC_ITEMLIST                    1092
#define IDC_DESCRIPTION                 1093
#define IDC_EDITTEXT                    1094
#define IDC_EDITNUMBER                  1095
#define IDC_EDITCOMBO                   1096
#define IDC_FUSEDEFAULT                 1097
#define IDC_CONFIGUREMODULE             1098
#define IDC_FEXTRACTIMAGE               1099
#define IDC_IMAGESTATIC                 1100
#define IDC_IMAGEBROWSE                 1101
#define IDC_EXTRACTIMAGE                1102
#define IDC_MERGERESULTS                1103
#define IDC_MEMORY                      1104
#define IDC_ALWAYSCONFIG                1105
#define IDC_WATCHLOG                    1106
#define IDC_USELFN                      1107
#define IDC_MERGEFAILURE                1108
#define IDC_VALMAJOR                    1109
#define IDC_TRANSFORMLIST               1110
#define IDC_FORCECOLUMNS                1111
#define IDC_WARNINGSTATIC               1112
#define IDC_ERRORSTATIC                 1113
#define IDC_IGNOREERRORS                1114
#define IDC_RESPECTERRORS               1115
#define IDC_TRANSVALPROMPT              1116
#define IDC_TRANSVALIGNORE              1117
#define IDC_TRANSVALRESPECT             1118
#define IDC_VERSTATIC1                  1119
#define IDC_VERSTATIC2                  1120
#define IDC_VERSTATIC3                  1121
#define IDC_VERSTATIC4                  1122

#define ID_VIEW_DECIMAL_HDR             32766
#define ID_VIEW_HEX_HDR                 32767
#define ID_VIEW_DECIMAL                 32768
#define ID_VIEW_HEX                     32769
#define ID_TOOLS_MERGEMOD               32770
#define ID_VALIDATOR                    32775
#define ID_SUMMARY_INFORMATION          32776
#define ID_TABLE_ADD                    32777
#define ID_ROW_ADD                      32779
#define ID_MENUITEM32780                32780
#define ID_TABLE_DROP                   32781
#define ID_ROW_DROP                     32782
#define ID_FIND                         32783
#define IDM_ADD_TABLE                   32784
#define IDM_DROP_TABLE                  32785
#define IDM_DROP_ROW                    32787
#define IDM_PROPERTIES                  32788
#define IDM_ERRORS                      32789
#define ID_TABLES_EXPORT                32790
#define ID_TABLES_IMPORT                32791
#define IDM_EXPORT_TABLES               32792
#define ID_EDIT_COPY_ROW                32793
#define ID_EDIT_CUT_ROW                 32794
#define ID_EDIT_PASTE_ROW               32795
#define ID_TOOLS_OPTIONS                32796
#define ID_TOOLS_DLGPRV                 32797
#define IDM_IMPORT_TABLES               32798
#define ID_EDIT_FINDNEXT                32801
#define ID_TABLE_COUNT                  32802
#define ID_TABLE_NAME                   32803
#define ID_COLUMN_TYPE                  32804
#define ID_TOOLS_APPLYTRANSFORM         32806
#define ID_TRANSFORM_NEWTRANSFORM       32808
#define ID_TRANSFORM_APPLYTRANSFORM     32809
#define ID_TRANSFORM_GENERATETRANSFORM  32810
#define ID_TRANSFORM_TRANSFORMPROPERTIES 32812
#define ID_TRANSFORM_CLOSETRANSFORM     32814
#define ID_TRANSFORM_VIEWPATCH          32815
#define ID_FILE_SAVE_TRANSFORMED        32816
#define ID_VIEW_VALPANE                 32817

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        163
#define _APS_NEXT_COMMAND_VALUE         32818
#define _APS_NEXT_CONTROL_VALUE         1123
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\orcalstv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_ORCALISTVIEW_H__68AFD211_2594_11D2_8888_00A0C981B015__INCLUDED_)
#define AFX_ORCALISTVIEW_H__68AFD211_2594_11D2_8888_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OrcaListView.h : header file
//

#include "OrcaDoc.h"


/////////////////////////////////////////////////////////////////////////////
// Due to a bug in the header control, it doesn't correctly size itself
// when the font changes. Thus this control subclasses the control and 
// overrides the layout code to determine the correct height
class COrcaHeaderCtrl : public CHeaderCtrl
{
public:
	explicit COrcaHeaderCtrl(int iHeight) : CHeaderCtrl(), m_iDesiredHeight(iHeight) { };
	inline void SetHeight(int iHeight) { m_iDesiredHeight = iHeight; }; 
protected:
	afx_msg LRESULT OnLayout(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
private:
	int m_iDesiredHeight;
};


/////////////////////////////////////////////////////////////////////////////
// COrcaListView view

class COrcaListView : public CListView
{
protected:
	COrcaListView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(COrcaListView)

// Attributes
public:
	int m_cColumns;
	bool m_bDrawIcons;

// Operations
public:
	void SetBGColors(COLORREF norm, COLORREF sel, COLORREF focus);
	void SetFGColors(COLORREF norm, COLORREF sel, COLORREF focus);
	void GetFontInfo(LOGFONT *data);

	void GetAllMaximumColumnWidths(const COrcaTable* pTable, int rgiMaxWidths[32], DWORD dwMask) const;
	int GetMaximumColumnWidth(int iColumn) const;

	virtual void SwitchFont(CString name, int size);

	enum ErrorState { OK, Error, Warning, ShadowError };
	COLORREF m_clrFocused;
	COLORREF m_clrSelected;
	COLORREF m_clrNormal;
	COLORREF m_clrTransform;
	COLORREF m_clrFocusedT;
	COLORREF m_clrSelectedT;
	COLORREF m_clrNormalT;
	CBrush   m_brshNormal;
	CBrush   m_brshSelected;
	CBrush   m_brshFocused;
	CPen     m_penTransform;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COrcaListView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult );
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~COrcaListView();
	virtual void DrawItem(LPDRAWITEMSTRUCT pDraw);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	int m_nSelCol;
	//{{AFX_MSG(COrcaListView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void MeasureItem ( LPMEASUREITEMSTRUCT lpMeasureItemStruct );
	afx_msg void OnUpdateErrors(CCmdUI* pCmdUI);
	afx_msg BOOL OnEraseBkgnd( CDC* pDC );

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	COrcaDoc* GetDocument() const;
	CFont* m_pfDisplayFont;

	POSITION GetFirstSelectedItemPosition( ) const;
	int GetNextSelectedItem( POSITION& pos ) const;
	const int GetFocusedItem() const;

public:
	int m_iRowHeight;
private:

	virtual ErrorState GetErrorState(const void *data, int iColumn) const;
	virtual const CString *GetOutputText(const void *data, int iColumn) const;
	virtual OrcaTransformAction GetItemTransformState(const void *data) const;
	virtual OrcaTransformAction GetCellTransformState(const void *data, int iColumn) const;
	virtual OrcaTransformAction GetColumnTransformState(int iColumn) const;

	virtual bool ContainsTransformedData(const void *data) const;
	virtual bool ContainsValidationErrors(const void *data) const;

	void RecalculateItemHeight();

	COrcaHeaderCtrl m_ctrlHeader;
};

#ifndef _DEBUG  // debug version in TableVw.cpp
inline COrcaDoc* COrcaListView::GetDocument() const { return (COrcaDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

const int g_iMarkingBarMargin = 13;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ORCALISTVIEW_H__68AFD211_2594_11D2_8888_00A0C981B015__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\pathpp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// PagePaths.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "PathPP.h"
#include "FolderD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPathPropPage property page

IMPLEMENT_DYNCREATE(CPathPropPage, CPropertyPage)

CPathPropPage::CPathPropPage() : CPropertyPage(CPathPropPage::IDD)
{
	//{{AFX_DATA_INIT(CPathPropPage)
	m_strExportDir = _T("");
	m_strOrcaDat = _T("");
	//}}AFX_DATA_INIT
	m_bPathChange = false;
}

CPathPropPage::~CPathPropPage()
{
}

void CPathPropPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPathPropPage)
	DDX_Text(pDX, IDC_ORCADAT, m_strOrcaDat);
	DDX_Text(pDX, IDC_EXPORTDIR, m_strExportDir);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPathPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CPathPropPage)
	ON_BN_CLICKED(IDC_ORCADATB, OnOrcaDatb)
	ON_BN_CLICKED(IDC_EXPORTDIRB, OnExportDirb)
	ON_EN_CHANGE(IDC_ORCADAT, OnChangeOrcaDat)
	ON_EN_CHANGE(IDC_EXPORTDIR, OnChangeExportdir)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPathPropPage message handlers

void CPathPropPage::OnOrcaDatb() 
{
	CFileDialogEx *dCUB = new CFileDialogEx(TRUE, NULL, NULL, OFN_FILEMUSTEXIST, 
		_T("Orca DAT files (Orca.dat)|Orca.dat|All Files (*.*)|*.*||"), this);

	if (IDOK == dCUB->DoModal()) {
		m_strOrcaDat = dCUB->GetPathName();
		m_bPathChange = true;
		UpdateData(FALSE);
	}
	delete dCUB;
}

void CPathPropPage::OnExportDirb() 
{
	CFolderDialog dlg(this->m_hWnd, _T("Select a directory to Export to."));

	if (IDOK == dlg.DoModal())
	{
		// update the dialog box
		m_strExportDir = dlg.GetPath();
		m_bPathChange = true;
		UpdateData(FALSE);
	}
}

void CPathPropPage::OnExportbr() 
{
/*    BROWSEINFO bi;
	TCHAR szDir[MAX_PATH];
    LPITEMIDLIST pidl;
	LPMALLOC pMalloc;
    if (SUCCEEDED(SHGetMalloc(&pMalloc))) 
	{
        ZeroMemory(&bi,sizeof(bi));
        bi.hwndOwner = NULL;
        bi.pszDisplayName = 0;
        bi.pidlRoot = 0;
        bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_STATUSTEXT;
        bi.lpfn = NULL;
        pidl = SHBrowseForFolder(&bi);
        if (pidl) 
		{
           if (SHGetPathFromIDList(pidl,szDir)) 
		   {
              m_strExportDir = szDir;
			  UpdateData(FALSE);
		   }   
			pMalloc->Free(pidl); pMalloc->Release();
		}         
	} 
	return 0;      */
};

void CPathPropPage::OnChangeOrcaDat() 
{
	m_bPathChange = true;	
}

void CPathPropPage::OnChangeExportdir() 
{	
	m_bPathChange = true;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\pathpp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_PAGEPATHS_H__AB9A409F_2658_11D2_8889_00A0C981B015__INCLUDED_)
#define AFX_PAGEPATHS_H__AB9A409F_2658_11D2_8889_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PagePaths.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPagePaths dialog

class CPathPropPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CPathPropPage)

// Construction
public:
	bool m_bPathChange;
	CPathPropPage();
	~CPathPropPage();

// Dialog Data
	//{{AFX_DATA(CPagePaths)
	enum { IDD = IDD_PAGE_PATHS };
	CString	m_strOrcaDat;
	CString	m_strExportDir;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPagePaths)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPagePaths)
	afx_msg void OnOrcaDatb();
	afx_msg void OnExportDirb();
	afx_msg void OnExportbr();
	afx_msg void OnChangeOrcaDat();
	afx_msg void OnChangeExportdir();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PAGEPATHS_H__AB9A409F_2658_11D2_8889_00A0C981B015__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\prvwdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_PRVWDLG_H__76314876_2815_11D2_888A_00A0C981B015__INCLUDED_)
#define AFX_PRVWDLG_H__76314876_2815_11D2_888A_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PrvwDlg.h : header file
//
#include "table.h"

/////////////////////////////////////////////////////////////////////////////
// CPreviewDlg dialog

class CPreviewDlg : public CDialog
{
// Construction
public:
	CPreviewDlg(CWnd* pParent = NULL);   // standard constructor

	MSIHANDLE m_hDatabase;

// Dialog Data
	//{{AFX_DATA(CPreviewDlg)
	enum { IDD = IDD_DLGPREVIEW };
	CButton	m_ctrlPreviewBtn;
	CTreeCtrl	m_ctrlDialogLst;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPreviewDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPreviewDlg)
	afx_msg void OnPreview();
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnSelchangedDialoglst(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemexpandedDialoglst(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkDialoglst(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CImageList m_imageList;
	MSIHANDLE m_hPreview;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRVWDLG_H__76314876_2815_11D2_888A_00A0C981B015__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\row.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Row.cpp
//

#include "stdafx.h"
#include "orca.h"
#include "Row.h"
#include "Table.h"
#include "..\common\query.h"
#include "OrcaDoc.h"

bool ValidateIntegerValue(const CString& strData, DWORD& dwValue)
{
	if (strData.GetLength() > 2 && strData[0] == '0' && (strData[1] == 'x' || strData[1]=='X'))
	{
		// validate and convert hex
		for (int iChar=2; iChar < strData.GetLength(); iChar++)
		{
			// if a high bit is set, the value is too big.
			if (dwValue & 0xF0000000)
				return false;
			dwValue <<= 4;
			if (strData[iChar] >= '0' && strData[iChar] <= '9')
				dwValue |= strData[iChar]-'0';
			else if (strData[iChar] >= 'A' && strData[iChar] <= 'F')
				dwValue |= (strData[iChar] - 'A' + 10);
			else if (strData[iChar] >= 'a' && strData[iChar] <= 'f')
				dwValue |= (strData[iChar] - 'a' + 10);
			else
				return false;
		}
		return true;
	}

	int i=0; 
	if (strData[0] == '-')
	{
		i++;
	}
	for (; i < strData.GetLength(); i++)
	{
		if (strData[i] < '0' || strData[i] > '9')
			return false;
	}
	dwValue = _ttoi(strData);
	return true;
}


///////////////////////////////////////////////////////////
// constructor
COrcaRow::COrcaRow(COrcaTable *pTable, MSIHANDLE hRecord) : m_pTable(pTable), m_iTransform(iTransformNone), m_dataArray()
{
        int cData = pTable->GetColumnCount();
        m_dataArray.SetSize(cData);

        ReadFromRecord(hRecord, cData);
}       // end of constructor

///////////////////////////////////////////////////////////
// constructor -- 2
COrcaRow::COrcaRow(COrcaTable *pTable, CStringList* pstrList) : m_pTable(pTable), m_iTransform(iTransformNone), m_dataArray()
{
        ASSERT(pTable && pstrList);

    // never more than 32 columns, so OK to cast down
        int cData = static_cast<int>(pTable->GetColumnCount());
        m_dataArray.SetSize(cData);

        const COrcaColumn* pColumn = NULL;
        COrcaData* pData = NULL;
        POSITION pos = pstrList->GetHeadPosition();
        for (int i = 0; i < cData; i++)
        {
                pColumn = pTable->GetColumn(i);

                // possible that we didn't get enough data (especially in transformed rows)
                if (pos)
                {
                        CString strValue = pstrList->GetNext(pos);
                        if (iColumnBinary == pColumn->m_eiType)
                        {
							pData = new COrcaStringData;
                                if (strValue.IsEmpty())
                                {
                                        pData->SetData(_T(""));
                                }
                                else
                                {
                                        pData->SetData(_T("[Binary Data]"));
                                }
                        }
                        else if (iColumnString == pColumn->m_eiType || iColumnLocal == pColumn->m_eiType)
                        {
							pData = new COrcaStringData;
							pData->SetData(strValue);
                        }
						else
						{
							pData = new COrcaIntegerData;
							pData->SetData(strValue);
						}
                }
                m_dataArray.SetAt(i, pData);
        }
}       // end of constructor -- 2

///////////////////////////////////////////////////////////
// constructor -- 3
COrcaRow::COrcaRow(const COrcaRow *pOldRow) : m_pTable(NULL), m_iTransform(iTransformNone), m_dataArray()
{
        ASSERT(pOldRow);

        m_dataArray.SetSize(pOldRow->m_dataArray.GetSize());
        m_pTable = pOldRow->m_pTable;
        m_iTransform = iTransformNone;

        for (int i = 0; i < m_dataArray.GetSize(); i++)
        {
			const COrcaColumn* pColumn = m_pTable->GetColumn(i);
			COrcaData *pOldData = pOldRow->GetData(i);
			COrcaData *pData = NULL;
			if (pColumn->m_eiType == iColumnShort || pColumn->m_eiType == iColumnLong)
			{
				pData = new COrcaIntegerData;
				static_cast<COrcaIntegerData*>(pData)->SetIntegerData(static_cast<COrcaIntegerData*>(pOldData)->GetInteger());
			}
			else
			{
                pData = new COrcaStringData;
				pData->SetData(pOldData->GetString());
			}
			m_dataArray.SetAt(i, pData);
        }
}       // end of constructor -- 3

///////////////////////////////////////////////////////////
// destructor
COrcaRow::~COrcaRow()
{
        m_pTable = NULL;
        DestroyRow();
}       // end of destructor


///////////////////////////////////////////////////////////
// GetErrorCount
int COrcaRow::GetErrorCount() const
{
        int cErrors = 0;

        // clear the data array
        COrcaData* pData;
        INT_PTR cData = m_dataArray.GetSize();
        for (INT_PTR i = 0; i < cData; i++)
        {
                pData = m_dataArray.GetAt(i);

                if (iDataError == pData->GetError())
                        cErrors++;
        }

        return cErrors;
}       // end of GetErrorCount

///////////////////////////////////////////////////////////
// GetWarningCount
int COrcaRow::GetWarningCount() const
{
        int cWarnings = 0;

        // clear the data array
        COrcaData* pData;
        INT_PTR cData = m_dataArray.GetSize();
        for (INT_PTR i = 0; i < cData; i++)
        {
                pData = m_dataArray.GetAt(i);

                if (iDataWarning == pData->GetError())
                        cWarnings++;
        }

        return cWarnings;
}       // end of GetWarningCount

///////////////////////////////////////////////////////////
// ClearErrors
void COrcaRow::ClearErrors()
{
        // clear the data array
        COrcaData* pData;
        INT_PTR cData = m_dataArray.GetSize();
        for (INT_PTR i = 0; i < cData; i++)
        {
                pData = m_dataArray.GetAt(i);
                pData->ClearErrors();
        }
}       // end of ClearErrors

///////////////////////////////////////////////////////////
// DestroyRow
void COrcaRow::DestroyRow()
{
        // destroy the data array
        INT_PTR cData = m_dataArray.GetSize();
        for (INT_PTR i = 0; i < cData; i++)
                delete m_dataArray.GetAt(i);
        m_dataArray.RemoveAll();
}       // end of DestroyRow


void COrcaRow::ReadCellFromRecord(MSIHANDLE hRecord, int cRecData, int iColumn, const COrcaColumn* pColumn, COrcaData** pData) const
{
	if (!pColumn || !pData)
		return;

	if (iColumnBinary == pColumn->m_eiType)
	{
		if (!*pData)
			*pData = new COrcaStringData;
		if (!*pData)
			return;
	
		if (iColumn < cRecData)
		{
			// if the binary data is null, don't display anything in the UI
			if (MsiRecordIsNull(hRecord, iColumn+1))
			{
					(*pData)->SetData(_T(""));
			}
			else
			{
					(*pData)->SetData(_T("[Binary Data]"));
			}
		}
		else
			(*pData)->SetData(_T(""));
	}
	else if (iColumnString == pColumn->m_eiType || iColumnLocal == pColumn->m_eiType)
	{
		if (!*pData)
			*pData = new COrcaStringData;
		if (!*pData)
			return;

		if (iColumn < cRecData)
		{
			CString strData;
	
			UINT iResult = RecordGetString(hRecord, iColumn + 1, strData);
			ASSERT(ERROR_SUCCESS == iResult);
			(*pData)->SetData(strData);
		}
		else
			(*pData)->SetData(_T(""));
	}
	else
	{
		if (!*pData)
			*pData = new COrcaIntegerData;
		if (!*pData)
			return;

		if (iColumn < cRecData)
		{
			if (MsiRecordIsNull(hRecord, iColumn+1))
			{
				(*pData)->SetData(_T(""));
			}
			else
			{
				DWORD dwValue = MsiRecordGetInteger(hRecord, iColumn + 1);
				static_cast<COrcaIntegerData*>(*pData)->SetIntegerData(dwValue);
			}
		}
		else
			(*pData)->SetData(_T(""));
	}
}

void COrcaRow::ReadFromRecord(MSIHANDLE hRecord, int cData)
{
        DWORD cchBuffer;

        COrcaData *pData = NULL;
        const COrcaColumn *pColumn = NULL;
		
		int cRecData = MsiRecordGetFieldCount(hRecord);

        for (int i = 0; i < cData; i++)
        {
                pColumn = m_pTable->GetColumn(i);
                pData = m_dataArray.GetAt(i);

				ReadCellFromRecord(hRecord, cRecData, i, pColumn, &pData);
                if (m_dataArray.GetAt(i) == NULL)
                        m_dataArray.SetAt(i, pData);
        }
}

bool COrcaRow::Find(OrcaFindInfo &FindInfo, int &iCol) const
{
        COrcaData *pData;
        INT_PTR iMax = m_dataArray.GetSize();
        if (iCol == COLUMN_INVALID)
                iCol = (int)(FindInfo.bForward ? 0 : iMax-1);
        
        for ( ; (iCol >= 0) && (iCol < iMax); iCol += (FindInfo.bForward ? 1 : -1))
        {
                pData = m_dataArray.GetAt(iCol);
				const COrcaColumn *pColumn = m_pTable->GetColumn(iCol);
				if (!pColumn)
					continue;
                if (pColumn->m_eiType == iColumnString || pColumn->m_eiType == iColumnLocal)
                {
                        CString strData = pData->GetString();
                        if (!FindInfo.bMatchCase) 
                        {
                                // it is the responsibility of the caller to make strFind all uppercase for
                                // case insensitive search
                                strData.MakeUpper();
                        }
                        if (FindInfo.bWholeWord)
                        {
                                if (strData == FindInfo.strFindString) 
                                        return true;
                        } 
                        else 
                                if (-1 != strData.Find(FindInfo.strFindString))
                                        return true;
                }
        }
        
        iCol = COLUMN_INVALID;
        return false;
}


MSIHANDLE COrcaRow::GetRowRecord(MSIHANDLE hDatabase) const
{
        // setup the query
        CString strQuery;

        strQuery.Format(_T("SELECT * FROM `%s` WHERE "), m_pTable->Name());

        // add the where clause for keys to look up this exact row
        strQuery += m_pTable->GetRowWhereClause();

        CQuery qFetch;
        MSIHANDLE hResult = 0;
        PMSIHANDLE hQueryRec = GetRowQueryRecord();
        if (ERROR_SUCCESS != qFetch.FetchOnce(hDatabase, hQueryRec, &hResult, strQuery))
                return 0;
        return hResult;
}

///////////////////////////////////////////////////////////////////////
// since any arbitrary (non-binary) data can be a primary key, we 
// can't make any assumptions about the parseability of a query built
// with a WHERE clause comparing against literal strings. The WHERE
// clause must use parameter queries. GetRowWhereClause in the table 
// builds up the SQL syntax based on column names, and GetRowQueryRecord 
// creates a record consisting of the primary key values.
MSIHANDLE COrcaRow::GetRowQueryRecord() const
{
        ASSERT(m_pTable);
        if (!m_pTable)
                return 0;

        int cKeys = m_pTable->GetKeyCount();
        MSIHANDLE hRec = MsiCreateRecord(cKeys);

        for (int i=0; i<cKeys; i++)
        {
			COrcaData *pData = m_dataArray.GetAt(i);
			const COrcaColumn *pColumn = m_pTable->GetColumn(i);
			if (pData)
			{
				UINT uiResult = ERROR_SUCCESS;
				if (pColumn->m_eiType == iColumnShort || pColumn->m_eiType == iColumnLong)
				{
					if (pData->IsNull())
					{
						// if the column is not nullable, this just won't ever match anything. Should never
						// get into this state anyway because the cell data should never be set to null
						// unless the column is nullable.
						uiResult = MsiRecordSetString(hRec, i+1, _T(""));
					}
					else
					{
						uiResult = MsiRecordSetInteger(hRec, i+1, static_cast<COrcaIntegerData*>(pData)->GetInteger());
					}
				}
				else
				{
					const CString& rString = pData->GetString();
					uiResult = MsiRecordSetString(hRec, i+1, rString);
				}
				if (ERROR_SUCCESS != uiResult)
				{
					MsiCloseHandle(hRec);
					return 0;
				}
			}
        }

        return hRec;
}

UINT COrcaRow::ChangeData(COrcaDoc *pDoc, UINT iCol, CString strData)
{
        ASSERT(pDoc);
        ASSERT(m_pTable);
        if (!m_pTable || !pDoc)
                return ERROR_FUNCTION_FAILED;

        UINT iResult = 0;

        // setup the query
        CString strQueryA;
        COrcaColumn* pColumn = NULL;
        pColumn = m_pTable->ColArray()->GetAt(iCol);
        ASSERT(pColumn);
        if (!pColumn)
                return ERROR_FUNCTION_FAILED;
        strQueryA.Format(_T("SELECT `%s` FROM `%s` WHERE "), pColumn->m_strName, m_pTable->Name());

        // add the where clause
        strQueryA += m_pTable->GetRowWhereClause();
        PMSIHANDLE hQueryRec = GetRowQueryRecord();
        if (!hQueryRec)
                return ERROR_FUNCTION_FAILED;

        // easier to check a few things ourselves
        if ((!pColumn->m_bNullable) && (strData.IsEmpty())) return MSIDBERROR_REQUIRED;
        if (((pColumn->m_eiType == iColumnLocal) || (pColumn->m_eiType == iColumnString)) && 
                (pColumn->m_iSize != 0) && (strData.GetLength() > pColumn->m_iSize))
                return MSIDBERROR_STRINGOVERFLOW;

        // validate well-formed integer
        DWORD dwIntegerValue = 0;
        if ((pColumn->m_eiType != iColumnString) && (pColumn->m_eiType != iColumnLocal))        
                if (!ValidateIntegerValue(strData, dwIntegerValue))
                        return MSIDBERROR_OVERFLOW;

        // get the one cell out of the database. Don't get whole row, because if there is
        // a stream column in the table, we can't have the stream open and rename any of
        // the primary keys, because the stream will be "in use"
        CQuery queryReplace;

        if (ERROR_SUCCESS != (iResult = queryReplace.OpenExecute(pDoc->GetTargetDatabase(), hQueryRec, strQueryA)))
                return iResult; // bail
        // we have to get that one row, or something is very wrong
        PMSIHANDLE hRec;
        if (ERROR_SUCCESS != (iResult = queryReplace.Fetch(&hRec)))
                return iResult; // bail

        // fail if we can't set the data. Column is always 1 because we only selected that 1 column.
        if ((pColumn->m_eiType == iColumnString) || (pColumn->m_eiType == iColumnLocal))
        {
			iResult = MsiRecordSetString(hRec, 1, strData);
        }
        else
        {
			if (strData.IsEmpty())
			{
				if (!pColumn->m_bNullable)
					return ERROR_FUNCTION_FAILED;
				iResult = MsiRecordSetString(hRec, 1, _T(""));
			}
			else
				iResult = MsiRecordSetInteger(hRec, 1, dwIntegerValue);
        }
        if (ERROR_SUCCESS != iResult)
                return iResult; // bail

        COrcaData* pData = GetData(iCol);
        ASSERT(pData);
        if (!pData)
                return ERROR_FUNCTION_FAILED;

        // check for dupe primary keys
        UINT iStat;
        CString strOldData;
        if (pColumn->IsPrimaryKey()) 
        {
                CQuery queryDupe;
                CString strQueryB;
                strQueryB.Format(_T("SELECT `%s` FROM `%s` WHERE %s"), pColumn->m_strName, m_pTable->Name(), m_pTable->GetRowWhereClause());
                PMSIHANDLE hDupeRec;
                if ((pColumn->m_eiType == iColumnString) || (pColumn->m_eiType == iColumnLocal))
                {
                        MsiRecordSetString(hQueryRec, iCol+1, strData);
                }
                else
                {
					if (strData.IsEmpty())
					{
						// if the column is not nullable, this query will just not find a match, and we should have failed
						// above when setting the data anyway.
						MsiRecordSetString(hQueryRec, iCol+1, _T(""));
					}
					else
					{
						MsiRecordSetInteger(hQueryRec, iCol+1, dwIntegerValue);
					}
                }
                iStat = queryDupe.FetchOnce(pDoc->GetTargetDatabase(), hQueryRec, &hDupeRec, strQueryB);
                switch (iStat) {
                case ERROR_NO_MORE_ITEMS :
                        break;
                case ERROR_SUCCESS :
                        return MSIDBERROR_DUPLICATEKEY;
                default:
                        return ERROR_FUNCTION_FAILED;
                }
        } // primary key
        else
        {
                // for non-primary keys, change the UI
                strOldData = pData->GetString();
                pData->SetData(strData);
        }

        // return what ever happens in the replace
        iStat = queryReplace.Modify(MSIMODIFY_REPLACE, hRec); 
        if (ERROR_SUCCESS == iStat)
        {
                // set that the document has changed
                pDoc->SetModifiedFlag(TRUE);

                if (pDoc->DoesTransformGetEdit())
                {
                        // mark that the cell has changed. If the row is an "add" row, this
                        // is not a cell change
                        if (IsTransformed() != iTransformAdd)
                        {
                                PMSIHANDLE hOtherRec = GetRowRecord(pDoc->GetOriginalDatabase());
                                TransformCellAgainstDatabaseRow(pDoc, iCol, 0, hOtherRec);      
                        }
                }
        }
        else if (!strOldData.IsEmpty())
                pData->SetData(strOldData);

        return iStat;
}

///////////////////////////////////////////////////////////////////////
// modifies the binary data in a cell, and if transforms are enabled
// compares the data to the other database to determine transform state
UINT COrcaRow::ChangeBinaryData(COrcaDoc *pDoc, int iCol, CString strFile)
{
        UINT iResult = ERROR_SUCCESS;

        // get the data item we're working with
        COrcaData* pData = GetData(iCol);
        ASSERT(pData);
        if (!pData)
                return ERROR_FUNCTION_FAILED;

        // setup the query
        CString strQuery;
        strQuery.Format(_T("SELECT * FROM `%s` WHERE "), m_pTable->Name());

        // add the key strings to query to do the exact look up
        strQuery += m_pTable->GetRowWhereClause();

        // get the one row out of the database
        CQuery queryReplace;
        PMSIHANDLE hQueryRec = GetRowQueryRecord();
        if (!hQueryRec)
                return ERROR_FUNCTION_FAILED;

        if (ERROR_SUCCESS != (iResult = queryReplace.OpenExecute(pDoc->GetTargetDatabase(), hQueryRec, strQuery)))
                return iResult;

        // we have to get that one row, or something is very wrong
        PMSIHANDLE hRec;
        if (ERROR_SUCCESS != (iResult = queryReplace.Fetch(&hRec)))
                return iResult;

        // bail if we can't set the string (iCol + 1 because MSI Records start at 1)
        if (strFile.IsEmpty())
        {
                MsiRecordSetString(hRec, iCol + 1, _T(""));
        }
        else
        {
                if (ERROR_SUCCESS != (iResult = ::MsiRecordSetStream(hRec, iCol + 1, strFile)))
                        return iResult; // bail
        }

        // return what ever happens in the replace
        iResult = queryReplace.Modify(MSIMODIFY_REPLACE, hRec);

        if (strFile.IsEmpty())
                pData->SetData(_T(""));
        else
                pData->SetData(_T("[Binary Data]"));
        
        if (pDoc->DoesTransformGetEdit() && iResult == ERROR_SUCCESS)
        {
                PMSIHANDLE hOtherRec = GetRowRecord(pDoc->GetOriginalDatabase());
                TransformCellAgainstDatabaseRow(pDoc, iCol, hRec, hOtherRec);
        }

        return iResult;
}

/////////////////////////////////////////////////////////////////////////////
// row level transform ops are interesting because they often arise from
// primary key changes which require on-the-fly comparisons between the two
// databases
void COrcaRow::Transform(COrcaDoc *pDoc, const OrcaTransformAction iAction, MSIHANDLE hOriginalRec, MSIHANDLE hTransformedRec) 
{
        ASSERT(pDoc);
        if (!pDoc)
                return;

        switch (iAction)
        {
                case iTransformAdd:
                case iTransformDrop:
                {
                        ASSERT(m_pTable);
                        if (!m_pTable)
                                return;

                        // when a row is added or dropped, the change states of the individual
                        // cells are irrelevant, but we must refresh from the original state
                        MSIHANDLE hRec = (hOriginalRec ? hOriginalRec : GetRowRecord(pDoc->GetOriginalDatabase()));
                        if (hRec)
                                ReadFromRecord(hRec, m_pTable->GetColumnCount());
                        for (int i = 0; i < m_dataArray.GetSize(); i++)
                        {
                                COrcaData *pData = GetData(i);
                                ASSERT(pData);
                                if (!pData)
                                        continue;
                                pData->Transform(iTransformNone);
                        }

                        // if the row is not already transformed, remove any outstanding
                        // cell-level transform counts and add one for the row
                        if (m_iTransform == iTransformNone)
                        {
                                RemoveOutstandingTransformCounts(pDoc);
                                m_pTable->IncrementTransformedData();
                        }
                        m_iTransform = iAction;

                        if (!hOriginalRec)
                                MsiCloseHandle(hRec);
                        break;
                }
                case iTransformNone:
                        // if a row is given a "none" transform, what should we do?????
                        ASSERT(0);
                        break;
                case iTransformChange:
                {
                        ASSERT(m_pTable);
                        if (!m_pTable)
                                return;

                        // a row-level "change" operation is actually a row-level"none", but
                        // each non-key cell in the row could become a "change". If a primary
                        // key on a record changes to something that collides with an existing 
                        // record, the transform state of each cell is unknown and must be checked.
                        if (m_iTransform != iTransformNone)
                                m_pTable->DecrementTransformedData();
                        m_iTransform = iTransformNone;
                        
                        int cKeys = m_pTable->GetKeyCount();
                        int cCols = GetColumnCount();
                        
                        // if the table consists only of primary keys, we are done
                        if (cKeys == cCols)
                                break;

                        // we need a record from the other database as a basis for 
                        // comparison
                        MSIHANDLE hOtherRow = (hOriginalRec ? hOriginalRec : GetRowRecord(pDoc->GetOriginalDatabase()));

                        // the original DB may actually have fewer columns than the transformed DB. 
                        // in that case we only want to check the columns that exist in both databases
                        int cOriginalCols = m_pTable->GetOriginalColumnCount();

                        // if the original table consists only of primary keys, we are done
                        if (cKeys == cOriginalCols)
                        {
                                if (!hOriginalRec)
                                        MsiCloseHandle(hOtherRow);
                                break;
                        }

                        // the primary keys can not be different or there would be
                        // no collision, so no need to check those columns.
                        for (int i = cKeys; i < cOriginalCols; i++)
                        {                       
                                TransformCellAgainstDatabaseRow(pDoc, i, hTransformedRec, hOtherRow);
                        }

						// anything greater than the number of columns in the original database is simply
						// a load from the transformed record. No need to transform because the original
						// database doesn't have this column, so the column must be added anyway.
						for (i = cOriginalCols; i < cCols; i++)
						{
							COrcaData *pData = GetData(i);
							const COrcaColumn* pColumn = m_pTable->GetColumn(i);
							ASSERT(pData && pColumn);
							if (!pData || !pColumn)
									continue;
							ReadCellFromRecord(hTransformedRec, cCols, i, pColumn, &pData);
						}

                        if (!hOriginalRec)
                                MsiCloseHandle(hOtherRow);
                        break;
                }
                default:
                        ASSERT(0);
                        break;
        }
}

///////////////////////////////////////////////////////////////////////
// given a row record (presumably from the original database when we're
// editing the transform), compare the specified cell against the 
// provided record and mark as transformed if different. Used to 
// reconcile the UI when a cell modification changes a primary key to
// clash with an previously dropped row.
void COrcaRow::TransformCellAgainstDatabaseRow(COrcaDoc *pDoc, int iColumn, MSIHANDLE hTargetRow, MSIHANDLE hOtherRow)
{
        bool fDifferent = false;
        COrcaData *pData = GetData(iColumn);
        ASSERT(pData);
        ASSERT(m_pTable);
        if (!pData || !m_pTable)
                return;
		const COrcaColumn* pColumn = m_pTable->GetColumn(iColumn);
		ASSERT(pColumn);

        CString strData = _T("");

        if (iColumnBinary == pColumn->m_eiType)
        {
                // for binary data, we need to check that this bits are identical to determine whether or
                // not this cell has been transformed
                MSIHANDLE hThisRow = 0;
                hThisRow = (hTargetRow ? hTargetRow : GetRowRecord(pDoc->GetTargetDatabase()));

                unsigned long iOtherSize = 0;
                unsigned long iThisSize = 0;
                MsiRecordReadStream(hOtherRow, iColumn+1, NULL, &iOtherSize);
                MsiRecordReadStream(hThisRow, iColumn+1, NULL, &iThisSize);

                strData = MsiRecordIsNull(hOtherRow, iColumn+1) ? _T("[Binary Data]") : _T("");

                if (iOtherSize != iThisSize)
                {
                        fDifferent = true;
                }
                else
                {
                        fDifferent = false;
                        while (iThisSize > 0)
                        {
                                int iBlock = (iThisSize > 1024) ? 1024 : iThisSize;
                                iThisSize -= iBlock;
                                char OtherBuffer[1024] = "";
                                char ThisBuffer[1024] = "";
                                DWORD dwTemp = iBlock;
                                if (ERROR_SUCCESS != MsiRecordReadStream(hOtherRow, iColumn+1, OtherBuffer, &dwTemp))
                                {
                                        fDifferent = true;
                                        break;
                                }
                                dwTemp = iBlock;
                                if (ERROR_SUCCESS != MsiRecordReadStream(hThisRow, iColumn+1, ThisBuffer, &dwTemp))
                                {
                                        fDifferent = true;
                                        break;
                                }

                                if (memcmp(OtherBuffer, ThisBuffer, iBlock))
                                {
                                        fDifferent = true;
                                        break;
                                }
                        }
                }

                // clean up owned target row
                if (!hTargetRow)
                {
                        MsiCloseHandle(hThisRow);
                }
        }
        else
        {
                UINT iResult = RecordGetString(hOtherRow, iColumn + 1, strData);

                if (strData != pData->GetString())
                {
                        fDifferent = true;
                }
        }

        if (fDifferent)
        {
                // if the cell is not already transformed, do so
                if (!pData->IsTransformed())
                {
                        pData->Transform(iTransformChange);                             
                        m_pTable->IncrementTransformedData();
                }
        }
        else
        {
                // data is same, if transform, remove change
                if (pData->IsTransformed())
                {
                        pData->Transform(iTransformNone);                               
                        m_pTable->DecrementTransformedData();
                }
        }
}

///////////////////////////////////////////////////////////////////////
// scans through every cell in the row, removing a transform count 
// for each transformed cell. It also removes one count if the row
// itself is transformed. This is used to clean-up counts before
// deleting or re-transforming the row.
void COrcaRow::RemoveOutstandingTransformCounts(COrcaDoc *pDoc)
{
        ASSERT(pDoc);
        ASSERT(m_pTable);
        if (!pDoc || !m_pTable)
                return;

        // if the row as a whole is transformed, there is only one 
        // transform count, not one for each cell.
        if (m_iTransform != iTransformNone)
        {
                m_pTable->DecrementTransformedData();
                return;
        }

        int cKeys = m_pTable->GetKeyCount();
        // never more than 32 columns, so cast OK on Win64
        int cCols = static_cast<int>(m_dataArray.GetSize());

        // if the table consists only of primary keys, we are done because
        // no primary keys can have "change" attributes
        if (cKeys == cCols)
                return;

        // the primary keys can not be different or there would be
        // no collision, so no need to check those columns.
        for (int i = cKeys; i < cCols; i++)
        {                       
                if (m_dataArray.GetAt(i)->IsTransformed())
                        m_pTable->DecrementTransformedData();
        }
}


///////////////////////////////////////////////////////////////////////
// Retrieve the value from a cell in the original database. Very slow
// function, should only be used for rare events.
const CString COrcaRow::GetOriginalItemString(const COrcaDoc *pDoc, int iItem) const
{
	CString strValue;
	ASSERT(pDoc);
	if (pDoc)
	{
		PMSIHANDLE hRec = GetRowRecord(pDoc->GetOriginalDatabase());
		if (hRec)
		{
			if (!MsiRecordIsNull(hRec, iItem+1))
			{
				// determine colomun format.
				const COrcaColumn* pColumn = m_pTable->GetColumn(iItem);
				if (pColumn)
				{
					switch (pColumn->m_eiType)
					{
					case iColumnShort:
					case iColumnLong:
					{
						DWORD dwValue = MsiRecordGetInteger(hRec, iItem+1);
						strValue.Format(pColumn->DisplayInHex() ? TEXT("0x%08X") : TEXT("%d"), dwValue);
						break;
					}
					case iColumnString:
					case iColumnLocal:
						RecordGetString(hRec, iItem+1, strValue);
						break;
					case iColumnBinary:
						strValue = TEXT("[Binary Data]");
						break;
					default:
						ASSERT(0);
						break;
					}
				}
			}
		}
	}
	return strValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\row.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Row.h
//

#ifndef _ORCA_ROW_H_
#define _ORCA_ROW_H_

#include "msiquery.h"
#include "Column.h"
#include "Data.h"

// forward declaration
class COrcaTable;
class COrcaDoc;

class COrcaRow : public CObject
{

public:
	COrcaRow(COrcaTable *pTable, MSIHANDLE hRecord);
	COrcaRow(COrcaTable *pTable, CStringList* pstrList);
	COrcaRow(const COrcaRow *pRow);
	~COrcaRow();
	
	CString GetRowWhereClause() const;
	bool Find(OrcaFindInfo &FindInfo, int &iCol) const;
	void Transform(COrcaDoc *pDoc, const OrcaTransformAction iAction, MSIHANDLE hNonTargetRec, MSIHANDLE hTargetRec);
	inline const OrcaTransformAction IsTransformed() const { return m_iTransform; };
	void RemoveOutstandingTransformCounts(COrcaDoc *pDoc);

	
	inline COrcaData* GetData(UINT iCol) const { return m_dataArray.GetAt(iCol); };

	// never more than 32 columns, so cast down to int is OK on Win64
	inline int GetColumnCount() const { return static_cast<int>(m_dataArray.GetSize()); };

	UINT ChangeData(COrcaDoc *pDoc, UINT iCol, CString strData);
	UINT ChangeBinaryData(COrcaDoc *pDoc, int iCol, CString strFile);

	MSIHANDLE GetRowRecord(MSIHANDLE hDatabase) const;
	MSIHANDLE GetRowQueryRecord() const;
	int GetErrorCount() const;
	int GetWarningCount() const;
	void ClearErrors();
	void DestroyRow();

	const CString GetOriginalItemString(const COrcaDoc *pDoc, int iItem) const;

private:
	void ReadCellFromRecord(MSIHANDLE hRecord, int cRecData, int iColumn, const COrcaColumn* pColumn, COrcaData** pData) const; 
	void ReadFromRecord(MSIHANDLE hRec, int cData);
	void TransformCellAgainstDatabaseRow(COrcaDoc *pDoc, int iColumn, MSIHANDLE hTargetRow, MSIHANDLE hOtherRow);
	
	CTypedPtrArray<CObArray, COrcaData*> m_dataArray;
	
	COrcaTable* m_pTable;
	OrcaTransformAction m_iTransform;
};	// end of COrcaRow

extern bool ValidateIntegerValue(const CString& strData, DWORD& dwValue);

#endif	// _ORCA_ROW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\prvwdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// PrvwDlg.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "PrvwDlg.h"
#include "row.h"
#include "data.h"
#include "..\common\query.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPreviewDlg dialog


CPreviewDlg::CPreviewDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPreviewDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPreviewDlg)
	//}}AFX_DATA_INIT
}


void CPreviewDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPreviewDlg)
	DDX_Control(pDX, IDC_PREVIEW, m_ctrlPreviewBtn);
	DDX_Control(pDX, IDC_DIALOGLST, m_ctrlDialogLst);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPreviewDlg, CDialog)
	//{{AFX_MSG_MAP(CPreviewDlg)
	ON_BN_CLICKED(IDC_PREVIEW, OnPreview)
	ON_WM_DESTROY()
	ON_NOTIFY(TVN_SELCHANGED, IDC_DIALOGLST, OnSelchangedDialoglst)
	ON_NOTIFY(TVN_ITEMEXPANDED, IDC_DIALOGLST, OnItemexpandedDialoglst)
	ON_NOTIFY(NM_DBLCLK, IDC_DIALOGLST, OnDblclkDialoglst)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPreviewDlg message handlers

void CPreviewDlg::OnPreview() 
{
	CWaitCursor curWait;
	if (m_hPreview != 0) {
		HTREEITEM hItem = m_ctrlDialogLst.GetSelectedItem();
		if (NULL == hItem) return;

		if (m_ctrlDialogLst.GetItemData(hItem) == 1) {
			CString strName = m_ctrlDialogLst.GetItemText(hItem);
			// get the currently selected Dialog 
			MsiPreviewDialog(m_hPreview, _T(""));
			MsiPreviewDialog(m_hPreview, strName);
		}
	}
}

BOOL CPreviewDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	if (ERROR_SUCCESS != MsiEnableUIPreview(m_hDatabase, &m_hPreview)) {
		m_hPreview = 0;
	}

	PMSIHANDLE hDialogRec;
	PMSIHANDLE hControlRec;
	CQuery qDialog;
	CQuery qControl;

	m_imageList.Create(16,16,ILC_COLOR, 2, 1);
	CBitmap	bmImages;
	bmImages.LoadBitmap(IDB_PRVWIMAGES);
	m_imageList.Add(&bmImages, COLORREF(0));
	m_ctrlDialogLst.SetImageList(&m_imageList, TVSIL_NORMAL);

	qDialog.OpenExecute(m_hDatabase, NULL, _T("SELECT `Dialog`.`Dialog` FROM `Dialog`"));
	qControl.Open(m_hDatabase, _T("SELECT `Control_`,`Event`,`Argument` FROM `ControlEvent` WHERE `Dialog_`=?"));


	while (ERROR_SUCCESS == qDialog.Fetch(&hDialogRec)) 
	{
		UINT iStat;
		// get the dialog name
		CString strName;
		unsigned long cchName = 80;
		LPTSTR pszName = strName.GetBuffer(cchName);
		iStat = ::MsiRecordGetString(hDialogRec, 1, pszName, &cchName);
		pszName = NULL;
		strName.ReleaseBuffer();
		if (ERROR_SUCCESS != iStat)	continue;
	
		HTREEITEM hItem = m_ctrlDialogLst.InsertItem(strName, 1, 1, TVI_ROOT, TVI_SORT);

		// set the item data to 1 to enable preview
		m_ctrlDialogLst.SetItemData(hItem, 1);

		qControl.Execute(hDialogRec);
		while (ERROR_SUCCESS == qControl.Fetch(&hControlRec))
		{
			// get the control name
			CString strControl;
			unsigned long cchControl = 80;
			LPTSTR pszControl = strControl.GetBuffer(cchControl);
			iStat = ::MsiRecordGetString(hControlRec, 1, pszControl, &cchControl);
			strControl.ReleaseBuffer();
			if (ERROR_SUCCESS != iStat)	continue;

 			HTREEITEM hControlItem = m_ctrlDialogLst.InsertItem(strControl, 0, 0, hItem, TVI_SORT);			
			m_ctrlDialogLst.SetItemData(hControlItem, 0);

			// get the type of event
			CString strEvent;
			unsigned long cchEvent = 80;
			LPTSTR pszEvent = strEvent.GetBuffer(cchEvent);
			iStat = ::MsiRecordGetString(hControlRec, 2, pszEvent, &cchEvent);
			strEvent.ReleaseBuffer();
			if (ERROR_SUCCESS != iStat)	continue;

			if ((strEvent == CString(_T("NewDialog"))) ||
				(strEvent  == CString(_T("SpawnDialog"))))
			{

				// get the next dialog name
				cchName = 80;
				pszName = strName.GetBuffer(cchName);
				iStat = ::MsiRecordGetString(hControlRec, 3, pszName, &cchName);
				pszName = NULL;
				strName.ReleaseBuffer();
				if (ERROR_SUCCESS != iStat)	continue;
			
				HTREEITEM hItem2 = m_ctrlDialogLst.InsertItem(strName, 1, 1, hControlItem, TVI_SORT);

				// set the item data to 1 to enable preview
				m_ctrlDialogLst.SetItemData(hItem2, 1);
			}
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPreviewDlg::OnDestroy() 
{
	CWaitCursor curWait;
	if (m_hPreview != 0) {
		::MsiPreviewDialog(m_hPreview, _T(""));
		::MsiCloseHandle(m_hPreview);
	}
	CDialog::OnDestroy();
}

void CPreviewDlg::OnSelchangedDialoglst(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

	m_ctrlPreviewBtn.EnableWindow(pNMTreeView->itemNew.lParam == 1);
	*pResult = 0;
}

void CPreviewDlg::OnItemexpandedDialoglst(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

	if (pNMTreeView->action == TVE_EXPAND) {
		HTREEITEM hChild = m_ctrlDialogLst.GetChildItem(pNMTreeView->itemNew.hItem);
		while (hChild != NULL) 
		{
			m_ctrlDialogLst.Expand(hChild, TVE_EXPAND);
			hChild = m_ctrlDialogLst.GetNextSiblingItem(hChild);
		}
	}

	*pResult = 0;
}

void CPreviewDlg::OnDblclkDialoglst(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnPreview();
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	Orca.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\sources.inc ===
TARGETNAME=orca
!INCLUDE ..\..\..\MsiMake.inc
                  
TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

NTTARGETFILE0=BuiltHeaders

C_DEFINES=-D_WIN32_MSM=200 $(C_DEFINES)

UMTYPE=windows

TARGETPATH=$(MSI_BUILD_TARGET)


# 
# Fusionized
# 

SXS_ASSEMBLY_NAME=Microsoft.Windows.MSI.Orca
SXS_ASSEMBLY_VERSION=2.0 
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=orca.exe.manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1


TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\msi.lib \
	$(SDK_LIB_PATH)\OLE32.lib \
	$(SDK_LIB_PATH)\OLEAUT32.lib \
	$(SDK_LIB_PATH)\shell32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\comctl32.lib \
        $(SDK_LIB_PATH)\comdlg32.lib

USE_MSVCRT=1
USE_NATIVE_EH=1


!if !$(FREEBUILD)
MSC_OPTIMIZATION=/Odi
!endif

!if "$(MSI_BUILD_UNICODE)"=="1"
USE_MFCUNICODE=1
!else
USE_MFC=1
!endif

INCLUDES=$(INC_DIR);$(SDK_INC_PATH);$(O);$(MFC_INCLUDES);$(RES_OBJDIR)

SOURCES=..\addrowd.cpp \
	..\addtbld.cpp \
	..\celledit.cpp \
	..\cellerrd.cpp \
	..\cnfgmsmd.cpp \
	..\column.cpp \
	..\data.cpp \
	..\odbutils.cpp \
	..\displypp.cpp \
	..\domerge.cpp \
	..\editbind.cpp \
	..\exportd.cpp \
	..\folderd.cpp \
	..\helpd.cpp \
	..\imprtdlg.cpp \
	..\orcadoc.cpp \
	..\orcalstv.cpp \
	..\mainfrm.cpp \
	..\merged.cpp \
	..\msmresd.cpp \
	..\orca.cpp \
	..\oquery.cpp \
	..\pathpp.cpp \
	..\prvwdlg.cpp \
	..\row.cpp \
	..\summaryd.cpp \
	..\table.cpp \
	..\tablelst.cpp \
	..\tablevw.cpp \
	..\tblerrd.cpp \
	..\trnpropd.cpp \
	..\otrace.cpp \
	..\outils.cpp \
	..\vald.cpp \
	..\valpane.cpp \
	..\valpp.cpp \
	..\stdafx.cpp \
	..\orca.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C3EDC1AA_E506_11D1_A856_006097ABDE17__INCLUDED_)
#define AFX_STDAFX_H__C3EDC1AA_E506_11D1_A856_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


// used in the build process
typedef BOOL (WINAPI* LPDISPLAYBUILD)(LPVOID pContext, UINT uiType, LPCTSTR szDisplay);

enum DisplayType
{
	iError,		// error display
	iInfo,		// info display
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C3EDC1AA_E506_11D1_A856_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\summaryd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// SummaryD.cpp : implementation file
//

#include "stdafx.h"
#include "Orca.h"
#include "SummaryD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSummaryD dialog


CSummaryD::CSummaryD(CWnd* pParent /*=NULL*/)
	: CDialog(CSummaryD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSummaryD)
	m_strAuthor = _T("");
	m_strComments = _T("");
	m_strKeywords = _T("");
	m_strLanguages = _T("");
	m_strPlatform = _T("");
	m_strProductID = _T("");
	m_nSchema = 0;
	m_nSecurity = -1;
	m_strSubject = _T("");
	m_strTitle = _T("");
	m_bAdmin = FALSE;
	m_bCompressed = FALSE;
	m_iFilenames = -1;
	//}}AFX_DATA_INIT
}


void CSummaryD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSummaryD)
	DDX_Text(pDX, IDC_AUTHOR, m_strAuthor);
	DDX_Text(pDX, IDC_COMMENTS, m_strComments);
	DDX_Text(pDX, IDC_KEYWORDS, m_strKeywords);
	DDX_Text(pDX, IDC_LANGUAGES, m_strLanguages);
	DDX_CBString(pDX, IDC_PLATFORM, m_strPlatform);
	DDX_Text(pDX, IDC_PRODUCTID, m_strProductID);
	DDX_Text(pDX, IDC_SCHEMA, m_nSchema);
	DDX_CBIndex(pDX, IDC_SECURITY, m_nSecurity);
	DDX_Text(pDX, IDC_SUBJECT, m_strSubject);
	DDX_Text(pDX, IDC_TITLE, m_strTitle);
	DDX_Check(pDX, IDC_ADMIN, m_bAdmin);
	DDX_Check(pDX, IDC_COMPRESSED, m_bCompressed);
	DDX_Radio(pDX, IDC_SHORT, m_iFilenames);
	DDX_Control(pDX, IDC_PLATFORM, m_ctrlPlatform);
	DDX_Control(pDX, IDC_SCHEMA, m_ctrlSchema);

	DDX_Control(pDX, IDC_AUTHOR, m_ctrlAuthor);
	DDX_Control(pDX, IDC_COMMENTS, m_ctrlComments);
	DDX_Control(pDX, IDC_KEYWORDS, m_ctrlKeywords);
	DDX_Control(pDX, IDC_LANGUAGES, m_ctrlLanguages);
	DDX_Control(pDX, IDC_PRODUCTID, m_ctrlProductID);
	DDX_Control(pDX, IDC_SUBJECT, m_ctrlSubject);
	DDX_Control(pDX, IDC_TITLE, m_ctrlTitle);
	DDX_Control(pDX, IDC_SECURITY, m_ctrlSecurity);
	DDX_Control(pDX, IDC_ADMIN, m_ctrlAdmin);
	DDX_Control(pDX, IDC_COMPRESSED, m_ctrlCompressed);
	DDX_Control(pDX, IDC_SHORT, m_ctrlSFN);
	DDX_Control(pDX, IDC_LONG, m_ctrlLFN);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSummaryD, CDialog)
	//{{AFX_MSG_MAP(CSummaryD)
	ON_EN_KILLFOCUS(IDC_SCHEMA, OnChangeSchema)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


const TCHAR szIntel64[] = _T("Intel64");
const TCHAR szIntel[] = _T("Intel");
const TCHAR szAlpha[] = _T("Alpha");
const TCHAR szIntelAlpha[] = _T("Intel,Alpha");

/////////////////////////////////////////////////////////////////////////////
// CSummaryD message handlers

void CSummaryD::OnChangeSchema() 
{
	CString strText;
	int nOldSchema = m_nSchema;
	m_ctrlSchema.GetWindowText(strText);

	if (!strText.IsEmpty())
	{
		UpdateData(TRUE);
		
		// alpha only supported for schema 100 or less
		if (nOldSchema <= 100 && m_nSchema > 100)
		{
			// drop alpha
			int iIndex = CB_ERR;
			if (CB_ERR != (iIndex = m_ctrlPlatform.FindString(-1, szAlpha)))
				m_ctrlPlatform.DeleteString(iIndex);
			if (CB_ERR != (iIndex = m_ctrlPlatform.FindString(-1, szIntelAlpha)))
				m_ctrlPlatform.DeleteString(iIndex);

			// moving from under 100 to over 100, you are going from Intel, Alpha, 
			// or Both to either Intel or Intel64. Set to Intel
			m_ctrlPlatform.SelectString(-1, szIntel);
		}
		else if (nOldSchema > 100 && m_nSchema <= 100)
		{
			// add alpha back in
			if (CB_ERR == m_ctrlPlatform.FindString(-1, szAlpha))
				m_ctrlPlatform.AddString(szAlpha);
			if (CB_ERR == m_ctrlPlatform.FindString(-1, szIntelAlpha))
				m_ctrlPlatform.AddString(szIntelAlpha);
		}			

		// Intel64 only supported on schemas >= 150
		if (nOldSchema >= 150 && m_nSchema < 150)
		{
			int iIndex = CB_ERR;
			if (CB_ERR != (iIndex = m_ctrlPlatform.FindString(-1, szIntel64)))
				m_ctrlPlatform.DeleteString(iIndex);
			
			// moving from over 150 to under 150, you are going from Intel or Intel64 
			// to Intel, Alpha, or both. Set to Intel.
			m_ctrlPlatform.SelectString(-1, szIntel);
		}
		else if (nOldSchema < 150 && m_nSchema >= 150)
		{
			if (CB_ERR == m_ctrlPlatform.FindString(-1, szIntel64))
				m_ctrlPlatform.AddString(szIntel64);
		}
	}
}

BOOL CSummaryD::OnInitDialog() 
{
	CDialog::OnInitDialog();

	m_ctrlPlatform.AddString(szIntel);
	if (m_nSchema >= 150)
		m_ctrlPlatform.AddString(szIntel64);
	if (m_nSchema <= 100)
	{
		m_ctrlPlatform.AddString(szAlpha);
		m_ctrlPlatform.AddString(szIntelAlpha);
	}
	m_ctrlPlatform.SelectString(-1, m_strPlatform);

	// if the summaryinfo is read-only, disable all controls:
	if (m_bReadOnly)
	{
		SetWindowText(TEXT("View Summary Information"));
		m_ctrlPlatform.EnableWindow(FALSE);
		m_ctrlSchema.EnableWindow(FALSE);
		m_ctrlAuthor.EnableWindow(FALSE);
		m_ctrlComments.EnableWindow(FALSE);
		m_ctrlKeywords.EnableWindow(FALSE);
		m_ctrlLanguages.EnableWindow(FALSE);
		m_ctrlProductID.EnableWindow(FALSE);
		m_ctrlSubject.EnableWindow(FALSE);
		m_ctrlTitle.EnableWindow(FALSE);
		m_ctrlSecurity.EnableWindow(FALSE);
		m_ctrlAdmin.EnableWindow(FALSE);
		m_ctrlCompressed.EnableWindow(FALSE);
		m_ctrlSFN.EnableWindow(FALSE);
		m_ctrlLFN.EnableWindow(FALSE);
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\table.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Table.cpp
//

#include "stdafx.h"
#include "Table.h"
#include "..\common\dbutils.h"
#include "..\common\query.h"
#include "orcadoc.h"
#include "mainfrm.h"
#include "row.h"

///////////////////////////////////////////////////////////
// constructor
COrcaTable::COrcaTable(COrcaDoc* pDoc) : m_pDoc(pDoc), m_strName(""), m_bRetrieved(false), m_fShadow(false), 
	m_eiError(iTableNoError), m_iTransform(iTransformNone), m_eiTableLocation(odlInvalid),
	m_iTransformedDataCount(0), m_bContainsValidationErrors(false), m_strWhereClause(_T("")),
	m_cOriginalColumns(0)
{
}

///////////////////////////////////////////////////////////
// destructor
COrcaTable::~COrcaTable()
{
}	// end of destructor


///////////////////////////////////////////////////////////
// DestroyTable
// destroys all rows and columns in the database
void COrcaTable::DestroyTable()
{
	ClearErrors();
	EmptyTable();
	
	m_eiTableLocation = odlInvalid;
	
	// destroy the column array
	int cColumns = static_cast<int>(m_colArray.GetSize());

	for (int i = 0; i < cColumns; i++)
		delete m_colArray.GetAt(i);
	m_colArray.RemoveAll();
	m_cOriginalColumns = 0;
}	// end of DestroyTable

///////////////////////////////////////////////////////////////////////
// given a column name, return the column number (0 based) or -1 if not
// found in the table.
int COrcaTable::FindColumnNumberByName(const CString& strCol) const
{
	// never more than 32 columns, so casting to int OK
	int iCol = -1;
	int cCols = static_cast<int>(m_colArray.GetSize());

	// find the first column that matches names
	for (int i = 0; i < cCols; i++)
	{
		COrcaColumn *pColumn = m_colArray.GetAt(i);
		if (!pColumn)
			continue;
		if (pColumn->m_strName == strCol)
		{
			iCol = i;
			break;
		}
	}
	return iCol;
}

///////////////////////////////////////////////////////////////////////
// GetData - 2
// returns a COrcaData pointer based on a primary key set and a column
// name. Returns NULL if the column or keys couldn't be found
COrcaData* COrcaTable::GetData(CString strCol, CStringArray& rstrKeys, const COrcaRow** pRowOut) const
{
	// never more than 32 columns, so casting to int OK
	int iCol = FindColumnNumberByName(strCol);

	// if we couldn't find the column bail
	if (iCol < 0)
		return NULL;

	COrcaRow* pRow = FindRowByKeys(rstrKeys);

	// if we have a match get the correct data spot
	COrcaData* pData = NULL;
	if (pRow)
	{
		pData = pRow->GetData(iCol);
		if (pRowOut)
			*pRowOut = pRow;
	}
	else
	{
		pData = NULL;
		if (pRowOut)
			*pRowOut = pRow;
	}

	return pData;
}	// end of GetData - 2


COrcaRow* COrcaTable::FindRowByKeys(CStringArray& rstrKeys) const
{
	int cKeys = GetKeyCount();

	// start at the top and look for a matching row
	BOOL bFound = FALSE;
	COrcaData* pData = NULL;
	COrcaRow* pRow = NULL;
	POSITION pos = m_rowList.GetHeadPosition();
	while (pos)
	{
		pRow = m_rowList.GetNext(pos);
		ASSERT(pRow);
		if (!pRow)
			continue;

		// loop through the strings in the passed in array looking for an exact match
		bFound = TRUE;  // assume we'll find a match this time
		for (int j = 0; j < cKeys; j++)
		{
			pData = pRow->GetData(j);
			ASSERT(pData);
			if (!pData)
				continue;

			// if we broke the matches
			if (pData->GetString() != rstrKeys.GetAt(j))
			{
				bFound = FALSE;
				break;
			}
		}

		if (bFound)
			break;
	}
	return pRow;
}

///////////////////////////////////////////////////////////
// FindRow -- finds a row by primary key without querying 
// the database.
COrcaRow* COrcaTable::FindDuplicateRow(COrcaRow* pBaseRow) const
{
	COrcaRow* pRow = NULL;
	int cKeys = GetKeyCount();
	if (pBaseRow->GetColumnCount() < cKeys)
		return NULL;
	
	CStringArray strArray;
	for (int i=0; i < cKeys; i++)
	{
		COrcaData* pBaseData = pBaseRow->GetData(i);
		ASSERT(pBaseData);
		if (!pBaseData)
			return NULL;
		
		// if we broke the matches
		strArray.Add(pBaseData->GetString());
	}

	return FindRowByKeys(strArray);
}

///////////////////////////////////////////////////////////
// CreateTable - builds an MSI table based on this object
// this might be useful when we can add custom tables, 
// but right now its bloat
/* 
UINT COrcaTable::CreateTable(MSIHANDLE hDatabase)
{
	m_fShadow = false;

	UINT iResult;
	CString strSQL;	// sql statement to create table
	strSQL.Format(_T("CREATE TABLE `%s` ("), m_strName);

	// loop through all columns - never more than 32
	COrcaColumn* pCol;
	CString strAdd;
	int cCols = static_cast<int>(m_colArray.GetSize());
	for (int i = 0; i < cCols; i++)
	{
		// get the column
		pCol = m_colArray.GetAt(i);

		switch (pCol->m_eiType)
		{
		case iColumnString:
		case iColumnLocal:
			strAdd.Format(_T("`%s` CHAR(%d)"), pCol->m_strName, pCol->m_iSize);
			break;
		case iColumnShort:
			strAdd.Format(_T("`%s` SHORT"), pCol->m_strName);
			break;
		case iColumnLong:
			strAdd.Format(_T("`%s` LONG"), pCol->m_strName);
			break;
		case iColumnBinary:
			strAdd.Format(_T("`%s` OBJECT"), pCol->m_strName);
			break;
		default:
			ASSERT(FALSE);
		}

		// set the extra flags
		if (!pCol->m_bNullable)
			strAdd += _T(" NOT NULL");
		if (iColumnLocal == pCol->m_eiType)
			strAdd += _T(" LOCALIZABLE");

		strSQL += strAdd;

		// if not last column tack on a comma
		if (i < cCols - 1)
			strSQL += _T(", ");
	}

	// first key HAS to be a primary eky
	strSQL += _T(" PRIMARY KEY `") + m_colArray.GetAt(0)->m_strName;

	// check if any other colums are primary keys
	for (i = 1; i < cCols; i++)
	{
		// get the column
		pCol = m_colArray.GetAt(i);

		// if this is a primary key
		if (pCol->m_bPrimaryKey)
			strSQL += _T("`, `") + pCol->m_strName;
		else
			break;	// no more primary keys
	}

	// close the query with a paren
	strSQL += _T("`)");

	// now execute the create table SQL
	CQuery queryAdd;
	if (ERROR_SUCCESS == (iResult = queryAdd.Open(hDatabase, strSQL)))
		iResult = queryAdd.Execute();
	ASSERT(ERROR_SUCCESS == iResult);

	return iResult;
}	// end of CreateTable
*/


///////////////////////////////////////////////////////////
// GetKeyCount
UINT COrcaTable::GetKeyCount() const
{
	int cKeys = 0;
	int cCols = static_cast<int>(m_colArray.GetSize());

	for (int i = 0; i < cCols; i++)
	{
		if (m_colArray.GetAt(i)->IsPrimaryKey())
			cKeys++;
	}

	return cKeys;
}	// end of GetKeyCount

///////////////////////////////////////////////////////////
// GetErrorCount
int COrcaTable::GetErrorCount()
{
	int cErrors = 0;

	// loop through the rows cleaning up
	POSITION pos = m_rowList.GetHeadPosition();
	while (pos)
		cErrors += m_rowList.GetNext(pos)->GetErrorCount();

	return cErrors;
}	// end of GetErrorCount

///////////////////////////////////////////////////////////
// GetWarningCount
int COrcaTable::GetWarningCount()
{
	int cWarnings = 0;

	// loop through the rows cleaning up
	POSITION pos = m_rowList.GetHeadPosition();
	while (pos)
		cWarnings += m_rowList.GetNext(pos)->GetWarningCount();

	return cWarnings;
}	// end of GetWarningCount

///////////////////////////////////////////////////////////
// ClearErrors
void COrcaTable::ClearErrors()
{
	m_eiError = iTableNoError;	// clear the table's error
	m_bContainsValidationErrors = false;
	m_strErrorList.RemoveAll();

	// loop through the rows cleaning up
	POSITION pos = m_rowList.GetHeadPosition();
	while (pos)
		m_rowList.GetNext(pos)->ClearErrors();
}	// end of ClearErrors

///////////////////////////////////////////////////////////////////////
// Find()
// searches for the specified string in the Table
// if found, returns true and fires an Update with a CHANGE_TABLE
// to the new table, followed by an update with a SET_SEL
// Currently this could find stuff in the original or transformed 
// database
bool COrcaTable::Find(OrcaFindInfo &FindInfo, COrcaRow *&pRow, int &iCol) const {

	INT_PTR iMax = m_rowList.GetCount();
	pRow = NULL;
	iCol = COLUMN_INVALID;

	POSITION pos = FindInfo.bForward ? m_rowList.GetHeadPosition()
							 		 : m_rowList.GetTailPosition();
	while (pos)
	{
		pRow = FindInfo.bForward  ? m_rowList.GetNext(pos)
								  : m_rowList.GetPrev(pos);
		if (pRow->Find(FindInfo, iCol)) {
			return true;
		}
	}
	return false;
}

UINT COrcaTable::DropTable(MSIHANDLE hDatabase)
{
	CQuery queryDrop;
	return queryDrop.OpenExecute(hDatabase, NULL, _T("DROP TABLE `%s`"), m_strName);
}

void COrcaTable::EmptyTable() 
{
	// destroy the row list
	while (!m_rowList.IsEmpty())
		delete m_rowList.RemoveHead();
	m_bRetrieved = false;
	m_iTransformedDataCount = 0;

	// release any database holds
	if (m_eiTableLocation == odlSplitOriginal || m_eiTableLocation == odlNotSplit)
	{
		CQuery qHoldQuery;
		qHoldQuery.OpenExecute(m_pDoc->GetOriginalDatabase(), 0, TEXT("ALTER TABLE `%s` FREE"), m_strName);
	}
	if (m_pDoc->DoesTransformGetEdit() && (m_eiTableLocation == odlSplitTransformed || m_eiTableLocation == odlNotSplit))
	{
		CQuery qHoldQuery;
		qHoldQuery.OpenExecute(m_pDoc->GetTransformedDatabase(), 0, TEXT("ALTER TABLE `%s` FREE"), m_strName);
	}

	ClearErrors();
}

///////////////////////////////////////////////////////////
// RetrieveTable
void COrcaTable::RetrieveTableData()
{
	TRACE(_T("COrcaTable::RetrieveTable - called for table: %s\n"), m_strName);

	// if this table has already been retrieved return
	if (m_bRetrieved)
		return;
	
	// if we ever use the "tranfsormed" attribute of the MSI table, a transform
	// count will exist even before the data is loaded.
	m_iTransformedDataCount = 0;

	bool fOriginalTableExists = (MSICONDITION_TRUE == MsiDatabaseIsTablePersistent(m_pDoc->GetOriginalDatabase(), m_strName));
	bool fTransformedTableExists = (MSICONDITION_TRUE == MsiDatabaseIsTablePersistent(m_pDoc->GetTransformedDatabase(), m_strName));

	// provide scope for marking column
	{
		// if possible, use a temporary marking column in the transformed DB
		// for perf gains when cross-referencing data
		CQuery qMarkColumn;
		bool fMarkingColumn = false;
	
		// a table can exist in one or both databases. Because a transform can
		// completely redefine a table a "retrieve" must not rely just on the presence
		// of a table to load the data
		
		// load from the transformed database first, since it will be the primary database 
		// that is displayed.
		if (m_pDoc->DoesTransformGetEdit() && (m_eiTableLocation == odlSplitTransformed || m_eiTableLocation == odlNotSplit))
		{
			UINT iResult = ERROR_SUCCESS;
			
			// only cross-reference with non-transformed database if this is not a split table
			bool fHaveTransform = (m_eiTableLocation == odlNotSplit);
	
			// open query to cross-reference with the original DB now. Much
			// faster than AddRowObject because the SQL doesn't need to be 
			// parsed and resolved every time.
			CQuery qConflictCheck;

			if (fOriginalTableExists)
			{    
				// if this is not a split table, and the table exists in both databases, attempt 
				// to create a temporary column in the original table to speed up conflict checking
				if (fTransformedTableExists && (m_eiTableLocation != odlSplitTransformed))
				{
					if (ERROR_SUCCESS == qMarkColumn.OpenExecute(m_pDoc->GetOriginalDatabase(), 0, TEXT("ALTER TABLE `%s` ADD `___Orca` INT TEMPORARY"), m_strName))
					{
						fMarkingColumn = true;
					}
				}
				
				if (ERROR_SUCCESS != qConflictCheck.Open(m_pDoc->GetOriginalDatabase(), TEXT("SELECT * FROM `%s` WHERE %s"), m_strName, GetRowWhereClause()))
				{
					return;
				}
			}
	
			if (fTransformedTableExists)
			{
				// open a query on the transformed table
				CQuery queryRows;
				iResult = queryRows.Open(m_pDoc->GetTransformedDatabase(), _T("SELECT * FROM `%s`"), m_strName);
		
				if (ERROR_SUCCESS == iResult)
					iResult = queryRows.Execute();
		
				// retrieve all rows from the transformed database
				COrcaRow* pRow = NULL;
				PMSIHANDLE hRow;
				while (ERROR_SUCCESS == iResult)
				{
					iResult = queryRows.Fetch(&hRow);
		
					if (ERROR_SUCCESS == iResult)
					{
						pRow = new COrcaRow(this, hRow);
						if (!pRow)
							return;
		
						PMSIHANDLE hOriginalRow;
						if (fOriginalTableExists)
						{
							// if necessary, use the row record to cross-reference this row with the original
							// database table. If there is a corresponding row, we need to diff the two rows, 
							// otherwise this row is transformed to a "add" row.
							if (ERROR_SUCCESS != qConflictCheck.Execute(hRow))
							{
								ASSERT(0);
								return;
							}
			
							switch (qConflictCheck.Fetch(&hOriginalRow))
							{
							case ERROR_NO_MORE_ITEMS:
							{
								// row does not exist in the original database, this
								// is a "add"
								pRow->Transform(m_pDoc, iTransformAdd, hOriginalRow, hRow);
								break;
							}
							case ERROR_SUCCESS:
							{
								// row DOES exist in the transformed database, need to diff
								// those two rows
								pRow->Transform(m_pDoc, iTransformChange, hOriginalRow, hRow);
								break;
							}
							default:
								ASSERT(0);
								return;
							}
						}
						else
						{
							// original table doesn't exist, row must be an add
							pRow->Transform(m_pDoc, iTransformAdd, hOriginalRow, hRow);
						}
		
						// update the temporary marking column
						if (fMarkingColumn)
						{
							MsiRecordSetInteger(hOriginalRow, GetOriginalColumnCount()+1, 1);
							if (ERROR_SUCCESS != qConflictCheck.Modify(MSIMODIFY_UPDATE, hOriginalRow))
							{
								// if the marking update failed for some reason, we can
								// no longer rely on the column when reading the transformed
								// database.
								fMarkingColumn = false;
							}
						}
		
						// after the row has been appropriately transformed, add it to
						// the list. No UI update required on initial load.
						m_rowList.AddTail(pRow);
					}
				}
			}
		}
		
		// next load from the original database.
		if (fOriginalTableExists && (m_eiTableLocation == odlSplitOriginal || m_eiTableLocation == odlNotSplit))
		{
			UINT iResult = ERROR_SUCCESS;
			
			// only cross-reference with transformed database if this is not a split table
			bool fCrossReference = fTransformedTableExists && m_pDoc->DoesTransformGetEdit() && (m_eiTableLocation == odlNotSplit);
	
			// only concerned with the presence or absence of the row, not the data,
			// so the query doesn't have to return anything.
			CQuery qConflictCheck;
			if (fCrossReference && !fMarkingColumn)
			{
				if (ERROR_SUCCESS != qConflictCheck.Open(m_pDoc->GetTransformedDatabase(), TEXT("SELECT '1' FROM `%s` WHERE %s"), m_strName, GetRowWhereClause()))
				{
					return;
				}
			}
	
			// retrieve all rows from the original database. If we are using a 
			// marking column during retrieval, there is a big perf gain because
			// conflicts are pre-determined.
			CQuery queryRows;
			if (fMarkingColumn)
			{
				iResult = queryRows.Open(m_pDoc->GetOriginalDatabase(), _T("SELECT * FROM `%s` WHERE `___Orca` <> 1"), m_strName);
			}
			else
			{
				iResult = queryRows.Open(m_pDoc->GetOriginalDatabase(), _T("SELECT * FROM `%s`"), m_strName);
			}
	
			if (ERROR_SUCCESS == iResult)
				iResult = queryRows.Execute();
	
			COrcaRow* pRow = NULL;
			PMSIHANDLE hOriginalRow;
			PMSIHANDLE hTransformedRow;
			while (ERROR_SUCCESS == iResult)
			{
				iResult = queryRows.Fetch(&hOriginalRow);
	
				if (ERROR_SUCCESS == iResult)
				{
					// if a cross-reference is required, and conflicting rows are not already
					// marked in the ___Orca column, check for an existing row in the transformed
					// database with the same primary keys
					if (fCrossReference && !fMarkingColumn)
					{
						qConflictCheck.Execute(hOriginalRow);
	
						switch (qConflictCheck.Fetch(&hTransformedRow))
						{
						case ERROR_NO_MORE_ITEMS:
						{
							// does not exist in the other database, so this is a "drop"
							pRow = new COrcaRow(this, hOriginalRow);
							pRow->Transform(m_pDoc, iTransformDrop, hTransformedRow, hOriginalRow);
							break;
						}
						case ERROR_SUCCESS:
						{
							// row does exist, transform was done in previous load
							pRow = NULL;
							break;
						}
						default:
							ASSERT(0);
							return;
						}
					}
					else
					{
						pRow = new COrcaRow(this, hOriginalRow);
	
						// if we skipped conflict checks because a marking column was
						// being used, we can assume that this is a drop row.
						// Also assume its a drop row if the transformed table doesn't 
						// exist but the transform itself does 
						if (fMarkingColumn || (m_pDoc->DoesTransformGetEdit() && !fTransformedTableExists))
						{
							pRow->Transform(m_pDoc, iTransformDrop, 0, hOriginalRow);
						}
					}
	
					// if a new row object was created from the transformed table, add it to
					// the list. No UI update required on initial load.
					if (pRow)
					{
						m_rowList.AddTail(pRow);
					}
				}
			}
		}
	}

	// add HOLDs to the table. Must do this last because the temporary column needs
	// to vanish first
	if (m_eiTableLocation == odlSplitOriginal || m_eiTableLocation == odlNotSplit)
	{
		// add a hold to the table to prevent repeatedly loading and unloading the table
		CQuery qHoldQuery;
		qHoldQuery.OpenExecute(m_pDoc->GetOriginalDatabase(), 0, TEXT("ALTER TABLE `%s` HOLD"), m_strName);
	}
	if (m_pDoc->DoesTransformGetEdit() && (m_eiTableLocation == odlSplitTransformed || m_eiTableLocation == odlNotSplit))
	{
		// add a hold to the table to prevent repeatedly loading and unloading the table
		CQuery qHoldQuery;
		qHoldQuery.OpenExecute(m_pDoc->GetTransformedDatabase(), 0, TEXT("ALTER TABLE `%s` HOLD"), m_strName);
	}

	m_bRetrieved = TRUE;	// set the table as retrieved
}	// end of RetrieveTable

void COrcaTable::ShadowTable(CString strTable)
{
	m_eiError = iTableNoError;
	m_strName = strTable;
	m_bRetrieved = false;
	m_fShadow = true;
	m_eiTableLocation = odlShadow;
}

void COrcaTable::LoadTableSchema(MSIHANDLE hDatabase, CString szTable)
{
	if (!m_colArray.GetSize())
	{
		m_strName = szTable;
		m_eiTableLocation = odlNotSplit;
		m_bRetrieved = FALSE;
		m_fShadow = false;
	}
	else 
	{
		// already have a loaded schema
		ASSERT(szTable == m_strName);
	
		// if we're adding more columns and the table is already loaded, we MUST
		// immediately destroy all of the rows, because they are out of sync and
		// don't contain enough data objects to fill the columns.
		m_bRetrieved = FALSE;
		EmptyTable();
	}

	// get primary keys for table
	PMSIHANDLE hPrimaryKeys;
	if (ERROR_SUCCESS != MsiDatabaseGetPrimaryKeys(hDatabase, szTable, &hPrimaryKeys))
		return;

	// query table
	CQuery queryRow;
	if (ERROR_SUCCESS != queryRow.Open(hDatabase, _T("SELECT * FROM `%s`"), szTable))
		return;

	// get the column info then create the table
	PMSIHANDLE hColNames;
	PMSIHANDLE hColTypes;
	queryRow.GetColumnInfo(MSICOLINFO_NAMES, &hColNames);
	queryRow.GetColumnInfo(MSICOLINFO_TYPES, &hColTypes);

	// shadow tables should keep their table errors
	if (!m_fShadow)
	{
		m_eiError = iTableNoError;
	}

	UINT cColumns = ::MsiRecordGetFieldCount(hColNames);
	UINT cKeys = ::MsiRecordGetFieldCount(hPrimaryKeys);

	// set the size of the array then create each new column. Limit of 32 colums, cast OK.
	COrcaColumn* pColumn;
	UINT cOldColumns = static_cast<int>(m_colArray.GetSize());
	if (!m_cOriginalColumns)
		m_cOriginalColumns = cColumns;
	m_colArray.SetSize(cColumns);
	for (UINT i = cOldColumns; i < cColumns; i++)
	{
		pColumn = new COrcaColumn(i, hColNames, hColTypes, (i < cKeys));	// key bool set if index is still in primary key range
		if (!pColumn)
			continue;

		// if we already had columns when we started reading from this database, these are
		// transform-added columns
		if (cOldColumns != 0)
			pColumn->Transform(iTransformAdd);
			
		m_colArray.SetAt(i, pColumn);
	}

	// schema changed, so rebuild the SQL query
	BuildRowWhereClause();
}

// IsSchemaDifferent returns true if the table definition referenced by hDatabase 
// differs from the object's idea of the table definition. If fStrict is
// true, the match must be exact. If fStrict is false, the hDatabase
// table can have more columns at the end and still be considered a match
// (this supports using one object for a transform that adds columns)
// fExact returns true if the match is exact. If fStrict is true, retval==!fExact
bool COrcaTable::IsSchemaDifferent(MSIHANDLE hDatabase, bool fStrict, bool &fExact)
{
	fExact = false;
	
	// get primary keys for table
	PMSIHANDLE hPrimaryKeys;
	if (ERROR_SUCCESS != MsiDatabaseGetPrimaryKeys(hDatabase, m_strName, &hPrimaryKeys))
		return true;

	// query table
	CQuery queryRow;
	if (ERROR_SUCCESS != queryRow.Open(hDatabase, _T("SELECT * FROM `%s`"), m_strName))
		return true;

	// get the column info then create the table
	PMSIHANDLE hColNames;
	PMSIHANDLE hColTypes;
	queryRow.GetColumnInfo(MSICOLINFO_NAMES, &hColNames);
	queryRow.GetColumnInfo(MSICOLINFO_TYPES, &hColTypes);

	int cColumns = ::MsiRecordGetFieldCount(hColNames);
	int cKeys = ::MsiRecordGetFieldCount(hPrimaryKeys);

	// if the number of columns doesn't exactly match, fExact is false
	// and strict fails immediately
	if (cColumns != m_colArray.GetSize())
	{
		fExact = false;
		if (fStrict)
			return true;
	}

	// if the number of columns is too small, even non-strict fails
	if (!fStrict && cColumns < m_colArray.GetSize())
		return true;

	// compare the columns up to the number of columns in the object. 
	// limit of 32 columns, so int cast OK on Win64
	COrcaColumn* pColumn = NULL;
	int cMemColumns = static_cast<int>(m_colArray.GetSize());
	for (int i = 0; i < cMemColumns; i++)
	{
		// now check the column type
		pColumn = m_colArray.GetAt(i);
		if (!pColumn)
			continue;
		if (!pColumn->SameDefinition(i, hColNames, hColTypes, (i < cKeys)))
			return true;
	}	

	// no change or non-strict match
	fExact = (cMemColumns == cColumns);
	return false;
}

UINT COrcaTable::AddRow(CStringList* pstrDataList)
{
	UINT iResult = ERROR_SUCCESS;
	// retrieve column counts. Never greater than 32
	int cData = static_cast<int>(pstrDataList->GetCount());
	int cColumns = static_cast<int>(m_colArray.GetSize());
	int i = 0;

	ASSERT(cData == cColumns);

	COrcaRow* pRow = new COrcaRow(this, pstrDataList);
	if (!pRow)
		return ERROR_OUTOFMEMORY;

	// first query the database to see whether this is a dupe primary key
	CQuery queryDupe;
	CString strDupeQuery;
	strDupeQuery.Format(_T("SELECT '1' FROM `%s` WHERE %s"), Name(), GetRowWhereClause());

	PMSIHANDLE hDupeRec;
	PMSIHANDLE hQueryRec = pRow->GetRowQueryRecord();
	if (!hQueryRec)
	{
		delete pRow;
		return ERROR_FUNCTION_FAILED;
	}

	switch (queryDupe.FetchOnce(m_pDoc->GetTargetDatabase(), hQueryRec, &hDupeRec, strDupeQuery)) 
	{
	case ERROR_NO_MORE_ITEMS :
		// row does not exist in the database, so the add can succeed
		break;
	case ERROR_SUCCESS :
		// row DOES exist in the database so this is a duplicate primary key
		// fall through
	default:
		// this is bad
		delete pRow;
		return ERROR_FUNCTION_FAILED;
	}
				
	COrcaColumn* pColumn = NULL;
	PMSIHANDLE hRec = MsiCreateRecord(cColumns);

	POSITION pos = pstrDataList->GetHeadPosition();
	while (pos)
	{
		pColumn = m_colArray.GetAt(i);
		ASSERT(pColumn);
		if (!pColumn)
		{
			iResult = ERROR_FUNCTION_FAILED;
			break;
		}

		iResult = ERROR_SUCCESS;
		// call the appropriate MSI API to add the data to the record.
		switch(pColumn->m_eiType)
		{
		case iColumnString:
		case iColumnLocal:
			iResult = MsiRecordSetString(hRec, i + 1, pstrDataList->GetNext(pos));
			ASSERT(ERROR_SUCCESS == iResult);
			break;
		case iColumnShort:
		case iColumnLong:
			{
				CString strData = pstrDataList->GetNext(pos);
				DWORD dwData = 0;
				if (strData.IsEmpty())
				{
					if (!pColumn->m_bNullable)
					{
						iResult = ERROR_FUNCTION_FAILED;
						break;
					}
					iResult = MsiRecordSetString(hRec, i+1, _T(""));
				}
				else
				{
					if (!ValidateIntegerValue(strData, dwData))
					{
						iResult = ERROR_FUNCTION_FAILED;
						break;
					}
					iResult = MsiRecordSetInteger(hRec, i+1, dwData);
				}
			}
			break;
		case iColumnBinary:
			{
			CString strFile = pstrDataList->GetNext(pos);
			if (!strFile.IsEmpty())
				iResult = ::MsiRecordSetStream(hRec, i + 1, strFile);
			break;
			}
		default:
			TRACE(_T(">> Error unknown column type.\n"));
			ASSERT(FALSE);
		}

		i++;
	}

	// if everything worked, update the document
	if (ERROR_SUCCESS == iResult)
	{
		CQuery queryTable;
		if (ERROR_SUCCESS == (iResult = queryTable.Open(m_pDoc->GetTargetDatabase(), _T("SELECT * FROM `%s`"), m_strName)))
		{
			if (ERROR_SUCCESS == (iResult = queryTable.Execute()))
				iResult = queryTable.Modify(MSIMODIFY_INSERT, hRec);
		}

		if (ERROR_SUCCESS == iResult)
		{
			// we have been able to add the row to the target database. Now add the row
			// to the UI
			AddRowObject(pRow, true, false, hRec);
			m_pDoc->SetModifiedFlag(TRUE);
		}
	}
	
	if (ERROR_SUCCESS != iResult)
	{
		delete pRow;
	}
	return iResult;
}

bool COrcaTable::DropRow(COrcaRow *pRow, bool fPerformDrop)
{
	ASSERT(m_pDoc);
	ASSERT(pRow);
	CQuery qDrop;
	CString strDrop;
	strDrop = _T("DELETE FROM `")+m_strName+_T("` WHERE") + GetRowWhereClause();
	PMSIHANDLE hQueryRec = pRow->GetRowQueryRecord();
	if (!hQueryRec)
		return false;

	switch (qDrop.OpenExecute(m_pDoc->GetTargetDatabase(), hQueryRec, strDrop)) 
	{
	case ERROR_NO_MORE_ITEMS :
	{
		// row does not exist in the database. Most likely this means we are trying
		// to drop a row that has already been deleted or only exists in the non-target
		// database
		ASSERT(0);
		return false;
	}
	case ERROR_SUCCESS :
	{
		// dropped OK.
		DropRowObject(pRow, /*fPerformDrop=*/true);
		//** pRow has been deleted after this. Don't use it.
		return true;
	}
	default:
		return false;
	}
}


// DropRowObject determines if this object should be removed from the table based on the 
// presence of the row in the non-target database and either removes or changes to an 
// "add" or "drop" row. Call with fPerformDrop false to not actually remove the object from
// the UI (so it can be reused in a primary key change for example). Returns true if row was 
// actually dropped, false if row was just transformed. Deletes the row from memory if removed 
// from table. Returns true if it was actually deleted
bool COrcaTable::DropRowObject(COrcaRow *pRow, bool fPerformDrop)
{
	ASSERT(m_pDoc);
	ASSERT(pRow);

	// if this table is listed as a split source, the object should definitely
	// be deleted because there's no way that it can exist in a non-target database
	if (m_eiTableLocation != odlNotSplit)
	{
		if (fPerformDrop)
		{
 			m_rowList.RemoveAt(m_rowList.Find(const_cast<CObject *>(static_cast<const CObject *>(pRow))));
			pRow->RemoveOutstandingTransformCounts(m_pDoc);
			m_pDoc->UpdateAllViews(NULL, HINT_DROP_ROW, pRow);
			delete pRow;
		}
		return true;
	}
	
	// this query checks to see if the row exists in the opposite database than we are editing
	if (m_pDoc->DoesTransformGetEdit())
	{
		CQuery queryDupe;
		CString strDupe;
		strDupe = _T("SELECT '1' FROM `")+m_strName+_T("` WHERE") + GetRowWhereClause();
		PMSIHANDLE hDupeRec;
		
		PMSIHANDLE hQueryRec = pRow->GetRowQueryRecord();
		if (!hQueryRec)
			return false;
		switch (queryDupe.FetchOnce(m_pDoc->GetOriginalDatabase(), hQueryRec, &hDupeRec, strDupe)) 
		{
		case ERROR_NO_MORE_ITEMS :
		{
			// A does not exist in the opposite database (meaning it now exists nowhere) so 
			// this object can actually be deleted
			if (fPerformDrop)
			{
				// if this row was added, we lose a transform count here
				m_rowList.RemoveAt(m_rowList.Find(const_cast<CObject *>(static_cast<const CObject *>(pRow)))); 	
				pRow->RemoveOutstandingTransformCounts(m_pDoc);
				m_pDoc->UpdateAllViews(NULL, HINT_DROP_ROW, pRow);
				delete pRow;
			}
			return true;
		}
		case ERROR_SUCCESS :
		{
			// A DOES exist in the opposite database, so if transform editing is enabled, convert 
			// the existing row to a "drop", but leave it in the UI.
			pRow->Transform(m_pDoc, iTransformDrop, 0, 0);
			m_pDoc->UpdateAllViews(NULL, HINT_CELL_RELOAD, pRow);
			return false;
		}
		default:
			return false;
		}
	}
	else
	{
		// if no transforms, this is a simple drop
		if (fPerformDrop)
		{
			m_rowList.RemoveAt(m_rowList.Find(const_cast<CObject *>(static_cast<const CObject *>(pRow)))); 	
			m_pDoc->UpdateAllViews(NULL, HINT_DROP_ROW, pRow);
			delete pRow;
		}
	}

	m_pDoc->SetModifiedFlag(TRUE);
	return true;
}

// returns true if it should be added, false if it should be\has been destroyed
// pRow is the row of interest. fUIUpdate is 
// false if the UI should not be updated (allowed to get out of sync). Note: you 
// will still get a UI update on the destruction of an existing row even if
// fUIUpdate is FALSE. This guarantees that a WM_PAINT message won't try to 
// access the deleted memory of the destroyed row
bool COrcaTable::AddRowObject(COrcaRow *pRow, bool fUIUpdate, bool fCleanAdd, MSIHANDLE hNewRowRec)
{
	// if the table is a split table, we can definitely do the add
	if (m_eiTableLocation != odlNotSplit)
	{
		// If we're already in the target state, it means we're just editing the 
		// primary keys of a row of that type without changing the type, so don't add 
		// it to the UI again.
		OrcaTransformAction iAction = m_pDoc->DoesTransformGetEdit() ? iTransformAdd : iTransformDrop;
		if (pRow->IsTransformed() != iAction)
		{
			pRow->Transform(m_pDoc, iAction, 0, hNewRowRec);
			m_rowList.AddTail(pRow);
			if (fUIUpdate)
				m_pDoc->UpdateAllViews(NULL, HINT_ADD_ROW, pRow);
		}
		return true;
	}
	
	// if transforms are enabled, and we haven't been explicitly told to do a clean add, adding 
	// to the row becomes a bit more complicated, because a row could exist in-memory already 
	// with the same primary keys.
	if (!fCleanAdd && m_pDoc->DoesTransformGetEdit())
	{
		CQuery queryDupe;
		CString strDupe;
		PMSIHANDLE hDupeRec;
		strDupe = _T("SELECT '1' FROM `")+m_strName+_T("` WHERE") + GetRowWhereClause();
		
		// this query checks to see if a row with the same primary keys already exists in the 
		// non-target database.
		PMSIHANDLE hQueryRecord = pRow->GetRowQueryRecord();
		switch (queryDupe.FetchOnce(m_pDoc->GetOriginalDatabase(), hQueryRecord, &hDupeRec, strDupe)) 
		{
		case ERROR_BAD_QUERY_SYNTAX:
		case ERROR_NO_MORE_ITEMS :
		{
			// row does not exist in the opposite database, so this becomes an "add". If we're already
			// in the target state, it means we're just editing the primary keys of a row
			// of that type without changing the type, so don't add it to the UI again.
			if (pRow->IsTransformed() != iTransformAdd)
			{
				pRow->Transform(m_pDoc, iTransformAdd, hDupeRec, hNewRowRec);
				m_rowList.AddTail(pRow);
				if (fUIUpdate)
					m_pDoc->UpdateAllViews(NULL, HINT_ADD_ROW, pRow);
			}
			return true;
		}
		case ERROR_SUCCESS :
		{
			queryDupe.Close();
			MsiCloseHandle(hDupeRec);

			// new row DOES exist in the opposite database. If it has an in-memory
			// representation already, the existing record becomes a "change" record 
			// and the new record is destroyed. Otherwise its just an add (this happens
			// when initially loading the tables while a transform is active)
			COrcaRow* pOldRow = FindDuplicateRow(pRow);

			if (pOldRow)
			{
				for (int iCol = 0; iCol < pOldRow->GetColumnCount(); iCol++)
				{
					pOldRow->GetData(iCol)->SetData(pRow->GetData(iCol)->GetString());
				}
				pOldRow->Transform(m_pDoc, iTransformChange, 0, hNewRowRec);
				if (fUIUpdate)
					m_pDoc->UpdateAllViews(NULL, HINT_CELL_RELOAD, pOldRow);

				// the row we are adding already exists in the UI (ex: changing an "add" row key
				// to match a dropped row.) so it needs to be dropped before it is destroyed.
				POSITION pos = NULL;
				if (NULL != (pos = m_rowList.Find(static_cast<CObject *>(pRow))))
				{
					m_rowList.RemoveAt(pos); 	
					pRow->RemoveOutstandingTransformCounts(m_pDoc);
					m_pDoc->UpdateAllViews(NULL, HINT_DROP_ROW, pRow);
				}
				delete pRow;
			}
			else
			{
				// this should only happen while initially loading a table into the UI (otherwise the UI
				// state should always track the row existence in the databases.) In this case, if
				// transforms get edits, it means that the non-target database is the original DB.
				// Since it exists in the original DB, its a "Drop" if transforms get edits
				OrcaTransformAction iAction = m_pDoc->DoesTransformGetEdit() ? iTransformDrop : iTransformAdd;
				if (pRow->IsTransformed() != iAction)
				{
					pRow->Transform(m_pDoc, iAction, 0, hNewRowRec);
					m_rowList.AddTail(pRow);
					if (fUIUpdate)
						m_pDoc->UpdateAllViews(NULL, HINT_ADD_ROW, pRow);
				}
				return true;
			}

			return false;
		}
		default:
			// this is just as bad as above
			return false;;
		}
	}
	else
	{
		// if no transforms, this is a simple add
		m_rowList.AddTail(pRow);
		if (fUIUpdate)
			m_pDoc->UpdateAllViews(NULL, HINT_ADD_ROW, pRow);
	}

	return true;
}

UINT COrcaTable::ChangeData(COrcaRow *pRow, UINT iCol, CString strData)
{
	ASSERT(m_pDoc && pRow);
	if (!m_pDoc || !pRow)
		return ERROR_FUNCTION_FAILED;

	// if changing a primary key, this becomes a drop and add from a UI point of view,
	// with the possibility that everything is a change.
	if (m_colArray.GetAt(iCol)->IsPrimaryKey())
	{
		UINT iStat = ERROR_SUCCESS;
		// make the actual database change. For primary keys, this does NOT change
		// the UI representation of this row
		if (ERROR_SUCCESS == (iStat = pRow->ChangeData(m_pDoc, iCol, strData)))
		{
			// drop the old primay keys. If DropRowObject returns false, it means that the row
			// was not dropped, just transformed. So it won't work for the add.
			bool fNeedCopy = !DropRowObject(pRow, false);

			if (fNeedCopy)
			{
				COrcaRow *pNewRow = new COrcaRow(pRow);
				pNewRow->GetData(iCol)->SetData(strData);

				// will destroy copy if its not needed
				AddRowObject(pNewRow, true, false, 0);			
			}
			else
			{
				pRow->GetData(iCol)->SetData(strData);
				if (m_pDoc->DoesTransformGetEdit())
				{
					AddRowObject(pRow, true, false, 0);
				}
			}
			m_pDoc->SetModifiedFlag(TRUE);
		}
		return iStat;
	}
	else
	{
		// make the actual database change. For non-primary keys, this changes the UI as well.
		return pRow->ChangeData(m_pDoc, iCol, strData);
	}
}

/////////////////////////////////////////////////////////////////////////////
// table level transform ops are interesting because they often arise from
// adds and drops which require on-the-fly comparisons between the two
// databases or reversions to DB versions
void COrcaTable::Transform(const OrcaTransformAction iAction) 
{	
	ASSERT(m_pDoc);
	if (!m_pDoc)
		return;

	switch (iAction)
	{
		case iTransformAdd:
		{
			// set the table-level action
			m_iTransform = iAction;

			// when a table is "add"ed, it means it didn't exist in the opposite database,
			// otherwise we would have "untransformed" or split-sourced the existing table.
			// thus nothing is required except to mark the table and all of its
			// data as "add"
			RetrieveTableData();
			POSITION rowPos = GetRowHeadPosition();
			while (rowPos)
			{
				COrcaRow *pRow = const_cast<COrcaRow *>(GetNextRow(rowPos));
				if (!pRow)
					continue;

				pRow->Transform(m_pDoc, iTransformAdd, 0, 0);
			}
			break;
		}
		case iTransformDrop:
		{
			// set the table-level action
			m_iTransform = iAction;

			// when a table is dropped, it means that it exists in the non-target
			// database (otherwise it would have been simply deleted). This means
			// that we need to "clean house" in this table and reload in case
			// any edits were made before the drop. This ensures that the "dropped"
			// UI accurately reflects the contents of the other database and not
			// the contents of the target database before the drop.
			bool fSchemaChanged = false;

	
			// for split-source tables, a transform operation doesn't require any schema
			// work. Transform ops on split sources only happen when the table is first
			// created, so no reload is necessary either
			if (!IsSplitSource())
			{

				// if the schema of the remaining table is not exactly the same as what our object
				// thinks, it means that the dropped table has more columns than the remaining table
				// in this case, we have to do a reload in the UI because one or more columns is
				// now useless

				//!!future: in the future we can do a non-strict comparison and selectively delete
				//!!future: the columns so that a UI refresh is sufficient (don't lose width settings)
				bool fExact = false;
				if (IsSchemaDifferent(m_pDoc->GetOriginalDatabase(), true, fExact))
				{
					LoadTableSchema(m_pDoc->GetOriginalDatabase(), Name());
					fSchemaChanged = true;
				}
				else
				{
					// otherwise there is no need to load the schema, but we still need
					// to empty out the table and reload the rows
					EmptyTable();
				}

			}
			// now retrieve the table data
			RetrieveTableData();

			// and all data in the existing table is "dropped" because the new table is empty
			POSITION rowPos = GetRowHeadPosition();
			while (rowPos)
			{
				COrcaRow *pRow = const_cast<COrcaRow *>(GetNextRow(rowPos));
				if (!pRow)
					continue;

				pRow->Transform(m_pDoc, iAction, 0, 0);
			}

			if (fSchemaChanged)
			{
				// refresh the UI in the table list
				m_pDoc->UpdateAllViews(NULL, HINT_TABLE_REDEFINE, this);
			}
			else
			{
				// refresh the UI in the table list
				m_pDoc->UpdateAllViews(NULL, HINT_REDRAW_TABLE, this);
				
				// refresh the UI in the table list
				m_pDoc->UpdateAllViews(NULL, HINT_TABLE_DATACHANGE, this);
			}
			break;
		}
		case iTransformNone:
			m_iTransform = iTransformNone;
			break;
		case iTransformChange:
		default:
			ASSERT(0);
			break;
	}
}

/////////////////////////////////////////////////////////////////////////////
// fills the provided array with the column names, either full or non-transformed
void COrcaTable::FillColumnArray(CTypedPtrArray<CObArray, COrcaColumn*>* prgColumn, bool fIncludeAdded) const
{
	// 32 columns max, so cast OK.
	int cColumns = static_cast<int>(m_colArray.GetSize());
	int i = 0;

	prgColumn->SetSize(cColumns);
	for (i = 0; i < cColumns; i++)
	{
		if (!fIncludeAdded && m_colArray.GetAt(i)->IsTransformed())
			break;
		prgColumn->SetAt(i, m_colArray.GetAt(i));
	}
	prgColumn->SetSize(i);
}


void COrcaTable::IncrementTransformedData() 
{	
	if (++m_iTransformedDataCount == 1)
	{
		ASSERT(m_pDoc);
		if (!m_pDoc)
			return;

		// refresh the UI in the table list
		m_pDoc->UpdateAllViews(NULL, HINT_REDRAW_TABLE, this);
	}
}

void COrcaTable::DecrementTransformedData()
{
	if (--m_iTransformedDataCount == 0)
	{
		ASSERT(m_pDoc);
		if (!m_pDoc)
			return;

		// refresh the UI in the table list
		m_pDoc->UpdateAllViews(NULL, HINT_REDRAW_TABLE, this);
	}
}

const CString COrcaTable::GetRowWhereClause() const
{
	return m_strWhereClause;
}

void COrcaTable::BuildRowWhereClause()
{
	// add the key strings to query to do the exact look up
	m_strWhereClause = _T("(");
	UINT cKeys = GetKeyCount();
	for (UINT i = 0; i < cKeys; i++)
	{
		CString strAddQuery;
		// get the column
		COrcaColumn *pColumn = ColArray()->GetAt(i);
		ASSERT(pColumn);

		strAddQuery.Format(_T("`%s`=?"), pColumn->m_strName);
			
		// if this is not the last row
		if (i < (cKeys - 1))
			m_strWhereClause  += strAddQuery + _T(" AND ");
		else	// it is the last row so close with a paren
			m_strWhereClause  += strAddQuery + _T(")");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\summaryd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

#if !defined(AFX_SUMMARYD_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_)
#define AFX_SUMMARYD_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SummaryD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSummaryD dialog

class CSummaryD : public CDialog
{
// Construction
public:
	CSummaryD(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSummaryD)
	enum { IDD = IDD_SUMMARY_INFORMATION };
	CString	m_strAuthor;
	CString	m_strComments;
	CString	m_strKeywords;
	CString	m_strLanguages;
	CString	m_strPlatform;
	CString	m_strProductID;
	int		m_nSchema;
	int		m_nSecurity;
	CString	m_strSubject;
	CString	m_strTitle;
	BOOL	m_bAdmin;
	BOOL	m_bCompressed;
	int		m_iFilenames;
	CComboBox m_ctrlPlatform;
	CEdit   m_ctrlSchema;

	CEdit   m_ctrlAuthor;
	CEdit   m_ctrlComments;
	CEdit   m_ctrlKeywords;
	CEdit   m_ctrlLanguages;
	CEdit   m_ctrlProductID;
	CEdit   m_ctrlSubject;
	CEdit   m_ctrlTitle;
	CComboBox m_ctrlSecurity;
	CButton m_ctrlAdmin;
	CButton m_ctrlCompressed;
	CButton m_ctrlSFN;
	CButton m_ctrlLFN;
	//}}AFX_DATA

	bool    m_bReadOnly;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSummaryD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSummaryD)
	afx_msg void OnChangeSchema();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SUMMARYD_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\table.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Table.h
//

#ifndef _ORCA_TABLE_H_
#define _ORCA_TABLE_H_

#include "msiquery.h"
#include "Column.h"
#include "Row.h"

enum OrcaTableError
{
	iTableNoError,
	iTableError,
	iTableWarning
};

enum odlOrcaDataLocation
{
	odlInvalid,
	odlShadow,
	odlSplitOriginal,
	odlSplitTransformed,
	odlNotSplit,
};

class COrcaDoc;

class COrcaTable : public CObject
{

public:
	COrcaTable(COrcaDoc* pDoc);
	~COrcaTable();

	// LoadTableSchema loads the schema from the database
	void LoadTableSchema(MSIHANDLE hDatabase, CString szTable);

	// RetrieveTable loads data from both databases
	void RetrieveTableData();

	// IsSchemaDifferent returns true if the schema of the database doesn't match the memory schema
	bool IsSchemaDifferent(MSIHANDLE hDatabase, bool fStrict, bool &fExact);

	// checks current memory object against database and marks extra columns as "added"
	void MarkAddedColumnsBasedOnDB(MSIHANDLE hDatabase);

	// object can come from one database or both
	inline bool IsSplitSource() const { return (m_eiTableLocation == odlSplitOriginal || m_eiTableLocation == odlSplitTransformed); };
	inline void SetSplitSource(odlOrcaDataLocation location)  { m_eiTableLocation = location; };
	inline odlOrcaDataLocation GetSplitSource() const { return m_eiTableLocation;};
	
	void EmptyTable();
	UINT DropTable(MSIHANDLE hDatabase);
	void DestroyTable();
	void Transform(const OrcaTransformAction iAction);

	bool Find(OrcaFindInfo &FindInfo, COrcaRow *&pRow, int &iCol) const;

	COrcaData* GetData(UINT nRow, UINT nCol);
	COrcaData* GetData(CString strCol, CStringArray& rstrRows, const COrcaRow** pRow=NULL) const;
//	COrcaRow* FindRow(CStringList& rstrRows);
	
//	UINT CreateTable(MSIHANDLE hDatabase);

	UINT GetKeyCount() const;
	int GetErrorCount();
	int GetWarningCount();
	void ClearErrors();
	void Release();

	// modification functions
	UINT ChangeData(COrcaRow *pRow, UINT iCol, CString strData);
	UINT AddRow(CStringList* pstrDataList);
	UINT AddRow(COrcaRow *pRow);

	// transform information
	inline const OrcaTransformAction IsTransformed() const { return m_iTransform; };
	inline bool ContainsTransformedData() const { return m_iTransformedDataCount != 0; };
	void IncrementTransformedData();
	void DecrementTransformedData();

	// shadow table information
	void ShadowTable(CString szTable);
	inline bool IsShadow() const { return m_fShadow; };

	inline const CStringList* ErrorList() const { return &m_strErrorList; };
	inline const CString& Name() const { return m_strName; };
	inline CTypedPtrArray<CObArray, COrcaColumn*>* ColArray() { return &m_colArray; };
	inline CTypedPtrList<CObList, COrcaRow*>* RowList() { return &m_rowList; };
	bool   DropRow(COrcaRow *pRow, bool fPerformDrop);

	// column information
	inline int GetColumnCount() const { return static_cast<int>(m_colArray.GetSize()); };
	inline int GetOriginalColumnCount() const { return m_cOriginalColumns; };
	inline const COrcaColumn *GetColumn(const int iColumn) const { return m_colArray.GetAt(iColumn); };
	int FindColumnNumberByName(const CString& strColumn) const;
	COrcaRow* FindRowByKeys(CStringArray& rstrKeys) const;

	void FillColumnArray(CTypedPtrArray<CObArray, COrcaColumn*>* prgColumn, bool fIncludeAdded) const;

	// row information
	inline INT_PTR GetRowCount() const { return m_rowList.GetCount(); };
	inline POSITION GetRowHeadPosition() const { return m_rowList.GetHeadPosition(); };
	inline const COrcaRow *GetNextRow(POSITION &pos) const { return m_rowList.GetNext(pos); };
	const CString GetRowWhereClause() const;

	// error information
	inline void SetContainsValidationErrors(bool bError) { m_bContainsValidationErrors = bError; };
	inline bool ContainsValidationErrors() const { return m_bContainsValidationErrors; };
	inline const OrcaTableError Error() const { return m_eiError; };
	inline void SetError(const OrcaTableError iError) { m_eiError = iError; };
	inline void AddError(const CString& strICE, const CString& strDescription, const CString&strURL)
	{
		m_strErrorList.AddTail(strICE);
		m_strErrorList.AddTail(strDescription);
		m_strErrorList.AddTail(strURL);
	}

private:
	COrcaDoc* m_pDoc;
	CString m_strName;
	BOOL m_bRetrieved;		// flag if have retrieved rows from database yet
	bool m_fShadow;

	int m_cOriginalColumns;
	CTypedPtrArray<CObArray, COrcaColumn*> m_colArray;
	CTypedPtrList<CObList, COrcaRow*> m_rowList;

	bool m_bContainsValidationErrors;
	int m_iTransformedDataCount;

	OrcaTableError m_eiError;
	CStringList m_strErrorList;
	OrcaTransformAction m_iTransform;
	odlOrcaDataLocation m_eiTableLocation;
	
	// store a SQL query WHERE clause against the primary keys for perf
	CString m_strWhereClause;
	void BuildRowWhereClause();

	bool DropRowObject(COrcaRow *pRow, bool fPerformDrop);
	bool AddRowObject(COrcaRow *pRow, bool fUIUpdate, bool fCleanAdd, MSIHANDLE hNewRowRec);
	COrcaRow* FindDuplicateRow(COrcaRow* pBaseRow) const;

};	// end of CTable

#endif	// _ORCA_TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\tablevw.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// TableVw.cpp : implementation of the CTableView class
//

#include "stdafx.h"
#include "Orca.h"
#include "OrcaDoc.h"
#include "MainFrm.h"

#include "TableVw.h"
#include "EditBinD.h"
#include "CellErrD.h"

#include "..\common\utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define WM_SAVECOLWIDTH WM_USER+1

/////////////////////////////////////////////////////////////////////////////
// CTableView

IMPLEMENT_DYNCREATE(CTableView, COrcaListView)

BEGIN_MESSAGE_MAP(CTableView, COrcaListView)
	//{{AFX_MSG_MAP(CTableView)
	ON_WM_KILLFOCUS()
	ON_WM_KEYDOWN()
	ON_WM_LBUTTONDOWN()
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	ON_WM_RBUTTONDOWN()
	ON_COMMAND(ID_ROW_DROP, OnDropRowConfirm)
	ON_COMMAND(IDM_ERRORS, OnErrors)
	ON_COMMAND(IDM_PROPERTIES, OnProperties)
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
	ON_UPDATE_COMMAND_UI(ID_ROW_DROP, OnUpdateRowDrop)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_COMMAND(ID_EDIT_COPY_ROW, OnEditCopyRow)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY_ROW, OnUpdateEditCopyRow)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT_ROW, OnUpdateEditCutRow)
	ON_COMMAND(ID_EDIT_CUT_ROW, OnEditCutRow)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_ROW, OnUpdateEditPasteRow)
	ON_COMMAND(ID_EDIT_PASTE_ROW, OnEditPasteRow)
	ON_WM_KEYUP()
	ON_WM_CHAR()
	ON_WM_SIZE()
	ON_COMMAND(ID_VIEW_HEX, OnViewColumnHex)
	ON_COMMAND(ID_VIEW_DECIMAL, OnViewColumnDecimal)
	ON_COMMAND(ID_VIEW_HEX_HDR, OnViewColumnHexHdr)
	ON_COMMAND(ID_VIEW_DECIMAL_HDR, OnViewColumnDecimalHdr)
	ON_UPDATE_COMMAND_UI(ID_VIEW_HEX, OnUpdateViewColumnFormat)
	ON_UPDATE_COMMAND_UI(ID_VIEW_DECIMAL, OnUpdateViewColumnFormat)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnclick)
	ON_COMMAND(ID_FILE_PRINT, COrcaListView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, COrcaListView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, COrcaListView::OnFilePrintPreview)
	ON_NOTIFY_EX(TTN_NEEDTEXTW, 0, OnToolTipNotify)
	ON_NOTIFY_EX(TTN_NEEDTEXTA, 0, OnToolTipNotify)

	ON_WM_MOUSEMOVE( )
	ON_WM_CTLCOLOR( )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTableView construction/destruction

CTableView::CTableView()
{
	m_pTable = NULL;
	m_cColumns = 0;
	m_nSelCol = -1;

	m_bCtrlDown = FALSE;

	m_pctrlToolTip = NULL;
	m_iToolTipItem = -1;
	m_iToolTipColumn = -1;
	m_iHeaderClickColumn = -1;
}

CTableView::~CTableView()
{
	m_pTable = NULL;
}

BOOL CTableView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return COrcaListView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CTableView drawing

void CTableView::OnDraw(CDC* pDC)
{
}

void CTableView::OnInitialUpdate()
{
	COrcaListView::OnInitialUpdate();

	m_pctrlToolTip = new CToolTipCtrl();
	if (m_pctrlToolTip)
	{
		m_pctrlToolTip->Create(this);
		m_pctrlToolTip->AddTool(this);
		m_pctrlToolTip->Activate(FALSE);
	}

	CListCtrl& rctrlList = GetListCtrl();
	
	// if the edit box is not created yet
	if (!m_editData.m_hWnd)
	{
		RECT rcEdit;
		rcEdit.left = 0;
		rcEdit.top = 0;
		rcEdit.right = 10;
		rcEdit.bottom = 10;

		m_editData.Create(WS_CHILD|ES_AUTOHSCROLL|ES_LEFT|WS_BORDER, rcEdit, this, 0);
		m_editData.SetFont(this->GetFont());

		// allow maximum possible text size. Limit will vary by OS
		m_editData.SetLimitText(0);
	}
	if (!m_ctrlStatic.m_hWnd)
	{
		RECT rcStatic = {0,0,10,10};
		m_ctrlStatic.Create(TEXT("This table does not actually exist in your database. It appears in the table list because one or more validators has indicated an error in this table."), WS_CHILD|WS_MAXIMIZE|SS_CENTER, rcStatic, this);		
		m_ctrlStatic.SetFont(this->GetFont());
	}

	// clear out any left over tables
	m_pTable = NULL;
	while (rctrlList.DeleteColumn(0))
		;
}

/////////////////////////////////////////////////////////////////////////////
// CTableView printing

BOOL CTableView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CTableView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CTableView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CTableView diagnostics

#ifdef _DEBUG
void CTableView::AssertValid() const
{
	COrcaListView::AssertValid();
}

void CTableView::Dump(CDumpContext& dc) const
{
	COrcaListView::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTableView message handlers

///////////////////////////////////////////////////////////
// OnUpdate
void CTableView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	// if this is the sender bail
	if (this == pSender)
		return;

	// set the row and column selections to nothing
	CListCtrl& rctrlList = GetListCtrl();

	switch (lHint) {
	case HINT_REDRAW_ALL:
	{
		rctrlList.RedrawItems(0, rctrlList.GetItemCount());
		break;
	}
	case HINT_DROP_TABLE:	// if this is a "drop table" hint
	{
		COrcaTable* pTable = (COrcaTable*)pHint;

		// clear the selection
		m_nSelCol = -1;

		// if droping the current viewed table
		if (pTable == m_pTable)
		{
			// empty out the list control
			rctrlList.DeleteAllItems();
		
			// delete all the columns
			while(rctrlList.DeleteColumn(0))
				;
			m_cColumns = 0;

			m_pTable = NULL;

			// kill the edit box no matter what
			CommitEdit(FALSE);	// but don't save, too late for that probably
		}
		break;
	}
	case HINT_DROP_ROW:	// if this is a request to drop a row
	{
		// pHint may be freed memory already. DO NOT dereference it within
		// this block!
		COrcaRow* pRowHint = (COrcaRow*)pHint;
		COrcaRow* pRow = NULL;

		// clear the selection
		m_nSelCol = -1;

		// make sure this row is actually in the list control
		int iFound = -1;
		int cItems = rctrlList.GetItemCount();
		for (int i = 0; i < cItems; i++)
		{
			pRow = (COrcaRow*)rctrlList.GetItemData(i);
			if (pRow == pRowHint)
			{
				iFound = i;
				break;
			}
		}
		ASSERT(iFound > -1);	// make sure we found something
		rctrlList.DeleteItem(iFound);

		// kill the edit box no matter what
		CommitEdit(FALSE);	// but don't save, too late for that probably

		// update the row count in the status bar
		((CMainFrame*)AfxGetMainWnd())->SetTableName(m_pTable->Name(), rctrlList.GetItemCount());

		return;	// bail now
	}
	case HINT_ADD_ROW_QUIET:
	case HINT_ADD_ROW:
	{
		ASSERT(pHint);
		// kill the edit box no matter what
		CommitEdit(FALSE);	// but don't save, too late for that probably

		COrcaRow* pRowHint = (COrcaRow*)pHint;
#ifdef _DEBUG
		COrcaRow* pRow;

		// make sure this row in NOT the list control already
		int cItems = rctrlList.GetItemCount();
		for (int i = 0; i < cItems; i++)
		{
			pRow = (COrcaRow*)rctrlList.GetItemData(i);
			ASSERT(pRow != pRowHint);
		}
#endif	// debug only

		int m_cColumns = m_pTable->GetColumnCount();
		COrcaData* pData = pRowHint->GetData(0);

		UnSelectAll();

		// add the item filling in the first column for free
		int iNewRow = rctrlList.InsertItem(LVIF_PARAM  | LVIF_STATE, 
													rctrlList.GetItemCount(),
													NULL,
													LVIS_SELECTED|LVIS_FOCUSED,
													0, 0,
													(LPARAM)pRowHint);
		ASSERT(-1 != iNewRow);

		m_nSelCol = 0;

		// when adding quietly, don't redraw
		if (lHint != HINT_ADD_ROW_QUIET)
		{
			rctrlList.RedrawItems(iNewRow, iNewRow);
			
			// update the row count in the status bar
			((CMainFrame*)AfxGetMainWnd())->SetTableName(m_pTable->Name(), rctrlList.GetItemCount());
		}

		break;
	}
	case HINT_TABLE_REDEFINE:
	case HINT_RELOAD_ALL:
	case HINT_CHANGE_TABLE:
	{
		// clear the selection
		m_nSelCol = -1;

		// save the existing column widths, unless the table is not loaded, is a shadow
		// table, or is a same-table redefinition
		if (m_pTable != NULL && !m_pTable->IsShadow() && (m_pTable != pHint)) 
		{
			m_cColumns = m_pTable->GetColumnCount();
			for (int i = 0; i < m_cColumns; i++)
			{
				const COrcaColumn* pColumn = m_pTable->GetColumn(i);
				pColumn->m_nWidth = rctrlList.GetColumnWidth(i);
			}
		}

		// if we are showing a different table, or the same table that has been redefined
		if ((pHint == NULL) || (m_pTable != pHint) || (m_pTable == pHint && lHint == HINT_TABLE_REDEFINE))
		{		
			rctrlList.DeleteAllItems();

			// delete all the columns
			while(rctrlList.DeleteColumn(0))
				;
			m_cColumns = 0;

			if (NULL != m_pTable)
			{
				// kill the edit box no matter what
				CommitEdit(FALSE);	// but don't save, too late for that probably
			}

			// reset the status bar to prevent stale data from surviving
			CMainFrame* pMainFrameWnd = static_cast<CMainFrame*>(AfxGetMainWnd());
			if (pMainFrameWnd)
				pMainFrameWnd->ResetStatusBar();

			// if no hint was passed, we're clearing the table, so bail
			if (NULL == pHint)
			{
				m_pTable = NULL;
				m_ctrlStatic.ShowWindow(SW_HIDE);
				UpdateWindow();
				break;
			}

			// get the number of columns in the table
			m_pTable = (COrcaTable*) pHint;

			// if a shadow table, don't create any columns and don't try
			// to load any data, but do destroy previous data by 
			// falling through to a table reload
			if (m_pTable->IsShadow())
			{
				m_ctrlStatic.ShowWindow(SW_SHOW);
			}
			else 
			{
				m_ctrlStatic.ShowWindow(SW_HIDE);
				m_cColumns = m_pTable->GetColumnCount();

				// storage for actual desired column widths
				int rgiColumnActual[32];

				// if the table doesn't have saved 
				// column widths,determine the best widths
				const COrcaColumn* pColumn = m_pTable->GetColumn(0);
				if (pColumn && pColumn->m_nWidth < 0)
				{
					int rgiColumnMax[32];
					int iTotalWidth = 0;
	
					// grab the window dimensions to calculate maximum column widths
					CRect rClient;
					GetClientRect(&rClient);
					int iWindowWidth = rClient.right;

					// retrieve the table if necessary to determine row count
					m_pTable->RetrieveTableData();

					// try to determine if a scroll bar is going to show up 
					if (m_pTable->GetRowCount()*m_iRowHeight > rClient.bottom)
					{
						iWindowWidth -= GetSystemMetrics(SM_CXVSCROLL);
					}
	
					// retreive the desired column widths for the table
					GetAllMaximumColumnWidths(m_pTable, rgiColumnMax, 0xFFFFFFFF);
	
					// check the system settings to see if we should force columns to fit in the view
					bool fForceColumns = AfxGetApp()->GetProfileInt(_T("Settings"), _T("ForceColumnsToFit"), 1) == 1;

					// start out giving every column everything that it is requesting
					for (int iCol=0; iCol < m_cColumns; iCol++)
					{
						rgiColumnActual[iCol] = rgiColumnMax[iCol];
						iTotalWidth += rgiColumnMax[iCol];
					}

					if (!fForceColumns)
					{
						// if not forcing to fit, just verify that none of the numbers are outrageous
						for (int iCol=0; iCol < m_cColumns; iCol++)
						{
							if (rgiColumnActual[iCol] > iWindowWidth)
								rgiColumnActual[iCol] = iWindowWidth;;
						}
					}
					else
					{
						// if all of the column widths together add up to less than the window width, the maximum
						// widths will do. 
						if (iTotalWidth > iWindowWidth)
						{
							int cPrimaryKeys = m_pTable->GetKeyCount();
							int cUnSatisfiedColumns = 0;
							int cUnSatisfiedKeys = 0;
		
							// otherwise, set all columns to an equal part of the window or their requested max, 
							// whichever is less. After this the sum of all widths is known to be <= the window
							int iColumnAverage = iWindowWidth/m_cColumns;
							iTotalWidth = 0;
							for (iCol=0; iCol < m_cColumns; iCol++)
							{
								if (rgiColumnActual[iCol] > iColumnAverage)
								{
									rgiColumnActual[iCol] = iColumnAverage;
									cUnSatisfiedColumns++;
									if (iCol < cPrimaryKeys)
										cUnSatisfiedKeys++;
								}
								iTotalWidth += rgiColumnActual[iCol];
							}
							
							// give any extra space to unhappy columns. Start with just the primary keys. 
							// If they can be given enough space and there is still space left over,
							// distribute the remaining space evenly between all remaning unhappy columns,
							// Earlier columns have higher priority on leftovers. Repeat until everybody 
							// is happy or all space has been taken up.
							while (cUnSatisfiedColumns && (iTotalWidth != iWindowWidth))
							{
								int iRemainingUnSatisfied = cUnSatisfiedKeys ? cUnSatisfiedKeys : cUnSatisfiedColumns;
		
								for (iCol = (cUnSatisfiedKeys ? cPrimaryKeys : m_cColumns)-1; iCol >= 0; iCol--)
								{
									if (rgiColumnActual[iCol] >= rgiColumnMax[iCol])
										continue;
			
									// give this column an equal share of what's left.
									int iAddToColumn = (iWindowWidth-iTotalWidth)/iRemainingUnSatisfied;
									iRemainingUnSatisfied--;
			
									// again, if we would be setting the column larger than it needs,
									// set it to the maximum. This gives more space for earlier columns
									if (rgiColumnActual[iCol]+iAddToColumn >= rgiColumnMax[iCol])
									{
										iTotalWidth = iTotalWidth - rgiColumnActual[iCol] + rgiColumnMax[iCol];
										rgiColumnActual[iCol] = rgiColumnMax[iCol];
										cUnSatisfiedColumns--;
										if (iCol < cPrimaryKeys)
											cUnSatisfiedKeys--;
									}
									else
									{
										iTotalWidth += iAddToColumn;
										rgiColumnActual[iCol] += iAddToColumn;
									}
								}
							}
						}
					}
				}			

				// add all the columns
				for (int i = 0; i < m_cColumns; i++)
				{
					pColumn = m_pTable->GetColumn(i);

					int iWidth = pColumn->m_nWidth < 0 ? rgiColumnActual[i] : pColumn->m_nWidth;
					rctrlList.InsertColumn(i, pColumn->m_strName, LVCFMT_LEFT, iWidth, i);
				}
			}
		}
		else
		{
			// showing the same table, so 
			break;
		}
		// otherwise fall through to reload data
	}
	case HINT_TABLE_DATACHANGE:
	{
		rctrlList.DeleteAllItems();
		int cItems = 0;

		if (m_pTable)
		{
			// if a shadow table don't try to load any data, just the message
			if (!m_pTable->IsShadow())
			{
    			// retrieve the table if necessary
				m_pTable->RetrieveTableData();

				// set the number of items into the list control
				// control apparently can't handle more than MAX_INT, so 
				// casting down isn't too bad
				rctrlList.SetItemCount(static_cast<int>(m_pTable->GetRowCount()));
				const COrcaRow* pRow = NULL;
				const COrcaData* pData = NULL;
				int nAddedRow;
				POSITION pos = m_pTable->GetRowHeadPosition();
				while (pos)
				{
					pRow = m_pTable->GetNextRow(pos);
					if (!pRow)
						continue;

					pData = pRow->GetData(0);
					if (!pData)
						continue;

					// add the item filling in the first column for free
					nAddedRow = rctrlList.InsertItem(LVIF_PARAM, 
																cItems,
																NULL,
																0, 0, 0,
																(LPARAM)pRow);
					
					cItems++;
				}
			}
			((CMainFrame*)AfxGetMainWnd())->SetTableName(m_pTable->Name(), cItems);
			UpdateWindow();
		}
		break;
	}
	case HINT_COMMIT_CHANGES:
	{
		CommitEdit(TRUE);
		break;
	}
	case HINT_SET_ROW_FOCUS:
	{
		UnSelectAll();
		LVFINDINFO findInfo;
		findInfo.flags = LVFI_PARAM;
		findInfo.lParam = reinterpret_cast<INT_PTR>(pHint);

		// this didn't come from us, so we have to set the selection state manually
		int iItem = rctrlList.FindItem(&findInfo);
		if (iItem < 0) break;
		rctrlList.SetItemState(iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
		rctrlList.EnsureVisible(iItem, FALSE);
		break;
	}
	case HINT_SET_COL_FOCUS:
	{
		UINT iItem = GetFocusedItem();
        // max column id is 32
		m_nSelCol = static_cast<int>(reinterpret_cast<INT_PTR>(pHint));
		EnsureVisibleCol(m_nSelCol);
		rctrlList.RedrawItems(iItem, iItem);
		break;
	}
	case HINT_CELL_RELOAD:
	{
		LVFINDINFO findInfo;
		findInfo.flags = LVFI_PARAM;
		findInfo.lParam = reinterpret_cast<INT_PTR>(pHint);
		int iItem = rctrlList.FindItem(&findInfo);
		if (iItem < 0)
			break;
		
		rctrlList.EnsureVisible(iItem, FALSE);
		break;
	}
	default:
		break;
	}
}	// end of OnUpdate

void CTableView::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	TRACE(_T("CTableView::OnColumnclick - called.\n"));
	TRACE(_T("Item: %d, Subitem: %d, OldState: %d, NewState: %d, Changed: %d, Param: %d\n"), 
			pNMListView->iItem, 
			pNMListView->iSubItem, 
			pNMListView->uNewState, 
			pNMListView->uOldState,
			pNMListView->uChanged,
			pNMListView->lParam);

	// set the param with the column in it (the highest bit sets the column type)
	LPARAM lParam = pNMListView->iSubItem;

	const COrcaColumn* pColumn = m_pTable->GetColumn(pNMListView->iSubItem);
	ASSERT(pColumn);
	if (pColumn)
	{
		OrcaColumnType eiColType = pColumn->m_eiType;
	
		// if this is a numeric column
		if (iColumnShort == eiColType || iColumnLong == eiColType)
		{
			lParam |= 0x80000000;	// make the top bit a 1
			if (pColumn->DisplayInHex())
				lParam |= 0x40000000;
		}
	
		// now sort since the column bit is set
		GetListCtrl().SortItems(SortView, lParam);
	
		// ensure that the item is still visible
		GetListCtrl().EnsureVisible(GetFocusedItem(), /*partialOK=*/false);
	}

	*pResult = 0;	
}

void CTableView::OnKillFocus(CWnd* pNewWnd) 
{
	CommitEdit(TRUE);
	if (m_pctrlToolTip)
	{
		m_pctrlToolTip->Activate(FALSE);
		m_iToolTipItem = -1;
		m_iToolTipColumn = -1;
	}
	COrcaListView::OnKillFocus(pNewWnd);
}

BOOL CTableView::CommitEdit(BOOL bSave /*= TRUE*/)
{
	if (m_editData.IsWindowVisible())
	{
		// hide the edit box real quick
		m_editData.ShowWindow(SW_HIDE);

		if (bSave)
		{
			// get the cell
			CListCtrl& rctrlList = GetListCtrl();
			COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(m_editData.m_nRow);
			ASSERT(pRow);
			COrcaData* pData = pRow->GetData(m_editData.m_nCol);
			ASSERT(pData);

			// update the data
			CString strData;
			m_editData.GetWindowText(strData);

			const COrcaColumn* pColumn = m_pTable->GetColumn(m_editData.m_nCol);
			ASSERT(pColumn);

			if (pColumn && strData != pData->GetString(pColumn->m_dwDisplayFlags))
			{
				UINT iResult = m_pTable->ChangeData(pRow, m_editData.m_nCol, strData);

				// if we succeeded in changing the document
				if (ERROR_SUCCESS == iResult)
				{
					// update the list control
					rctrlList.RedrawItems(m_editData.m_nRow, m_editData.m_nRow);
				}
				else	// tell the user that what they are doing is not valid
				{
					CString strPrompt;
					strPrompt.Format(_T("Could not change this cell to \'%s\'"), strData);
					switch (iResult) {
					case MSIDBERROR_REQUIRED: 
						strPrompt += _T(". Null values are not allowed in this column.");
						break;
					case MSIDBERROR_DUPLICATEKEY:
						strPrompt += _T(". because it would result in two records having the same primary key(s).");
						break;
					case MSIDBERROR_STRINGOVERFLOW:
						strPrompt += _T(". because the string is too long for this cell.");
						break;
					case MSIDBERROR_OVERFLOW:
						strPrompt += _T(". The string does not represent a number.");
						break;
					default:
						strPrompt += _T(". The data was rejected by the database.\nIt may be out of the valid range or formatted incorrectly.");
					}
					AfxMessageBox(strPrompt, MB_ICONINFORMATION);
				}
			}
		}
	}

	return TRUE;
}

void CTableView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	TRACE(_T("CTableView::OnKeyDown - called\n"));

	// if the edit box is open it probably sent the message. We don't want
	// to handle any of those right now. 
	//!! FUTURE: Might be nice at some point to have Up and Down commit the 
	// edit and move you up or down one row.)
	if (!m_editData.IsWindowVisible())
	{
		if (VK_LEFT == nChar)
		{
			// left arrow key we must update the column, the list ctrl will take care of row.
			if (m_nSelCol > 0)
			{
				m_nSelCol--;

				int iItem = GetFocusedItem();
				rctrlList.RedrawItems( iItem, iItem);
				UpdateColumn(m_nSelCol);
			}
		}
		else if (VK_RIGHT == nChar)
		{
			// left arrow key we must update the column, the list ctrl will take care of row.
			if ((m_nSelCol < m_cColumns - 1) && (m_nSelCol > -1))
			{
				m_nSelCol++;
				
				int iItem = GetFocusedItem();				
				rctrlList.RedrawItems( iItem, iItem);
				UpdateColumn(m_nSelCol);
			}
		}
		else if (VK_HOME == nChar)
		{		
			// home key we must update the column,
			m_nSelCol= 0;

			int iItem = GetFocusedItem();				
			rctrlList.RedrawItems( iItem, iItem);
			if (m_bCtrlDown) {

				UnSelectAll();
				rctrlList.SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED, 
					LVIS_SELECTED | LVIS_FOCUSED);
				rctrlList.EnsureVisible(0, FALSE);
			};
			UpdateColumn(m_nSelCol);
		}
		else if (VK_END == nChar)
		{
			// end key we must update the column,
			m_nSelCol = m_cColumns-1;

			int iItem = GetFocusedItem();				
			rctrlList.RedrawItems( iItem, iItem);
			if (m_bCtrlDown) {

				UnSelectAll();
				int iLastItem = rctrlList.GetItemCount()-1; 
				rctrlList.SetItemState(iLastItem, LVIS_SELECTED | LVIS_FOCUSED, 
					LVIS_SELECTED | LVIS_FOCUSED);
				rctrlList.EnsureVisible(iLastItem, FALSE);
			};
			UpdateColumn(m_nSelCol);
		}
		else if (VK_DELETE == nChar)
		{
			// if some row(s) are selected
			if (rctrlList.GetSelectedCount() > 0)
				OnDropRowConfirm();	// drop the row
		}
		else if (VK_INSERT == nChar)
		{
			GetDocument()->OnRowAdd();
		}
		else if (VK_CONTROL == nChar)
		{
			m_bCtrlDown = TRUE;
		}
		else
			COrcaListView::OnKeyDown(nChar, nRepCnt, nFlags);
	}
}

void CTableView::OnLButtonDown(UINT nFlags, CPoint point) 
{
//	TRACE(_T("CTableView::OnLButtonDown - called at: %d,%d.\n"), point.x, point.y);

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get if any item was hit
	UINT iState;
	int iItem = rctrlList.HitTest(point, &iState);
	int iCol = -1;

	// shift by the scroll point
	int nScrollPos = GetScrollPos(SB_HORZ);
	point.x += nScrollPos;

	// if missed an item
	if (iItem < 0 || !(iState & LVHT_ONITEM))
	{
		m_nSelCol = -1;
		UpdateColumn(m_nSelCol);
		COrcaListView::OnLButtonDown(nFlags, point);
	}
	else
	{
		// get the column of the hit
		int nX = 0;
		int nWidth;
		for (int i = 0; i < m_cColumns; i++)
		{
			nWidth = rctrlList.GetColumnWidth(i);

			if (point.x >= nX && point.x < nX + nWidth)
			{
				iCol = i;
				break;		// found the column break
			}

			nX += nWidth;	// move x over to the next column
		}

		// if the user clicked outside of the items
		if (iCol < 0)
		{
			// if something was selected try and commit the edit box
			if ((rctrlList.GetSelectedCount() == 1) && m_nSelCol >= 0)
				CommitEdit(TRUE);

			m_nSelCol = -1;
			UpdateColumn(m_nSelCol);
			return;
		}

		// store the previous selections and update to the new ones
		int nPrevCol = m_nSelCol;

		// set the new selected items
		m_nSelCol = iCol;
		UpdateColumn(m_nSelCol);

		// find out if the clicked on item has the focus
		bool bFocused = (0 != rctrlList.GetItemState(iItem, LVIS_FOCUSED));

		if (bFocused) 
		{
			// need to manually set selection state 
			rctrlList.SetItemState(iItem, LVIS_SELECTED, LVIS_SELECTED);
			rctrlList.RedrawItems(iItem, iItem);
		}
		else 
		{
			COrcaListView::OnLButtonDown(nFlags, point);
		} 

		// if item that was clicked already had the focus, and the column was the same
		if (bFocused && (nPrevCol == m_nSelCol))
		{
			EditCell(FALSE);
		}
		else	// commit the editbox
			CommitEdit(TRUE);
	}
}	// end of OnLButtonDown();

///////////////////////////////////////////////////////////////////////
// responsible for handling the creation of the cell edit box if 
// the document can be edited.
void CTableView::EditCell(BOOL bSelectAll /*= TRUE*/) 
{
	if (GetDocument()->TargetIsReadOnly())
		return;

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	int nSelRow = GetFocusedItem();
	ASSERT(nSelRow >= 0);
	ASSERT(m_nSelCol >= 0);

	// get the row and data
	COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(nSelRow);
	ASSERT(pRow);
	COrcaData* pData = pRow->GetData(m_nSelCol);
	ASSERT(pData);

	// if the row doesn't exist in the currently active database, you can't edit it
	if (!GetDocument()->IsRowInTargetDB(pRow))
		return;

	// if the column doesn't exist in the target DB, you can't edit it either
	const COrcaColumn* pColumn = m_pTable->GetColumn(m_nSelCol);
	if (!pColumn)
		return;
	if (!GetDocument()->IsColumnInTargetDB(pColumn))
		return;


	// if the colum is a binary type, you can't edit it
	if (iColumnBinary == pColumn->m_eiType)
	{
		CEditBinD dlg;

		dlg.m_fNullable = (m_pTable->GetColumn(m_nSelCol)->m_bNullable != 0);
		dlg.m_fCellIsNull = pData->IsNull();
		if (IDOK == dlg.DoModal())
		{
			COrcaDoc* pDoc = GetDocument();
			UINT iResult;
			if (dlg.m_nAction == 0)
			{
				iResult = pRow->ChangeBinaryData(pDoc, m_nSelCol, dlg.m_strFilename);
			}
			else
				iResult = pDoc->WriteBinaryCellToFile(m_pTable, pRow, m_nSelCol, dlg.m_strFilename);

			// if we succeeded in changing the document
			if (ERROR_SUCCESS == iResult)
			{
				// if we were importing
				if (0 == dlg.m_nAction)
					pDoc->SetModifiedFlag(TRUE);	// set that the document has changed

            	// update the list control
				rctrlList.RedrawItems(nSelRow, nSelRow);

				// else exporting should have no affect on document
			}
			else	// tell the user that what they are doing is not valid
			{
				CString strPrompt;
				strPrompt.Format(_T("Failed to update the cell"));
				AfxMessageBox(strPrompt, MB_ICONINFORMATION);
			}
		}

		return;	// all done
	}

	int nScrollPos = GetScrollPos(SB_HORZ);

	// get the column start and width
	// shift back by the scroll point
	int nX = -nScrollPos;
	int nWidth = 0;
	for (int i = 0; i <= m_nSelCol; i++)
	{
		nX += nWidth;	// move x over to the next column
		nWidth = rctrlList.GetColumnWidth(i);
	}

	// change the size of the edit box appropriately
	RECT rcCell;
	BOOL bResult = rctrlList.GetItemRect(nSelRow, &rcCell, LVIR_BOUNDS);
	ASSERT(bResult);

	// move the edit box to the correct coordinates
	m_editData.MoveWindow(nX, rcCell.top, nWidth + 1, rcCell.bottom - rcCell.top + 1, FALSE);
	m_editData.SetFont(m_pfDisplayFont, FALSE);

	// put the text from this cell in the edit box
	m_editData.SetWindowText(pData->GetString(pColumn->m_dwDisplayFlags));
	if (bSelectAll)
		m_editData.SetSel(0, -1);
	else
		m_editData.SetSel(pData->GetString().GetLength(), pData->GetString().GetLength());

	// set the cell position of the edit box
	m_editData.m_nRow = nSelRow;
	m_editData.m_nCol = m_nSelCol;

	// finally show the window and set focus
	m_editData.SetFocus();
	m_editData.ShowWindow(SW_SHOW);
	m_editData.BringWindowToTop();
}	// end of EditCell


void CTableView::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// if the user is not clicking in bounds
	if (GetFocusedItem() < 0 || m_nSelCol < 0)
	{
		// if there is a table selected
		if (m_pTable && !m_pTable->IsShadow() && !(m_pTable->IsTransformed() == iTransformDrop))
			GetDocument()->OnRowAdd();		// bring up the add row dialog box
		return;
	}

	// otherwise edit the cell (read only handled by EditCell())
	EditCell();
	*pResult = 0;
}


///////////////////////////////////////////////////////////
// SortView
int CALLBACK CTableView::SortView(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	BOOL bNumeric = FALSE;
	bool bNumericHex = false;

	// if any of the top bits of lParamSort is TRUE it's a numeric column
	if (0 != (lParamSort & 0xF0000000))
	{
		bNumeric = TRUE;	// set the numeric flag try
		bNumericHex = (lParamSort & 0x40000000) ? true : false;
		lParamSort = lParamSort & ~0xF0000000;
	}

	// get the rows
	COrcaRow* pRow1 = (COrcaRow*)lParam1;
	COrcaRow* pRow2 = (COrcaRow*)lParam2;
	COrcaData* pData1 = pRow1->GetData(static_cast<int>(lParamSort));
	COrcaData* pData2 = pRow2->GetData(static_cast<int>(lParamSort));

	// if it is a numeric column
	if (bNumeric)
	{
		DWORD lData1 = static_cast<COrcaIntegerData*>(pData1)->GetInteger();
		DWORD lData2 = static_cast<COrcaIntegerData*>(pData2)->GetInteger();

		if (lData1 == lData2)
			return 0;
		else
		{
			// in hex view, sort absolute, otherwise sort signed
			if (bNumericHex)
				return (static_cast<unsigned int>(lData1) > static_cast<unsigned int>(lData2)) ?  1 : -1;
			else
				return (static_cast<int>(lData1) > static_cast<int>(lData2)) ? 1 : -1;
		}
	}
	else	// non-numeric
		return ((CMainFrame *)AfxGetMainWnd())->IsCaseSensitiveSort() ? pData1->GetString().Compare(pData2->GetString()) : 
					pData1->GetString().CompareNoCase(pData2->GetString());
}	// end of SortView


void CTableView::OnRButtonDown(UINT nFlags, CPoint point) 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	
	// get if any item was hit
	UINT iState;
	int iItem = rctrlList.HitTest(point, &iState);
	int iCol = -1;

	// shift by the scroll point
	int nScrollPos = GetScrollPos(SB_HORZ);
	point.x += nScrollPos;

	BOOL bGoodHit = TRUE;		// assume the hit was inbounds

	// if missed an item
	if (iItem < 0 || !(iState & LVHT_ONITEM))
	{
		
		bGoodHit = FALSE;	// not even close to in bounds
	}
	else	// something was hit with the mouse button
	{
		// get the column of the hit
		int nX = 0;
		int nWidth;
		for (int i = 0; i < m_cColumns; i++)
		{
			nWidth = rctrlList.GetColumnWidth(i);

			if (point.x >= nX && point.x < nX + nWidth)
			{
				iCol = i;
				break;		// found the column break
			}

			nX += nWidth;	// move x over to the next column
		}

		// if the user clicked outside of the items
		if (iCol < 0)
		{
			CommitEdit(TRUE);
			m_nSelCol = -1;
			bGoodHit = FALSE;	// hit was actually out of bounds
		}
		else 
		{
			// set the new selected items
			m_nSelCol = iCol;
		}
		UpdateColumn(m_nSelCol);

		// list control won't redraw if the same row is selected so force it to redraw
		rctrlList.RedrawItems(iItem, iItem);

		// now commit the edit box just incase it was left open
		CommitEdit(TRUE);


	}

	ClientToScreen(&point);


	COrcaRow* pRow = NULL;
	COrcaData* pData = NULL;

	if (!bGoodHit)
	{
		// clear the focus 
		int iFocusItem = GetFocusedItem();
		if (iFocusItem >= 0) {
			rctrlList.SetItemState(iFocusItem, 0, LVIS_FOCUSED);
		}
	}
	else
	{
		// set the focus to the right location
		UnSelectAll();
		rctrlList.SetItemState(iItem, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
		rctrlList.RedrawItems(iItem, iItem);
		UpdateWindow();
	
		// get the item data
		pRow = (COrcaRow*)rctrlList.GetItemData(iItem);
		ASSERT(pRow);
		if (!pRow)
			return;
		pData = pRow->GetData(iCol);
		ASSERT(pData);
		if (!pData)
			return;
	}

	// create and track the pop up menu
	CMenu menuContext;
	menuContext.LoadMenu(IDR_CELL_POPUP);
	if (m_pTable && iCol > 0 && iCol <= m_pTable->GetColumnCount())
	{
		const COrcaColumn* pColumn = m_pTable->GetColumn(iCol);
		if (pColumn)
		{
			if (pColumn->m_eiType == iColumnShort || pColumn->m_eiType == iColumnLong)
			{
				menuContext.CheckMenuRadioItem(ID_VIEW_DECIMAL, ID_VIEW_HEX, pColumn->DisplayInHex() ? ID_VIEW_HEX : ID_VIEW_DECIMAL, MF_BYCOMMAND);
			}
		}
	}
	menuContext.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN|TPM_TOPALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, point.x - nScrollPos, point.y, AfxGetMainWnd());
}

void CTableView::OnDropRowConfirm() {
	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	CString strPrompt;

	int iNumRows = rctrlList.GetSelectedCount();

	strPrompt.Format(_T("This will permanently remove %d rows from this database.\nDo you wish to continue?"),
		iNumRows);

	if (IDOK == AfxMessageBox(strPrompt, MB_OKCANCEL, 0)) {
		DropRows();
	};
};

void CTableView::DropRows() 
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	COrcaTable* pTable = pFrame->GetCurrentTable();

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// find first item
	POSITION pos = GetFirstSelectedItemPosition();

	ASSERT(pos != NULL);
	
	// repeat for every selected row. Because we are dropping rows in the midle of this 
	// selection iterator, we have to reset it every time. 
	while (pos) 
	{
		UINT iItem = GetNextSelectedItem(pos);
		// get the row and data
		COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iItem);
		ASSERT(pRow);
		if (!pRow)
			continue;

		// if the row doesn't exist in the active database, we can't really drop it
		if (!GetDocument()->IsRowInTargetDB(pRow))
			continue;

		// we need to mark this row as not selected before we drop it, because if the drop 
		// actually applies to a transform, the entry in the view will not actually go
		// away and GetFirstSelectedItemPosition will return the exact same row again
		// we can't do this afterwards because this view doesn't know whats going on under
		// the hood. pRow could point to freed memory.
		rctrlList.SetItemState(iItem, 0, LVIS_SELECTED);
		
		// drop row 
		GetDocument()->DropRow(pTable, pRow);
		pos = GetFirstSelectedItemPosition();
	}
}

void CTableView::OnErrors() 
{
	// get the item data
	CListCtrl& rctrlList = GetListCtrl();
	int iItem = GetFocusedItem();
	ASSERT(iItem >= 0);
	COrcaRow* pRow = (COrcaRow *)rctrlList.GetItemData(iItem);
	ASSERT(pRow);
	if (!pRow)
		return;

	COrcaData* pData = pRow->GetData(m_nSelCol);
	ASSERT(pData);
	if (!pData)
		return;

	ASSERT(iDataNoError != pData->m_eiError);

	pData->ShowErrorDlg();
}

void CTableView::OnProperties() 
{
	AfxMessageBox(_T("What Properties do you want to see?"), MB_ICONINFORMATION);
}

BOOL CTableView::OnScrollBy(CSize sizeScroll, BOOL bDoScroll) 
{
	TRACE(_T("CTableView::OnScrollBy - called: %d, %d, and %d\n"), sizeScroll.cx, sizeScroll.cy, bDoScroll);
	
	if (bDoScroll && m_editData.IsWindowVisible())
	{
		RECT rcEdit;
		m_editData.GetWindowRect(&rcEdit);
		rcEdit.left += sizeScroll.cx;
		rcEdit.top += sizeScroll.cy;
		rcEdit.right += sizeScroll.cx;
		rcEdit.bottom += sizeScroll.cy;
		m_editData.MoveWindow(&rcEdit, FALSE);
	}

	return COrcaListView::OnScrollBy(sizeScroll, bDoScroll);
}

void CTableView::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	TRACE(_T("CTableView::OnHScroll - called, nPos: %d\n"), nPos);

	if (m_editData.IsWindowVisible())
	{
		CommitEdit(TRUE);
	}

	COrcaListView::OnHScroll(nSBCode, nPos, pScrollBar);
}

void CTableView::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	TRACE(_T("CTableView::OnVScroll - called, nPos: %d\n"), nPos);

	if (m_editData.IsWindowVisible())
	{
		CommitEdit(TRUE);
	}

	COrcaListView::OnVScroll(nSBCode, nPos, pScrollBar);
}

///////////////////////////////////////////////////////////
// OnEditCopy
void CTableView::OnEditCopy() 
{
	// if any binary data has been placed in temp file, we can remove it because
	// it is no longer on the clipboard after this
	CStringList *pList = &((static_cast<COrcaApp *>(AfxGetApp()))->m_lstClipCleanup);
	while (pList->GetCount())
		DeleteFile(pList->RemoveHead());

	// if the edit control is currently active, it should handle the
	// copy message, it will handle bad data quietly
	if (m_editData.IsWindowVisible()) {
		m_editData.Copy();
		return;
	}

	ASSERT(m_nSelCol >= 0);

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get the row and data
	int iFocusedItem = GetFocusedItem();
	COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iFocusedItem);
	ASSERT(pRow);
	if (!pRow)
		return;

	COrcaData* pData = pRow->GetData(m_nSelCol);
	ASSERT(pData);
	if (!pData)
		return;

	const COrcaColumn* pColumn = m_pTable->GetColumn(m_nSelCol);
	ASSERT(pColumn);
	if (!pColumn)
		return;

	// allocate memory for the string on the clipboard (+ 3 for \r\n and null)
	DWORD cchString = (pData->GetString(pColumn->m_dwDisplayFlags).GetLength() + 3)*sizeof(TCHAR);
	HANDLE hString = ::GlobalAlloc(GHND|GMEM_DDESHARE, cchString);
	if (hString)
	{
		LPTSTR szString = (LPTSTR)::GlobalLock(hString);
		if (szString)
		{
			lstrcpy(szString, pData->GetString(pColumn->m_dwDisplayFlags));
			lstrcat(szString, _T("\r\n"));
			::GlobalUnlock(hString);

			OpenClipboard();	
			::EmptyClipboard();
#ifdef _UNICODE
			::SetClipboardData(CF_UNICODETEXT, hString);
#else
			::SetClipboardData(CF_TEXT, hString);
#endif
			::CloseClipboard();
		}
	}
}	// end of OnEditCopy

///////////////////////////////////////////////////////////
// OnEditCut
void CTableView::OnEditCut() 
{
	// if the edit control is currently active, it should handle the
	// cut message, it will handle bad data quietly
	if (m_editData.IsWindowVisible()) {
		m_editData.Cut();
		return;
	}

	if (GetDocument()->TargetIsReadOnly())
		return;

	ASSERT(m_nSelCol >= 0);

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get the row and data
	int iFocusedItem = GetFocusedItem();
	COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iFocusedItem);
	ASSERT(pRow);
	if (!pRow)
		return;

	COrcaData* pData = pRow->GetData(m_nSelCol);
	ASSERT(pData);
	if (!pData)
		return;

	// if the row doesn't exist in the currently active database, you can't edit it
	if (!GetDocument()->IsRowInTargetDB(pRow))
		return;

	const COrcaColumn* pColumn = m_pTable->GetColumn(m_nSelCol);
	ASSERT(pColumn);
	if (!pColumn)
		return;

	// allocate memory for the string on the clipboard (+ 3 for \r\n and null)
	DWORD cchString = (pData->GetString(pColumn->m_dwDisplayFlags).GetLength() + 3)*sizeof(TCHAR);
	HANDLE hString = ::GlobalAlloc(GHND|GMEM_DDESHARE, cchString);
	if (hString)
	{
		LPTSTR szString = (LPTSTR)::GlobalLock(hString);
		if (szString)
		{
			lstrcpy(szString, pData->GetString(pColumn->m_dwDisplayFlags));
			lstrcat(szString, _T("\r\n"));
			::GlobalUnlock(hString);

			OpenClipboard();	
			::EmptyClipboard();
#ifdef _UNICODE
			::SetClipboardData(CF_UNICODETEXT, hString);
#else
			::SetClipboardData(CF_TEXT, hString);
#endif
			::CloseClipboard();
		
			// if the cell wasn't empty before it will be soon
			if (!pData->GetString().IsEmpty())
			{
				UINT iResult = m_pTable->ChangeData(pRow, m_nSelCol, _T(""));
	
				// if we succeeded in changing the document
				if (ERROR_SUCCESS == iResult)
				{
					// update the list control
					rctrlList.RedrawItems(iFocusedItem,iFocusedItem);
				}
			}
		}
	}
}	// end of OnEditCut

///////////////////////////////////////////////////////////
// OnEditPaste
void CTableView::OnEditPaste() 
{
	// if the edit control is currently active, it should handle the
	// paste message, it will handle bad data quietly
	if (m_editData.IsWindowVisible()) {
		m_editData.Paste();
		return;
	}

	ASSERT(m_nSelCol >= 0);

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get the row and data
	int iFocusedItem = GetFocusedItem();
	COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iFocusedItem);
	ASSERT(pRow);
	if (!pRow)
		return;

	COrcaData* pData = pRow->GetData(m_nSelCol);
	ASSERT(pData);
	if (!pData)
		return;

	// copy the text out of the clipboard real fast
	CString strNewData;
	OpenClipboard();
#ifdef _UNICODE
	HANDLE hString = ::GetClipboardData(CF_UNICODETEXT);
#else
	HANDLE hString = ::GetClipboardData(CF_TEXT);
#endif
	::CloseClipboard();
	ASSERT(hString);
	strNewData = (LPTSTR)::GlobalLock(hString);
	::GlobalUnlock(hString);

	// if clipboard data ends in new line chop it off
	if (_T("\r\n") == strNewData.Right(2))
		strNewData = strNewData.Left(strNewData.GetLength() - 2);

	// if the pasted text isn't the same as the cell data
	if (strNewData != pData->GetString())
	{
		UINT iResult = m_pTable->ChangeData(pRow, m_nSelCol, strNewData);

		// if we succeeded in changing the document
		if (ERROR_SUCCESS == iResult)
		{
			// update the list control
			rctrlList.RedrawItems(iFocusedItem, iFocusedItem);
		}
		else	// tell the user that what they are doing is not valid
		{
			CString strPrompt;
			strPrompt.Format(_T("Could not paste `%s` into this cell."), strNewData);
			AfxMessageBox(strPrompt, MB_ICONINFORMATION);
		}
	}
}	// end of OnEditPaste


///////////////////////////////////////////////////////////
// OnUpdateEditCopy
void CTableView::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
	if (m_editData.IsWindowVisible()) {
		int nBeg, nEnd;
        m_editData.GetSel( nBeg, nEnd );         
		pCmdUI->Enable( nBeg != nEnd );
	} 
	else if (m_pTable && !m_pTable->IsShadow() && (m_nSelCol >= 0) && (GetFocusedItem() >= 0))
	{
		// enable only if the column is not binary
		const COrcaColumn* pCol = m_pTable->GetColumn(m_nSelCol);
		pCmdUI->Enable(iColumnBinary != pCol->m_eiType);
	}
	else	// nothing is selected
		pCmdUI->Enable(FALSE);
}	// end of OnUpdateEditCopy


///////////////////////////////////////////////////////////
// OnUpdateEditCut
void CTableView::OnUpdateEditCut(CCmdUI* pCmdUI) 
{
	int iItem = 0;
	if (m_editData.IsWindowVisible()) {
		int nBeg, nEnd;
        m_editData.GetSel( nBeg, nEnd );         
		pCmdUI->Enable( nBeg != nEnd );
	} 
	else if (m_pTable && !m_pTable->IsShadow() && (m_nSelCol >= 0) && ((iItem = GetFocusedItem()) >= 0) )
	{
		// get list control
		CListCtrl& rctrlList = GetListCtrl();

		// disable if the currently selected row is not in the current database, otherwise
		// enable only if the column is nullable and not binary
		const COrcaColumn* pCol = m_pTable->GetColumn(m_nSelCol);
		COrcaRow *pRow = (COrcaRow *)rctrlList.GetItemData(iItem);
		ASSERT(pRow);

		pCmdUI->Enable(!pRow || (GetDocument()->IsRowInTargetDB(pRow) && pCol->m_bNullable && 
							iColumnBinary != pCol->m_eiType));
	}
	else	// nothing is selected
		pCmdUI->Enable(FALSE);
}	// end of OnUpdateEditCut

///////////////////////////////////////////////////////////
// OnUpdateEditPaste
void CTableView::OnUpdateEditPaste(CCmdUI* pCmdUI) 
{
	if (GetDocument()->TargetIsReadOnly()) 
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	if (m_editData.IsWindowVisible()) {
#ifdef _UNICODE
		pCmdUI->Enable(::IsClipboardFormatAvailable(CF_UNICODETEXT));
#else
		pCmdUI->Enable(::IsClipboardFormatAvailable(CF_TEXT));
#endif
		return;
	} 
	else if (m_pTable && !m_pTable->IsShadow() && (m_nSelCol >= 0))
	{
		// for speed, check to see if column is pastable first (non-binary)
		const COrcaColumn* pCol = m_pTable->GetColumn(m_nSelCol);
		int iItem = 0;
		if ((iColumnBinary != pCol->m_eiType) && ((iItem = GetFocusedItem()) >= 0)) 
		{
			// get list control
			CListCtrl& rctrlList = GetListCtrl();

			// disable if the currently selected row is not in the current database, otherwise
			// enable only if there is text in the database
			COrcaRow *pRow = (COrcaRow *)rctrlList.GetItemData(iItem);
			ASSERT(pRow);

			if (!pRow || !GetDocument()->IsRowInTargetDB(pRow))
			{
				pCmdUI->Enable(FALSE);
			}
			else
			{
				OpenClipboard();
#ifdef _UNICODE
				HANDLE hAnyText = ::GetClipboardData(CF_UNICODETEXT);
#else
				HANDLE hAnyText = ::GetClipboardData(CF_TEXT);
#endif
				::CloseClipboard();
				pCmdUI->Enable(NULL != hAnyText);
			}
			return;
		}
	}
	pCmdUI->Enable(FALSE);

}	// end of OnUpdateEditPaste


///////////////////////////////////////////////////////////
// OnEditCopyRow
void CTableView::OnEditCopyRow() 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	ASSERT(rctrlList.GetSelectedCount() > 0);

	// if any binary data has been placed in temp file, we can remove it because
	// it is no longer on the clipboard after this
	CStringList *pList = &((static_cast<COrcaApp *>(AfxGetApp()))->m_lstClipCleanup);
	while (pList->GetCount())
		DeleteFile(pList->RemoveHead());

	CString strCopy;		// string to copy to clipboard
	int iItem;
	POSITION pos = GetFirstSelectedItemPosition();
	ASSERT(pos != NULL);
	
	// repeat for every selected row
	while (pos) 
	{
		iItem = GetNextSelectedItem(pos);

		// get the row and data
		COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iItem);
		ASSERT(pRow);
		if (!pRow)
			continue;

		if (!GetDocument()->IsRowInTargetDB(pRow))
			continue;

		const COrcaColumn* pColumn = NULL;
		COrcaData* pData = NULL;
		int cColumns = m_pTable->GetColumnCount();
		for (int i = 0; i < cColumns; i++)
		{
			pColumn = m_pTable->GetColumn(i);
			pData = pRow->GetData(i);
			ASSERT(pData);
			if (pData)
			{
				// if this is a binary column
				if (iColumnBinary == pColumn->m_eiType)
				{
					if (!pData->IsNull())
					{
						PMSIHANDLE hRow = pRow->GetRowRecord(GetDocument()->GetTargetDatabase());
						CString strTempFile;
						GetDocument()->WriteStreamToFile(hRow, i, strTempFile);
		
						// add the file to the current row, and the list of files to cleanup
						// at exit time
						(static_cast<COrcaApp *>(AfxGetApp()))->m_lstClipCleanup.AddTail(strTempFile);
						strCopy += strTempFile;
					}
				}
				else	// some other column, just add it to the list of columsn
				{
					strCopy += pData->GetString(pColumn->m_dwDisplayFlags);
				}
			}

			// if not last column
			if (i < (cColumns - 1))
				strCopy += _T('\t');
		}

		strCopy += _T("\r\n");	// tack on the last return character
	}

	// allocate memory for the string on the clipboard
	DWORD cchString = (strCopy.GetLength() + 1)*sizeof(TCHAR);
	HANDLE hString = ::GlobalAlloc(GHND|GMEM_DDESHARE, cchString);
	if (hString)
	{
		LPTSTR szString = (LPTSTR)::GlobalLock(hString);
		if (szString)
		{
			lstrcpy(szString, strCopy);
			::GlobalUnlock(hString);

			OpenClipboard();	
			::EmptyClipboard();
#ifdef _UNICODE
			::SetClipboardData(CF_UNICODETEXT, hString);
#else
			::SetClipboardData(CF_TEXT, hString);
#endif
			::CloseClipboard();
		}
	}
}	// end of OnEditCopyRow

///////////////////////////////////////////////////////////
// OnEditCutRow
void CTableView::OnEditCutRow() 
{
	ASSERT(!GetDocument()->TargetIsReadOnly());

	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	CString strPrompt;

	int iNumRows = rctrlList.GetSelectedCount();

	strPrompt.Format(_T("This will remove %d rows from this database and place them on the clipbard.\nDo you wish to continue?"),
		iNumRows);

	if (IDOK == AfxMessageBox(strPrompt, MB_OKCANCEL, 0)) {
		OnEditCopyRow();
		DropRows();
	};

}	// end of OnEditCutRow

///////////////////////////////////////////////////////////
// OnEditPasteRow
void CTableView::OnEditPasteRow() 
{
	ASSERT(!GetDocument()->TargetIsReadOnly());

	// get the clipboard junk
	OpenClipboard();
#ifdef _UNICODE
	HANDLE hString = ::GetClipboardData(CF_UNICODETEXT);
#else
	HANDLE hString = ::GetClipboardData(CF_TEXT);
#endif
	ASSERT(hString);
	CString strClipped = (LPTSTR)::GlobalLock(hString);
	::GlobalUnlock(hString);
	::CloseClipboard();

	int cColumns = m_pTable->GetColumnCount();

	// if the string isn't empty
	if (!strClipped.IsEmpty())
	{
		COrcaDoc* pDoc = GetDocument();
		UINT iResult;

		CStringList strListColumns;
		CString strParse;

		UnSelectAll();

		int nFind = strClipped.Find(_T("\r\n"));
		int nFind2;

		while (-1 != nFind)
		{
			// get the string to parse for tabs and move to tne next string after the return character
			strParse = strClipped.Left(nFind);
			strClipped = strClipped.Mid(nFind + 2);	// skip \r\n

			// empty out the list
			strListColumns.RemoveAll();

			nFind2 = strParse.Find(_T('\t'));
			while (-1 != nFind2)
			{
				// add the string to the list
				strListColumns.AddTail(strParse.Left(nFind2));

				// move the parse after the tab then find the next tab
				strParse = strParse.Mid(nFind2 + 1);
				nFind2 = strParse.Find(_T('\t'));
			}
			
			// add the last string to the list
			strListColumns.AddTail(strParse);

			// if we don't have the number of columns to fill a row bail
			if (strListColumns.GetCount() != cColumns)
				break;

			// try to add the row now
			if (ERROR_SUCCESS != (iResult = pDoc->AddRow(m_pTable, &strListColumns)))
			{
				iResult = ERROR_SUCCESS;// assume the error cna be fixed

				// do a loop through to make sure the rows match the column types
				const COrcaColumn* pColumn;
				POSITION pos = strListColumns.GetHeadPosition();
				for (int i = 0; i < cColumns; i++)
				{
					pColumn = m_pTable->GetColumn(i);
					strParse = strListColumns.GetNext(pos);

					// if the string is null and the column can't handle nulls
					// giveup
					if (strParse.IsEmpty())
						if (pColumn->m_bNullable)
							continue;
						else
						{
							iResult = ERROR_FUNCTION_FAILED;
							break;
						}
			
					// if this is a binary column
					if (iColumnBinary == pColumn->m_eiType)
					{
						if (!FileExists(strParse))
						{
							iResult = ERROR_FUNCTION_FAILED;
							break;
						}
					}
					else if (iColumnShort == pColumn->m_eiType ||
								iColumnLong == pColumn->m_eiType)
					{
						DWORD dwValue = 0;
						// if failed to convert
						if (!ValidateIntegerValue(strParse, dwValue))
						{
							iResult = ERROR_FUNCTION_FAILED;
							break;
						}
					}
					// else all strings should go through no problem (if they passed nullabe at the top
				}

				// if the row passed the above checks it should be fixable
				if (ERROR_SUCCESS == iResult)
				{
					pos = strListColumns.GetHeadPosition();
					CString strFirstKey = strListColumns.GetAt(pos);
					int cLoop = 0;
					do
					{
						// try changing the primary key and add again
						strParse.Format(_T("%s%d"), strFirstKey, cLoop++);
						strListColumns.SetAt(pos, strParse);

						iResult = m_pTable->AddRow(&strListColumns);
					} while (ERROR_SUCCESS != iResult);
				}
			}

			
			if (ERROR_SUCCESS != iResult)
			{
				CString strPrompt;
				strPrompt.Format(_T("Cannot to paste row(s) into table[%s]."), m_pTable->Name());
				AfxMessageBox(strPrompt);
			}

			nFind = strClipped.Find(_T("\r\n"));
		}
	}
}	// end of OnEditPasteRow

///////////////////////////////////////////////////////////
// OnUpdateEditCutCopyRow
void CTableView::OnUpdateEditCutRow(CCmdUI* pCmdUI) 
{
	if (GetDocument()->TargetIsReadOnly()) 
	{
		pCmdUI->Enable(FALSE);
		return;
	}
	
	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	pCmdUI->Enable(m_pTable && !m_pTable->IsShadow() && (rctrlList.GetSelectedCount() > 0) && AnySelectedItemIsActive());
}	// end of OnUpdateEditCutCopyRow

///////////////////////////////////////////////////////////
// OnUpdateEditCutCopyRow
void CTableView::OnUpdateEditCopyRow(CCmdUI* pCmdUI) 
{
	CListCtrl& rctrlList = GetListCtrl();
	pCmdUI->Enable(m_pTable && !m_pTable->IsShadow() && (rctrlList.GetSelectedCount() > 0) && AnySelectedItemIsActive());
}	// end of OnUpdateEditCutCopyRow

///////////////////////////////////////////////////////////
// OnUpdateEditPasteRow
// only activate command if clipboard has stuff that can
// be parsed into valid row(s) for this table
void CTableView::OnUpdateEditPasteRow(CCmdUI* pCmdUI) 
{
	if (GetDocument()->TargetIsReadOnly()) 
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	if (m_pTable && !m_pTable->IsShadow())
	{
		// get the clipboard junk
		OpenClipboard();
#ifdef _UNICODE
		HANDLE hString = ::GetClipboardData(CF_UNICODETEXT);
#else
		HANDLE hString = ::GetClipboardData(CF_TEXT);
#endif
		::CloseClipboard();

		// if there's no text on the clipboard don't enable
		if (!hString)
			pCmdUI->Enable(FALSE);
		else	// check the text
		{
			// get the text
			CString strClipped = (LPTSTR)::GlobalLock(hString);
			::GlobalUnlock(hString);

			int cColumns = m_pTable->GetColumnCount();
			int cWords = 0;

			// if the string isn't empty
			if (!strClipped.IsEmpty())
			{
				cWords++; // there must be one word in there (it's not empty)
				int cString = strClipped.GetLength();
				for (int i = 0; i < cString; i++)
				{
					if (_T('\t') == strClipped.GetAt(i))
						cWords++;
					else if (_T('\n') == strClipped.GetAt(i))
						break;	// quit when hit a new line
				}
			}

			pCmdUI->Enable(cColumns == cWords);
		}
	}
	else	// nothing is selected
		pCmdUI->Enable(FALSE);
}	// end of OnUpdateEditPasteRow

void CTableView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView) 
{
	if (m_pTable)
	{
		// get list control
		CListCtrl& rctrlList = GetListCtrl();

		if (rctrlList.GetItemCount() > 0 && rctrlList.GetSelectedCount() == 0)
		{
			m_nSelCol = 0;
		}
	}

	COrcaListView::OnActivateView(bActivate, pActivateView, pDeactiveView);
}

void CTableView::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// if the ctrl key was relese
	if (VK_CONTROL == nChar)
		m_bCtrlDown = FALSE;

	COrcaListView::OnKeyUp(nChar, nRepCnt, nFlags);
}

void CTableView::UnSelectAll()
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// clear any existing row selections
	POSITION pos = GetFirstSelectedItemPosition();
	if (pos != NULL)
	{   
		while (pos) 
		{
			int nItem = GetNextSelectedItem(pos);
			rctrlList.SetItemState(nItem, 0, LVIS_SELECTED); 
			rctrlList.RedrawItems(nItem, nItem);
		}
	}
	rctrlList.UpdateWindow();
}

void CTableView::OnUpdateRowDrop(CCmdUI* pCmdUI) 
{
	if (GetDocument()->TargetIsReadOnly()) 
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!pFrame)
		pCmdUI->Enable(FALSE);
	else	// if there is an active row enable it
		pCmdUI->Enable(rctrlList.GetSelectedCount() && AnySelectedItemIsActive());
}

bool CTableView::AnySelectedItemIsActive() const
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	POSITION pos = GetFirstSelectedItemPosition();
	ASSERT(pos != NULL);
	COrcaDoc *pDoc = GetDocument();
	
	// repeat for every selected row
	while (pos) 
	{
		int iItem = GetNextSelectedItem(pos);

		// get the row and data
		COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iItem);
		ASSERT(pRow);
		if (!pRow)
			continue;

		if (pDoc->IsRowInTargetDB(pRow))
			return true;
	}
	return false;
}

OrcaTransformAction CTableView::GetColumnTransformState(int iColumn) const
{
	return m_pTable->GetColumn(iColumn)->IsTransformed();
}

OrcaTransformAction CTableView::GetCellTransformState(const void *row, int iColumn) const
{
	const COrcaData *pItemData = static_cast<const COrcaRow *>(row)->GetData(iColumn);
	if (!pItemData)
		return iTransformNone;
	return pItemData->IsTransformed();
}

OrcaTransformAction CTableView::GetItemTransformState(const void *row) const
{
	return static_cast<const COrcaRow *>(row)->IsTransformed();
}

COrcaListView::ErrorState CTableView::GetErrorState(const void *row, int iColumn) const
{
	const COrcaData *pItemData = static_cast<const COrcaRow *>(row)->GetData(iColumn);
	// if there is an error
	if (iDataError == pItemData->GetError())
		return Error;
	if (iDataWarning == pItemData->GetError())
		return Warning;
	return OK;
}

const CString* CTableView::GetOutputText(const void *rowdata, int iColumn) const
{
	const COrcaColumn *pColumn = m_pTable->GetColumn(iColumn);
	ASSERT(pColumn);
	return &(static_cast<const COrcaRow *>(rowdata)->GetData(iColumn)->GetString(pColumn->m_dwDisplayFlags));
}

void CTableView::UpdateColumn(int i)
{
	if (i < 0) return;

	// this is the select column so update the status bar
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (pFrame)
	{
		const COrcaColumn* pColumn = m_pTable->GetColumn(i);
		ASSERT(pColumn);
		if (!pColumn)
			return;

		pFrame->SetColumnType(pColumn->m_strName, pColumn->m_eiType, pColumn->m_iSize, pColumn->m_bNullable, pColumn->IsPrimaryKey());
	}
}

////////////////////////////////////////////////////////////////////////
// Searches using the FindInfo structure, beginning with one cell after
// (or before if backwards) the cell with the focus (if none focused, 
// search entire table)
bool CTableView::Find(OrcaFindInfo &FindInfo)
{
	// if there is no selected table, return false (not found)
	if (!m_pTable)
		return false;

	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	COrcaRow *pRow;

	// start searching one cell past the focus
	int iChangeVal = (FindInfo.bForward ? 1 : -1);
	int iCol = m_nSelCol + iChangeVal;
	int iRow = GetFocusedItem();
	if (iRow < 0) iRow = (FindInfo.bForward ? 0 : rctrlList.GetItemCount()-1);

	for ( ; (iRow >= 0) && (iRow < rctrlList.GetItemCount()); iRow += iChangeVal) 
	{
		pRow = (COrcaRow *)rctrlList.GetItemData(iRow);
		ASSERT(pRow);

		// if iCol == COLUMN_INVALID, search whole thing
		if (pRow->Find(FindInfo, iCol))
		{
			// pass NULL as window so that this view also gets the message
			GetDocument()->UpdateAllViews(NULL, HINT_SET_ROW_FOCUS, pRow);
			GetDocument()->UpdateAllViews(NULL, HINT_SET_COL_FOCUS, reinterpret_cast<CObject *>(static_cast<INT_PTR>(iCol)));
			return true;
		}
	}
	return false;
}

///////////////////////////////////////////////////////////////////////
// scrolls the control by enough to see the specified column.
// right now, scrolls just enough to be visible. Might want to consider
// scrolling full left and right if still valid 
void CTableView::EnsureVisibleCol(const int iCol)
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// find the horizontal position of the column
	int iScrollL = 0;
	int iScrollR = 0;
	for (int i=0; i < iCol; i++)
		iScrollL += rctrlList.GetColumnWidth(i);
	iScrollR = iScrollL + rctrlList.GetColumnWidth(iCol);

	// if its not visible, scroll horizontally so that it is visible
	CRect rWin;
	rctrlList.GetClientRect(&rWin);
	int iWinWidth = rWin.right-rWin.left;
	int iCurScrollPos = rctrlList.GetScrollPos(SB_HORZ);

	if ((iScrollL > iCurScrollPos) &&
		(iScrollR < (iCurScrollPos+iWinWidth))) 
		return;

	CSize size;
	size.cy = 0;
	size.cx = (iScrollR > (iCurScrollPos + iWinWidth)) ?
			iScrollR-iWinWidth : // off right
			iScrollL; // off left
	size.cx -= iCurScrollPos;
	rctrlList.Scroll(size);
}

void CTableView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	TRACE(_T("CTableView::OnChar - called\n"));

	// if the edit box is open it probably sent the message
	if (m_editData.IsWindowVisible())
	{
		if (VK_ESCAPE == nChar)
		{
			CommitEdit(FALSE);
			return;
		}
		else if (VK_RETURN == nChar)
		{
			CommitEdit(TRUE);
			return;
		}
	}
	else
	{
		// there is no cell edit conttrol active. A CR means activate
		// the cell edit. 
		if (VK_F2 == nChar || VK_RETURN == nChar)
		{
			if ((GetFocusedItem() >= 0) && (m_nSelCol >= 0))
			{
				EditCell();
				return;
			}
		} 
	}
	
	COrcaListView::OnChar(nChar, nRepCnt, nFlags);
}

afx_msg void CTableView::OnSize( UINT nType, int cx, int cy ) 
{
	if (::IsWindow(m_ctrlStatic.m_hWnd) && m_ctrlStatic.IsWindowVisible())
	{
		m_ctrlStatic.MoveWindow(0,0, cx, cy);
	}
}

afx_msg HBRUSH CTableView::OnCtlColor( CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	pDC->SetBkColor(m_clrNormal);
	pDC->SetTextColor(m_clrNormalT);
	return m_brshNormal;
}

void CTableView::SwitchFont(CString name, int size)
{
	COrcaListView::SwitchFont(name, size);
	m_ctrlStatic.SetFont(m_pfDisplayFont, TRUE);
}

///////////////////////////////////////////////////////////////////////
// Handles requests for tip text from the ToolTip control. Returns the 
// old untransformed value from cell under the mouse cursor.
BOOL CTableView::OnToolTipNotify( UINT id, NMHDR * pNMHDR, LRESULT * pResult )
{
	if (!m_pctrlToolTip)
		return FALSE;

	// because of the MFC message routing system, this window could get 
	// tooltip notifications from other controls. Only need to handle
	// requests from our manually managed tip.
	if (pNMHDR->hwndFrom == m_pctrlToolTip->m_hWnd)
	{
		CPoint CursorPos;
		VERIFY(::GetCursorPos(&CursorPos));
		ScreenToClient(&CursorPos);
	
		// Another safety check to ensure we don't incorrectly handle the wrong
		// notification messages. Verify that the cursor is inside the client
		// area of this window
		CRect ClientRect;
		GetClientRect(ClientRect);
	
		if (ClientRect.PtInRect(CursorPos))
		{
			// init the structure to empty strings
			TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *)pNMHDR;
			pTTT->hinst = 0;
			pTTT->lpszText = NULL;
			pTTT->szText[0] = '\0';
	
			int iItem = -1;
			int iColumn = -1;
			if (GetRowAndColumnFromCursorPos(CursorPos, iItem, iColumn))
			{
				CListCtrl& rctrlList = GetListCtrl();
				COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iItem);
				ASSERT(pRow);
				if (!pRow)
					return FALSE;

				COrcaData* pData = pRow->GetData(iColumn);
				ASSERT(pData);
				if (!pData)
					return FALSE;

				// only cells with a "transform change" operation have previous data.
				// adds don't have old data, and drops don't hide the old data.
				if (pData->IsTransformed() != iTransformChange)
					return FALSE;

				// update the data
				CString strData = _T("Old Value: ");
				strData += pRow->GetOriginalItemString(GetDocument(), iColumn); 
				pTTT->lpszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(strData));
			}

			return TRUE;
		}
	}
    return FALSE;
} 

///////////////////////////////////////////////////////////////////////
// since the tool tip is manually managed (not by the CWnd), it is 
// necessary to feed mouse events received by this window to the 
// control. The control will peek at the messages it is concerned about
// and ignore the rest.
BOOL CTableView::PreTranslateMessage(MSG* pMsg) 
{
   if (NULL != m_pctrlToolTip)            
      m_pctrlToolTip->RelayEvent(pMsg);
   
   return COrcaListView::PreTranslateMessage(pMsg);
}

///////////////////////////////////////////////////////////////////////
// given a cursor position, returns the item and column containing
// the position. Item is handled by the control, column is detected 
// manually from our stored column widths. Returns true if the hit
// is valid, false otherwise.
bool CTableView::GetRowAndColumnFromCursorPos(CPoint point, int &iItem, int &iCol)
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get if any item was hit
	UINT iState;
	iItem = rctrlList.HitTest(point, &iState);
	iCol = -1;

	// if missed an item
	if (iItem < 0 || !(iState & LVHT_ONITEM))
	{
		return false;
	}

	// shift by the scroll point
	int nScrollPos = GetScrollPos(SB_HORZ);
	point.x += nScrollPos;

	// get the column of the hit
	int nX = 0;
	int nWidth;
	for (int i = 0; i < m_cColumns; i++)
	{
		nWidth = rctrlList.GetColumnWidth(i);

		if (point.x >= nX && point.x < nX + nWidth)
		{
			// hit lies in this column
			iCol = i;
			break;
		}

		// move x over to the next column
		nX += nWidth;
	}

	// if the user clicked outside of the items
	if (iCol < 0)
	{
		return false;
	}
	return true;
}

///////////////////////////////////////////////////////////////////////
// because the tool tip views the list view as one tool, we need to
// check if a mouse move has changed the cursor from one cell to another. 
// If so, deactivate and re-activate the tooltip to force a string
// refresh. If transforms are not enabled, this is a no-op.
void CTableView::OnMouseMove(UINT nFlags, CPoint point) 
{
    if (m_pctrlToolTip && ::IsWindow(m_pctrlToolTip->m_hWnd))
    {
		// get the document
		COrcaDoc* pDoc = GetDocument();
		ASSERT(pDoc);

		if (pDoc && pDoc->DoesTransformGetEdit())
		{
			int iItem = 0;
			int iColumn = 0;
	
			// currently don't handle situation where right pane gets mouse messages but left pane has focus
			// (thus handles WM_NOTIFY messages from the tool tip.) Once that support is added, remove focus
			// check here.
			bool fItemHit = (this == GetFocus()) && GetRowAndColumnFromCursorPos(point, iItem, iColumn);
	
			// if different item, deactivate
			if (!fItemHit || iItem != m_iToolTipItem || iColumn != m_iToolTipColumn)
			{
				// Use Activate() to hide the tooltip.
				m_pctrlToolTip->Activate(FALSE);
			}
	
			if (fItemHit)
			{
				m_pctrlToolTip->Activate(TRUE);
				m_iToolTipItem = iItem;
				m_iToolTipColumn = iColumn;
			}
			else
			{
				m_iToolTipItem = -1;
				m_iToolTipColumn = -1;
			}
		}
    }
    COrcaListView::OnMouseMove(nFlags, point);
}

////
// change the view of the currently selected column to Hex. Resizes the
// column if needed, unless doing so would push the total width of the
// columns beyond the window width.
void CTableView::OnViewColumnHex()
{
	if (!m_pTable || m_nSelCol == -1)
		return;
	ChangeColumnView(m_nSelCol, true);
}

////
// swith the view of the currently selected column to decimal. Does not
// resize the columns.
void CTableView::OnViewColumnDecimal()
{
	if (!m_pTable || m_nSelCol == -1)
		return;
	ChangeColumnView(m_nSelCol, false);
}

////
// change the view of the whose header was right-clicked to Hex,
// even if that column is not selected. Resizes the
// column if needed, unless doing so would push the total width of the
// columns beyond the window width.
void CTableView::OnViewColumnHexHdr()
{
	if (!m_pTable || m_iHeaderClickColumn == -1)
		return;
	ChangeColumnView(m_iHeaderClickColumn, true);
}

////
// swith the view of the column whose header was right-clicked, even
// if that column is not selected. Does not resize the columns.
void CTableView::OnViewColumnDecimalHdr()
{
	if (!m_pTable || m_iHeaderClickColumn == -1)
		return;
	ChangeColumnView(m_iHeaderClickColumn, false);
}

////
// does the actual work of switching a column view from hex to decimal
// and back.
void CTableView::ChangeColumnView(int iColumn, bool fHex)
{
	ASSERT(m_pTable);
	if (!m_pTable || iColumn < 0 || iColumn >= m_pTable->GetColumnCount())
		return;
	const COrcaColumn* pColumn=m_pTable->GetColumn(iColumn);
	if (!pColumn)
		return;

	// verify integer column
	if (pColumn->m_eiType != iColumnShort && pColumn->m_eiType != iColumnLong)
		return;

	pColumn->SetDisplayInHex(fHex);
	
	if (fHex)
	{
		CListCtrl& rctrlList = GetListCtrl();
		
		// if all of the columns together add up to less than the window width,
		// expand the resized column to show all characters
		int iTotalWidth = 0;
		for (int iCol=0; iCol < m_pTable->GetColumnCount(); iCol++)
		{
			iTotalWidth += rctrlList.GetColumnWidth(iCol);
		}
	
		// grab the window dimensions to calculate maximum column widths
		CRect rClient;
		GetClientRect(&rClient);
		int iWindowWidth = rClient.right;
	
		// try to determine if a scroll bar is going to show up 
		if (m_pTable->GetRowCount()*m_iRowHeight > rClient.bottom)
		{
			iWindowWidth -= GetSystemMetrics(SM_CXVSCROLL);
		}
	
		// retreive the current and desired column widths for this column
		int iDesiredWidth = GetMaximumColumnWidth(iColumn);
		int iCurrentWidth = rctrlList.GetColumnWidth(iColumn);
	
		// check the system settings to see if we should force columns to fit in the view
		bool fForceColumns = AfxGetApp()->GetProfileInt(_T("Settings"), _T("ForceColumnsToFit"), 1) == 1;
	
		// only resize the column if it is not big enough. If it is too big, 
		// leave it alone.
		if (iDesiredWidth > iCurrentWidth)
		{
			// ensure that resizing this column won't push beyond the window boundary
			// unless we're already beyond the window boundary
			if ((iTotalWidth > iWindowWidth) || (iTotalWidth - iCurrentWidth + iDesiredWidth < iWindowWidth))
			{
				pColumn->m_nWidth = iDesiredWidth;
				rctrlList.SetColumnWidth(iColumn, iDesiredWidth);
			}
		}
	}

	// pass NULL as window so that this view also gets the message
	GetDocument()->UpdateAllViews(NULL, HINT_REDRAW_ALL, NULL);
}

///////////////////////////////////////////////////////////
// OnUpdateViewColumnFormat
void CTableView::OnUpdateViewColumnFormat(CCmdUI* pCmdUI) 
{
	if (m_nSelCol > 0 && m_pTable && m_nSelCol <= m_pTable->GetColumnCount()) 
	{
		const COrcaColumn* pColumn = m_pTable->GetColumn(m_nSelCol);
		if (pColumn && (pColumn->m_eiType == iColumnLong || pColumn->m_eiType == iColumnShort))
		{
			pCmdUI->Enable(TRUE);
			return;
		}
	}

	pCmdUI->Enable(FALSE);
}	// end of OnUpdateEditPaste

///////////////////////////////////////////////////////////
// notification messages from the list view and header control
BOOL CTableView::OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult )
{
	NMHEADER* pHDR = reinterpret_cast<NMHEADER*>(lParam);
	switch (pHDR->hdr.code)
	{
	case NM_RCLICK:
	{
		// get list control and header
		CListCtrl& rctrlList = GetListCtrl();
		HWND hHeader = ListView_GetHeader(rctrlList.m_hWnd);

		// win95 gold fails ListView_GetHeader.
		if (!hHeader || pHDR->hdr.hwndFrom != hHeader)
		{
			break;
		}

		// ensure there is a table
		if (!m_pTable)
			break;

		CHeaderCtrl* pCtrl = rctrlList.GetHeaderCtrl();
		if (!pCtrl)
			break;

		// get the position of the click
		DWORD dwPos = GetMessagePos();
		CPoint ptClick(LOWORD(dwPos), HIWORD(dwPos));
		CPoint ptScreen(ptClick);
		pCtrl->ScreenToClient(&ptClick);

		// determine which column was clicked by sending the header
		// control a hittest message
		HD_HITTESTINFO hdhti;
		hdhti.pt = ptClick;
		pCtrl->SendMessage(HDM_HITTEST, (WPARAM)0, (LPARAM)&hdhti);
		int iColumn = hdhti.iItem;

		// determine if the column is integer
		const COrcaColumn* pColumn = m_pTable->GetColumn(iColumn);
		if (!pColumn)
			break;
		if (pColumn->m_eiType != iColumnShort && pColumn->m_eiType != iColumnLong)
			break;

		// create a popup menu
		m_iHeaderClickColumn = iColumn;
		CMenu menuContext;
		menuContext.LoadMenu(IDR_HEADER_POPUP);
		menuContext.CheckMenuRadioItem(ID_VIEW_DECIMAL_HDR, ID_VIEW_HEX_HDR, pColumn->DisplayInHex() ? ID_VIEW_HEX_HDR : ID_VIEW_DECIMAL_HDR, MF_BYCOMMAND);
		menuContext.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN|TPM_TOPALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());

		return 1;
	}
	default:
		break;
	}
	return COrcaListView::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\tablelst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// TableLst.cpp : implementation file
//

#include "stdafx.h"
#include "Orca.h"
#include "OrcaDoc.h"
#include "MainFrm.h"

#include "TableLst.h"
#include "TblErrD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTableList

IMPLEMENT_DYNCREATE(CTableList, COrcaListView)

CTableList::CTableList()
{
	m_cColumns = 1;
	m_nPreviousItem = -1;
}

CTableList::~CTableList()
{
}


BEGIN_MESSAGE_MAP(CTableList, COrcaListView)
	//{{AFX_MSG_MAP(CTableList)
	ON_WM_SIZE()
	ON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnItemchanged)
	ON_WM_RBUTTONDOWN()
	ON_COMMAND(IDM_ADD_TABLE, OnAddTable)
	ON_COMMAND(IDM_DROP_TABLE, OnDropTable)
	ON_COMMAND(IDM_PROPERTIES, OnProperties)
	ON_COMMAND(IDM_ERRORS, OnErrors)
	ON_COMMAND(IDM_EXPORT_TABLES, OnContextTablesExport)
	ON_COMMAND(IDM_IMPORT_TABLES, OnContextTablesImport)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTableList drawing

void CTableList::OnDraw(CDC* pDC)
{
}

/////////////////////////////////////////////////////////////////////////////
// CTableList diagnostics

#ifdef _DEBUG
void CTableList::AssertValid() const
{
	COrcaListView::AssertValid();
}

void CTableList::Dump(CDumpContext& dc) const
{
	COrcaListView::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTableList message handlers

void CTableList::OnInitialUpdate() 
{
	m_bDrawIcons = true;
	m_bDisableAutoSize = false;
	COrcaListView::OnInitialUpdate();
	
	CListCtrl& rctrlList = GetListCtrl();

	// empty any previous columns
	while (rctrlList.DeleteColumn(0))
		;

	// add the table list
	m_nSelCol = 0;
	RECT rcSize;
	GetWindowRect(&rcSize);
	rctrlList.InsertColumn(0, _T("Tables"), LVCFMT_LEFT, rcSize.right - rcSize.left + 1);
	rctrlList.SetColumnWidth(0, LVSCW_AUTOSIZE_USEHEADER);

	CSplitterWnd *wndParent = static_cast<CSplitterWnd *>(GetParent());
	if (wndParent)
		wndParent->RecalcLayout();
}

void CTableList::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	// if this is the sender bail
	if (this == pSender)
		return;

	CListCtrl& rctrlList = GetListCtrl();

	switch (lHint) {
	case HINT_REDRAW_ALL:	// simple redraw request
	{
		rctrlList.RedrawItems(0, rctrlList.GetItemCount());
		break;
	}
	case HINT_REDRAW_TABLE:
	{
		LVFINDINFO findInfo;
		findInfo.flags = LVFI_PARAM;
		findInfo.lParam = reinterpret_cast<INT_PTR>(pHint);
		
		int iItem = rctrlList.FindItem(&findInfo);
		if (iItem < 0)
			break;
		rctrlList.RedrawItems(iItem, iItem);
		rctrlList.EnsureVisible(iItem, FALSE);
	}
	case HINT_ADD_ROW:
	case HINT_DROP_ROW:
		break; // do nothing
	case HINT_ADD_TABLE_QUIET:
	case HINT_ADD_TABLE:
	{
		ASSERT(pHint);

		COrcaTable* pTableHint = (COrcaTable*)pHint;		
		COrcaTable* pTable;

		// see if this table is in the list control already
		int iFound = -1;	// assume not going to find it
		int cItems = rctrlList.GetItemCount();
		for (int i = 0; i < cItems; i++)
		{
			pTable = (COrcaTable*)rctrlList.GetItemData(i);

			if (pTable == pTableHint)
			{
				iFound = i;
				break;
			}
		}

		// if it was not found add it and select it
		if (iFound < 0)
		{
			rctrlList.InsertItem(LVIF_PARAM | LVIF_STATE, 
									  rctrlList.GetItemCount(),
									  NULL,
									  (lHint == HINT_ADD_TABLE_QUIET) ? 0 : LVIS_SELECTED|LVIS_FOCUSED, 
									  0, 0,
									  (LPARAM)pTableHint);

			// sort the items now to put this new table in the right place
			rctrlList.SortItems(SortList, (LPARAM)this);
		}
		else if (lHint != HINT_ADD_TABLE_QUIET)
		{
			// item is already in the list so select

			// if there was a previously selected item
			if (m_nPreviousItem >= 0)
				pTable = (COrcaTable*)rctrlList.GetItemData(m_nPreviousItem);
			else	// nothing was selected
				pTable = NULL;

			// if this is a newly selected item
			if (pTableHint != pTable)
			{
				rctrlList.SetItemState(iFound, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
			}

			// update status bar
			((CMainFrame*)AfxGetMainWnd())->SetTableCount(cItems+1);
		}
		break;
	}
	case HINT_DROP_TABLE:
	{
		ASSERT(pHint);

		COrcaTable* pTableHint = (COrcaTable*)pHint;		
		COrcaTable* pTable;

		// see if this table is in the list control already
		int iFound = -1;	// assume not going to find it
		int cItems = rctrlList.GetItemCount();
		for (int i = 0; i < cItems; i++)
		{
			pTable = (COrcaTable*)rctrlList.GetItemData(i);

			if (pTable == pTableHint)
			{
				iFound = i;
				break;
			}
		}
		ASSERT(iFound > -1);	// make sure something was found

		rctrlList.DeleteItem(iFound);

		// if there are items set the selected item
		if (rctrlList.GetItemCount() > 0)
		{
			if (rctrlList.GetItemCount() != (m_nPreviousItem + 1))
				m_nPreviousItem--;
			rctrlList.SetItemState(m_nPreviousItem, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
		}

		// update status bar
		((CMainFrame*)AfxGetMainWnd())->SetTableCount(cItems-1);
		
		break;
	}
	case HINT_TABLE_REDEFINE:
	{
		LVFINDINFO findInfo;
		findInfo.flags = LVFI_PARAM;
		findInfo.lParam = reinterpret_cast<INT_PTR>(pHint);

		// this didn't come from us, so we have to set the selection state manually
		int iItem = rctrlList.FindItem(&findInfo);
		ASSERT(iItem >= 0);
		rctrlList.RedrawItems(iItem, iItem);
		rctrlList.EnsureVisible(iItem, FALSE);
		break;
	}
	case HINT_CHANGE_TABLE:
	{
		// if an item is currently selected
		if (m_nPreviousItem >= 0)
		{
			// and we're switching to the same item, just ensure that it is visible
			if (reinterpret_cast<COrcaTable*>(rctrlList.GetItemData(m_nPreviousItem)) == static_cast<COrcaTable*>(pHint))
			{
				rctrlList.EnsureVisible(m_nPreviousItem, FALSE);
				break;
			}
		}

		LVFINDINFO findInfo;
		findInfo.flags = LVFI_PARAM;
		findInfo.lParam = reinterpret_cast<INT_PTR>(pHint);

		// this didn't come from us, so we have to set the selection state manually
		int iItem = rctrlList.FindItem(&findInfo);
		if (iItem < 0) break;
		rctrlList.SetItemState(iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
		rctrlList.EnsureVisible(iItem, FALSE);
		break;
	}
	case HINT_TABLE_DROP_ALL:
	{
		// empty out the list control
		rctrlList.DeleteAllItems();
		break;
	}
	case HINT_RELOAD_ALL:
	{
		// empty out the list control
		rctrlList.DeleteAllItems();

		// if there is no table open in the document
		COrcaDoc* pDoc = GetDocument();
		if (iDocNone == pDoc->m_eiType)
		{
			break;
		}

		// refill from document
		int cTables = 0;
		RECT rClient;
		RECT rWindow;
		
		COrcaTable* pTable;
		POSITION pos = pDoc->m_tableList.GetHeadPosition();
		while (pos)
		{
			pTable = pDoc->m_tableList.GetNext(pos);

			rctrlList.InsertItem(LVIF_PARAM, 
									  rctrlList.GetItemCount(),
									  NULL,
									  0, 0, 0,
									  (LPARAM)pTable);
			cTables++;
		}

		int iMinWidth = 0;
		int iDummy = 0;
		CSplitterWnd *wndParent = (CSplitterWnd *)GetParent();

		// set the width to the maximum string width
		// set the minimum (arbitrarily) to 10.
		TRACE(_T("AutoSizing Table list - called.\n"));

		// Set this to true to not automatically size the control when the window is
		// resized. Otherwise, when we set the column width, any ColumnWidth messages floating
		// around in the queue will muck with things before we have a chance to fix the size
		// (at least I think thats what was happening).
		m_bDisableAutoSize = true;
		int cColumnWidth = 0;
		if (cTables)
		{
			cColumnWidth = GetMaximumColumnWidth(0);
			rctrlList.SetColumnWidth(0, cColumnWidth);
		}
		else
		{
			rctrlList.SetColumnWidth(0, LVSCW_AUTOSIZE_USEHEADER);
			cColumnWidth = rctrlList.GetColumnWidth(0);
		}
		wndParent->SetColumnInfo(0, cColumnWidth + GetSystemMetrics(SM_CXVSCROLL), 10);

		// make the changes
		m_bDisableAutoSize = false;

		wndParent->RecalcLayout();

		((CMainFrame*)AfxGetMainWnd())->SetTableCount(cTables);

		// sort
		rctrlList.SortItems(SortList, (LPARAM)this);

		m_nPreviousItem = -1;
		break;
	}
	default:
		break;
	}
}

// the cx value coming in is the client size.
void CTableList::OnSize(UINT nType, int cx, int cy) 
{
	COrcaListView::OnSize(nType, cx, cy);
	TRACE(_T("CTableList::OnSize - called.\n"));

	// minimum width is 1. Status bar controls don't like 0 width panes
	if (cx < 1) cx = 1;

	CRect rWindow;
	int iScrollWidth;

	// adjust the status bar. Because cx is client, we have to get the 
	// NC area in order to set the status bar correctly.
	GetWindowRect(&rWindow);
	iScrollWidth = (rWindow.right-rWindow.left);
	CMainFrame* pFrame = ((CMainFrame*)AfxGetMainWnd());
	if (pFrame)
		pFrame->SetStatusBarWidth(iScrollWidth);

	// unless told not to (see reload hint for discussion) adujust 
	// the list control.
	if (!m_bDisableAutoSize)
	{
		// DO NOT use GetListCtrl().SetColumnWidth() here. The list control cannot handle setting
		// a column width in the midst of a resize which changes whether the vertical scroll bar
		// is needed or not, it gets confused and improperly scrolls the window down by the 
		// previous scroll amount even in the new shape. Instead, post the message directly
		// to the window queue (rather than blocking). 
		GetListCtrl().PostMessage(LVM_SETCOLUMNWIDTH, 0, MAKELPARAM(LVSCW_AUTOSIZE_USEHEADER, 0)); 
	}
}



///////////////////////////////////////////////////////////
// SortList
int CALLBACK SortList(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	COrcaTable* pTable1 = (COrcaTable*)lParam1;
	COrcaTable* pTable2 = (COrcaTable*)lParam2;
	
	return pTable1->Name().Compare(pTable2->Name());
}	// end of SortList

void CTableList::OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	if (pNMListView->iItem != m_nPreviousItem)
	{
		CWaitCursor cursorWait;	// switch to an hour glass real quick
		// need to manually set selection state 
//		rctrlList.SetItemState(iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
		rctrlList.RedrawItems(pNMListView->iItem, pNMListView->iItem);
		rctrlList.UpdateWindow();

		// get the document
		COrcaDoc* pDoc = GetDocument();
		pDoc->UpdateAllViews(this, HINT_CHANGE_TABLE, (COrcaTable*)pNMListView->lParam);

		m_nPreviousItem = pNMListView->iItem;
	}

	*pResult = 0;
}

void CTableList::OnRButtonDown(UINT nFlags, CPoint point) 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	
	// if there are no items in this list
	if (rctrlList.GetItemCount() < 1)
		return;	// bail

	// get if any item was hit
	UINT iState;
	int iItem = rctrlList.HitTest(point, &iState);
	int iCol = -1;

	// if missed an item
	if (iItem < 0 || !(iState & LVHT_ONITEM))
	{
		COrcaListView::OnRButtonDown(nFlags, point);
	}
	else	// something was hit with the mouse button
	{
		// select the item
		rctrlList.SetItemState(iItem, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
	}
	ClientToScreen(&point);

	// create and track the pop up menu
	CMenu menuContext;
	menuContext.LoadMenu(IDR_LIST_POPUP);
	menuContext.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN|TPM_TOPALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, point.x, point.y, AfxGetMainWnd());
}

void CTableList::OnAddTable() 
{
	GetDocument()->OnTableAdd();
}

void CTableList::OnDropTable() 
{
	GetDocument()->OnTableDrop();
}

void CTableList::OnContextTablesExport() 
{
	((CMainFrame *)AfxGetMainWnd())->ExportTables(true);
}

void CTableList::OnContextTablesImport() 
{
	GetDocument()->OnTablesImport();
}

void CTableList::OnProperties() 
{
	AfxMessageBox(_T("What Properties do you want to see?"), MB_ICONINFORMATION);
}

void CTableList::OnErrors() 
{
	CListCtrl& rctrlList = GetListCtrl();
	COrcaTable* pTable = ((CMainFrame*)AfxGetMainWnd())->GetCurrentTable();

	CTableErrorD dlg;
	dlg.m_strTable = pTable->Name();
	dlg.m_strErrors.Format(_T("%d"), pTable->GetErrorCount());
	dlg.m_strWarnings.Format(_T("%d"), pTable->GetWarningCount());

	const CStringList *pErrorList = pTable->ErrorList();
	POSITION pos = pErrorList->GetHeadPosition();
	if (pos)
	{
		TableErrorS* pError;
		while (pos)
		{
			pError  = new TableErrorS;
			dlg.m_errorsList.AddTail(pError);

			pError->strICE = pErrorList->GetNext(pos);
			pError->strDescription = pErrorList->GetNext(pos);
			pError->strURL = pErrorList->GetNext(pos);
			pError->iError = iTableError;
		}
	}

	dlg.DoModal();
}

COrcaListView::ErrorState CTableList::GetErrorState(const void *data, int iColumn) const
{
	ASSERT(data);
	if (iTableError == ((const COrcaTable *)data)->Error()) 
		return ((const COrcaTable *)data)->IsShadow() ? ShadowError : Error;
	return OK;
}

OrcaTransformAction CTableList::GetItemTransformState(const void *data) const
{
	ASSERT(data);
	return ((const COrcaTable *)data)->IsTransformed();
}

const CString* CTableList::GetOutputText(const void *rowdata, int iColumn) const
{
	ASSERT(rowdata);
	return &((const COrcaTable *)rowdata)->Name();
}

bool CTableList::ContainsTransformedData(const void *data) const
{
	ASSERT(data);
	return ((const COrcaTable *)data)->ContainsTransformedData();
}

bool CTableList::ContainsValidationErrors(const void *data) const
{
	ASSERT(data);
	return ((const COrcaTable *)data)->ContainsValidationErrors();
}

bool CTableList::Find(OrcaFindInfo &FindInfo)
{
	int iItem;
	int iChangeVal = FindInfo.bForward ? 1 : -1;

	CListCtrl& rctrlList = GetListCtrl();

	POSITION pos = GetFirstSelectedItemPosition();

	int iMaxItems = rctrlList.GetItemCount();
	// if nothing is selected or we are set to wholedoc, start at the very beginning
	if (FindInfo.bWholeDoc || (pos == NULL)) {
		iItem = FindInfo.bForward ? 0 : iMaxItems-1;
		// and if we start at 0, we ARE searching the whole document
		FindInfo.bWholeDoc = true;
	}
	else
	{   
		iItem = GetNextSelectedItem(pos)+iChangeVal;
	}
	
	for ( ; (iItem >= 0) && (iItem < iMaxItems); iItem += iChangeVal) {
		COrcaTable *pTable = (COrcaTable *)rctrlList.GetItemData(iItem);
		COrcaRow *pRow = NULL;
		int iCol = 0;
	
		// retrieve the table if necessary
		pTable->RetrieveTableData();

		if (pTable->Find(FindInfo, pRow, iCol)) 
		{
			// pass Null as sender so we get the message tooe
			GetDocument()->UpdateAllViews(NULL, HINT_CHANGE_TABLE, pTable);
			GetDocument()->UpdateAllViews(this, HINT_SET_ROW_FOCUS, pRow);
			GetDocument()->UpdateAllViews(this, HINT_SET_COL_FOCUS, reinterpret_cast<CObject*>(static_cast<INT_PTR>(iCol)));
			return true;
		}
	}
	return false;
}

BOOL CTableList::PreCreateWindow(CREATESTRUCT& cs) 
{
	// TODO: Add your specialized code here and/or call the base class
	cs.style |= LVS_SINGLESEL | LVS_SORTASCENDING;
	
	return COrcaListView::PreCreateWindow(cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\tablelst.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_TABLELST_H__C3EDC1B8_E506_11D1_A856_006097ABDE17__INCLUDED_)
#define AFX_TABLELST_H__C3EDC1B8_E506_11D1_A856_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TableLst.h : header file
//

#include "OrcaLstV.h"

/////////////////////////////////////////////////////////////////////////////
// CTableList view

class CTableList : public COrcaListView
{
protected:
	CTableList();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CTableList)

// Attributes
public:
	int m_nPreviousItem;

// Operations
public:
	bool m_bDisableAutoSize;
	bool Find(OrcaFindInfo &FindInfo);
	void OnClose();

	friend int CALLBACK SortList(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTableList)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CTableList();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CTableList)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnAddTable();
	afx_msg void OnDropTable();
	afx_msg void OnProperties();
	afx_msg void OnErrors();
	afx_msg void OnContextTablesExport();
	afx_msg void OnContextTablesImport();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	virtual ErrorState GetErrorState(const void *data, int iColumn) const;
	virtual const CString *GetOutputText(const void *data, int iColumn) const;
	virtual OrcaTransformAction GetItemTransformState(const void *data) const;

	virtual bool ContainsValidationErrors(const void *data) const;
	virtual bool ContainsTransformedData(const void *data) const;
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABLELST_H__C3EDC1B8_E506_11D1_A856_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\tablevw.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// TableVw.h : interface of the CTableView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_TABLEVW_H__C3EDC1B0_E506_11D1_A856_006097ABDE17__INCLUDED_)
#define AFX_TABLEVW_H__C3EDC1B0_E506_11D1_A856_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "CellEdit.h"
#include "OrcaLstV.h"

class CTableView : public COrcaListView
{
protected: // create from serialization only
	CTableView();
	DECLARE_DYNCREATE(CTableView)

// Attributes
public:
	COrcaTable* m_pTable;
	CCellEdit m_editData;
	CStatic m_ctrlStatic;

// Operations
public:
	void OnClose();

	static int CALLBACK SortView(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTableView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	virtual BOOL PreTranslateMessage( MSG* pMsg );

	virtual BOOL OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult );

	//}}AFX_VIRTUAL

// Implementation
public:
	bool Find(OrcaFindInfo &FindInfo);
	virtual void UpdateColumn(int i);
	virtual ~CTableView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void SwitchFont(CString name, int size);

protected:

	BOOL m_bCtrlDown;

	void EditCell(BOOL bSelectAll = TRUE);
	BOOL CommitEdit(BOOL bSave = TRUE);

// Generated message map functions
protected:
	//{{AFX_MSG(CTableView)
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnDropRowConfirm();
	afx_msg void OnErrors();
	afx_msg void OnProperties();
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnEditCopy();
	afx_msg void OnEditCut();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRowDrop(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnEditCopyRow();
	afx_msg void OnUpdateEditCopyRow(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditCutRow(CCmdUI* pCmdUI);
	afx_msg void OnEditCutRow();
	afx_msg void OnUpdateEditPasteRow(CCmdUI* pCmdUI);
	afx_msg void OnEditPasteRow();
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSize( UINT nType, int cx, int cy );
	afx_msg HBRUSH OnCtlColor( CDC* pDC, CWnd* pWnd, UINT nCtlColor); 
	afx_msg BOOL OnToolTipNotify( UINT id, NMHDR * pNMHDR, LRESULT * pResult );
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);

	afx_msg void OnViewColumnHex();
	afx_msg void OnViewColumnDecimal();
	afx_msg void OnViewColumnHexHdr();
	afx_msg void OnViewColumnDecimalHdr();
	afx_msg void OnUpdateViewColumnFormat(CCmdUI* pCmdUI);


	//}}AFX_MSG
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUpdateRowAdd(CCmdUI* pCmdUI);
	DECLARE_MESSAGE_MAP()
private:
	void ChangeColumnView(int iColumn, bool fHex);
	void EnsureVisibleCol(const int iCol);
	void UnSelectAll();
	void DropRows();

	virtual ErrorState GetErrorState(const void *row, int iColumn) const;
	virtual const CString *GetOutputText(const void *data, int iColumn) const;

	virtual OrcaTransformAction GetCellTransformState(const void *data, int iColumn) const;
	virtual OrcaTransformAction GetItemTransformState(const void *data) const;
	virtual OrcaTransformAction GetColumnTransformState(int iColumn) const;
	
	bool GetRowAndColumnFromCursorPos(CPoint point, int &iItem, int &iCol);
	bool AnySelectedItemIsActive() const;

	CToolTipCtrl* m_pctrlToolTip;
	int m_iToolTipItem;
	int m_iToolTipColumn;

	int m_iHeaderClickColumn;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABLEVW_H__C3EDC1B0_E506_11D1_A856_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\tblerrd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// TblErrD.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "TblErrD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTableErrorD dialog


CTableErrorD::CTableErrorD(CWnd* pParent /*=NULL*/)
	: CDialog(CTableErrorD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTableErrorD)
	m_strErrors = _T("");
	m_strWarnings = _T("");
	m_strTable = _T("");
	//}}AFX_DATA_INIT
}


void CTableErrorD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTableErrorD)
	DDX_Text(pDX, IDC_ERRORS, m_strErrors);
	DDX_Text(pDX, IDC_WARNINGS, m_strWarnings);
	DDX_Text(pDX, IDC_TABLE, m_strTable);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTableErrorD, CDialog)
	//{{AFX_MSG_MAP(CTableErrorD)
	ON_WM_DESTROY()
	ON_WM_DRAWITEM()
	ON_NOTIFY(NM_CLICK, IDC_TABLE_LIST, OnClickTableList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTableErrorD message handlers

BOOL CTableErrorD::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	CListCtrl* pList = (CListCtrl*)GetDlgItem(IDC_TABLE_LIST);
//	pList->ModifyStyle(NULL, LVS_REPORT EDLISTVIEWSTYLE, 0, LVS_EX_F| LVS_SHOWSELALWAYS | LVS_OWNERDRAWFIXED | LVS_SINGLESEL);
	pList->SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

	RECT rcSize;
	pList->GetWindowRect(&rcSize);
	pList->InsertColumn(0, _T("ICE"), LVCFMT_LEFT, 50);
	pList->InsertColumn(1, _T("Description"), LVCFMT_LEFT, rcSize.right - 50 - rcSize.left - 4);
	pList->SetBkColor(RGB(255, 255, 255));

	int nAddedAt;
	TableErrorS* pError;
	while (m_errorsList.GetHeadPosition())
	{
		pError = m_errorsList.RemoveHead();
		nAddedAt = pList->InsertItem(LVIF_TEXT | LVIF_PARAM | LVIF_STATE, 
											  pList->GetItemCount(),
											  pError->strICE,
											  LVIS_SELECTED|LVIS_FOCUSED, 
											  0, 0,
											  (LPARAM)pError);
		pList->SetItem(nAddedAt, 
							1, 
							LVIF_TEXT, 
							pError->strDescription, 
							0, 0, 0, 0);
	}

	m_bHelpEnabled = AfxGetApp()->GetProfileInt(_T("Validation"), _T("EnableHelp"), 0)==1;
		
	return TRUE;  // return TRUE unless you set the focus to a control
}

///////////////////////////////////////////////////////////
// DrawItem
void CTableErrorD::DrawItem(LPDRAWITEMSTRUCT pDraw)
{
	// get list control
	CListCtrl* pList = (CListCtrl*)GetDlgItem(IDC_TABLE_LIST);
	OrcaTableError iError = ((TableErrorS*)pList->GetItemData(pDraw->itemID))->iError;

	CDC dc;
	dc.Attach(pDraw->hDC);

	// loop through all the columns
	int iColumnWidth;
	int iTextOut = pDraw->rcItem.left;		// position to place first word (in pixels)
	RECT rcArea;

	rcArea.top = pDraw->rcItem.top;
	rcArea.bottom = pDraw->rcItem.bottom;

	CPen penBlue(PS_SOLID, 1, RGB(0, 0, 255));
	CPen* ppenOld = dc.SelectObject(&penBlue);

	CString strText;
	for (int i = 0; i < 2; i++)
	{
		iColumnWidth = pList->GetColumnWidth(i);

		// area box to redraw
		rcArea.left = iTextOut;
		iTextOut += iColumnWidth;
		rcArea.right = iTextOut;

		dc.SetTextColor(RGB(0, 0, 255));

		// get text
		strText = pList->GetItemText(pDraw->itemID, i);

		rcArea.left = rcArea.left + 2;
		rcArea.right = rcArea.right - 2;
		dc.DrawText(strText, &rcArea, DT_LEFT|DT_NOPREFIX|DT_SINGLELINE);

		// draw an underline
		if (m_bHelpEnabled)
		{
			dc.MoveTo(rcArea.left, rcArea.bottom - 2);
			dc.LineTo(rcArea.right + 2, rcArea.bottom - 2);
		}
	}

	dc.SelectObject(ppenOld);
	dc.Detach();
}	// end of DrawItem

void CTableErrorD::OnDestroy() 
{
	CListCtrl* pList = (CListCtrl*)GetDlgItem(IDC_TABLE_LIST);
	int cItems =  pList->GetItemCount();
	for (int i = 0; i < cItems; i++)
	{
		delete (TableErrorS*)pList->GetItemData(i);
	}

	CDialog::OnDestroy();
}

void CTableErrorD::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	if (IDC_TABLE_LIST == nIDCtl)
		DrawItem(lpDrawItemStruct);

	CDialog::OnDrawItem(nIDCtl, lpDrawItemStruct);
}

void CTableErrorD::OnClickTableList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	if (!m_bHelpEnabled)
		return;

	// find the selected list control
	CListCtrl* pList = (CListCtrl*)GetDlgItem(IDC_TABLE_LIST);

	CString strURL = _T("");
	int cItems = pList->GetItemCount();
	for (int i = 0; i < cItems; i++)
	{
		if (pList->GetItemState(i, LVIS_SELECTED) & LVIS_SELECTED)
		{
			strURL = ((TableErrorS*)pList->GetItemData(i))->strURL;
			break;
		}
	}

	if(!strURL.IsEmpty())
	{
		if (32 >= (const INT_PTR)ShellExecute(AfxGetMainWnd()->m_hWnd, _T("open"), strURL, _T(""), _T(""), SW_SHOWNORMAL)) 
			AfxMessageBox(_T("There was an error opening your browser. Web help is not available."));
	}
	else
		AfxMessageBox(_T("There is no help associated with this ICE at this time."));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\trnpropd.cpp ===
// TransformPropDlg.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "Trnpropd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTransformPropDlg dialog


CTransformPropDlg::CTransformPropDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTransformPropDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTransformPropDlg)
	m_bValAddExistingRow = FALSE;
	m_bValAddExistingTable = FALSE;
	m_bValChangeCodepage = FALSE;
	m_bValDelMissingRow = FALSE;
	m_bValDelMissingTable = FALSE;
	m_bValUpdateMissingRow = FALSE;
	m_bValLanguage = FALSE;
	m_bValProductCode = FALSE;
	m_bValUpgradeCode = FALSE;
	m_iVersionCheck = 0;
	m_bValGreaterVersion = FALSE;
	m_bValLowerVersion = FALSE;
	m_bValEqualVersion = FALSE;
	//}}AFX_DATA_INIT
}


void CTransformPropDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTransformPropDlg)
	DDX_Control(pDX, IDC_VALGREATER, m_btnValGreater);
	DDX_Control(pDX, IDC_VALLESS, m_btnValLess);
	DDX_Control(pDX, IDC_VALEQUAL, m_btnValEqual);
	DDX_Control(pDX, IDC_VALMAJOR, m_btnMajor);
	DDX_Control(pDX, IDC_VALMINOR, m_btnMinor);
	DDX_Control(pDX, IDC_VALUPDATE, m_btnUpdate);
	DDX_Control(pDX, IDC_VERSTATIC1, m_ctrlVerStatic1);
	DDX_Control(pDX, IDC_VERSTATIC2, m_ctrlVerStatic2);
	DDX_Control(pDX, IDC_VERSTATIC3, m_ctrlVerStatic3);
	DDX_Control(pDX, IDC_VERSTATIC4, m_ctrlVerStatic4);
	DDX_Check(pDX, IDC_ADDEXISTINGROW, m_bValAddExistingRow);
	DDX_Check(pDX, IDC_ADDEXISTINGTABLE, m_bValAddExistingTable);
	DDX_Check(pDX, IDC_CHANGECODEPAGE, m_bValChangeCodepage);
	DDX_Check(pDX, IDC_DELMISSINGROW, m_bValDelMissingRow);
	DDX_Check(pDX, IDC_DELMISSINGTABLE, m_bValDelMissingTable);
	DDX_Check(pDX, IDC_UPDATEMISSINGROW, m_bValUpdateMissingRow);
	DDX_Check(pDX, IDC_VALLANGUAGE, m_bValLanguage);
	DDX_Check(pDX, IDC_VALPRODUCT, m_bValProductCode);
	DDX_Check(pDX, IDC_VALUPGRADE, m_bValUpgradeCode);
	DDX_Radio(pDX, IDC_VALMAJOR, m_iVersionCheck);
	DDX_Check(pDX, IDC_VALGREATER, m_bValGreaterVersion);
	DDX_Check(pDX, IDC_VALLESS, m_bValLowerVersion);
	DDX_Check(pDX, IDC_VALEQUAL, m_bValEqualVersion);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTransformPropDlg, CDialog)
	//{{AFX_MSG_MAP(CTransformPropDlg)
	ON_BN_CLICKED(IDC_VALGREATER, OnValGreater)
	ON_BN_CLICKED(IDC_VALLESS, OnValLess)
	ON_BN_CLICKED(IDC_VALEQUAL, OnValEqual)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTransformPropDlg message handlers


void CTransformPropDlg::OnValGreater() 
{
	if (m_btnValGreater.GetCheck())
		m_btnValLess.SetCheck(FALSE);
	m_btnValLess.EnableWindow(!m_btnValGreater.GetCheck());

	EnableVersionRadioButtons();
}

void CTransformPropDlg::OnValEqual() 
{
	EnableVersionRadioButtons();
}

void CTransformPropDlg::OnValLess() 
{
	if (m_btnValLess.GetCheck())
		m_btnValGreater.SetCheck(FALSE);
	m_btnValGreater.EnableWindow(!m_btnValLess.GetCheck());

	EnableVersionRadioButtons();
}

void CTransformPropDlg::EnableVersionRadioButtons() 
{
	bool fEnable = m_btnValLess.GetCheck() || m_btnValGreater.GetCheck() || m_btnValEqual.GetCheck();
	m_btnMajor.EnableWindow(fEnable);
	m_btnMinor.EnableWindow(fEnable);
	m_btnUpdate.EnableWindow(fEnable);
	m_ctrlVerStatic1.EnableWindow(fEnable);
	m_ctrlVerStatic2.EnableWindow(fEnable);
	m_ctrlVerStatic3.EnableWindow(fEnable);
	m_ctrlVerStatic4.EnableWindow(fEnable);
}

BOOL CTransformPropDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// set the enable/disable state of the greater/less controls
	OnValGreater();
	OnValLess();
	EnableVersionRadioButtons();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\tblerrd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

#if !defined(AFX_TBLERRD_H__25468EE3_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_)
#define AFX_TBLERRD_H__25468EE3_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TblErrD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTableErrorD dialog

#include "Table.h"

struct TableErrorS
{
	CString strICE;
	CString strDescription;
	CString strURL;
	OrcaTableError iError;
};

class CTableErrorD : public CDialog
{
// Construction
public:
	CTableErrorD(CWnd* pParent = NULL);   // standard constructor
	void DrawItem(LPDRAWITEMSTRUCT);

	CTypedPtrList<CPtrList, TableErrorS*> m_errorsList;

// Dialog Data
	//{{AFX_DATA(CTableErrorD)
	enum { IDD = IDD_TABLE_ERROR };
	CString	m_strErrors;
	CString	m_strWarnings;
	CString	m_strTable;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTableErrorD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTableErrorD)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnClickTableList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool m_bHelpEnabled;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TBLERRD_H__25468EE3_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\trnpropd.h ===
#if !defined(AFX_TRANSFORMPROPDLG_H__E703BE7D_6CF3_45E4_A27F_4CC0E1890631__INCLUDED_)
#define AFX_TRANSFORMPROPDLG_H__E703BE7D_6CF3_45E4_A27F_4CC0E1890631__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TransformPropDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTransformPropDlg dialog

class CTransformPropDlg : public CDialog
{
// Construction
public:
	CTransformPropDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CTransformPropDlg)
	enum { IDD = IDD_TRANSFORM_PROPERTIES };
	CButton	m_btnValGreater;
	CButton	m_btnValLess;
	CButton	m_btnValEqual;
	CButton	m_btnMajor;
	CButton	m_btnMinor;
	CButton	m_btnUpdate;
	CWnd 	m_ctrlVerStatic1;
	CWnd 	m_ctrlVerStatic2;
	CWnd 	m_ctrlVerStatic3;
	CWnd 	m_ctrlVerStatic4;
	BOOL	m_bValAddExistingRow;
	BOOL	m_bValAddExistingTable;
	BOOL	m_bValChangeCodepage;
	BOOL	m_bValDelMissingRow;
	BOOL	m_bValDelMissingTable;
	BOOL	m_bValUpdateMissingRow;
	BOOL	m_bValLanguage;
	BOOL	m_bValProductCode;
	BOOL	m_bValUpgradeCode;
	int		m_iVersionCheck;
	BOOL	m_bValGreaterVersion;
	BOOL	m_bValLowerVersion;
	BOOL	m_bValEqualVersion;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTransformPropDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTransformPropDlg)
	afx_msg void OnValGreater();
	afx_msg void OnValLess();
	afx_msg void OnValEqual();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void EnableVersionRadioButtons();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TRANSFORMPROPDLG_H__E703BE7D_6CF3_45E4_A27F_4CC0E1890631__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\vald.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// ValD.cpp : implementation file
//

#include "stdafx.h"
#include "Orca.h"

#include <initguid.h>
#include "ValD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CValD dialog

bool InitCUBCombo(CComboBox* pBox, CString strDefault);
bool FreeCUBCombo(CComboBox* pBox);

CValD::CValD(CWnd* pParent /*=NULL*/)
	: CDialog(CValD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CValD)
	m_strICE = "";
	m_bShowInfo = FALSE;
	//}}AFX_DATA_INIT

	m_pIResults = NULL;
	m_cResults = 0;
}

CValD::~CValD()
{
	// if there were any results retrieved release them
	if (m_pIResults)
		m_pIResults->Release();
}

void CValD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CValD)
	DDX_Control(pDX, IDC_EVALUATION_FILE, m_ctrlCUBFile);
	DDX_Control(pDX, IDC_OUTPUT, m_ctrlOutput);
	DDX_Control(pDX, IDC_GO, m_ctrlGo);
	DDX_Text(pDX, IDC_ICES, m_strICE);
	DDX_Check(pDX, IDC_SHOW_INFO, m_bShowInfo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CValD, CDialog)
	//{{AFX_MSG_MAP(CValD)
	ON_BN_CLICKED(IDC_GO, OnGo)
	ON_WM_DESTROY()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_OUTPUT, OnColumnclickOutput)
	ON_BN_CLICKED(IDC_SHOW_INFO, OnShowInfo)
	ON_BN_CLICKED(IDC_CLIPBOARD, OnClipboard)
	ON_CBN_EDITCHANGE(IDC_EVALUATION_FILE, OnCUBEditChange)
	ON_CBN_SELCHANGE(IDC_EVALUATION_FILE, OnCUBSelChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CValD message handlers

#ifdef _WIN64
static const TCHAR CUB_QUALIFIED_GUID[] = TEXT("{17C2BAD5-F32B-4A0D-B5E1-813FF88DA1C5}");
#else
static const TCHAR CUB_QUALIFIED_GUID[] = TEXT("{DC441E1D-3ECB-4DCF-B0A5-791F9C0F4F5B}");
#endif

BOOL CValD::OnInitDialog() 
{
	CDialog::OnInitDialog();

	CSingleLock lkUILock(&m_mtxDisplay);
	lkUILock.Lock();

	CListCtrl* pList = (CListCtrl*)GetDlgItem(IDC_OUTPUT);
	pList->SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES);

	// add the table list
	RECT rcSize;
	pList->GetWindowRect(&rcSize);
	pList->InsertColumn(0, _T("ICE"), LVCFMT_LEFT, 50);
	pList->InsertColumn(1, _T("Type"), LVCFMT_LEFT, 50);
	pList->InsertColumn(2, _T("Description"), LVCFMT_LEFT, rcSize.right - 100 - rcSize.left - 4);
	m_bShowWarn = ::AfxGetApp()->GetProfileInt(_T("Validation"), _T("SuppressWarn"), 0) != 1;

	// init the CUB file combo box
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_EVALUATION_FILE);

	InitCUBCombo(pBox, m_strEvaluation);
	UpdateData(FALSE);
	m_iSortColumn = 99999;
	if (m_ctrlCUBFile.GetCount() == 0)
	{
		CString strText;
		m_ctrlCUBFile.GetWindowText(strText);
		if (strText.IsEmpty())
			m_ctrlGo.EnableWindow(FALSE);
	}
	SetDefID(IDC_GO);	// set the default button to the GO button in the beginning

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CValD::OnGo() 
{
	HRESULT hResult;

	// clear results
	if (AfxGetApp()->GetProfileInt(_T("Validation"),_T("ClearResults"), 1))
	{
		CSingleLock lkUILock(&m_mtxDisplay);
		lkUILock.Lock();
		m_ctrlOutput.DeleteAllItems();
	}

	// get the path to the cub file. If a qualified component was used, call Darwin to get the path
	// otherwise, the path is explicitly provided
	CString strCUBFile;
	int iIndex = m_ctrlCUBFile.GetCurSel();
	if (CB_ERR == iIndex)
	{
		// no qualified component was chosen, explicit path
		m_ctrlCUBFile.GetWindowText(strCUBFile);
		m_strEvaluation = strCUBFile;
	}
	else
	{
		// qualified component was chosen. Get the component path (try to repair if necessary).
		DWORD cchCUBFile = MAX_PATH;
		TCHAR *szCUBFile = strCUBFile.GetBuffer(cchCUBFile);
		TCHAR *szQualifier = static_cast<TCHAR*>(m_ctrlCUBFile.GetItemDataPtr(iIndex));
		UINT iStat = MsiProvideQualifiedComponent(CUB_QUALIFIED_GUID, szQualifier, INSTALLMODE_DEFAULT,
			szCUBFile, &cchCUBFile);
		strCUBFile.ReleaseBuffer();
		if (ERROR_SUCCESS != iStat)
		{
			// could not find or install the CUB File
			AfxMessageBox(_T("Error: The Validation Suite you selected could not be found, and Orca could not repair the problem."), MB_ICONSTOP);
			return;
		}
		m_strEvaluation = TEXT(":");
		m_strEvaluation += szQualifier;
	}
	
	// create an EvalCom object
	IEval* pIEval;
	hResult = ::CoCreateInstance(CLSID_EvalCom, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
											  IID_IEval, (void**)&pIEval);

	// if failed to create the object
	if (FAILED(hResult))
	{
		GetDlgItem(IDC_GO)->EnableWindow(FALSE);
		AfxMessageBox(_T("Error: Failed to instantiate EvalCom Object.\n\n"), MB_ICONSTOP);
		return;	// bail
	}
	else	// rock and roll
	{
		// disable controls
		GetDlgItem(IDC_GO)->EnableWindow(FALSE);
		GetDlgItem(IDC_CLIPBOARD)->EnableWindow(FALSE);
		GetDlgItem(IDOK)->EnableWindow(FALSE);
		CMenu *pSysMenu = GetSystemMenu(FALSE);
		pSysMenu->EnableMenuItem(SC_CLOSE, MF_GRAYED | MF_BYCOMMAND);

		CWaitCursor cursorWait;

		// open the database
		WCHAR szwBuffer[16];
		swprintf(szwBuffer, L"#%d", m_hDatabase);
		hResult = pIEval->OpenDatabase(szwBuffer);
		if (FAILED(hResult))
		{
			AfxMessageBox(_T("Error: Failed to open database.\n\n"), MB_ICONSTOP);
		}
		else
		{
			UpdateData(TRUE);	// update the evaluation file

			WCHAR szwEvaluations[1024];
#ifndef UNICODE
			DWORD cchBuffer;
			cchBuffer = ::MultiByteToWideChar(CP_ACP, 0, strCUBFile, -1, NULL, 0);
			::MultiByteToWideChar(CP_ACP, 0, strCUBFile, -1, szwEvaluations, cchBuffer);
#else
			wcscpy(szwEvaluations, strCUBFile);
#endif

			// open the evaluations
			hResult = pIEval->OpenEvaluations(szwEvaluations);
			if (FAILED(hResult))
			{
				AfxMessageBox(_T("Error: Failed to open evaluation file.\n\n"), MB_ICONSTOP);
			}
			else
			{
				pIEval->SetDisplay(DisplayFunction, this);
				WCHAR szwICEs[1024];
				
#ifndef UNICODE
				cchBuffer = ::MultiByteToWideChar(CP_ACP, 0, m_strICE, -1, NULL, 0);
				::MultiByteToWideChar(CP_ACP, 0, m_strICE, -1, szwICEs, cchBuffer);
#else
				wcscpy(szwICEs, m_strICE);
#endif
				
				hResult = pIEval->Evaluate((*szwICEs == L'\0') ? NULL : szwICEs);
				if(FAILED(hResult))
					AfxMessageBox(_T("Failed to run all of the evaluations.\r\n"), MB_ICONINFORMATION);

				pIEval->CloseEvaluations();
			}
		}			

		// get any results
		pIEval->GetResults(&m_pIResults, &m_cResults);

		// release the object
		pIEval->Release();

		// re-enable buttons/menu
		pSysMenu->EnableMenuItem(SC_CLOSE, MF_ENABLED | MF_BYCOMMAND);
		GetDlgItem(IDC_GO)->EnableWindow(TRUE);
		GetDlgItem(IDOK)->EnableWindow(TRUE);
		GetDlgItem(IDC_CLIPBOARD)->EnableWindow(m_ctrlOutput.GetItemCount() > 0);
	}

	m_iSortColumn = 99999;

	GotoDlgCtrl(GetDlgItem(IDOK));
	SetDefID(IDOK);	// set the default button to OK now
	AfxMessageBox(_T("Validations complete."));
}

///////////////////////////////////////////////////////////
// DisplayFunction
// pre:	called from Evaluation COM Object
// pos:	displays output from COM Object
BOOL WINAPI DisplayFunction(LPVOID pContext, UINT uiType, LPCWSTR szwVal, LPCWSTR szwDescription, LPCWSTR szwLocation)
{
	// try to change the context into a validation dialog box
	CValD* pDlg = (CValD*)pContext;

	if (ieInfo == uiType && !pDlg->m_bShowInfo)
		 return TRUE;
	if (ieWarning == uiType && !pDlg->m_bShowWarn)
		 return TRUE;
	
	// set the type correctly
	LPTSTR szType;
	switch (uiType)
	{
	case ieError:
		szType = _T("ERROR");
		break;
	case ieWarning:
		szType = _T("WARNING");
		break;
	case ieInfo:
		szType = _T("INFO");
		break;
	case ieUnknown:
		szType = _T("FAIL");
		break;
	default:
		szType = _T("UNKNOWN");
		break;
	}

	CString strICE;
#ifndef _UNICODE
	int cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, szwVal, -1, NULL, 0, NULL, NULL);
	::WideCharToMultiByte(CP_ACP, 0, szwVal, -1, strICE.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
	strICE.ReleaseBuffer();
#else
	strICE = szwVal;
#endif

	CString strDescription;
#ifndef _UNICODE
	cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, szwDescription, -1, NULL, 0, NULL, NULL);
	::WideCharToMultiByte(CP_ACP, 0, szwDescription, -1, strDescription.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
	strDescription.ReleaseBuffer();
#else
	strDescription = szwDescription;
#endif

	TRACE(_T("%s\t%s\t%s\n"), strICE, szType, strDescription);
	
	// add line to list control
	int nAddedAt;

	CSingleLock lkUILock(&(pDlg->m_mtxDisplay));
	lkUILock.Lock();

	nAddedAt = pDlg->m_ctrlOutput.InsertItem(LVIF_TEXT, pDlg->m_ctrlOutput.GetItemCount(),
										  strICE, 0, 0, 0, NULL);
	pDlg->m_ctrlOutput.SetItem(nAddedAt, 1, LVIF_TEXT, szType, 0, 0, 0, 0);
	pDlg->m_ctrlOutput.SetItem(nAddedAt, 2, LVIF_TEXT, strDescription, 0, 0, 0, 0);
	pDlg->m_ctrlOutput.SetItemData(nAddedAt, nAddedAt);
	lkUILock.Unlock();

	return FALSE;
}

void CValD::OnColumnclickOutput(NMHDR* pNMHDR, LRESULT* pResult) 
{
	CWaitCursor curWait;

	CSingleLock lkUILock(&m_mtxDisplay);
	lkUILock.Lock();

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	// set the lparam values of each item to the item number
	int iMaxItem = m_ctrlOutput.GetItemCount();
	for (int i=0; i < iMaxItem; i++) 
		m_ctrlOutput.SetItemData(i, i);

	// column numbers are offset by 1 (so that column 0 can be 
	// sorted in either order.)
	int iNewSortColumn = pNMListView->iSubItem+1;
	if (iNewSortColumn == m_iSortColumn) 
		m_iSortColumn = -m_iSortColumn;
	else
		m_iSortColumn = iNewSortColumn;

	// now sort since the column bit is set
	m_ctrlOutput.SortItems(CValD::SortOutput, reinterpret_cast<ULONG_PTR>(this));
	*pResult = 0;
	lkUILock.Unlock();
}

//////////////////////////////////////////////////////////
// SortView
int CALLBACK CValD::SortOutput(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	CValD *pThis = reinterpret_cast<CValD *>(lParamSort);

	// get the data
	int iCol = pThis->m_iSortColumn < 0 ? -pThis->m_iSortColumn : pThis->m_iSortColumn;

	CString str1 = pThis->m_ctrlOutput.GetItemText(static_cast<int>(lParam1), iCol-1);
	CString str2 = pThis->m_ctrlOutput.GetItemText(static_cast<int>(lParam2), iCol-1);

	return (pThis->m_iSortColumn > 0) ? str1.Compare(str2) : -str1.Compare(str2);
}	// end of SortView

void CValD::OnShowInfo() 
{
	// TODO: Add your control notification handler code here
	m_bShowInfo = (static_cast<CButton *>(GetDlgItem(IDC_SHOW_INFO))->GetCheck() == 1);
}

void CValD::OnClipboard() 
{
	CWaitCursor curWait;

	CSingleLock lkUILock(&m_mtxDisplay);
	lkUILock.Lock();
	CString strItem;

	// loop over all items in the listview control
	int cItems = m_ctrlOutput.GetItemCount();
	for (int i=0; i < cItems; i++) 
	{
		strItem += m_ctrlOutput.GetItemText(i, 0);
		strItem += _T("\t");
		strItem += m_ctrlOutput.GetItemText(i, 1);
		strItem += _T("\t");
		strItem += m_ctrlOutput.GetItemText(i, 2);
		strItem += _T("\r\n");
	}
	lkUILock.Unlock();

	if (0 != OpenClipboard())
	{
		::EmptyClipboard();
		
		// allocate memory for the string on the clipboard (+ 1 for null)
		DWORD cchString = (strItem.GetLength()+1)*sizeof(TCHAR);
		HANDLE hString = ::GlobalAlloc(GHND|GMEM_DDESHARE, cchString);

		LPTSTR szString = (LPTSTR)::GlobalLock(hString);
		_tcscpy(szString, strItem);
		::GlobalUnlock(hString);

		// open and clear clipboard
#ifdef _UNICODE
		::SetClipboardData(CF_UNICODETEXT, hString);
#else
		::SetClipboardData(CF_TEXT, hString);
#endif

		// release held objects
		CloseClipboard();
	}
}


void CValD::OnDestroy() 
{
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_EVALUATION_FILE);
	FreeCUBCombo(pBox);
	CDialog::OnDestroy();
}
 

////
// disable the "go" button any time the CUB file edit box becomes empty. Enable it if the
// edit box is not empty or an item is selected
void CValD::OnCUBEditChange( )
{
	CString strCUBFile;
	m_ctrlCUBFile.GetWindowText(strCUBFile);
	m_ctrlGo.EnableWindow(!strCUBFile.IsEmpty());
}

void CValD::OnCUBSelChange( )
{
	m_ctrlGo.EnableWindow(TRUE);
}

bool InitCUBCombo(CComboBox* pBox, CString strDefault)
{
	bool fSuccess = true;
	bool fDefaultQualifier = (strDefault[0] == TEXT(':'));
	if (fDefaultQualifier)
		strDefault = strDefault.Right(strDefault.GetLength()-1);
	else
		pBox->SetWindowText(strDefault);
			
	int iCompNum = 0;
	for (iCompNum = 0; true ; iCompNum++)
	{
		DWORD cchQualifier = 72;
		DWORD cchText = 128;
		TCHAR *szQualifier = new TCHAR[cchQualifier];
		CString strText;
		TCHAR *szText = strText.GetBuffer(cchText);
		
		UINT iStat = MsiEnumComponentQualifiers(CUB_QUALIFIED_GUID, iCompNum, szQualifier, &cchQualifier, szText, &cchText);

		if (ERROR_NO_MORE_ITEMS == iStat)
		{
			delete[] szQualifier;
			break;
		}
		
		if (ERROR_MORE_DATA == iStat)
		{
			delete[] szQualifier;
			szQualifier = new TCHAR[++cchQualifier];
			strText.ReleaseBuffer();
			szText = strText.GetBuffer(++cchText);
			iStat = MsiEnumComponentQualifiers(CUB_QUALIFIED_GUID, iCompNum, 
				szQualifier, &cchQualifier, szText, &cchText);
		}		
		strText.ReleaseBuffer();

		if (ERROR_SUCCESS == iStat)
		{			
			int iIndex = pBox->AddString(strText);
			if (CB_ERR != iIndex)
			{
				pBox->SetItemDataPtr(iIndex, szQualifier);
				if (fDefaultQualifier && 0==_tcscmp(strDefault, szQualifier))
				{
					pBox->SetCurSel(iIndex);
				}
			}
		}
		// API not guaranteed to return ERROR_NO_MORE_ITEMS in all cases
		// can continue with ERROR_BAD_CONFIGURATION
		else if (ERROR_BAD_CONFIGURATION != iStat)
			break; // break on all other errors (UNKNOWN_COMPONENT, INVALID_PARAMETER, etc.)
	}

	if (strDefault.IsEmpty() && pBox->GetCount() > 0)
		pBox->SetCurSel(0);

	return fSuccess;
}

bool FreeCUBCombo(CComboBox* pBox)
{
	for (int i=0; i < pBox->GetCount(); i++)
	{
		void *szTemp = pBox->GetItemDataPtr(i);
		if (szTemp)
			delete[] szTemp;
		pBox->SetItemDataPtr(i, NULL);
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\valpp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// ValPage.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "ValPP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CValPropPage property page

IMPLEMENT_DYNCREATE(CValPropPage, CPropertyPage)

CValPropPage::CValPropPage() : CPropertyPage(CValPropPage::IDD)
{
	//{{AFX_DATA_INIT(CValPropPage)
	m_strICEs = _T("");
	m_bSuppressInfo = FALSE;
	m_bSuppressWarn = FALSE;
	m_bClearResults = FALSE;
	//}}AFX_DATA_INIT
	m_bValChange = false;
}

CValPropPage::~CValPropPage()
{
}

extern bool InitCUBCombo(CComboBox *pBox, CString strDefault);
extern bool FreeCUBCombo(CComboBox *pBox);

void CValPropPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CValPropPage)
	DDX_Text(pDX, IDC_RUNICE, m_strICEs);
	DDX_Check(pDX, IDC_SUPPRESSINFO, m_bSuppressInfo);
	DDX_Check(pDX, IDC_SUPPRESSWARNING, m_bSuppressWarn);
	DDX_Control(pDX, IDC_VALDIR, m_ctrlCUBFile);
	DDX_Check(pDX, IDC_CLEARRESULTS, m_bClearResults);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CValPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CValPropPage)
	ON_WM_DESTROY()
	ON_EN_CHANGE(IDC_RUNICE, OnChange)
	ON_BN_CLICKED(IDC_SUPPRESSINFO, OnChange)
	ON_BN_CLICKED(IDC_SUPPRESSWARNING, OnChange)
	ON_CBN_SELCHANGE(IDC_VALDIR, OnChange)
	ON_CBN_EDITCHANGE(IDC_VALDIR, OnChange)
	ON_BN_CLICKED(IDC_WARNSUMM, OnChange)
	ON_BN_CLICKED(IDC_CLEARRESULTS, OnChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CValPropPage message handlers

void CValPropPage::OnChange() 
{
	m_bValChange = true;
}

BOOL CValPropPage::OnInitDialog() 
{
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_VALDIR);
	InitCUBCombo(pBox, m_strCUBFile);
	return TRUE;  
}

BOOL CValPropPage::OnKillActive() 
{
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_VALDIR);
	int iIndex = pBox->GetCurSel();
	if (CB_ERR == iIndex)
	{
		// no qualified component was chosen, explicit path
		pBox->GetWindowText(m_strCUBFile);
	}
	else
	{
		// qualified component was chosen. Get the qualifier
		DWORD cchCUBFile = MAX_PATH;
		TCHAR *szQualifier = static_cast<TCHAR*>(pBox->GetItemDataPtr(iIndex));
		m_strCUBFile = TEXT(":");
		m_strCUBFile += szQualifier;
	}
	return CPropertyPage::OnKillActive();
}

void CValPropPage::OnDestroy() 
{
	FreeCUBCombo(&m_ctrlCUBFile);
	CWnd::OnDestroy();
}


IMPLEMENT_DYNCREATE(CMsmPropPage, CPropertyPage)

CMsmPropPage::CMsmPropPage() : CPropertyPage(CMsmPropPage::IDD)
{
	//{{AFX_DATA_INIT(CMsmPropPage)
	m_iMemoryCount = 3;
	m_bWatchLog = FALSE;
	m_bAlwaysConfig = FALSE;
	//}}AFX_DATA_INIT
	m_bMSMChange = false;
}

CMsmPropPage::~CMsmPropPage()
{
}

void CMsmPropPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMsmPropPage)
	DDX_Text(pDX, IDC_MEMORY, m_iMemoryCount);
	DDX_Check(pDX, IDC_WATCHLOG, m_bWatchLog);
	DDX_Check(pDX, IDC_ALWAYSCONFIG, m_bAlwaysConfig);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMsmPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CMsmPropPage)
	ON_EN_CHANGE(IDC_MEMORY, OnChange)
	ON_BN_CLICKED(IDC_WATCHLOG, OnChange)
	ON_BN_CLICKED(IDC_ALWAYSCONFIG, OnChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CMsmPropPage::OnChange() 
{
	m_bMSMChange = true;
}


BOOL CMsmPropPage::OnInitDialog() 
{
	// can't watch the merge log on Win9X due to lack of pipe support.
	OSVERSIONINFOA osviVersion;
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
	::GetVersionExA(&osviVersion); // fails only if size set wrong
	if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
	{
		CButton* pCheck = (CButton*)GetDlgItem(IDC_WATCHLOG);
		if (pCheck)
			pCheck->EnableWindow(FALSE);
	}
	UpdateData(FALSE);
	return TRUE;
}
	
///////////////////////////////////////////////////////////////////////
// property sheet page for transform options

IMPLEMENT_DYNCREATE(CTransformPropPage, CPropertyPage)

CTransformPropPage::CTransformPropPage() : CPropertyPage(CTransformPropPage::IDD)
{
	//{{AFX_DATA_INIT(CTransformPropPage)
	m_iValidationOptions = 0;
	m_iErrorOptions = 0;
	//}}AFX_DATA_INIT
	m_bTransformChange = false;
}

CTransformPropPage::~CTransformPropPage()
{
}

void CTransformPropPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTransformPropPage)
	DDX_Radio(pDX, IDC_TRANSVALIGNORE, m_iValidationOptions);
	DDX_Radio(pDX, IDC_IGNOREERRORS, m_iErrorOptions);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTransformPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CTransformPropPage)
	ON_BN_CLICKED(IDC_TRANSVALRESPECT, OnChange)
	ON_BN_CLICKED(IDC_TRANSVALPROMPT, OnChange)
	ON_BN_CLICKED(IDC_TRANSVALIGNORE, OnChange)
	ON_BN_CLICKED(IDC_RESPECTERRORS, OnChange)
	ON_BN_CLICKED(IDC_IGNOREERRORS, OnChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CTransformPropPage::OnChange() 
{
	m_bTransformChange = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\valpane.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_VALPANE_H__AB9A409F_2658_11D2_8889_00A0C981B015__INCLUDED_)
#define AFX_VALPANE_H__AB9A409F_2658_11D2_8889_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
//

#include "stdafx.h"
#include "orca.h"
#include "table.h"
#include "row.h"
#include "iface.h"

/////////////////////////////////////////////////////////////////////////////
// CPagePaths dialog

class CValidationPane : public CListView
{
	DECLARE_DYNCREATE(CValidationPane)

// Construction
public:
	CValidationPane();
	~CValidationPane();

// Implementation
public:
	virtual void SwitchFont(CString name, int size);
	void GetFontInfo(LOGFONT *data);

	static int CALLBACK SortView(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

	
protected:
	virtual void OnInitialUpdate();
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	
	//{{AFX_MSG(COrcaListView)
	afx_msg void OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy( );
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	bool SwitchViewToRowTarget(int iItem);
	void ClearAllValidationErrors();

	CFont* m_pfDisplayFont;
	int m_nSelRow;
	bool m_fSendNotifications;
};


class CValidationError : public CObject
{
public:
	CValidationError(const CString* strICE, RESULTTYPES eiType, const CString* strDescription, const COrcaTable* pTable, const COrcaRow* pRow, int strColumn);
	~CValidationError();

	CString*    m_pstrICE;
	RESULTTYPES m_eiType;
	CString*    m_pstrDescription;

	const COrcaTable* m_pTable;
	const COrcaRow*   m_pRow;
	int m_iColumn;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\vald.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_VALD_H__EEDCAAA4_F4EC_11D1_A85A_006097ABDE17__INCLUDED_)
#define AFX_VALD_H__EEDCAAA4_F4EC_11D1_A85A_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ValD.h : header file
//

#include "iface.h"
#include "msiquery.h"
#include <afxmt.h>

/////////////////////////////////////////////////////////////////////////////
// CValD dialog

class CValD : public CDialog
{
// Construction
public:
	CMutex m_mtxDisplay;
	CValD(CWnd* pParent = NULL);   // standard constructor
	~CValD();

// Dialog Data
	//{{AFX_DATA(CValD)
	enum { IDD = IDD_VALIDATION };
	CComboBox	m_ctrlCUBFile;
	CListCtrl	m_ctrlOutput;
	CButton     m_ctrlGo;
	CString	m_strEvaluation;
	CString	m_strICE;
	BOOL	m_bShowInfo;
	//}}AFX_DATA

	MSIHANDLE m_hDatabase;
	IEnumEvalResult* m_pIResults;
	ULONG m_cResults;
	bool m_bShowWarn;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CValD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	friend BOOL WINAPI DisplayFunction(LPVOID pContext, UINT uiType, LPCWSTR szwVal, LPCWSTR szwDescription, LPCWSTR szwLocation);
// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CValD)
	virtual BOOL OnInitDialog();
	afx_msg void OnGo();
	afx_msg void OnColumnclickOutput(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnShowInfo();
	afx_msg void OnClipboard();
	afx_msg void OnDestroy();
    afx_msg void OnCUBEditChange( );
    afx_msg void OnCUBSelChange( );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	int m_iSortColumn;
	static int CALLBACK SortOutput(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VALD_H__EEDCAAA4_F4EC_11D1_A85A_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\valpane.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// PagePaths.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "Valpane.h"
#include "orcadoc.h"
#include "mainfrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CValidationPane property page

IMPLEMENT_DYNCREATE(CValidationPane, CListView)

CValidationPane::CValidationPane() : CListView()
{
	m_pfDisplayFont = NULL;
	m_nSelRow = -1;
	m_fSendNotifications = false;
}

CValidationPane::~CValidationPane()
{
}

BEGIN_MESSAGE_MAP(CValidationPane, CListView)
	//{{AFX_MSG_MAP(CValidationPane)
	ON_WM_CREATE()
	ON_WM_CHAR()
	ON_WM_DESTROY()
	ON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnItemChanged)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnclick)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CValidationPane message handlers
int CValidationPane::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CListView::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	CString strFacename = ::AfxGetApp()->GetProfileString(_T("Font"), _T("Name"));
	int iFontSize = ::AfxGetApp()->GetProfileInt(_T("Font"),_T("Size"), 0);
	if (strFacename.IsEmpty() || iFontSize == 0) 
	{
		m_pfDisplayFont = NULL;
	} 
	else
	{
		m_pfDisplayFont = new CFont();
		m_pfDisplayFont->CreatePointFont( iFontSize, strFacename);
	}
	return 0;
}


BOOL CValidationPane::PreCreateWindow(CREATESTRUCT& cs) 
{												   
	cs.style = (cs.style | LVS_REPORT | LVS_SHOWSELALWAYS | LVS_SINGLESEL) & ~LVS_ICON;
	return CListView::PreCreateWindow(cs);
}


void CValidationPane::SwitchFont(CString name, int size)
{
	if (m_pfDisplayFont)
		delete m_pfDisplayFont;
	m_pfDisplayFont = new CFont();
	int iLogicalUnits = MulDiv(size, GetDC()->GetDeviceCaps(LOGPIXELSY), 720);
	m_pfDisplayFont->CreateFont(
		-iLogicalUnits,       // logical height of font 
 		0,                  // logical average character width 
 		0,                  // angle of escapement 
 		0,                  // base-line orientation angle 
 		FW_NORMAL,          // FW_DONTCARE??, font weight 
 		0,                  // italic attribute flag 
 		0,                  // underline attribute flag 
	 	0,                  // strikeout attribute flag 
 		0,                  // character set identifier
 		OUT_DEFAULT_PRECIS, // output precision
 		0x40,               // clipping precision (force Font Association off)
 		DEFAULT_QUALITY,    // output quality
 		DEFAULT_PITCH,      // pitch and family
		name);              // pointer to typeface name string

	RedrawWindow();

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	rctrlList.SetFont(m_pfDisplayFont, TRUE);
	HWND hHeader = ListView_GetHeader(rctrlList.m_hWnd);

	// win95 gold fails ListView_GetHeader.
	if (hHeader)
	{
		::PostMessage(hHeader, WM_SETFONT, (UINT_PTR)HFONT(*m_pfDisplayFont), 1);
	}
};



///////////////////////////////////////////////////////////
// OnUpdate
void CValidationPane::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	// if this is the sender window, nothing to do
	if (this == pSender)
		return;

	CListCtrl& rctrlList = GetListCtrl();
	switch (lHint) {
	case HINT_DROP_TABLE:
	{
		COrcaTable* pTable = static_cast<COrcaTable*>(pHint);

		// turn off notifications, as deletions may change the selected item and
		// the table may already be gone
		m_fSendNotifications = false;

		for (int iItem=0; iItem < rctrlList.GetItemCount(); )
		{
			CValidationError* pError = reinterpret_cast<CValidationError*>(rctrlList.GetItemData(iItem));
			if (pError && pError->m_pTable == pTable)
			{
				// delete the item, do NOT increment iItem because we just shifted the next item
				// into this slot.
				rctrlList.DeleteItem(iItem);
			}
			else
				iItem++;
		}

		// re-enable item selections
		m_fSendNotifications = true;

		break;
	}
	case HINT_DROP_ROW:
	{
		// pHint may be freed memory already. DO NOT dereference it within
		// this block!
		COrcaRow* pRow = static_cast<COrcaRow*>(pHint);

		// turn off notifications, as deletions may change the selected item and
		// the table may already be gone
		m_fSendNotifications = false;

		for (int iItem=0; iItem < rctrlList.GetItemCount(); )
		{
			CValidationError* pError = reinterpret_cast<CValidationError*>(rctrlList.GetItemData(iItem));
			if (pError && pError->m_pRow == pRow)
			{
				// delete the item, do NOT increment iItem because we just shifted the next item
				// into this slot.
				rctrlList.DeleteItem(iItem);
			}
			else
				iItem++;
		}

		// re-enable item selections
		m_fSendNotifications = true;

		break;
	}
	case HINT_CLEAR_VALIDATION_ERRORS:
	{
		ClearAllValidationErrors();
		break;
	}
	case HINT_ADD_VALIDATION_ERROR:
	{
		CValidationError* pError = static_cast<CValidationError*>(pHint);
		if (pError && pError->m_pstrICE)
		{
			CValidationError* pNewError = new CValidationError(NULL, pError->m_eiType, NULL, pError->m_pTable, pError->m_pRow, pError->m_iColumn);
			int iItem = rctrlList.InsertItem(LVIF_TEXT | LVIF_PARAM, rctrlList.GetItemCount(), static_cast<LPCTSTR>(*pError->m_pstrICE), 0, 0, 0, reinterpret_cast<LPARAM>(pNewError));

			switch (pError->m_eiType)
			{
			case ieError:
				rctrlList.SetItemText(iItem, 1, TEXT("Error"));
				break;
			case ieWarning:
				rctrlList.SetItemText(iItem, 1, TEXT("Warning"));
				break;
			case ieInfo:
				// should never happen.
				rctrlList.SetItemText(iItem, 1, TEXT("Info"));
				break;
			default:
				rctrlList.SetItemText(iItem, 1, TEXT("ICE Failure"));
				break;
			}
			rctrlList.SetItemText(iItem, 2, static_cast<LPCTSTR>(*pError->m_pstrDescription));
		}
		// size only on first error
		if (rctrlList.GetItemCount() == 1)
		{
			rctrlList.SetColumnWidth(0, LVSCW_AUTOSIZE);
			rctrlList.SetColumnWidth(1, LVSCW_AUTOSIZE);
			rctrlList.SetColumnWidth(2, LVSCW_AUTOSIZE_USEHEADER);
		}

		break;
	}
	default:
		break;
	}
}	// end of OnUpdate


void CValidationPane::GetFontInfo(LOGFONT *data)
{
	ASSERT(data);
	if (m_pfDisplayFont)
		m_pfDisplayFont->GetLogFont(data);
	else
		GetListCtrl().GetFont()->GetLogFont(data);
}


///////////////////////////////////////////////////////////////////////
// initial update sets the list view styles and prepares the columns
// for the control
void CValidationPane::OnInitialUpdate() 
{
	CListView::OnInitialUpdate();
	
	CListCtrl& rctrlErrorList = GetListCtrl();

   	// empty any previous columns
	while (rctrlErrorList.DeleteColumn(0))
		;

	// add gridlines and full row select
	rctrlErrorList.SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES);
	rctrlErrorList.InsertColumn(0, TEXT("ICE"), LVCFMT_LEFT, -1, 0);
	rctrlErrorList.InsertColumn(1, TEXT("Type"), LVCFMT_LEFT, -1, 1);
	rctrlErrorList.InsertColumn(2, TEXT("Description"), LVCFMT_LEFT, -1, 2);
	rctrlErrorList.SetFont(m_pfDisplayFont);
	rctrlErrorList.SetColumnWidth(0, LVSCW_AUTOSIZE_USEHEADER);
	rctrlErrorList.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);
	rctrlErrorList.SetColumnWidth(2, LVSCW_AUTOSIZE_USEHEADER);
	m_fSendNotifications = true;
	m_nSelRow = -1;
}

///////////////////////////////////////////////////////////////////////
// on destruction, be sure to release any validation error structures 
// managed by the list control
void CValidationPane::OnDestroy( )
{
	ClearAllValidationErrors();
	m_fSendNotifications = false;
}

///////////////////////////////////////////////////////////////////////
// on destruction, be sure to release any validation error structures 
// managed by the list control
void CValidationPane::ClearAllValidationErrors()
{
	// turn off notifications so that deleting the items won't cause the other window
	// to jump all over the place as the items are deleted.
	m_fSendNotifications = false;

	CListCtrl& rctrlErrorList = GetListCtrl();

   	// empty out any items, deleting validation target information as we go 
	while (rctrlErrorList.GetItemCount())
	{
		CValidationError* pError = reinterpret_cast<CValidationError*>(rctrlErrorList.GetItemData(0));
		if (pError)
			delete pError;
		rctrlErrorList.DeleteItem(0);
	}

	// reactivate notifications
	m_fSendNotifications = true;
}


///////////////////////////////////////////////////////////////////////
// send the hints to the rest of the windows to switch to the table
// and row indicated by the error.
bool CValidationPane::SwitchViewToRowTarget(int iItem) 
{
	if (iItem == -1)
		return true;

	if (!m_fSendNotifications)
		return true;

	CWaitCursor cursorWait;

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get the document
	CDocument* pDoc = GetDocument();
	CValidationError* pError = reinterpret_cast<CValidationError*>(rctrlList.GetItemData(iItem)); 
	
	// set the focus as specifically as we can
	if (pError->m_pTable)
	{
		pDoc->UpdateAllViews(this, HINT_CHANGE_TABLE, const_cast<COrcaTable*>(pError->m_pTable));
		if (pError->m_pRow)
		{
			pDoc->UpdateAllViews(this, HINT_SET_ROW_FOCUS, const_cast<COrcaRow*>(pError->m_pRow));
			if (pError->m_iColumn >= 0)
				pDoc->UpdateAllViews(this, HINT_SET_COL_FOCUS, reinterpret_cast<CObject*>(static_cast<INT_PTR>(pError->m_iColumn)));
		}
	}

	return true;
}

///////////////////////////////////////////////////////////////////////
// when the selected item changes, force the table list and view to 
// switch to that exact location
void CValidationPane::OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	if (pNMListView->uNewState & LVIS_FOCUSED)
	{
		m_nSelRow = pNMListView->iItem;
		SwitchViewToRowTarget(m_nSelRow);
	}
	*pResult = 0;
}


void CValidationPane::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// the view of the main pane should already have been switched by the first click
	// so no need to reset the view

	// this relies on the window tree staying in the same form
	CSplitterWnd* pSplitter = static_cast<CSplitterWnd*>(GetParent());
	CSplitterView* pDatabaseView = static_cast<CSplitterView*>(pSplitter->GetPane(0,0));
	CWnd* pTableView = pDatabaseView->m_wndSplitter.GetPane(0,1);
	pTableView->SetFocus();
}


struct SortData {
	int iColumn;
	CListCtrl* pCtrl;
};

///////////////////////////////////////////////////////////
// when a column is clicked, sort on that column
void CValidationPane::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	// set the param with the column in it (the highest bit sets the column type)
	SortData SD = { pNMListView->iSubItem, &GetListCtrl() };
	LPARAM lParam = reinterpret_cast<LPARAM>(&SD);
	
	// now sort since the column bit is set
	GetListCtrl().SortItems(SortView, lParam);

	*pResult = 0;	
}


///////////////////////////////////////////////////////////
// SortView
int CALLBACK CValidationPane::SortView(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	SortData* pSD = (SortData*)lParamSort;

	LVFINDINFO fi;
	fi.flags = LVFI_PARAM;
	fi.psz = NULL;
	fi.lParam = lParam1;
	fi.pt.x = 0;
	fi.pt.y = 0;
	fi.vkDirection = 0;
	int iItem1 = pSD->pCtrl->FindItem(&fi, -1);

	fi.lParam = lParam2;
	int iItem2 = pSD->pCtrl->FindItem(&fi, -1);

	CString strItem1 = pSD->pCtrl->GetItemText(iItem1, pSD->iColumn);
	CString strItem2 = pSD->pCtrl->GetItemText(iItem2, pSD->iColumn);

	return ((CMainFrame *)AfxGetMainWnd())->IsCaseSensitiveSort() ? strItem1.Compare(strItem2) : 
					strItem1.CompareNoCase(strItem2);
}	// end of SortView


///////////////////////////////////////////////////////////////////////
// when the list control receives an CR, switch the main view to the
// selected row
void CValidationPane::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (VK_RETURN == nChar)
	{
		CSplitterWnd* pSplitter = static_cast<CSplitterWnd*>(GetParent());
		CSplitterView* pDatabaseView = static_cast<CSplitterView*>(pSplitter->GetPane(0,0));
		CWnd* pTableView = pDatabaseView->m_wndSplitter.GetPane(0,1);
		pTableView->SetFocus();
		return;
	}
	CListView::OnChar(nChar, nRepCnt, nFlags);
}


///////////////////////////////////////////////////////////////////////
// CValidationError, class that maintains information about a validation
// error.
CValidationError::CValidationError(const CString* pstrICE, RESULTTYPES eiType, const CString* pstrDescription, 
	const COrcaTable* pTable, const COrcaRow* pRow, int iColumn)
{
	m_pstrICE = pstrICE ? new CString(*pstrICE) : NULL;
	m_pstrDescription = pstrDescription ? new CString(*pstrDescription) : NULL;
	m_iColumn = iColumn;
	m_eiType = eiType;
	m_pTable = pTable;
	m_pRow = pRow;
}


CValidationError::~CValidationError()
{
	if (m_pstrDescription)
		delete m_pstrDescription;
	if (m_pstrICE)
		delete m_pstrICE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\orca\valpp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_VALPAGE_H__2D9D6C93_3EDA_11D2_8893_00A0C981B015__INCLUDED_)
#define AFX_VALPAGE_H__2D9D6C93_3EDA_11D2_8893_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ValPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CValPropPage dialog

class CValPropPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CValPropPage)

// Construction
public:
	bool m_bValChange;
	CValPropPage();
	~CValPropPage();

// Dialog Data
	//{{AFX_DATA(CValPropPage)
	enum { IDD = IDD_PAGE_VALIDATION };
	CString	m_strICEs;
	BOOL	m_bSuppressInfo;
	BOOL	m_bSuppressWarn;
	BOOL	m_bClearResults;
	CString m_strCUBFile;
	CComboBox m_ctrlCUBFile;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CValPropPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL OnInitDialog();
	virtual BOOL OnKillActive();
	virtual void OnDestroy(); 

	// Generated message map functions
	//{{AFX_MSG(CValPropPage)
	afx_msg void OnChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CMsmPropPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CMsmPropPage)

// Construction
public:
	CMsmPropPage();
	~CMsmPropPage();

// Dialog Data
	//{{AFX_DATA(CValPropPage)
	enum { IDD = IDD_PAGE_MSM };
	int m_iMemoryCount;
	BOOL m_bAlwaysConfig;
	BOOL m_bWatchLog;
	//}}AFX_DATA
	
	bool m_bMSMChange;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CValPropPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL OnInitDialog();

	// Generated message map functions
	//{{AFX_MSG(CValPropPage)
	afx_msg void OnChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


class CTransformPropPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CTransformPropPage)

// Construction
public:
	CTransformPropPage();
	~CTransformPropPage();

// Dialog Data
	//{{AFX_DATA(CValPropPage)
	enum { IDD = IDD_PAGE_TRANSFORM };
	int m_iValidationOptions;
	int m_iErrorOptions;
	//}}AFX_DATA
	
	bool m_bTransformChange;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CValPropPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CValPropPage)
	afx_msg void OnChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VALPAGE_H__2D9D6C93_3EDA_11D2_8893_00A0C981B015__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\patchwiz\fileptch.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//--------------------------------------------------------------------------

  /* FILEPTCH.CPP -- File Patch stuff */

#pragma warning (disable:4553)

#include "patchdll.h"
#include "patchres.h"

//header file for new patch caching mechanism for perf...
#include "patchcache.h"

EnableAsserts


static MSIHANDLE g_hdbInput     = NULL;
static LPTSTR    g_szTempFolder = szNull;
static LPTSTR    g_szTempFName  = szNull;
static BOOL      g_bUsedMsiPatchHeadersTable = FALSE;

#ifdef UNICODE
static PATCH_OLD_FILE_INFO_W* g_ppofi        = NULL;
#else
static PATCH_OLD_FILE_INFO_A* g_ppofi        = NULL;
#endif
static LPSTR*               g_pszaSymPaths = NULL;  // ANSI strings only
static ULONG                g_cpofiMax     = 0;

static ULONG UlMaxExtFiles ( MSIHANDLE hdbInput );

static UINT IdsCountTargetImages                     ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsCreatePatchFilesMSTsCabinetsForFamily ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT UiStuffCabsAndMstsIntoPackage            ( MSIHANDLE hdbInput, LPTSTR szPatchPath );
static BOOL FSetPatchPackageSummaryInfo              ( MSIHANDLE hdbInput, LPTSTR szPatchPath );

/* ********************************************************************** */
UINT UiMakeFilePatchesCabinetsTransformsAndStuffIntoPatchPackage ( MSIHANDLE hdbInput, LPTSTR szPatchPath, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szPatchPath));
	Assert(!FFolderExist(szPatchPath));
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);

	g_hdbInput     = hdbInput;
	g_szTempFolder = szTempFolder;
	g_szTempFName  = szTempFName;

	Assert(g_ppofi == NULL);
	Assert(g_pszaSymPaths == NULL);
	Assert(g_cpofiMax == 0);
	
	UINT ids = IdsMsiEnumTable(hdbInput, TEXT("`TargetImages`"),
					TEXT("`Target`"), szNull, IdsCountTargetImages,
					0L, 0L);
	Assert(ids == IDS_OKAY);
	Assert(g_cpofiMax > 0);
	Assert(g_cpofiMax < 256);
	g_cpofiMax += UlMaxExtFiles(hdbInput);
	Assert(g_cpofiMax < 256);

#ifdef UNICODE
	g_ppofi = (PATCH_OLD_FILE_INFO_W*)LocalAlloc(LPTR, g_cpofiMax*sizeof(PATCH_OLD_FILE_INFO_W));
#else
	g_ppofi = (PATCH_OLD_FILE_INFO_A*)LocalAlloc(LPTR, g_cpofiMax*sizeof(PATCH_OLD_FILE_INFO_A));
#endif
	Assert(g_ppofi != NULL);
	if (!g_ppofi)
		return IDS_OOM;

	g_pszaSymPaths = (LPSTR*)LocalAlloc(LPTR, g_cpofiMax*sizeof(LPSTR));
	Assert(g_pszaSymPaths != NULL);
	if (!g_pszaSymPaths)
		return IDS_OOM;

	for (ULONG ipofi = g_cpofiMax; ipofi-- > 0; )
		{
#ifdef UNICODE
		PATCH_OLD_FILE_INFO_W* ppofi = &(g_ppofi[ipofi]);
		ppofi->SizeOfThisStruct = sizeof(PATCH_OLD_FILE_INFO_W);
#else
		PATCH_OLD_FILE_INFO_A* ppofi = &(g_ppofi[ipofi]);
		ppofi->SizeOfThisStruct = sizeof(PATCH_OLD_FILE_INFO_A);
#endif
		ppofi->OldFileName      = szNull;
		ppofi->IgnoreRangeCount = 0;
		ppofi->IgnoreRangeArray = NULL;
		ppofi->RetainRangeCount = 0;
		ppofi->RetainRangeArray = NULL;

		g_pszaSymPaths[ipofi] = NULL;
		}

	ids = IdsMsiEnumTable(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`,`MediaDiskId`,`FileSequenceStart`"),
					szNull, IdsCreatePatchFilesMSTsCabinetsForFamily,
					0L, 0L);

	LocalFree((HLOCAL)g_ppofi);
	g_ppofi = NULL;
	LocalFree((HLOCAL)g_pszaSymPaths);
	g_pszaSymPaths = NULL;
	g_cpofiMax = 0;

	if (ids != IDS_OKAY)
		return (ids);

	lstrcpy(szTempFName, TEXT("tempcopy.msp"));
	Assert(!FFileExist(szTempFolder));
	Assert(!FFolderExist(szTempFolder));

	TCHAR rgchTempMspPath[MAX_PATH];
	lstrcpy(rgchTempMspPath, szTempFolder);
	*szTempFName = TEXT('\0');

	ids = UiStuffCabsAndMstsIntoPackage(hdbInput, rgchTempMspPath);
	if (ids != ERROR_SUCCESS)
		return (ids);

	if (!FSetPatchPackageSummaryInfo(hdbInput, rgchTempMspPath))
		return (UiLogError(ERROR_PCW_WRITE_SUMMARY_PROPERTIES, szNull, szNull));

	if (FFileExist(szPatchPath))
		{
		SetFileAttributes(szPatchPath, FILE_ATTRIBUTE_NORMAL);
		DeleteFile(szPatchPath);
		if (FFileExist(szPatchPath))
			return (UiLogError(ERROR_PCW_CANT_OVERWRITE_PATCH, szPatchPath, NULL));
		}
	if (!CopyFile(rgchTempMspPath, szPatchPath, fTrue))
		return (UiLogError(ERROR_PCW_CANT_OVERWRITE_PATCH, rgchTempMspPath, NULL));

	return (ERROR_SUCCESS);
}


/* ********************************************************************** */
static UINT IdsCountTargetImages ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	g_cpofiMax++;
	Assert(g_cpofiMax > 0);
	Assert(g_cpofiMax < 256);

	return (IDS_OKAY);
}


static UINT IdsCountExtFiles ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static ULONG UlMaxExtFiles ( MSIHANDLE hdbInput )
{
	Assert(hdbInput != NULL);

	ULONG ulRet = 0L;

	EvalAssert( MSI_OKAY == IdsMsiEnumTable(hdbInput,
					TEXT("`ExternalFiles`"), TEXT("`Family`,`FTK`"),
					szNull, IdsCountExtFiles,
					(LPARAM)(hdbInput), (LPARAM)(&ulRet)) );

	Assert(ulRet >= 0L);
	Assert(ulRet < 250L);

	return (ulRet);
}


static UINT IdsIncrExtFilesCount ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static UINT IdsCountExtFiles ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	MSIHANDLE hdbInput = (MSIHANDLE)lp1;
	Assert(hdbInput != NULL);

	ULONG* pulMax = (ULONG*)lp2;
	Assert(pulMax != NULL);

	TCHAR rgchFamily[16];
	DWORD dwcch = 16;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchFamily, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFamily));

	TCHAR rgchFTK[128];
	dwcch = 128;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFTK));

	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("`Family`='%s' AND `FTK`='%s'"), rgchFamily, rgchFTK);
	Assert(lstrlen(rgchWhere) < sizeof(rgchWhere)/sizeof(TCHAR));

	ULONG ulRet = 0L;
	EvalAssert( MSI_OKAY == IdsMsiEnumTable(hdbInput,
					TEXT("`ExternalFiles`"), TEXT("`Family`,`FTK`"),
					rgchWhere, IdsIncrExtFilesCount,
					(LPARAM)(&ulRet), 0L) );

	Assert(ulRet >= 1L);
	Assert(ulRet < 250L);

	if (ulRet > *pulMax)
		*pulMax = ulRet;

	return (IDS_OKAY);
}


/* ********************************************************************** */
static UINT IdsIncrExtFilesCount ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	ULONG* pulCount = (ULONG*)lp1;
	Assert(pulCount != NULL);

	(*pulCount)++;

	return (IDS_OKAY);
}


static UINT UiMakeFilePatches ( LPTSTR szFamily, int iDiskId, int* piSequenceNumCur );
static UINT UiMakeTransforms  ( LPTSTR szFamily, int iSequenceNumCur );
static UINT UiCreateCabinet   ( LPTSTR szFamily, int iSequenceNumStart, int iSequenceNumCur );

/* ********************************************************************** */
static UINT IdsCreatePatchFilesMSTsCabinetsForFamily ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	TCHAR rgchFamily[32];
	DWORD dwcch = 32;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchFamily, &dwcch);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchFamily));

	lstrcpy(g_szTempFName, rgchFamily);
	lstrcat(g_szTempFName, TEXT("\\"));
	if (!FEnsureFolderExists(g_szTempFolder))
		return (UiLogError(ERROR_PCW_CANT_CREATE_TEMP_FOLDER, g_szTempFolder, szNull));
	Assert(FFolderExist(g_szTempFolder));

	int iDiskId, iSeqNumStart;

	if (MsiRecordIsNull(hrec, 2))
		{
		// patch targeting Windows Installer 2.0 or greater; sequence conflict management will take care of this

		// we don't validate that MinimumRequiredMsiVersion >= iWindowsInstallerXP since IdsValidateFamilyRecords
		// should already have taken care of this
			iDiskId = 2;
		}
	else
		{
		iDiskId = MsiRecordGetInteger(hrec, 2);
		}
	Assert(iDiskId > 1);

	if (MsiRecordIsNull(hrec, 3))
		{
		// patch targeting Windows Installer 2.0 or greater; sequence conflict management will take care of this

		// we don't validate that MinimumRequiredMsiVersion >= iWindowsInstallerXP since IdsValidateFamilyRecords
		// should already have taken care of this
			iSeqNumStart = 2;
		}
	else
		{
		iSeqNumStart = MsiRecordGetInteger(hrec, 3);
		}
	Assert(iSeqNumStart > 1);

	int iSeqNumCur = iSeqNumStart;

	UpdateStatusMsg(IDS_STATUS_CREATE_FILE_PATCHES, rgchFamily, szEmpty);
	uiRet = UiMakeFilePatches(rgchFamily, iDiskId, &iSeqNumCur);
	if (uiRet != ERROR_SUCCESS)
		return (uiRet);

	UpdateStatusMsg(IDS_STATUS_CREATE_TRANSFORMS, rgchFamily, szEmpty);
	uiRet = UiMakeTransforms(rgchFamily, iSeqNumCur);
	if (uiRet != ERROR_SUCCESS)
		return (uiRet);
			
	UpdateStatusMsg(IDS_STATUS_CREATE_CABINET, rgchFamily, szEmpty);
	uiRet = UiCreateCabinet(rgchFamily, iSeqNumStart, iSeqNumCur);
	if (uiRet != ERROR_SUCCESS)
		return (uiRet);

	return (IDS_OKAY);
}


static int    g_iSeqNumCur       = 0;
static LPTSTR g_szFamily         = szNull;
static BOOL   g_fDontUsePatching = fFalse;

static UINT IdsMakeFilePatchesForUpgradedImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsUpdateLastSeqNumForTargetImage  ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static UINT UiMakeFilePatches ( LPTSTR szFamily, int iDiskId, int* piSequenceNumCur )
{
	Assert(!FEmptySz(szFamily));
	Assert(iDiskId > 1);
	Assert(piSequenceNumCur != NULL);
	Assert(*piSequenceNumCur > 0);

	Assert(g_cpofiMax > 0);
	Assert(g_cpofiMax < 256);
	Assert(g_ppofi != NULL);
	Assert(g_pszaSymPaths != NULL);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	g_iSeqNumCur = *piSequenceNumCur;
	g_szFamily   = szFamily;

	TCHAR rgchWhere[MAX_PATH] = {0};
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(g_hdbInput, TEXT("Properties"), TEXT("Name"), TEXT("Value"), TEXT("IncludeWholeFilesOnly"), rgchWhere, MAX_PATH) );

	TCHAR rgchPatchCacheEnabled[4];
	HRESULT hrret;
	hrret = IdsMsiGetTableString(g_hdbInput, TEXT("Properties"), TEXT("Name"), TEXT("Value"), TEXT("PATCH_CACHE_ENABLED"), rgchPatchCacheEnabled, 4);

	if (S_OK == hrret)
		{
		if (rgchPatchCacheEnabled[0] == '1')
		{
			g_bPatchCacheEnabled = TRUE;

			HRESULT hrret2;
			TCHAR rgchPatchCacheDir[MAX_PATH];
			hrret2 = IdsMsiGetTableString(g_hdbInput, TEXT("Properties"), TEXT("Name"), TEXT("Value"), TEXT("PATCH_CACHE_DIR"), rgchPatchCacheDir, MAX_PATH);
			if (S_OK == hrret2)
				{
				if (!FEmptySz(rgchPatchCacheDir))
					{
					TCHAR rgchOptimizePatchSizeBuf[64];
					if (*SzLastChar(rgchPatchCacheDir) != TEXT('\\'))
						{
							_tcscat(rgchPatchCacheDir, TEXT("\\"));
						}

					//are we doing a 1.2 or 1.1 compatible patch?
					UINT iRet = IdsMsiGetPcwPropertyString(g_hdbInput, TEXT("OptimizePatchSizeForLargeFiles"), rgchOptimizePatchSizeBuf, 64);
				 
					if (iRet == IDS_OKAY) //ok, found it, is it on or off?
						{
							if (rgchOptimizePatchSizeBuf[0] == TEXT('1')) //1.2 feature on?
								_tcscat(rgchPatchCacheDir, TEXT("1.2\\"));  //set cache dir to 1.2 compatible only!  Won't work on less than 1.2 engine!
							else
								_tcscat(rgchPatchCacheDir, TEXT("1.1\\")); //not using 1.2 feature, so cache dir can be 1.1 compatible...
						}
					else
						{
							_tcscat(rgchPatchCacheDir, TEXT("1.1\\"));
						}

					// must be sure trailing backslash '\' is the last char in rgchPatchCacheDir

					if (!FEnsureFolderExists(rgchPatchCacheDir))
						{
						Assert(1); //dir creation failed!
						g_bPatchCacheEnabled = FALSE; //no dir, can't use caching
						}
					else
						_tcscpy(g_szPatchCacheDir, rgchPatchCacheDir);
					}
				else //no dir, can't use caching
					{
					EvalAssert( FWriteLogFile(TEXT("    Patch cache could not be used!  Need to set PATCH_CACHE_DIR in Properties table in .pcp file\r\n")) );
					g_bPatchCacheEnabled = FALSE;
					}
				}
			}
		}
	
	g_fDontUsePatching = ((!FEmptySz(rgchWhere)) && (*rgchWhere != TEXT('0')));

	wsprintf(rgchWhere, TEXT("`Family`='%s'"), szFamily);

	UINT ids = IdsMsiEnumTable(g_hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`,`MsiPath`,`LFN`"),
					rgchWhere, IdsMakeFilePatchesForUpgradedImage,
					(LPARAM)(g_hdbInput), 0L);
	if (ids != IDS_OKAY)
		return (ids);
	*piSequenceNumCur = g_iSeqNumCur;

	ids = IdsMsiEnumTable(g_hdbInput, TEXT("`TargetImages`"),
					TEXT("`Target`"), rgchWhere,
					IdsUpdateLastSeqNumForTargetImage, (LPARAM)iDiskId, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	return (ERROR_SUCCESS);
}


/* ********************************************************************** */
static UINT IdsUpdateLastSeqNumForTargetImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	int iDiskId = (int)(lp1);
	Assert(iDiskId > 1);

	Assert(g_hdbInput != NULL);
	Assert(g_iSeqNumCur > 1);

	TCHAR rgchTarget[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTarget));

	MSIHANDLE hdbCopyOfUpgradedImage = HdbReopenMsi(g_hdbInput, rgchTarget, fFalse, fTrue);
	Assert(hdbCopyOfUpgradedImage != NULL);

	uiRet = IdsMsiUpdateTableRecordIntPkeyInt(hdbCopyOfUpgradedImage, TEXT("Media"),
				TEXT("LastSequence"), g_iSeqNumCur, TEXT("DiskId"), iDiskId);

	EvalAssert( MSI_OKAY == MsiDatabaseCommit(hdbCopyOfUpgradedImage) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbCopyOfUpgradedImage) );

	return (uiRet);
}


static LPTSTR g_szUpgradedImage     = szNull;
static BOOL   g_fLfn                = fFalse;
static LPTSTR g_szUpgradedSrcFolder = szNull;
static LPTSTR g_szUpgradedSrcFName  = szNull;

static UINT IdsHandleOneFilePatch ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static UINT IdsMakeFilePatchesForUpgradedImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	MSIHANDLE hdbInput = (MSIHANDLE)(lp1);
	Assert(hdbInput != NULL);

	Assert(g_szFamily     != szNull);
	Assert(g_szTempFolder != szNull);
	Assert(g_szTempFName  != szNull);
	Assert(g_iSeqNumCur   > 0);

	TCHAR rgchSrcRoot[MAX_PATH+MAX_PATH];
	DWORD dwcch = MAX_PATH+MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 2, rgchSrcRoot, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchSrcRoot));
	Assert(FFileExist(rgchSrcRoot));
	g_szUpgradedSrcFolder = rgchSrcRoot;
	g_szUpgradedSrcFName  = SzFindFilenameInPath(g_szUpgradedSrcFolder);
	Assert(!FEmptySz(g_szUpgradedSrcFName));

	TCHAR rgch[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 3, rgch, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgch));
	Assert(!lstrcmp(rgch, TEXT("Yes")) || !lstrcmp(rgch, TEXT("No")));
	g_fLfn = (*rgch == TEXT('Y'));

	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 1, rgch, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgch));
	g_szUpgradedImage = rgch;

	UpdateStatusMsg(0, rgch, TEXT(""));

	MSIHANDLE hdbUpgradedImage = HdbReopenMsi(hdbInput, rgch, fTrue, fFalse);
	Assert(hdbUpgradedImage != NULL);

	uiRet = IdsMsiEnumTable(hdbUpgradedImage, TEXT("`File`"),
					TEXT("`File`,`Component_`,`FileName`"),
					szNull, IdsHandleOneFilePatch,
					lp1, (LPARAM)hdbUpgradedImage);

	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbUpgradedImage) );

	return (uiRet);
}


static TCHAR g_rgchFNameToCompare[MAX_PATH] = TEXT("");
static TCHAR g_rgchSubFolderToCompare[MAX_PATH+ MAX_PATH] = TEXT("");

static BOOL FFamilyFileProcessed      ( MSIHANDLE hdb, LPTSTR szFamily, LPTSTR szFTK );
static BOOL FFamilyFileIgnored        ( MSIHANDLE hdb, LPTSTR szUpgraded, LPTSTR szFTK );
static void ClearAttributeField       ( MSIHANDLE hdb, LPTSTR szTable );
static void DoTargetFileComparesForUpgradedsInFamilyThatHaveFile ( MSIHANDLE hdbInput, LPTSTR szFTK );
static void DoFileComparesForExternalFiles ( MSIHANDLE hdbInput, LPTSTR szWhere );
static void GetFileSizeSz             ( LPTSTR szFile, DWORD* pdwHi, DWORD* pdwLow );
static UINT IdsUpdateMsiForNewSeqNum  ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static UINT IdsHandleOneFilePatch ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	MSIHANDLE hdbInput         = (MSIHANDLE)(lp1);
	MSIHANDLE hdbUpgradedImage = (MSIHANDLE)(lp2);
	Assert(hdbInput         != NULL);
	Assert(g_hdbInput       == hdbInput);
	Assert(hdbUpgradedImage != NULL);

	Assert(g_szFamily     != szNull);
	Assert(g_szTempFolder != szNull);
	Assert(g_szTempFName  != szNull);
	Assert(g_iSeqNumCur   > 0);

	Assert(g_szUpgradedImage != szNull);
	// g_fLfn is set appropriately
	Assert(!FEmptySz(g_szUpgradedSrcFolder));
	Assert(g_szUpgradedSrcFName != szNull);

	TCHAR rgchFTK[MAX_PATH];
	DWORD dwcch = MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchFTK, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFTK));        // File.File

	if (FFamilyFileProcessed(hdbInput, g_szFamily, rgchFTK))
		return (IDS_OKAY); // no work here

	if (FFamilyFileIgnored(hdbInput, g_szUpgradedImage, rgchFTK))
		return (IDS_OKAY); // no work here

	UpdateStatusMsg(0, szNull, rgchFTK);

	TCHAR rgchComponent[MAX_PATH+MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchComponent, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchComponent));  // File.Component_

	TCHAR rgchFName[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchFName, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFName));      // File.FileName
	lstrcpy(g_rgchFNameToCompare, rgchFName);

	uiRet = IdsResolveSrcFilePathSzs(hdbUpgradedImage, g_szUpgradedSrcFName,
				rgchComponent, rgchFName, g_fLfn, g_rgchSubFolderToCompare);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(g_szUpgradedSrcFName));
	if (!FFileExist(g_szUpgradedSrcFolder))
		return (IDS_OKAY); // no work here

	ClearAttributeField(hdbInput, TEXT("TargetImages"));

	DoTargetFileComparesForUpgradedsInFamilyThatHaveFile(hdbInput, rgchFTK);

	BOOL fNeedWholeFile = fFalse;
	EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput,
				TEXT("`TargetImages`"), TEXT("`Target`"),
				TEXT("WHERE `Attributes` = 2"), &fNeedWholeFile) );
	BOOL fFilesDiffer = fNeedWholeFile;
	EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput,
				TEXT("`TargetImages`"), TEXT("`Target`"),
				TEXT("WHERE `Attributes` = 1"), &fFilesDiffer) );

#define rgchWhere rgchComponent // reuse buffer
	if (!fNeedWholeFile)
		{
		wsprintf(rgchWhere, TEXT("`FTK` = '%s' AND `Family` = '%s'"), rgchFTK, g_szFamily);
		DoFileComparesForExternalFiles(hdbInput, rgchWhere);
		}

	if (!fFilesDiffer)
		{
		wsprintf(rgchWhere, TEXT("WHERE `FTK` = '%s' AND `Family` = '%s'"), rgchFTK, g_szFamily);
		EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput,
				TEXT("`ExternalFiles`"), TEXT("`FilePath`"),
				rgchWhere, &fFilesDiffer) );
		}

	if (!fFilesDiffer)
		return (IDS_OKAY); // no work here

	if (g_fDontUsePatching)
		fNeedWholeFile = fTrue;
	else if (!fNeedWholeFile)
		{
		BOOL fExists;

		fExists = fFalse;
		EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput,
						TEXT("`UpgradedFiles_OptionalData`"),
						TEXT("`Upgraded`"), TEXT("WHERE `IncludeWholeFile` is null"), &fExists) );
		Assert(!fExists);

		/* single backslashes (`) eliminated to shorten query length */
		wsprintf(rgchWhere, TEXT("WHERE UpgradedImages.Upgraded = UpgradedFiles_OptionalData.Upgraded AND Family = '%s' AND FTK = '%s' AND IncludeWholeFile <> 0"),
				g_szFamily, rgchFTK);
//		wsprintf(rgchWhere, TEXT("WHERE UpgradedImages.Upgraded = UpgradedFiles_OptionalData.Upgraded AND Family = '%s' AND FTK = '%s' AND IncludeWholeFile is not null AND IncludeWholeFile <> 0"),
//				g_szFamily, rgchFTK);
		fExists = fFalse;
		/* single backslashes (`) eliminated to shorten query length */
		EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput,
						TEXT("UpgradedImages,UpgradedFiles_OptionalData"),
						TEXT("Family"), rgchWhere, &fExists) );
		if (fExists)
			fNeedWholeFile = fTrue;
		}


	wsprintf(rgchWhere, TEXT("`Family` = '%s' AND `FTK` = '%s'"),
				g_szFamily, rgchFTK);
	int iSeqNumNew = 0;
	uiRet = IdsMsiGetTableIntegerWhere(hdbInput, TEXT("`NewSequenceNums`"),
				TEXT("`SequenceNum`"), rgchWhere, &iSeqNumNew);
	Assert(uiRet == IDS_OKAY);

	if (iSeqNumNew == MSI_NULL_INTEGER || iSeqNumNew <= 0)
		{
		iSeqNumNew = g_iSeqNumCur++;
		Assert(iSeqNumNew <= 32767);
		if (!fNeedWholeFile)
			{
			lstrcpy(g_szTempFName, g_szFamily);
			lstrcat(g_szTempFName, TEXT("\\"));
			
			//Only do this for non-full files as full files is NOT 
			//slow...
			if (g_bPatchCacheEnabled) //use new algorithm???
				{
				UINT ui = PatchCacheEntryPoint(hdbInput, rgchFTK, g_szUpgradedSrcFolder, iSeqNumNew,
												g_szTempFolder, g_szTempFName + lstrlen(g_szTempFName));

				if (ui != IDS_OKAY)
				     return (ui);
				}
			else //caching not enabled, using existing way of doing patches...
				{
				UINT ui = UiGenerateOnePatchFile(hdbInput, rgchFTK, g_szUpgradedSrcFolder, iSeqNumNew,
													g_szTempFolder, g_szTempFName + lstrlen(g_szTempFName));

				if (ui != IDS_OKAY)
				   return (ui);
	
				}
			}

		DWORD dwNewHi = 0L, dwNewLow = 0L;
		wsprintf(g_szTempFName, TEXT("%s\\%05i.PAT"), g_szFamily, iSeqNumNew);
		if (!FFileExist(g_szTempFolder))
			{
			EvalAssert( FWriteLogFile(TEXT("    Patch API could not create a small patch; using whole upgraded file.\r\n")) );
			fNeedWholeFile = fTrue;
			}
		else
			{
			GetFileSizeSz(g_szTempFolder, &dwNewHi, &dwNewLow);
			wsprintf(g_szTempFName, TEXT("%s\\%05i.HDR"), g_szFamily, iSeqNumNew);
			if (dwNewHi > 0L || dwNewLow > 2147483647L || !FFileExist(g_szTempFolder))
				{
				EvalAssert( FWriteLogFile(TEXT("    Patch API could not create a small patch header; using whole upgraded file.\r\n")) );
				fNeedWholeFile = fTrue;
				}
			else
				{
				GetFileSizeSz(g_szTempFolder, &dwNewHi, &dwNewLow);

				Assert(FFileExist(g_szUpgradedSrcFolder));
				DWORD dwSrcHi = 0L, dwSrcLow = 0L;
				GetFileSizeSz(g_szUpgradedSrcFolder, &dwSrcHi, &dwSrcLow);

				if (dwNewHi > dwSrcHi || (dwNewHi == dwSrcHi && dwNewLow >= dwSrcLow))
					{
					EvalAssert( FWriteLogFile(TEXT("    Patch API results are bigger than upgraded file; using whole upgraded file.\r\n")) );
					fNeedWholeFile = fTrue;
					}
				}
			}

		if (fNeedWholeFile)
			{
			wsprintf(g_szTempFName, TEXT("%s\\%05i.PAT"), g_szFamily, iSeqNumNew);
			if (FFileExist(g_szTempFolder))
				{
				SetFileAttributes(g_szTempFolder, FILE_ATTRIBUTE_NORMAL);
				DeleteFile(g_szTempFolder);
				Assert(!FFileExist(g_szTempFolder));
				}
			wsprintf(g_szTempFName, TEXT("%s\\%05i.HDR"), g_szFamily, iSeqNumNew);
			if (FFileExist(g_szTempFolder))
				{
				SetFileAttributes(g_szTempFolder, FILE_ATTRIBUTE_NORMAL);
				DeleteFile(g_szTempFolder);
				Assert(!FFileExist(g_szTempFolder));
				}
			wsprintf(g_szTempFName, TEXT("%s\\%05i.FLE"), g_szFamily, iSeqNumNew);
			if (FFileExist(g_szTempFolder))
				{
				SetFileAttributes(g_szTempFolder, FILE_ATTRIBUTE_NORMAL);
				DeleteFile(g_szTempFolder);
				Assert(!FFileExist(g_szTempFolder));
				}
			EvalAssert( FSprintfToLog(TEXT("  Including entire file: '%s';\r\n           FTK=%s; temp location=%s."), g_szUpgradedSrcFolder, rgchFTK, g_szTempFName, szEmpty) );
			if (!CopyFile(g_szUpgradedSrcFolder, g_szTempFolder, fTrue))
				{
				return (UiLogError(ERROR_PCW_CANT_COPY_FILE_TO_TEMP_FOLDER,
						g_szUpgradedSrcFolder, g_szTempFolder));
				}
			}
		else
			{
			if (!g_bPatchCacheEnabled) //if cache is used, don't write out stuff to log...
				{
				EvalAssert( FSprintfToLog(TEXT("  Patch file created: FTK=%s; temp location=%s."), rgchFTK, g_szTempFName, szEmpty, szEmpty) );
				}
			}

#define rgchQuery rgchComponent // reuse buffer
		wsprintf(rgchQuery, TEXT("INSERT INTO `NewSequenceNums` ( `Family`, `FTK`, `SequenceNum` ) VALUES ( '%s', '%s', %d )"),
				g_szFamily, rgchFTK, iSeqNumNew);
		Assert(lstrlen(rgchQuery) < sizeof(rgchQuery)/sizeof(TCHAR));

		MSIHANDLE hviewNew = NULL;
		EvalAssert( MSI_OKAY == MsiDatabaseOpenView(hdbInput, rgchQuery, &hviewNew) );
		Assert(hviewNew != NULL);
		EvalAssert( MSI_OKAY == MsiViewExecute(hviewNew, 0) );
		EvalAssert( MSI_OKAY == MsiCloseHandle(hviewNew) );

		Assert(g_hdbInput == hdbInput);

		EvalAssert( IDS_OKAY == IdsMsiEnumTable(hdbInput,
						TEXT("`TargetImages`"),
						TEXT("`Target`,`Upgraded`"),
						TEXT("Attributes <> 0"), IdsUpdateMsiForNewSeqNum,
						(LPARAM)rgchFTK, (LPARAM)iSeqNumNew) );
		}

#undef rgchQuery
#undef rgchWhere

	return (IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FFamilyFileProcessed ( MSIHANDLE hdb, LPTSTR szFamily, LPTSTR szFTK )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szFamily));
	Assert(!FEmptySz(szFTK));

	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("`Upgraded` = '%s' AND `FTK` = '%s'"), szFamily, szFTK);

	TCHAR rgch[64];
	EvalAssert( IDS_OKAY == IdsMsiGetTableStringWhere(hdb, TEXT("`UpgradedFiles_OptionalData`"),
					TEXT("`Upgraded`"), rgchWhere, rgch, 64) );

	return (!FEmptySz(rgch));
}


static UINT IdsMatchIgnoreFTK ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FFamilyFileIgnored ( MSIHANDLE hdb, LPTSTR szUpgraded, LPTSTR szFTK )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szUpgraded));
	Assert(!FEmptySz(szFTK));

	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("`Upgraded` = '*' OR `Upgraded` = '%s'"), szUpgraded);

	UINT ids = IdsMsiEnumTable(hdb, TEXT("`UpgradedFilesToIgnore`"),
						TEXT("`FTK`"), rgchWhere, IdsMatchIgnoreFTK,
						(LPARAM)szFTK, 0L);
	Assert(ids == IDS_OKAY || ids == IDS_CANCEL);

	return (ids != IDS_OKAY);
}


/* ********************************************************************** */
static UINT IdsMatchIgnoreFTK ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0l);

	LPTSTR szFTK = (LPTSTR)(lp1);
	Assert(!FEmptySz(szFTK));

	TCHAR rgchFTK[MAX_PATH];
	DWORD dwcch = MAX_PATH;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchFTK, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFTK));

	if (*SzLastChar(rgchFTK) != TEXT('*'))
		return ((!lstrcmp(szFTK, rgchFTK)) ? IDS_CANCEL : IDS_OKAY);

	*SzLastChar(rgchFTK) = TEXT('\0');

	return ((FMatchPrefix(szFTK, rgchFTK)) ? IDS_CANCEL : IDS_OKAY);
}


/* ********************************************************************** */
static void ClearAttributeField ( MSIHANDLE hdb, LPTSTR szTable )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!lstrcmp(szTable, TEXT("TargetImages")));

	TCHAR rgchQuery[MAX_PATH];
	wsprintf(rgchQuery, TEXT("UPDATE `%s` SET `Attributes` = 0"), szTable);
	Assert(lstrlen(rgchQuery) < sizeof(rgchQuery)/sizeof(TCHAR));

	MSIHANDLE hview;
	EvalAssert( MSI_OKAY == MsiDatabaseOpenView(hdb, rgchQuery, &hview) );
	EvalAssert( MSI_OKAY == MsiViewExecute(hview, 0) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hview) );  /* calls MsiViewClose() internally */
}


static void DoTargetFileComparesForThisUpgradedImage ( MSIHANDLE hdbInput, LPTSTR szUpgraded, LPTSTR szFTK );
static UINT IdsDoTargetFileComparesIfFileExists ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static void DoTargetFileComparesForUpgradedsInFamilyThatHaveFile ( MSIHANDLE hdbInput, LPTSTR szFTK )
{
	Assert(hdbInput != NULL);
	Assert(g_hdbInput == hdbInput);
	Assert(!FEmptySz(szFTK));

	Assert(!FEmptySz(g_szFamily));
	Assert(!FEmptySz(g_szUpgradedImage));
	Assert(!FEmptySz(g_szUpgradedSrcFolder));
	Assert(FFileExist(g_szUpgradedSrcFolder)); // NOTE: true but expensive test

	DoTargetFileComparesForThisUpgradedImage(hdbInput, g_szUpgradedImage, szFTK);

	TCHAR rgchWhere[128];
	wsprintf(rgchWhere, TEXT("`Family` = '%s' AND `Upgraded` <> '%s'"), g_szFamily, g_szUpgradedImage);
	EvalAssert( IDS_OKAY == IdsMsiEnumTable(hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`,`MsiPath`,`LFN`"),
					rgchWhere, IdsDoTargetFileComparesIfFileExists,
					(LPARAM)hdbInput, (LPARAM)szFTK) );
}


static UINT IdsMarkIfSrcFileDiffers ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static void DoTargetFileComparesForThisUpgradedImage ( MSIHANDLE hdbInput, LPTSTR szUpgraded, LPTSTR szFTK )
{
	Assert(hdbInput != NULL);
	Assert(g_hdbInput == hdbInput);
	Assert(!FEmptySz(szUpgraded));
	Assert(!FEmptySz(szFTK));

	Assert(!FEmptySz(g_szUpgradedSrcFolder));
	Assert(FFileExist(g_szUpgradedSrcFolder)); // NOTE: true but expensive test

	TCHAR rgchWhere[128];
	wsprintf(rgchWhere, TEXT("`Upgraded` = '%s'"), szUpgraded);
	EvalAssert( IDS_OKAY == IdsMsiEnumTable(hdbInput, TEXT("`TargetImages`"),
					TEXT("`Target`,`MsiPath`,`LFN`,`Attributes`,`IgnoreMissingSrcFiles`"),
					rgchWhere, IdsMarkIfSrcFileDiffers,
					(LPARAM)g_szUpgradedSrcFolder, (LPARAM)szFTK) );
}


static BOOL FDoFilesDiffer    ( LPTSTR szFile1, LPTSTR szFile2 );
static BOOL FComponentInImage ( MSIHANDLE hdb, LPTSTR szComp );

/* ********************************************************************** */
static UINT IdsDoTargetFileComparesIfFileExists ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	MSIHANDLE hdbInput = (MSIHANDLE)lp1;
	Assert(hdbInput != NULL);
	Assert(g_hdbInput == hdbInput);
	
	LPTSTR szFTK = (LPTSTR)lp2;
	Assert(!FEmptySz(szFTK));

	Assert(!FEmptySz(g_szUpgradedSrcFolder));
	Assert(FFileExist(g_szUpgradedSrcFolder)); // NOTE: true but expensive test

	TCHAR rgchUpgraded[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchUpgraded, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchUpgraded));

	MSIHANDLE hdbUpgradedImage = HdbReopenMsi(hdbInput, rgchUpgraded, fTrue, fFalse);
	Assert(hdbUpgradedImage != NULL);

	TCHAR rgchComponent[MAX_PATH];
	uiRet = IdsMsiGetTableString(hdbUpgradedImage, TEXT("`File`"),
					TEXT("`File`"), TEXT("`Component_`"), szFTK,
					rgchComponent, MAX_PATH);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	if (FEmptySz(rgchComponent))
		goto LEarlyReturn; // file not in this Upgraded image
	if (!FComponentInImage(hdbUpgradedImage, rgchComponent))
		goto LEarlyReturn;

	TCHAR rgchFName[MAX_PATH];
	uiRet = IdsMsiGetTableString(hdbUpgradedImage, TEXT("`File`"),
					TEXT("`File`"), TEXT("`FileName`"), szFTK,
					rgchFName, MAX_PATH);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFName));

	TCHAR rgchPath[MAX_PATH+MAX_PATH];
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchPath, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchPath));        // LFN
	Assert(!lstrcmp(rgchPath, TEXT("Yes")) || !lstrcmp(rgchPath, TEXT("No")));
	BOOL fLfn;
	fLfn = (*rgchPath == TEXT('Y'));

	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchPath, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchPath));        // MsiPath
	Assert(FFileExist(rgchPath)); // NOTE: true but expensive test

	LPTSTR szFNameBuf;
	szFNameBuf = SzFindFilenameInPath(rgchPath);
	Assert(!FEmptySz(szFNameBuf));

	uiRet = IdsResolveSrcFilePathSzs(hdbUpgradedImage, szFNameBuf,
				rgchComponent, rgchFName, fLfn, g_rgchSubFolderToCompare);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(szFNameBuf));

	if (FFileExist(rgchPath))
		{
		Assert(!FDoFilesDiffer(g_szUpgradedSrcFolder, rgchPath)); // NOTE: true but expensive test
		DoTargetFileComparesForThisUpgradedImage(hdbInput, rgchUpgraded, szFTK);
		}

LEarlyReturn:
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbUpgradedImage) );

	return (IDS_OKAY);
}


/* ********************************************************************** */
static UINT IdsMarkIfSrcFileDiffers ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	Assert(g_hdbInput != NULL);

	LPTSTR szUpgradedImageSrcFile = (LPTSTR)(lp1);
	Assert(!FEmptySz(szUpgradedImageSrcFile));
	Assert(FFileExist(szUpgradedImageSrcFile)); // NOTE: true but expensive test

	LPTSTR szFTK = (LPTSTR)(lp2);
	Assert(!FEmptySz(szFTK));


	TCHAR rgchTargetImage[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchTargetImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTargetImage));

	MSIHANDLE hdbTargetImage = HdbReopenMsi(g_hdbInput, rgchTargetImage, fFalse, fFalse);
	Assert(hdbTargetImage != NULL);

	TCHAR rgchComponent[MAX_PATH];
	uiRet = IdsMsiGetTableString(hdbTargetImage, TEXT("`File`"),
					TEXT("`File`"), TEXT("`Component_`"), szFTK,
					rgchComponent, MAX_PATH);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	if (FEmptySz(rgchComponent)) // file is missing completely from this image
		goto LMarkAsNeedingEntireFile;
	if (!FComponentInImage(hdbTargetImage, rgchComponent))
		goto LMarkAsNeedingEntireFile;

	TCHAR rgchFName[MAX_PATH];
	uiRet = IdsMsiGetTableString(hdbTargetImage, TEXT("`File`"),
					TEXT("`File`"), TEXT("`FileName`"), szFTK,
					rgchFName, MAX_PATH);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFName));

	if (lstrcmpi(g_rgchFNameToCompare, rgchFName))
		{
		EvalAssert( FSprintfToLog(TEXT("WARNING (11): File.FileName mismatch between Upgraded ('%s') and Target ('%s') Images means old files may be orphaned.  File Table Key: %s"),
				g_rgchFNameToCompare, rgchFName, szFTK, szEmpty) );
		goto LMarkAsNeedingEntireFile;
		}

	TCHAR rgchPath[MAX_PATH+MAX_PATH];
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchPath, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchPath));        // LFN
	Assert(!lstrcmp(rgchPath, TEXT("Yes")) || !lstrcmp(rgchPath, TEXT("No")));
	BOOL fLfn;
	fLfn = (*rgchPath == TEXT('Y'));

	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchPath, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchPath));        // Path_To_Msi
	Assert(FFileExist(rgchPath)); // NOTE: true but expensive test

	LPTSTR szFNameBuf;
	szFNameBuf = SzFindFilenameInPath(rgchPath);
	Assert(!FEmptySz(szFNameBuf));

	TCHAR rgchSubFolder[MAX_PATH + MAX_PATH];
	uiRet = IdsResolveSrcFilePathSzs(hdbTargetImage, szFNameBuf,
				rgchComponent, rgchFName, fLfn, rgchSubFolder);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(szFNameBuf));

	if (!FFileExist(rgchPath))
		{
		int iRet = MsiRecordGetInteger(hrec, 5); // IgnoreMissingSrcFiles
		if (iRet == MSI_NULL_INTEGER || iRet == 0)
			{
			EvalAssert( FSprintfToLog(TEXT("    Src file missing: '%s'."), rgchPath, szEmpty, szEmpty, szEmpty) );
			goto LMarkAsNeedingEntireFile;
			}
		}
	else if (lstrcmpi(g_rgchSubFolderToCompare, rgchSubFolder))
		{
		EvalAssert( FSprintfToLog(TEXT("WARNING (12): SubFolder mismatch between Upgraded ('%s') and Target ('%s') Images means old files may be orphaned.  File Table Key: %s\r\n"),
				g_rgchSubFolderToCompare, rgchSubFolder, szFTK, szEmpty) );

LMarkAsNeedingEntireFile:
		EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 4, 2) );
		EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );
		}
	else if (FDoFilesDiffer(szUpgradedImageSrcFile, rgchPath))
		{
		if (!g_bPatchCacheEnabled)
			{
			EvalAssert( FSprintfToLog(TEXT("     Files differ: '%s',\r\n                   '%s'."), szUpgradedImageSrcFile, rgchPath, szEmpty, szEmpty) );
			}
		EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 4, 1) );
		EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );
		
		if (g_bPatchCacheEnabled) //only do for caching option set...
			{
			StringCchCopy(g_szSourceLFN, sizeof(g_szSourceLFN)/sizeof(g_szSourceLFN[0]), rgchPath); 
			StringCchCopy(g_szDestLFN, sizeof(g_szDestLFN)/sizeof(g_szDestLFN[0]), szUpgradedImageSrcFile); 
			}
		}

	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbTargetImage) );

	return (IDS_OKAY);
}


static UINT IdsMarkIfFileMatches ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static void DoFileComparesForExternalFiles ( MSIHANDLE hdbInput, LPTSTR szWhere )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szWhere));

	EvalAssert( IDS_OKAY == IdsMsiEnumTable(hdbInput, TEXT("`ExternalFiles`"),
					TEXT("`FilePath`,`FTK`"), szWhere,
					IdsMarkIfFileMatches, (LPARAM)g_szUpgradedSrcFolder, 0L) );
}


/* ********************************************************************** */
static UINT IdsMarkIfFileMatches ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	LPTSTR szUpgradedImageSrcFile = (LPTSTR)(lp1);
	Assert(!FEmptySz(szUpgradedImageSrcFile));
	Assert(FFileExist(szUpgradedImageSrcFile)); // NOTE: true but expensive test


	TCHAR rgch[MAX_PATH+MAX_PATH];
	DWORD dwcch = MAX_PATH+MAX_PATH;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgch, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgch));
	Assert(FFileExist(rgch)); // NOTE: true but expensive test

	if (!FDoFilesDiffer(szUpgradedImageSrcFile, rgch))
		{
		TCHAR rgchNewFTK[MAX_PATH];
		lstrcpy(rgchNewFTK, TEXT("<matches> "));
		dwcch = MAX_PATH - lstrlen(rgchNewFTK);
		LPTSTR szFTK = rgchNewFTK + lstrlen(rgchNewFTK);
		uiRet = MsiRecordGetString(hrec, 2, szFTK, &dwcch);
		Assert(uiRet != ERROR_MORE_DATA);
		Assert(uiRet == IDS_OKAY);
		Assert(!FEmptySz(szFTK));

		if (!g_bPatchCacheEnabled) //try to speed up more by not writing to log...
			{
			EvalAssert( FSprintfToLog(TEXT("     External file matched, ignoring; FTK = '%s',\r\n                   : '%s',\r\n                   '%s'."), szFTK, szUpgradedImageSrcFile, rgch, szEmpty) );
			}

		EvalAssert( MSI_OKAY == MsiRecordSetString(hrec, 2, rgchNewFTK) );
		EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );
		}
	else
		{
			if (!g_bPatchCacheEnabled) //don't write to log if we want speed...
			{
			EvalAssert( FSprintfToLog(TEXT("     Files differ: '%s',\r\n                   <ExtFile>: '%s'."), szUpgradedImageSrcFile, rgch, szEmpty, szEmpty) );
			}
		}

	return (IDS_OKAY);
}


TCHAR g_szLastFile1[MAX_PATH] = TEXT("");
TCHAR g_szLastFile2[MAX_PATH] = TEXT("");

#define READ_SIZE 8192

/* ********************************************************************** */
static BOOL FDoFilesDiffer ( LPTSTR szFile1, LPTSTR szFile2 )
{
	Assert(!FEmptySz(szFile1));
	Assert(FFileExist(szFile1)); // NOTE: true but expensive test
	Assert(!FEmptySz(szFile2));
	Assert(FFileExist(szFile2)); // NOTE: true but expensive test

	static BOOL bLastRet = FALSE;

	if (g_bPatchCacheEnabled) //using fastest possible code?  if so, do checks below
		{
		if (0 == _tcsicmp(szFile1, g_szLastFile1) && 0 == _tcsicmp(szFile2, g_szLastFile2))
			{
			// same files just looked at...
			return bLastRet;
			}
		}

   DWORD dw1Hi, dw1Low, dw2Hi, dw2Low;
	GetFileVersion(szFile1, &dw1Hi, &dw1Low);
	GetFileVersion(szFile2, &dw2Hi, &dw2Low);

	if (dw1Hi > dw2Hi || (dw1Hi == dw2Hi && dw1Low > dw2Low))
		return (fTrue);

	TCHAR rgchVer1[64], rgchVer2[64];
	wsprintf(rgchVer1, TEXT("%u.%u.%u.%u"), HIWORD(dw1Hi), LOWORD(dw1Hi), HIWORD(dw1Low), LOWORD(dw1Low));
	Assert(lstrlen(rgchVer1) < 64);
	wsprintf(rgchVer2, TEXT("%u.%u.%u.%u"), HIWORD(dw2Hi), LOWORD(dw2Hi), HIWORD(dw2Low), LOWORD(dw2Low));
	Assert(lstrlen(rgchVer2) < 64);

	if (dw1Hi < dw2Hi || dw1Low < dw2Low)
		{
		EvalAssert( FSprintfToLog(TEXT("WARNING (13): File versions are reversed.  Upgraded: '%s' ver=%s;  Target: '%s' ver=%s."), szFile1, rgchVer1, szFile2, rgchVer2) );
		return (fTrue);
		}

	Assert(dw1Hi  == dw2Hi);
	Assert(dw1Low == dw2Low);
	BOOL fNonZeroVersions = (dw1Hi != 0L || dw1Low != 0L);

	HANDLE hf1 = CreateFile(szFile1, GENERIC_READ, FILE_SHARE_READ,
				NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	Assert(hf1 != INVALID_HANDLE_VALUE);

	HANDLE hf2 = CreateFile(szFile2, GENERIC_READ, FILE_SHARE_READ,
				NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	Assert(hf2 != INVALID_HANDLE_VALUE);

	dw1Low = GetFileSize(hf1, &dw1Hi);
	Assert(dw1Low != 0xffffffff || GetLastError() == NO_ERROR);

	dw2Low = GetFileSize(hf2, &dw2Hi);
	Assert(dw2Low != 0xffffffff || GetLastError() == NO_ERROR);

	BOOL fRet = fFalse;
	if (dw1Low != dw2Low || dw1Hi != dw2Hi)
		fRet = fTrue;
	else
		{
		BOOL fDone = fFalse;
		while (!fDone)
			{
			BYTE rgb1[READ_SIZE], rgb2[READ_SIZE];

			EvalAssert( ReadFile(hf1, (LPVOID)rgb1, READ_SIZE, &dw1Low, NULL) );
			EvalAssert( ReadFile(hf2, (LPVOID)rgb2, READ_SIZE, &dw2Low, NULL) );
			if (dw1Low != dw2Low)
				fDone = fRet = fTrue;
			else if (dw1Low == 0)
				fDone = fTrue;
			else
				{
				while (dw1Low > 0 && !fDone)
					{
					dw1Low--;
					if (rgb1[dw1Low] != rgb2[dw1Low])
						fDone = fRet = fTrue;
					}
				}
			}
		}

	CloseHandle(hf1);
	CloseHandle(hf2);

	if (fRet && fNonZeroVersions)
		{
		EvalAssert( FSprintfToLog(TEXT("WARNING (14): File versions are equal.  Upgraded: '%s' ver=%s;  Target: '%s' ver=%s."), szFile1, rgchVer1, szFile2, rgchVer2) );
		}

	if (g_bPatchCacheEnabled) //if using cache, save state for this compare for later...
		{
		bLastRet = fRet;
		_tcscpy(g_szLastFile1, szFile1);
		_tcscpy(g_szLastFile2, szFile2);
		}

	return (fRet);
}


/* ********************************************************************** */
void GetFileVersion ( LPTSTR szFile, DWORD* pdwHi, DWORD* pdwLow )
{
	Assert(!FEmptySz(szFile));
	Assert(FFileExist(szFile)); // NOTE: true but expensive test
	Assert(pdwHi != NULL);
	Assert(pdwLow != NULL);

	*pdwHi = *pdwLow = 0L;

	BYTE *rgbBuf;
	DWORD dwSize;
	DWORD dwDummy;

	dwSize = GetFileVersionInfoSize(szFile,&dwDummy);

	if (dwSize == 0 || (rgbBuf = (BYTE *)malloc(dwSize)) == NULL)
		return;

	if (GetFileVersionInfo(szFile, 0L, dwSize, (LPVOID)rgbBuf))
		{
		VS_FIXEDFILEINFO* pffi = NULL;
		UINT cchRet = 0;
		if (VerQueryValue((LPVOID)rgbBuf, TEXT("\\"), (LPVOID*)(&pffi), &cchRet))
			{
			Assert(pffi != NULL);
			Assert(cchRet * sizeof(TCHAR) == sizeof(VS_FIXEDFILEINFO));
			*pdwHi  = pffi->dwFileVersionMS;
			*pdwLow = pffi->dwFileVersionLS;
			}
		}
	free(rgbBuf);
}


static UINT IdsIsFeatureInImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FComponentInImage ( MSIHANDLE hdb, LPTSTR szComp )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szComp));

	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("`Feature`.`Feature` = `FeatureComponents`.`Feature_` AND `FeatureComponents`.`Component_` = '%s'"), szComp);
	UINT ids = IdsMsiEnumTable(hdb, TEXT("`Feature`,`FeatureComponents`"),
					TEXT("`Feature`.`Feature`,`Feature`.`Feature_Parent`,`Feature`.`Level`"),
					rgchWhere, IdsIsFeatureInImage, (LPARAM)hdb, 0L);

	Assert(ids == IDS_OKAY             // component NOT in image
			|| ids == IDS_CANCEL);     // component IS  in image

	return (ids == IDS_CANCEL);
}


/* ********************************************************************** */
static UINT IdsIsFeatureInImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	MSIHANDLE hdb = (MSIHANDLE)lp1;
	Assert(hdb != NULL);

	int iLevel = MsiRecordGetInteger(hrec, 3);
	if (iLevel <= 0 || iLevel == MSI_NULL_INTEGER)
		return (IDS_OKAY);  // is NOT in image

	TCHAR rgchFeature[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchFeature, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFeature));

	TCHAR rgchParent[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 2, rgchParent, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);

	if (FEmptySz(rgchParent) || !lstrcmp(rgchFeature, rgchParent))
		return (IDS_CANCEL);  // root feature IS in image

	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("`Feature` = '%s'"), rgchParent);
	uiRet = IdsMsiEnumTable(hdb, TEXT("`Feature`"),
					TEXT("`Feature`,`Feature_Parent`,`Level`"),
					rgchWhere, IdsIsFeatureInImage, lp1, 0L);

	Assert(uiRet == IDS_OKAY             // component NOT in image
			|| uiRet == IDS_CANCEL);     // component IS  in image

	return (uiRet);
}



static void   LogAndIgnoreRetainRangeMismatches ( ULONG ulTargets, LPTSTR szFamily, LPTSTR szFTK );
static LPCSTR SzaGetUpgradedSymPaths ( LPTSTR szFTK );
static UINT   IdsFillG_pofi ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT   IdsFillG_pofiForExtFile ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static BOOL   FCatSymPath   ( MSIHANDLE hdb, LPTSTR szImage, LPTSTR szFTK, LPTSTR szBuf, UINT cch, BOOL fTarget );

static ULONG UlGetApiPatchFlags ( MSIHANDLE hdbInput, BOOL fOption );
#define UlGetApiPatchOptionFlags(hdb)  UlGetApiPatchFlags(hdb,fTrue)
#define UlGetApiPatchSymbolFlags(hdb)  UlGetApiPatchFlags(hdb,fFalse)

/* ********************************************************************** */
UINT UiGenerateOnePatchFile ( MSIHANDLE hdbInput, LPTSTR szFTK, LPTSTR szSrcPath, int iFileSeqNum, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szFTK));
	Assert(!FEmptySz(szSrcPath));
	Assert(FFileExist(szSrcPath)); // NOTE: true but expensive
	Assert(iFileSeqNum > 1);
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);
	Assert(szTempFName > szTempFolder);

	Assert(g_ppofi != NULL);
	Assert(g_pszaSymPaths != NULL);
	Assert(g_cpofiMax > 0);
	Assert(g_cpofiMax < 256);

	g_hdbInput = hdbInput;

	wsprintf(szTempFName, TEXT("%05i.PAT"), iFileSeqNum);
	Assert(!FFileExist(szTempFolder));
		
	Assert(iOrderMax > 0);
	ULONG ulTargets = 0;
	int   iOrderCur = 0;
	for (; iOrderCur < iOrderMax; iOrderCur++)
		{
		TCHAR rgchWhere[MAX_PATH];
		wsprintf(rgchWhere, TEXT("`Attributes` = 1 AND `Order` = %i"), iOrderCur);

		UINT ids = IdsMsiEnumTable(hdbInput, TEXT("`TargetImages`"),
						TEXT("`Target`,`MsiPath`,`LFN`"),
						rgchWhere, IdsFillG_pofi,
						(LPARAM)(&ulTargets), (LPARAM)szFTK);
		if (ids != IDS_OKAY)
			return (ids);

		wsprintf(rgchWhere, TEXT("`Order` = %i AND `Family` = '%s' AND `FTK` = '%s'"), iOrderCur, g_szFamily, szFTK);
		ids = IdsMsiEnumTable(hdbInput, TEXT("`ExternalFiles`"),
						TEXT("`FilePath`,`SymbolPaths`,`IgnoreCount`,`IgnoreOffsets`,`IgnoreLengths`,`RetainOffsets`"),
						rgchWhere, IdsFillG_pofiForExtFile,
						(LPARAM)(&ulTargets), (LPARAM)szFTK);
		if (ids != IDS_OKAY)
			return (ids);
		}

	LogAndIgnoreRetainRangeMismatches(ulTargets, g_szFamily, szFTK);

	Assert(ulTargets > 0);
	Assert(ulTargets < 256);
	Assert(ulTargets <= g_cpofiMax);

	PATCH_OPTION_DATA pod;
	pod.SizeOfThisStruct       = sizeof(PATCH_OPTION_DATA);
	pod.SymbolOptionFlags      = UlGetApiPatchSymbolFlags(hdbInput);
	pod.NewFileSymbolPath      = SzaGetUpgradedSymPaths(szFTK);
	pod.OldFileSymbolPathArray = (LPCSTR*)g_pszaSymPaths;
	pod.ExtendedOptionFlags    = 0;    // TODO - what is allowable here?
	pod.SymLoadCallback        = NULL;
	pod.SymLoadContext         = NULL;

	BOOL fRet = CreatePatchFileEx(ulTargets, g_ppofi, szSrcPath, szTempFolder,
					UlGetApiPatchOptionFlags(hdbInput), &pod, NULL, NULL);

	while (ulTargets-- > 0)
		{
#ifdef UNICODE
		PATCH_OLD_FILE_INFO_W* ppofi = &(g_ppofi[ulTargets]);
#else
		PATCH_OLD_FILE_INFO_A* ppofi = &(g_ppofi[ulTargets]);
#endif
		Assert(!FEmptySz(ppofi->OldFileName));
		LocalFree((HLOCAL)(ppofi->OldFileName));
		ppofi->OldFileName = szNull;

		LPSTR* psza = &(g_pszaSymPaths[ulTargets]);
		if (*psza != NULL)
			{
			LocalFree((HLOCAL)(*psza));
			*psza = NULL;
			}

		if (ppofi->IgnoreRangeCount > 0)
			{
			Assert(ppofi->IgnoreRangeArray != NULL);
			LocalFree((HLOCAL)(ppofi->IgnoreRangeArray));

			ppofi->IgnoreRangeCount = 0;
			ppofi->IgnoreRangeArray = NULL;
			}

		if (ppofi->RetainRangeCount > 0)
			{
			Assert(ppofi->RetainRangeArray != NULL);
			LocalFree((HLOCAL)(ppofi->RetainRangeArray));

			ppofi->RetainRangeCount = 0;
			ppofi->RetainRangeArray = NULL;
			}
		}

	if (pod.NewFileSymbolPath != NULL)
		{
		LocalFree((HLOCAL)(pod.NewFileSymbolPath));
		pod.NewFileSymbolPath = NULL;
		}

	if (!fRet)
		{
		DWORD dwError = GetLastError();
		Assert(dwError == ERROR_PATCH_ENCODE_FAILURE
					|| dwError == ERROR_PATCH_BIGGER_THAN_COMPRESSED
					|| dwError == ERROR_EXTENDED_ERROR); // Retain/Ignore Range problems
		Assert(dwError != ERROR_PATCH_INVALID_OPTIONS);
		Assert(dwError != ERROR_PATCH_SAME_FILE);
		Assert(dwError != ERROR_PATCH_RETAIN_RANGES_DIFFER);
		Assert(dwError != ERROR_PATCH_IMAGEHLP_FAILURE);

		if (dwError == ERROR_PATCH_BIGGER_THAN_COMPRESSED)
			return (IDS_OKAY);

		return (UiLogError(ERROR_PCW_CANT_CREATE_ONE_PATCH_FILE, szSrcPath, szTempFolder));
		}


	Assert(lstrlen(szTempFolder) < MAX_PATH);
	TCHAR rgchPatchFile[MAX_PATH];
	lstrcpy(rgchPatchFile, szTempFolder);

	wsprintf(szTempFName, TEXT("%05i.HDR"), iFileSeqNum);
	Assert(!FFileExist(szTempFolder));

	Assert(FFileExist(rgchPatchFile));
	EvalAssert( ExtractPatchHeaderToFile(rgchPatchFile, szTempFolder) );
	Assert(FFileExist(szTempFolder));

	return (IDS_OKAY);
}


/* ********************************************************************** */
static void LogAndIgnoreRetainRangeMismatches ( ULONG ulTargets, LPTSTR szFamily, LPTSTR szFTK )
{
	Assert(ulTargets > 0);
	Assert(ulTargets < 256);
	Assert(ulTargets <= g_cpofiMax);
	Assert(!FEmptySz(szFamily));
	Assert(!FEmptySz(szFTK));

	ULONG ulSav = ulTargets;
	ULONG RetainRangeCountFirst = (g_ppofi[0]).RetainRangeCount;

	while (ulTargets-- > 0)
		{
#ifdef UNICODE
		PATCH_OLD_FILE_INFO_W* ppofi = &(g_ppofi[ulTargets]);
#else
		PATCH_OLD_FILE_INFO_A* ppofi = &(g_ppofi[ulTargets]);
#endif

		if (ppofi->RetainRangeCount != RetainRangeCountFirst)
			{
			EvalAssert( FSprintfToLog(TEXT("  Mismatch in RetainRangeCounts - ignoring them: Family=%s; FTK=%s."), szFamily, szFTK, szEmpty, szEmpty) );
			while (ulSav-- > 0)
				{
				ppofi = &(g_ppofi[ulSav]);

				if (ppofi->RetainRangeCount > 0)
					{
					Assert(ppofi->RetainRangeArray != NULL);
					LocalFree((HLOCAL)(ppofi->RetainRangeArray));

					ppofi->RetainRangeCount = 0;
					ppofi->RetainRangeArray = NULL;
					}
				}
			return;
			}
		}
}


static UINT IdsFillSymPaths ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static LPCSTR SzaGetUpgradedSymPaths ( LPTSTR szFTK )
{
	Assert(!FEmptySz(szFTK));

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szFamily));

	TCHAR rgchSymPaths[MAX_PATH*10];
	*rgchSymPaths = TEXT('\0');

	TCHAR rgchWhere[64];
	wsprintf(rgchWhere, TEXT("`Family` = '%s'"), g_szFamily);
	UINT ids = IdsMsiEnumTable(g_hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`"), rgchWhere, IdsFillSymPaths,
					(LPARAM)rgchSymPaths, (LPARAM)szFTK);
	Assert(ids == IDS_OKAY);

	LPCSTR szaRet = NULL;
	if (!FEmptySz(rgchSymPaths))
		{
		szaRet = SzaDupSz(rgchSymPaths);
		Assert(szaRet != NULL);
		Assert(*szaRet != '\0');
		}

	return (szaRet);
}


/* ********************************************************************** */
static UINT IdsFillSymPaths ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	LPTSTR szSymPaths = (LPTSTR)(lp1);
	Assert(szSymPaths != szNull);

	LPTSTR szFTK = (LPTSTR)lp2;
	Assert(!FEmptySz(szFTK));

	Assert(g_hdbInput != NULL);

	TCHAR rgchTarget[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTarget));

	EvalAssert( FCatSymPath(g_hdbInput, rgchTarget, szFTK, szSymPaths, MAX_PATH*10, fFalse) );

	return (IDS_OKAY);
}


static UINT IdsResolveSrcFilePathFtk ( MSIHANDLE hdb, LPTSTR szBuf, LPTSTR szFtk, BOOL fLfn, LPTSTR szFullSubFolder );

#ifdef UNICODE
static void FillIgnoreRangeArray ( PATCH_OLD_FILE_INFO_W* ppofi, int cRanges, LPTSTR szOffsets, LPTSTR szLengths );
static void FillRetainRangeArray ( PATCH_OLD_FILE_INFO_W* ppofi, int cRanges, LPTSTR szOldOffsets, LPTSTR szNewOffsets, LPTSTR szLengths );
#else
static void FillIgnoreRangeArray ( PATCH_OLD_FILE_INFO_A* ppofi, int cRanges, LPTSTR szOffsets, LPTSTR szLengths );
static void FillRetainRangeArray ( PATCH_OLD_FILE_INFO_A* ppofi, int cRanges, LPTSTR szOldOffsets, LPTSTR szNewOffsets, LPTSTR szLengths );
#endif

/* ********************************************************************** */
static UINT IdsFillG_pofi ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	ULONG* pulTargets = (ULONG*)(lp1);
	Assert(pulTargets != NULL);
	Assert(*pulTargets >= 0);

	LPTSTR szFTK = (LPTSTR)lp2;
	Assert(!FEmptySz(szFTK));

	Assert(g_ppofi != NULL);
	Assert(g_pszaSymPaths != NULL);
	Assert(g_cpofiMax > 0);
	Assert(g_cpofiMax < 256);
	Assert(*pulTargets < g_cpofiMax);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szFamily));

	TCHAR rgchSrcRoot[MAX_PATH+MAX_PATH];
	DWORD dwcch = MAX_PATH+MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 2, rgchSrcRoot, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchSrcRoot));
	Assert(FFileExist(rgchSrcRoot));

	TCHAR rgchLFN[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 3, rgchLFN, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchLFN));
	Assert(!lstrcmp(rgchLFN, TEXT("Yes")) || !lstrcmp(rgchLFN, TEXT("No")));
	BOOL fLfn = (*rgchLFN == TEXT('Y'));

#define rgchTargetImage rgchLFN // reuse buffer
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 1, rgchTargetImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTargetImage));

	MSIHANDLE hdbTargetImage = HdbReopenMsi(g_hdbInput, rgchTargetImage, fFalse, fFalse);
	Assert(hdbTargetImage != NULL);
#undef rgchTargetImage

	uiRet = IdsResolveSrcFilePathFtk(hdbTargetImage,
				SzFindFilenameInPath(rgchSrcRoot), szFTK, fLfn, szNull);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(SzFindFilenameInPath(rgchSrcRoot)));
	Assert(FFileExist(rgchSrcRoot));

	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbTargetImage) );

#ifdef UNICODE
	PATCH_OLD_FILE_INFO_W* ppofi = &(g_ppofi[*pulTargets]);
	Assert(ppofi != NULL);
	Assert(ppofi->SizeOfThisStruct == sizeof(PATCH_OLD_FILE_INFO_W));
#else
	PATCH_OLD_FILE_INFO_A* ppofi = &(g_ppofi[*pulTargets]);
	Assert(ppofi != NULL);
	Assert(ppofi->SizeOfThisStruct == sizeof(PATCH_OLD_FILE_INFO_A));
#endif
	Assert(ppofi->OldFileName == szNull);
	Assert(ppofi->IgnoreRangeCount == 0);
	Assert(ppofi->IgnoreRangeArray == NULL);
	Assert(ppofi->RetainRangeCount == 0);
	Assert(ppofi->RetainRangeArray == NULL);

	ppofi->OldFileName = SzDupSz(rgchSrcRoot);
	Assert(!FEmptySz(ppofi->OldFileName));

	TCHAR rgchTarget[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTarget));

#define rgchSymPaths  rgchSrcRoot // reuse buffer
	*rgchSymPaths = TEXT('\0');
	EvalAssert( FCatSymPath(g_hdbInput, rgchTarget, szFTK, rgchSymPaths, MAX_PATH+MAX_PATH, fTrue) );

	if (!FEmptySz(rgchSymPaths))
		{
		LPSTR* psza = &(g_pszaSymPaths[*pulTargets]);
		*psza = SzaDupSz(rgchSymPaths);
		Assert(*psza != NULL);
		Assert(**psza != '\0');
		}
#undef rgchSymPaths

	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("`Target`='%s' AND `FTK`='%s'"), rgchTarget, szFTK);

	int cIgnoreRanges;
	uiRet = IdsMsiGetTableIntegerWhere(g_hdbInput, TEXT("`TargetFiles_OptionalData`"),
				TEXT("`IgnoreCount`"), rgchWhere, &cIgnoreRanges);
	Assert(uiRet == MSI_OKAY);

#define rgchIgnoreOffsets  rgchSrcRoot // reuse buffer
	if (cIgnoreRanges > 0)
		{
		uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`TargetFiles_OptionalData`"),
					TEXT("`IgnoreOffsets`"), rgchWhere, rgchIgnoreOffsets, MAX_PATH);
		Assert(uiRet == MSI_OKAY);
		Assert(!FEmptySz(rgchIgnoreOffsets));

		TCHAR rgchIgnoreLengths[MAX_PATH];
		uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`TargetFiles_OptionalData`"),
					TEXT("`IgnoreLengths`"), rgchWhere, rgchIgnoreLengths, MAX_PATH);
		Assert(uiRet == MSI_OKAY);
		Assert(!FEmptySz(rgchIgnoreLengths));

		FillIgnoreRangeArray(ppofi, cIgnoreRanges, rgchIgnoreOffsets, rgchIgnoreLengths);

		Assert(ppofi->IgnoreRangeCount == (ULONG)cIgnoreRanges);
		Assert(ppofi->IgnoreRangeArray != NULL);
		}
#undef rgchIgnoreOffsets

#define rgchRetainOldOffsets  rgchSrcRoot // reuse buffer
	uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`TargetFiles_OptionalData`"),
				TEXT("`RetainOffsets`"), rgchWhere, rgchRetainOldOffsets, MAX_PATH);
	Assert(uiRet == MSI_OKAY);
	if (!FEmptySz(rgchRetainOldOffsets))
		{
		wsprintf(rgchWhere, TEXT("`Family`='%s' AND `FTK`='%s'"), g_szFamily, szFTK);
		
		int cRetainRanges;
		uiRet = IdsMsiGetTableIntegerWhere(g_hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainCount`"), rgchWhere, &cRetainRanges);
		Assert(uiRet == MSI_OKAY);
		Assert(cRetainRanges > 0);

		TCHAR rgchRetainNewOffsets[MAX_PATH];
		uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainOffsets`"), rgchWhere, rgchRetainNewOffsets, MAX_PATH);
		Assert(uiRet == MSI_OKAY);
		Assert(!FEmptySz(rgchRetainNewOffsets));

		TCHAR rgchRetainLengths[MAX_PATH];
		uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainLengths`"), rgchWhere, rgchRetainLengths, MAX_PATH);
		Assert(uiRet == MSI_OKAY);
		Assert(!FEmptySz(rgchRetainLengths));

		FillRetainRangeArray(ppofi, cRetainRanges, rgchRetainOldOffsets, rgchRetainNewOffsets, rgchRetainLengths);

		Assert(ppofi->RetainRangeCount == (ULONG)cRetainRanges);
		Assert(ppofi->RetainRangeArray != NULL);
		}
#undef rgchRetainOldOffsets

	(*pulTargets)++;

	return (IDS_OKAY);
}


/* ********************************************************************** */
static UINT IdsFillG_pofiForExtFile ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	ULONG* pulTargets = (ULONG*)(lp1);
	Assert(pulTargets != NULL);
	Assert(*pulTargets >= 0);

	LPTSTR szFTK = (LPTSTR)(lp2);
	Assert(!FEmptySz(szFTK));

	Assert(g_ppofi != NULL);
	Assert(g_pszaSymPaths != NULL);
	Assert(g_cpofiMax > 0);
	Assert(g_cpofiMax < 256);
	Assert(*pulTargets < g_cpofiMax);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szFamily));

	TCHAR rgchSrcRoot[MAX_PATH+MAX_PATH];
	DWORD dwcch = MAX_PATH+MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchSrcRoot, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchSrcRoot));
	Assert(FFileExist(rgchSrcRoot));

#ifdef UNICODE
	PATCH_OLD_FILE_INFO_W* ppofi = &(g_ppofi[*pulTargets]);
	Assert(ppofi != NULL);
	Assert(ppofi->SizeOfThisStruct == sizeof(PATCH_OLD_FILE_INFO_W));
#else
	PATCH_OLD_FILE_INFO_A* ppofi = &(g_ppofi[*pulTargets]);
	Assert(ppofi != NULL);
	Assert(ppofi->SizeOfThisStruct == sizeof(PATCH_OLD_FILE_INFO_A));
#endif
	Assert(ppofi->OldFileName == szNull);
	Assert(ppofi->IgnoreRangeCount == 0);
	Assert(ppofi->IgnoreRangeArray == NULL);
	Assert(ppofi->RetainRangeCount == 0);
	Assert(ppofi->RetainRangeArray == NULL);

	ppofi->OldFileName = SzDupSz(rgchSrcRoot);
	Assert(!FEmptySz(ppofi->OldFileName));

#define rgchSymPaths  rgchSrcRoot // reuse buffer
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchSymPaths, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);

	if (!FEmptySz(rgchSymPaths))
		{
		LPSTR* psza = &(g_pszaSymPaths[*pulTargets]);
		*psza = SzaDupSz(rgchSymPaths);
		Assert(*psza != NULL);
		Assert(**psza != '\0');
		}
#undef rgchSymPaths

#define rgchIgnoreOffsets  rgchSrcRoot // reuse buffer
	int cIgnoreRanges = MsiRecordGetInteger(hrec, 3);
	if (cIgnoreRanges > 0)
		{
		dwcch = MAX_PATH+MAX_PATH;
		uiRet = MsiRecordGetString(hrec, 4, rgchIgnoreOffsets, &dwcch);
		Assert(uiRet != ERROR_MORE_DATA);
		Assert(uiRet == IDS_OKAY);
		Assert(!FEmptySz(rgchIgnoreOffsets));

		TCHAR rgchIgnoreLengths[MAX_PATH];
		dwcch = MAX_PATH;
		uiRet = MsiRecordGetString(hrec, 5, rgchIgnoreLengths, &dwcch);
		Assert(uiRet != ERROR_MORE_DATA);
		Assert(uiRet == IDS_OKAY);
		Assert(!FEmptySz(rgchIgnoreLengths));

		FillIgnoreRangeArray(ppofi, cIgnoreRanges, rgchIgnoreOffsets, rgchIgnoreLengths);

		Assert(ppofi->IgnoreRangeCount == (ULONG)cIgnoreRanges);
		Assert(ppofi->IgnoreRangeArray != NULL);
		}
#undef rgchIgnoreOffsets

#define rgchRetainOldOffsets  rgchSrcRoot // reuse buffer
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 6, rgchRetainOldOffsets, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	if (!FEmptySz(rgchRetainOldOffsets))
		{
		TCHAR rgchWhere[MAX_PATH];
		wsprintf(rgchWhere, TEXT("`Family`='%s' AND `FTK`='%s'"), g_szFamily, szFTK);
		
		int cRetainRanges;
		uiRet = IdsMsiGetTableIntegerWhere(g_hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainCount`"), rgchWhere, &cRetainRanges);
		Assert(uiRet == MSI_OKAY);
		Assert(cRetainRanges > 0);

		TCHAR rgchRetainNewOffsets[MAX_PATH];
		uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainOffsets`"), rgchWhere, rgchRetainNewOffsets, MAX_PATH);
		Assert(uiRet == MSI_OKAY);
		Assert(!FEmptySz(rgchRetainNewOffsets));

		TCHAR rgchRetainLengths[MAX_PATH];
		uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainLengths`"), rgchWhere, rgchRetainLengths, MAX_PATH);
		Assert(uiRet == MSI_OKAY);
		Assert(!FEmptySz(rgchRetainLengths));

		FillRetainRangeArray(ppofi, cRetainRanges, rgchRetainOldOffsets, rgchRetainNewOffsets, rgchRetainLengths);

		Assert(ppofi->RetainRangeCount == (ULONG)cRetainRanges);
		Assert(ppofi->RetainRangeArray != NULL);
		}
#undef rgchRetainOldOffsets

	(*pulTargets)++;

	return (IDS_OKAY);
}


/* ********************************************************************** */
#ifdef UNICODE
static void FillIgnoreRangeArray ( PATCH_OLD_FILE_INFO_W* ppofi, int cRanges, LPTSTR szOffsets, LPTSTR szLengths )
#else
static void FillIgnoreRangeArray ( PATCH_OLD_FILE_INFO_A* ppofi, int cRanges, LPTSTR szOffsets, LPTSTR szLengths )
#endif
{
	Assert(ppofi != NULL);
	Assert(cRanges > 0);
	Assert(cRanges < 256);
	Assert(!FEmptySz(szOffsets));
	Assert(!FEmptySz(szLengths));

	Assert(ppofi->IgnoreRangeCount == 0);
	Assert(ppofi->IgnoreRangeArray == NULL);

	ppofi->IgnoreRangeArray = (_PATCH_IGNORE_RANGE*)LocalAlloc(LPTR, sizeof(_PATCH_IGNORE_RANGE)*cRanges);
	Assert(ppofi->IgnoreRangeArray != NULL);
	ppofi->IgnoreRangeCount = cRanges;

	_PATCH_IGNORE_RANGE* ppir = ppofi->IgnoreRangeArray;
	for (int i = 0; i < cRanges; i++, ppir++)
		{
		Assert(!FEmptySz(szOffsets));
		ULONG ulOffset = UlGetRangeElement(&szOffsets);
		Assert(ulOffset != (ULONG)(-1));

		Assert(!FEmptySz(szLengths));
		ULONG ulLength = UlGetRangeElement(&szLengths);
		Assert(ulLength != (ULONG)(-1));
		Assert(ulLength > 0);

		ppir->OffsetInOldFile = ulOffset;
		ppir->LengthInBytes   = ulLength;
		}
}


/* ********************************************************************** */
#ifdef UNICODE
static void FillRetainRangeArray ( PATCH_OLD_FILE_INFO_W* ppofi, int cRanges, LPTSTR szOldOffsets, LPTSTR szNewOffsets, LPTSTR szLengths )
#else
static void FillRetainRangeArray ( PATCH_OLD_FILE_INFO_A* ppofi, int cRanges, LPTSTR szOldOffsets, LPTSTR szNewOffsets, LPTSTR szLengths )
#endif
{
	Assert(ppofi != NULL);
	Assert(cRanges > 0);
	Assert(cRanges < 256);
	Assert(!FEmptySz(szOldOffsets));
	Assert(!FEmptySz(szNewOffsets));
	Assert(!FEmptySz(szLengths));

	Assert(ppofi->RetainRangeCount == 0);
	Assert(ppofi->RetainRangeArray == NULL);

	ppofi->RetainRangeArray = (_PATCH_RETAIN_RANGE*)LocalAlloc(LPTR, sizeof(_PATCH_RETAIN_RANGE)*cRanges);
	Assert(ppofi->RetainRangeArray != NULL);
	ppofi->RetainRangeCount = cRanges;

	_PATCH_RETAIN_RANGE* ppir = ppofi->RetainRangeArray;
	for (int i = 0; i < cRanges; i++, ppir++)
		{
		Assert(!FEmptySz(szOldOffsets));
		ULONG ulOldOffset = UlGetRangeElement(&szOldOffsets);
		Assert(ulOldOffset != (ULONG)(-1));

		Assert(!FEmptySz(szNewOffsets));
		ULONG ulNewOffset = UlGetRangeElement(&szNewOffsets);
		Assert(ulNewOffset != (ULONG)(-1));

		Assert(!FEmptySz(szLengths));
		ULONG ulLength = UlGetRangeElement(&szLengths);
		Assert(ulLength != (ULONG)(-1));
		Assert(ulLength > 0);

		ppir->OffsetInOldFile = ulOldOffset;
		ppir->OffsetInNewFile = ulNewOffset;
		ppir->LengthInBytes   = ulLength;
		}
}


/* ********************************************************************** */
static BOOL FCatSymPath ( MSIHANDLE hdb, LPTSTR szImage, LPTSTR szFTK, LPTSTR szBuf, UINT cch, BOOL fTarget )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szImage));
	Assert(!FEmptySz(szFTK));
	Assert(szBuf != szNull);
	Assert(cch >= MAX_PATH);

	LPTSTR szTail = szBuf;
	if (!FEmptySz(szBuf))
		{
		Assert(!fTarget);
		lstrcat(szBuf, TEXT(";"));
		szTail += lstrlen(szBuf);
		cch -= lstrlen(szBuf);
		Assert(cch >= 64);
		}

	TCHAR rgchWhere[128];
	wsprintf(rgchWhere, TEXT("`%s` = '%s' AND `FTK` = '%s'"), (fTarget) ? TEXT("Target") : TEXT("Upgraded"), szImage, szFTK);
	EvalAssert( IDS_OKAY == IdsMsiGetTableStringWhere(hdb, (fTarget) ? TEXT("`TargetFiles_OptionalData`") : TEXT("`UpgradedFiles_OptionalData`"),
					TEXT("`SymbolPaths`"), rgchWhere, szTail, cch) );

	if (!FEmptySz(szTail))
		{
		lstrcat(szTail, TEXT(";"));
		cch -= lstrlen(szTail);
		Assert(cch >= 64);
		szTail += lstrlen(szTail);
		}
	wsprintf(rgchWhere, TEXT("`%s` = '%s'"), (fTarget) ? TEXT("Target") : TEXT("Upgraded"), szImage);
	EvalAssert( IDS_OKAY == IdsMsiGetTableStringWhere(hdb, (fTarget) ? TEXT("`TargetImages`") : TEXT("`UpgradedImages`"),
					TEXT("`SymbolPaths`"), rgchWhere, szTail, cch) );

	if (!FEmptySz(szBuf) && *(szTail = SzLastChar(szBuf)) == TEXT(';'))
		*szTail = TEXT('\0');

	return (fTrue);
}


/* ********************************************************************** */
static UINT IdsResolveSrcFilePathFtk ( MSIHANDLE hdb, LPTSTR szBuf, LPTSTR szFtk, BOOL fLfn, LPTSTR szFullSubFolder )
{
	Assert(hdb != NULL);
	Assert(szBuf != szNull);
	Assert(!FEmptySz(szFtk));

	TCHAR rgchComponent[MAX_PATH] = {0};
	UINT  uiRet = IdsMsiGetTableString(hdb, TEXT("`File`"), TEXT("`File`"),
					TEXT("`Component_`"), szFtk, rgchComponent, MAX_PATH);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchComponent));

	TCHAR rgchFName[MAX_PATH] = {0};
	uiRet = IdsMsiGetTableString(hdb, TEXT("`File`"), TEXT("`File`"),
					TEXT("`FileName`"), szFtk, rgchFName, MAX_PATH);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFName));

	uiRet = IdsResolveSrcFilePathSzs(hdb, szBuf, rgchComponent,
						rgchFName, fLfn, szFullSubFolder);
	Assert(uiRet == IDS_OKAY);

	return (uiRet);
}


/* ********************************************************************** */
static void GetFileSizeSz ( LPTSTR szFile, DWORD* pdwHi, DWORD* pdwLow )
{
	Assert(!FEmptySz(szFile));
	Assert(FFileExist(szFile));
	Assert(pdwHi  != NULL);
	Assert(pdwLow != NULL);

	HANDLE hf = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ,
				NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	Assert(hf != INVALID_HANDLE_VALUE);

	DWORD dwHi = 0L, dwLow = 0L;
	dwLow = GetFileSize(hf, &dwHi);
	Assert(dwLow != 0xffffffff || GetLastError() == NO_ERROR);
	CloseHandle(hf);

	*pdwHi  += dwHi;
	*pdwLow += dwLow;
}


/* ********************************************************************** */
static UINT IdsUpdateMsiForNewSeqNum ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec != NULL);

	LPTSTR szFTK = (LPTSTR)(lp1);
	Assert(!FEmptySz(szFTK));

	int iSeqNumNew = (int)(lp2);
	Assert(iSeqNumNew > 1);
	Assert(iSeqNumNew < 32767);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szFamily));

	TCHAR rgchTargetImage[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchTargetImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTargetImage));

	MSIHANDLE hdbCopyOfUpgradedImage = HdbReopenMsi(g_hdbInput, rgchTargetImage, fFalse, fTrue);
	Assert(hdbCopyOfUpgradedImage != NULL);

	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

#ifdef DEBUG
	wsprintf(g_szTempFName, TEXT("%s\\%05i.PAT"), g_szFamily, iSeqNumNew);
	BOOL fPatExist = FFileExist(g_szTempFolder);
	wsprintf(g_szTempFName, TEXT("%s\\%05i.HDR"), g_szFamily, iSeqNumNew);
	BOOL fHdrExist = FFileExist(g_szTempFolder);
	wsprintf(g_szTempFName, TEXT("%s\\%05i.FLE"), g_szFamily, iSeqNumNew);
	BOOL fFleExist = FFileExist(g_szTempFolder);

	Assert(fPatExist == fHdrExist);
	Assert(fPatExist || fFleExist);
	Assert(!fPatExist || !fFleExist);
#endif /* DEBUG */

	wsprintf(g_szTempFName, TEXT("%s\\%05i.PAT"), g_szFamily, iSeqNumNew);
	if (FFileExist(g_szTempFolder))
		{
		DWORD dwHi = 0L, dwLow = 0L;
		GetFileSizeSz(g_szTempFolder, &dwHi, &dwLow);
		Assert(dwHi == 0L);
		Assert(dwLow <= 2147483647L);

		int iPatchSize = (int)dwLow;
		Assert((DWORD)(iPatchSize) == dwLow);

#define rgchUpgradedImage rgchTargetImage  // reuse buffer
		dwcch = 64;
		uiRet = MsiRecordGetString(hrec, 2, rgchUpgradedImage, &dwcch);
		Assert(uiRet != ERROR_MORE_DATA);
		Assert(uiRet == IDS_OKAY);
		Assert(!FEmptySz(rgchUpgradedImage));

		TCHAR rgchWhere[MAX_PATH];
		wsprintf(rgchWhere, TEXT("`Upgraded` = '%s' AND `FTK` = '%s'"),
					rgchUpgradedImage, szFTK);
#undef rgchUpgradedImage
		
		int iAttributes;
		EvalAssert( IDS_OKAY == IdsMsiGetTableIntegerWhere(g_hdbInput,
						TEXT("`UpgradedFiles_OptionalData`"),
						TEXT("`AllowIgnoreOnPatchError`"), rgchWhere, &iAttributes) );
		if (iAttributes != 0)
			iAttributes = 1;

		wsprintf(g_szTempFName, TEXT("%s\\%05i.HDR"), g_szFamily, iSeqNumNew);
		Assert(FFileExist(g_szTempFolder));

		//
		// OLE has a stream name limitation of 31 characters (32 if you include '\0'). The Installer can support up to 62
		//  characters due to a special compression algorithm. But, the limit is easily reached when attempting to generate
		//  the stream name for the Patch.Header column as the stream name formula is:
		//			"{table}" + "." + "{primary key 1}" [+ "." + "{primary key 2}" + ...]"
		//
		// Packages built using merge modules more commonly see this problem due to the merge module naming convention for
		//  primary keys.  To guarantee uniqueness, the primary keys are generally very lengthy. In the case of the Patch
		//  table, the stream name is:
		//			"Patch" + "." + szFTK + "." + sequence
		//
		// To get around this limit, the MsiPatchHeaders table is used. The header is written to the MsiPatchHeaders table
		//  using a primary key that is an autogenerated Guid.  The total concatenation in this case comes well under the
		//  62 character limit. A link is made to the MsiPatchHeaders table via the Patch.StreamRef_ column.
		//
		// Since the MsiPatchHeaders table will only work with Windows Installer version 2.0 or later, the table is only
		//  used in those cases that warrant it.  In all other cases, backwards compatible patches will be created.
		//

		TCHAR szSeqNum[MAX_PATH] = {0};
		wsprintf(szSeqNum, TEXT("%d"), iSeqNumNew);
		int cchStreamName = lstrlen(TEXT("Patch")) + lstrlen(TEXT(".")) + lstrlen(szFTK) + lstrlen(TEXT(".")) + lstrlen(szSeqNum);
		if (cchStreamName > cchMaxStreamName)
			{
				//
				// must use MsiPatchHeaders table
				//

				if (!g_bUsedMsiPatchHeadersTable)
					{
						//
						// this is the first time we've encountered this, ask the user if s/he wants to continue; patch can only
						// work with Windows Installer version 2.0 or greater
						//

						int iMinimumMsiVersion = 100;
						EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyInteger(g_hdbInput, TEXT("MinimumRequiredMsiVersion"), &iMinimumMsiVersion) );

						if (iMinMsiPatchHeadersVersion <= iMinimumMsiVersion)
							{
								FWriteLogFile(TEXT("  Patch header stream name limitation reached. Continuing creation since .PCP authored to require a minimum Windows Installer version that supports the new format -.\r\n"));
							}
						else if (IDNO == IMessageBoxIds(HdlgStatus(), IDS_STREAM_NAME_LIMIT_REACHED, MB_YESNO | MB_ICONQUESTION))
							{
								FWriteLogFile(TEXT("  Patch header stream name limitation reached. File table key was too long and user did not want to create a patch that requires Windows Installer version 2.0 or later - .\r\n"));
								return IDS_CANCEL;
							}
						else
							{
								FWriteLogFile(TEXT("  Patch header stream name limitation reached. User chose to bypass limit by creating a patch that requires Windows Installer version 2.0 or later.\r\n"));
							}
					}

				GUID guidKey;
				EvalAssert( S_OK == ::CoCreateGuid(&guidKey) );
				TCHAR szPHK[cchMaxGuid] = {0};
				wsprintf(szPHK, TEXT("_%08lX_%04X_%04x_%02X%02X_%02X%02X%02X%02X%02X%02X"), guidKey.Data1, guidKey.Data2, guidKey.Data3,
							guidKey.Data4[0], guidKey.Data4[1], guidKey.Data4[2], guidKey.Data4[3], guidKey.Data4[4], guidKey.Data4[5], guidKey.Data4[6], guidKey.Data4[7]);

				MSIHANDLE hrecPatch = MsiCreateRecord(6);
				Assert(hrecPatch != NULL);
				EvalAssert( MSI_OKAY == MsiRecordClearData(hrecPatch) );
				EvalAssert( MSI_OKAY == MsiRecordSetString( hrecPatch, 1, szFTK) );
				EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrecPatch, 2, iSeqNumNew) );
				EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrecPatch, 3, iPatchSize) );
				EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrecPatch, 4, iAttributes) );
				// field 5 is left NULL
				EvalAssert( MSI_OKAY == MsiRecordSetString( hrecPatch, 6, szPHK) );

				EvalAssert( IDS_OKAY == IdsMsiSetTableRecord(hdbCopyOfUpgradedImage, TEXT("`Patch`"),
								TEXT("`File_`,`Sequence`,`PatchSize`,`Attributes`,`Header`,`StreamRef_`"),
								TEXT("`File_`"), szFTK, hrecPatch) );

				MSIHANDLE hrecPatchHeader = MsiCreateRecord(2);
				Assert(hrecPatchHeader != NULL);
				EvalAssert( MSI_OKAY == MsiRecordSetString( hrecPatchHeader, 1, szPHK) );
				EvalAssert( MSI_OKAY == MsiRecordSetStream( hrecPatchHeader, 2, g_szTempFolder) );

				EvalAssert( IDS_OKAY == IdsMsiSetTableRecord(hdbCopyOfUpgradedImage, TEXT("`MsiPatchHeaders`"),
								TEXT("`StreamRef`,`Header`"),
								TEXT("`StreamRef`"), szPHK, hrecPatchHeader) );

				g_bUsedMsiPatchHeadersTable = TRUE;
			}
		else
			{
				//
				// normal Patch table should work
				//

				MSIHANDLE hrecPatch = MsiCreateRecord(6);
				Assert(hrecPatch != NULL);
				EvalAssert( MSI_OKAY == MsiRecordClearData(hrecPatch) );
				EvalAssert( MSI_OKAY == MsiRecordSetString( hrecPatch, 1, szFTK) );
				EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrecPatch, 2, iSeqNumNew) );
				EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrecPatch, 3, iPatchSize) );
				EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrecPatch, 4, iAttributes) );
				EvalAssert( MSI_OKAY == MsiRecordSetStream( hrecPatch, 5, g_szTempFolder) );
				// field 6 is left NULL

				EvalAssert( IDS_OKAY == IdsMsiSetTableRecord(hdbCopyOfUpgradedImage, TEXT("`Patch`"),
								TEXT("`File_`,`Sequence`,`PatchSize`,`Attributes`,`Header`,`StreamRef_`"),
								TEXT("`File_`"), szFTK, hrecPatch) );
			}
		}
	else
		{
		EvalAssert( IDS_OKAY == IdsMsiUpdateTableRecordInt(hdbCopyOfUpgradedImage,
						TEXT("File"), TEXT("Sequence"), iSeqNumNew,
						TEXT("File"), szFTK) );
		int iAttributes;
		EvalAssert( IDS_OKAY == IdsMsiGetTableInteger(hdbCopyOfUpgradedImage,
						TEXT("`File`"), TEXT("`File`"),
						TEXT("`Attributes`"), szFTK, &iAttributes) );
		if (iAttributes == MSI_NULL_INTEGER)
			iAttributes = 0;
#define msidbFileAttributesPatchAdded      0x00001000
#define msidbFileAttributesNoncompressed   0x00002000
		iAttributes |= msidbFileAttributesPatchAdded;
		iAttributes &= ~msidbFileAttributesNoncompressed;
		EvalAssert( IDS_OKAY == IdsMsiUpdateTableRecordInt(hdbCopyOfUpgradedImage,
						TEXT("File"), TEXT("Attributes"), iAttributes,
						TEXT("File"), szFTK) );
		}

	EvalAssert( MSI_OKAY == MsiDatabaseCommit(hdbCopyOfUpgradedImage) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbCopyOfUpgradedImage) );

	return (IDS_OKAY);
}


#define PATCH_OPTION_DEFAULT  (PATCH_OPTION_USE_LZX_BEST + PATCH_OPTION_FAIL_IF_BIGGER)
#define PATCH_OPTION_DEFAULT_LARGE (PATCH_OPTION_DEFAULT + PATCH_OPTION_USE_LZX_LARGE)
#define PATCH_SYMBOL_DEFAULT  0x00000000

/* ********************************************************************** */
static ULONG UlGetApiPatchFlags ( MSIHANDLE hdbInput, BOOL fOption )
{
	Assert(hdbInput != NULL);

	TCHAR rgch[64];
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					(fOption) ? TEXT("OptimizePatchSizeForLargeFiles") : TEXT("ApiPatchingSymbolFlags"),
					rgch, 64) );

	if (FEmptySz(rgch) && fOption)
		return (PATCH_OPTION_DEFAULT);
	if (FEmptySz(rgch))
		return (PATCH_SYMBOL_DEFAULT);
	
	Assert(fOption || FValidHexValue(rgch));
	Assert(fOption || FValidApiPatchSymbolFlags(UlFromHexSz(rgch)));

	if (fOption)
		return (lstrcmp(rgch, TEXT("0")) == 0) ? PATCH_OPTION_DEFAULT : PATCH_OPTION_DEFAULT_LARGE;
	else	
		return (UlFromHexSz(rgch));
}




static UINT IdsGenerateTransformsForTargetImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static UINT UiMakeTransforms ( LPTSTR szFamily, int iSequenceNumCur )
{
	Assert(!FEmptySz(szFamily));
	Assert(iSequenceNumCur > 0);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	g_iSeqNumCur = iSequenceNumCur;

	UINT ids = IdsMsiEnumTable(g_hdbInput, TEXT("`TargetImages`"),
					TEXT("`Target`,`Upgraded`,`ProductValidateFlags`"),
					szNull, IdsGenerateTransformsForTargetImage, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	return (ERROR_SUCCESS);
}


/* ********************************************************************** */
static UINT IdsGenerateTransformsForTargetImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);
	Assert(g_iSeqNumCur > 1);

	TCHAR rgchTargetImage[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchTargetImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTargetImage));

	TCHAR rgchUpgradedImage[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 2, rgchUpgradedImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchUpgradedImage));

	MSIHANDLE hdbUpgradedImage = HdbReopenMsi(g_hdbInput, rgchUpgradedImage, fTrue, fFalse);
	Assert(hdbUpgradedImage != NULL);

	MSIHANDLE hdbTargetImage = HdbReopenMsi(g_hdbInput, rgchTargetImage, fFalse, fFalse);
	Assert(hdbTargetImage != NULL);

	MSIHANDLE hdbCopyOfUpgradedImage = HdbReopenMsi(g_hdbInput, rgchTargetImage, fFalse, fTrue);
	Assert(hdbCopyOfUpgradedImage != NULL);

	wsprintf(g_szTempFName, TEXT("%sTo%s.MST"), rgchTargetImage, rgchUpgradedImage);
	// this will fail if transforms are equal -- will that ever happen?
	UINT idsRet = ERROR_PCW_CANT_GENERATE_TRANSFORM;
	uiRet = MsiDatabaseGenerateTransform(hdbUpgradedImage,
					hdbTargetImage, g_szTempFolder, 0, 0);
	Assert(uiRet == MSI_OKAY);
	if (uiRet != MSI_OKAY)
		goto LEarlyReturn;

	TCHAR rgchFlags[32];
	dwcch = 32;
	uiRet = MsiRecordGetString(hrec, 3, rgchFlags, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFlags));

	ULONG ulValidationFlags;
	ulValidationFlags = UlFromHexSz(rgchFlags);

#define iSuppressedErrors   (MSITRANSFORM_ERROR_ADDEXISTINGROW | MSITRANSFORM_ERROR_DELMISSINGROW | MSITRANSFORM_ERROR_UPDATEMISSINGROW | MSITRANSFORM_ERROR_ADDEXISTINGTABLE)
	int iValidationFlags;
	iValidationFlags = (int)(LOWORD((DWORD)ulValidationFlags));

	uiRet = MsiCreateTransformSummaryInfo(hdbUpgradedImage,
					hdbTargetImage, g_szTempFolder, iSuppressedErrors,
					iValidationFlags);
	Assert(uiRet == MSI_OKAY);
	idsRet = ERROR_PCW_CANT_CREATE_SUMMARY_INFO;
	if (uiRet != MSI_OKAY)
		goto LEarlyReturn;

	// per Whistler bug 381320, we need to drop the Patch table from the reference database to ensure that the transform has an
	// add table entry for the Patch table. This is only necessary if the Patch table is present in the reference database.
	// This ensures that we can successfully handle the new schema change to bypass the FTK limit (transforms don't handle
	// changes in column nullability gracefully)
	MSICONDITION ePatchTablePresent = MsiDatabaseIsTablePersistent(hdbUpgradedImage, TEXT("Patch"));
	if (MSICONDITION_TRUE == ePatchTablePresent)
		{
		MSIHANDLE hViewPatch = NULL;
		EvalAssert( MSI_OKAY == MsiDatabaseOpenView(hdbUpgradedImage, TEXT("DROP TABLE `Patch`"), &hViewPatch) );
		EvalAssert( MSI_OKAY == MsiViewExecute(hViewPatch, 0) );
		EvalAssert( MSI_OKAY == MsiViewClose(hViewPatch) );
		EvalAssert( MSI_OKAY == MsiCloseHandle(hViewPatch) );
		}

	wsprintf(g_szTempFName, TEXT("#%sTo%s.MST"), rgchTargetImage, rgchUpgradedImage);
	// this will fail if transforms are equal -- will that ever happen?
	uiRet = MsiDatabaseGenerateTransform(hdbCopyOfUpgradedImage,
					hdbUpgradedImage, g_szTempFolder, 0, 0);
	Assert(uiRet == MSI_OKAY);
	idsRet = ERROR_PCW_CANT_GENERATE_TRANSFORM_POUND;
	if (uiRet != MSI_OKAY)
		goto LEarlyReturn;

#define iValidationFlagsMax 0x0927
	uiRet = MsiCreateTransformSummaryInfo(hdbCopyOfUpgradedImage,
					hdbUpgradedImage, g_szTempFolder, iSuppressedErrors,
					iValidationFlags);
	Assert(uiRet == MSI_OKAY);
	idsRet = ERROR_PCW_CANT_CREATE_SUMMARY_INFO_POUND;
	if (uiRet != MSI_OKAY)
		goto LEarlyReturn;

	idsRet = IDS_OKAY;

LEarlyReturn:
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbUpgradedImage) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbTargetImage) );
	EvalAssert( MSI_OKAY == MsiDatabaseCommit(hdbCopyOfUpgradedImage) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbCopyOfUpgradedImage) );

	if (IDS_OKAY != idsRet)
		return (UiLogError(idsRet, NULL, NULL));

	return (idsRet);
}


static BOOL FInitializeDdf   ( LPTSTR szFamily, LPTSTR szTempFolder, LPTSTR szTempFName );
static BOOL FWriteSzToDdf    ( LPTSTR sz );
static void CloseDdf         ( void );
static BOOL FCreateSmallFile ( LPTSTR szPath );
static BOOL FRunMakeCab      ( LPTSTR szFamily, LPTSTR szTempFolder );

/* ********************************************************************** */
static UINT UiCreateCabinet ( LPTSTR szFamily, int iSequenceNumStart, int iSequenceNumCur )
{
	Assert(!FEmptySz(szFamily));
	Assert(iSequenceNumStart > 0);
	Assert(iSequenceNumCur > 0);
	Assert(iSequenceNumCur >= iSequenceNumStart);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	UINT uiRet = ERROR_SUCCESS;
	if (!FInitializeDdf(szFamily, g_szTempFolder, g_szTempFName))
		uiRet = ERROR_PCW_CANNOT_WRITE_DDF;

	if (uiRet == ERROR_SUCCESS && iSequenceNumStart >= iSequenceNumCur)
		{
		wsprintf(g_szTempFName, TEXT("%s\\filler"), szFamily);
		if (!FCreateSmallFile(g_szTempFolder) || !FWriteSzToDdf(TEXT("filler filler\r\n")))
			uiRet = ERROR_PCW_CANNOT_WRITE_DDF;
		*g_szTempFName = TEXT('\0');
		}

	lstrcpy(g_szTempFName, szFamily);
	lstrcat(g_szTempFName, TEXT("\\"));
	LPTSTR szTail = g_szTempFName + lstrlen(g_szTempFName);
	while (uiRet == ERROR_SUCCESS && iSequenceNumStart < iSequenceNumCur)
		{
		wsprintf(szTail, TEXT("%05i.FLE"), iSequenceNumStart);
		if (!FFileExist(g_szTempFolder))
			{
			wsprintf(szTail, TEXT("%05i.HDR"), iSequenceNumStart);
			Assert(FFileExist(g_szTempFolder));
			wsprintf(szTail, TEXT("%05i.PAT"), iSequenceNumStart);
			Assert(FFileExist(g_szTempFolder));
			}

		TCHAR rgchDdfLine[MAX_PATH+MAX_PATH];
		wsprintf(rgchDdfLine, TEXT("`SequenceNum` = %i AND `Family` = '%s'"),
					iSequenceNumStart, szFamily);

		TCHAR rgchFTK[MAX_PATH];
		EvalAssert( IDS_OKAY == IdsMsiGetTableStringWhere(g_hdbInput,
						TEXT("`NewSequenceNums`"), TEXT("`FTK`"), rgchDdfLine,
						rgchFTK, MAX_PATH) );
		Assert(!FEmptySz(rgchFTK));

		wsprintf(rgchDdfLine, TEXT("%s %s\r\n"), szTail, rgchFTK);
		if (!FWriteSzToDdf(rgchDdfLine))
			uiRet = ERROR_PCW_CANNOT_WRITE_DDF;
		iSequenceNumStart++;
		}
	CloseDdf();

	if (uiRet == ERROR_SUCCESS)
		{
		*g_szTempFName = TEXT('\0');
		if (!FRunMakeCab(szFamily, g_szTempFolder))
			return (UiLogError(ERROR_PCW_CANNOT_RUN_MAKECAB, szNull, szNull));

		return (ERROR_SUCCESS);
		}

	Assert(uiRet == ERROR_PCW_CANNOT_WRITE_DDF);

	return (UiLogError(uiRet, szNull, szNull));
}


static HANDLE g_hfDdf = INVALID_HANDLE_VALUE;

#define WriteDDF(sz)  if (!FWriteSzToDdf(sz)) { fRet=fFalse; }

/* ********************************************************************** */
static BOOL FInitializeDdf ( LPTSTR szFamily, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(!FEmptySz(szFamily));
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);

	Assert(g_hfDdf == INVALID_HANDLE_VALUE);

	lstrcpy(szTempFName, szFamily);
	lstrcat(szTempFName, TEXT(".DDF"));
	Assert(!FFileExist(szTempFolder));
	Assert(!FFolderExist(szTempFolder));

	g_hfDdf = CreateFile(szTempFolder, GENERIC_WRITE, 0, NULL,
				CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (g_hfDdf == INVALID_HANDLE_VALUE)
		return (fFalse);

	BOOL fRet = fTrue;

	WriteDDF(TEXT(".Set DiskDirectoryTemplate=.\r\n"));
	WriteDDF(TEXT(".Set InfFileName=nul\r\n"));
	WriteDDF(TEXT(".Set RptFileName=nul\r\n"));
	WriteDDF(TEXT(".Set Compress=on\r\n"));
	WriteDDF(TEXT(".Set Cabinet=on\r\n"));
	WriteDDF(TEXT(".Set CompressionType=LZX\r\n"));
	WriteDDF(TEXT(".Set MaxDiskSize=0\r\n"));

	TCHAR rgch[MAX_PATH];
	wsprintf(rgch, TEXT(".Set CabinetNameTemplate=%s.CAB\r\n\r\n"), szFamily);
	WriteDDF(rgch);

	*szTempFName = TEXT('\0');
	wsprintf(rgch, TEXT(".Set SourceDir=%s%s\\\r\n\r\n"), szTempFolder, szFamily);
	WriteDDF(rgch);

	return (fRet);
}


/* ********************************************************************** */
static BOOL FWriteSzToDdf ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));
	Assert(g_hfDdf != INVALID_HANDLE_VALUE);

	DWORD dwWritten = 0;
	DWORD dwSize = lstrlen(sz)*sizeof(TCHAR);

	return (WriteFile(g_hfDdf, (LPVOID)sz, dwSize, &dwWritten, NULL) && dwWritten == dwSize);
}


/* ********************************************************************** */
static void CloseDdf ( void )
{
	if (g_hfDdf != INVALID_HANDLE_VALUE)
		{
		CloseHandle(g_hfDdf);
		g_hfDdf = INVALID_HANDLE_VALUE;
		}
}


/* ********************************************************************** */
static BOOL FCreateSmallFile ( LPTSTR szPath )
{
	Assert(!FEmptySz(szPath));
	Assert(!FFileExist(szPath));
	Assert(!FFolderExist(szPath));

	BOOL   fRet  = fTrue;
	HANDLE hfSav = g_hfDdf;
	g_hfDdf = CreateFile(szPath, GENERIC_WRITE, 0, NULL,
				CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (g_hfDdf == INVALID_HANDLE_VALUE || !FWriteSzToDdf(TEXT("filler")))
		fRet = fFalse;
	CloseDdf();

	g_hfDdf = hfSav;

	return (fRet);
}


/* ********************************************************************** */
static BOOL FRunMakeCab ( LPTSTR szFamily, LPTSTR szTempFolder )
{
	Assert(!FEmptySz(szFamily));
	Assert(!FEmptySz(szTempFolder));
	Assert(*SzLastChar(szTempFolder) == TEXT('\\'));

	TCHAR rgchCmdLine[MAX_PATH+20];
	wsprintf(rgchCmdLine, TEXT("MAKECAB.EXE /f %s.DDF"), szFamily);

	STARTUPINFO si;
	si.cb               = sizeof(si);
	si.lpReserved       = NULL;
	si.lpDesktop        = NULL;
	si.lpTitle          = NULL;
	si.dwX              = 0;
	si.dwY              = 0;
	si.dwXSize          = 0;
	si.dwYSize          = 0;
	si.dwXCountChars    = 0;
	si.dwYCountChars    = 0;
	si.dwFillAttribute  = 0;
	si.dwFlags          = STARTF_FORCEONFEEDBACK | STARTF_USESHOWWINDOW;
	si.wShowWindow      = SW_SHOW;
	si.cbReserved2      = 0;
	si.lpReserved2      = NULL;

	PROCESS_INFORMATION pi;
	if (!CreateProcess(NULL, rgchCmdLine, NULL, NULL, FALSE,
				NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE, NULL,
				szTempFolder, &si, &pi))
		{
		return (fFalse);
		}

	DWORD dw = WaitForSingleObject(pi.hProcess, INFINITE);
	CloseHandle(pi.hThread);

	if (dw == WAIT_FAILED
			|| !GetExitCodeProcess(pi.hProcess, &dw)
			|| dw != 0)
		{
		Assert(CloseHandle(pi.hProcess));
		return (fFalse);
		}

	return (fTrue);
}


static UINT IdsStuffFamilyCabs ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsStuffTargetMsts ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static UINT UiStuffCabsAndMstsIntoPackage ( MSIHANDLE hdbInput, LPTSTR szPatchPath )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szPatchPath));
	Assert(!FFileExist(szPatchPath));

	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	MSIHANDLE hdbPackage;
	UINT ids = MsiOpenDatabase(szPatchPath,
					MSIDBOPEN_CREATEDIRECT + MSIDBOPEN_PATCHFILE, &hdbPackage);
	if (ids != MSI_OKAY)
		return (UiLogError(ERROR_PCW_CANT_CREATE_PATCH_FILE, szPatchPath, NULL));
	Assert(hdbPackage != NULL);

	ids = IdsMsiEnumTable(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), szNull, IdsStuffFamilyCabs,
					(LPARAM)hdbPackage, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	Assert(iOrderMax > 0);
	ids = IdsMsiEnumTable(hdbInput, TEXT("`TargetImages`"),
					TEXT("`Target`,`Upgraded`"), TEXT("`Target`<>'' ORDER BY `Order`"),
					IdsStuffTargetMsts, (LPARAM)hdbPackage, (LPARAM)hdbInput);
	if (ids != IDS_OKAY)
		return (ids);

	EvalAssert( MSI_OKAY == MsiDatabaseCommit(hdbPackage) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbPackage) );

	return (ERROR_SUCCESS);
}


static UINT UiStuffFileIntoStream  ( LPTSTR szFile, LPTSTR szStream,  MSIHANDLE hdbPackage );
static UINT UiStuffFileIntoStorage ( LPTSTR szFile, LPTSTR szStorage, MSIHANDLE hdbPackage );

/* ********************************************************************** */
static UINT IdsStuffFamilyCabs ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	MSIHANDLE hdbPackage = (MSIHANDLE)lp1;
	Assert(hdbPackage != NULL);

	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	TCHAR rgchFamily[32];
	DWORD dwcch = 32;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchFamily, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFamily));

	wsprintf(g_szTempFName, TEXT("%s.CAB"), rgchFamily);
	Assert(FFileExist(g_szTempFolder));

	TCHAR rgchStreamName[32];
	wsprintf(rgchStreamName, TEXT("PCW_CAB_%s"), rgchFamily);

	return (UiStuffFileIntoStream(g_szTempFolder, rgchStreamName, hdbPackage));
}


static void AppendStorageNamesToProp ( MSIHANDLE hdbInput, LPTSTR szStorage );

/* ********************************************************************** */
static UINT IdsStuffTargetMsts ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	MSIHANDLE hdbPackage = (MSIHANDLE)lp1;
	Assert(hdbPackage != NULL);

	MSIHANDLE hdbInput = (MSIHANDLE)lp2;
	Assert(hdbInput != NULL);

	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	TCHAR rgchTarget[32];
	DWORD dwcch = 32;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTarget));

	TCHAR rgchUpgraded[32];
	dwcch = 32;
	uiRet = MsiRecordGetString(hrec, 2, rgchUpgraded, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchUpgraded));

	TCHAR rgchStorageName[64];
	wsprintf(rgchStorageName, TEXT("#%sTo%s"), rgchTarget, rgchUpgraded);

	AppendStorageNamesToProp(hdbInput, rgchStorageName);

	wsprintf(g_szTempFName, TEXT("%s.MST"), rgchStorageName+1);
	Assert(FFileExist(g_szTempFolder));

	UINT ui = UiStuffFileIntoStorage(g_szTempFolder, rgchStorageName+1, hdbPackage);
	if (ui != ERROR_SUCCESS)
		return (ui);

	wsprintf(g_szTempFName, TEXT("%s.MST"), rgchStorageName);
	Assert(FFileExist(g_szTempFolder));

	return (UiStuffFileIntoStorage(g_szTempFolder, rgchStorageName, hdbPackage));
}


/* ********************************************************************** */
static UINT UiStuffFileIntoStream ( LPTSTR szFile, LPTSTR szStream, MSIHANDLE hdbPackage )
{
	Assert(!FEmptySz(szFile));
	Assert(FFileExist(szFile));
	Assert(!FEmptySz(szStream));
	Assert(lstrlen(szStream) < 64);
	Assert(hdbPackage != NULL);

	MSIHANDLE hrecNew = MsiCreateRecord(2);
	Assert(hrecNew != NULL);
	EvalAssert( MSI_OKAY == MsiRecordSetString( hrecNew, 1, szStream) );
	EvalAssert( MSI_OKAY == MsiRecordSetStream( hrecNew, 2, szFile) );

	EvalAssert( IDS_OKAY == IdsMsiSetTableRecord(hdbPackage, TEXT("`_Streams`"),
						TEXT("`Name`,`Data`"), TEXT("`Name`"), szStream, hrecNew) );

	return (IDS_OKAY);
}


/* ********************************************************************** */
static UINT UiStuffFileIntoStorage ( LPTSTR szFile, LPTSTR szStorage, MSIHANDLE hdbPackage )
{
	Assert(!FEmptySz(szFile));
	Assert(FFileExist(szFile));
	Assert(!FEmptySz(szStorage));
	Assert(lstrlen(szStorage) < 64);
	Assert(hdbPackage != NULL);

	MSIHANDLE hrecNew = MsiCreateRecord(2);
	Assert(hrecNew != NULL);
	EvalAssert( MSI_OKAY == MsiRecordSetString( hrecNew, 1, szStorage) );
	EvalAssert( MSI_OKAY == MsiRecordSetStream( hrecNew, 2, szFile) );

	EvalAssert( IDS_OKAY == IdsMsiSetTableRecord(hdbPackage, TEXT("`_Storages`"),
						TEXT("`Name`,`Data`"), TEXT("`Name`"), szStorage, hrecNew) );

	return (IDS_OKAY);
}


/* ********************************************************************** */
static void AppendStorageNamesToProp ( MSIHANDLE hdbInput, LPTSTR szStorage )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szStorage));
	Assert(*szStorage == TEXT('#'));

	TCHAR rgch[1024*8] = {0};

	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					TEXT("StorageNamesForMSTs"), rgch, 1024*8) );

	if (!FEmptySz(rgch))
		lstrcat(rgch, TEXT(";"));

	lstrcat(rgch, TEXT(":"));
	lstrcat(rgch, szStorage+1);
	lstrcat(rgch, TEXT(";:"));
	lstrcat(rgch, szStorage);

	EvalAssert( IDS_OKAY == IdsMsiSetPcwPropertyString(hdbInput,
					TEXT("StorageNamesForMSTs"), rgch) );
}


/* ********************************************************************** */
static BOOL FSetPatchPackageSummaryInfo ( MSIHANDLE hdbInput, LPTSTR szPatchPath )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szPatchPath));
	Assert(FFileExist(szPatchPath));

	MSIHANDLE hSummaryInfo = NULL;
	if (MSI_OKAY != MsiGetSummaryInformation(NULL, szPatchPath, 20, &hSummaryInfo))
		return (fFalse);
	Assert(hSummaryInfo != NULL);


	UINT cchBuf, cchCur;
	cchBuf = CchMsiPcwPropertyString(hdbInput, TEXT("PatchGUID"));
	Assert(cchBuf > 0);
	Assert(cchBuf < 50*1024);
	cchCur = CchMsiPcwPropertyString(hdbInput, TEXT("ListOfPatchGUIDsToReplace"));
//	Assert(cchCur > 0);
	Assert(cchCur < 50*1024);
	if (cchCur < 63)
		cchCur = 63;
	cchBuf += cchCur;
	Assert(cchBuf < 50*1024);

	cchCur = CchMsiPcwPropertyString(hdbInput, TEXT("ListOfTargetProductCodes"));
	Assert(cchCur > 0);
	Assert(cchCur < 50*1024);
	if (cchCur > cchBuf)
		cchBuf = cchCur;

	cchCur = CchMsiPcwPropertyString(hdbInput, TEXT("StorageNamesForMSTs"));
	Assert(cchCur > 0);
	Assert(cchCur < 50*1024);
	if (cchCur > cchBuf)
		cchBuf = cchCur;

	cchCur = CchMsiPcwPropertyString(hdbInput, TEXT("PatchSourceList"));
	Assert(cchCur > 0);
	Assert(cchCur < 50*1024);
	if (cchCur > cchBuf)
		cchBuf = cchCur;

	if (cchBuf < 63)
		cchBuf = 64;
	else
		cchBuf++; // for terminating Null char

	LPTSTR szBuf = (LPTSTR)LocalAlloc(LPTR, cchBuf*sizeof(TCHAR));
	Assert(szBuf != szNull);
	if (szBuf == szNull)
		return (fFalse);


	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					TEXT("PatchGUID"), szBuf, cchBuf) );
	Assert(!FEmptySz(szBuf));
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					TEXT("ListOfPatchGUIDsToReplace"), szBuf+lstrlen(szBuf), cchBuf-lstrlen(szBuf)) );
	CharUpper(szBuf);
	if (MSI_OKAY != MsiSummaryInfoSetProperty(hSummaryInfo, PID_REVNUMBER, VT_LPTSTR, 0, NULL, szBuf))
		{
LEarlyReturn:
		EvalAssert( NULL == LocalFree((HLOCAL)szBuf) );
		return (fFalse);
		}

	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					TEXT("ListOfTargetProductCodes"), szBuf, cchBuf) );
	Assert(!FEmptySz(szBuf));
	CharUpper(szBuf);
	if (MSI_OKAY != MsiSummaryInfoSetProperty(hSummaryInfo, PID_TEMPLATE, VT_LPTSTR, 0, NULL, szBuf))
		goto LEarlyReturn;

	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					TEXT("StorageNamesForMSTs"), szBuf, cchBuf) );
	Assert(!FEmptySz(szBuf));
	if (MSI_OKAY != MsiSummaryInfoSetProperty(hSummaryInfo, PID_LASTAUTHOR, VT_LPTSTR, 0, NULL, szBuf))
		goto LEarlyReturn;

	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					TEXT("PatchSourceList"), szBuf, cchBuf) );
	Assert(!FEmptySz(szBuf));
	if (MSI_OKAY != MsiSummaryInfoSetProperty(hSummaryInfo, PID_KEYWORDS, VT_LPTSTR, 0, NULL, szBuf))
		goto LEarlyReturn;

	EvalAssert( NULL == LocalFree((HLOCAL)szBuf) );

	int iWordCount = UlGetApiPatchOptionFlags(hdbInput) == PATCH_OPTION_DEFAULT_LARGE ? 2 : 1;

	int iMinimumMsiVersion = 100;
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyInteger(hdbInput, TEXT("MinimumRequiredMsiVersion"), &iMinimumMsiVersion) );

	if (iMinimumMsiVersion >= iWindowsInstallerME && iMinimumMsiVersion < iWindowsInstallerXP)
		iWordCount = 2;
	if (iMinimumMsiVersion >= iWindowsInstallerXP || g_bUsedMsiPatchHeadersTable)
		iWordCount = 3;

	if (MSI_OKAY != MsiSummaryInfoSetProperty(hSummaryInfo, PID_WORDCOUNT, VT_I4, iWordCount, NULL, NULL))
		return (fFalse);

	if (MSI_OKAY != MsiSummaryInfoPersist(hSummaryInfo))
		return (fFalse);

	EvalAssert( MSI_OKAY == MsiCloseHandle(hSummaryInfo) );

	return (fTrue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\patchwiz\msistuff.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//--------------------------------------------------------------------------

  /* MSISTUFF.CPP -- MSI stuff */

#pragma warning (disable:4553)

#include "patchdll.h"

EnableAsserts

#define iSchemaMin  0
#define iSchemaMax  1

enum pteEnum // Patch table enum
	{
	pteFirstEnum,
	ptePatch,
	ptePatchPackage,
	pteMsiPatchHeaders,
	pteNextEnum
	};

int iOrderMax = 0;

static BOOL g_fValidateProductCodeIncluded = FALSE;

static BOOL FValidSummInfoVersion   ( LPTSTR szPcp, INT iMin, INT iMax );
static BOOL FValidateInputMsiSchema ( MSIHANDLE hdb );
static BOOL FAddColumnToTable       ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, BOOL fSz, BOOL fTemporary );

/* ********************************************************************** */
UINT UiOpenInputPcp ( LPTSTR szPcpPath, LPTSTR szTempFldrBuf, LPTSTR szTempFName, MSIHANDLE* phdbInput )
{
	Assert(!FEmptySz(szPcpPath));

	TCHAR rgchPcpPath[MAX_PATH];
	EvalAssert( FFixupPathEx(szPcpPath, rgchPcpPath) );

	Assert(FFileExist(rgchPcpPath));
	Assert(!FEmptySz(szTempFldrBuf));
	Assert(szTempFName != szNull);
	Assert(phdbInput != NULL);
	
	*phdbInput = NULL;
	if (FEmptySz(rgchPcpPath) || !FFileExist(rgchPcpPath))
		return (UiLogError(ERROR_PCW_PCP_DOESNT_EXIST, rgchPcpPath, NULL));

	lstrcpy(szTempFName, TEXT("inputcpy.pcp"));
	if (FFileExist(szTempFldrBuf))
		SetFileAttributes(szTempFldrBuf, FILE_ATTRIBUTE_NORMAL);

	EvalAssert( CopyFile(rgchPcpPath, szTempFldrBuf, fFalse) );
	// CopyFile preserves FILE_ATTRIBUTE_READONLY so we'll remove it from our copy
	SetFileAttributes(szTempFldrBuf, FILE_ATTRIBUTE_NORMAL); 

	if (!FValidSummInfoVersion(szTempFldrBuf, iSchemaMin, iSchemaMax))
		return (UiLogError(ERROR_PCW_PCP_BAD_FORMAT, rgchPcpPath, NULL));

	MSIHANDLE hdb;
	UINT ui = MsiOpenDatabase(szTempFldrBuf, MSIDBOPEN_DIRECT, &hdb);
	if (ui != MSI_OKAY)
		return (UiLogError(ERROR_PCW_PCP_BAD_FORMAT, rgchPcpPath, NULL));

#define STRING     fTrue
#define INTEGER    fFalse
#define TEMPORARY  fTrue
#define PERSIST    fFalse
	if (!FValidateInputMsiSchema(hdb)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`LFN`"),             STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`ProductCode`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`ProductVersion`"),  STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`UpgradeCode`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`PackageCode`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`SummSubject`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`SummComments`"),    STRING,  PERSIST)

			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`LFN`"),             STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`ProductCode`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`ProductVersion`"),  STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`UpgradeCode`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`PackageCode`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`Family`"),          STRING,  TEMPORARY)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`MsiPathUpgradedCopy`"), STRING,  TEMPORARY)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`Attributes`"),      INTEGER, TEMPORARY)

			|| !FAddColumnToTable(hdb, TEXT("`FamilyFileRanges`"), TEXT("`RetainCount`"),     INTEGER, TEMPORARY)

			|| !FAddColumnToTable(hdb, TEXT("`ExternalFiles`"),    TEXT("`IgnoreCount`"),     INTEGER, TEMPORARY)
			|| !FAddColumnToTable(hdb, TEXT("`TargetFiles_OptionalData`"), TEXT("`IgnoreCount`"),     INTEGER, TEMPORARY)

			|| !FExecSqlCmd(hdb, TEXT("CREATE TABLE `NewSequenceNums` ( `Family` CHAR(13) NOT NULL, `FTK` CHAR(128) NOT NULL, `SequenceNum` INTEGER NOT NULL PRIMARY KEY `Family`, `FTK` )"))

			|| !FExecSqlCmd(hdb, TEXT("CREATE TABLE `TempPackCodes`   ( `PackCode`  CHAR(63) NOT NULL PRIMARY KEY `PackCode` )"))

			|| !FExecSqlCmd(hdb, TEXT("CREATE TABLE `TempImageNames`  ( `ImageName` CHAR(63) NOT NULL PRIMARY KEY `ImageName` )"))
					)
		{
		MsiCloseHandle(hdb);
		return (UiLogError(ERROR_PCW_PCP_BAD_FORMAT, szTempFldrBuf, NULL));
		}

	*phdbInput = hdb;

	return (ERROR_SUCCESS);
}


/* ********************************************************************** */
static BOOL FValidSummInfoVersion ( LPTSTR szPcp, INT iMin, INT iMax )
{
	Assert(!FEmptySz(szPcp));
	Assert(FFileExist(szPcp));
	Assert(iMin >= 0);
	Assert(iMin <= iMax);

	MSIHANDLE hSummaryInfo = NULL;
	UINT uiRet = MsiGetSummaryInformation(NULL, szPcp, 0, &hSummaryInfo);
	if (uiRet != MSI_OKAY || hSummaryInfo == NULL)
		return (fFalse);

	UINT uiType;
	INT  intRet;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_PAGECOUNT, &uiType, &intRet, NULL, NULL, NULL);
	if (uiRet != MSI_OKAY || (uiType != VT_I4 && uiType != VT_EMPTY))
		return (fFalse);
	if (uiType == VT_EMPTY)
		intRet = 0;

	EvalAssert( MsiCloseHandle(hSummaryInfo) == MSI_OKAY );

	return (intRet >= iMin && intRet <= iMax);
}


/* ********************************************************************** */
static BOOL FAddColumnToTable ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, BOOL fSz, BOOL fTemporary )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szColumn));

	TCHAR rgchQuery[MAX_PATH];
	StringCchPrintf(rgchQuery, sizeof(rgchQuery)/sizeof(TCHAR), TEXT("ALTER TABLE %s ADD %s %s"), szTable, szColumn, (fSz) ? TEXT("CHAR(32)") : TEXT("INTEGER"));

//	if (fTemporary)
//		lstrcat(rgchQuery, TEXT(" TEMPORARY"));

	MSIHANDLE hview = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		AssertFalse();
		return (fFalse);
		}

	UINT ids = MsiViewExecute(hview, 0);
	EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */
	Assert(ids == IDS_OKAY);

	return (ids == IDS_OKAY);
}



/* Generic Table stuff */

/* return value does NOT include terminating null; zero if error */
/* ********************************************************************** */
UINT CchMsiTableString ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szPKey, LPTSTR szFieldName, LPTSTR szPKeyValue )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szPKey));
	Assert(!FEmptySz(szFieldName));
	Assert(!FEmptySz(szPKeyValue));

	const TCHAR szWhereSzPattern[] = TEXT("%s = '%s'");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szWhereSzPattern) + lstrlen(szPKey) + lstrlen(szPKeyValue) + 1;
	LPTSTR rgchWhere = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchWhere)
		return IDS_OOM;

	// don't use StringCchPrintf because of 1024 buffer length limitation
	lstrcpy(rgchWhere, szPKey);
	lstrcat(rgchWhere, TEXT(" = '"));
	lstrcat(rgchWhere, szPKeyValue);
	lstrcat(rgchWhere, TEXT("'"));

	UINT idsRet = CchMsiTableStringWhere(hdb, szTable, szFieldName, rgchWhere);

	EvalAssert( NULL == LocalFree((HLOCAL)rgchWhere) );

	return (idsRet);
}


/* return value does NOT include terminating null; zero if error */
/* ********************************************************************** */
UINT CchMsiTableStringWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFieldName, LPTSTR szWhere )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szFieldName));
	Assert(!FEmptySz(szWhere));

	UINT cchBufNeeded = 0;

	static const TCHAR szSelectWherePattern[] = TEXT("SELECT %s FROM %s WHERE %s");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szSelectWherePattern) + lstrlen(szTable) + lstrlen(szFieldName) + lstrlen(szWhere) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return IDS_OOM;

	// don't use StringCchPrintf because of 1024 buffer length limitation
	lstrcpy(rgchQuery, TEXT("SELECT "));
	lstrcat(rgchQuery, szFieldName);
	lstrcat(rgchQuery, TEXT(" FROM "));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT(" WHERE "));
	lstrcat(rgchQuery, szWhere);

	MSIHANDLE hview = NULL;
	MSIHANDLE hrec  = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		goto LEarlyReturn;

	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		goto LEarlyReturn;

	UINT uiRet;
	uiRet = MsiViewFetch(hview, &hrec);
	if (uiRet == ERROR_NO_MORE_ITEMS)
		goto LEarlyReturn;
	else if (uiRet != MSI_OKAY)
		goto LEarlyReturn;

	TCHAR rgchBuf[1];
	DWORD dwcch;
	dwcch = 0;
	uiRet = MsiRecordGetString(hrec, 1, rgchBuf, &dwcch);
	Assert(uiRet != MSI_OKAY);
	if (uiRet == ERROR_MORE_DATA)
		{
		Assert(dwcch < 50*1024);
		cchBufNeeded = (UINT)dwcch;
		}

LEarlyReturn:
	if (hrec != NULL)
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (cchBufNeeded);
}


/* ********************************************************************** */
UINT IdsMsiGetTableString ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szPKey, LPTSTR szFieldName, LPTSTR szPKeyValue, LPTSTR szBuf, UINT cch )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szPKey));
	Assert(!FEmptySz(szFieldName));
	Assert(!FEmptySz(szPKeyValue));
	Assert(szBuf != szNull);
	Assert(cch > 1);

	const TCHAR szWhereSzPattern[] = TEXT("%s = '%s'");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szWhereSzPattern) + lstrlen(szPKey) + lstrlen(szPKeyValue) + 1;
	LPTSTR rgchWhere = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchWhere)
		return IDS_OOM;

	// don't use StringCchPrintf because of 1024 buffer length limitation
	lstrcpy(rgchWhere, szPKey);
	lstrcat(rgchWhere, TEXT(" = '"));
	lstrcat(rgchWhere, szPKeyValue);
	lstrcat(rgchWhere, TEXT("'"));

	UINT idsRet = IdsMsiGetTableStringWhere(hdb, szTable, szFieldName, rgchWhere, szBuf, cch);

	EvalAssert( NULL == LocalFree((HLOCAL)rgchWhere) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiGetTableStringWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFieldName, LPTSTR szWhere, LPTSTR szBuf, UINT cch )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szFieldName));
	Assert(!FEmptySz(szWhere));
	Assert(szBuf != szNull);
	Assert(cch > 1);

	*szBuf = TEXT('\0');

	UINT idsRet = IDS_OKAY;

	const TCHAR szSelectWherePattern[] = TEXT("SELECT %s FROM %s WHERE %s");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szSelectWherePattern) + lstrlen(szFieldName) + lstrlen(szTable) + lstrlen(szWhere) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return IDS_OOM;

	// don't use StringCchPrintf because of 1024 buffer length limitation
	lstrcpy(rgchQuery, TEXT("SELECT "));
	lstrcat(rgchQuery, szFieldName);
	lstrcat(rgchQuery, TEXT(" FROM "));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT(" WHERE "));
	lstrcat(rgchQuery, szWhere);

	MSIHANDLE hview = NULL;
	MSIHANDLE hrec  = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		idsRet = IDS_CANT_OPEN_VIEW;
		goto LEarlyReturn;
		}

	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		{
		idsRet = IDS_CANT_EXECUTE_VIEW;
		goto LEarlyReturn;
		}

	UINT uiRet;
	uiRet = MsiViewFetch(hview, &hrec);
	if (uiRet == ERROR_NO_MORE_ITEMS)
		goto LEarlyReturn;
	else if (uiRet != MSI_OKAY)
		{
		idsRet = IDS_CANT_FETCH_RECORD;
		goto LEarlyReturn;
		}

	DWORD dwcch;
	dwcch = (DWORD)cch;
	uiRet = MsiRecordGetString(hrec, 1, szBuf, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		idsRet = IDS_BUFFER_IS_TOO_SHORT;
	else if (uiRet != MSI_OKAY)
		idsRet = IDS_CANT_GET_RECORD_FIELD;

LEarlyReturn:
	if (hrec != NULL)
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiGetTableInteger ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szPKey, LPTSTR szFieldName, LPTSTR szPKeyValue, int * pi )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szPKey));
	Assert(!FEmptySz(szFieldName));
	Assert(!FEmptySz(szPKeyValue));
	Assert(pi != NULL);

	const TCHAR szWherePattern[] = TEXT("%s = '%s'");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szWherePattern) + lstrlen(szPKey) + lstrlen(szPKeyValue) + 1;
	LPTSTR rgchWhere = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchWhere)
		return IDS_OOM;

	// don't use StringCchPrintf due to 1024 buffer limitation
	lstrcpy(rgchWhere, szPKey);
	lstrcat(rgchWhere, TEXT(" = '"));
	lstrcat(rgchWhere, szPKeyValue);
	lstrcat(rgchWhere, TEXT("'"));

	UINT idsRet = IdsMsiGetTableIntegerWhere(hdb, szTable, szFieldName, rgchWhere, pi);

	EvalAssert( NULL == LocalFree((HLOCAL)rgchWhere) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiGetTableIntegerWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFieldName, LPTSTR szWhere, int * pi )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szFieldName));
	Assert(!FEmptySz(szWhere));
	Assert(pi != NULL);

	*pi = 0;

	UINT idsRet = IDS_OKAY;

	const TCHAR szSelectQuery[] = TEXT("SELECT %s FROM %s WHERE %s");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szSelectQuery) + lstrlen(szFieldName) + lstrlen(szTable) + lstrlen(szWhere) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return IDS_OOM;

	// don't use StringCchPrintf due to 1024 buffer limitation
	lstrcpy(rgchQuery, TEXT("SELECT "));
	lstrcat(rgchQuery, szFieldName);
	lstrcat(rgchQuery, TEXT(" FROM "));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT(" WHERE "));
	lstrcat(rgchQuery, szWhere);

	MSIHANDLE hview = NULL;
	MSIHANDLE hrec  = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		idsRet = IDS_CANT_OPEN_VIEW;
		goto LEarlyReturn;
		}

	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		{
		idsRet = IDS_CANT_EXECUTE_VIEW;
		goto LEarlyReturn;
		}

	UINT uiRet;
	uiRet = MsiViewFetch(hview, &hrec);
	if (uiRet == ERROR_NO_MORE_ITEMS)
		goto LEarlyReturn;
	else if (uiRet != MSI_OKAY)
		{
		idsRet = IDS_CANT_FETCH_RECORD;
		goto LEarlyReturn;
		}

	*pi = MsiRecordGetInteger(hrec, 1);

LEarlyReturn:
	if (hrec != NULL)
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiSetTableRecordWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFields, LPTSTR szWhere, MSIHANDLE hrec )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szFields));
	Assert(!FEmptySz(szWhere));
	Assert(hrec != NULL);

	UINT idsRet = IDS_OKAY;

	const TCHAR szSelectQuery[] = TEXT("SELECT %s FROM %s WHERE %s");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szSelectQuery) + lstrlen(szFields)+ lstrlen(szTable) + lstrlen(szWhere) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return IDS_OOM;

	// avoid StringCchPrintf due to 1024 limitation
	lstrcpy(rgchQuery, TEXT("SELECT "));
	lstrcat(rgchQuery, szFields);
	lstrcat(rgchQuery, TEXT(" FROM "));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT(" WHERE "));
	lstrcat(rgchQuery, szWhere);

	MSIHANDLE hview = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		idsRet = IDS_CANT_OPEN_VIEW;
		goto LEarlyReturn;
		}

	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		{
		idsRet = IDS_CANT_EXECUTE_VIEW;
		goto LEarlyReturn;
		}

	if (MsiViewModify(hview, MSIMODIFY_ASSIGN, hrec) != MSI_OKAY)
		idsRet = IDS_CANT_ASSIGN_RECORD_IN_VIEW;

LEarlyReturn:
	if (hrec != NULL)
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiSetTableRecord ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFields, LPTSTR szPrimaryField, LPTSTR szKey, MSIHANDLE hrec )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szFields));
	Assert(!FEmptySz(szPrimaryField));
	Assert(!FEmptySz(szKey));
	Assert(hrec != NULL);

	const TCHAR szWherePattern[] = TEXT("%s = '%s'");
	UINT cchWhere = 0;

	cchWhere = lstrlen(szWherePattern) + lstrlen(szPrimaryField) + lstrlen(szKey) + 1;
	LPTSTR rgchWhere = (LPTSTR)LocalAlloc(LPTR, cchWhere * sizeof(TCHAR));

	if (!rgchWhere)
		return IDS_OOM;

	// avoid StringCchPrintf due to 1024 limitation
	lstrcpy(rgchWhere, szPrimaryField);
	lstrcat(rgchWhere, TEXT(" = '"));
	lstrcat(rgchWhere, szKey);
	lstrcat(rgchWhere, TEXT("'"));

	UINT idsRet = IdsMsiSetTableRecordWhere(hdb, szTable, szFields, rgchWhere, hrec);

	EvalAssert( NULL == LocalFree((HLOCAL)rgchWhere) );

	return (idsRet);

}


/* ********************************************************************** */
UINT IdsMsiUpdateTableRecordSz ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szValue, LPTSTR szPKeyField, LPTSTR szPKeyValue )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(*szTable != TEXT('`'));
	Assert(!FEmptySz(szField));
	Assert(*szField != TEXT('`'));
	Assert(szValue != szNull);
	Assert(!FEmptySz(szPKeyField));
	Assert(*szPKeyField != TEXT('`'));
	Assert(!FEmptySz(szPKeyValue));

	UINT cchQuery;
	// keep szUpdateSQLPatern for easy understanding of the SQL statement
	static const TCHAR szUpdateSQLPatern[] = TEXT("UPDATE `%s` SET `%s` = '%s' WHERE `%s` = '%s'");

	// TCHAR rgchQuery[MAX_PATH];
	cchQuery =	lstrlen(szUpdateSQLPatern) + 
				(szTable ? lstrlen(szTable) : 0) +
				(szField ? lstrlen(szField) : 0) +
				(szValue ? lstrlen(szValue) : 0) +
				(szPKeyField ? lstrlen(szPKeyField) : 0) +
				(szPKeyValue ? lstrlen(szPKeyValue) : 0) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return IDS_OOM;

	// don't use StringCchPrintf because of 1024 buffer length limitation
	lstrcpy(rgchQuery, TEXT("UPDATE `"));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT("` SET `"));
	lstrcat(rgchQuery, szField);
	lstrcat(rgchQuery, TEXT("` = '"));
	lstrcat(rgchQuery, szValue);
	lstrcat(rgchQuery, TEXT("' WHERE `"));
	lstrcat(rgchQuery, szPKeyField);
	lstrcat(rgchQuery, TEXT("` = '"));
	lstrcat(rgchQuery, szPKeyValue);
	lstrcat(rgchQuery, TEXT("'"));

	UINT idsRet = IDS_OKAY;

	MSIHANDLE hview = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		Assert(hview == NULL);
		idsRet = IDS_CANT_OPEN_VIEW;
		}

	if (hview != NULL && MsiViewExecute(hview, 0) != MSI_OKAY)
		idsRet = IDS_CANT_EXECUTE_VIEW;

	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiUpdateTableRecordInt ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, int iValue, LPTSTR szPKeyField, LPTSTR szPKeyValue )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(*szTable != TEXT('`'));
	Assert(!FEmptySz(szField));
	Assert(*szField != TEXT('`'));
	Assert(!FEmptySz(szPKeyField));
	Assert(*szPKeyField != TEXT('`'));
	Assert(!FEmptySz(szPKeyValue));

	const TCHAR szUpdatePattern[] = TEXT("UPDATE `%s` SET `%s` = %d WHERE `%s` = '%s'");
	UINT cchQuery = 0;

	TCHAR szInt[32] = {0};
	StringCchPrintf(szInt, sizeof(szInt)/sizeof(TCHAR), TEXT("%d"), iValue);

	cchQuery = lstrlen(szUpdatePattern) + lstrlen(szTable) + lstrlen(szField) + lstrlen(szInt) + lstrlen(szPKeyField) + lstrlen(szPKeyValue) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return IDS_OOM;

	// avoid StringCchPrintf due to 1024 buffer limitation
	lstrcpy(rgchQuery, TEXT("UPDATE `"));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT("` SET `"));
	lstrcat(rgchQuery, szField);
	lstrcat(rgchQuery, TEXT("` = "));
	lstrcat(rgchQuery, szInt);
	lstrcat(rgchQuery, TEXT(" WHERE `"));
	lstrcat(rgchQuery, szPKeyField);
	lstrcat(rgchQuery, TEXT("` = '"));
	lstrcat(rgchQuery, szPKeyValue);
	lstrcat(rgchQuery, TEXT("'"));

	UINT idsRet = IDS_OKAY;

	MSIHANDLE hview = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		Assert(hview == NULL);
		idsRet = IDS_CANT_OPEN_VIEW;
		}

	if (hview != NULL && MsiViewExecute(hview, 0) != MSI_OKAY)
		idsRet = IDS_CANT_EXECUTE_VIEW;

	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiUpdateTableRecordIntPkeyInt ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, int iValue, LPTSTR szPKeyField, int iPKeyValue )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(*szTable != TEXT('`'));
	Assert(!FEmptySz(szField));
	Assert(*szField != TEXT('`'));
	Assert(!FEmptySz(szPKeyField));
	Assert(*szPKeyField != TEXT('`'));

	const TCHAR szQueryPattern[] = TEXT("UPDATE `%s SET `%s` = %d WHERE `%s` = %d");
	UINT cchQuery = 0;

	TCHAR szInt1[32] = {0};
	StringCchPrintf(szInt1, sizeof(szInt1)/sizeof(TCHAR), TEXT("%d"), iValue);
	TCHAR szInt2[32] = {0};
	StringCchPrintf(szInt2, sizeof(szInt2)/sizeof(TCHAR), TEXT("%d"), iPKeyValue);

	cchQuery = lstrlen(szQueryPattern) + lstrlen(szTable) + lstrlen(szField) + lstrlen(szInt1) + lstrlen(szPKeyField) + lstrlen(szInt2) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return (IDS_OOM);

	// avoid StringCchPrintf due to 1024 buffer limitation
	lstrcpy(rgchQuery, TEXT("UPDATE `"));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT("` SET `"));
	lstrcat(rgchQuery, szField);
	lstrcat(rgchQuery, TEXT("` = "));
	lstrcat(rgchQuery, szInt1);
	lstrcat(rgchQuery, TEXT(" WHERE `"));
	lstrcat(rgchQuery, szPKeyField);
	lstrcat(rgchQuery, TEXT("` = "));
	lstrcat(rgchQuery, szInt2);

	UINT idsRet = IDS_OKAY;

	MSIHANDLE hview = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		Assert(hview == NULL);
		idsRet = IDS_CANT_OPEN_VIEW;
		}

	if (hview != NULL && MsiViewExecute(hview, 0) != MSI_OKAY)
		idsRet = IDS_CANT_EXECUTE_VIEW;

	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiDeleteTableRecords ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szKey )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szField));
	Assert(!FEmptySz(szKey));

	const TCHAR szWherePattern[] = TEXT("%s = '%s'");
	UINT cchWhere = 0;

	cchWhere = lstrlen(szWherePattern) + lstrlen(szField) + lstrlen(szKey) + 1;
	LPTSTR rgchWhere = (LPTSTR)LocalAlloc(LPTR, cchWhere * sizeof(TCHAR));

	if (!rgchWhere)
		return (IDS_OOM);

	// avoid StringCchPrintf due to 1024 buffer limitation
	lstrcpy(rgchWhere, szField);
	lstrcat(rgchWhere, TEXT(" = '"));
	lstrcat(rgchWhere, szKey);
	lstrcat(rgchWhere, TEXT("'"));

	UINT idsRet = IdsMsiDeleteTableRecordsWhere(hdb, szTable, rgchWhere);

	EvalAssert( NULL == LocalFree((HLOCAL)rgchWhere) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiDeleteTableRecordsWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szWhere )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szWhere));

	const TCHAR szDeletePattern[] = TEXT("DELETE FROM %s WHERE %s");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szDeletePattern) + lstrlen(szTable) + lstrlen(szWhere) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return (IDS_OOM);

	// avoid StringCchPrintf due to 1024 buffer limitation
	lstrcpy(rgchQuery, TEXT("DELETE FROM "));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT(" WHERE "));
	lstrcat(rgchQuery, szWhere);

	MSIHANDLE hview = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		return (IDS_CANT_OPEN_VIEW);

	UINT ids = IDS_OKAY;
	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		ids = IDS_CANT_EXECUTE_VIEW;

	EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (ids);
}


/* ********************************************************************** */
UINT IdsMsiEnumTable ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFields,
			LPTSTR szWhere, PIEMTPROC pIemtProc, LPARAM lp1, LPARAM lp2 )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szFields));
	Assert(pIemtProc != NULL);

	UINT idsRet = IDS_OKAY;

	const TCHAR szEnumQueryPattern[] = TEXT("SELECT %s FROM %s WHERE %s");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szEnumQueryPattern)
				+ lstrlen(szFields)
				+ lstrlen(szTable)
				+ (szWhere ? lstrlen(szWhere) : 0)
				+ 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return (IDS_OOM);

	// avoid StringCchPrintf due to 1024 buffer limitation
	lstrcpy(rgchQuery, TEXT("SELECT "));
	lstrcat(rgchQuery, szFields);
	lstrcat(rgchQuery, TEXT(" FROM "));
	lstrcat(rgchQuery, szTable);
	if (szWhere != szNull)
		{
		lstrcat(rgchQuery, TEXT(" WHERE "));
		lstrcat(rgchQuery, szWhere);
		}

	MSIHANDLE hview = NULL;
	MSIHANDLE hrec  = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		idsRet = IDS_CANT_OPEN_VIEW;
		goto LEarlyReturn;
		}

	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		{
		idsRet = IDS_CANT_EXECUTE_VIEW;
		goto LEarlyReturn;
		}

	UINT uiRet;
	uiRet = MsiViewFetch(hview, &hrec);
	while (uiRet != ERROR_NO_MORE_ITEMS)
		{
		if (uiRet != MSI_OKAY)
			{
			idsRet = IDS_CANT_FETCH_RECORD;
			goto LEarlyReturn;
			}

		idsRet = (*pIemtProc)(hview, hrec, lp1, lp2);
		if (idsRet != IDS_OKAY)
			goto LEarlyReturn;
		
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
		hrec = NULL;
		uiRet = MsiViewFetch(hview, &hrec);
		}

LEarlyReturn:
	if (hrec != NULL)
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiExistTableRecords ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szValue, PBOOL pf )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szValue));
	Assert(pf != pfNull);

	if (*pf != fFalse)
		return (IDS_OKAY);

	if (szField == szNull)
		szField = TEXT("`Component_`");
	Assert(*szField != TEXT('\0'));

	const TCHAR szWherePattern[] = TEXT("WHERE %s = '%s'");
	UINT cchWhere = 0;

	cchWhere = lstrlen(szWherePattern) + lstrlen(szField) + lstrlen(szValue) + 1;
	LPTSTR rgchWhere = (LPTSTR)LocalAlloc(LPTR, cchWhere * sizeof(TCHAR));

	if (!rgchWhere)
		return (IDS_OOM);

	// avoid StringCchPrintf due to 1024 buffer limitation
	lstrcpy(rgchWhere, TEXT("WHERE "));
	lstrcat(rgchWhere, szField);
	lstrcat(rgchWhere, TEXT(" = '"));
	lstrcat(rgchWhere, szValue);
	lstrcat(rgchWhere, TEXT("'"));

	UINT idsRet = IdsMsiExistTableRecordsWhere(hdb, szTable, szField, rgchWhere, pf);

	EvalAssert( NULL == LocalFree((HLOCAL)rgchWhere) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiExistTableRecordsWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szWhere, PBOOL pf )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(szWhere != szNull);
//	Assert(!FEmptySz(szWhere));
	Assert(pf != pfNull);

	if (*pf != fFalse)
		return (IDS_OKAY);

	if (szField == szNull)
		szField = TEXT("`Component_`");
	Assert(*szField != TEXT('\0'));

	const TCHAR szQueryPattern[] = TEXT("SELECT %s FROM %s ");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szQueryPattern) + lstrlen(szField) + lstrlen(szTable) + lstrlen(szWhere) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return (IDS_OOM);

	// avoid StringCchPrintf due to 1024 buffer limitation
	lstrcpy(rgchQuery, TEXT("SELECT "));
	lstrcat(rgchQuery, szField);
	lstrcat(rgchQuery, TEXT(" FROM "));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT(" "));
	lstrcat(rgchQuery, szWhere);

	MSIHANDLE hview = NULL;
	MSIHANDLE hrec  = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
//		AssertFalse(); FSz/IntColumnExists() expects this to fail
		return (IDS_CANT_OPEN_VIEW);
		}

	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		{
		AssertFalse();
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */
		return (IDS_CANT_EXECUTE_VIEW);
		}

	UINT idsRet = IDS_OKAY;
	UINT uiRet;
	uiRet = MsiViewFetch(hview, &hrec);
	if (uiRet != ERROR_NO_MORE_ITEMS)
		{
		if (uiRet != MSI_OKAY)
			idsRet = IDS_CANT_FETCH_RECORD;
		else
			*pf = fTrue;
		}

	if (hrec != NULL)
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	Assert(hview != NULL);
	EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}



/* PROPERTY TABLES */

/* ********************************************************************** */
UINT IdsMsiGetPropertyString ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue, UINT cch )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szName));
	Assert(szValue != szNull);
	Assert(cch > 1);

	return (IdsMsiGetTableString(hdb, TEXT("`Property`"),
			TEXT("`Property`"), TEXT("`Value`"), szName, szValue, cch));
}


/* ********************************************************************** */
UINT IdsMsiSetPropertyString ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szName));
	Assert(!FEmptySz(szValue));

	MSIHANDLE hrec = MsiCreateRecord(2);
	if (hrec == NULL)
		return (IDS_CANT_CREATE_RECORD);

	if (MsiRecordSetString(hrec, 1, szName) != MSI_OKAY
			|| MsiRecordSetString(hrec, 2, szValue) != MSI_OKAY)
		{
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
		return (IDS_CANT_SET_RECORD_FIELD);
		}

	return (IdsMsiSetTableRecord(hdb, TEXT("`Property`"), TEXT("`Property`,`Value`"), TEXT("`Property`"), szName, hrec));
}


/* return value does NOT include terminating null; zero if error */
/* ********************************************************************** */
UINT CchMsiPcwPropertyString ( MSIHANDLE hdb, LPTSTR szName )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szName));

	return (CchMsiTableString(hdb, TEXT("`Properties`"),
			TEXT("`Name`"), TEXT("`Value`"), szName));
}


/* ********************************************************************** */
UINT IdsMsiGetPcwPropertyString ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue, UINT cch )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szName));
	Assert(szValue != szNull);
	Assert(cch > 1);

	return (IdsMsiGetTableString(hdb, TEXT("`Properties`"),
			TEXT("`Name`"), TEXT("`Value`"), szName, szValue, cch));
}


/* ********************************************************************** */
UINT IdsMsiGetPcwPropertyInteger ( MSIHANDLE hdb, LPTSTR szName, int * pi )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szName));
	Assert(pi != (int*)NULL);

	TCHAR rgch[MAX_PATH];
	UINT  idsRet = IdsMsiGetPcwPropertyString(hdb, szName, rgch, sizeof(rgch)/sizeof(TCHAR));
	if (idsRet != IDS_OKAY)
		return (idsRet);

	LPTSTR sz = rgch;

	BOOL fNegative = fFalse;
	if (*sz == TEXT('-'))
		{
		fNegative = fTrue;
		sz = CharNext(sz);
		}
	
	*pi = 0;
	while (*sz != TEXT('\0') && *sz >= TEXT('0') && *sz <= TEXT('9'))
		{
		*pi = (*pi * 10) + (UINT)(*sz - TEXT('0'));
		sz = CharNext(sz);
		}

	if (fNegative)
		*pi = *pi * (-1);

	return (IDS_OKAY);
}


/* ********************************************************************** */
UINT IdsMsiSetPcwPropertyString ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szName));
	Assert(!FEmptySz(szValue));

	MSIHANDLE hrec = MsiCreateRecord(2);
	if (hrec == NULL)
		return (IDS_CANT_CREATE_RECORD);

	if (MsiRecordSetString(hrec, 1, szName) != MSI_OKAY
			|| MsiRecordSetString(hrec, 2, szValue) != MSI_OKAY)
		{
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
		return (IDS_CANT_SET_RECORD_FIELD);
		}

	return (IdsMsiSetTableRecord(hdb, TEXT("`Properties`"), TEXT("`Name`,`Value`"), TEXT("`Name`"), szName, hrec));
}



static BOOL FSzColumnExists     ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, BOOL fMsg );
static BOOL FIntColumnExists    ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, BOOL fMsg );
static BOOL FBinaryColumnExists ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, LPTSTR szPKey, BOOL fMsg );

#define TableExists(szT)  if (!FTableExists(hdb,szT,fTrue))             return (fFalse); szTable = szT
#define SzColExists(szC)  if (!FSzColumnExists(hdb,szTable,szC,fTrue))  return (fFalse)
#define IntColExists(szC) if (!FIntColumnExists(hdb,szTable,szC,fTrue)) return (fFalse)

static BOOL FCopyRecordsFromFileDataToUFOD ( MSIHANDLE hdb );

/* ********************************************************************** */
static BOOL FValidateInputMsiSchema ( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	LPTSTR szTable;

	TableExists (TEXT("Properties"));
	SzColExists (TEXT("Name"));
	SzColExists (TEXT("Value"));

	TableExists (TEXT("ImageFamilies"));
	SzColExists (TEXT("Family"));
	SzColExists (TEXT("MediaSrcPropName"));
	IntColExists(TEXT("MediaDiskId"));
	IntColExists(TEXT("FileSequenceStart"));
	if (!FSzColumnExists(hdb, szTable, TEXT("DiskPrompt"), fFalse))
		{
		if (!FAddColumnToTable(hdb, szTable, TEXT("`DiskPrompt`"), STRING, PERSIST))
			return (fFalse);
		}
	if (!FSzColumnExists(hdb, szTable, TEXT("VolumeLabel"), fFalse))
		{
		if (!FAddColumnToTable(hdb, szTable, TEXT("`VolumeLabel`"), STRING, PERSIST))
			return (fFalse);
		}

	TableExists (TEXT("UpgradedImages"));
	SzColExists (TEXT("Upgraded"));
	SzColExists (TEXT("MsiPath"));
	SzColExists (TEXT("Family"));
	if (!FSzColumnExists(hdb, szTable, TEXT("PatchMsiPath"), fFalse))
		{
		if (!FAddColumnToTable(hdb, szTable, TEXT("`PatchMsiPath`"), STRING, PERSIST))
			return (fFalse);
		}
	if (!FSzColumnExists(hdb, szTable, TEXT("SymbolPaths"), fFalse))
		{
		if (!FAddColumnToTable(hdb, szTable, TEXT("`SymbolPaths`"), STRING, PERSIST))
			return (fFalse);
		}

	TableExists (TEXT("TargetImages"));
	SzColExists (TEXT("Target"));
	SzColExists (TEXT("MsiPath"));
	SzColExists (TEXT("Upgraded"));
	IntColExists(TEXT("Order"));
	SzColExists (TEXT("ProductValidateFlags"));
	if (!FSzColumnExists(hdb, szTable, TEXT("SymbolPaths"), fFalse))
		{
		if (!FAddColumnToTable(hdb, szTable, TEXT("`SymbolPaths`"), STRING, PERSIST))
			return (fFalse);
		}
	if (!FIntColumnExists(hdb, szTable, TEXT("IgnoreMissingSrcFiles"), fFalse))
		{
		if (!FAddColumnToTable(hdb, szTable, TEXT("`IgnoreMissingSrcFiles`"), INTEGER, PERSIST))
			return (fFalse);
		}

	if (FTableExists(hdb, TEXT("ExternalFiles"), fFalse))
		{
		szTable = TEXT("ExternalFiles");
		SzColExists (TEXT("Family"));
		SzColExists (TEXT("FTK"));
		SzColExists (TEXT("FilePath"));
		if (!FIntColumnExists(hdb, szTable, TEXT("Order"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`Order`"), INTEGER, PERSIST))
				return (fFalse);
			}
		if (!FSzColumnExists(hdb, szTable, TEXT("SymbolPaths"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`SymbolPaths`"), STRING, PERSIST))
				return (fFalse);
			}
		if (!FSzColumnExists(hdb, szTable, TEXT("IgnoreOffsets"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`IgnoreOffsets`"), STRING, PERSIST))
				return (fFalse);
			}
		if (!FSzColumnExists(hdb, szTable, TEXT("IgnoreLengths"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`IgnoreLengths`"), STRING, PERSIST))
				return (fFalse);
			}
		if (!FSzColumnExists(hdb, szTable, TEXT("RetainOffsets"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`RetainOffsets`"), STRING, PERSIST))
				return (fFalse);
			}
		}
	else if (!FExecSqlCmd(hdb, TEXT("CREATE TABLE `ExternalFiles` ( `Family` CHAR(13) NOT NULL, `FTK` CHAR(128) NOT NULL, `FilePath` CHAR(128) NOT NULL, `SymbolPaths` CHAR(128), `IgnoreOffsets` CHAR(128), `IgnoreLengths` CHAR(128), `RetainOffsets` CHAR(128), `Order` INTEGER PRIMARY KEY `Family`, `FTK`, `FilePath` )")))
		return (fFalse);

	if (FTableExists(hdb, TEXT("UpgradedFiles_OptionalData"), fFalse))
		{
		szTable = TEXT("UpgradedFiles_OptionalData");
		SzColExists (TEXT("Upgraded"));
		SzColExists (TEXT("FTK"));
		SzColExists (TEXT("SymbolPaths"));
		if (FIntColumnExists(hdb, szTable, TEXT("IgnoreErrors"), fFalse))
			{
#ifdef DEBUG
			OutputDebugString(TEXT("The IgnoreErrors column has been dropped from the UpgradedFiles_OptionalData table; ignoring column in current PCP.  Use 'AllowIgnoreOnPatchError' column."));
#endif /* DEBUG */
			FWriteLogFile(TEXT("  WARNING - ignoring 'IgnoreErrors' column in UpgradedFiles_OptionalData table.\r\n"));
			if (!FIntColumnExists(hdb, szTable, TEXT("AllowIgnoreOnPatchError"), fFalse))
				{
				if (!FAddColumnToTable(hdb, szTable, TEXT("`AllowIgnoreOnPatchError`"), INTEGER, PERSIST))
					return (fFalse);
				}
			}
		else
			IntColExists(TEXT("AllowIgnoreOnPatchError"));
		IntColExists(TEXT("IncludeWholeFile"));
		if (FTableExists(hdb, TEXT("FileData"), fFalse))
			return (fFalse);
		}
	else if (!FExecSqlCmd(hdb, TEXT("CREATE TABLE `UpgradedFiles_OptionalData` ( `Upgraded` CHAR(13) NOT NULL, `FTK` CHAR(128) NOT NULL, `SymbolPaths` CHAR(128), `AllowIgnoreOnPatchError` INTEGER, `IncludeWholeFile` INTEGER PRIMARY KEY `Upgraded`, `FTK` )")))
		return (fFalse);
	else if (FTableExists(hdb, TEXT("FileData"), fFalse))
		{
		szTable = TEXT("FileData");
		SzColExists (TEXT("Upgraded"));
		SzColExists (TEXT("FTK"));
		IntColExists(TEXT("AllowIgnoreOnPatchError"));
		if (!FSzColumnExists(hdb, szTable, TEXT("SymbolPaths"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`SymbolPaths`"), STRING, PERSIST))
				return (fFalse);
			}
		if (!FIntColumnExists(hdb, szTable, TEXT("IncludeWholeFile"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`IncludeWholeFile`"), INTEGER, PERSIST))
				return (fFalse);
			}
		if (!FCopyRecordsFromFileDataToUFOD(hdb))
			return (fFalse);
		if (!FExecSqlCmd(hdb, TEXT("DROP TABLE `FileData`")))
			return (fFalse);
		}

	if (FTableExists(hdb, TEXT("UpgradedFilesToIgnore"), fFalse))
		{
		szTable = TEXT("UpgradedFilesToIgnore");
		SzColExists (TEXT("Upgraded"));
		SzColExists (TEXT("FTK"));
		}
	else if (!FExecSqlCmd(hdb, TEXT("CREATE TABLE `UpgradedFilesToIgnore` ( `Upgraded` CHAR(13) NOT NULL, `FTK` CHAR(128) NOT NULL PRIMARY KEY `Upgraded`, `FTK` )")))
		return (fFalse);

	if (FTableExists(hdb, TEXT("TargetFiles_OptionalData"), fFalse))
		{
		szTable = TEXT("TargetFiles_OptionalData");
		SzColExists (TEXT("Target"));
		SzColExists (TEXT("FTK"));
		SzColExists (TEXT("SymbolPaths"));
		if (!FSzColumnExists(hdb, szTable, TEXT("IgnoreOffsets"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`IgnoreOffsets`"), STRING, PERSIST))
				return (fFalse);
			}
		if (!FSzColumnExists(hdb, szTable, TEXT("IgnoreLengths"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`IgnoreLengths`"), STRING, PERSIST))
				return (fFalse);
			}
		if (!FSzColumnExists(hdb, szTable, TEXT("RetainOffsets"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`RetainOffsets`"), STRING, PERSIST))
				return (fFalse);
			}
		}
	else if (!FExecSqlCmd(hdb, TEXT("CREATE TABLE `TargetFiles_OptionalData` ( `Target` CHAR(13) NOT NULL, `FTK` CHAR(128) NOT NULL, `SymbolPaths` CHAR(128), `IgnoreOffsets` CHAR(128), `IgnoreLengths` CHAR(128), `RetainOffsets` CHAR(128) PRIMARY KEY `Target`, `FTK` )")))
		return (fFalse);

	if (FTableExists(hdb, TEXT("FamilyFileRanges"), fFalse))
		{
		szTable = TEXT("FamilyFileRanges");
		SzColExists (TEXT("Family"));
		SzColExists (TEXT("FTK"));
		SzColExists (TEXT("RetainOffsets"));
		SzColExists (TEXT("RetainLengths"));
		}
	else if (!FExecSqlCmd(hdb, TEXT("CREATE TABLE `FamilyFileRanges` ( `Family` CHAR(13) NOT NULL, `FTK` CHAR(128) NOT NULL, `RetainOffsets` CHAR(128), `RetainLengths` CHAR(128) PRIMARY KEY `Family`, `FTK` )")))
		return (fFalse);

	return (fTrue);
}


/* ********************************************************************** */
BOOL FTableExists ( MSIHANDLE hdb, LPTSTR szTable, BOOL fMsg )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));

	MSIHANDLE hrec;
	UINT ids = MsiDatabaseGetPrimaryKeys(hdb, szTable, &hrec);
	if (ids == IDS_OKAY && hrec != NULL)
		{
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
		return (fTrue);
		}

#ifdef DEBUG
	if (fMsg)
		{
		TCHAR rgch[256];
		StringCchPrintf(rgch, sizeof(rgch)/sizeof(TCHAR), TEXT("Input-Msi is missing a table: '%s'."), szTable);
		OutputDebugString(rgch);
		}
#endif

	return (fFalse);
}


/* ********************************************************************** */
static BOOL FSzColumnExists ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, BOOL fMsg )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szColumn));

	TCHAR rgchTable[MAX_PATH];
	StringCchPrintf(rgchTable, sizeof(rgchTable)/sizeof(TCHAR), TEXT("`%s`"), szTable);

	TCHAR rgchColumn[MAX_PATH];
	StringCchPrintf(rgchColumn, sizeof(rgchColumn)/sizeof(TCHAR), TEXT("`%s`"), szColumn);
	
	BOOL fExist = fFalse;
	UINT ids = IdsMsiExistTableRecords(hdb, rgchTable,
			rgchColumn, TEXT("bogus_value"), &fExist);

#ifdef DEBUG
	if (fMsg && ids != IDS_OKAY)
		{
		TCHAR rgch[256];
		StringCchPrintf(rgch, sizeof(rgch)/sizeof(TCHAR), TEXT("Input-Msi table '%s' is missing a string column: '%s'."), szTable, szColumn);
		OutputDebugString(rgch);
		}
#endif

	return (ids == IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FIntColumnExists ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, BOOL fMsg )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szColumn));

	TCHAR rgchTable[MAX_PATH];
	StringCchPrintf(rgchTable, sizeof(rgchTable)/sizeof(TCHAR), TEXT("`%s`"), szTable);

	TCHAR rgchColumn[MAX_PATH];
	StringCchPrintf(rgchColumn, sizeof(rgchColumn)/sizeof(TCHAR), TEXT("`%s`"), szColumn);
	
	TCHAR rgchWhere[MAX_PATH];
	StringCchPrintf(rgchWhere, sizeof(rgchWhere)/sizeof(TCHAR), TEXT("WHERE `%s` = 7"), szColumn);
	
	BOOL fExist = fFalse;
	UINT ids = IdsMsiExistTableRecordsWhere(hdb, rgchTable,
			rgchColumn, rgchWhere, &fExist);

#ifdef DEBUG
	if (fMsg && ids != IDS_OKAY)
		{
		TCHAR rgch[256];
		StringCchPrintf(rgch, sizeof(rgch)/sizeof(TCHAR), TEXT("Input-Msi table '%s' is missing an integer column: '%s'."), szTable, szColumn);
		OutputDebugString(rgch);
		}
#endif

	return (ids == IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FBinaryColumnExists ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, LPTSTR szPKey, BOOL fMsg )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szColumn));
	Assert(!FEmptySz(szPKey));

	TCHAR rgchTable[MAX_PATH];
	StringCchPrintf(rgchTable, sizeof(rgchTable)/sizeof(TCHAR), TEXT("`%s`"), szTable);

	TCHAR rgchColumn[MAX_PATH];
	StringCchPrintf(rgchColumn, sizeof(rgchColumn)/sizeof(TCHAR), TEXT("`%s`"), szColumn);
	
	
	TCHAR rgchWhere[MAX_PATH];
	StringCchPrintf(rgchWhere, sizeof(rgchWhere)/sizeof(TCHAR), TEXT("WHERE `%s` = 'foo'"), szPKey);
	
	BOOL fExist = fFalse;
	UINT ids = IdsMsiExistTableRecordsWhere(hdb, rgchTable,
			rgchColumn, rgchWhere, &fExist);

#ifdef DEBUG
	if (fMsg && ids != IDS_OKAY)
		{
		TCHAR rgch[256];
		StringCchPrintf(rgch, sizeof(rgch)/sizeof(TCHAR), TEXT("Input-Msi table '%s' is missing a binary column: '%s'."), szTable, szColumn);
		OutputDebugString(rgch);
		}
#endif

	return (ids == IDS_OKAY);
}


static UINT IdsCopyRecordsFromFileDataToUFOD ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FCopyRecordsFromFileDataToUFOD ( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	return (IDS_OKAY == IdsMsiEnumTable(hdb, TEXT("`FileData`"),
				TEXT("`Upgraded`,`FTK`,`SymbolPaths`,`IgnoreErrors`,`IncludeWholeFile`"),
				szNull, IdsCopyRecordsFromFileDataToUFOD, (LPARAM)(hdb), 0L) );
}


/* ********************************************************************** */
static UINT IdsCopyRecordsFromFileDataToUFOD ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	MSIHANDLE hdb = (MSIHANDLE)lp1;
	Assert(hdb != NULL);

	TCHAR rgchUpgradedImage[64];
	DWORD dwcch = 64;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchUpgradedImage, &dwcch);
	if (uiRet != MSI_OKAY || FEmptySz(rgchUpgradedImage))
		return (IDS_CANCEL);

	TCHAR rgchFTK[128];
	dwcch = 128;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	if (uiRet != MSI_OKAY || FEmptySz(rgchFTK))
		return (IDS_CANCEL);

	TCHAR rgchSymbolPaths[MAX_PATH+MAX_PATH];
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchSymbolPaths, &dwcch);
	if (uiRet != MSI_OKAY)
		return (IDS_CANCEL);

	TCHAR rgchIgnoreErrors[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 4, rgchIgnoreErrors, &dwcch);
	if (uiRet != MSI_OKAY || FEmptySz(rgchIgnoreErrors))
		return (IDS_CANCEL);

	TCHAR rgchIncludeWholeFile[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 5, rgchIncludeWholeFile, &dwcch);
	if (uiRet != MSI_OKAY)
		return (IDS_CANCEL);
	if (FEmptySz(rgchIncludeWholeFile))
		lstrcpy(rgchIncludeWholeFile, TEXT("0"));

	TCHAR rgchQuery[MAX_PATH+MAX_PATH+MAX_PATH];
	StringCchPrintf(rgchQuery, sizeof(rgchQuery)/sizeof(TCHAR), TEXT("INSERT INTO `UpgradedFiles_OptionalData` ( `Upgraded`, `FTK`, `SymbolPaths`, `AllowIgnoreOnPatchError`, `IncludeWholeFile` ) VALUES ( '%s', '%s', '%s', %s, %s )"),
			rgchUpgradedImage, rgchFTK, rgchSymbolPaths, rgchIgnoreErrors, rgchIncludeWholeFile);
	if (!FExecSqlCmd(hdb, rgchQuery))
		return (IDS_CANCEL);

	return (IDS_OKAY);
}




static MSIHANDLE hdbInput = NULL;

static UINT UiValidateAndLogPCWProperties  ( MSIHANDLE hdbInput, LPTSTR szPcpPath, LPTSTR szPatchPath, LPTSTR szTempFolder, LPTSTR szTempFName );
static int  IGetOrderMax                   ( MSIHANDLE hdbInput );
static UINT IdsValidateFamilyRecords       ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateFamilyRangeRecords  ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateUpgradedRecords     ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateTargetRecords       ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateExternalFileRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateUFileDataRecords    ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateUFileIgnoreRecords  ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateTFileDataRecords    ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

static UINT IdsValidateTargetProductCodesAgainstList ( MSIHANDLE hdb );

static BOOL FNoUpgradedImages                  ( MSIHANDLE hdb );
static BOOL FCheckForProductCodeMismatches     ( MSIHANDLE hdb );
static BOOL FCheckForProductVersionMismatches  ( MSIHANDLE hdb );
static BOOL FCheckForProductCodeMismatchWithVersionMatch (MSIHANDLE hdb );
static void FillInListOfTargetProductCodes     ( MSIHANDLE hdb );

/* ********************************************************************** */
UINT UiValidateInputRecords ( MSIHANDLE hdb, LPTSTR szPcpPath, LPTSTR szPatchPath, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szPcpPath));
	Assert(FFileExist(szPcpPath));
	Assert(!FEmptySz(szPatchPath));
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);

	UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, szEmpty, szEmpty);
	UpdateStatusMsg(0, TEXT("Table: Properties"), szNull);
	UINT ids = UiValidateAndLogPCWProperties(hdb, szPcpPath, szPatchPath, szTempFolder, szTempFName);
	if (ids != IDS_OKAY)
		return (ids);

	hdbInput = hdb;

	iOrderMax = IGetOrderMax(hdbInput);
	Assert(iOrderMax > 0);

	UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, TEXT("Table: ImageFamilies"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`ImageFamilies`"),
					TEXT("`Family`,`MediaSrcPropName`,`MediaDiskId`,`FileSequenceStart`"),
					szNull, IdsValidateFamilyRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, TEXT("Table: FamilyFileRanges"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`FamilyFileRanges`"),
					TEXT("`Family`,`FTK`,`RetainOffsets`,`RetainLengths`,`RetainCount`"),
					szNull, IdsValidateFamilyRangeRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, TEXT("Table: UpgradedImages"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`,`MsiPath`,`Family`,`PatchMsiPath`"),
					szNull, IdsValidateUpgradedRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(0, TEXT("Table: TargetImages"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`MsiPath`,`Upgraded`,`ProductValidateFlags`,`Order`,`IgnoreMissingSrcFiles`"),
					szNull, IdsValidateTargetRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(0, TEXT("Table: ExternalFiles"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`ExternalFiles`"),
					TEXT("`Family`,`FTK`,`FilePath`,`Order`,`IgnoreOffsets`,`IgnoreLengths`,`RetainOffsets`,`IgnoreCount`"),
					szNull, IdsValidateExternalFileRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(0, TEXT("Table: UpgradedFiles_OptionalData"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`UpgradedFiles_OptionalData`"),
					TEXT("`Upgraded`,`FTK`,`IncludeWholeFile`"),
					szNull, IdsValidateUFileDataRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(0, TEXT("Table: UpgradedFilesToIgnore"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`UpgradedFilesToIgnore`"),
					TEXT("`Upgraded`,`FTK`"),
					szNull, IdsValidateUFileIgnoreRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(0, TEXT("Table: TargetFiles_OptionalData"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`TargetFiles_OptionalData`"),
					TEXT("`Target`,`FTK`,`IgnoreOffsets`,`IgnoreLengths`,`RetainOffsets`,`IgnoreCount`"),
					szNull, IdsValidateTFileDataRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, TEXT("Table: UpgradedImages"), szEmpty);
	if (FNoUpgradedImages(hdb))
		return (UiLogError(ERROR_PCW_NO_UPGRADED_IMAGES_TO_PATCH, NULL, NULL));
	
	if (!FCheckForProductCodeMismatches(hdb))
		return (UiLogError(ERROR_PCW_MISMATCHED_PRODUCT_CODES, NULL, NULL));
	if (!FCheckForProductVersionMismatches(hdb))
		return (UiLogError(ERROR_PCW_MISMATCHED_PRODUCT_VERSIONS, NULL, NULL));
	if (!FCheckForProductCodeMismatchWithVersionMatch(hdb))
		return (UiLogError(ERROR_PCW_MATCHED_PRODUCT_VERSIONS, NULL, NULL));

	FillInListOfTargetProductCodes(hdb);

	ids = IdsValidateTargetProductCodesAgainstList(hdb);
	if (ids != IDS_OKAY)
		return (ids);

	return (ERROR_SUCCESS);
}


static UINT IdsGetMaxOrder ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static int IGetOrderMax ( MSIHANDLE hdbInput )
{
	Assert(hdbInput != NULL);

	int iMax = 0;

	EvalAssert( IDS_OKAY == IdsMsiEnumTable(hdbInput, TEXT("`TargetImages`"),
					TEXT("`Order`"), szNull, IdsGetMaxOrder, (LPARAM)(&iMax), 0L) );
	EvalAssert( IDS_OKAY == IdsMsiEnumTable(hdbInput, TEXT("`ExternalFiles`"),
					TEXT("`Order`"), szNull, IdsGetMaxOrder, (LPARAM)(&iMax), 0L) );

	return (iMax+1);
}


/* ********************************************************************** */
static UINT IdsGetMaxOrder ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	int* piMax = (int*)lp1;
	Assert(piMax != NULL);
	Assert(*piMax >= 0);

	int iOrder = MsiRecordGetInteger(hrec, 1);
	if (iOrder != MSI_NULL_INTEGER && iOrder > *piMax)
		*piMax = iOrder;

	return (IDS_OKAY);
}


static BOOL FValidName         ( LPTSTR sz, int cchMax );
#define FValidFamilyName(sz)   FValidName(sz,MAX_LENGTH_IMAGE_FAMILY_NAME)
#define FValidImageName(sz)    FValidName(sz,MAX_LENGTH_TARGET_IMAGE_NAME)

static BOOL FUniqueImageName   ( LPTSTR sz, MSIHANDLE hdbInput );
static BOOL FUniquePackageCode ( LPTSTR sz, MSIHANDLE hdbInput );
static BOOL FValidPropertyName ( LPTSTR sz );
static BOOL FValidDiskId       ( LPTSTR sz );

/* ********************************************************************** */
static UINT IdsValidateFamilyRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchFamily[MAX_LENGTH_IMAGE_FAMILY_NAME + 1];
	DWORD dwcch = MAX_LENGTH_IMAGE_FAMILY_NAME + 1;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchFamily, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_IMAGE_FAMILY_NAME_TOO_LONG, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ImageFamilies.Family"), szNull));

	UpdateStatusMsg(0, 0, rgchFamily);

	if (!FValidFamilyName(rgchFamily))
		return (UiLogError(ERROR_PCW_BAD_IMAGE_FAMILY_NAME, rgchFamily, szNull));

	if (!FUniqueImageName(rgchFamily, hdbInput))
		return (UiLogError(ERROR_PCW_DUP_IMAGE_FAMILY_NAME, rgchFamily, szNull));

	int iMinimumMsiVersion = 100;
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyInteger(hdbInput, TEXT("MinimumRequiredMsiVersion"), &iMinimumMsiVersion) );

	TCHAR rgchPropName[MAX_PATH];
	dwcch = MAX_PATH;
	if (MsiRecordIsNull(hrec, 2) && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch targets Windows Installer 2.0 or greater

		// MediaSrcPropName is not required since sequence conflict management handles 
		// this automatically
		}
	else
		{
		// author chose to author this value so we will validate it; or author is not
		// targeting the patch for Windows Installer 2.0 or greater

		uiRet = MsiRecordGetString(hrec, 2, rgchPropName, &dwcch);
		if (uiRet == ERROR_MORE_DATA)
			return (UiLogError(ERROR_PCW_BAD_IMAGE_FAMILY_SRC_PROP, rgchFamily, szNull));
		if (uiRet != MSI_OKAY)
			return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ImageFamilies.MediaSrcPropName"), szNull));
		if (!FValidPropertyName(rgchPropName))
			return (UiLogError(ERROR_PCW_BAD_IMAGE_FAMILY_SRC_PROP, rgchPropName, rgchFamily));
		}

	if (MsiRecordIsNull(hrec, 3) && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch targets Windows Installer 2.0 or greater

		// MediaDiskId is not required since sequence conflict management handles
		// this automatically
		}
	else
		{
		// author chose to author this value so we will validate it; or author is not
		// targeting the patch for Windows Installer 2.0 or greater

		int iDiskId = MsiRecordGetInteger(hrec, 3);
		if (iDiskId == MSI_NULL_INTEGER || iDiskId < 2)
			return (UiLogError(ERROR_PCW_BAD_IMAGE_FAMILY_DISKID, rgchFamily, szNull));
		}

	if (MsiRecordIsNull(hrec, 4) && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch targets Windows Installer 2.0 or greater

		// FileSequenceStart is not required since sequence conflict management handles
		// this automatically
		}
	else
		{
		// author chose to author this value so we will validate it; or author is not
		// targeting the patch for Windows Installer 2.0 or greater

		int iSeqStart = MsiRecordGetInteger(hrec, 4);
		if (iSeqStart == MSI_NULL_INTEGER || iSeqStart < 2)
			return (UiLogError(ERROR_PCW_BAD_IMAGE_FAMILY_FILESEQSTART, rgchFamily, szNull));
		}

	return (IDS_OKAY);
}


static int ICountRangeElements ( LPTSTR sz, BOOL fAllowZeros );

/* ********************************************************************** */
static UINT IdsValidateFamilyRangeRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchFamily[MAX_LENGTH_IMAGE_FAMILY_NAME + 1];
	DWORD dwcch = MAX_LENGTH_IMAGE_FAMILY_NAME + 1;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchFamily, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_NAME_TOO_LONG, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("FamilyFileRanges.Family"), szNull));
	if (!FValidFamilyName(rgchFamily))
		return (UiLogError(ERROR_PCW_BAD_FAMILY_RANGE_NAME, rgchFamily, szNull));

	UpdateStatusMsg(0, 0, rgchFamily);

	int iMinimumMsiVersion = 100;
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyInteger(hdbInput, TEXT("MinimumRequiredMsiVersion"), &iMinimumMsiVersion) );

	int iDiskId;
	uiRet = IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
				TEXT("`Family`"), TEXT("`MediaDiskId`"), rgchFamily, &iDiskId);
	Assert(uiRet == IDS_OKAY);

	if (iDiskId == MSI_NULL_INTEGER && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch targets Windows Installer 2.0 so a NULL MediaDiskId is allowed
		iDiskId = 2;
		}

	if (iDiskId < 2)
		return (UiLogError(ERROR_PCW_BAD_FAMILY_RANGE_NAME, rgchFamily, szNull));
	Assert(iDiskId != MSI_NULL_INTEGER && iDiskId >= 2);

	TCHAR rgchFTK[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_LONG_FILE_TABLE_KEY, rgchFamily, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("FamilyFileRanges.FTK"), szNull));
	if (FEmptySz(rgchFTK))
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_BLANK_FILE_TABLE_KEY, rgchFamily, szNull));

	TCHAR rgchRetainOffsets[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchRetainOffsets, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_OFFSETS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("FamilyFileRanges.RetainOffsets"), szNull));
	if (FEmptySz(rgchRetainOffsets))
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_OFFSETS, rgchFamily, rgchFTK));

	int cRetainOffsets = ICountRangeElements(rgchRetainOffsets, fTrue);
	if (cRetainOffsets <= 0)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_OFFSETS, rgchFamily, rgchFTK));
	Assert(cRetainOffsets < 256);

	TCHAR rgchRetainLengths[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 4, rgchRetainLengths, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_LENGTHS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("FamilyFileRanges.RetainLengths"), szNull));
	if (FEmptySz(rgchRetainLengths))
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_LENGTHS, rgchFamily, rgchFTK));

	int cRetainLengths = ICountRangeElements(rgchRetainLengths, fFalse);
	if (cRetainLengths <= 0)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_LENGTHS, rgchFamily, rgchFTK));
	Assert(cRetainLengths < 256);

	if (cRetainOffsets != cRetainLengths)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_COUNT_MISMATCH, rgchFamily, rgchFTK));

	// TODO - could check for overlaps in ranges

	EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 5, cRetainOffsets) );
	EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );

	return (IDS_OKAY);
}


/* ********************************************************************** */
static int ICountRangeElements ( LPTSTR sz, BOOL fAllowZeros )
{
	Assert(sz != szNull);

	CharLower(sz);

	int iCount = 0;
	while (!FEmptySz(sz))
		{
		ULONG ul = UlGetRangeElement(&sz);
		if (sz == szNull)
			{
			Assert(ul == (ULONG)(-1));
			return (-1);
			}
		if (ul == 0L && !fAllowZeros)
			return (-1);
		iCount++;
		}

	return (iCount);
}


/* ********************************************************************** */
ULONG UlGetRangeElement ( LPTSTR* psz )
{
	Assert(psz != NULL);

	LPTSTR sz = *psz;
	Assert(!FEmptySz(sz));

	BOOL fHex = FMatchPrefix(sz, TEXT("0x"));
	if (fHex)
		sz += 2;

	ULONG ulRet  = 0L;
	ULONG ulMult = (fHex) ? 16L : 10L;
	TCHAR ch = *sz;
	do	{
		ULONG ulNext;
		if (ch >= TEXT('0') && ch <= TEXT('9'))
			ulNext = (ULONG)(ch - TEXT('0'));
		else if (fHex && ch >= TEXT('a') && ch <= TEXT('f'))
			ulNext = (ULONG)(ch - TEXT('a') + 10);
		else
			{
			*psz = szNull;
			return ((ULONG)(-1));
			}
		// TODO - watch for overflow
		Assert(ulRet < ((ULONG)(-1) / ulMult));
		ulRet = (ulRet * ulMult) + ulNext;
		ch = *(++sz);
		}  while (ch != TEXT('\0') && ch != TEXT(','));

	if (ch == TEXT(','))
		{
		sz++;
		while (*sz == TEXT(' '))
			sz++;
		}

	Assert(ulRet != (ULONG)(-1));
	*psz = sz;

	return (ulRet);
}


#define MSISOURCE_SFN         0x0001
#define MSISOURCE_COMPRESSED  0x0002

static BOOL FValidGUID ( LPTSTR sz, BOOL fList, BOOL fLeadAsterisk, BOOL fSemiColonSeparated );
static BOOL FValidProductVersion ( LPTSTR sz, UINT iFields );
static BOOL FEnsureAllSrcFilesExist ( MSIHANDLE hdb, LPTSTR szFolder, BOOL fLfn );

/* ********************************************************************** */
static UINT IdsValidateUpgradedRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchUpgraded[MAX_LENGTH_TARGET_IMAGE_NAME + 1];
	DWORD dwcch = MAX_LENGTH_TARGET_IMAGE_NAME + 1;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchUpgraded, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_NAME_TOO_LONG, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedImages.Upgraded"), szNull));

	UpdateStatusMsg(0, 0, rgchUpgraded);

	if (!FValidImageName(rgchUpgraded))
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_NAME, rgchUpgraded, szNull));

	TCHAR rgchFamily[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchFamily, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY, rgchUpgraded, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedImages.Family"), szNull));
	if (!FValidFamilyName(rgchFamily))
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY, rgchUpgraded, rgchFamily));

	// TODO for each file in this image that exists, check all
	//   UpgradedImages in this family with non-blank PackageCode fields
	//   for same file and FileName

	if (!FUniqueImageName(rgchUpgraded, hdbInput))
		return (UiLogError(ERROR_PCW_DUP_UPGRADED_IMAGE_NAME, rgchUpgraded, szNull));

	TCHAR rgchMsiPath[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchMsiPath, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_TOO_LONG, rgchUpgraded, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedImages.MsiPath"), szNull));

	if (FEmptySz(rgchMsiPath))
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_EMPTY, rgchUpgraded, szNull));
	EvalAssert( FFixupPath(rgchMsiPath) );
	if (FEmptySz(rgchMsiPath))
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_EMPTY, rgchUpgraded, szNull));

	if (!FFileExist(rgchMsiPath))
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_EXIST, rgchMsiPath, szNull));

	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
			TEXT("MsiPath"), rgchMsiPath, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	MSIHANDLE hSummaryInfo = NULL;
	uiRet = MsiGetSummaryInformation(NULL, rgchMsiPath, 0, &hSummaryInfo);
	if (uiRet != MSI_OKAY || hSummaryInfo == NULL)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));

	UINT uiType;
	INT  intRet;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_MSISOURCE, &uiType, &intRet, NULL, NULL, NULL);
	if (uiRet != MSI_OKAY || uiType != VT_I4 || intRet > 7)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	if (intRet & MSISOURCE_COMPRESSED)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_COMPRESSED, rgchMsiPath, szNull));

	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("LFN"), (intRet & MSISOURCE_SFN) ? TEXT("No") : TEXT("Yes"),
				TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	TCHAR rgchData[MAX_PATH+MAX_PATH];
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_REVNUMBER, &uiType, NULL, NULL, rgchData, &dwcch);
	if (uiRet != MSI_OKAY || uiType != VT_LPTSTR)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("PackageCode"), rgchData, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);
	if (!FUniquePackageCode(rgchData, hdbInput))
		return (UiLogError(ERROR_PCW_DUP_UPGRADED_IMAGE_PACKCODE, rgchUpgraded, rgchData));

	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_SUBJECT, &uiType, NULL, NULL, rgchData, &dwcch);
	if (uiRet != MSI_OKAY || uiType != VT_LPTSTR)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("SummSubject"), rgchData, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_COMMENTS, &uiType, NULL, NULL, rgchData, &dwcch);
	if (uiRet != MSI_OKAY || uiType != VT_LPTSTR)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("SummComments"), rgchData, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	EvalAssert( MsiCloseHandle(hSummaryInfo) == MSI_OKAY );

	MSIHANDLE hdb = NULL;
	uiRet = MsiOpenDatabase(rgchMsiPath, MSIDBOPEN_READONLY, &hdb);
	if (uiRet != MSI_OKAY)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	Assert(hdb != NULL);

	// NYI bug 9392 - could call ICE24 validation on this

	EvalAssert( MSI_OKAY == IdsMsiGetPropertyString(hdb, TEXT("ProductCode"), rgchData, MAX_PATH) );
	if (!FValidGUID(rgchData, fFalse, fFalse, fFalse))
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_CODE, rgchUpgraded, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("ProductCode"), rgchData, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	EvalAssert( MSI_OKAY == IdsMsiGetPropertyString(hdb, TEXT("ProductVersion"), rgchData, MAX_PATH) );
	if (!FValidProductVersion(rgchData, 4))
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_VERSION, rgchUpgraded, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("ProductVersion"), rgchData, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	EvalAssert( MSI_OKAY == IdsMsiGetPropertyString(hdb, TEXT("UpgradeCode"), rgchData, MAX_PATH) );
	if (!FEmptySz(rgchData) && !FValidGUID(rgchData, fFalse, fFalse, fFalse))
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_UPGRADE_CODE, rgchUpgraded, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("UpgradeCode"), rgchData, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	StringCchPrintf(rgchData, sizeof(rgchData)/sizeof(TCHAR), TEXT("Upgraded image: %s"), rgchUpgraded);
	UpdateStatusMsg(IDS_STATUS_VALIDATE_IMAGES, rgchData, szEmpty);
	lstrcpy(rgchData, rgchMsiPath);
	*SzFindFilenameInPath(rgchData) = TEXT('\0');
//	if (!FEnsureAllSrcFilesExist(hdb, rgchData, !(intRet & MSISOURCE_SFN)))
//		return (UiLogError(ERROR_PCW_UPGRADED_MISSING_SRC_FILES, rgchData, szNull));
//	UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, TEXT("Table: UpgradedImages"), rgchUpgraded);


	int iMinimumMsiVersion = 100;
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyInteger(hdbInput, TEXT("MinimumRequiredMsiVersion"), &iMinimumMsiVersion) );

	int iDiskId;
	uiRet = IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
				TEXT("`Family`"), TEXT("`MediaDiskId`"), rgchFamily, &iDiskId);
	Assert(uiRet == IDS_OKAY);

	if (iDiskId == MSI_NULL_INTEGER && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch targets Windows Installer 2.0, MediaDiskId can be NULL
		iDiskId = 2;
		}

	if (iDiskId < 2)
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY, rgchUpgraded, rgchFamily));
	Assert(iDiskId != MSI_NULL_INTEGER && iDiskId >= 2);

	int iFileSeqStart;
	uiRet = IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
				TEXT("`Family`"), TEXT("`FileSequenceStart`"), rgchFamily, &iFileSeqStart);
	Assert(uiRet == IDS_OKAY);

	if (iFileSeqStart == MSI_NULL_INTEGER && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch targets Windows Installer 2.0, FileSequenceStart can be NULL
		iFileSeqStart = 2;
	}

	Assert(iFileSeqStart != MSI_NULL_INTEGER && iFileSeqStart >= 2);

	// verify ImageFamilies.FileSequenceStart (pcp) > Media.LastSequence (upgraded image)
	// -- only matters when not targeting Windows XP or greater since XP or greater has conflict mgmt
	if (iMinimumMsiVersion < iWindowsInstallerXP)
		{
		PMSIHANDLE hViewMedia = 0;
		PMSIHANDLE hRecMedia  = 0;
		EvalAssert( MsiDatabaseOpenView(hdb, TEXT("SELECT `LastSequence` FROM `Media`"), &hViewMedia) == MSI_OKAY );
		EvalAssert( MsiViewExecute(hViewMedia, 0) == MSI_OKAY );

		int iMediaLargestLastSequence = 0;
		int iSequence = 0;

		while (ERROR_SUCCESS == (uiRet = MsiViewFetch(hViewMedia, &hRecMedia)))
			{
			iSequence = MsiRecordGetInteger(hRecMedia, 1);
			if (iSequence > iMediaLargestLastSequence)
				{
				iMediaLargestLastSequence = iSequence;
				}
			}
		Assert( ERROR_NO_MORE_ITEMS == uiRet );

		if (iFileSeqStart <= iMediaLargestLastSequence)
			{
			// overlapping sequence numbers
			return (UiLogError(ERROR_PCW_BAD_FILE_SEQUENCE_START, rgchFamily, rgchUpgraded)); 
			}
		}	


	// TODO ensure all Media.DiskId, PatchPackage.PatchId < iDiskId
	//  ensure all File.Sequence < iFileSeqStart
	//  assert that ExecuteSequence tables have InstallFiles actions
	//  assert that if PatchFiles is present it comes after InstallFiles

	// EvalAssert( MsiCloseHandle(hdb) == MSI_OKAY );

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 4, rgchMsiPath, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_TOO_LONG, rgchUpgraded, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedImages.PatchMsiPath"), szNull));

	if (!FEmptySz(rgchMsiPath))
		{
		EvalAssert( FFixupPath(rgchMsiPath) );
		Assert(!FEmptySz(rgchMsiPath));
		if (!FFileExist(rgchMsiPath))
			return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_EXIST, rgchMsiPath, szNull));

		uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("PatchMsiPath"), rgchMsiPath, TEXT("Upgraded"), rgchUpgraded);
		Assert(uiRet == MSI_OKAY);

		hSummaryInfo = NULL;
		uiRet = MsiGetSummaryInformation(NULL, rgchMsiPath, 0, &hSummaryInfo);
		if (uiRet != MSI_OKAY || hSummaryInfo == NULL)
			return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_MSI, rgchMsiPath, szNull));

		EvalAssert( MsiCloseHandle(hSummaryInfo) == MSI_OKAY );
		}

	EvalAssert( MsiCloseHandle(hdb) == MSI_OKAY );
	
	return (IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FValidProductVersion ( LPTSTR sz, UINT iFields )
{
	Assert(iFields <= 4);

	if (FEmptySz(sz))
		return (iFields < 4);

	if (*sz < TEXT('0') || *sz > TEXT('9'))
		return (fFalse);

	DWORD dw = 0;
	while (*sz >= TEXT('0') && *sz <= TEXT('9'))
		{
		dw = (dw * 10) + (*sz - TEXT('0'));
		if (dw > 65535)
			return (fFalse);
		sz = CharNext(sz);
		}

	if (*sz == TEXT('.'))
		sz = CharNext(sz);
	else if (*sz != TEXT('\0'))
		return (fFalse);

	return (FValidProductVersion(sz, --iFields));
}


static BOOL FValidProdValValue  ( LPTSTR sz );

/* ********************************************************************** */
static UINT IdsValidateTargetRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchTarget[MAX_LENGTH_TARGET_IMAGE_NAME + 1];
	DWORD dwcch = MAX_LENGTH_TARGET_IMAGE_NAME + 1;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_NAME_TOO_LONG, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetImages.Target"), szNull));

	UpdateStatusMsg(0, 0, rgchTarget);

	if (!FValidImageName(rgchTarget))
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_NAME, rgchTarget, szNull));

	if (!FUniqueImageName(rgchTarget, hdbInput))
		return (UiLogError(ERROR_PCW_DUP_TARGET_IMAGE_NAME, rgchTarget, szNull));

	TCHAR rgchMsiPath[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchMsiPath, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_TOO_LONG, rgchTarget, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetImages.MsiPath"), szNull));

	if (FEmptySz(rgchMsiPath))
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_EMPTY, rgchTarget, szNull));
	EvalAssert( FFixupPath(rgchMsiPath) );
	if (FEmptySz(rgchMsiPath))
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_EMPTY, rgchTarget, szNull));

	if (!FFileExist(rgchMsiPath))
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_NOT_EXIST, rgchMsiPath, szNull));

	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
			TEXT("MsiPath"), rgchMsiPath, TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);

	MSIHANDLE hSummaryInfo = NULL;
	uiRet = MsiGetSummaryInformation(NULL, rgchMsiPath, 0, &hSummaryInfo);
	if (uiRet != MSI_OKAY || hSummaryInfo == NULL)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));

	UINT uiType;
	INT  intRet;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_MSISOURCE, &uiType, &intRet, NULL, NULL, NULL);
	if (uiRet != MSI_OKAY || uiType != VT_I4 || intRet > 7)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	if (intRet & MSISOURCE_COMPRESSED)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_COMPRESSED, rgchMsiPath, szNull));

	TCHAR rgchData[MAX_PATH+MAX_PATH];
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_REVNUMBER, &uiType, NULL, NULL, rgchData, &dwcch);
	if (uiRet != MSI_OKAY || uiType != VT_LPTSTR)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("PackageCode"), rgchData, TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);
	if (!FUniquePackageCode(rgchData, hdbInput))
		return (UiLogError(ERROR_PCW_DUP_TARGET_IMAGE_PACKCODE, rgchTarget, rgchData));

	EvalAssert( MsiCloseHandle(hSummaryInfo) == MSI_OKAY );

	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("LFN"), (intRet & MSISOURCE_SFN) ? TEXT("No") : TEXT("Yes"),
				TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);

	MSIHANDLE hdb = NULL;
	uiRet = MsiOpenDatabase(rgchMsiPath, MSIDBOPEN_READONLY, &hdb);
	if (uiRet != MSI_OKAY)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	Assert(hdb != NULL);

	// NYI bug 9392 - could call ICE24 validation on this

	EvalAssert( MSI_OKAY == IdsMsiGetPropertyString(hdb, TEXT("ProductCode"), rgchData, MAX_PATH) );
	if (!FValidGUID(rgchData, fFalse, fFalse, fFalse))
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_CODE, rgchTarget, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("ProductCode"), rgchData, TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);

	EvalAssert( MSI_OKAY == IdsMsiGetPropertyString(hdb, TEXT("ProductVersion"), rgchData, MAX_PATH) );
	if (!FValidProductVersion(rgchData, 4))
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_VERSION, rgchTarget, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("ProductVersion"), rgchData, TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);

	EvalAssert( MSI_OKAY == IdsMsiGetPropertyString(hdb, TEXT("UpgradeCode"), rgchData, MAX_PATH) );
	if (!FEmptySz(rgchData) && !FValidGUID(rgchData, fFalse, fFalse, fFalse))
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_UPGRADE_CODE, rgchTarget, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("UpgradeCode"), rgchData, TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);

	StringCchPrintf(rgchData, sizeof(rgchData)/sizeof(TCHAR), TEXT("Target image: %s"), rgchTarget);
	UpdateStatusMsg(IDS_STATUS_VALIDATE_IMAGES, rgchData, szEmpty);
	lstrcpy(rgchData, rgchMsiPath);
	*SzFindFilenameInPath(rgchData) = TEXT('\0');

//	int iIgnoreMissingSrcFiles = MsiRecordGetInteger(hrec, 6);
//	if (iIgnoreMissingSrcFiles == MSI_NULL_INTEGER || iIgnoreMissingSrcFiles == 0)
//		{
//		if (!FEnsureAllSrcFilesExist(hdb, rgchData, !(intRet & MSISOURCE_SFN)))
//			return (UiLogError(ERROR_PCW_TARGET_MISSING_SRC_FILES, rgchData, szNull));
//		UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, TEXT("Table: TargetImages"), rgchTarget);
//		}

	EvalAssert( MsiCloseHandle(hdb) == MSI_OKAY );


	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchData, &dwcch); // Upgraded
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED, rgchTarget, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetImages.Upgraded"), szNull));
	if (!FValidImageName(rgchData))
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED, rgchTarget, rgchData));

	TCHAR rgchFamily[32];
	uiRet = IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
				TEXT("`Upgraded`"), TEXT("`Family`"), rgchData, rgchFamily, 32);
	Assert(uiRet == IDS_OKAY);
	if (!FValidFamilyName(rgchFamily))
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED, rgchTarget, rgchData));

	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("Family"), rgchFamily,	TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);

	int iDiskId;
	uiRet = IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
				TEXT("`Family`"), TEXT("`MediaDiskId`"), rgchFamily, &iDiskId);
	Assert(uiRet == IDS_OKAY);
	Assert(iDiskId != MSI_NULL_INTEGER && iDiskId >= 2);

	int iFileSeqStart;
	uiRet = IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
				TEXT("`Family`"), TEXT("`FileSequenceStart`"), rgchFamily, &iFileSeqStart);
	Assert(uiRet == IDS_OKAY);
	Assert(iFileSeqStart != MSI_NULL_INTEGER && iFileSeqStart >= 2);

	// TODO ensure all Media.DiskId, PatchPackage.PatchId < iDiskId
	//  ensure all File.Sequence < iFileSeqStart
	//  assert that ExecuteSequence tables have InstallFiles actions
	//  assert that if PatchFiles is present it comes after InstallFiles

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 4, rgchData, &dwcch); // ProductValidateFlags
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TARGET_BAD_PROD_VALIDATE, rgchTarget, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetImages.ProductValidateFlags"), szNull));
	if (FEmptySz(rgchData))
		{
		Assert(FValidProdValValue(TEXT("0x00000922")));
		uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("ProductValidateFlags"), TEXT("0x00000922"), TEXT("Target"), rgchTarget);
		Assert(uiRet == MSI_OKAY);
		g_fValidateProductCodeIncluded = TRUE;
		}
	else
		{
		if (!FValidHexValue(rgchData) || !FValidProdValValue(rgchData))
			return (UiLogError(ERROR_PCW_TARGET_BAD_PROD_VALIDATE, rgchTarget, szNull));

		// see if MSITRANSFORM_VALIDATE_PRODUCT is included (0x00000002)
		ULONG ulFlags = UlFromHexSz(rgchData);
		if (ulFlags & MSITRANSFORM_VALIDATE_PRODUCT)
			{
			g_fValidateProductCodeIncluded = TRUE;
			}
		}


	Assert(iOrderMax > 0);
	int iOrder = MsiRecordGetInteger(hrec, 5);
	if (iOrder == MSI_NULL_INTEGER || iOrder < 0)
		{
		uiRet = IdsMsiUpdateTableRecordInt(hdbInput, TEXT("TargetImages"), TEXT("Order"), iOrderMax-1, TEXT("Target"), rgchTarget);
		Assert(uiRet == MSI_OKAY);
		}
	Assert(iOrder < iOrderMax);

	return (IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FValidProdValValue ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));
	Assert(FValidHexValue(sz));

	ULONG ulFlags = UlFromHexSz(sz);
	if (ulFlags > 0x00000FFF)
		EvalAssert( FWriteLogFile(TEXT("   WARNING: TargetImages.ProductValidateFlags contains unknown bits above 0x00000FFF that might cause patch to fail.\r\n")) );

	UINT cVerFlags = 0;
	if (ulFlags & MSITRANSFORM_VALIDATE_MAJORVERSION)
		cVerFlags++;
	if (ulFlags & MSITRANSFORM_VALIDATE_MINORVERSION)
		cVerFlags++;
	if (ulFlags & MSITRANSFORM_VALIDATE_UPDATEVERSION)
		cVerFlags++;

	UINT cCompFlags = 0;
	if (ulFlags & MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION)
		cCompFlags++;
	if (ulFlags & MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION)
		cCompFlags++;
	if (ulFlags & MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION)
		cCompFlags++;
	if (ulFlags & MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION)
		cCompFlags++;
	if (ulFlags & MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION)
		cCompFlags++;

	// prevent specification of product version check without comparison flag
	if (cVerFlags >= 1 && cCompFlags == 0)
		{
		EvalAssert( FWriteLogFile(TEXT("   ERROR: TargetImages.ProductValidateFlags specifies validation of the product version but does not also include a product version comparison flag.\r\n")) );
		return FALSE;
		}

	return (cVerFlags <= 1 && cCompFlags <= 1);
}


#ifdef UNUSED

static LPTSTR g_szFolder = szNull;
static LPTSTR g_szFName  = szNull;

static UINT IdsCheckFileExists ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FEnsureAllSrcFilesExist ( MSIHANDLE hdb, LPTSTR szFolder, BOOL fLfn )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szFolder));
	Assert(FFolderExist(szFolder));

	g_szFolder = szFolder;
	g_szFName  = szFolder + lstrlen(szFolder);

	UINT ids = IdsMsiEnumTable(hdb, TEXT("`File`"),
					TEXT("`File`,`Component_`,`FileName`"),
					szNull, IdsCheckFileExists,
					(LPARAM)(hdb), (LPARAM)(fLfn));

	return (ids == MSI_OKAY);
}


/* ********************************************************************** */
static UINT IdsCheckFileExists ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	MSIHANDLE hdb = (MSIHANDLE)(lp1);
	Assert(hdb != NULL);

	BOOL fLfn = (BOOL)(lp2);

	Assert(!FEmptySz(g_szFolder));
	Assert(g_szFName != szNull);
	Assert(g_szFName > g_szFolder);
	*g_szFName = TEXT('\0');
	Assert(FFolderExist(g_szFolder)); // true but expensive to test repeatedly

	TCHAR rgchComponent[MAX_PATH];
	TCHAR rgchFName[MAX_PATH];

	DWORD dwcch = MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchFName, &dwcch);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchFName));

	UpdateStatusMsg(0, 0, rgchFName);

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchComponent, &dwcch);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchComponent));

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchFName, &dwcch);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchFName));

	uiRet = IdsResolveSrcFilePathSzs(hdb, g_szFName, rgchComponent, rgchFName, fLfn, szNull);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(g_szFName));

	return ((FFileExist(g_szFolder)) ? IDS_OKAY : IDS_CANCEL);
}
#endif /* UNUSED */


static UINT IdsResolveSrcDir ( MSIHANDLE hdb, LPTSTR szDir, LPTSTR szBuf, BOOL fLfn, LPTSTR szFullSubFolder );

/* ********************************************************************** */
UINT IdsResolveSrcFilePathSzs ( MSIHANDLE hdb, LPTSTR szBuf, LPTSTR szComponent, LPTSTR szFName, BOOL fLfn, LPTSTR szFullSubFolder )
{
	Assert(hdb != NULL);
	Assert(szBuf != szNull);
	Assert(!FEmptySz(szComponent));
	Assert(!FEmptySz(szFName));
	Assert(*szFName != TEXT('\\'));
	Assert(*SzLastChar(szFName) != TEXT('\\'));

	*szBuf = TEXT('\0');
	if (szFullSubFolder != szNull)
		*szFullSubFolder = TEXT('\0');

	TCHAR rgchDir[MAX_PATH] = {0};
	UINT  ids = IdsMsiGetTableString(hdb, TEXT("`Component`"), TEXT("`Component`"), TEXT("`Directory_`"), szComponent, rgchDir, MAX_PATH);
	Assert(ids == MSI_OKAY);
	Assert(!FEmptySz(rgchDir));

	ids = IdsResolveSrcDir(hdb, rgchDir, szBuf, fLfn, szFullSubFolder);
	Assert(ids == MSI_OKAY);
	Assert(!FEmptySz(szBuf));

	LPTSTR szBar = szFName;
	while (*szBar != TEXT('\0') && *szBar != TEXT('|'))
		szBar = CharNext(szBar);

	if (!fLfn)
		*szBar = TEXT('\0');

	if (*szBar == TEXT('\0'))
		lstrcat(szBuf, szFName);
	else
		{
		Assert(fLfn);
		Assert(*CharNext(szBar) != TEXT('\0'));
		Assert(*CharNext(szBar) != TEXT('\\'));
		lstrcat(szBuf, CharNext(szBar));
		}

	return (MSI_OKAY);
}


/* ********************************************************************** */
static UINT IdsResolveSrcDir ( MSIHANDLE hdb, LPTSTR szDir, LPTSTR szBuf, BOOL fLfn, LPTSTR szFullSubFolder )
{
	/* RECURSION WARNING */

	Assert(hdb != NULL);
	Assert(!FEmptySz(szDir));
	Assert(szBuf != szNull);
	Assert(*szBuf == TEXT('\0'));

	TCHAR rgchData[MAX_PATH] = {0};
	UINT  ids = IdsMsiGetTableString(hdb, TEXT("`Directory`"), TEXT("`Directory`"), TEXT("`Directory_Parent`"), szDir, rgchData, MAX_PATH);
	Assert(ids == MSI_OKAY);

	if (!FEmptySz(rgchData) && lstrcmp(rgchData, szDir))
		{
		ids = IdsResolveSrcDir(hdb, rgchData, szBuf, fLfn, szFullSubFolder);
		Assert(ids == MSI_OKAY);
		Assert(!FEmptySz(szBuf));
		Assert(*SzLastChar(szBuf) == TEXT('\\'));
		if (szFullSubFolder != szNull)
			{
			Assert(!FEmptySz(szFullSubFolder));
			Assert(*SzLastChar(szFullSubFolder) == TEXT('\\'));
			}
		}

	ids = IdsMsiGetTableString(hdb, TEXT("`Directory`"), TEXT("`Directory`"), TEXT("`DefaultDir`"), szDir, rgchData, MAX_PATH);
	Assert(ids == MSI_OKAY);
	Assert(!FEmptySz(rgchData));
	Assert(*rgchData != TEXT('\\'));
	Assert(*rgchData != TEXT('|'));
	Assert(*SzLastChar(rgchData) != TEXT('\\'));

	LPTSTR szCur = rgchData;
	if (szFullSubFolder != szNull)
		lstrcat(szFullSubFolder, rgchData);

	while (*szCur != TEXT('\0') && *szCur != TEXT(':'))
		szCur = CharNext(szCur);

	if (*szCur == TEXT(':'))
		{
		lstrcpy(rgchData, CharNext(szCur));
		Assert(!FEmptySz(rgchData));
		Assert(*rgchData != TEXT('\\'));
		Assert(*rgchData != TEXT('|'));
		}
	
	if (szFullSubFolder != szNull)
		{
		Assert(*SzLastChar(szFullSubFolder) != TEXT('\\'));
		lstrcat(szFullSubFolder, TEXT("\\"));
		}

	szCur = rgchData;
	while (*szCur != TEXT('\0') && *szCur != TEXT('|'))
		szCur = CharNext(szCur);

	if (!fLfn)
		*szCur = TEXT('\0');

	if (*szCur == TEXT('\0'))
		szCur = rgchData;
	else
		{
		Assert(fLfn);
		Assert(*CharNext(szCur) != TEXT('\0'));
		Assert(*CharNext(szCur) != TEXT('\\'));
		szCur = CharNext(szCur);
		}
	if (!lstrcmp(szCur, TEXT("SOURCEDIR")) || !lstrcmp(szCur, TEXT("SourceDir")))
		lstrcpy(szBuf, TEXT("."));
	else
		lstrcat(szBuf, szCur);

	Assert(*SzLastChar(szBuf) != TEXT('\\'));
	lstrcat(szBuf, TEXT("\\"));

	return (MSI_OKAY);
}


/* ********************************************************************** */
static UINT IdsValidateExternalFileRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchFamily[MAX_PATH];
	DWORD dwcch = MAX_PATH;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchFamily, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ExternalFiles.Family"), szNull));
	if (!FValidFamilyName(rgchFamily))
		return (UiLogError(ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD, rgchFamily, szNull));

	int iMinimumMsiVersion = 100;
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyInteger(hdbInput, TEXT("MinimumRequiredMsiVersion"), &iMinimumMsiVersion) );

	int iDiskId;
	uiRet = IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
				TEXT("`Family`"), TEXT("`MediaDiskId`"), rgchFamily, &iDiskId);
	Assert(uiRet == IDS_OKAY);

	if (iDiskId == MSI_NULL_INTEGER && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch is targeted to Windows Installer 2.0 so MediaDiskId can be NULL
		iDiskId = 2;
		}

	if (iDiskId <= 0)
		return (UiLogError(ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD, rgchFamily, szNull));

	TCHAR rgchFTK[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_EXTFILE_LONG_FILE_TABLE_KEY, rgchFamily, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ExternalFiles.FTK"), szNull));
	if (FEmptySz(rgchFTK))
		return (UiLogError(ERROR_PCW_EXTFILE_BLANK_FILE_TABLE_KEY, rgchFamily, szNull));

	TCHAR rgchPath[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchPath, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_EXTFILE_LONG_PATH_TO_FILE, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ExternalFiles.FilePath"), szNull));
	if (FEmptySz(rgchPath))
		return (UiLogError(ERROR_PCW_EXTFILE_BLANK_PATH_TO_FILE, rgchFamily, rgchFTK));
	EvalAssert( FFixupPath(rgchPath) );
	if (FEmptySz(rgchPath))
		return (UiLogError(ERROR_PCW_EXTFILE_BLANK_PATH_TO_FILE, rgchFamily, rgchFTK));
	if (!FFileExist(rgchPath))
		return (UiLogError(ERROR_PCW_EXTFILE_MISSING_FILE, rgchPath, rgchFamily));

	EvalAssert( MSI_OKAY == MsiRecordSetString(hrec, 3, rgchPath) );

	Assert(iOrderMax > 0);
	int iOrder = MsiRecordGetInteger(hrec, 4);
	if (iOrder == MSI_NULL_INTEGER || iOrder < 0)
		EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 4, iOrderMax-1) );
	Assert(iOrder < iOrderMax);

	TCHAR rgchOffsets[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 5, rgchOffsets, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_EXTFILE_LONG_IGNORE_OFFSETS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ExternalFiles.IgnoreOffsets"), szNull));

	int cOffsets = ICountRangeElements(rgchOffsets, fTrue);
	if (cOffsets < 0)
		return (UiLogError(ERROR_PCW_EXTFILE_BAD_IGNORE_OFFSETS, rgchFamily, rgchFTK));
	Assert(cOffsets < 256);

	TCHAR rgchLengths[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 6, rgchLengths, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_EXTFILE_LONG_IGNORE_LENGTHS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ExternalFiles.IgnoreLengths"), szNull));

	int cLengths = ICountRangeElements(rgchLengths, fFalse);
	if (cLengths < 0)
		return (UiLogError(ERROR_PCW_EXTFILE_BAD_IGNORE_LENGTHS, rgchFamily, rgchFTK));
	Assert(cLengths < 256);

	if (cOffsets != cLengths)
		return (UiLogError(ERROR_PCW_EXTFILE_IGNORE_COUNT_MISMATCH, rgchFamily, rgchFTK));

	EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 8, cOffsets) );

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 7, rgchOffsets, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_EXTFILE_LONG_RETAIN_OFFSETS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ExternalFiles.RetainOffsets"), szNull));

	cOffsets = ICountRangeElements(rgchOffsets, fTrue);
	if (cOffsets < 0)
		return (UiLogError(ERROR_PCW_EXTFILE_BAD_RETAIN_OFFSETS, rgchFamily, rgchFTK));
	Assert(cOffsets < 256);

	if (cOffsets > 0)
		{
		StringCchPrintf(rgchLengths, sizeof(rgchLengths)/sizeof(TCHAR), TEXT("`Family`='%s' AND `FTK`='%s'"), rgchFamily, rgchFTK);
		uiRet = IdsMsiGetTableIntegerWhere(hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainCount`"), rgchLengths, &cLengths);
		Assert(uiRet == MSI_OKAY);

		if (cOffsets != cLengths)
			return (UiLogError(ERROR_PCW_EXTFILE_IGNORE_COUNT_MISMATCH, rgchFamily, rgchFTK));
		}

	// TODO - could check for overlaps in ranges

	EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );

	return (IDS_OKAY);
}


static BOOL FFileRecordExistsInImage ( MSIHANDLE hdbInput, LPTSTR szFile, LPTSTR szImage, BOOL fUpgradedImage );

/* ********************************************************************** */
static UINT IdsValidateUFileDataRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchUpgraded[MAX_PATH];
	DWORD dwcch = MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchUpgraded, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedFiles_OptionalData.Upgraded"), szNull));
	if (!FValidImageName(rgchUpgraded))
		return (UiLogError(ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD, rgchUpgraded, szNull));

	TCHAR rgchFTK[MAX_PATH];
	uiRet = IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
				TEXT("`Upgraded`"), TEXT("`Family`"), rgchUpgraded, rgchFTK, MAX_PATH);
	Assert(uiRet == IDS_OKAY);
	if (FEmptySz(rgchFTK))
		return (UiLogError(ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD, rgchUpgraded, szNull));

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UFILEDATA_LONG_FILE_TABLE_KEY, rgchUpgraded, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedFiles_OptionalData.FTK"), szNull));
	if (FEmptySz(rgchFTK))
		return (UiLogError(ERROR_PCW_UFILEDATA_BLANK_FILE_TABLE_KEY, rgchUpgraded, szNull));
	if (!FFileRecordExistsInImage(hdbInput, rgchFTK, rgchUpgraded, fTrue))
		return (UiLogError(ERROR_PCW_UFILEDATA_MISSING_FILE_TABLE_KEY, rgchFTK, rgchUpgraded));

	int iWholeFile = MsiRecordGetInteger(hrec, 3);
	if (iWholeFile == MSI_NULL_INTEGER)
		{
		EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 3, 0) );
		EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );
		}

	return (IDS_OKAY);
}


static BOOL FValidIgnoreFTK ( LPTSTR szFTK );

/* ********************************************************************** */
static UINT IdsValidateUFileIgnoreRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchUpgraded[MAX_PATH];
	DWORD dwcch = MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchUpgraded, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedFilesToIgnore.Upgraded"), szNull));

	TCHAR rgchFTK[MAX_PATH];
	if (lstrcmp(rgchUpgraded, TEXT("*")))
		{
		if (!FValidImageName(rgchUpgraded))
			return (UiLogError(ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD, rgchUpgraded, szNull));

		uiRet = IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`"), TEXT("`Family`"), rgchUpgraded, rgchFTK, MAX_PATH);
		Assert(uiRet == IDS_OKAY);
		if (FEmptySz(rgchFTK))
			return (UiLogError(ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD, rgchUpgraded, szNull));
		}

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UFILEIGNORE_LONG_FILE_TABLE_KEY, rgchUpgraded, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedFilesToIgnore.FTK"), szNull));
	if (FEmptySz(rgchFTK))
		return (UiLogError(ERROR_PCW_UFILEIGNORE_BLANK_FILE_TABLE_KEY, rgchUpgraded, szNull));
	if (!FValidIgnoreFTK(rgchFTK))
		return (UiLogError(ERROR_PCW_UFILEIGNORE_BAD_FILE_TABLE_KEY, rgchUpgraded, rgchFTK));
		
	return (IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FValidIgnoreFTK ( LPTSTR szFTK )
{
	Assert(!FEmptySz(szFTK));

	BOOL fEndsInAsterisk = (*SzLastChar(szFTK) == TEXT('*'));

	if (fEndsInAsterisk)
		*SzLastChar(szFTK) = TEXT('\0');
	Assert(!FEmptySz(szFTK));

	BOOL fRet = fTrue;
	while (*szFTK != TEXT('\0'))
		{
		if (*szFTK == TEXT('*'))
			fRet = fFalse;
		szFTK = CharNext(szFTK);
		}

	if (fEndsInAsterisk)
		lstrcpy(szFTK, TEXT("*"));

	return (fRet);
}

/* ********************************************************************** */
static UINT IdsValidateTargetProductCodesAgainstList( MSIHANDLE hdb )
{
	if (!g_fValidateProductCodeIncluded)
		{
		// MSITRANSFORM_VALIDATE_PRODUCT isn't included anywhere
		// so it doesn't matter whether or not some target product
		// codes in ListOfTargetProductCodes are missing from the TargetImages
		// table
		return (IDS_OKAY);
		}

	UINT cchProp = CchMsiPcwPropertyString(hdb, TEXT("ListOfTargetProductCodes")) + 1; //length + null terminator

	LPTSTR rgchProp = (LPTSTR)LocalAlloc(LPTR, cchProp*sizeof(TCHAR));
	if (!rgchProp)
		return (IDS_OOM);

	UINT ids = IdsMsiGetPcwPropertyString(hdb, TEXT("ListOfTargetProductCodes"), rgchProp, cchProp);
	Assert(ids == IDS_OKAY);

	if (!FEmptySz(rgchProp))
		{
		TCHAR* pch = rgchProp;
		TCHAR* pchBegin = pch;
		TCHAR* pchCur = NULL;

		BOOL fRecExists = FALSE;

		// ListOfTargetProductCodes is a delimited list of Guids, so no DBCS chars here
		while (*pch != '\0')
			{
			if (*pch == ';')
				{
				pchCur = pch;
				*pchCur = '\0';
				pch++; // for ';'

				// check for presence of product code in TargetImages table
				fRecExists = FALSE;
				EvalAssert( IDS_OKAY == IdsMsiExistTableRecords(hdbInput, TEXT("TargetImages"), TEXT("ProductCode"), pchBegin, &fRecExists) );
				if (!fRecExists)
					{
					// patch won't work right
					EvalAssert( NULL == LocalFree((HLOCAL)rgchProp) );
					return (UiLogError(ERROR_PCW_TARGET_BAD_PROD_CODE_VAL, pchBegin, szNull));
					}

				pchBegin = pch; // start of next guid
				}
			else
				{
				pch++;
				}
			}

		// complete last check
		fRecExists = FALSE;
		EvalAssert( IDS_OKAY == IdsMsiExistTableRecords(hdbInput, TEXT("TargetImages"), TEXT("ProductCode"), pchBegin, &fRecExists) );
		if (!fRecExists)
			{
			// patch won't work right
			EvalAssert( NULL == LocalFree((HLOCAL)rgchProp) );
			return (UiLogError(ERROR_PCW_TARGET_BAD_PROD_CODE_VAL, pchBegin, szNull));
			}
		}
       
	EvalAssert( NULL == LocalFree((HLOCAL)rgchProp) );

	return (IDS_OKAY);
}

/* ********************************************************************** */
static UINT IdsValidateTFileDataRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchTarget[MAX_PATH];
	DWORD dwcch = MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetFiles_OptionalData.Upgraded"), szNull));
	if (!FValidImageName(rgchTarget))
		return (UiLogError(ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD, rgchTarget, szNull));

	TCHAR rgchFamily[MAX_PATH];
	uiRet = IdsMsiGetTableString(hdbInput, TEXT("`TargetImages`"),
				TEXT("`Target`"), TEXT("`Family`"), rgchTarget, rgchFamily, MAX_PATH);
	Assert(uiRet == IDS_OKAY);
	if (FEmptySz(rgchFamily))
		return (UiLogError(ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD, rgchTarget, szNull));

	TCHAR rgchFTK[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TFILEDATA_LONG_FILE_TABLE_KEY, rgchTarget, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetFiles_OptionalData.FTK"), szNull));
	if (FEmptySz(rgchFTK))
		return (UiLogError(ERROR_PCW_TFILEDATA_BLANK_FILE_TABLE_KEY, rgchTarget, szNull));
	if (!FFileRecordExistsInImage(hdbInput, rgchFTK, rgchTarget, fFalse))
		return (UiLogError(ERROR_PCW_TFILEDATA_MISSING_FILE_TABLE_KEY, rgchFTK, rgchTarget));

	TCHAR rgchOffsets[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchOffsets, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TFILEDATA_LONG_IGNORE_OFFSETS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetFiles_OptionalData.IgnoreOffsets"), szNull));

	int cOffsets = ICountRangeElements(rgchOffsets, fTrue);
	if (cOffsets < 0)
		return (UiLogError(ERROR_PCW_TFILEDATA_BAD_IGNORE_OFFSETS, rgchFamily, rgchFTK));
	Assert(cOffsets < 256);

	TCHAR rgchLengths[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 4, rgchLengths, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TFILEDATA_LONG_IGNORE_LENGTHS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetFiles_OptionalData.IgnoreLengths"), szNull));

	int cLengths = ICountRangeElements(rgchLengths, fFalse);
	if (cLengths < 0)
		return (UiLogError(ERROR_PCW_TFILEDATA_BAD_IGNORE_LENGTHS, rgchFamily, rgchFTK));
	Assert(cLengths < 256);

	if (cOffsets != cLengths)
		return (UiLogError(ERROR_PCW_TFILEDATA_IGNORE_COUNT_MISMATCH, rgchFamily, rgchFTK));

	EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 6, cOffsets) );

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 5, rgchOffsets, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TFILEDATA_LONG_RETAIN_OFFSETS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetFiles_OptionalData.RetainOffsets"), szNull));

	cOffsets = ICountRangeElements(rgchOffsets, fTrue);
	if (cOffsets < 0)
		return (UiLogError(ERROR_PCW_TFILEDATA_BAD_RETAIN_OFFSETS, rgchFamily, rgchFTK));
	Assert(cOffsets < 256);

	if (cOffsets > 0)
		{
		StringCchPrintf(rgchLengths, sizeof(rgchLengths)/sizeof(TCHAR), TEXT("`Family`='%s' AND `FTK`='%s'"), rgchFamily, rgchFTK);
		uiRet = IdsMsiGetTableIntegerWhere(hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainCount`"), rgchLengths, &cLengths);
		Assert(uiRet == MSI_OKAY);

		if (cOffsets != cLengths)
			return (UiLogError(ERROR_PCW_TFILEDATA_IGNORE_COUNT_MISMATCH, rgchFamily, rgchFTK));
		}

	// TODO - could check for overlaps in ranges

	EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );

	return (IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FFileRecordExistsInImage ( MSIHANDLE hdbInput, LPTSTR szFile, LPTSTR szImage, BOOL fUpgradedImage )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szFile));
	Assert(!FEmptySz(szImage));

	MSIHANDLE hdb = HdbReopenMsi(hdbInput, szImage, fUpgradedImage, fFalse);
	Assert(hdb != NULL);

	BOOL fExists = fFalse;
	EvalAssert( IDS_OKAY == IdsMsiExistTableRecords(hdb, TEXT("`File`"), TEXT("`File`"), szFile, &fExists) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdb) );

	return (fExists);
}


/* ********************************************************************** */
static BOOL FValidName ( LPTSTR sz, int cchMax )
{
	Assert(sz != szNull);

	if (FEmptySz(sz) || lstrlen(sz) > cchMax
			|| *sz == TEXT('_') || *SzLastChar(sz) == TEXT('_'))
		{
		return (fFalse);
		}

	while (!FEmptySz(sz))
		{
		TCHAR ch = *sz;
		if ((ch < TEXT('a') || ch > TEXT('z'))
				&& (ch < TEXT('A') || ch > TEXT('Z'))
				&& (ch < TEXT('0') || ch > TEXT('9'))
				&& ch != TEXT('_') )
			{
			return (fFalse);
			}
		sz = CharNext(sz);
		}

	return (fTrue);
}


/* ********************************************************************** */
static BOOL FUniqueImageName ( LPTSTR sz, MSIHANDLE hdbInput )
{
	Assert(!FEmptySz(sz));
	Assert(FValidImageName(sz));
	Assert(lstrlen(sz) < 32);
	Assert(hdbInput != NULL);

	TCHAR rgch[32];
	lstrcpy(rgch, sz);
	CharUpper(rgch);

	BOOL fExist = fFalse;
	UINT ids = IdsMsiExistTableRecords(hdbInput, TEXT("`TempImageNames`"),
				TEXT("`ImageName`"), rgch, &fExist);
	Assert(ids == MSI_OKAY);

	if (!fExist)
		{
		TCHAR rgchQuery[MAX_PATH];
		StringCchPrintf(rgchQuery, sizeof(rgchQuery)/sizeof(TCHAR), TEXT("INSERT INTO `TempImageNames` ( `ImageName` ) VALUES ( '%s' )"), rgch);
		EvalAssert( FExecSqlCmd(hdbInput, rgchQuery) );
		}

	return (!fExist);
}


/* ********************************************************************** */
static BOOL FUniquePackageCode ( LPTSTR sz, MSIHANDLE hdbInput )
{
	Assert(!FEmptySz(sz));
	Assert(lstrlen(sz) < 64);
	Assert(hdbInput != NULL);

	TCHAR rgch[64];
	lstrcpy(rgch, sz);
	CharUpper(rgch);

	BOOL fExist = fFalse;
	UINT ids = IdsMsiExistTableRecords(hdbInput, TEXT("`TempPackCodes`"),
				TEXT("`PackCode`"), rgch, &fExist);
	Assert(ids == MSI_OKAY);

	if (!fExist)
		{
		TCHAR rgchQuery[MAX_PATH];
		StringCchPrintf(rgchQuery, sizeof(rgchQuery)/sizeof(TCHAR), TEXT("INSERT INTO `TempPackCodes` ( `PackCode` ) VALUES ( '%s' )"), rgch);
		EvalAssert( FExecSqlCmd(hdbInput, rgchQuery) );
		}

	return (!fExist);
}


/* ********************************************************************** */
static BOOL FNoUpgradedImages ( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	BOOL fExists = fFalse;
	EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput, TEXT("`UpgradedImages`"), TEXT("`Upgraded`"), TEXT(" "), &fExists) );

#ifdef DEBUG
	if (fExists)
		{
		BOOL fExistsTarget = fFalse;
		EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput, TEXT("`TargetImages`"), TEXT("`Target`"), TEXT(" "), &fExistsTarget) );
		Assert(fExistsTarget);

		fExistsTarget = fFalse;
		EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput, TEXT("`ImageFamilies`"), TEXT("`Family`"), TEXT(" "), &fExistsTarget) );
		Assert(fExistsTarget);
		}
#endif

	return (!fExists);
}

static UINT IdsCheckPCodeAndVersion( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FCheckForProductCodeMismatchWithVersionMatch( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	UINT ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`Upgraded`,`ProductCode`,`ProductVersion`"),
					szNull, IdsCheckPCodeAndVersion, (LPARAM)(hdb), 0L);
	if (ids == IDS_OKAY)
		return (fTrue);

	return (fFalse);
}

static UINT IdsCheckProductCode ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FCheckForProductCodeMismatches ( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	TCHAR rgch[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdb, TEXT("AllowProductCodeMismatches"), rgch, MAX_PATH) );

	if ((!FEmptySz(rgch)) && (*rgch != TEXT('0')))
		return (fTrue);

	UINT ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`Upgraded`,`ProductCode`"),
					szNull, IdsCheckProductCode, (LPARAM)(hdb), 0L);
	Assert(ids == IDS_OKAY || ids == IDS_CANCEL);
	if (ids == IDS_OKAY)
		return (fTrue);

	if (IDNO == IMessageBoxIds(HdlgStatus(), IDS_PRODUCTCODES_DONT_MATCH, MB_YESNO | MB_ICONQUESTION))
		{
		FWriteLogFile(TEXT("  ERROR - ProductCodes do not match between Target and Upgraded images.\r\n"));
		return (fFalse);
		}

	FWriteLogFile(TEXT("  User supressed error for ProductCodes not matching between Target and Upgraded images.\r\n"));

	return (fTrue);
}

static int ICompareVersions ( LPTSTR szUpgradedPC, LPTSTR szTargetPC );

/* ********************************************************************** */
static UINT IdsCheckPCodeAndVersion( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2   == 0L);

	MSIHANDLE hdb = (MSIHANDLE)(lp1);
	Assert(hdb != NULL);

	DWORD dwcch = 64;

	TCHAR rgchUpgradedImage[64] = {0};
	TCHAR rgchTargetPC[40] = {0};
	TCHAR rgchUpgradePC[40] = {0};
	TCHAR rgchTargetPV[32] = {0};
	TCHAR rgchUpgradePV[32] = {0};

	UINT uiRet = MsiRecordGetString(hrec, 2, rgchUpgradedImage, &dwcch);
	Assert(uiRet == MSI_OKAY && !FEmptySz(rgchUpgradedImage));

	dwcch = 40;
	uiRet = MsiRecordGetString(hrec, 3, rgchTargetPC, &dwcch);
	Assert(uiRet == MSI_OKAY && !FEmptySz(rgchTargetPC));

	dwcch = 32;
	uiRet = MsiRecordGetString(hrec, 4, rgchTargetPV, &dwcch);
	Assert(uiRet == MSI_OKAY && !FEmptySz(rgchTargetPV));

	dwcch = 40;
	uiRet = IdsMsiGetTableString(hdb, TEXT("`UpgradedImages`"),
				TEXT("`Upgraded`"), TEXT("`ProductCode`"),
				rgchUpgradedImage, rgchUpgradePC, 40);
	Assert(uiRet == MSI_OKAY && !FEmptySz(rgchUpgradePC));

	dwcch = 32;
	uiRet = IdsMsiGetTableString(hdb, TEXT("`UpgradedImages`"),
				TEXT("`Upgraded`"), TEXT("`ProductVersion`"),
				rgchUpgradedImage, rgchUpgradePV, 32);
	Assert(uiRet == MSI_OKAY && !FEmptySz(rgchUpgradePV));

	// report an error when the product codes differ but the product versions are the same
	// -- patch would generally be okay, but we want to err on the side of caution
	// -- see Whistler bug #355521
	// -- at least one of the 3 fields of the ProductVersion must change to use the Upgrade table
	//    which enables major update functionality (which coincidentally, requires a ProductCode change)
	//
	if (0 != lstrcmpi(rgchTargetPC, rgchUpgradePC)
		&& 0 == ICompareVersions(rgchUpgradePV, rgchTargetPV))
		return (ERROR_PCW_MATCHED_PRODUCT_VERSIONS);

	return (IDS_OKAY);
}

/* ********************************************************************** */
static UINT IdsCheckProductCode ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2   == 0L);

	MSIHANDLE hdb = (MSIHANDLE)(lp1);
	Assert(hdb != NULL);

	TCHAR rgchUpgradedImage[64];
	DWORD dwcch = 64;
	UINT uiRet = MsiRecordGetString(hrec, 2, rgchUpgradedImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchUpgradedImage));

	TCHAR rgchTargetPC[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 3, rgchTargetPC, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchTargetPC));

	TCHAR rgchUpgradedPC[64];
	uiRet = IdsMsiGetTableString(hdb, TEXT("`UpgradedImages`"),
				TEXT("`Upgraded`"), TEXT("`ProductCode`"),
				rgchUpgradedImage, rgchUpgradedPC, 64);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchUpgradedPC));

	Assert(MSI_OKAY == IDS_OKAY);
	Assert(uiRet == IDS_OKAY);
	if (lstrcmpi(rgchTargetPC, rgchUpgradedPC))
		uiRet = IDS_CANCEL;

	return (uiRet);
}

static UINT IdsCheckProductVersion ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FCheckForProductVersionMismatches ( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	BOOL fLower = fFalse;
	UINT ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`Upgraded`,`ProductVersion`"),
					szNull, IdsCheckProductVersion, (LPARAM)(hdb), (LPARAM)(&fLower));
	Assert(ids == IDS_OKAY || ids == IDS_CANCEL);
	if (ids == IDS_OKAY)
		return (fTrue);

	if (fLower)
		{
		if (IDNO == IMessageBoxIds(HdlgStatus(), IDS_PRODUCTVERSION_INVERSION, MB_YESNO | MB_ICONQUESTION))
			{
			FWriteLogFile(TEXT("  ERROR - Target ProductVersion is greater than Upgraded image.\r\n"));
			return (fFalse);
			}

		FWriteLogFile(TEXT("  User supressed error for Target ProductVersion greater than Upgraded image.\r\n"));
		return (fTrue);
		}

	TCHAR rgch[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdb, TEXT("AllowProductVersionMajorMismatches"), rgch, MAX_PATH) );
	
	if ((!FEmptySz(rgch)) && (*rgch != TEXT('0')))
		return (fTrue);

	if (IDNO == IMessageBoxIds(HdlgStatus(), IDS_PRODUCTVERSIONS_DONT_MATCH, MB_YESNO | MB_ICONQUESTION))
		{
		FWriteLogFile(TEXT("  ERROR - ProductVersions do not match between Target and Upgraded images.\r\n"));
		return (fFalse);
		}

	FWriteLogFile(TEXT("  User supressed error for ProductVersions not matching between Target and Upgraded images.\r\n"));

	return (fTrue);
}


/* ********************************************************************** */
static UINT IdsCheckProductVersion ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	MSIHANDLE hdb = (MSIHANDLE)(lp1);
	Assert(hdb != NULL);
	PBOOL pfLower = (PBOOL)(lp2);
	Assert(pfLower != NULL);

	TCHAR rgchUpgradedImage[64];
	DWORD dwcch = 64;
	UINT uiRet = MsiRecordGetString(hrec, 2, rgchUpgradedImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchUpgradedImage));

	TCHAR rgchTargetPV[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 3, rgchTargetPV, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchTargetPV));

	TCHAR rgchUpgradedPV[64];
	uiRet = IdsMsiGetTableString(hdb, TEXT("`UpgradedImages`"),
				TEXT("`Upgraded`"), TEXT("`ProductVersion`"),
				rgchUpgradedImage, rgchUpgradedPV, 64);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchUpgradedPV));

	Assert(MSI_OKAY == IDS_OKAY);
	Assert(uiRet == IDS_OKAY);
	int i = ICompareVersions(rgchUpgradedPV, rgchTargetPV);
	if (i != 0)
		{
		uiRet = IDS_CANCEL;
		if (i < 0)
			*pfLower = fTrue;
		}

	return (uiRet);
}


/* ********************************************************************** */
static int ICompareVersions ( LPTSTR szUpgradedPC, LPTSTR szTargetPC )
{
	// compares the next field of the 2 versions.
	// if they match, make a recursive call to compare the next field
	
	Assert(szUpgradedPC != szNull);
	Assert(szTargetPC != szNull);
	if (*szUpgradedPC == TEXT('\0') && *szTargetPC == TEXT('\0'))
		return (0);

	LPTSTR szUpgradedNext = szUpgradedPC;
	while (*szUpgradedNext != TEXT('\0') && *szUpgradedNext != TEXT('.'))
		szUpgradedNext = CharNext(szUpgradedNext);
	if(*szUpgradedNext != TEXT('\0'))
	{
		*szUpgradedNext = TEXT('\0');
		szUpgradedNext++;
	}

	LPTSTR szTargetNext = szTargetPC;
	while (*szTargetNext != TEXT('\0') && *szTargetNext != TEXT('.'))
		szTargetNext = CharNext(szTargetNext);
	if(*szTargetNext != TEXT('\0'))
	{
		*szTargetNext = TEXT('\0');
		szTargetNext++;
	}

	int iUpgradedField = _ttoi(szUpgradedPC);
	int iTargetField   = _ttoi(szTargetPC);
	
	if(iUpgradedField < iTargetField)
		return (-1);
	else if(iUpgradedField > iTargetField)
		return (1);
	else
		return (ICompareVersions(szUpgradedNext, szTargetNext));
}


static UINT IdsCountTargets ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsCatTargetProductCode ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static void FillInListOfTargetProductCodes ( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	UINT cchCur;
	cchCur = CchMsiPcwPropertyString(hdb, TEXT("ListOfTargetProductCodes"));
	if (cchCur < 63)
		cchCur = 64;
	else
		cchCur++;

	LPTSTR rgchCur = (LPTSTR)LocalAlloc(LPTR, cchCur*sizeof(TCHAR));
	Assert(rgchCur != szNull);
	if (rgchCur == szNull)
		return;


	UINT ids = IdsMsiGetPcwPropertyString(hdb, TEXT("ListOfTargetProductCodes"), rgchCur, cchCur);
	Assert(ids == IDS_OKAY);
	if (FEmptySz(rgchCur) || *rgchCur == TEXT('*'))
		{
		if (*rgchCur == TEXT('*'))
			{
			Assert(*(rgchCur+1) == TEXT('\0') || *(rgchCur+1) == TEXT(';'));
			if (*(rgchCur+1) == TEXT('\0'))
				*rgchCur = TEXT('\0');
			else if (*(rgchCur+1) == TEXT(';'))
				lstrcpy(rgchCur, rgchCur+2);
			else
				lstrcpy(rgchCur, rgchCur+1);
			}

		UINT cTargets = 0;
		ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`ProductCode`"), szNull,
					IdsCountTargets, (LPARAM)(&cTargets), 0);
		Assert(ids == IDS_OKAY);
		if (cTargets < 4)
			cTargets = 4;
		if (cTargets > 512)
			{
			AssertFalse();
			cTargets = 512;
			}

		LPTSTR rgchNew = (LPTSTR)LocalAlloc(LPTR, (cTargets*64 + cchCur)*sizeof(TCHAR));
		Assert(rgchNew != szNull);
		if (rgchNew == szNull)
			{
			EvalAssert( NULL == LocalFree((HLOCAL)rgchCur) );
			return;
			}


		*rgchNew = TEXT('\0');
		ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`ProductCode`"), szNull,
					IdsCatTargetProductCode, (LPARAM)(rgchNew),
					(LPARAM)(cTargets*64));
		Assert(ids == IDS_OKAY);
		Assert(!FEmptySz(rgchNew));

		if (!FEmptySz(rgchCur))
			{
			lstrcat(rgchNew, TEXT(";"));
			lstrcat(rgchNew, rgchCur);
			}

		ids = IdsMsiSetPcwPropertyString(hdb, TEXT("ListOfTargetProductCodes"), rgchNew);
		Assert(ids == IDS_OKAY);

		EvalAssert( NULL == LocalFree((HLOCAL)rgchNew) );
		}

	EvalAssert( NULL == LocalFree((HLOCAL)rgchCur) );
}


/* ********************************************************************** */
static UINT IdsCountTargets ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0);

	UINT* pcTargets = (UINT*)(lp1);
	Assert(pcTargets != NULL);

	TCHAR rgch[64];
	DWORD dwcch = 64;
	UINT uiRet = MsiRecordGetString(hrec, 2, rgch, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgch));

	(*pcTargets)++;

	return (IDS_OKAY);
}


/* ********************************************************************** */
static UINT IdsCatTargetProductCode ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	LPTSTR szBuf  = (LPTSTR)(lp1);
	int    cchBuf = (int)(lp2);
	Assert(szBuf != szNull);
	Assert(cchBuf > 0);
	Assert(lstrlen(szBuf) < cchBuf);

	TCHAR rgch[64];
	DWORD dwcch = 64;
	UINT uiRet = MsiRecordGetString(hrec, 2, rgch, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgch));

	if (lstrlen(szBuf) + lstrlen(rgch) + 2 >= cchBuf)
		{
		AssertFalse();
		return (IDS_CANCEL);
		}

	LPTSTR sz = szBuf;
	while (!FEmptySz(sz))
		{
		Assert(lstrlen(sz) >= lstrlen(rgch));
		if (FMatchPrefix(sz, rgch))
			return (IDS_OKAY);
		sz += lstrlen(rgch);
		if (!FEmptySz(sz))
			{
			Assert(*sz == TEXT(';'));
			sz++;
			Assert(!FEmptySz(sz));
			}
		}

	if (!FEmptySz(szBuf))
		lstrcat(szBuf, TEXT(";"));
	lstrcat(szBuf, rgch);

	return (IDS_OKAY);
}


static UINT IdsCopyUpgradeMsi ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
UINT UiCopyUpgradedMsiToTempFolderForEachTarget ( MSIHANDLE hdb, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);

	hdbInput = hdb;

	UINT ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`Upgraded`,`MsiPathUpgradedCopy`"),
					szNull, IdsCopyUpgradeMsi,
					(LPARAM)(szTempFolder), (LPARAM)(szTempFName));
	if (ids != IDS_OKAY)
		return (ids);

	return (ERROR_SUCCESS);
}


static UINT UiCreatePatchingTables ( MSIHANDLE hdb, LPTSTR szFamily, LPTSTR szTempFolder, LPTSTR szTempFName );

/* ********************************************************************** */
static UINT IdsCopyUpgradeMsi ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	LPTSTR szTempFolder = (LPTSTR)(lp1);
	LPTSTR szTempFName  = (LPTSTR)(lp2);
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);
	Assert(szTempFolder != szTempFName);

	Assert(hdbInput != NULL);

	TCHAR rgchTarget[64];
	DWORD dwcch = 64;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchTarget));
	Assert(FValidImageName(rgchTarget));

	lstrcpy(szTempFName, rgchTarget);
	lstrcat(szTempFName, TEXT(".MSI"));
	Assert(!FFileExist(szTempFolder));
	Assert(!FFolderExist(szTempFolder));

#define rgchUpgraded rgchTarget // reuse buffer
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 2, rgchUpgraded, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchUpgraded));
	Assert(FValidImageName(rgchUpgraded));

	TCHAR rgchUpgradedMsi[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput,
					TEXT("`UpgradedImages`"), TEXT("`Upgraded`"),
					TEXT("`PatchMsiPath`"), rgchUpgraded, rgchUpgradedMsi, MAX_PATH) );
	if (FEmptySz(rgchUpgradedMsi))
		{
		EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput,
						TEXT("`UpgradedImages`"), TEXT("`Upgraded`"),
						TEXT("`MsiPath`"), rgchUpgraded, rgchUpgradedMsi, MAX_PATH) );
		Assert(!FEmptySz(rgchUpgradedMsi));
		}
	Assert(FFileExist(rgchUpgradedMsi));

	if (!CopyFile(rgchUpgradedMsi, szTempFolder, fFalse))
		return (UiLogError(ERROR_PCW_OODS_COPYING_MSI, rgchUpgradedMsi, szTempFolder));

	SetFileAttributes(szTempFolder, FILE_ATTRIBUTE_NORMAL);

	MSIHANDLE hdb = NULL;
	EvalAssert( MSI_OKAY == MsiOpenDatabase(szTempFolder, MSIDBOPEN_DIRECT, &hdb) );
	Assert(hdb != NULL);

	EvalAssert( MSI_OKAY == MsiRecordSetString(hrec, 3, szTempFolder) );
	EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );

#define rgchPackageCode rgchUpgradedMsi // reuse buffer
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`"), TEXT("`PackageCode`"), rgchUpgraded,
					rgchPackageCode, MAX_PATH) );
	EvalAssert( IDS_OKAY == IdsMsiSetPropertyString(hdb,
					TEXT("PATCHNEWPACKAGECODE"), rgchPackageCode) );

#define rgchSummSubject rgchUpgradedMsi // reuse buffer
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`"), TEXT("`SummSubject`"), rgchUpgraded,
					rgchSummSubject, MAX_PATH) );
	EvalAssert( IDS_OKAY == IdsMsiSetPropertyString(hdb,
					TEXT("PATCHNEWSUMMARYSUBJECT"), rgchSummSubject) );

#define rgchSummComments rgchUpgradedMsi // reuse buffer
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`"), TEXT("`SummComments`"), rgchUpgraded,
					rgchSummComments, MAX_PATH) );
	EvalAssert( IDS_OKAY == IdsMsiSetPropertyString(hdb,
					TEXT("PATCHNEWSUMMARYCOMMENTS"), rgchSummComments) );

#define rgchFamily rgchUpgradedMsi // reuse buffer
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`"), TEXT("`Family`"), rgchUpgraded,
					rgchFamily, 64) );
	Assert(!FEmptySz(rgchFamily));
	Assert(FValidFamilyName(rgchFamily));

	uiRet = UiCreatePatchingTables(hdb, rgchFamily, szTempFolder, szTempFName);

	EvalAssert( MSI_OKAY == MsiDatabaseCommit(hdb) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdb) );

	return (uiRet);
}


static BOOL FValidPatchTableFormat  ( MSIHANDLE hdb, pteEnum ptePatchTable );
static void UpdatePatchPackageTable ( MSIHANDLE hdb, MSIHANDLE hdbInput, LPTSTR szFamily );
static void UpdateMediaTable        ( MSIHANDLE hdb, MSIHANDLE hdbInput, LPTSTR szFamily );
static void InsertPatchFilesActionIntoTable ( MSIHANDLE hdb, LPTSTR szTable );

/* ********************************************************************** */
static UINT UiCreatePatchingTables ( MSIHANDLE hdb, LPTSTR szFamily, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szFamily));
	Assert(FValidFamilyName(szFamily));
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);
	Assert(szTempFolder != szTempFName);

	lstrcpy(szTempFName, TEXT("Patch.idt"));
	Assert(FFileExist(szTempFolder));
	lstrcpy(szTempFName, TEXT("PPackage.idt"));
	Assert(FFileExist(szTempFolder));
	lstrcpy(szTempFName, TEXT("MsiPatch.idt"));
	Assert(FFileExist(szTempFolder));
	*szTempFName = TEXT('\0');

	if (FTableExists(hdb, TEXT("Patch"), fFalse) && !FValidPatchTableFormat(hdb, ptePatch))
		{
		// drop the Patch table 
		MSIHANDLE hViewPatch = NULL;
		EvalAssert( MSI_OKAY == MsiDatabaseOpenView(hdb, TEXT("DROP TABLE `Patch`"), &hViewPatch) );
		EvalAssert( MSI_OKAY == MsiViewExecute(hViewPatch, 0) );
		EvalAssert( MSI_OKAY == MsiViewClose(hViewPatch) );
		EvalAssert( MSI_OKAY == MsiCloseHandle(hViewPatch) );
		EvalAssert( MSI_OKAY == MsiDatabaseCommit(hdb) );
		}

	EvalAssert( ERROR_SUCCESS == MsiDatabaseImport(hdb, szTempFolder, TEXT("Patch.idt")) );
	Assert(FTableExists(hdb, TEXT("Patch"), fFalse));
	Assert(FValidPatchTableFormat(hdb, ptePatch));

	if (!FTableExists(hdb, TEXT("PatchPackage"), fFalse))
		{
		EvalAssert( ERROR_SUCCESS == MsiDatabaseImport(hdb, szTempFolder, TEXT("PPackage.idt")) );
		Assert(FTableExists(hdb, TEXT("PatchPackage"), fFalse));
		}
	Assert(FValidPatchTableFormat(hdb, ptePatchPackage));

	if (!FTableExists(hdb, TEXT("MsiPatchHeaders"), fFalse))
		{
		EvalAssert( ERROR_SUCCESS == MsiDatabaseImport(hdb, szTempFolder, TEXT("MsiPatch.idt")) );
		Assert(FTableExists(hdb, TEXT("MsiPatchHeaders"), fFalse));
		}
	Assert(FValidPatchTableFormat(hdb, pteMsiPatchHeaders));

	Assert(hdbInput != NULL);
	UpdatePatchPackageTable(hdb, hdbInput, szFamily);
	UpdateMediaTable(hdb, hdbInput, szFamily);
	InsertPatchFilesActionIntoTable(hdb, TEXT("`InstallExecuteSequence`"));
	InsertPatchFilesActionIntoTable(hdb, TEXT("`AdminExecuteSequence`"));

	return (IDS_OKAY);
}


/* ********************************************************************** */
BOOL FExecSqlCmd ( MSIHANDLE hdb, LPTSTR sz )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(sz));

	MSIHANDLE hview = NULL;
	UINT      uiRet = MsiDatabaseOpenView(hdb, sz, &hview);
	if (uiRet != MSI_OKAY)
		{
		AssertFalse();
		return (fFalse);
		}
	uiRet = MsiViewExecute(hview, 0);
	if (uiRet != IDS_OKAY)
		{
		AssertFalse();
		return (fFalse);
		}
	EvalAssert( MSI_OKAY == MsiCloseHandle(hview) );

	return (fTrue);
}


/* ********************************************************************** */
static void UpdatePatchPackageTable ( MSIHANDLE hdb, MSIHANDLE hdbInput, LPTSTR szFamily )
{
	Assert(hdb != NULL);
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szFamily));
	Assert(FValidFamilyName(szFamily));

	int iDiskId = 1;
	EvalAssert( IDS_OKAY == IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), TEXT("`MediaDiskId`"), szFamily, &iDiskId) );

	if (iDiskId == MSI_NULL_INTEGER)
		{
		// assume this is a Windows Installer 2.0 targeted patch; we have validation elsewhere to catch this
		// iDiskId is set to 2 (always) in this case.  The sequence conflict management feature of Windows
		// Installer 2.0 can handle this

		iDiskId = 2;
		}
	Assert(iDiskId > 1);

	TCHAR rgch[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput, TEXT("PatchGUID"), rgch, MAX_PATH) );
	Assert(!FEmptySz(rgch));
	CharUpper(rgch);

	MSIHANDLE hrec = MsiCreateRecord(2);
	Assert(hrec != NULL);
	EvalAssert( MsiRecordSetString(hrec, 1, rgch) == MSI_OKAY );
	EvalAssert( MsiRecordSetInteger(hrec, 2, iDiskId) == MSI_OKAY );

	TCHAR rgchQuery[MAX_PATH];
	StringCchPrintf(rgchQuery, sizeof(rgchQuery)/sizeof(TCHAR), TEXT("SELECT %s FROM %s WHERE %s='%s'"),
			TEXT("`PatchId`,`Media_`"), TEXT("`PatchPackage`"),
			TEXT("`PatchId`"), rgch);
	Assert(lstrlen(rgchQuery) < sizeof(rgchQuery)/sizeof(TCHAR));

	MSIHANDLE hview = NULL;
	EvalAssert( MsiDatabaseOpenView(hdb, rgchQuery, &hview) == MSI_OKAY );
	Assert(hview != NULL);
	EvalAssert( MsiViewExecute(hview, 0) == MSI_OKAY );
	EvalAssert( MsiViewModify(hview, MSIMODIFY_ASSIGN, hrec) == MSI_OKAY );

	EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);
}


/* ********************************************************************** */
static void UpdateMediaTable ( MSIHANDLE hdb, MSIHANDLE hdbInput, LPTSTR szFamily )
{
	Assert(hdb != NULL);
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szFamily));
	Assert(FValidFamilyName(szFamily));

	int iDiskId = 0;
	EvalAssert( IDS_OKAY == IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), TEXT("`MediaDiskId`"), szFamily, &iDiskId) );

	if (iDiskId == MSI_NULL_INTEGER)
		{
		// assume WI 2.0 targeted patch (MediaDiskId can be NULL); validation elsewhere -- sequence conflict management
		// feature of WI 2.0 handles this, set to 2 always in this case
		iDiskId = 2;
		}
	Assert(iDiskId > 1);

	int iFileSeqStart = 0;
	EvalAssert( IDS_OKAY == IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), TEXT("`FileSequenceStart`"), szFamily, &iFileSeqStart) );

	if (iFileSeqStart == MSI_NULL_INTEGER)
		{
		// assume WI 2.0 targeted patch (FileSequenceStart can be NULL); validation elsewhere -- sequence conflict management
		// feature of WI 2.0 handles this, set to 2 always in this case
		iFileSeqStart = 2;
		}
	Assert(iFileSeqStart > 1);

	TCHAR rgchCabName[MAX_PATH];
	StringCchPrintf(rgchCabName, sizeof(rgchCabName)/sizeof(TCHAR), TEXT("#PCW_CAB_%s"), szFamily);

	MSIHANDLE hrec = MsiCreateRecord(6);
	Assert(hrec != NULL);
	EvalAssert( MsiRecordSetInteger(hrec, 1, iDiskId) == MSI_OKAY );
	EvalAssert( MsiRecordSetInteger(hrec, 2, iFileSeqStart) == MSI_OKAY ); // to be updated later
	EvalAssert( MsiRecordSetString(hrec,  3, rgchCabName) == MSI_OKAY );

	TCHAR rgch[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), TEXT("`MediaSrcPropName`"), szFamily, rgch, MAX_PATH) );
	if (!FEmptySz(rgch))
		{
		EvalAssert( MsiRecordSetString(hrec,  4, rgch) == MSI_OKAY );
		}
	else
		{
		// else WI 2.0 targeted patch (MediaSrcPropName can be NULL); validation elsewhere -- sequence conflict management feature
		// of WI 2.0 handles this, set to PATCHMediaSrcProp always in this case
		EvalAssert( MsiRecordSetString(hrec, 4, szPatchMediaSrcProp) == MSI_OKAY );
		}

	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), TEXT("`DiskPrompt`"), szFamily, rgch, MAX_PATH) );
	EvalAssert( MsiRecordSetString(hrec,  5, rgch) == MSI_OKAY );

	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), TEXT("`VolumeLabel`"), szFamily, rgch, MAX_PATH) );
	EvalAssert( MsiRecordSetString(hrec,  6, rgch) == MSI_OKAY );

#define rgchQuery rgchCabName // reuse buffer
	StringCchPrintf(rgchQuery, sizeof(rgchQuery)/sizeof(TCHAR), TEXT("SELECT %s FROM %s WHERE %s=%d"),
			TEXT("`DiskId`,`LastSequence`,`Cabinet`,`Source`,`DiskPrompt`,`VolumeLabel`"),
			TEXT("`Media`"), TEXT("`DiskId`"), iDiskId);
	Assert(lstrlen(rgchQuery) < sizeof(rgchQuery)/sizeof(TCHAR));

	MSIHANDLE hview = NULL;
	EvalAssert( MsiDatabaseOpenView(hdb, rgchQuery, &hview) == MSI_OKAY );
	Assert(hview != NULL);
	EvalAssert( MsiViewExecute(hview, 0) == MSI_OKAY );
	EvalAssert( MsiViewModify(hview, MSIMODIFY_ASSIGN, hrec) == MSI_OKAY );

	EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);
}


/* ********************************************************************** */
static void InsertPatchFilesActionIntoTable ( MSIHANDLE hdb, LPTSTR szTable )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!lstrcmp(szTable, TEXT("`InstallExecuteSequence`"))
				|| !lstrcmp(szTable, TEXT("`AdminExecuteSequence`")));

	BOOL fExists = fFalse;
	EvalAssert( IDS_OKAY == IdsMsiExistTableRecords(hdb, szTable,
					TEXT("`Action`"), TEXT("PatchFiles"), &fExists) );
	if (fExists)
		return;

	int iSeq = 0;
	EvalAssert( IDS_OKAY == IdsMsiGetTableInteger(hdb, szTable,
					TEXT("`Action`"), TEXT("`Sequence`"),
					TEXT("InstallFiles"), &iSeq) );
	Assert(iSeq > 0);

	MSIHANDLE hrec = MsiCreateRecord(2);
	Assert(hrec != NULL);
	EvalAssert( MsiRecordSetString(hrec, 1, TEXT("PatchFiles")) == MSI_OKAY );
	EvalAssert( MsiRecordSetInteger(hrec, 2, iSeq + 1) == MSI_OKAY );

	TCHAR rgchQuery[MAX_PATH];
	StringCchPrintf(rgchQuery, sizeof(rgchQuery)/sizeof(TCHAR), TEXT("SELECT %s FROM %s WHERE %s='%s'"),
			TEXT("`Action`,`Sequence`"), szTable,
			TEXT("`Action`"), TEXT("PatchFiles"));
	Assert(lstrlen(rgchQuery) < sizeof(rgchQuery)/sizeof(TCHAR));

	MSIHANDLE hview = NULL;
	EvalAssert( MsiDatabaseOpenView(hdb, rgchQuery, &hview) == MSI_OKAY );
	Assert(hview != NULL);
	EvalAssert( MsiViewExecute(hview, 0) == MSI_OKAY );
	EvalAssert( MsiViewModify(hview, MSIMODIFY_ASSIGN, hrec) == MSI_OKAY );

	EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);
}


static void LogSzProp  ( MSIHANDLE hdbInput, LPTSTR szProp, LPTSTR szBuf, LPTSTR szBufLog );
static UINT UiCreatePatchingTableExportFile ( MSIHANDLE hdbInput, pteEnum ptePatchTable, LPTSTR szTempFolder, LPTSTR szTempFName );

#define BIGPROPERTYSIZE (49*1024)

/* ********************************************************************** */
static UINT UiValidateAndLogPCWProperties ( MSIHANDLE hdbInput, LPTSTR szPcpPath, LPTSTR szPatchPath, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szPcpPath));
	Assert(!FEmptySz(szPatchPath));
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);
	*szTempFName = TEXT('\0');
	Assert(!FEmptySz(szTempFolder));

	EvalAssert( FSprintfToLog(TEXT("Input-PCP path                     = '%s'"), szPcpPath, szEmpty, szEmpty, szEmpty) );
	EvalAssert( FSprintfToLog(TEXT("Patch-MSP path                     = '%s'"), szPatchPath, szEmpty, szEmpty, szEmpty) );
	EvalAssert( FSprintfToLog(TEXT("Temp Folder                        = '%s'"), szTempFolder, szEmpty, szEmpty, szEmpty) );

	TCHAR rgchLog[BIGPROPERTYSIZE+64];

	TCHAR rgch[BIGPROPERTYSIZE];
	UINT ids;

	UpdateStatusMsg(0, szNull, TEXT("PatchGUID"));
	ids = IdsMsiGetPcwPropertyString(hdbInput, TEXT("PatchGUID"), rgch, MAX_PATH);
	Assert(ids == IDS_OKAY);
	CharUpper(rgch);
	if (FEmptySz(rgch))
		return (UiLogError(ERROR_PCW_MISSING_PATCH_GUID, NULL, NULL));
	if (!FValidGUID(rgch, fFalse, fFalse, fFalse))
		return (UiLogError(ERROR_PCW_BAD_PATCH_GUID, rgch, NULL));

	StringCchPrintf(rgchLog, sizeof(rgchLog)/sizeof(TCHAR), TEXT("Patch GUID                         = '%s'\r\n"), rgch);
	EvalAssert( FWriteLogFile(rgchLog) );
	EvalAssert( FUniquePackageCode(rgch, hdbInput) ); // first entry

	UpdateStatusMsg(0, szNull, TEXT("ListOfPatchGUIDsToReplace"));
	ids = IdsMsiGetPcwPropertyString(hdbInput, TEXT("ListOfPatchGUIDsToReplace"), rgch, BIGPROPERTYSIZE);
	Assert(ids == IDS_OKAY);
	CharUpper(rgch);
	if (FEmptySz(rgch))
		lstrcpy(rgch, TEXT("<none>"));
	else if (!FValidGUID(rgch, fTrue, fFalse, fFalse))
		return (UiLogError(ERROR_PCW_BAD_GUIDS_TO_REPLACE, rgch, NULL));

	StringCchPrintf(rgchLog, sizeof(rgchLog)/sizeof(TCHAR), TEXT("ListOfPatchGUIDsToReplace          = '%s'\r\n"), rgch);
	EvalAssert( FWriteLogFile(rgchLog) );

	UpdateStatusMsg(0, szNull, TEXT("ListOfTargetProductCodes"));
	// zzz this could overflow buffer
	ids = IdsMsiGetPcwPropertyString(hdbInput, TEXT("ListOfTargetProductCodes"), rgch, BIGPROPERTYSIZE);
	Assert(ids == IDS_OKAY);
	CharUpper(rgch);
	if (FEmptySz(rgch))
		lstrcpy(rgch, TEXT("*"));
	if (!FValidGUID(rgch, fTrue, fTrue, fTrue))
		return (UiLogError(ERROR_PCW_BAD_TARGET_PRODUCT_CODE_LIST, rgch, NULL));

	StringCchPrintf(rgchLog, sizeof(rgchLog)/sizeof(TCHAR), TEXT("ListOfTargetProductCodes           = '%s'\r\n"), rgch);
	EvalAssert( FWriteLogFile(rgchLog) );

	LogSzProp(hdbInput, TEXT("PatchSourceList"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("AllowProductCodeMismatches"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("AllowProductVersionMajorMismatches"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("OptimizePatchSizeForLargeFiles"), rgch, rgchLog);

	UpdateStatusMsg(0, szNull, TEXT("ApiPatchingSymbolFlags"));
	ids = IdsMsiGetPcwPropertyString(hdbInput, TEXT("ApiPatchingSymbolFlags"), rgch, MAX_PATH);
	Assert(ids == IDS_OKAY);
	if (FEmptySz(rgch))
		lstrcpy(rgch, TEXT("<blank>"));
	else if (!FValidHexValue(rgch) || !FValidApiPatchSymbolFlags(UlFromHexSz(rgch)))
		return (UiLogError(ERROR_PCW_BAD_API_PATCHING_SYMBOL_FLAGS, rgch, NULL));
	StringCchPrintf(rgchLog, sizeof(rgchLog)/sizeof(TCHAR), TEXT("ApiPatchingSymbolFlags             = '%s'\r\n"), rgch);
	EvalAssert( FWriteLogFile(rgchLog) );

	LogSzProp(hdbInput, TEXT("MsiFileToUseToCreatePatchTables"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("SqlCmdToCreatePatchTable"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("SqlCmdToCreatePatchPackageTable"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("SqlCmdToCreateMsiPatchHeadersTable"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("DontRemoveTempFolderWhenFinished"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("IncludeWholeFilesOnly"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("MinimumRequiredMsiVersion"), rgch, rgchLog);
	EvalAssert( FWriteLogFile(TEXT("\r\n")) );

	ids = UiCreatePatchingTableExportFile(hdbInput, ptePatch, szTempFolder, szTempFName);
	if (ids != IDS_OKAY)
		return (ids);
	ids = UiCreatePatchingTableExportFile(hdbInput, ptePatchPackage, szTempFolder, szTempFName);
	if (ids != IDS_OKAY)
		return (ids);
	ids = UiCreatePatchingTableExportFile(hdbInput, pteMsiPatchHeaders, szTempFolder, szTempFName);
	if (ids != IDS_OKAY)
		return (ids);
	*szTempFName = TEXT('\0');
	EvalAssert( FWriteLogFile(TEXT("\r\n")) );

	return (ERROR_SUCCESS);
}


static BOOL FHexChars ( LPTSTR * psz, UINT cch, BOOL fAllowLower );

/* ********************************************************************** */
static BOOL FValidGUID ( LPTSTR sz, BOOL fList, BOOL fLeadAsterisk, BOOL fSemiColonSeparated )
{
	Assert(sz != szNull);

	if (fLeadAsterisk && *sz == TEXT('*'))
		{
		Assert(fList);
		Assert(fSemiColonSeparated);
		sz = CharNext(sz);
		if (*sz == TEXT('\0'))
			return (fTrue);
		if (*sz != TEXT(';'))
			return (fFalse);
		return (FValidGUID(CharNext(sz), fTrue, fFalse, fTrue));
		}

	if (*sz != TEXT('{'))
		return (fFalse);
	sz = CharNext(sz);

	if (!FHexChars(&sz, 8, fFalse))
		return (fFalse);

	if (*sz != TEXT('-'))
		return (fFalse);
	sz = CharNext(sz);

	if (!FHexChars(&sz, 4, fFalse))
		return (fFalse);

	if (*sz != TEXT('-'))
		return (fFalse);
	sz = CharNext(sz);

	if (!FHexChars(&sz, 4, fFalse))
		return (fFalse);

	if (*sz != TEXT('-'))
		return (fFalse);
	sz = CharNext(sz);

	if (!FHexChars(&sz, 4, fFalse))
		return (fFalse);

	if (*sz != TEXT('-'))
		return (fFalse);
	sz = CharNext(sz);

	if (!FHexChars(&sz, 12, fFalse))
		return (fFalse);

	if (*sz != TEXT('}'))
		return (fFalse);
	sz = CharNext(sz);

	if (*sz != TEXT('\0'))
		{
		if (!fList)
			return (fFalse);
		if (fSemiColonSeparated && *sz != TEXT(';'))
			return (fFalse);
		if (fSemiColonSeparated)
			sz = CharNext(sz);

		return (FValidGUID(sz, fList, fFalse, fSemiColonSeparated));
		}

	return (fTrue);
}


/* ********************************************************************** */
BOOL FValidHexValue ( LPTSTR sz )
{
	Assert(sz != szNull);

	return (*sz++ == TEXT('0') && *sz++ == TEXT('x') && FHexChars(&sz, 8, fTrue) && *sz == TEXT('\0'));
}


/* ********************************************************************** */
static BOOL FHexChars ( LPTSTR * psz, UINT cch, BOOL fAllowLower )
{
	Assert(psz != NULL);
	Assert(*psz != szNull);
	Assert(cch == 4 || cch == 8 || cch == 12);

	LPTSTR sz = *psz;
	while (cch--)
		{
		if (*sz >= TEXT('0') && *sz <= TEXT('9'))
			;
		else if (*sz >= TEXT('A') && *sz <= TEXT('F'))
			;
		else if (fAllowLower && *sz >= TEXT('a') && *sz <= TEXT('f'))
			;
		else
			return (fFalse);
		sz = CharNext(sz);
		}

	*psz = sz;

	return (fTrue);
}


/* ********************************************************************** */
static BOOL FValidPropertyName ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));

	if (lstrlen(sz) > 70)
		return (fFalse);

	TCHAR rgch[128];
	lstrcpy(rgch, sz);
	sz = rgch;
	CharUpper(sz);

	TCHAR ch = *sz++;
	if (ch != TEXT('_') && (ch < TEXT('A') || ch > TEXT('Z')))
		return (fFalse);

	while ((ch = *sz++) != TEXT('\0'))
		{
		if (ch != TEXT('_') && ch != TEXT('.')
				&& (ch < TEXT('A') || ch > TEXT('Z'))
				&& (ch < TEXT('0') || ch > TEXT('9')))
			{
			return (fFalse);
			}
		}

	return (fTrue);
}


/* ********************************************************************** */
static BOOL FValidDiskId ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));

	DWORD dw = 0;
	while (*sz != TEXT('\0'))
		{
		TCHAR ch = *sz++;
		if (ch < TEXT('0') || ch > TEXT('9'))
			return (fFalse);
		if (dw > 3276)
			return (fFalse);
		dw = (dw * 10) + (DWORD)(ch - TEXT('0'));
		}

	return (dw <= 32767 && dw > 0);
}


/* ********************************************************************** */
ULONG UlFromHexSz ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));
	Assert(FValidHexValue(sz));
	Assert(FMatchPrefix(sz, TEXT("0x")));
	sz += lstrlen(TEXT("0x"));

	ULONG ul = 0L;

	while (*sz != TEXT('\0'))
		{
		TCHAR ch = *sz, chBase;
		if (ch >= TEXT('0') && ch <= TEXT('9'))
			chBase = TEXT('0');
		else if (ch >= TEXT('A') && ch <= TEXT('F'))
			chBase = TEXT('A') - 10;
		else if (ch >= TEXT('a') && ch <= TEXT('f'))
			chBase = TEXT('a') - 10;
		else
			{ AssertFalse(); }

		ul = (ul * 16) + (ch - chBase);
		sz = CharNext(sz);
		}

	return (ul);
}


/* ********************************************************************** */
BOOL FValidApiPatchSymbolFlags ( ULONG ul )
{
	if (ul > (PATCH_SYMBOL_NO_IMAGEHLP + PATCH_SYMBOL_NO_FAILURES + PATCH_SYMBOL_UNDECORATED_TOO))
		return (fFalse);

	return (fTrue);
}


/* ********************************************************************** */
static void LogSzProp ( MSIHANDLE hdbInput, LPTSTR szProp, LPTSTR szBuf, LPTSTR szBufLog )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szProp));
	Assert(szBuf != szNull);
	Assert(szBufLog != szNull);

	UpdateStatusMsg(0, szNull, szProp);
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput, szProp, szBuf, MAX_PATH) );
	if (FEmptySz(szBuf))
		lstrcpy(szBuf, TEXT("<blank>"));
	wsprintf(szBufLog, TEXT("%-34s = '%s'\r\n"), szProp, szBuf);
	EvalAssert( FWriteLogFile(szBufLog) );
}


static BOOL FMsiExistAnyTableRecords ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField );

/* ********************************************************************** */
static UINT UiCreatePatchingTableExportFile ( MSIHANDLE hdbInput, pteEnum ptePatchTable, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);
	Assert(szTempFolder != szTempFName);
	Assert(ptePatchTable > pteFirstEnum && ptePatchTable < pteNextEnum);

	LPTSTR szTable        = TEXT("Patch");
	LPTSTR szField        = TEXT("`PatchSize`");
	LPTSTR szFName        = TEXT("Patch.idt");
	LPTSTR szCreateSqlCmd = TEXT("CREATE TABLE `Patch` ( `File_` CHAR(72) NOT NULL, `Sequence` INTEGER NOT NULL, `PatchSize` LONG NOT NULL, `Attributes` INTEGER NOT NULL, `Header` OBJECT, `StreamRef_` CHAR(72)  PRIMARY KEY `File_`, `Sequence` )");
	LPTSTR szDropSqlCmd   = TEXT("DROP   TABLE `Patch`");
	LPTSTR szEmptySqlCmd  = TEXT("DELETE FROM  `Patch`");
	if (ptePatchPackage == ptePatchTable)
		{
		szTable        = TEXT("PatchPackage");
		szField        = TEXT("`PatchId`");
		szFName        = TEXT("PPackage.idt");
		szCreateSqlCmd = TEXT("CREATE TABLE `PatchPackage` ( `PatchId` CHAR(38) NOT NULL, `Media_` INTEGER NOT NULL PRIMARY KEY `PatchId` )");
		szDropSqlCmd   = TEXT("DROP   TABLE `PatchPackage`");
		szEmptySqlCmd  = TEXT("DELETE FROM  `PatchPackage`");
		}
	else if (pteMsiPatchHeaders == ptePatchTable)
		{
		szTable        = TEXT("MsiPatchHeaders");
		szField        = TEXT("`StreamRef`");
		szFName        = TEXT("MsiPatch.idt");
		szCreateSqlCmd = TEXT("CREATE TABLE `MsiPatchHeaders` ( `StreamRef` CHAR(38) NOT NULL, `Header` OBJECT NOT NULL PRIMARY KEY `StreamRef` )");
		szDropSqlCmd   = TEXT("DROP   TABLE `MsiPatchHeaders`");
		szEmptySqlCmd  = TEXT("DELETE FROM  `MsiPatchHeaders`");
		}

	if (FTableExists(hdbInput, szTable, fFalse))
		{
		if (FValidPatchTableFormat(hdbInput, ptePatchTable))
			{
			if (FMsiExistAnyTableRecords(hdbInput, szTable, szField))
				{
				EvalAssert( FSprintfToLog(TEXT("WARNING (22): PCP: ignoring records in table '%s'."), szTable, szEmpty, szEmpty, szEmpty) );
				EvalAssert( FExecSqlCmd(hdbInput, szEmptySqlCmd) );
				}
			EvalAssert( FSprintfToLog(TEXT("Using '%s' table from PCP."), szTable, szEmpty, szEmpty, szEmpty) );
			goto LTableExists;
			}
		EvalAssert( FSprintfToLog(TEXT("WARNING (21): PCP: bad table syntax for '%s'; ignoring."), szTable, szEmpty, szEmpty, szEmpty) );
		EvalAssert( FExecSqlCmd(hdbInput, szDropSqlCmd) );
		Assert(!FTableExists(hdbInput, szTable, fFalse));
		}


	BOOL fUsingDefaultMsi;
	fUsingDefaultMsi = fFalse;
	TCHAR rgchMsiPath[MAX_PATH] = {0};
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput, TEXT("MsiFileToUseToCreatePatchTables"), rgchMsiPath, MAX_PATH) );
	if (!FEmptySz(rgchMsiPath))
		{
		MSIHANDLE hdb;
		hdb = NULL;
		TCHAR rgchFullPath[MAX_PATH];
		if (MSI_OKAY != MsiOpenDatabase(rgchMsiPath, MSIDBOPEN_READONLY, &hdb))
			{
			Assert(hdb == NULL);
LHandleRelativePath:
			hdb = NULL;
			if (FFixupPathEx(rgchMsiPath, rgchFullPath))
				MsiOpenDatabase(rgchFullPath, MSIDBOPEN_READONLY, &hdb);
			// should we try DLL's folder instead of just CWD??
			}
		else
			lstrcpy(rgchFullPath, rgchMsiPath);

		if (hdb != NULL)
			{
			if (FTableExists(hdb, szTable, fFalse))
				{
				if (!FValidPatchTableFormat(hdb, ptePatchTable))
					{
					EvalAssert( FSprintfToLog(TEXT("WARNING (23): bad table syntax for '%s' found in file '%s'; ignoring."), szTable, rgchFullPath, szEmpty, szEmpty) );
					}
				else
					{
					LPTSTR szFNameTmp = (ptePatch == ptePatchTable) ? TEXT("export1.idt") : ((ptePatchPackage == ptePatchTable) ? TEXT("export2.idt") : TEXT("export3.idt"));
					lstrcpy(szTempFName, szFNameTmp);
					Assert(!FFileExist(szTempFolder));
					*szTempFName = TEXT('\0');

					UINT uiRet = MsiDatabaseExport(hdb, szTable, szTempFolder, szFNameTmp);
					lstrcpy(szTempFName, szFNameTmp);
					if (!FFileExist(szTempFolder))
						{
						EvalAssert( FSprintfToLog(TEXT("WARNING (24): unable to export table '%s' from file '%s'; ignoring."), szTable, rgchFullPath, szEmpty, szEmpty) );
						}
					else
						{
						Assert(uiRet == MSI_OKAY);
						*szTempFName = TEXT('\0');
						EvalAssert( MSI_OKAY == MsiDatabaseImport(hdbInput, szTempFolder, szFNameTmp) );
						Assert(FTableExists(hdbInput, szTable, fFalse));
						Assert(FValidPatchTableFormat(hdbInput, ptePatchTable));
						EvalAssert( FExecSqlCmd(hdbInput, szEmptySqlCmd) );
						// wait to goto LTableExists; until hdb closed
						}
					}
				}

			MsiCloseHandle(hdb);
			hdb = NULL;

			if (FTableExists(hdbInput, szTable, fFalse))
				{
				EvalAssert( FSprintfToLog(TEXT("Exported '%s' table from MSI file '%s'."), szTable, rgchFullPath, szEmpty, szEmpty) );
				goto LTableExists;
				}
			}
		else if (ptePatch == ptePatchTable && !fUsingDefaultMsi)
			{
			EvalAssert( FSprintfToLog(TEXT("WARNING (25): unable to find MSI file '%s' to export 'Patch' and/or 'PatchPackage' tables; ignoring."), rgchFullPath, szEmpty, szEmpty, szEmpty) );
			}
		}

	if (FEmptySz(rgchMsiPath) && lstrcmpi(rgchMsiPath, TEXT("patch.msi")))
		{
		lstrcpy(rgchMsiPath, TEXT("patch.msi"));
		fUsingDefaultMsi = fTrue;
		goto LHandleRelativePath;
		}


#define rgchPropSqlCmd rgchMsiPath // reuse buffer
	LPTSTR szPcpSqlPropName;
	szPcpSqlPropName = (ptePatch == ptePatchTable) ? TEXT("SqlCmdToCreatePatchTable") : ((ptePatchPackage == ptePatchTable) ? TEXT("SqlCmdToCreatePatchPackageTable") : TEXT("SqlCmdToCreateMsiPatchHeadersTable"));
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput, szPcpSqlPropName, rgchPropSqlCmd, MAX_PATH) );
	if (!FEmptySz(rgchPropSqlCmd))
		{
		if (!FExecSqlCmd(hdbInput, rgchPropSqlCmd))
			{
			EvalAssert( FSprintfToLog(TEXT("WARNING (26): could not execute PCP SQL command: '%s'; ignoring."), szPcpSqlPropName, szEmpty, szEmpty, szEmpty) );
			}
		else if (!FTableExists(hdbInput, szTable, fFalse))
			{
			EvalAssert( FSprintfToLog(TEXT("WARNING (27): no table created by PCP SQL command: '%s'; ignoring."), szPcpSqlPropName, szEmpty, szEmpty, szEmpty) );
			}
		else if (!FValidPatchTableFormat(hdbInput, ptePatchTable))
			{
			EvalAssert( FSprintfToLog(TEXT("WARNING (28): bad table format created by PCP SQL command: '%s'; ignoring."), szPcpSqlPropName, szEmpty, szEmpty, szEmpty) );
			EvalAssert( FExecSqlCmd(hdbInput, szDropSqlCmd) );
			Assert(!FTableExists(hdbInput, szTable, fFalse));
			}
		else
			{
			EvalAssert( FSprintfToLog(TEXT("Using SQL cmd from PCP's Properties to create '%s' table."), szTable, szEmpty, szEmpty, szEmpty) );
			goto LTableExists;
			}
		}

	EvalAssert( FSprintfToLog(TEXT("Using internal SQL cmd to create '%s' table."), szTable, szEmpty, szEmpty, szEmpty) );
	EvalAssert( FExecSqlCmd(hdbInput, szCreateSqlCmd) );

LTableExists:
	Assert(FTableExists(hdbInput, szTable, fFalse));
	Assert(FValidPatchTableFormat(hdbInput, ptePatchTable));
	Assert(!FMsiExistAnyTableRecords(hdbInput, szTable, szField));

	*szTempFName = TEXT('\0');
	EvalAssert( ERROR_SUCCESS == MsiDatabaseExport(hdbInput, szTable, szTempFolder, szFName) );

	lstrcpy(szTempFName, szFName);
	Assert(FFileExist(szTempFolder));

	EvalAssert( FExecSqlCmd(hdbInput, szDropSqlCmd) );

	return (IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FMsiExistAnyTableRecords ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szField));
	Assert(*szField == TEXT('`'));
	Assert(*SzLastChar(szField) == TEXT('`'));
	Assert(lstrlen(szField) >= 3);

	BOOL fExists = fFalse;
	EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdb, szTable, szField, TEXT(""), &fExists) );

	return (fExists);
}


/* ********************************************************************** */
static BOOL FValidPatchTableFormat ( MSIHANDLE hdb, pteEnum ptePatchTable )
{
	Assert(hdb != NULL);
	Assert(ptePatchTable > pteFirstEnum && ptePatchTable < pteNextEnum);

	LPTSTR szTable = (ptePatch == ptePatchTable) ? TEXT("Patch") : ((ptePatchPackage == ptePatchTable) ? TEXT("PatchPackage") : TEXT("MsiPatchHeaders"));

	Assert(FTableExists(hdb, szTable, fFalse));

	if (ptePatch == ptePatchTable)
		{
		return (FSzColumnExists(hdb, szTable, TEXT("File_"), fFalse)
				&& FIntColumnExists(hdb, szTable, TEXT("Sequence"), fFalse)
				&& FIntColumnExists(hdb, szTable, TEXT("PatchSize"), fFalse)
				&& FIntColumnExists(hdb, szTable, TEXT("Attributes"), fFalse)
				&& FBinaryColumnExists(hdb, szTable, TEXT("Header"), TEXT("File_"), fFalse)
				&& FSzColumnExists(hdb, szTable, TEXT("StreamRef_"), fFalse));
		}
	else if (ptePatchPackage == ptePatchTable)
		{
		return (FSzColumnExists(hdb, szTable, TEXT("PatchId"), fFalse)
				&& FIntColumnExists(hdb, szTable, TEXT("Media_"), fFalse));
		}

	return (FSzColumnExists(hdb, szTable, TEXT("StreamRef"), fFalse)
			&& FBinaryColumnExists(hdb, szTable, TEXT("Header"), TEXT("StreamRef"), fFalse));
}


/* ********************************************************************** */
MSIHANDLE HdbReopenMsi ( MSIHANDLE hdbInput, LPTSTR szImage, BOOL fUpgradedImage, BOOL fTargetUpgradedCopy )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szImage));
	Assert(!fUpgradedImage || !fTargetUpgradedCopy);

	LPTSTR szTable   = TEXT("`TargetImages`");
	LPTSTR szPKey    = TEXT("`Target`");
	LPTSTR szMsiPath = TEXT("`MsiPath`");
	if (fUpgradedImage)
		{
		szTable = TEXT("`UpgradedImages`");
		szPKey  = TEXT("`Upgraded`");
		}
	else if (fTargetUpgradedCopy)
		szMsiPath = TEXT("`MsiPathUpgradedCopy`");

	TCHAR rgch[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, szTable, szPKey, szMsiPath, szImage, rgch, MAX_PATH) );
	Assert(!FEmptySz(rgch));
	Assert(FFileExist(rgch));

	MSIHANDLE hdb = NULL;
	EvalAssert( MSI_OKAY == MsiOpenDatabase(rgch, (fTargetUpgradedCopy) ? MSIDBOPEN_DIRECT : MSIDBOPEN_READONLY, &hdb) );
	Assert(hdb != NULL);

	return (hdb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\patchwiz\patchcache.h ===
#ifndef PATCHCACHE_H
#define PATCHCACHE_H

//need this #include for MSIHANDLE
#include "msiquery.h"

UINT PatchCacheEntryPoint( MSIHANDLE hdbInput, LPTSTR szFTK, LPTSTR szSrcPath, int iFileSeqNum, LPTSTR szTempFolder, LPTSTR szTempFName );

//new globals used in existing patchwiz code for new algorithm...
extern BOOL  g_bPatchCacheEnabled;

extern TCHAR g_szPatchCacheDir[MAX_PATH];

extern TCHAR g_szSourceLFN[MAX_PATH];
extern TCHAR g_szDestLFN[MAX_PATH];

//existing API's used in existing MSI PatchWiz.dll code and in the new patch caching code...
void  GetFileVersion ( LPTSTR szFile, DWORD* pdwHi, DWORD* pdwLow );
UINT  UiGenerateOnePatchFile ( MSIHANDLE hdbInput, LPTSTR szFTK, LPTSTR szSrcPath, int iFileSeqNum, LPTSTR szTempFolder, LPTSTR szTempFName );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\patchwiz\myassrtc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//--------------------------------------------------------------------------

#ifndef MYASSERT_H
#define MYASSERT_H

#ifdef _DEBUG
#define  EnableAsserts  // static TCHAR rgchFile[] = TEXT(__FILE__);
#define  EvalAssert(x)  Assert(x)
/* NOTE - this definition of Assert() includes 'Patch Creation Wizard' in the msgbox title */
#define  Assert(x) \
        { \
        if (!(x)) \
            { \
            TCHAR rgch[128]; \
            StringCchPrintf(rgch, sizeof(rgch)/sizeof(TCHAR), TEXT("File: %s, Line: %d"), __FILE__, __LINE__); \
            MessageBox(hwndNull, rgch, TEXT("Patch Creation Wizard Assert"), MB_OK); \
            } \
        }
#define  AssertFalse() \
        { \
        TCHAR rgch[128]; \
        StringCchPrintf(rgch, sizeof(rgch)/sizeof(TCHAR), TEXT("File: %s, Line: %d"), __FILE__, __LINE__); \
        MessageBox(hwndNull, rgch, TEXT("Patch Creation Wizard AssertFalse"), MB_OK); \
        }
#define  DebugMsg() \
        { \
        TCHAR rgch[128]; \
        StringCchPrintf(rgch, sizeof(rgch)/sizeof(TCHAR), TEXT("File: %s, Line: %d"), __FILE__, __LINE__); \
        MessageBox(hwndNull, rgch, TEXT("Patch Creation Wizard Debug Msg"), MB_OK); \
        }
#else
#define  EnableAsserts
#define  EvalAssert(x)  if (x) 1;
#define  Assert(x)
#define  AssertFalse()
#define  DebugMsg()
#endif

#define  Unused(x)  x = x;


#endif /* !MYASSERT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\patchwiz\patchres.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       patchres.h
//
//--------------------------------------------------------------------------

#ifndef __PATCHRES_H_119F5B1A_5737_4069_AEFD_E9EFFEF07C28
#define __PATCHRES_H_119F5B1A_5737_4069_AEFD_E9EFFEF07C28

#define IDS_STATUS_VALIDATE_INPUT           100
#define IDS_STATUS_VALIDATE_IMAGES          101
#define IDS_STATUS_VALIDATE_FILE_RANGES     102
#define IDS_STATUS_DETERMINE_SEQUENCE_START 103
#define IDS_STATUS_EXPAND_OVERLAP_RECORDS   104
#define IDS_STATUS_COPY_UPGRADED_MSI        105
#define IDS_STATUS_CREATE_FILE_PATCHES      106
#define IDS_STATUS_CREATE_TRANSFORMS        107
#define IDS_STATUS_CREATE_CABINET           108
#define IDS_STATUS_CLEANUP                  109

#define IDS_TITLE                           116
#define IDS_PRODUCTCODES_DONT_MATCH         117
#define IDS_PRODUCTVERSIONS_DONT_MATCH      118
#define IDS_PRODUCTVERSION_INVERSION        119
#define IDS_STREAM_NAME_LIMIT_REACHED       120

#endif //__PATCHRES_H_119F5B1A_5737_4069_AEFD_E9EFFEF07C28
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\patchwiz\patchdll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//--------------------------------------------------------------------------

  /* PATCHDLL.H - internal header file for PATCHWIZ.DLL */

#ifndef _PATCHDLL_H_3AA1E0C9_FE2F_4A53_AE2F_CC71C7E7ABB5
#define _PATCHDLL_H_3AA1E0C9_FE2F_4A53_AE2F_CC71C7E7ABB5

#include <windows.h>
#include <ole2.h>
#include <strsafe.h>
#include "patchwiz.h"
#include "patchres.h"

#define hwndNull  ((HWND)NULL)
#define szNull    ((LPTSTR)NULL)
#define pfNull    ((PBOOL)NULL)
#define fTrue     TRUE
#define fFalse    FALSE
#define szEmpty   (TEXT(""))
#define szMsgBoxTitle (TEXT("Patch Creation Wizard"))

static LPCTSTR _sz = szNull;
#define FEmptySz(sz) ((BOOL)(((_sz=(sz))==szNull)||(*_sz==TEXT('\0'))))

#ifndef RC_INVOKED
#include "myassrtc.h"
#include "msiquery.h"
#define MSI_OKAY ERROR_SUCCESS
#include "patchapi.h"
#include "tchar.h"
#endif  // !RC_INVOKED


extern TCHAR  rgchTempFolder[MAX_PATH + MAX_PATH];
extern LPTSTR szTempFileName;
extern TCHAR  rgchPatchPath[MAX_PATH];
extern int    iOrderMax;


UINT UiLogError     ( UINT ids, LPTSTR szData, LPTSTR szData2 );
BOOL FWriteLogFile  ( LPTSTR szLine );
BOOL FSprintfToLog  ( LPTSTR szLine, LPTSTR szData1, LPTSTR szData2, LPTSTR szData3, LPTSTR szData4 );
BOOL FValidHexValue ( LPTSTR sz );


/* UTILS.CPP */

#define IDS_STATUS_MIN    IDS_STATUS_VALIDATE_INPUT
#define IDS_STATUS_MAX    IDS_STATUS_CLEANUP+1

void InitStatusMsgs         ( HWND hwndStatus );
void UpdateStatusMsg        ( UINT ids, LPTSTR szData1, LPTSTR szData2 );
void EndStatusMsgs          ( void );
HWND HdlgStatus             ( void );

void MyYield                ( void );

BOOL FLoadString            ( UINT ids, LPTSTR rgch, UINT cch );
int  IMessageBoxIds         ( HWND hwnd, UINT ids, UINT uiType );

LPTSTR SzLastChar           ( LPTSTR sz );
LPTSTR SzDupSz              ( LPTSTR sz );
LPSTR  SzaDupSz             ( LPTSTR sz );
BOOL   FFileExist           ( LPTSTR sz );
BOOL   FFolderExist         ( LPTSTR sz );
LPTSTR SzFindFilenameInPath ( LPTSTR sz );

BOOL   FDeleteFiles         ( LPTSTR sz );
BOOL   FEnsureFolderExists  ( LPTSTR sz );

BOOL   FSetTempFolder       ( LPTSTR szBuf, LPTSTR *pszFName, HWND hwnd, LPTSTR szTempFolder, BOOL fRemoveTempFolderIfPresent );
BOOL   FDeleteTempFolder    ( LPTSTR sz );
BOOL   FMatchPrefix         ( LPTSTR sz, LPTSTR szPrefix );

BOOL   FFixupPath           ( LPTSTR sz );
BOOL   FFixupPathEx         ( LPTSTR szIn, LPTSTR szOut );


/* FILEPTCH.CPP */

const int cchMaxGuid       = 39;
const int cchMaxStreamName = 62;
const int iMinMsiPatchHeadersVersion = 200;
const int iWindowsInstallerME = 120;
const int iWindowsInstallerXP = 200;

UINT UiMakeFilePatchesCabinetsTransformsAndStuffIntoPatchPackage (
			MSIHANDLE hdbInput, LPTSTR szPatchPath, LPTSTR szTempFolder, LPTSTR szTempFName );


/* MSISTUFF.CPP */

#define MAX_LENGTH_IMAGE_FAMILY_NAME 8
#define MAX_LENGTH_TARGET_IMAGE_NAME 13

#define IDS_OKAY        0
#define MSI_OKAY        ERROR_SUCCESS

#define IDS_CANCEL      7
#define IDS_MATCH       IDS_CANCEL
#define IDS_NOMATCH     IDS_OKAY

#define IDS_OOM                             34
#define IDS_CANT_OPEN_MSI                   40
#define IDS_CANT_APPLY_MST                  41
#define IDS_CANT_OPEN_VIEW					42
#define IDS_CANT_EXECUTE_VIEW				43
#define IDS_CANT_CREATE_RECORD				44
#define IDS_CANT_FETCH_RECORD				45
#define IDS_CANT_SET_RECORD_FIELD			46
#define IDS_CANT_GET_RECORD_FIELD			47
#define IDS_CANT_ASSIGN_RECORD_IN_VIEW		48
#define IDS_CANT_DELETE_RECORD_IN_VIEW		49
#define IDS_CANT_GENERATE_MST				50
#define IDS_CANT_SAVE_MSI					51
#define IDS_BUFFER_IS_TOO_SHORT				52
#define IDS_BAD_DEST_FOLDER                 53
#define IDS_BAD_DIRECTORY_NAME              54
#define IDS_MISSING_INSTALLSEQ_RECORD       55

UINT UiOpenInputPcp           ( LPTSTR szPcpPath, LPTSTR szTempFldrBuf, LPTSTR szTempFName, MSIHANDLE* phdbInput );

UINT UiValidateInputRecords   ( MSIHANDLE hdb, LPTSTR szMsiPath, LPTSTR szPatchPath, LPTSTR szTempFolder, LPTSTR szTempFName );
UINT IdsResolveSrcFilePathSzs ( MSIHANDLE hdb, LPTSTR szBuf, LPTSTR szComponent, LPTSTR szFName, BOOL fLfn, LPTSTR szFullSubFolder );

ULONG UlFromHexSz               ( LPTSTR sz );
ULONG UlGetRangeElement         ( LPTSTR* psz );
BOOL  FValidApiPatchSymbolFlags ( ULONG ul );

UINT UiCopyUpgradedMsiToTempFolderForEachTarget ( MSIHANDLE hdb, LPTSTR szTempFolder, LPTSTR szTempFName );

BOOL FExecSqlCmd  ( MSIHANDLE hdb, LPTSTR sz );
BOOL FTableExists ( MSIHANDLE hdb, LPTSTR szTable, BOOL fMsg );

UINT CchMsiTableString             ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szPKey, LPTSTR szFieldName, LPTSTR szPKeyValue );
UINT CchMsiTableStringWhere        ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFieldName, LPTSTR szWhere );
UINT IdsMsiGetTableString          ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szPKey, LPTSTR szFieldName, LPTSTR szPKeyValue, LPTSTR szBuf, UINT cch );
UINT IdsMsiGetTableInteger         ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szPKey, LPTSTR szFieldName, LPTSTR szPKeyValue, int * pi );
UINT IdsMsiGetTableStringWhere     ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFieldName, LPTSTR szWhere, LPTSTR szBuf, UINT cch );
UINT IdsMsiGetTableIntegerWhere    ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFieldName, LPTSTR szWhere, int * pi );
UINT IdsMsiSetTableRecord          ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFields, LPTSTR szPrimaryField, LPTSTR szKey, MSIHANDLE hrec );
UINT IdsMsiSetTableRecordWhere     ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFields, LPTSTR szWhere, MSIHANDLE hrec );
UINT IdsMsiUpdateTableRecordSz     ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szValue, LPTSTR szPKeyField, LPTSTR szPKeyValue );
UINT IdsMsiUpdateTableRecordInt    ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, int iValue, LPTSTR szPKeyField, LPTSTR szPKeyValue );
UINT IdsMsiUpdateTableRecordIntPkeyInt ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, int iValue, LPTSTR szPKeyField, int iPKeyValue );
UINT IdsMsiDeleteTableRecords      ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szKey );
UINT IdsMsiDeleteTableRecordsWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szWhere );
typedef UINT (*PIEMTPROC)          ( MSIHANDLE, MSIHANDLE, LPARAM, LPARAM );
UINT IdsMsiEnumTable               ( MSIHANDLE hdb, LPTSTR szTable,
			LPTSTR szFields, LPTSTR szWhere, PIEMTPROC pIemtProc, LPARAM lp1, LPARAM lp2 );
UINT IdsMsiExistTableRecordsWhere  ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szWhere, PBOOL pf );
UINT IdsMsiExistTableRecords       ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szValue, PBOOL pf );

UINT IdsMsiGetPropertyString       ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue, UINT cch );
UINT IdsMsiSetPropertyString       ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue );

UINT CchMsiPcwPropertyString       ( MSIHANDLE hdb, LPTSTR szName );
UINT IdsMsiGetPcwPropertyString    ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue, UINT cch );
UINT IdsMsiGetPcwPropertyInteger   ( MSIHANDLE hdb, LPTSTR szName, int * pi );
UINT IdsMsiSetPcwPropertyString    ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue );

MSIHANDLE HdbReopenMsi ( MSIHANDLE hdbInput, LPTSTR szImage, BOOL fUpgradedImage, BOOL fTargetUpgradedCopy );


#define PID_SUBJECT      3
#define PID_KEYWORDS     5
#define PID_COMMENTS     6
#define PID_TEMPLATE     7
#define PID_LASTAUTHOR   8
#define PID_REVNUMBER    9
#define PID_PAGECOUNT   14
#define PID_MSISOURCE   15
#define PID_WORDCOUNT   15

#ifdef UNICODE
#define VT_LPTSTR    VT_LPSTR
#else
#define VT_LPTSTR    VT_LPSTR
#endif

const TCHAR szPatchMediaSrcProp[] = TEXT("PATCHMediaSrcProp");

#endif //_PATCHDLL_H_3AA1E0C9_FE2F_4A53_AE2F_CC71C7E7ABB5
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\patchwiz\patchcache.cpp ===
// PatchCache.cpp


//include patching DLL headers...
#include "patchdll.h"

#include "patchcache.h"

#include <tchar.h> //for _tcscpy _tcscat


//IMPLEMENTATION that is not exposed to outside callers.... Moved this to here from header...
//REVIEW this length, may be too much.  May a checksum instead???

struct PCIFILEINFO
{
  TCHAR szFilePath[MAX_PATH];
  DWORD dwVersionHigh;
  DWORD dwVersionLow;
  DWORD dwSizeHigh;
  DWORD dwSizeLow;
  FILETIME ftCreationTime;
  FILETIME ftLastWriteTime;
};


struct CACHEDPATCHFILELOCATIONS
{
  TCHAR szPATFilePath[MAX_PATH];
  TCHAR szHDRFilePath[MAX_PATH];
};

typedef CACHEDPATCHFILELOCATIONS PATCHFILELOCATIONS;

struct PCIFILEFORMAT
{
  PCIFILEINFO SourceInfo;
  PCIFILEINFO TargetInfo;
  CACHEDPATCHFILELOCATIONS Locations;
};
  
BOOL PatchInCache(TCHAR *szSourceLFN, TCHAR *szTargetLFN, TCHAR *szPCIFileName, PCIFILEFORMAT *pPciFile);

//populate PCI struct for patches...
BOOL  PopulatePCIFileInfoForCurrentPatch(TCHAR *lpszLFN, PCIFILEINFO *pFilePCI);

//pass by ref for all struct params for speed...  No changes are done to struct...
DWORD ReadPCIFileFromCache(TCHAR *pciPath, PCIFILEFORMAT *pPciFile);
DWORD WritePCIInfoToCache(TCHAR *pciPath, PCIFILEFORMAT *pPciFile);

//pass by ref for all struct params for speed...  No changes are done to struct...
BOOL ComparePCIInfos(PCIFILEINFO *pCurFilePCI, PCIFILEINFO *pCachedFilePCI);


//cache/temp file updating functions
BOOL CopyPatchesToCache(CACHEDPATCHFILELOCATIONS *pCacheFileLocations, PATCHFILELOCATIONS *pTempFileLocations);
BOOL CopyPatchesFromCache(PATCHFILELOCATIONS *pTempFileLocations, CACHEDPATCHFILELOCATIONS *pCacheFileLocations);

//i/o return contants for functions reading/writing to .PCI files...
#define PCI_SUCCESS          0
#define ERR_PCI_FILENOTFOUND 1
#define ERR_PCI_FILECORRUPT  2


TCHAR g_szSourceLFN[MAX_PATH] = { 0 };
TCHAR g_szDestLFN[MAX_PATH] = { 0 };

BOOL  g_bPatchCacheEnabled = FALSE;
TCHAR g_szPatchCacheDir[MAX_PATH] = TEXT(""); 

//end IMPLEMENTATION


BOOL PopulatePCIFileInfoForCurrentPatch(TCHAR *lpszLFN, PCIFILEINFO *pPCIFileInfo)
{
	BOOL bRet = TRUE;

	Assert(lpszLFN);
	Assert(pPCIFileInfo);

	_tcscpy(pPCIFileInfo->szFilePath, lpszLFN);

	GetFileVersion(lpszLFN, &pPCIFileInfo->dwVersionHigh, &pPCIFileInfo->dwVersionLow);
  
	HANDLE hf1 = CreateFile(lpszLFN, GENERIC_READ, FILE_SHARE_READ,
							NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	Assert(hf1 != INVALID_HANDLE_VALUE);

	pPCIFileInfo->dwSizeLow = GetFileSize(hf1, &pPCIFileInfo->dwSizeHigh);
	Assert(pPCIFileInfo->dwSizeLow != 0xffffffff || GetLastError() == NO_ERROR);

	BY_HANDLE_FILE_INFORMATION finfo;
	bRet = GetFileInformationByHandle(hf1, &finfo);
	Assert(bRet)
	if (!bRet)
		{
		DWORD dwErr = GetLastError();
		Assert(1); //should assert and tell we got an error
		}
	else
		{
		pPCIFileInfo->ftCreationTime  = finfo.ftCreationTime;
		pPCIFileInfo->ftLastWriteTime = finfo.ftLastWriteTime;
		}

	CloseHandle(hf1);
  
	return bRet;
}


DWORD ReadPCIInfoFromCache(TCHAR *pciPath, PCIFILEFORMAT *pPciFile)
{
	DWORD dwReturn = PCI_SUCCESS;
	Assert(pPciFile);

	HANDLE hf1 = CreateFile(pciPath, GENERIC_READ, FILE_SHARE_READ,
							NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

	//annoying assert for many files...
	//  Assert(hf1 != INVALID_HANDLE_VALUE);
	if (INVALID_HANDLE_VALUE == hf1)
	{
		return ERR_PCI_FILENOTFOUND;
	}

	DWORD dwRead;
	BOOL bRet;

	bRet = ReadFile(hf1, (LPVOID)pPciFile, sizeof(PCIFILEFORMAT), &dwRead, NULL);
  
	Assert(bRet);
	Assert(dwRead == sizeof(PCIFILEFORMAT));
	if (bRet && dwRead != sizeof(PCIFILEFORMAT))
		{
		dwReturn = ERR_PCI_FILECORRUPT;
		}

	if (!bRet)
		{
		//ERR_PCI_UNKNOWN
		dwReturn = GetLastError();
		}

	CloseHandle(hf1);
	return dwReturn;
}


DWORD WritePCIInfoToCache(TCHAR *pciPath, PCIFILEFORMAT *pPciFile)
{
	DWORD dwReturn = PCI_SUCCESS;

	Assert(pPciFile);


	HANDLE hf1 = CreateFile(pciPath, GENERIC_WRITE, FILE_SHARE_READ,
							NULL, CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

	Assert(hf1 != INVALID_HANDLE_VALUE);
	if (INVALID_HANDLE_VALUE == hf1)
		{
		return ERR_PCI_FILENOTFOUND;
		}

	DWORD dwWritten;
	BOOL bRet;

	bRet = WriteFile(hf1, (LPVOID)pPciFile, sizeof(PCIFILEFORMAT), &dwWritten, NULL);
  
	Assert(bRet);
	Assert(dwWritten == sizeof(PCIFILEFORMAT));
	if (bRet && dwWritten != sizeof(PCIFILEFORMAT))
		{
		dwReturn = ERR_PCI_FILECORRUPT;
		}

	if (!bRet)
		{
		//ERR_PCI_UNKNOWN
		dwReturn = GetLastError();
		}

	CloseHandle(hf1);
	return dwReturn;
}


BOOL ComparePCIInfos(PCIFILEINFO *pCurFilePCI, PCIFILEINFO *pCachedFilePCI)
{
	Assert(pCurFilePCI);
	Assert(pCachedFilePCI);

	if (0 == memcmp(pCurFilePCI, pCachedFilePCI, sizeof(PCIFILEINFO)))
		return TRUE;

	return FALSE;

}


BOOL PatchInCache(TCHAR *szSourceLFN, TCHAR *szTargetLFN, TCHAR *szPCIFileName, PCIFILEFORMAT *pPciFile)
{
	BOOL bPatchInCache = FALSE;

	struct PCIFILEINFO CurSourceFilePCI = { 0 };
	struct PCIFILEINFO CurTargetFilePCI = { 0 };

	BOOL bRet;
	bRet = PopulatePCIFileInfoForCurrentPatch(szSourceLFN, &CurSourceFilePCI);
	Assert(bRet);

	bRet = PopulatePCIFileInfoForCurrentPatch(szTargetLFN, &CurTargetFilePCI);
	Assert(bRet);

	DWORD dwResult;
	dwResult = ReadPCIInfoFromCache(szPCIFileName, pPciFile);
	if (PCI_SUCCESS == dwResult)
		{
		BOOL bRet = ComparePCIInfos(&pPciFile->SourceInfo, &CurSourceFilePCI);
		if (bRet)
			{
			bRet = ComparePCIInfos(&pPciFile->TargetInfo, &CurTargetFilePCI);
			if (bRet)
				bPatchInCache = TRUE;
			}
		}
	else //error, check dwResult... 
		{
		}

	if (!bPatchInCache) //will need to copy files to cache, they are not in it!
		{
		pPciFile->SourceInfo = CurSourceFilePCI;
		pPciFile->TargetInfo = CurTargetFilePCI;

		BOOL bRet;
		TCHAR tempname[MAX_PATH];

		GetTempFileName(g_szPatchCacheDir, TEXT("PC"), 0, tempname);
		Assert(ERROR_SUCCESS == GetLastError());

		 
		_tcscpy(pPciFile->Locations.szPATFilePath, tempname);

		TCHAR tempname2[MAX_PATH];

		GetTempFileName(g_szPatchCacheDir, TEXT("HC"), 0, tempname2);
		Assert(ERROR_SUCCESS == GetLastError());

		bRet = DeleteFile(tempname);
		Assert(bRet);

		bRet = DeleteFile(tempname2);
		Assert(bRet);

		_tcscpy(pPciFile->Locations.szHDRFilePath, tempname2);
		}

	return bPatchInCache;
}


BOOL CopyPatches(PATCHFILELOCATIONS *pSource, PATCHFILELOCATIONS *pDest)
{
	BOOL bRet = FALSE;

	if (!FEmptySz(pSource->szPATFilePath))
		{
		bRet = CopyFile(pSource->szPATFilePath, pDest->szPATFilePath, FALSE);
		Assert(bRet);
		if (!bRet)
			{
			DWORD dwError = GetLastError();
			//todo: trace dwError possibly
			}

		}

	if (!FEmptySz(pSource->szHDRFilePath))
		{
		bRet = CopyFile(pSource->szHDRFilePath, pDest->szHDRFilePath, FALSE);
		Assert(bRet);
		if (!bRet)
			{
			DWORD dwError = GetLastError();
			//todo: trace dwError possibly
			}
		}

	return bRet;
}


BOOL CopyPatchesFromCache(CACHEDPATCHFILELOCATIONS *pCacheFileLocations, PATCHFILELOCATIONS *pTempFileLocations)
{
	return CopyPatches(pCacheFileLocations, pTempFileLocations);
}


BOOL CopyPatchesToCache(PATCHFILELOCATIONS *pTempFileLocations, CACHEDPATCHFILELOCATIONS *pCacheFileLocations)
{
	return CopyPatches(pTempFileLocations, pCacheFileLocations);
}


UINT PatchCacheEntryPoint( MSIHANDLE hdbInput, LPTSTR szFTK, LPTSTR szSrcPath, int iFileSeqNum, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(g_szDestLFN[0]);
	Assert(g_szSourceLFN[0]);

	UINT ui = IDS_OKAY;

	Assert(szFTK);

	BOOL bRet;
	PCIFILEFORMAT PciFile = { 0 };

	TCHAR szPCIFN[MAX_PATH];

	_tcscpy(szPCIFN, g_szPatchCacheDir);

	_tcscat(szPCIFN, szFTK);

	_tcscat(szPCIFN, TEXT(".PCI"));

	PATCHFILELOCATIONS templocation = { 0 };

	TCHAR filename[MAX_PATH];
	StringCchPrintf(filename, sizeof(filename)/sizeof(TCHAR), TEXT("%05i.PAT"), iFileSeqNum);
	_tcscpy(templocation.szPATFilePath, szTempFolder);

	_tcscat(templocation.szPATFilePath, filename);

	StringCchPrintf(filename, sizeof(filename)/sizeof(TCHAR), TEXT("%05i.HDR"), iFileSeqNum);
	_tcscpy(templocation.szHDRFilePath, szTempFolder);

	_tcscat(templocation.szHDRFilePath, filename);

	bRet = PatchInCache(g_szSourceLFN, g_szDestLFN, szPCIFN, &PciFile);
	if (bRet) //patch was in cache, get it from there...
		{
		//get the patch files from cache and copy them to the temp dir...
		//don't do the patch code...
		bRet = CopyPatchesFromCache(&PciFile.Locations, &templocation);
		Assert(bRet);
		}
	else
		{
		//do patch code like before...
		ui = UiGenerateOnePatchFile(hdbInput, szFTK, szSrcPath, iFileSeqNum,
									szTempFolder, szTempFName);

		//patch creation successful???
		if (ui == IDS_OKAY)
			{
			bRet = CopyPatchesToCache(&templocation, &PciFile.Locations);
			if (bRet) //copy was a success!!!  Create FTK.PCI file...
				{
				//write out info file for patch and the two files patch was for...

				DWORD dwReturn = WritePCIInfoToCache(szPCIFN, &PciFile);
				if (PCI_SUCCESS != dwReturn)
					{
					//todo: trace dwResult...
					}
				}
			}
		}
    
	return ui;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\patchwiz\patchwiz.cpp ===
#pragma message("Windows Installer Patch Creation DLL")
#if 0  // makefile definitions
DESCRIPTION = PatchWiz patch generation tool
MODULENAME  = PatchWiz
ADDCPP = fileptch,msistuff,pwutils
FILEVERSION = msi
ENTRY = UiCreatePatchPackageA,UiCreatePatchPackageW
LINKLIBS = MSPATCHC.LIB
!include "..\..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f patchwiz.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 DLL project
//      2. Add the patching source files to the project (SDK\Patching\Source)
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib, mspatchc.lib, and version.lib to the library list in the
//          Project Settings dialog (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------

# pragma warning (disable:4553)

#include "patchdll.h"

#ifndef RC_INVOKED

EnableAsserts


static UINT UiInitPatchingModule ( LPTSTR szLogPath, HWND hwndStatus, LPTSTR szTempFolder, LPTSTR* pszTempFName, LPTSTR szTempFolderInput, BOOL fRemoveTempFolderIfPresent );
static UINT UiValidatePatchPath  ( MSIHANDLE hdb, LPTSTR szPatchPath );
static void TerminatePatchModule ( MSIHANDLE hdbInput, HWND hwnd, LPTSTR szTempFolder, LPTSTR szTempFName );


UINT UiCreatePatchPackageEx ( LPTSTR szPcpPath, LPTSTR szPatchPath, LPTSTR szLogPath, HWND hwndStatus, LPTSTR szTempFolder, BOOL fRemoveTempFolderIfPresent );

/* ********************************************************************** */
UINT UiCreatePatchPackageEx ( LPTSTR szPcpPath, LPTSTR szPatchPath, LPTSTR szLogPath, HWND hwndStatus, LPTSTR szTempFolder, BOOL fRemoveTempFolderIfPresent )
{
	TCHAR  rgchTempFolder[MAX_PATH + MAX_PATH];
	LPTSTR szTempFName = szNull;
	MSIHANDLE hdbInput = NULL;
	UINT   uiRet = UiInitPatchingModule(szLogPath, hwndStatus, rgchTempFolder, &szTempFName, szTempFolder, fRemoveTempFolderIfPresent);
	if (uiRet != ERROR_SUCCESS)
		goto LEarlyReturn;

	uiRet = UiOpenInputPcp(szPcpPath, rgchTempFolder, szTempFName, &hdbInput);
	if (uiRet != ERROR_SUCCESS)
		goto LEarlyReturn;
	Assert(hdbInput != NULL);

	TCHAR rgchPatchPath[MAX_PATH];
	lstrcpy(rgchPatchPath, szPatchPath);
	uiRet = UiValidatePatchPath(hdbInput, rgchPatchPath);
	if (uiRet != ERROR_SUCCESS)
		goto LEarlyReturn;

	uiRet = UiValidateInputRecords(hdbInput, szPcpPath, rgchPatchPath, rgchTempFolder, szTempFName);
	if (uiRet != ERROR_SUCCESS)
		goto LEarlyReturn;

	UpdateStatusMsg(IDS_STATUS_COPY_UPGRADED_MSI, szEmpty, szEmpty);
	uiRet = UiCopyUpgradedMsiToTempFolderForEachTarget(hdbInput, rgchTempFolder, szTempFName);
	if (uiRet != ERROR_SUCCESS)
		goto LEarlyReturn;

	uiRet = UiMakeFilePatchesCabinetsTransformsAndStuffIntoPatchPackage(
					hdbInput, rgchPatchPath, rgchTempFolder, szTempFName);

LEarlyReturn:
	TerminatePatchModule(hdbInput, hwndStatus, rgchTempFolder, szTempFName);

	return (uiRet);
}


/* ********************************************************************** */
UINT __declspec(dllexport) WINAPI UiCreatePatchPackageA ( LPSTR  szaPcpPath, LPSTR  szaPatchPath, LPSTR  szaLogPath, HWND hwndStatus, LPSTR szaTempFolder, BOOL fRemoveTempFolderIfPresent )
{
#ifndef UNICODE
	CHAR rgchTempFolder[MAX_PATH + 1];

	if (szaTempFolder)
		{
		*rgchTempFolder    = '\0';
		strncat(rgchTempFolder, szaTempFolder, MAX_PATH);
		}
	return (UiCreatePatchPackageEx(szaPcpPath, szaPatchPath, szaLogPath, hwndStatus, 
			szaTempFolder ? rgchTempFolder : szaTempFolder, fRemoveTempFolderIfPresent));
#else
	WCHAR rgchPcpPath[MAX_PATH];
	WCHAR rgchPatchPath[MAX_PATH];
	WCHAR rgchLogPath[MAX_PATH];
	WCHAR rgchTempFolder[MAX_PATH];

	*rgchPcpPath    = L'\0';
	*rgchPatchPath  = L'\0';
	*rgchLogPath    = L'\0';
	*rgchTempFolder = L'\0';

	if (szaPcpPath != NULL && *szaPcpPath != '\0')
		{
		EvalAssert( MultiByteToWideChar(CP_ACP, MB_USEGLYPHCHARS,
				szaPcpPath, -1, rgchPcpPath, MAX_PATH) );
		}

	if (szaPatchPath != NULL && *szaPatchPath != '\0')
		{
		EvalAssert( MultiByteToWideChar(CP_ACP, MB_USEGLYPHCHARS,
				szaPatchPath, -1, rgchPatchPath, MAX_PATH) );
		}

	if (szaLogPath != NULL && *szaLogPath != '\0')
		{
		EvalAssert( MultiByteToWideChar(CP_ACP, MB_USEGLYPHCHARS,
				szaLogPath, -1, rgchLogPath, MAX_PATH) );
		}

	if (szaTempFolder != NULL && *szaTempFolder != '\0')
		{
		EvalAssert( MultiByteToWideChar(CP_ACP, MB_USEGLYPHCHARS,
				szaTempFolder, -1, rgchTempFolder, MAX_PATH) );
		}

	return (UiCreatePatchPackageEx(rgchPcpPath, rgchPatchPath, rgchLogPath, hwndStatus, rgchTempFolder, fRemoveTempFolderIfPresent));
#endif
}
	
	
/* ********************************************************************** */
UINT __declspec(dllexport) WINAPI UiCreatePatchPackageW ( LPWSTR szwPcpPath, LPWSTR szwPatchPath, LPWSTR szwLogPath, HWND hwndStatus, LPWSTR szwTempFolder, BOOL fRemoveTempFolderIfPresent )
{
#ifdef UNICODE
	WCHAR rgchTempFolder[MAX_PATH + 1];

	if (szwTempFolder)
		{
		*rgchTempFolder    = L'\0';
		wcsncat(rgchTempFolder, szwTempFolder, MAX_PATH);
		}
	return (UiCreatePatchPackageEx(szwPcpPath, szwPatchPath, szwLogPath, hwndStatus, 
			szwTempFolder ? rgchTempFolder : szwTempFolder , fRemoveTempFolderIfPresent));
#else
	CHAR rgchPcpPath[MAX_PATH];
	CHAR rgchPatchPath[MAX_PATH];
	CHAR rgchLogPath[MAX_PATH];
	CHAR rgchTempFolder[MAX_PATH];

	*rgchPcpPath    = '\0';
	*rgchPatchPath  = '\0';
	*rgchLogPath    = '\0';
	*rgchTempFolder = '\0';

	if (szwPcpPath != NULL && *szwPcpPath != L'\0')
		{
		EvalAssert( WideCharToMultiByte(CP_ACP, 0, szwPcpPath, -1,
				rgchPcpPath, MAX_PATH, NULL, NULL) );
		}

	if (szwPatchPath != NULL && *szwPatchPath != L'\0')
		{
		EvalAssert( WideCharToMultiByte(CP_ACP, 0, szwPatchPath, -1,
				rgchPatchPath, MAX_PATH, NULL, NULL) );
		}

	if (szwLogPath != NULL && *szwLogPath != L'\0')
		{
		EvalAssert( WideCharToMultiByte(CP_ACP, 0, szwLogPath, -1,
				rgchLogPath, MAX_PATH, NULL, NULL) );
		}

	if (szwTempFolder != NULL && *szwTempFolder != L'\0')
		{
		EvalAssert( WideCharToMultiByte(CP_ACP, 0, szwTempFolder, -1,
				rgchTempFolder, MAX_PATH, NULL, NULL) );
		}

	return (UiCreatePatchPackageEx(rgchPcpPath, rgchPatchPath, rgchLogPath, hwndStatus, rgchTempFolder, fRemoveTempFolderIfPresent));
#endif
}


static UINT UiInitLogFile ( LPTSTR szLogPath );
static BOOL FEndLogFile   ( void );
static void CloseLogFile  ();


/* ********************************************************************** */
static UINT UiInitPatchingModule ( LPTSTR szLogPath, HWND hwndStatus, LPTSTR szTempFolder, LPTSTR* pszTempFName, LPTSTR szTempFolderInput, BOOL fRemoveTempFolderIfPresent )
{
	Assert(szTempFolder != szNull);
	Assert(pszTempFName != NULL);

	InitStatusMsgs(hwndStatus);

	if (!FSetTempFolder(szTempFolder, pszTempFName, hwndStatus, szTempFolderInput, fRemoveTempFolderIfPresent))
		return (ERROR_PCW_CANT_CREATE_TEMP_FOLDER);
	Assert(!FEmptySz(szTempFolder));
	Assert(*pszTempFName != szNull);

	TCHAR rgch[MAX_PATH] = {0};
	EvalAssert( GetModuleFileName(NULL, rgch, MAX_PATH) );
	rgch[MAX_PATH-1] = '\0';
	*SzFindFilenameInPath(rgch) = TEXT('\0');
	Assert(lstrlen(rgch) > 0);
	Assert(*SzLastChar(rgch) == TEXT('\\'));
	lstrcat(rgch, TEXT("MAKECAB.EXE"));
	Assert(FFileExist(rgch));

	lstrcpy(*pszTempFName, TEXT("MAKECAB.EXE"));
	Assert(!FFileExist(szTempFolder));
	Assert(!FFolderExist(szTempFolder));

	EvalAssert( CopyFile(rgch, szTempFolder, fFalse) );
	Assert(FFileExist(szTempFolder));
	**pszTempFName = TEXT('\0');

	return (UiInitLogFile(szLogPath));
}


/* ********************************************************************** */
static void TerminatePatchModule ( MSIHANDLE hdbInput, HWND hwnd, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(!FEmptySz(szTempFolder));
//	Assert(szTempFName != szNull);

	UpdateStatusMsg(IDS_STATUS_CLEANUP, szEmpty, szEmpty);

	TCHAR rgch[MAX_PATH + MAX_PATH];
	if (hdbInput != NULL)
		{
		if (FTableExists(hdbInput, TEXT("TempPackCodes"), fFalse))
			EvalAssert( FExecSqlCmd(hdbInput, TEXT("DROP TABLE `TempPackCodes`")) );
		if (FTableExists(hdbInput, TEXT("TempImageNames"), fFalse))
			EvalAssert( FExecSqlCmd(hdbInput, TEXT("DROP TABLE `TempImageNames`")) );
		Assert(szTempFName != szNull);
		EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput, TEXT("DontRemoveTempFolderWhenFinished"), rgch, MAX_PATH) );
		}
	else if (szTempFName != szNull)
		lstrcpy(rgch, TEXT("0")); // remove temp folder; PCP never opened.
	else
		lstrcpy(rgch, TEXT("1")); // don't attempt to remove temp folder; it was never created.
	
#ifdef DEBUG
	if (hdbInput != NULL)
		MsiDatabaseCommit(hdbInput);
#endif

	MsiCloseAllHandles();
	EvalAssert( FEndLogFile() );

	CloseLogFile();

	if (FEmptySz(rgch) || *rgch == TEXT('0'))
		{
		Assert(szTempFName != szNull);
		*szTempFName = TEXT('\0');
#ifdef DEBUG
		StringCchPrintf(rgch, sizeof(rgch)/sizeof(TCHAR), TEXT("Temp folder is about to be cleaned out and deleted:\n   '%s'"), szTempFolder);
		OutputDebugString(rgch);
#endif

		EvalAssert( FDeleteTempFolder(szTempFolder) );
		}

	EndStatusMsgs();
}


/* ********************************************************************** */
static UINT UiValidatePatchPath ( MSIHANDLE hdb, LPTSTR szPatchPath )
{
	Assert(hdb != NULL);

	if (FEmptySz(szPatchPath))
		{
		UINT ids = IdsMsiGetPcwPropertyString(hdb, TEXT("PatchOutputPath"), szPatchPath, MAX_PATH);
		if (ids != IDS_OKAY || FEmptySz(szPatchPath))
			return (UiLogError(ERROR_PCW_MISSING_PATCH_PATH, NULL, NULL));
		}

	if (FFileExist(szPatchPath))
		{
		EvalAssert( FFixupPath(szPatchPath) );
		}

	if (FFolderExist(szPatchPath))
		return (UiLogError(ERROR_PCW_CANT_OVERWRITE_PATCH, szPatchPath, NULL));

	return (ERROR_SUCCESS);
}


static TCHAR rgchLogFile[MAX_PATH] = TEXT("");

/* ********************************************************************** */
static UINT UiInitLogFile ( LPTSTR szLogPath )
{
	Assert(FEmptySz(rgchLogFile));

	if (!FEmptySz(szLogPath))
		{
		TCHAR rgch[MAX_PATH];
		EvalAssert( FFixupPathEx(szLogPath, rgch) );

		LPTSTR szFName = SzFindFilenameInPath(rgch);
		if (FEmptySz(szFName))
			{
			AssertFalse();
			return (ERROR_SUCCESS);
			}

		*szFName = TEXT('\0');
		if (!FEnsureFolderExists(rgch))
			{
			AssertFalse();
			return (ERROR_SUCCESS);
			}

		EvalAssert( FFixupPathEx(szLogPath, rgchLogFile) );
		if (FFileExist(rgchLogFile))
			SetFileAttributes(rgchLogFile, FILE_ATTRIBUTE_NORMAL);

		SYSTEMTIME st;
		GetLocalTime(&st);
		StringCchPrintf(rgch, sizeof(rgch)/sizeof(TCHAR), TEXT("\r\n***** Log starting: %4d-%02d-%02d %02d:%02d:%02d *****\r\n\r\n"),
				st.wYear, st.wMonth, st.wDay,
				st.wHour, st.wMinute, st.wSecond);

		if (!FWriteLogFile(rgch))
			{
			AssertFalse();
			*rgchLogFile = TEXT('\0');
			return (ERROR_SUCCESS);
			}
		}

	return (ERROR_SUCCESS);
}


//log file handle open all the time...

HANDLE g_hf = NULL;

/* ********************************************************************** */
BOOL FWriteLogFile ( LPTSTR szLine )
{
	Assert(!FEmptySz(szLine));

	if (FEmptySz(rgchLogFile))
		return (fTrue);

	// use global handle and don't reopen/close, that is expensive!
	if (!g_hf) //if first time
		{
		g_hf = CreateFile(rgchLogFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

		if (g_hf == INVALID_HANDLE_VALUE)
			return (fFalse);
		
		// handle concatenation of log files
		SetFilePointer(g_hf, 0, NULL, FILE_END);
		}

	if (g_hf == INVALID_HANDLE_VALUE)
		return (fFalse);


	BOOL fRet = fTrue;

	DWORD dwWritten = 0;
	DWORD dwSize = lstrlen(szLine)*sizeof(TCHAR);
	if (!WriteFile(g_hf, (LPVOID)szLine, dwSize, &dwWritten, NULL) || dwWritten != dwSize)
		fRet = fFalse;

	// file handle is closed by CloseLogFile() in TerminatePatchModule(...)
	return (fRet);
}


//add new function to close log file at end...
void CloseLogFile()
{
  if (g_hf && (g_hf != INVALID_HANDLE_VALUE))
  {
     CloseHandle(g_hf);     
	 g_hf = NULL;
  }
}

/* ********************************************************************** */
BOOL FSprintfToLog ( LPTSTR szLine, LPTSTR szData1, LPTSTR szData2, LPTSTR szData3, LPTSTR szData4 )
{
	Assert(!FEmptySz(szLine));
	Assert(szData1 != szNull);
	Assert(szData2 != szNull);
	Assert(szData3 != szNull);
	Assert(szData4 != szNull);
	Assert(lstrlen(szLine) + lstrlen(szData1) + lstrlen(szData2) + lstrlen(szData3) + lstrlen(szData4) < 1020);

	TCHAR rgch[1024];
	StringCchPrintf(rgch, sizeof(rgch)/sizeof(TCHAR), szLine, szData1, szData2, szData3, szData4);
	lstrcat(rgch, TEXT("\r\n"));
	Assert(lstrlen(rgch) < 1024);

	return (FWriteLogFile(rgch));
}


/* ********************************************************************** */
UINT UiLogError ( UINT ids, LPTSTR szData, LPTSTR szData2 )
{
	LPTSTR szT;
	switch (ids)
		{
	case ERROR_PCW_PCP_DOESNT_EXIST:
		if (szData == NULL)
			szT = TEXT(".PCP file does not exist (or was not specified)");
		else
			{
			Assert(!FEmptySz(szData));
			szT = TEXT(".PCP file '%s' does not exist.");
			}
		break;
	case ERROR_PCW_PCP_BAD_FORMAT:
		Assert(!FEmptySz(szData));
		szT = TEXT("The .pcp file '%s' is invalid.");
		break;
	case ERROR_PCW_CANT_CREATE_TEMP_FOLDER:
		Assert(!FEmptySz(szData));
		szT = TEXT("Cannot create folder: '%s'.");
		break;
	case ERROR_PCW_MISSING_PATCH_PATH:
		szT = TEXT("The PatchOutputPath property is missing from the Properties table of the .pcp file.  No other patch output path was specified, so this property is required.");
		break;
	case ERROR_PCW_CANT_OVERWRITE_PATCH:
		Assert(!FEmptySz(szData));
		szT = TEXT("Cannot overwrite patch '%s'. Check the permissions to make sure that patchwiz will have access to the file. (Note, this path cannot be a folder.)");
		break;
	case ERROR_PCW_CANT_CREATE_PATCH_FILE:
		Assert(!FEmptySz(szData));
		szT = TEXT("Unable to create patch '%s'.");
		break;
	case ERROR_PCW_MISSING_PATCH_GUID:
		szT = TEXT("PatchGUID property is missing from the Properties table of the .pcp file. This is a required property");
		break;
	case ERROR_PCW_BAD_PATCH_GUID:
		Assert(!FEmptySz(szData));
		szT = TEXT("The PatchGUID '%s' in the Properties table of the .pcp file is an invalid GUID.");
		break;
	case ERROR_PCW_BAD_GUIDS_TO_REPLACE:
		Assert(!FEmptySz(szData));
		szT = TEXT("At least one of the GUIDs '%s' defined in the ListOfPatchGUIDsToReplace property in the Properties table of the .pcp file is invalid.");
		break;
	case ERROR_PCW_BAD_TARGET_PRODUCT_CODE_LIST:
		Assert(!FEmptySz(szData));
		szT = TEXT("At least one of the GUIDs '%s' defined in the ListOfTargetProductCodes property in the Properties table of the .pcp file is invalid.");
		break;
	case ERROR_PCW_NO_UPGRADED_IMAGES_TO_PATCH:
		szT = TEXT("No upgraded images are present in the UpgradedImages table of the .pcp file.");
		break;
	case ERROR_PCW_BAD_API_PATCHING_SYMBOL_FLAGS:
		Assert(!FEmptySz(szData));
		szT = TEXT("Bad ApiPatchingSymbolFlags = '%s'.");
		break;
	case ERROR_PCW_OODS_COPYING_MSI:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("Possible out of disk space condition.  Unable to copy '%s' to '%s'.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_NAME_TOO_LONG:
		if (szData == szNull)
			szT = TEXT("UpgradedImages.Upgraded string is way too long; use 1 to 13 alphanumeric characters.");
		else
			{
			Assert(!FEmptySz(szData));
			szT = TEXT("UpgradedImages.Upgraded string '%s' is too long; use 1 to 13 alphanumeric characters.");
			}
		break;
	case ERROR_PCW_BAD_UPGRADED_IMAGE_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.Upgraded string '%s' is invalid; use 1 to 13 alphanumeric characters.");
		break;
	case ERROR_PCW_DUP_UPGRADED_IMAGE_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.Upgraded string '%s' is a duplicate.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATH_TOO_LONG:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.MsiPath string is too long; Upgraded = '%s'.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATH_EMPTY:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.MsiPath field is empty; Upgraded = '%s'.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_EXIST:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.MsiPath '%s' does not exist.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.MsiPath '%s' is not a proper MSI.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_COMPRESSED:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.MsiPath '%s' is marked as having compressed files (PID_WORDCOUNT property of Summary Information stream). PatchWiz is unable to patch files compressed in a cabinet.");
		break;
	case ERROR_PCW_TARGET_IMAGE_NAME_TOO_LONG:
		if (szData == szNull)
			szT = TEXT("TargetImages.Target string is way too long; use 1 to 13 alphanumeric characters.");
		else
			{
			Assert(!FEmptySz(szData));
			szT = TEXT("TargetImages.Target string '%s' is too long; use 1 to 13 alphanumeric characters.");
			}
		break;
	case ERROR_PCW_BAD_TARGET_IMAGE_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.Target string '%s' is invalid; use 1 to 13 alphanumeric characters.");
		break;
	case ERROR_PCW_DUP_TARGET_IMAGE_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.Target string '%s' is a duplicate.");
		break;
	case ERROR_PCW_TARGET_IMAGE_PATH_TOO_LONG:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.MsiPath string is too long; Target = '%s'.");
		break;
	case ERROR_PCW_TARGET_IMAGE_PATH_EMPTY:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.MsiPath field is empty; Target = '%s'.");
		break;
	case ERROR_PCW_TARGET_IMAGE_PATH_NOT_EXIST:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.MsiPath '%s' does not exist.");
		break;
	case ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.MsiPath '%s' is not a proper MSI.");
		break;
	case ERROR_PCW_TARGET_IMAGE_COMPRESSED:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.MsiPath '%s' is marked as having compressed files (PID_WORDCOUNT property of Summary Information stream). PatchWiz is unable to patch files compressed in a cabinet.");
		break;
	case ERROR_PCW_TARGET_BAD_PROD_VALIDATE:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.ProductValidateFlags for '%s' is invalid; it should be an eight digit hex value of the form 0x12345678 and be valid.");
		break;
	case ERROR_PCW_TARGET_BAD_PROD_CODE_VAL:
		Assert(!FEmptySz(szData));
		szT = TEXT("The product code '%s' in ListOfTargetProductCodes is not referenced by a target image. This creates an invalid patch for this product because at least one of the TargetImages records contains MSITRANSFORM_VALIDATE_PRODUCT in its ProductValidateFlags.");
		break;
	case ERROR_PCW_UPGRADED_MISSING_SRC_FILES:
		Assert(!FEmptySz(szData));
		szT = TEXT("Cannot find Upgraded image source file: '%s'.");
		break;
	case ERROR_PCW_TARGET_MISSING_SRC_FILES:
		Assert(!FEmptySz(szData));
		szT = TEXT("Cannot find Target image source file: '%s'.");
		break;
	case ERROR_PCW_IMAGE_FAMILY_NAME_TOO_LONG:
		if (szData == szNull)
			szT = TEXT("ImageFamilies.Family string is way too long; use 1 to 8 alphanumeric characters.");
		else
			{
			Assert(!FEmptySz(szData));
			szT = TEXT("ImageFamilies.Family string '%s' is too long; use 1 to 8 alphanumeric characters.");
			}
		break;
	case ERROR_PCW_BAD_IMAGE_FAMILY_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("ImageFamilies.Family string '%s' is invalid; use 1 to 8 alphanumeric characters.");
		break;
	case ERROR_PCW_DUP_IMAGE_FAMILY_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("ImageFamilies.Family string '%s' is a duplicate.");
		break;
	case ERROR_PCW_BAD_IMAGE_FAMILY_SRC_PROP:
		Assert(szData != szNull);
		if (szData2 == szNull)
			{
			Assert(!FEmptySz(szData));
			szT = TEXT("ImageFamilies.MediaSrcPropName string is way too long; use 1 to 36 alphanumeric characters. Family: '%s'.");
			}
		else if (FEmptySz(szData))
			{
			Assert(!FEmptySz(szData2));
			szT = TEXT("ImageFamilies.MediaSrcPropName string is blank; use 1 to 36 alphanumeric characters. Family: '%s%s'.");
			}
		else
			{
			Assert(!FEmptySz(szData2));
			szT = TEXT("ImageFamilies.MediaSrcPropName string '%s' is invalid; use 1 to 36 alphanumeric characters. Family: '%s'.");
			}
		break;
	case ERROR_PCW_UFILEDATA_LONG_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedFiles_OptionalData: FTK is too long; Upgraded image: '%s'.");
		break;
	case ERROR_PCW_UFILEDATA_BLANK_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedFiles_OptionalData: FTK is blank; Upgraded image: '%s'.");
		break;
	case ERROR_PCW_UFILEDATA_MISSING_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("UpgradedFiles_OptionalData: FTK '%s' record is missing from image; Upgraded image: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_LONG_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("ExternalFiles: FTK is too long; Family: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_BLANK_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("ExternalFiles: FTK is blank; Family: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD:
		if (szData == szNull)
			szT = TEXT("ExternalFiles.Family string is way too long; use 1 to 8 alphanumeric characters.");
		else if (FEmptySz(szData))
			szT = TEXT("ExternalFiles.Family string is blank; use 1 to 8 alphanumeric characters.");
		else
			szT = TEXT("ExternalFiles.Family string is invalid or does not match a Family record; use 1 to 8 alphanumeric characters. Family: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_LONG_PATH_TO_FILE:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: FilePath is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_BLANK_PATH_TO_FILE:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: FilePath is blank; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_MISSING_FILE:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: Cannot find FilePath: '%s'; Family: '%s'.");
		break;
	case ERROR_PCW_BAD_FILE_SEQUENCE_START:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("The starting sequence value (FileSequenceStart) for the family '%s' in the ImageFamilies table overlaps the greatest last sequence value in the upgraded image '%s' Media table.");
		break;
	case ERROR_PCW_CANT_COPY_FILE_TO_TEMP_FOLDER:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("Cannot copy file from '%s' to '%s'.");
		break;
	case ERROR_PCW_CANT_CREATE_ONE_PATCH_FILE:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("Cannot create patch file for '%s' at '%s'.");
		break;
	case ERROR_PCW_BAD_IMAGE_FAMILY_DISKID:
		Assert(!FEmptySz(szData));
		szT = TEXT("ImageFamilies.MediaDiskId is invalid. Family: '%s'.");
		break;
	case ERROR_PCW_BAD_IMAGE_FAMILY_FILESEQSTART:
		Assert(!FEmptySz(szData));
		szT = TEXT("ImageFamilies.FileSequenceStart is invalid. Family: '%s'.");
		break;
	case ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY:
		Assert(!FEmptySz(szData));
		if (szData2 == szNull)
			szT = TEXT("UpgradedImages.Family string is way too long; use 1 to 8 alphanumeric characters. Upgraded image: '%s'.");
		else if (FEmptySz(szData2))
			szT = TEXT("UpgradedImages.Family string is blank; use 1 to 8 alphanumeric characters. Upgraded image: '%s'.");
		else
			szT = TEXT("UpgradedImages.Family string is invalid or does not match a Family record; use 1 to 8 alphanumeric characters. Upgraded image: '%s'; Family: '%s'.");
		break;
	case ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED:
		Assert(!FEmptySz(szData));
		if (szData2 == szNull)
			szT = TEXT("TargetImages.Upgraded string is way too long; use 1 to 13 alphanumeric characters. Target image: '%s'.");
		else if (FEmptySz(szData2))
			szT = TEXT("TargetImages.Upgraded string is blank; use 1 to 13 alphanumeric characters. Target image: '%s'.");
		else
			szT = TEXT("TargetImages.Upgraded string is invalid or does not match an Upgraded record; use 1 to 8 alphanumeric characters. Target image: '%s'; Upgraded image: '%s'.");
		break;
	case ERROR_PCW_DUP_TARGET_IMAGE_PACKCODE:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetImages.Target = '%s': PackageCode %s is not unique.");
		break;
	case ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD:
		if (szData == szNull)
			szT = TEXT("UpgradedFiles_OptionalData.Upgraded string is way too long; use 1 to 13 alphanumeric characters.");
		else if (FEmptySz(szData))
			szT = TEXT("UpgradedFiles_OptionalData.Upgraded string is blank; use 1 to 13 alphanumeric characters.");
		else
			szT = TEXT("UpgradedFiles_OptionalData.Upgraded string is invalid or does not match an Upgraded record; use 1 to 13 alphanumeric characters. Upgraded image: '%s'.");
		break;
	case ERROR_PCW_MISMATCHED_PRODUCT_CODES:
		szT = TEXT("The product code differs between the target and upgraded images. Set AllowProductCodeMismatches in the Properties table of the .pcp file to 1 to allow mismatches.");
		break;
	case ERROR_PCW_MISMATCHED_PRODUCT_VERSIONS:
		szT = TEXT("The product version differs between the target and upgraded images. Set AllowProductVersionMismatches in the Properties table of the .pcp file to 1 to allow mismatches.");
		break;
	case ERROR_PCW_CANNOT_WRITE_DDF:
		szT = TEXT("Cannot write to DDF file for MAKECAB.EXE.");
		break;
	case ERROR_PCW_CANNOT_RUN_MAKECAB:
		szT = TEXT("Cannot execute MAKECAB.EXE.");
		break;
	case ERROR_PCW_WRITE_SUMMARY_PROPERTIES:
		szT = TEXT("Cannot write Summary Properties to Patch Package.");
		break;
	case ERROR_PCW_TFILEDATA_LONG_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetFiles_OptionalData: FTK is too long; Target image: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_BLANK_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetFiles_OptionalData: FTK is blank; Target image: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_MISSING_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: FTK '%s' record is missing from image; Target image: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD:
		if (szData == szNull)
			szT = TEXT("TargetFiles_OptionalData.Target string is way too long; use 1 to 13 alphanumeric characters.");
		else if (FEmptySz(szData))
			szT = TEXT("TargetFiles_OptionalData.Target string is blank; use 1 to 13 alphanumeric characters.");
		else
			szT = TEXT("TargetFiles_OptionalData.Target string is invalid or does not match an Target record; use 1 to 13 alphanumeric characters. Target image: '%s'.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_TOO_LONG:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.PatchMsiPath string is too long; Upgraded = '%s'.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_EXIST:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.PatchMsiPath '%s' does not exist.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_MSI:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.PatchMsiPath '%s' is not a proper MSI.");
		break;
	case ERROR_PCW_DUP_UPGRADED_IMAGE_PACKCODE:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("UpgradedImages.Upgraded = '%s': PackageCode %s is not unique.");
		break;
	case ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD:
		if (szData == szNull)
			szT = TEXT("UpgradedFilesToIgnore.Upgraded string is way too long; use 1 to 13 alphanumeric characters or '*' for all images.");
		else if (FEmptySz(szData))
			szT = TEXT("UpgradedFilesToIgnore.Upgraded string is blank; use 1 to 13 alphanumeric characters or '*' for all images.");
		else
			szT = TEXT("UpgradedFilesToIgnore.Upgraded string is invalid or does not match an Upgraded record; use 1 to 13 alphanumeric characters or '*' for all images. Upgraded image: '%s'.");
		break;
	case ERROR_PCW_UFILEIGNORE_LONG_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedFilesToIgnore: FTK is too long; Upgraded image: '%s'.");
		break;
	case ERROR_PCW_UFILEIGNORE_BLANK_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedFilesToIgnore: FTK is blank; Upgraded image: '%s'.");
		break;
	case ERROR_PCW_UFILEIGNORE_BAD_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("UpgradedFilesToIgnore: FTK can only have a trailing asterisk; Upgraded image: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_NAME_TOO_LONG:
		if (szData == szNull)
			szT = TEXT("FamilyFileRanges.Family string is way too long; use 1 to 8 alphanumeric characters.");
		else
			{
			Assert(!FEmptySz(szData));
			szT = TEXT("FamilyFileRanges.Family string '%s' is too long; use 1 to 8 alphanumeric characters.");
			}
		break;
	case ERROR_PCW_BAD_FAMILY_RANGE_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("FamilyFileRanges.Family string '%s' is invalid; use 1 to 8 alphanumeric characters; must match a record in ImageFamilies table.");
		break;
	case ERROR_PCW_FAMILY_RANGE_LONG_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("FamilyFileRanges: FTK is too long; Family: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_BLANK_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("FamilyFileRanges: FTK is blank; Family: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: RetainOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: RetainOffsets is blank; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: RetainOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: RetainLengths is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: RetainLengths is blank; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: RetainLengths is badly formatted - use comma deliminated numbers, no zeros; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_COUNT_MISMATCH:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: Number of elements in RetainOffsets does not match RetainLengths; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_LONG_IGNORE_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: IgnoreOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_BAD_IGNORE_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: IgnoreOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_LONG_IGNORE_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: IgnoreOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_BAD_IGNORE_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: IgnoreOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_IGNORE_COUNT_MISMATCH:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: Number of elements in IgnoreOffsets does not match IgnoreLengths; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_LONG_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: RetainOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_BAD_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: RetainOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_LONG_IGNORE_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: IgnoreOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_BAD_IGNORE_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: IgnoreOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_LONG_IGNORE_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: IgnoreOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_BAD_IGNORE_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: IgnoreOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_IGNORE_COUNT_MISMATCH:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: Number of elements in IgnoreOffsets does not match IgnoreLengths; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_LONG_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: RetainOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_BAD_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: RetainOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_CANT_GENERATE_TRANSFORM:
		szT = TEXT("Cannot generate a primary transform.");
		break;
	case ERROR_PCW_CANT_CREATE_SUMMARY_INFO:
		szT = TEXT("Cannot create Summary Info for primary transform.");
		break;
	case ERROR_PCW_CANT_GENERATE_TRANSFORM_POUND:
		szT = TEXT("Cannot generate a pound transform.");
		break;
	case ERROR_PCW_CANT_CREATE_SUMMARY_INFO_POUND:
		szT = TEXT("Cannot create Summary Info for pound transform.");
		break;
	case ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_CODE:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.Upgraded = '%s': ProductCode is not a valid GUID.");
		break;
	case ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_VERSION:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.Upgraded = '%s': ProductVersion is not valid.");
		break;
	case ERROR_PCW_BAD_UPGRADED_IMAGE_UPGRADE_CODE:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.Upgraded = '%s': UpgradeCode is not a valid GUID.");
		break;
	case ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_CODE:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.Target = '%s': ProductCode is not a valid GUID.");
		break;
	case ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_VERSION:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.Target = '%s': ProductVersion is not valid.");
		break;
	case ERROR_PCW_BAD_TARGET_IMAGE_UPGRADE_CODE:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.Target = '%s': UpgradeCode is not a valid GUID.");
		break;
	case ERROR_PCW_MATCHED_PRODUCT_VERSIONS:
		szT = TEXT("The product codes between the target and upgrade images changed, but the product versions remain the same. At least one of the three fields of the ProductVersion must change for a major upgrade patch.");
		break;

	case IDS_CANT_GET_RECORD_FIELD:
		Assert(!FEmptySz(szData));
		szT = TEXT("Cannot get record field: '%s'.");
		break;
	default:
		AssertFalse();
		return (ids);
		}

	TCHAR rgch[MAX_PATH+128];
	lstrcpy(rgch, TEXT("  ERROR: "));
	StringCchPrintf(rgch+lstrlen(TEXT("  ERROR: ")), sizeof(rgch)/sizeof(TCHAR) - lstrlen(TEXT("  ERROR: ")), szT, szData, szData2);
	lstrcat(rgch, TEXT("\r\n"));

	EvalAssert( FWriteLogFile(rgch) );

	return (ids);
}


/* ********************************************************************** */
static BOOL FEndLogFile ( void )
{
	if (!FEmptySz(rgchLogFile))
		{
		SYSTEMTIME st;
		GetLocalTime(&st);

		TCHAR rgch[MAX_PATH];
		StringCchPrintf(rgch, sizeof(rgch)/sizeof(TCHAR), TEXT("\r\n***** Log finishing: %4d-%02d-%02d %02d:%02d:%02d *****\r\n\r\n"),
				st.wYear, st.wMonth, st.wDay,
				st.wHour, st.wMinute, st.wSecond);
	
		EvalAssert( FWriteLogFile(rgch) );

// annoying!  don't see the need to make this read only
//		if (FFileExist(rgchLogFile))
//			SetFileAttributes(rgchLogFile, FILE_ATTRIBUTE_READONLY);

		*rgchLogFile = TEXT('\0');
		}

	return (fTrue);
}

#else // RC_INVOKED, end of source code, start of resources
//#include <winver.h>
STRINGTABLE DISCARDABLE
BEGIN
  IDS_STATUS_VALIDATE_INPUT           "Validating MSI input file..."
  IDS_STATUS_VALIDATE_IMAGES          "Checking for source files in images..." 
  IDS_STATUS_VALIDATE_FILE_RANGES     "Validating file retain/ignore ranges..."
  IDS_STATUS_DETERMINE_SEQUENCE_START "Determining file sequence starting number..."
  IDS_STATUS_EXPAND_OVERLAP_RECORDS   "Checking for file overlaps between upgraded images..."
  IDS_STATUS_COPY_UPGRADED_MSI        "Copying upgraded MSI to temp-target location..."
  IDS_STATUS_CREATE_FILE_PATCHES      "Creating file patches..."
  IDS_STATUS_CREATE_TRANSFORMS        "Generating transforms (MSTs)..."
  IDS_STATUS_CREATE_CABINET           "Creating cabinet file..."
  IDS_STATUS_CLEANUP                  "Cleaning up temporary files..."

  IDS_TITLE                           "Patch Creation Wizard"
  IDS_PRODUCTCODES_DONT_MATCH         "ProductCodes between Target and Upgraded images do not match; do you want to proceed anyway?"
  IDS_PRODUCTVERSIONS_DONT_MATCH      "ProductVersions between Target and Upgraded images do not match; do you want to proceed anyway?"
  IDS_PRODUCTVERSION_INVERSION        "Target ProductVersion is greater than the Upgraded image; do you want to proceed anyway?"
END
#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\regmsi\sources.inc ===
TARGETNAME=regmsi
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=windows
UMENTRY=winmain

TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
	$(SDK_LIB_PATH)\msi.lib \
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\OLE32.lib \
        $(SDK_LIB_PATH)\strsafe.lib

C_DEFINES=$(C_DEFINES)
USE_LIBCMT=1

INCLUDES=$(INCLUDES);$(INC_DIR);$(RES_OBJDIR);$(BUILD_COMMONDIR);$(TOOLS_INC_DIR)

SOURCES=..\regmsi.cpp \
	..\regmsi.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\patchwiz\patchwiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation.  All rights reserved.
//
//--------------------------------------------------------------------------

  /* PATCHWIZ.H - public header file for PATCHWIZ.DLL */

/*
**	UINT WINAPI UiCreatePatchPackage ( LPTSTR szPcpPath,
**		LPTSTR szPatchPath, LPTSTR szLogPath, HWND hwndStatus,
**		LPTSTR szTempFolder, BOOL fRemoveTempFolderIfPresent );
**
**	Arguments:
**	  szPcpPath - full absolute path to Windows Installer database
**		(PCP file) that contains appropriate tables of input-data for
**		Patch creation process such as Properties and TargetImages.
**	  szPatchPath - optional, full absolute path to Patching Package
**		file (MSP file) to create and stuff with output.  If this
**		NULL or an empty string, the api will try to use
**		Properties.Value where Properties.Name = PatchOutputPath
**		from the PCP file.
**	  szLogPath - optional, full absolute path to text log file to
**		append to.  Caller should truncate file if wanted.
**	  hwndStatus - optional, window handle to display status text.
**		More details to come later.
**	  szTempFolder - optional location to use for temp files.
**		Default is %TEMP%\~pcw_tmp.tmp\.
**	  fRemoveTempFolderIfPresent - remove temp folder (and all its
**		contents) if present.  If FALSE and folder is present, api
**		will fail.
**		
**	Return Values: ERROR_SUCCESS, plus ERROR_PCW_* that follow.
*/
#define ERROR_PCW_BASE                                 0xC00E5101

#define ERROR_PCW_PCP_DOESNT_EXIST                    (ERROR_PCW_BASE + 0x00)
#define ERROR_PCW_PCP_BAD_FORMAT                      (ERROR_PCW_BASE + 0x01)
#define ERROR_PCW_CANT_CREATE_TEMP_FOLDER             (ERROR_PCW_BASE + 0x02)
#define ERROR_PCW_MISSING_PATCH_PATH                  (ERROR_PCW_BASE + 0x03)
#define ERROR_PCW_CANT_OVERWRITE_PATCH                (ERROR_PCW_BASE + 0x04)
#define ERROR_PCW_CANT_CREATE_PATCH_FILE              (ERROR_PCW_BASE + 0x05)
#define ERROR_PCW_MISSING_PATCH_GUID                  (ERROR_PCW_BASE + 0x06)
#define ERROR_PCW_BAD_PATCH_GUID                      (ERROR_PCW_BASE + 0x07)
#define ERROR_PCW_BAD_GUIDS_TO_REPLACE                (ERROR_PCW_BASE + 0x08)
#define ERROR_PCW_BAD_TARGET_PRODUCT_CODE_LIST        (ERROR_PCW_BASE + 0x09)
#define ERROR_PCW_NO_UPGRADED_IMAGES_TO_PATCH         (ERROR_PCW_BASE + 0x0a)
//#define ERROR_PCW_BAD_API_PATCHING_OPTION_FLAGS       (ERROR_PCW_BASE + 0x0b) -- obsolete
#define ERROR_PCW_BAD_API_PATCHING_SYMBOL_FLAGS       (ERROR_PCW_BASE + 0x0c)
#define ERROR_PCW_OODS_COPYING_MSI                    (ERROR_PCW_BASE + 0x0d)
#define ERROR_PCW_UPGRADED_IMAGE_NAME_TOO_LONG        (ERROR_PCW_BASE + 0x0e)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_NAME             (ERROR_PCW_BASE + 0x0f)

#define ERROR_PCW_DUP_UPGRADED_IMAGE_NAME             (ERROR_PCW_BASE + 0x10)
#define ERROR_PCW_UPGRADED_IMAGE_PATH_TOO_LONG        (ERROR_PCW_BASE + 0x11)
#define ERROR_PCW_UPGRADED_IMAGE_PATH_EMPTY           (ERROR_PCW_BASE + 0x12)
#define ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_EXIST       (ERROR_PCW_BASE + 0x13)
#define ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI         (ERROR_PCW_BASE + 0x14)
#define ERROR_PCW_UPGRADED_IMAGE_COMPRESSED           (ERROR_PCW_BASE + 0x15)
#define ERROR_PCW_TARGET_IMAGE_NAME_TOO_LONG          (ERROR_PCW_BASE + 0x16)
#define ERROR_PCW_BAD_TARGET_IMAGE_NAME               (ERROR_PCW_BASE + 0x17)
#define ERROR_PCW_DUP_TARGET_IMAGE_NAME               (ERROR_PCW_BASE + 0x18)
#define ERROR_PCW_TARGET_IMAGE_PATH_TOO_LONG          (ERROR_PCW_BASE + 0x19)
#define ERROR_PCW_TARGET_IMAGE_PATH_EMPTY             (ERROR_PCW_BASE + 0x1a)
#define ERROR_PCW_TARGET_IMAGE_PATH_NOT_EXIST         (ERROR_PCW_BASE + 0x1b)
#define ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI           (ERROR_PCW_BASE + 0x1c)
#define ERROR_PCW_TARGET_IMAGE_COMPRESSED             (ERROR_PCW_BASE + 0x1d)
#define ERROR_PCW_TARGET_BAD_PROD_VALIDATE            (ERROR_PCW_BASE + 0x1e)
#define ERROR_PCW_TARGET_BAD_PROD_CODE_VAL            (ERROR_PCW_BASE + 0x1f)

#define ERROR_PCW_UPGRADED_MISSING_SRC_FILES          (ERROR_PCW_BASE + 0x20)
#define ERROR_PCW_TARGET_MISSING_SRC_FILES            (ERROR_PCW_BASE + 0x21)
#define ERROR_PCW_IMAGE_FAMILY_NAME_TOO_LONG          (ERROR_PCW_BASE + 0x22)
#define ERROR_PCW_BAD_IMAGE_FAMILY_NAME               (ERROR_PCW_BASE + 0x23)
#define ERROR_PCW_DUP_IMAGE_FAMILY_NAME               (ERROR_PCW_BASE + 0x24)
#define ERROR_PCW_BAD_IMAGE_FAMILY_SRC_PROP           (ERROR_PCW_BASE + 0x25)
#define ERROR_PCW_UFILEDATA_LONG_FILE_TABLE_KEY       (ERROR_PCW_BASE + 0x26)
#define ERROR_PCW_UFILEDATA_BLANK_FILE_TABLE_KEY      (ERROR_PCW_BASE + 0x27)
#define ERROR_PCW_UFILEDATA_MISSING_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x28)
#define ERROR_PCW_EXTFILE_LONG_FILE_TABLE_KEY         (ERROR_PCW_BASE + 0x29)
#define ERROR_PCW_EXTFILE_BLANK_FILE_TABLE_KEY        (ERROR_PCW_BASE + 0x2a)
#define ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD            (ERROR_PCW_BASE + 0x2b)
#define ERROR_PCW_EXTFILE_LONG_PATH_TO_FILE           (ERROR_PCW_BASE + 0x2c)
#define ERROR_PCW_EXTFILE_BLANK_PATH_TO_FILE          (ERROR_PCW_BASE + 0x2d)
#define ERROR_PCW_EXTFILE_MISSING_FILE                (ERROR_PCW_BASE + 0x2e)
//#define ERROR_PCW_FILERANGE_LONG_FILE_TABLE_KEY       (ERROR_PCW_BASE + 0x2f) -- obsolete

//#define ERROR_PCW_FILERANGE_BLANK_FILE_TABLE_KEY      (ERROR_PCW_BASE + 0x30) -- obsolete
//#define ERROR_PCW_FILERANGE_MISSING_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x31) -- obsolete
//#define ERROR_PCW_FILERANGE_LONG_PATH_TO_FILE         (ERROR_PCW_BASE + 0x32) -- obsolete
//#define ERROR_PCW_FILERANGE_MISSING_FILE              (ERROR_PCW_BASE + 0x33) -- obsolete
//#define ERROR_PCW_FILERANGE_INVALID_OFFSET            (ERROR_PCW_BASE + 0x34) -- obsolete
//#define ERROR_PCW_FILERANGE_INVALID_SIZE              (ERROR_PCW_BASE + 0x35) -- obsolete
//#define ERROR_PCW_FILERANGE_INVALID_RETAIN            (ERROR_PCW_BASE + 0x36) -- obsolete
//#define ERROR_PCW_BAD_MEDIA_SRC_PROP_NAME             (ERROR_PCW_BASE + 0x37) -- obsolete
//#define ERROR_PCW_BAD_MEDIA_DISK_ID                   (ERROR_PCW_BASE + 0x38) -- obsolete
#define ERROR_PCW_BAD_FILE_SEQUENCE_START             (ERROR_PCW_BASE + 0x39)
#define ERROR_PCW_CANT_COPY_FILE_TO_TEMP_FOLDER       (ERROR_PCW_BASE + 0x3a)
#define ERROR_PCW_CANT_CREATE_ONE_PATCH_FILE          (ERROR_PCW_BASE + 0x3b)
#define ERROR_PCW_BAD_IMAGE_FAMILY_DISKID             (ERROR_PCW_BASE + 0x3c)
#define ERROR_PCW_BAD_IMAGE_FAMILY_FILESEQSTART       (ERROR_PCW_BASE + 0x3d)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY           (ERROR_PCW_BASE + 0x3e)
#define ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED           (ERROR_PCW_BASE + 0x3f)

#define ERROR_PCW_DUP_TARGET_IMAGE_PACKCODE           (ERROR_PCW_BASE + 0x40)
#define ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD        (ERROR_PCW_BASE + 0x41)
#define ERROR_PCW_MISMATCHED_PRODUCT_CODES            (ERROR_PCW_BASE + 0x42)
#define ERROR_PCW_MISMATCHED_PRODUCT_VERSIONS         (ERROR_PCW_BASE + 0x43)
#define ERROR_PCW_CANNOT_WRITE_DDF                    (ERROR_PCW_BASE + 0x44)
#define ERROR_PCW_CANNOT_RUN_MAKECAB                  (ERROR_PCW_BASE + 0x45)
//#define ERROR_PCW_CANNOT_CREATE_STORAGE               (ERROR_PCW_BASE + 0x46) -- obsolete
//#define ERROR_PCW_CANNOT_CREATE_STREAM                (ERROR_PCW_BASE + 0x47) -- obsolete
//#define ERROR_PCW_CANNOT_WRITE_STREAM                 (ERROR_PCW_BASE + 0x48) -- obsolete
//#define ERROR_PCW_CANNOT_READ_CABINET                 (ERROR_PCW_BASE + 0x49) -- obsolete
#define ERROR_PCW_WRITE_SUMMARY_PROPERTIES            (ERROR_PCW_BASE + 0x4a)
#define ERROR_PCW_TFILEDATA_LONG_FILE_TABLE_KEY       (ERROR_PCW_BASE + 0x4b)
#define ERROR_PCW_TFILEDATA_BLANK_FILE_TABLE_KEY      (ERROR_PCW_BASE + 0x4c)
#define ERROR_PCW_TFILEDATA_MISSING_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x4d)
#define ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD          (ERROR_PCW_BASE + 0x4e)
#define ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_TOO_LONG  (ERROR_PCW_BASE + 0x4f)

#define ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_EXIST (ERROR_PCW_BASE + 0x50)
#define ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_MSI   (ERROR_PCW_BASE + 0x51)
#define ERROR_PCW_DUP_UPGRADED_IMAGE_PACKCODE         (ERROR_PCW_BASE + 0x52)
#define ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD      (ERROR_PCW_BASE + 0x53)
#define ERROR_PCW_UFILEIGNORE_LONG_FILE_TABLE_KEY     (ERROR_PCW_BASE + 0x54)
#define ERROR_PCW_UFILEIGNORE_BLANK_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x55)
#define ERROR_PCW_UFILEIGNORE_BAD_FILE_TABLE_KEY      (ERROR_PCW_BASE + 0x56)
#define ERROR_PCW_FAMILY_RANGE_NAME_TOO_LONG          (ERROR_PCW_BASE + 0x57)
#define ERROR_PCW_BAD_FAMILY_RANGE_NAME               (ERROR_PCW_BASE + 0x58)
#define ERROR_PCW_FAMILY_RANGE_LONG_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x59)
#define ERROR_PCW_FAMILY_RANGE_BLANK_FILE_TABLE_KEY   (ERROR_PCW_BASE + 0x5a)
#define ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_OFFSETS    (ERROR_PCW_BASE + 0x5b)
#define ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_OFFSETS   (ERROR_PCW_BASE + 0x5c)
#define ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_OFFSETS     (ERROR_PCW_BASE + 0x5d)
#define ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_LENGTHS    (ERROR_PCW_BASE + 0x5e)
#define ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_LENGTHS   (ERROR_PCW_BASE + 0x5f)

#define ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_LENGTHS     (ERROR_PCW_BASE + 0x60)
#define ERROR_PCW_FAMILY_RANGE_COUNT_MISMATCH         (ERROR_PCW_BASE + 0x61)
#define ERROR_PCW_EXTFILE_LONG_IGNORE_OFFSETS         (ERROR_PCW_BASE + 0x62)
#define ERROR_PCW_EXTFILE_BAD_IGNORE_OFFSETS          (ERROR_PCW_BASE + 0x63)
#define ERROR_PCW_EXTFILE_LONG_IGNORE_LENGTHS         (ERROR_PCW_BASE + 0x64)
#define ERROR_PCW_EXTFILE_BAD_IGNORE_LENGTHS          (ERROR_PCW_BASE + 0x65)
#define ERROR_PCW_EXTFILE_IGNORE_COUNT_MISMATCH       (ERROR_PCW_BASE + 0x66)
#define ERROR_PCW_EXTFILE_LONG_RETAIN_OFFSETS         (ERROR_PCW_BASE + 0x67)
#define ERROR_PCW_EXTFILE_BAD_RETAIN_OFFSETS          (ERROR_PCW_BASE + 0x68)
//#define ERROR_PCW_EXTFILE_RETAIN_COUNT_MISMATCH       (ERROR_PCW_BASE + 0x69) -- obsolete
#define ERROR_PCW_TFILEDATA_LONG_IGNORE_OFFSETS       (ERROR_PCW_BASE + 0x6a)
#define ERROR_PCW_TFILEDATA_BAD_IGNORE_OFFSETS        (ERROR_PCW_BASE + 0x6b)
#define ERROR_PCW_TFILEDATA_LONG_IGNORE_LENGTHS       (ERROR_PCW_BASE + 0x6c)
#define ERROR_PCW_TFILEDATA_BAD_IGNORE_LENGTHS        (ERROR_PCW_BASE + 0x6d)
#define ERROR_PCW_TFILEDATA_IGNORE_COUNT_MISMATCH     (ERROR_PCW_BASE + 0x6e)
#define ERROR_PCW_TFILEDATA_LONG_RETAIN_OFFSETS       (ERROR_PCW_BASE + 0x6f)

#define ERROR_PCW_TFILEDATA_BAD_RETAIN_OFFSETS        (ERROR_PCW_BASE + 0x70)
//#define ERROR_PCW_TFILEDATA_RETAIN_COUNT_MISMATCH     (ERROR_PCW_BASE + 0x71) -- obsolete
#define ERROR_PCW_CANT_GENERATE_TRANSFORM             (ERROR_PCW_BASE + 0x72)
#define ERROR_PCW_CANT_CREATE_SUMMARY_INFO            (ERROR_PCW_BASE + 0x73)
#define ERROR_PCW_CANT_GENERATE_TRANSFORM_POUND       (ERROR_PCW_BASE + 0x74)
#define ERROR_PCW_CANT_CREATE_SUMMARY_INFO_POUND      (ERROR_PCW_BASE + 0x75)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_CODE     (ERROR_PCW_BASE + 0x76)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_VERSION  (ERROR_PCW_BASE + 0x77)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_UPGRADE_CODE     (ERROR_PCW_BASE + 0x78)
#define ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_CODE       (ERROR_PCW_BASE + 0x79)
#define ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_VERSION    (ERROR_PCW_BASE + 0x7a)
#define ERROR_PCW_BAD_TARGET_IMAGE_UPGRADE_CODE       (ERROR_PCW_BASE + 0x7b)
#define ERROR_PCW_MATCHED_PRODUCT_VERSIONS            (ERROR_PCW_BASE + 0x7c)
#define ERROR_PCW_NEXTxd           (ERROR_PCW_BASE + 0x7d)
#define ERROR_PCW_NEXTxe           (ERROR_PCW_BASE + 0x7e)
#define ERROR_PCW_NEXTxf           (ERROR_PCW_BASE + 0x7f)

/* 
#define ERROR_PCW_NEXTx0           (ERROR_PCW_BASE + 0x80)
#define ERROR_PCW_NEXTx1           (ERROR_PCW_BASE + 0x81)
#define ERROR_PCW_NEXTx2           (ERROR_PCW_BASE + 0x82)
#define ERROR_PCW_NEXTx3           (ERROR_PCW_BASE + 0x83)
#define ERROR_PCW_NEXTx4           (ERROR_PCW_BASE + 0x84)
#define ERROR_PCW_NEXTx5           (ERROR_PCW_BASE + 0x85)
#define ERROR_PCW_NEXTx6           (ERROR_PCW_BASE + 0x86)
#define ERROR_PCW_NEXTx7           (ERROR_PCW_BASE + 0x87)
#define ERROR_PCW_NEXTx8           (ERROR_PCW_BASE + 0x88)
#define ERROR_PCW_NEXTx9           (ERROR_PCW_BASE + 0x89)
#define ERROR_PCW_NEXTxa           (ERROR_PCW_BASE + 0x8a)
#define ERROR_PCW_NEXTxb           (ERROR_PCW_BASE + 0x8b)
#define ERROR_PCW_NEXTxc           (ERROR_PCW_BASE + 0x8c)
#define ERROR_PCW_NEXTxd           (ERROR_PCW_BASE + 0x8d)
#define ERROR_PCW_NEXTxe           (ERROR_PCW_BASE + 0x8e)
#define ERROR_PCW_NEXTxf           (ERROR_PCW_BASE + 0x8f)
*/


/*  Control IDs for hwndStatus child Text controls; title is required */
#define IDC_STATUS_TITLE                     (0x1cf0)
#define IDC_STATUS_DATA1                     (0x1cf1)
#define IDC_STATUS_DATA2                     (0x1cf2)



#ifdef __cplusplus
extern "C" {
#endif

extern UINT __declspec(dllexport) WINAPI UiCreatePatchPackageA ( LPSTR  szaPcpPath, LPSTR  szaPatchPath, LPSTR  szaLogPath, HWND hwndStatus, LPSTR  szaTempFolder, BOOL fRemoveTempFolderIfPresent );
extern UINT __declspec(dllexport) WINAPI UiCreatePatchPackageW ( LPWSTR szwPcpPath, LPWSTR szwPatchPath, LPWSTR szwLogPath, HWND hwndStatus, LPWSTR szwTempFolder, BOOL fRemoveTempFolderIfPresent );

#ifdef __cplusplus
} /* end extern "C" */
#endif


#ifdef UNICODE
#define UiCreatePatchPackage  UiCreatePatchPackageW
#else
#define UiCreatePatchPackage  UiCreatePatchPackageA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\patchwiz\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=patchwiz
TARGETTYPE=DYNLINK

!INCLUDE ..\..\..\MsiMake.inc

UMTYPE=windows
DLLDEF=..\patchwiz.def
DLLENTRY=_DllMainCRTStartup

C_DEFINES=$(C_DEFINES) -DWIN32 -D_WIN32 
INCLUDES=$(INCLUDES);..;$(INC_DIR);$(RES_OBJDIR)

USE_LIBCMT=1

SOURCES=\
    ..\patchwiz.rc  \
    ..\fileptch.cpp \
    ..\msistuff.cpp \
    ..\patchwiz.cpp \
    ..\pwutils.cpp \
    ..\patchcache.cpp 

TARGETLIBS= \
       $(SDK_LIB_PATH)\kernel32.lib \
       $(SDK_LIB_PATH)\advapi32.lib \
       $(SDK_LIB_PATH)\user32.lib   \
       $(SDK_LIB_PATH)\version.lib  \
       $(SDK_LIB_PATH)\ole32.lib  \
       $(SDK_LIB_PATH)\msi.lib \
       $(SDK_LIB_PATH)\mspatchc.lib          

!if "$(MAKEDLL)"=="1"
MISCFILES=\
       $(BUILD_DIR)\patchwiz.lib
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\setup.exe\common.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation. All rights reserved.
//
//  File:       common.h
//
//--------------------------------------------------------------------------

#ifndef __COMMON_H_5F90F583_B9A4_4A8F_91BC_618DE6696231_
#define __COMMON_H_5F90F583_B9A4_4A8F_91BC_618DE6696231_

#include <windows.h>

/*--------------------------------------------------------------------------
 *
 * Predefined Resource Types
 *
 --------------------------------------------------------------------------*/
#define RT_INSTALL_PROPERTY  MAKEINTRESOURCE(40)

/*--------------------------------------------------------------------------
 *
 * Predefined Resource Names
 *
 --------------------------------------------------------------------------*/
#define ISETUPPROPNAME_BASEURL              TEXT("BASEURL")
#define ISETUPPROPNAME_DATABASE             TEXT("DATABASE")
#define ISETUPPROPNAME_OPERATION            TEXT("OPERATION")
#define ISETUPPROPNAME_MINIMUM_MSI          TEXT("MINIMUM_MSI")
#define ISETUPPROPNAME_INSTLOCATION         TEXT("INSTLOCATION")
#define ISETUPPROPNAME_INSTMSIA             TEXT("INSTMSIA")
#define ISETUPPROPNAME_INSTMSIW             TEXT("INSTMSIW")
#define ISETUPPROPNAME_PRODUCTNAME          TEXT("PRODUCTNAME")
#define ISETUPPROPNAME_PROPERTIES           TEXT("PROPERTIES")
#define ISETUPPROPNAME_PATCH                TEXT("PATCH")

/*--------------------------------------------------------------------------
 *
 * Common Prototypes
 *
 ---------------------------------------------------------------------------*/
UINT LoadResourceString(HINSTANCE hInst, LPCSTR lpType, LPCSTR lpName, LPSTR lpBuf, DWORD *pdwBufSize);
UINT SetupLoadResourceString(HINSTANCE hInst, LPCSTR lpName, LPSTR *lppBuf, DWORD dwBufSize);

#endif //__COMMON_H_5F90F583_B9A4_4A8F_91BC_618DE6696231_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\regmsi\regmsi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       regmsi.cpp
//
//--------------------------------------------------------------------------

/* regmsi.cpp - Registers/unregisters MsiComponents
____________________________________________________________________________*/

#undef UNICODE

#include "common.h"  // names of standard DLLs
#include "tools.h"   // names of tool DLLs
#define MSI_AUTOAPI_NAME   "AutoApi.dll"  // temporary until merged with kernel

const char szRegisterEntry[]   = "DllRegisterServer";
const char szUnregisterEntry[] = "DllUnregisterServer";

const char szCmdOptions[] = "AaSsEeHhPpCcLlGgTtIiKk/-UuQqDdBb";  // pairs of equivalent options
enum rfEnum // must track each pair of letters above
{
/* Aa */ rfAutomation = 1,
/* Ss */ rfServices   = 2,
/* Ee */ rfEngine     = 4,
/* Hh */ rfHandler    = 8,
/* Pp */ rfPatch      = 16,
/* Cc */ rfAcmeConv   = 32,
/* Ll */ rfLocalize   = 64,
/* Gg */ rfGenerate   = 128,
/* Tt */ rfUtilities  = 256,
/* Ii */ rfInstaller  = 512,
/* Kk */ rfKernel     = 1024,
/* /- */ rfNoOp       = 2048,
/* Uu */ rfUnregister = 4096,
/* Qq */ rfQuiet      = 8192,
/* Dd */ rfDebug      = 16384,
/* Bb */ rfLego       = 32768,
			rfCoreModules = rfAutomation + rfKernel + rfHandler,
			rfAllModules = rfCoreModules + rfServices + rfEngine + rfAcmeConv + rfPatch
												  + rfUtilities + rfInstaller + rfLocalize + rfGenerate
};
const char* rgszModule[] = // must track enum above
{
/* rfAutomation */ MSI_AUTOMATION_NAME,
/* rfServices   */ TEXT("MsiSrv.dll"),
/* rfEngine     */ TEXT("MsiEng.dll"),
/* rfHandler    */ MSI_HANDLER_NAME,
/* rfPatch      */ MSI_PATCH_NAME,
/* rfAcmeConv   */ MSI_ACMECONV_NAME,
/* rfLocalize   */ MSI_LOCALIZE_NAME,
/* rfGenerate   */ MSI_GENERATE_NAME,
/* rfUtilities  */ MSI_UTILITIES_NAME,
/* rfInstaller  */ MSI_AUTOAPI_NAME,
/* rfKernel     */ MSI_KERNEL_NAME,
/* 0 terminator */ 0,
/* rfUnregister */ szUnregisterEntry,
/* rfQuiet      */ "Quiet, no error display",
/* rfDebug      */ "(ignored)",
/* rfLego       */ "(ignored)",
};

enum reEnum
{
	reNoError    = 0,
	reCmdOption  = 1,
	reModuleLoad = 2,
	reEntryPoint = 3,
	reRegFailure = 4,
};
const char* rgszError[] = // must track reEnum
{
	"",
	"Invalid command line option",
	"Error loading module",
	"Could not obtain module entry: %s",
	"Execution failed: %s"
};

reEnum CallModule(const char* szModule, const char* szEntry)
{
	HINSTANCE hLib;
	FARPROC pEntry;
	hLib = WIN::LoadLibraryEx(szModule,0, LOAD_WITH_ALTERED_SEARCH_PATH);
	if (!hLib)
	{
		char szPath[MAX_PATH];
		WIN::GetModuleFileName(0, szPath, sizeof(szPath)-1);
		szPath[sizeof(szPath)-1] = 0;
		char* pch = szPath + lstrlenA(szPath);
		while (*(pch-1) != '\\')
			pch--;
		StringCchCopy(pch, MAX_PATH - (pch - szPath), szModule);
		hLib = WIN::LoadLibraryEx(szPath ,0, LOAD_WITH_ALTERED_SEARCH_PATH);
	}
	if (!hLib)
		return reModuleLoad;
	reEnum reReturn = reNoError;
	if ((pEntry = WIN::GetProcAddress(hLib, szEntry)) == 0)
		reReturn = reEntryPoint;
	else if ((*pEntry)() != 0)
		reReturn  = reRegFailure;
	FreeLibrary(hLib);
	return reReturn;
}

INT WINAPI
WinMain(HINSTANCE /*hInst*/, HINSTANCE/*hPrev*/, char* cmdLine, INT/*show*/)
{
	int rfCmdOptions = 0;
	reEnum reStat = reNoError;;
	for (; *cmdLine; cmdLine++)
	{
		if (*cmdLine == ' ')
			continue;
		if (*cmdLine == '?')
		{
			char szHelp[1024];
			char* pchHelp = szHelp;
			char* pchHelpEnd = szHelp + sizeof(szHelp);
			const char** pszModule = rgszModule;
			for (const char* pch = szCmdOptions; *pch; pszModule++, pch += 2)
			{
				if (*pszModule != 0)
				{
					StringCchPrintf(pchHelp, pchHelpEnd-pchHelp, "%c\t%s\r", *pch, *pszModule);
					size_t i = 0;
					StringCchLength(pchHelp, pchHelpEnd-pchHelp, &i);
					pchHelp += i;
				}
			}
			WIN::MessageBox(0, szHelp, WIN::GetCommandLine(), MB_OK);
			return 0;
		}
		for (const char* pch = szCmdOptions; *pch != *cmdLine; pch++)
			if (*pch == 0)
			{
				WIN::MessageBox(0, rgszError[reCmdOption], WIN::GetCommandLine(), MB_OK);
				return 2;
			}
		rfCmdOptions |= 1 << (pch - szCmdOptions)/2;
	}
	if ((rfCmdOptions & rfAllModules) == 0)
		rfCmdOptions |= rfCoreModules;
	//!! will test TestAutomation flags and set the environment variable only if that flag is set
	//!! for now set it all the time until tests are updated
	WIN::SetEnvironmentVariable("_MSI_TEST", "R");
	const char* szEntry    = (rfCmdOptions & rfUnregister) ? szUnregisterEntry : szRegisterEntry;
	const char** pszModule = rgszModule;
	for (int iOptions = rfCmdOptions; *pszModule; pszModule++, iOptions >>= 1)
	{
		if ((iOptions & 1) && (reStat = CallModule(*pszModule, szEntry)) != reNoError)
		{
			char buf[80];
			StringCchPrintf(buf, sizeof(buf), rgszError[reStat], szEntry);
			int iStat;
			if ((rfCmdOptions & rfQuiet)
			 || (iStat = WIN::MessageBox(0, buf, *pszModule, MB_ABORTRETRYIGNORE)) == IDABORT)
				break;
			if (iStat == IDRETRY)
				pszModule--;
			else // IDIGNORE
				reStat = reNoError;
		}
	}
	return reStat != reNoError;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\patchwiz\pwutils.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//--------------------------------------------------------------------------

  /* PWUTILS.CPP -- Patch Creation Wizard DLL Utilities */

#pragma warning (disable:4553)

#include "patchdll.h"
#include <tchar.h>

EnableAsserts


static HINSTANCE hinstDll = NULL;

/* ********************************************************************** */
BOOL WINAPI DllMain ( HANDLE hModule, DWORD dwReason, LPVOID lpReserved )
{
	Unused(lpReserved);

	if (dwReason == DLL_PROCESS_ATTACH)
		{
		if ( ::CoInitialize(NULL) != S_OK )
			return (0);
		hinstDll = (HINSTANCE)hModule;
		}
	else if (dwReason == DLL_PROCESS_DETACH)
		{
		::CoUninitialize();
		}

	return (1);
}


static HWND  hdlgStatus        = hwndNull;
static HWND  hwndStatusTitle   = hwndNull;
static HWND  hwndStatusData1   = hwndNull;
static HWND  hwndStatusData2   = hwndNull;
static DWORD dwTicksStatusEnd  = 0;
static UINT  idsStatusTitleCur = 0;

/* ********************************************************************** */
void InitStatusMsgs ( HWND hwndStatus )
{
	Assert(hdlgStatus == hwndNull);
	Assert(idsStatusTitleCur == 0);

	if (hwndStatus == hwndNull)
		return;

	hwndStatusTitle  = GetDlgItem(hwndStatus, IDC_STATUS_TITLE);
	Assert(hwndStatusTitle != hwndNull);
	if (hwndStatusTitle == hwndNull)
		return;

	hdlgStatus       = hwndStatus;
	dwTicksStatusEnd = GetTickCount() + 1000L;  /* 1 second */
	hwndStatusData1  = GetDlgItem(hwndStatus, IDC_STATUS_DATA1);
	hwndStatusData2  = GetDlgItem(hwndStatus, IDC_STATUS_DATA2);
}


/* **************************************************************** */
void UpdateStatusMsg ( UINT ids, LPTSTR szData1, LPTSTR szData2 )
{
    Assert(ids == 0 || ids >= IDS_STATUS_MIN);
	Assert(ids == 0 || ids <  IDS_STATUS_MAX);
	Assert(szData1 != szNull || szData2 != szNull);

	if (hdlgStatus == hwndNull)
		return;

	Assert(hwndStatusTitle != hwndNull);

	if (ids != 0 && ids != idsStatusTitleCur)
		{
		Assert(szData1 != szNull);
		Assert(szData2 != szNull);

		TCHAR rgch[256];
		EvalAssert( FLoadString(ids, rgch, 256) );

		while (GetTickCount() < dwTicksStatusEnd)
			MyYield();

		SetWindowText(hwndStatusTitle, rgch);
		dwTicksStatusEnd = GetTickCount() + 1000L;  /* 1 second */
		}

	if (szData1 != szNull && hwndStatusData1 != hwndNull)
		SetWindowText(hwndStatusData1, szData1);

	if (szData2 != szNull && hwndStatusData2 != hwndNull)
		SetWindowText(hwndStatusData2, szData2);

	MyYield();
}


/* **************************************************************** */
void EndStatusMsgs ( void )
{
    if (hdlgStatus != hwndNull && idsStatusTitleCur != 0)
		{
		Assert(dwTicksStatusEnd > 0);
		Assert(hwndStatusTitle != hwndNull);

		while (GetTickCount() < dwTicksStatusEnd)
			MyYield();
		}

	hdlgStatus        = hwndNull;
	hwndStatusTitle   = hwndNull;
	hwndStatusData1   = hwndNull;
	hwndStatusData2   = hwndNull;
	dwTicksStatusEnd  = 0;
	idsStatusTitleCur = 0;
}


/* **************************************************************** */
HWND HdlgStatus ( void )
{
	return (hdlgStatus);
}


/* **************************************************************** */
void MyYield ( void )
{
	MSG msg;
	while (PeekMessage(&msg, hwndNull, 0, 0, PM_REMOVE))
		{
		if (hdlgStatus != hwndNull && IsDialogMessage(hdlgStatus, &msg))
			continue;

		TranslateMessage(&msg);
		DispatchMessage(&msg);
		}
}


/* ********************************************************************** */
BOOL FLoadString ( UINT ids, LPTSTR rgch, UINT cch )
{
    Assert(hinstDll != NULL);
    Assert(rgch != szNull);
    Assert(cch > 0);

    return (LoadString(hinstDll, ids, rgch, cch));
}


/* ********************************************************************** */
int IMessageBoxIds ( HWND hwnd, UINT ids, UINT uiType )
{
	TCHAR rgchMsg[MAX_PATH];
	EvalAssert( FLoadString(ids, rgchMsg, MAX_PATH) );

	TCHAR rgchTitle[MAX_PATH];
	EvalAssert( FLoadString(IDS_TITLE, rgchTitle, MAX_PATH) );

	return (MessageBox(hwnd, rgchMsg, rgchTitle, uiType));
}


/* ********************************************************************** */
LPTSTR SzLastChar ( LPTSTR sz )
{
    Assert(sz != szNull);
	Assert(*sz != TEXT('\0'));

    LPTSTR szNext = CharNext(sz);
    while (*szNext != TEXT('\0'))
        {
        sz = szNext;
        szNext = CharNext(sz);
        }

    return (sz);
}


/* ********************************************************************** */
LPTSTR SzDupSz ( LPTSTR sz )
{
	Assert(sz != szNull);

	UINT   cch = lstrlen(sz) + 1;
	LPTSTR szNew = (LPTSTR)LocalAlloc(LPTR, cch*sizeof(TCHAR));
	if (szNew != szNull)
		lstrcpy(szNew, sz);

	return (szNew);
}


/* ********************************************************************** */
LPSTR SzaDupSz ( LPTSTR sz )
{
	Assert(sz != szNull);

#ifdef UNICODE
	// nyi - convert to ansi and dup that
	return 0;
#else
	return (SzDupSz(sz));
#endif
}


/* ********************************************************************** */
BOOL FFileExist ( LPTSTR sz )
{
	if (sz == NULL || *sz == TEXT('\0'))
		return (fFalse);

	return (!(GetFileAttributes(sz) & FILE_ATTRIBUTE_DIRECTORY));
}


/* ********************************************************************** */
BOOL FFolderExist ( LPTSTR sz )
{
	if (sz == NULL || *sz == TEXT('\0'))
		return (fFalse);

	DWORD dwRet = GetFileAttributes(sz);

	return (dwRet != 0xffffffff && (dwRet & FILE_ATTRIBUTE_DIRECTORY));
}


/* ********************************************************************** */
BOOL FDeleteTempFolder ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));
	Assert(FFolderExist(sz));

	TCHAR rgch[MAX_PATH];
	lstrcpy(rgch, sz);

	LPTSTR szTail = SzLastChar(rgch);
	Assert(*szTail == TEXT('\\'));

	lstrcat(szTail, TEXT("*.*"));
	if (!FDeleteFiles(rgch))
		{
		AssertFalse();
		return (fFalse);
		}

	RemoveDirectory(sz);
	*szTail = TEXT('\0');
	RemoveDirectory(rgch);
	Assert(!FFolderExist(sz));

	return (!FFolderExist(sz));
}


/* ********************************************************************** */
BOOL FDeleteFiles ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));
	Assert(*SzLastChar(sz) != TEXT('\\'));

	TCHAR rgch[MAX_PATH];
	lstrcpy(rgch, sz);

	LPTSTR szTail = SzFindFilenameInPath(rgch);
	Assert(!FEmptySz(szTail));
	Assert(*szTail != TEXT('\\'));

	WIN32_FIND_DATA ffd;
	HANDLE hff = FindFirstFile(sz, &ffd);
	while (hff != INVALID_HANDLE_VALUE)
		{
		if (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
			{
			lstrcpy(szTail, ffd.cFileName);
			Assert(lstrlen(rgch) < MAX_PATH);
			SetFileAttributes(rgch, FILE_ATTRIBUTE_NORMAL);
			DeleteFile(rgch);
			Assert(!FFileExist(rgch));
			}
		else if (lstrcmp(ffd.cFileName, TEXT(".")) && lstrcmp(ffd.cFileName, TEXT("..")))
			{
			lstrcpy(szTail, ffd.cFileName);
			lstrcat(szTail, TEXT("\\"));
			EvalAssert( FDeleteTempFolder(rgch) );
			}

		if (!FindNextFile(hff, &ffd))
			{
			Assert(GetLastError() == ERROR_NO_MORE_FILES);
			EvalAssert( FindClose(hff) );
			hff = INVALID_HANDLE_VALUE;
			}
		}

	return (fTrue);
}


/* ********************************************************************** */
BOOL FEnsureFolderExists ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));
	Assert(*SzLastChar(sz) == TEXT('\\'));

	if (*sz == TEXT('\0') || *SzLastChar(sz) != TEXT('\\'))
		return (fFalse);

	/* RECURSION WARNING */

	if (FFolderExist(sz))
		return (fTrue);

	LPTSTR szLast = SzLastChar(sz);
	Assert(!FEmptySz(szLast));
	Assert(*szLast == TEXT('\\'));
	*szLast = TEXT('\0');

	LPTSTR szFName = SzFindFilenameInPath(sz);
	Assert(!FEmptySz(szFName));
	TCHAR chSav = *szFName;
	*szFName = TEXT('\0');

	BOOL fRet = FEnsureFolderExists(sz);

	*szFName = chSav;
	if (fRet && !FFolderExist(sz))
		fRet = CreateDirectory(sz, NULL);

	*szLast = TEXT('\\');

	return (fRet);
}


/* ********************************************************************** */
LPTSTR SzFindFilenameInPath ( LPTSTR sz )
{
	Assert(sz != szNull);

	LPTSTR szSlash = szNull;
	LPTSTR szCur   = sz;

	while (*szCur != TEXT('\0'))
		{
		LPTSTR szNext = CharNext(szCur);
		if (*szCur == TEXT('\\') && *szNext != TEXT('\0'))
			szSlash = szCur;
		szCur = szNext;
		}

	if (szSlash != szNull)
		return (CharNext(szSlash));

	return (sz);
}


/*
**	Windows API GetTempPath() can return unusable stuff if the TMP or
**	TEMP environment variables are set to garbage.
*/
/* ********************************************************************** */
BOOL FSetTempFolder ( LPTSTR szBuf, LPTSTR *pszFName, HWND hwnd, LPTSTR szTempFolder, BOOL fRemoveTempFolderIfPresent )
{
	Assert(szBuf != szNull);
	Assert(pszFName != NULL);

	TCHAR rgchPath[MAX_PATH + MAX_PATH];
	if (!FEmptySz(szTempFolder))
		{
		StringCchPrintf(rgchPath, sizeof(rgchPath)/sizeof(TCHAR), TEXT("Bad szTempFolder argument: '%s'."), szTempFolder);
		if (*SzLastChar(szTempFolder) == TEXT('\\'))
			*SzLastChar(szTempFolder) = TEXT('\0');
		while (*SzLastChar(szTempFolder) == TEXT('.'))
			{
			*SzLastChar(szTempFolder) = TEXT('\0');
			if (*SzLastChar(szTempFolder) == TEXT('\\'))
				*SzLastChar(szTempFolder) = TEXT('\0');
			else
				break;
			}
		if (FEmptySz(szTempFolder) || *szTempFolder == TEXT(':')
				|| *SzLastChar(szTempFolder) == TEXT('\\')
				|| *SzLastChar(szTempFolder) == TEXT(':'))
			{
LFailureReturn:
			*pszFName = szNull;
			if (hwnd != hwndNull)
				MessageBox(hwnd, rgchPath, szMsgBoxTitle, MB_OK | MB_ICONEXCLAMATION);
			return (fFalse);
			}
		if (*szTempFolder == TEXT('\\'))
			{
			LPTSTR sz = CharNext(szTempFolder);
			if (*sz == TEXT('\\')) //  \\server\share\subfolder
				{
				sz = CharNext(sz);
				if (*sz == TEXT('\\'))
					goto LFailureReturn;
				while (*sz != TEXT('\\'))
					{
					if (*sz == TEXT('\0'))
						goto LFailureReturn;
					sz = CharNext(sz);
					}
				sz = CharNext(sz);
				if (*sz == TEXT('\\'))
					goto LFailureReturn;
				while (*sz != TEXT('\\'))
					{
					if (*sz == TEXT('\0'))
						goto LFailureReturn;
					sz = CharNext(sz);
					}
				sz = CharNext(sz);
				if (*sz == TEXT('\0') || *sz == TEXT('\\'))
					goto LFailureReturn;
				}
			else if (*sz == TEXT(':'))
				goto LFailureReturn;
			}

		LPTSTR szFName = szNull;
		// could use _tfullpath()
		DWORD  dwRet   = GetFullPathName(szTempFolder, MAX_PATH, szBuf, &szFName);
		if (0 == dwRet)
			goto LFailureReturn;
		if (!FEmptySz(szFName))
			goto LGotFolderPath;
		}

	UINT uiRet;
	uiRet = GetTempPath(MAX_PATH, szBuf);
	Assert(uiRet > 0);
	Assert(uiRet < MAX_PATH);
	
	LPTSTR szLast;
	szLast = SzLastChar(szBuf);
	Assert(szLast != szNull);
	if (*szLast != TEXT('\\'))
		lstrcat(szLast, TEXT("\\"));

	if (!FEnsureFolderExists(szBuf))
		goto LUseWinDir;

	if (!GetTempFileName(szBuf, TEXT("SPH"), 0, rgchPath))
		goto LUseWinDir;
	Assert(lstrlen(rgchPath) < MAX_PATH);
	if (!FFileExist(rgchPath))
		goto LUseWinDir;
	DeleteFile(rgchPath);
	if (FFileExist(rgchPath))
		{
LUseWinDir:
		uiRet = GetWindowsDirectory(szBuf, MAX_PATH);
		Assert(uiRet > 0);
		Assert(uiRet < MAX_PATH);
		szLast = SzLastChar(szBuf);
		Assert(szLast != szNull);
		if (*szLast != TEXT('\\'))
			lstrcat(szLast, TEXT("\\"));
		Assert(FFolderExist(szBuf));
		}

	lstrcat(szBuf, TEXT("~PCW_TMP.TMP"));

LGotFolderPath:
	EvalAssert( FFixupPath(szBuf) );
	StringCchPrintf(rgchPath, sizeof(rgchPath)/sizeof(TCHAR), TEXT("Cannot delete file: '%s'."), szBuf);
	while (FFileExist(szBuf))
		{
		SetFileAttributes(szBuf, FILE_ATTRIBUTE_NORMAL);
		DeleteFile(szBuf);
		if (FFileExist(szBuf))
			{
			if (hwnd == hwndNull || IDRETRY != MessageBox(hwnd, rgchPath, szMsgBoxTitle, MB_RETRYCANCEL | MB_ICONEXCLAMATION))
				return (fFalse);
			}
		}

	lstrcat(szBuf, TEXT("\\"));
	*pszFName = szBuf + lstrlen(szBuf);

	if (FFolderExist(szBuf))
		{
		if (!fRemoveTempFolderIfPresent)
			{
			StringCchPrintf(rgchPath, sizeof(rgchPath)/sizeof(TCHAR), TEXT("PCW temp folder already exists: '%s'."), szBuf);
			goto LFailureReturn;
			}
		else if (!FDeleteTempFolder(szBuf))
			{
			StringCchPrintf(rgchPath, sizeof(rgchPath)/sizeof(TCHAR), TEXT("Cannot delete PCW temp folder: '%s'."), szBuf);
			goto LFailureReturn;
			}
		}

	StringCchPrintf(rgchPath, sizeof(rgchPath)/sizeof(TCHAR), TEXT("Cannot create folder: '%s'."), szBuf);
	while (!FEnsureFolderExists(szBuf))
		{
		if (hwnd == hwndNull || IDRETRY != MessageBox(hwnd, rgchPath, szMsgBoxTitle, MB_RETRYCANCEL | MB_ICONEXCLAMATION))
			return (fFalse);
		}

	return (fTrue);
}


/* ********************************************************************** */
BOOL FMatchPrefix ( LPTSTR sz, LPTSTR szPrefix )
{
	Assert(sz != szNull);
	Assert(!FEmptySz(szPrefix));

	while (*szPrefix != TEXT('\0'))
		{
		if (*szPrefix != *sz)
			return (fFalse);
		sz       = CharNext(sz);
		szPrefix = CharNext(szPrefix);
		}

	return (fTrue);
}


/* ********************************************************************** */
BOOL FFixupPath ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));

	TCHAR rgch[MAX_PATH];

	BOOL fRet = FFixupPathEx(sz, rgch);
	if (fRet)
		lstrcpy(sz, rgch);

	return (fRet);
}


/* ********************************************************************** */
BOOL FFixupPathEx ( LPTSTR szIn, LPTSTR szOut )
{
	Assert(!FEmptySz(szIn));
	Assert(szOut != szNull);

	return (NULL != _tfullpath(szOut, szIn, MAX_PATH));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\setup.exe\resource.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#ifndef _RESOURCE_H_39383913_1926_4E7F_9741_8F454BD9A99C_
#define _RESOURCE_H_39383913_1926_4E7F_9741_8F454BD9A99C_

#define IDS_APP_TITLE                  11
#define IDS_OUTOFMEM                   12
#define IDS_NOMSI                      13
#define IDS_CANCEL                     14
#define IDS_MISSING_RESOURCE           15
#define IDS_BANNER_TEXT                16
#define IDS_DEFAULT_PRODUCT            17
#define IDS_DOWNLOADING_PACKAGE        18
#define IDS_VALIDATING_SIGNATURE       19
#define IDS_REQUIRES_NEWER_VERSION     20
#define IDS_NO_WINTRUST                21
#define IDS_UNTRUSTED                  22
#define IDS_INVALID_PATH               23
#define IDS_USER_CANCELLED             24
#define IDS_INVALID_VER_STR            25
#define IDS_REQUIRES_ADMIN_PRIV        26
#define IDS_DOWNLOADING_INSTMSI        27
#define IDS_NOINSTMSI                  28
#define IDS_FAILED_TO_UPGRADE_MSI      29
#define IDS_REBOOT_REQUIRED            30
#define IDS_INCORRECT_INSTMSI          31
#define IDS_INSTALL_ERROR              32
#define IDS_ALLOW_MSI_UPDATE           33
#define IDS_INVALID_OPERATION          34
#define IDS_USAGE                      35

#define IDI_INSTALLER                  99

#define IDC_DOWNLOAD_ICON             101
#define IDC_DOWNLOAD_CANCEL           102
#define IDC_DOWNLOAD_BANNER           103
#define IDC_DOWNLOAD_PROGRESSBAR      104
#define IDC_DOWNLOAD_ACTIONTEXT       105

#define IDD_PROGRESS                 1101

#endif //_RESOURCE_H_39383913_1926_4E7F_9741_8F454BD9A99C_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\setup.exe\setupui.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       setupui.cpp
//
//  Implementation of CDownloadUI class
//--------------------------------------------------------------------------

#define WIN // scope W32 API
#define COMCTL32 // scope COMCTRL32

#include "resource.h"
#include "setupui.h"
#include <commctrl.h>

//{B506A5D1-9716-4F35-8ED5-9ECB0E9A55F8}
const GUID IID_IDownloadBindStatusCallback = {0xB506A5D1L,0x9716,0x4F35,{0x8E,0xD5,0x9E,0xCB,0x0E,0x9A,0x55,0xF8}};
//{00000000-9716-4F35-8ED5-9ECB0E9A55F8}
const GUID IID_IUnknown = {0x00000000L,0x9716,0x4F35,{0x8E,0xD5,0x9E,0xCB,0x0E,0x9A,0x55,0xF8}};


/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::CDownloadUI constructor
//

CDownloadUI::CDownloadUI() : m_hwndProgress(0), m_hwndParent(0), m_hInst(0),
                            m_fInitialized(false), m_fUserCancel(false),
                            m_ulProgressMax(0), m_ulProgressSoFar(0)
{
    lstrcpy(m_szCaption, "");
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::~CDownloadUI destructor
//

CDownloadUI::~CDownloadUI()
{
}

/////////////////////////////////////////////////////////////////////////////
// ProgressProc - callback routine for IDD_PROGRESS dialog
//

BOOL CALLBACK ProgressProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    if (uiMsg == WM_INITDIALOG)
    {
        return TRUE;
    }
    else if (uiMsg == WM_COMMAND && wParam == IDCANCEL)
    {
        ((CDownloadUI*)lParam)->SetUserCancel();
        return TRUE;
    }
    else if (uiMsg == WM_SETCURSOR)
    {
        // always display WAIT cursor if mouse not over Cancel button
        if ( (HWND)wParam != WIN::GetDlgItem(hDlg, IDC_DOWNLOAD_CANCEL))
        {
            WIN::SetCursor(WIN::LoadCursor(0, MAKEINTRESOURCE(IDC_WAIT)));
            return TRUE;
        }
    }
    else if (uiMsg == WM_CLOSE)
    {

    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// GetScreenCenterCoord
//

bool GetScreenCenterCoord(HWND hDlg, int& iDialogLeft, int& iDialogTop, int& iDialogWidth, int& iDialogHeight)
{
    RECT rcDialog;
    if (!WIN::GetWindowRect(hDlg, &rcDialog))
        return false;

    RECT rcScreen;
    if (!WIN::SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, 0))
    {
        rcScreen.left = 0;
        rcScreen.top = 0;
        rcScreen.right = WIN::GetSystemMetrics(SM_CXSCREEN);
        rcScreen.bottom = WIN::GetSystemMetrics(SM_CYSCREEN);
    }
    iDialogWidth = rcDialog.right - rcDialog.left;
    iDialogHeight = rcDialog.bottom - rcDialog.top;
    iDialogLeft = rcScreen.left + (rcScreen.right - rcScreen.left - iDialogWidth)/2;
    iDialogTop = rcScreen.top + (rcScreen.bottom - rcScreen.top - iDialogHeight)/2;

    return true;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::Initialize
//

bool CDownloadUI::Initialize(HINSTANCE hInst, HWND hwndParent, LPCSTR szCaption)
{
    INITCOMMONCONTROLSEX iccData = {sizeof(INITCOMMONCONTROLSEX), ICC_PROGRESS_CLASS};
    COMCTL32::InitCommonControlsEx(&iccData);

    char szText[MAX_STR_CAPTION] = {0};

    // set member variables
    m_hwndParent = hwndParent;
    m_hInst = hInst;

    if (MAX_STR_CAPTION < lstrlen(szCaption))
    {
        lstrcpyn(m_szCaption, szCaption, MAX_STR_CAPTION);
    }
    else
    {
        lstrcpy(m_szCaption, szCaption);
    }

    if (!m_hwndProgress)
    {
        // create Progress Dialog
        m_hwndProgress = WIN::CreateDialogParam(m_hInst, MAKEINTRESOURCE(IDD_PROGRESS), m_hwndParent, ProgressProc, (LPARAM)this);
        if (!m_hwndProgress)
            return false;

        // set window caption
        WIN::SetWindowText(m_hwndProgress, m_szCaption);

        // center dialog on screen
        int iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight;
        ::GetScreenCenterCoord(m_hwndProgress, iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight);
        WIN::MoveWindow(m_hwndProgress, iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight, TRUE);

        // set CANCEL button text
        WIN::LoadString(m_hInst, IDS_CANCEL, szText, MAX_STR_CAPTION);
        WIN::SetDlgItemText(m_hwndProgress, IDC_DOWNLOAD_CANCEL, szText);

        // set to foreground and make visible all controls
        WIN::SetFocus(WIN::GetDlgItem(m_hwndProgress, IDC_DOWNLOAD_PROGRESSBAR));
        WIN::ShowWindow(WIN::GetDlgItem(m_hwndProgress, IDC_DOWNLOAD_CANCEL), SW_SHOW);
        WIN::SetForegroundWindow(m_hwndProgress);
        WIN::ShowWindow(WIN::GetDlgItem(m_hwndProgress, IDC_DOWNLOAD_PROGRESSBAR), SW_SHOW);

        // set icon
        HICON hIcon = (HICON) WIN::LoadIcon(m_hInst, MAKEINTRESOURCE(IDI_INSTALLER));
        if (hIcon)
            WIN::SendMessage(m_hwndProgress, WM_SETICON, ICON_BIG, (LPARAM)hIcon);

        // make window visible
        WIN::ShowWindow(m_hwndProgress, SW_SHOW);
    }

    // message pump
    MSG msg;
    while (WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
    {
        if (!WIN::IsDialogMessage(m_hwndProgress, &msg))
        {
            WIN::TranslateMessage(&msg);
            WIN::DispatchMessage(&msg);
        }
    }

    m_fInitialized = true;

    return true;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::Terminate
//

bool CDownloadUI::Terminate()
{
    if (m_hwndProgress)
    {
        // destroy the progress window
        WIN::DestroyWindow(m_hwndProgress);
        m_hwndProgress = 0;
    }

    m_hInst                 = 0;
    m_hwndParent            = 0;
    m_fInitialized          = false;
    m_fUserCancel           = false;
    m_ulProgressMax         = 0;
    m_ulProgressSoFar       = 0;

    return true;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::GetCurrentWindow
//

HWND CDownloadUI::GetCurrentWindow()
{
    return (m_hwndProgress) ? m_hwndProgress : m_hwndParent;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::SetUserCancel
//

void CDownloadUI::SetUserCancel()
{
    m_fUserCancel = true;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::HasUserCanceled
//

bool CDownloadUI::HasUserCanceled()
{
    return (m_fUserCancel);
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::SetBannerText
//

irmProgress CDownloadUI::SetBannerText(LPCSTR szBanner)
{
    if (!m_fInitialized)
        return irmNotInitialized;

    if (m_fUserCancel)
        return irmCancel;

    WIN::SetDlgItemText(m_hwndProgress, IDC_DOWNLOAD_BANNER, szBanner);

    return irmOK;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::SetActionText
//

irmProgress CDownloadUI::SetActionText(LPCSTR szAction)
{
    if (!m_fInitialized)
        return irmNotInitialized;

    if (m_fUserCancel)
        return irmCancel;

    WIN::SetDlgItemText(m_hwndProgress, IDC_DOWNLOAD_ACTIONTEXT, szAction);

    return irmOK;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::InitProgressBar
//

void CDownloadUI::InitProgressBar(ULONG ulProgressMax)
{
    // init progress bar values
    m_ulProgressMax         = ulProgressMax;
    m_ulProgressSoFar       = 0;

    // set range on progress bar of [0, ulProgressMax]
    HWND hwndProgBar = WIN::GetDlgItem(m_hwndProgress, IDC_DOWNLOAD_PROGRESSBAR);
    WIN::SendMessage(hwndProgBar, PBM_SETRANGE32, /* WPARAM = */ 0, /* LPARAM = */ m_ulProgressMax);

    // initialize the position of the progress bar -- forward direction, so set at 0
    WIN::SendMessage(hwndProgBar, PBM_SETPOS, /* WPARAM = */ (WPARAM)0, /* LPARAM = */ 0);

    // message pump
    MSG msg;
    while (WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
    {
        if (!WIN::IsDialogMessage(m_hwndProgress, &msg))
        {
            WIN::TranslateMessage(&msg);
            WIN::DispatchMessage(&msg);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::IncrementProgressBar
//

void CDownloadUI::IncrementProgressBar(ULONG ulProgress)
{
    // increment progress bar

    HWND hwndProgBar = WIN::GetDlgItem(m_hwndProgress, IDC_DOWNLOAD_PROGRESSBAR);
    WIN::SendMessage(hwndProgBar, PBM_DELTAPOS, /* WPARAM = */ (WPARAM) (ulProgress), /* LPARAM = */ 0);

    m_ulProgressSoFar += ulProgress;

    // message pump
    MSG msg;
    while (WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
    {
        if (!WIN::IsDialogMessage(m_hwndProgress, &msg))
        {
            WIN::TranslateMessage(&msg);
            WIN::DispatchMessage(&msg);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadBindStatusCallback::CDownloadBindStatusCallback constructor
//

CDownloadBindStatusCallback::CDownloadBindStatusCallback(CDownloadUI* pDownloadUI) : m_pDownloadUI(pDownloadUI), m_iRefCnt(1), m_ulProgressSoFar(0)
{
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadBindStatusCallback::~CDownloadBindStatusCallback destructor
//

CDownloadBindStatusCallback::~CDownloadBindStatusCallback()
{
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadBindStatusCallback::QueryInterface
//

HRESULT CDownloadBindStatusCallback::QueryInterface(const IID& riid, void** ppvObj)
{
    if (!ppvObj)
        return E_INVALIDARG;

    if (riid == IID_IUnknown || riid == IID_IDownloadBindStatusCallback)
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    *ppvObj = 0;
    return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadBindStatusCallback::AddRef
//

unsigned long CDownloadBindStatusCallback::AddRef()
{
    return ++m_iRefCnt;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadBindStatusCallback::Release
//

unsigned long CDownloadBindStatusCallback::Release()
{
    if (--m_iRefCnt != 0)
        return m_iRefCnt;
    delete this;
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadBindStatusCallback::OnProgress
//

HRESULT CDownloadBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR /*szStatusText*/)
{
    switch (ulStatusCode)
    {
    case BINDSTATUS_BEGINDOWNLOADDATA:
        {
            // initialize progress bar with max # of ticks
            m_pDownloadUI->InitProgressBar(ulProgressMax);

            // init progress so far
            m_ulProgressSoFar = 0;

            // check for cancel
            if (m_pDownloadUI->HasUserCanceled())
                return E_ABORT;

            // fall through
        }
    case BINDSTATUS_DOWNLOADINGDATA:
        {
            // calculate how far we have moved since the last time
            ULONG ulProgIncrement = ulProgress - m_ulProgressSoFar;

            // set progress so far to current value
            m_ulProgressSoFar = ulProgress;

            // send progress message (if we have progressed)
            if (ulProgIncrement > 0)
                m_pDownloadUI->IncrementProgressBar(ulProgIncrement);

            // check for cancel
            if(m_pDownloadUI->HasUserCanceled())
                return E_ABORT;

            break;
        }
    case BINDSTATUS_ENDDOWNLOADDATA:
        {
            // send any remaining progress to complete download portion of progress bar
            ULONG ulProgIncrement = ulProgressMax - m_ulProgressSoFar;
            if (ulProgIncrement > 0)
                m_pDownloadUI->IncrementProgressBar(ulProgIncrement);
            
            // check for cancel
            if(m_pDownloadUI->HasUserCanceled())
                return E_ABORT;

            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\setup.exe\setup.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       setup.h
//
//--------------------------------------------------------------------------

#ifndef __SETUP_H_58FA8147_50A0_4FDC_BD83_17C3A2525E0A_
#define __SETUP_H_58FA8147_50A0_4FDC_BD83_17C3A2525E0A_

#include "setupui.h"

#include <windows.h>
#include <wincrypt.h>

/*--------------------------------------------------------------------------
 *
 * Constants
 *
 --------------------------------------------------------------------------*/
#define MAX_STR_LENGTH 1024
#define MINIMUM_SUPPORTED_MSI_VERSION 150
#define MAX_LENGTH_GUID 40

const char szUrlPathSep[] = "/";
const char szPathSep[] = "\\";

const char szDefaultOperation[] = "DEFAULT";
const char szInstallOperation[] = "INSTALL";
const char szMinPatchOperation[] = "MINPATCH";
const char szMajPatchOperation[] = "MAJPATCH";
const char szInstallUpdOperation[] = "INSTALLUPD";

const char szDefaultMinPatchCommandLine[] = "REINSTALL=ALL REINSTALLMODE=omus";
const char szDefaultInstallUpdCommandLine[] = "REINSTALL=ALL REINSTALLMODE=vomus";
const char szAdminInstallProperty[] = " ACTION=ADMIN";

const char sqlProductCode[] = "SELECT `Value` FROM `Property` WHERE `Property`='ProductCode'";

/*--------------------------------------------------------------------------
 *
 * Enums
 *
 --------------------------------------------------------------------------*/
enum itvEnum
{
    itvWintrustNotOnMachine = 0,
    itvTrusted = 1,
    itvUnTrusted = 2
};

// Execution modes.
enum emEnum
{
    emPreset = 0,
    emHelp = 1,
    emVerify = 2,
    emAdminInstall = 3
};

/*--------------------------------------------------------------------------
 *
 * Prototypes
 *
 --------------------------------------------------------------------------*/

DWORD VerifyFileSignature (LPCSTR lpszModule, LPSTR lpszCmdLine);
emEnum GetExecutionMode (LPCSTR lpszCmdLine);
DWORD GetNextArgument (LPCSTR pszCmdLine, LPCSTR *ppszArgStart, LPCSTR *ppszArgEnd, bool * pfQuoted);
DWORD GetAdminInstallInfo (bool fPatch, LPSTR lpszCmdLine, LPCSTR * ppszAdminImagePath);
bool AlreadyInProgress(bool fWin9X, int iMajorVersion);
void DisplayUsage (HINSTANCE hInst, HWND hwndOwner, LPCSTR szCaption);
DWORD GetFileVersionNumber(LPSTR szFilename, DWORD *pdwMSVer, DWORD *pdwLSVer);
bool IsOSWin9X(int *piMajVer);
bool IsAdmin(bool fWin9X, int iMajorVersion);
bool IsTerminalServerInstalled(bool fWin9X, int iMajorVersion);
bool AcquireShutdownPrivilege();

/////////////////////////////////////////////////////////////////////////////
//
// WinVerifyTrust functions
//
/////////////////////////////////////////////////////////////////////////////
itvEnum IsPackageTrusted(LPCSTR szSetupEXE, LPCSTR szPackage, HWND hwndParent);
itvEnum IsFileTrusted(LPCWSTR szwFile, HWND hwndParent, DWORD dwUIChoice, bool *pfIsSigned, PCCERT_CONTEXT *ppcSigner);

/////////////////////////////////////////////////////////////////////////////
//
// InstMsi upgrade functions
//
/////////////////////////////////////////////////////////////////////////////
bool IsMsiUpgradeNecessary(ULONG ulReqMsiMinVer);
DWORD ExecuteUpgradeMsi(LPSTR szUpgradeMsi);
DWORD ExecuteVerifyInstMsi(LPCSTR szModuleFile, LPCSTR szInstMsiCachePath);
DWORD WaitForProcess(HANDLE handle);
bool IsInstMsiRequiredVersion(LPSTR szFilename, ULONG ulMinVer);
UINT UpgradeMsi(HINSTANCE hInst, CDownloadUI *piDownloadUI, LPCSTR szAppTitle, LPCSTR szInstLocation, LPCSTR szInstMsi, ULONG ulMinVer);
UINT DownloadAndUpgradeMsi(HINSTANCE hInst, CDownloadUI *piDownloadUI, LPCSTR szAppTitle, LPCSTR szBaseInstMsi, LPCSTR szInstMsi, LPCSTR szModuleFile, ULONG ulMinVer);
UINT ValidateInstmsi(HINSTANCE hInst, CDownloadUI *piDownloadUI, LPCSTR szAppTitle, LPSTR szInstMsiPath, LPCSTR szModuleFile, ULONG ulMinVer);

/////////////////////////////////////////////////////////////////////////////
//
// Error handling functions
//
/////////////////////////////////////////////////////////////////////////////
void ReportErrorOutOfMemory(HINSTANCE hInst, HWND hwndOwner, LPCSTR szCaption);
void PostResourceNotFoundError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, LPCSTR szName);
void ReportUserCancelled(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle);
void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId);
void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, int iValue);
void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, LPCSTR szValue);
void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, LPCSTR szValue, int iValue);
void PostMsiError(HINSTANCE hInst, HINSTANCE hMsi, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId);
void PostFormattedError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, LPCSTR szValue);

/////////////////////////////////////////////////////////////////////////////
//
// Msi DLL registration location -- HKLM
//
//  HKLM\Software\Microsoft\Windows\CurrentVersion\Installer
//      InstallerLocation : REG_SZ
//
/////////////////////////////////////////////////////////////////////////////
const char szInstallerKey[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Installer";
const char szInstallerLocationValueName[] = "InstallerLocation";
const char szMsiDll[] = "\\msi.dll";

/////////////////////////////////////////////////////////////////////////////
//
// InstMsi command line options
//
//
/////////////////////////////////////////////////////////////////////////////
const char szDelayReboot[] = " /c:\"msiinst /delayreboot\"";
const char szDelayRebootQuiet[] = " /c:\"msiinst /delayrebootq\"";


/////////////////////////////////////////////////////////////////////////////
//
// Debugging Functions
//
//
/////////////////////////////////////////////////////////////////////////////
void DebugMsg(LPCSTR szFormat, ...);
const char szDebugEnvVar[] = "_MSI_WEB_BOOTSTRAP_DEBUG";


#endif //__SETUP_H_58FA8147_50A0_4FDC_BD83_17C3A2525E0A_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\setup.exe\setupui.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       setupui.h
//
//--------------------------------------------------------------------------

#ifndef _SETUPUI_H_3E24CC91_BC41_4182_BEBA_785BBB28B677_
#define _SETUPUI_H_3E24CC91_BC41_4182_BEBA_785BBB28B677_

#include <windows.h>
#include <urlmon.h>

/*---------------------------------------------------------------------------
 *
 * Constants
 *
 ---------------------------------------------------------------------------*/
#define MAX_STR_CAPTION 256

/*---------------------------------------------------------------------------
 *
 * Enums
 *
 ---------------------------------------------------------------------------*/
enum irmProgress // progress dialog return messages
{
    irmNotInitialized = -1, // dialog was not initialized
    irmOK             =  0, // ok
    irmCancel         =  1, // user depressed cancel button
};

/*---------------------------------------------------------------------------
 *
 * CDownloadUI class
 *
 ---------------------------------------------------------------------------*/
class CDownloadUI
{
public:
     CDownloadUI();
     ~CDownloadUI();

    bool Initialize(HINSTANCE hInst, HWND hwndParent, LPCSTR szCaption);
    bool Terminate();
    HWND GetCurrentWindow();
    bool HasUserCanceled();
    void SetUserCancel();
    void InitProgressBar(ULONG ulProgressMax);
    void IncrementProgressBar(ULONG ulProgress);

    irmProgress SetBannerText(LPCSTR szBanner);
    irmProgress SetActionText(LPCSTR szAction);

private:
    HINSTANCE m_hInst;  // handle to instance containing resources

    HWND  m_hwndProgress;    // handle to progress dialog
    HWND  m_hwndParent;      // handle to parent window
    char  m_szCaption[MAX_STR_CAPTION]; // caption
    bool  m_fInitialized;    // whether dialog has been initialized
    bool  m_fUserCancel;     // whether user has chosen to cancel
    ULONG m_ulProgressMax;   // maximum number of ticks on progress bar
    ULONG m_ulProgressSoFar; // current progress
};

/*---------------------------------------------------------------------------
 *
 * CDownloadBindStatusCallback class
 *
 ---------------------------------------------------------------------------*/

class CDownloadBindStatusCallback : public IBindStatusCallback
{
 public: // IUnknown implemented virtual functions
     HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
     unsigned long   __stdcall AddRef();
     unsigned long   __stdcall Release();
 public: // IBindStatusCallback implemented virtual functions
     CDownloadBindStatusCallback(CDownloadUI* piDownloadUI);
    ~CDownloadBindStatusCallback();

    HRESULT __stdcall OnStartBinding(DWORD, IBinding*) {return S_OK;}
    HRESULT __stdcall GetPriority(LONG*) {return S_OK;}
    HRESULT __stdcall OnLowResource(DWORD ) {return S_OK;}
    HRESULT __stdcall OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText);
    HRESULT __stdcall OnStopBinding(HRESULT, LPCWSTR ) {return S_OK;}
    HRESULT __stdcall GetBindInfo(DWORD*, BINDINFO*) {return S_OK;}
    HRESULT __stdcall OnDataAvailable(DWORD, DWORD, FORMATETC*, STGMEDIUM*) {return S_OK;}
    HRESULT __stdcall OnObjectAvailable(REFIID, IUnknown*) {return S_OK;}
 private:
    CDownloadUI* m_pDownloadUI; // pointer to actual UI
    int          m_iRefCnt;
    ULONG        m_ulProgressSoFar;
};

#endif //_SETUPUI_H_3E24CC91_BC41_4182_BEBA_785BBB28B677_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\setup.exe\sources.inc ===
TARGETNAME=Setup
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=windows
UMENTRY=$(MSI_WINENTRY)

USE_LIBCMT=1

TARGETLIBS=\
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\wininet.lib \
	$(SDK_LIB_PATH)\urlmon.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\comctl32.lib \
	$(SDK_LIB_PATH)\version.lib \
	$(SDK_LIB_PATH)\advapi32.lib


C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(INC_DIR);$(RES_OBJDIR);$(INCLUDES)

SOURCES=\
	..\setup.cpp \
	..\vertrust.cpp \
	..\setupui.cpp \
	..\utils.cpp \
	..\setup.rc \
	..\upgrdmsi.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\setup.exe\setup.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       setup.cpp
//
//--------------------------------------------------------------------------

#define WIN // scope W32 API
#define MSI // scope MSI API

#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include <strsafe.h>

// internet download
#include "wininet.h"  // DeleteUrlCacheEntry, InternetCanonicalizeUrl
#include "urlmon.h"   // URLDownloadToCacheFile

// package trust
#include "wintrust.h"
#include "softpub.h"

// msi installation
#include "msidefs.h"
#include "msiquery.h"
#include "msi.h"

// setup.exe
#include "common.h"
#include "setup.h"
#include "setupui.h"
#include "resource.h"

//--------------------------------------------------------------------------------------
// MSI API -- delay load
//--------------------------------------------------------------------------------------

#define MSI_DLL "msi.dll"

#define MSIAPI_MsiSetInternalUI "MsiSetInternalUI"
typedef INSTALLUILEVEL (WINAPI* PFnMsiSetInternalUI)(INSTALLUILEVEL dwUILevel, HWND *phWnd);

#define MSIAPI_MsiInstallProduct "MsiInstallProductA"
typedef UINT (WINAPI* PFnMsiInstallProduct)(LPCSTR szPackagePath, LPCSTR szCommandLine);

#define MSIAPI_MsiApplyPatch "MsiApplyPatchA"
typedef UINT (WINAPI* PFnMsiApplyPatch)(LPCSTR szPatchPackage, LPCSTR szInstallPackage, INSTALLTYPE eInstallType, LPCSTR szCommandLine);

#define MSIAPI_MsiReinstallProduct "MsiReinstallProductA"
typedef UINT (WINAPI* PFnMsiReinstallProduct)(LPCSTR szProduct, DWORD dwReinstallMode);

#define MSIAPI_MsiQueryProductState "MsiQueryProductStateA"
typedef INSTALLSTATE (WINAPI* PFnMsiQueryProductState)(LPCSTR szProduct);

#define MSIAPI_MsiOpenDatabase "MsiOpenDatabaseA"
typedef UINT (WINAPI* PFnMsiOpenDatabase)(LPCSTR szDatabasePath, LPCSTR szPersist, MSIHANDLE *phDatabase);

#define MSIAPI_MsiDatabaseOpenView "MsiDatabaseOpenViewA"
typedef UINT (WINAPI* PFnMsiDatabaseOpenView)(MSIHANDLE hDatabase, LPCSTR szQuery, MSIHANDLE *phView);

#define MSIAPI_MsiViewExecute "MsiViewExecute"
typedef UINT (WINAPI* PFnMsiViewExecute)(MSIHANDLE hView, MSIHANDLE hRecord);

#define MSIAPI_MsiViewFetch "MsiViewFetch"
typedef UINT (WINAPI* PFnMsiViewFetch)(MSIHANDLE hView, MSIHANDLE *phRecord);

#define MSIAPI_MsiRecordGetString "MsiRecordGetStringA"
typedef UINT (WINAPI* PFnMsiRecordGetString)(MSIHANDLE hRecord, unsigned int uiField, LPSTR szValue, DWORD *pcchValueBuf);

#define MSIAPI_MsiCloseHandle "MsiCloseHandle"
typedef UINT (WINAPI* PFnMsiCloseHandle)(MSIHANDLE h);

const DWORD lcidLOCALE_INVARIANT = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);

/////////////////////////////////////////////////////////////////////////////
// WinMain -- Application Entry Point
//

extern "C" int __stdcall WinMain(HINSTANCE hInst, HINSTANCE hPrevInst , LPSTR lpszCmdLine, int nCmdShow)
{

//-----------------------------------------------------------------------------------------------------------------
//  VARIABLES
//
//-----------------------------------------------------------------------------------------------------------------
    UINT    uiRet = ERROR_SUCCESS;
    HRESULT hr    = S_OK;

    char *szMsiFile          = 0;
    char *szBaseURL          = 0;
    char *szInstallPath      = 0;
    char *szMsiCacheFile     = 0;
    char *szOperation        = 0;
    char *szProductName      = 0;
    char *szMinimumMsi       = 0;
    char *szProperties       = 0;
    char *szInstProperties   = 0;
    char *szTempPath         = 0;
    char *szFilePart         = 0;
    char *szBaseInstMsi      = 0;
    char *szInstMsi          = 0;

    char *szRegisteredMsiFolder = 0;
    char *szMsiDllLocation      = 0;

    char szAppTitle[MAX_STR_CAPTION]    = {0};
    char szError[MAX_STR_LENGTH]        = {0};
    char szText[MAX_STR_CAPTION]        = {0};
    char szBanner[MAX_STR_LENGTH]       = {0};
    char szAction[MAX_STR_LENGTH]       = {0};
    char szUserPrompt[MAX_STR_LENGTH]   = {0};
    char szProductCode[MAX_LENGTH_GUID] = {0};

    char szModuleFile[MAX_PATH]         = {0};
    DWORD dwModuleFileSize       = MAX_PATH;
    
    DWORD dwMsiFileSize          = 0;
    DWORD dwBaseURLSize          = 0;
    DWORD cchInstallPath         = 0;
    DWORD dwMsiCacheFileSize     = 0;
    DWORD dwOperationSize        = 0;
    DWORD dwProductNameSize      = 0;
    DWORD dwMinimumMsiSize       = 0;
    DWORD dwPropertiesSize       = 0;
    DWORD cchInstProperties      = 0;
    DWORD cchTempPath            = 0;
    DWORD dwLastError            = 0;
    DWORD cchReturn              = 0;
    DWORD dwBaseInstMsiSize      = 0;
    DWORD dwInstMsiSize          = 0;
    DWORD dwResult               = 0;
    DWORD dwType                 = 0;
    DWORD dwProductCodeSize      = MAX_LENGTH_GUID;

    DWORD dwRegisteredMsiFolderSize  = 0;
    DWORD dwMsiDllLocationSize       = 0;

    ULONG ulMsiMinVer        = 0;
    char *szStopScan         = NULL;

    int         iMajorVersion      = 0;
    bool        fUpgradeMsi        = false;
    bool        fWin9X             = false;
    bool        fAdmin             = false;
    bool        fDelayRebootReq    = false;
    bool        fPatch             = false;
    bool        fQFE               = false;
    emEnum      emExecMode         = emPreset;

    HKEY hInstallerKey = 0;

    HMODULE hMsi = 0;
    PFnMsiSetInternalUI pfnMsiSetInternalUI = 0;
    PFnMsiInstallProduct pfnMsiInstallProduct = 0;
    PFnMsiApplyPatch pfnMsiApplyPatch = 0;
    PFnMsiReinstallProduct pfnMsiReinstallProduct = 0;
    PFnMsiQueryProductState pfnMsiQueryProductState = 0;
    PFnMsiOpenDatabase pfnMsiOpenDatabase = 0;
    PFnMsiDatabaseOpenView pfnMsiDatabaseOpenView = 0;
    PFnMsiViewExecute pfnMsiViewExecute = 0;
    PFnMsiViewFetch pfnMsiViewFetch = 0;
    PFnMsiRecordGetString pfnMsiRecordGetString = 0;
    PFnMsiCloseHandle pfnMsiCloseHandle = 0;

    MSIHANDLE hDatabase = 0;
    MSIHANDLE hView = 0;
    MSIHANDLE hRec = 0;

    INSTALLSTATE isProduct = INSTALLSTATE_UNKNOWN;
    
    const char * szAdminImagePath = 0;



//-----------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------
    // create our UI object
    CDownloadUI DownloadUI;

    // Load our AppTitle (caption)
    WIN::LoadString(hInst, IDS_APP_TITLE, szAppTitle, sizeof(szAppTitle)/sizeof(char));

    // Obtain path we are running from
    if (0 == WIN::GetModuleFileName(hInst, szModuleFile, dwModuleFileSize))
    {
        // No UI displayed. Silent failure.
        uiRet = GetLastError();
        goto CleanUp;
    }
    DebugMsg("[Info] we are running from --> %s\n", szModuleFile);

    // Figure out what we want to do
    emExecMode = GetExecutionMode (lpszCmdLine);
    
    if (emVerify == emExecMode)
    {
        //
        // We don't want any UI to be displayed in this case. The return value
        // from the exe is the result of the verification. Therefore, this
        // should be done before initializing the UI.
        //
        uiRet = VerifyFileSignature (szModuleFile, lpszCmdLine);
        if (ERROR_BAD_ARGUMENTS != uiRet)
            goto CleanUp;
    }
    
    if (ERROR_BAD_ARGUMENTS == uiRet || emHelp == emExecMode)
    {
        DisplayUsage(hInst, NULL, szAppTitle);
        goto CleanUp;
    }
    
    //
    // NOTE:
    // Delay handling admin. installs until we have determined if we are
    // patching an existing install or if we are doing a default install.
    //
 
    // initialize our UI object with desktop as parent
    DownloadUI.Initialize(hInst, /* hwndParent = */ 0, szAppTitle);

    // other initializations
    fWin9X = IsOSWin9X(&iMajorVersion);
    fAdmin = IsAdmin(fWin9X, iMajorVersion);

    // only run one instance at a time
    if (AlreadyInProgress(fWin9X, iMajorVersion))
    {
        // silently return - correct return code ?
        return ERROR_INSTALL_ALREADY_RUNNING;
    }

    DebugMsg("[Info] fWin9X = %s, fAdmin = %s\n", fWin9X ? "TRUE" : "FALSE", fAdmin ? "TRUE" : "FALSE");

    // determine operation, default (if not present) is INSTALL
    if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_OPERATION, &szOperation, dwOperationSize)))
    {
        ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        goto CleanUp;
    }
    if (ERROR_SUCCESS != uiRet)
    {
        // set operation to default which is install
        if (!szOperation)
        {
            szOperation = new char[lstrlen(szDefaultOperation) + 1];
            if (!szOperation)
            {
                ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                goto CleanUp;
            }
        }
        if (lstrlen(szOperation) <= lstrlen(szDefaultOperation))
        {
            delete [] szOperation;
            szOperation = new char[lstrlen(szDefaultOperation) + 1];
            if (!szOperation)
            {
                ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                goto CleanUp;
            }
        }
        lstrcpy(szOperation, szDefaultOperation);
    }

    // obtain name of product
    if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_PRODUCTNAME, &szProductName, dwProductNameSize)))
    {
        ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        goto CleanUp;
    }
    if (ERROR_SUCCESS != uiRet)
    {
        // use default
        WIN::LoadString(hInst, IDS_DEFAULT_PRODUCT, szProductName, MAX_STR_CAPTION);
    }

    // set banner text
    WIN::LoadString(hInst, IDS_BANNER_TEXT, szText, MAX_STR_CAPTION);
    StringCchPrintf(szBanner, sizeof(szBanner), szText, szProductName);
    if (irmCancel == DownloadUI.SetBannerText(szBanner))
    {
        ReportUserCancelled(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_INSTALL_USEREXIT;
        goto CleanUp;
    }

    // Determine if this is a patch or a normal install.
    if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_DATABASE, &szMsiFile, dwMsiFileSize)))
    {
        ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        goto CleanUp;
    }
    else if (ERROR_SUCCESS != uiRet)
    {
        // look for patch
        if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_PATCH, &szMsiFile, dwMsiFileSize)))
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            goto CleanUp;
        }
        else if (ERROR_SUCCESS != uiRet)
        {
            PostResourceNotFoundError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, ISETUPPROPNAME_DATABASE);
            goto CleanUp;
        }

        fPatch = true;
    }
    
    //
    // If we are here, this is either an admin. install or a default install.
    // File signature verification, help and other invalid parameters have
    // already been taken care of above.
    //
    if (emAdminInstall == emExecMode)
    {
        uiRet = GetAdminInstallInfo (fPatch, lpszCmdLine, &szAdminImagePath);
        if (ERROR_BAD_ARGUMENTS == uiRet)
        {
            DisplayUsage(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            goto CleanUp;
        }
    }
    
    //
    // At this point, the validation of the commandline arguments is complete
    // and we have all the information we need.
    //

    // obtain minimum required MSI version
    if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_MINIMUM_MSI, &szMinimumMsi, dwMinimumMsiSize)))
    {
        ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        goto CleanUp;
    }
    else if (ERROR_SUCCESS != uiRet)
    {
        PostResourceNotFoundError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, ISETUPPROPNAME_MINIMUM_MSI);
        goto CleanUp;
    }

    // make sure required Msi version is a valid value -- must be >= 150
    ulMsiMinVer = strtoul(szMinimumMsi, &szStopScan, 10);
    if (!szStopScan || (szStopScan == szMinimumMsi) || (*szStopScan != 0) || ulMsiMinVer < MINIMUM_SUPPORTED_MSI_VERSION)
    {
        // invalid minimum version string
        PostError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_INVALID_VER_STR, szMinimumMsi, MINIMUM_SUPPORTED_MSI_VERSION);
        uiRet = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    DebugMsg("[Resource] Minimum Msi Value = %d\n", ulMsiMinVer);

    // compare minimum required MSI version to that which is on the machine
    if ((fUpgradeMsi = IsMsiUpgradeNecessary(ulMsiMinVer)))
    {
        DebugMsg("[Info] Upgrade of Windows Installer is requested\n");

        // make sure this is admin -- must have admin priviledges to upgrade Windows Installer
        if (!fAdmin)
        {
            PostError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_REQUIRES_ADMIN_PRIV);
            uiRet = ERROR_INSTALL_FAILURE;
            goto CleanUp;
        }

        // since instmsi hides the cancel button, ask the user if they want to upgrade the installer
        WIN::LoadString(hInst, IDS_ALLOW_MSI_UPDATE, szUserPrompt, MAX_STR_LENGTH);
        if (IDYES != WIN::MessageBox(DownloadUI.GetCurrentWindow(), szUserPrompt, szAppTitle, MB_YESNO|MB_ICONQUESTION))
        {
            // user decided to cancel
            ReportUserCancelled(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_INSTALL_USEREXIT;
            goto CleanUp;
        }

        if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, fWin9X ? ISETUPPROPNAME_INSTMSIA : ISETUPPROPNAME_INSTMSIW, &szInstMsi, dwInstMsiSize)))
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            goto CleanUp;
        }
        else if (ERROR_SUCCESS != uiRet)
        {
            PostResourceNotFoundError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, fWin9X ? ISETUPPROPNAME_INSTMSIA : ISETUPPROPNAME_INSTMSIW);
            goto CleanUp;
        }

        // determine if we need to download instmsi.exe from the web -- based on presence of INSTLOCATION property
        if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_INSTLOCATION, &szBaseInstMsi, dwBaseInstMsiSize)))
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            goto CleanUp;
        }
        else if (ERROR_SUCCESS == uiRet)
        {
            // presence of INSTLOCATION property indicates assumption of URL source
            if (ERROR_SUCCESS != (uiRet = DownloadAndUpgradeMsi(hInst, &DownloadUI, szAppTitle, szBaseInstMsi, szInstMsi, szModuleFile, ulMsiMinVer)))
            {
                if (ERROR_SUCCESS_REBOOT_REQUIRED == uiRet)
                {
                    // successful, but must reboot at end
                    fDelayRebootReq = true;
                }
                else
                    goto CleanUp;
            }
        }
        else
        {
            // lack of INSTLOCATION property indicates assumption of Media source
            if (ERROR_SUCCESS != (uiRet = UpgradeMsi(hInst, &DownloadUI, szAppTitle, szModuleFile, szInstMsi, ulMsiMinVer)))
            {
                if (ERROR_SUCCESS_REBOOT_REQUIRED == uiRet)
                {
                    // successful, but must reboot at end
                    fDelayRebootReq = true;
                }
                else
                    goto CleanUp;
            }
        }
    }

    DebugMsg("[Info] Windows Installer has been upgraded, or was already correct version\n");

    // perform some extra authoring validation
    if (fPatch
        && CSTR_EQUAL != CompareString(lcidLOCALE_INVARIANT, NORM_IGNORECASE, szOperation, -1, szMinPatchOperation, -1)
        && CSTR_EQUAL != CompareString(lcidLOCALE_INVARIANT, NORM_IGNORECASE, szOperation, -1, szMajPatchOperation, -1)
        && CSTR_EQUAL != CompareString(lcidLOCALE_INVARIANT, NORM_IGNORECASE, szOperation, -1, szDefaultOperation, -1))
    {
        // wrong operation
        DebugMsg("[Error] Operation %s is not valid for a patch\n", szOperation);
        PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_INVALID_OPERATION, szOperation);
        uiRet = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }
    else if (!fPatch
        && CSTR_EQUAL != CompareString(lcidLOCALE_INVARIANT, NORM_IGNORECASE, szOperation, -1, szInstallOperation, -1)
        && CSTR_EQUAL != CompareString(lcidLOCALE_INVARIANT, NORM_IGNORECASE, szOperation, -1, szInstallUpdOperation, -1)
        && CSTR_EQUAL != CompareString(lcidLOCALE_INVARIANT, NORM_IGNORECASE, szOperation, -1, szDefaultOperation, -1))
    {
        // wrong operation
        DebugMsg("[Error] Operation %s is not valid for a package\n", szOperation);
        PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_INVALID_OPERATION, szOperation);
        uiRet = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    // by now we either have a MSI or a MSP
    if (CSTR_EQUAL == CompareString(lcidLOCALE_INVARIANT, NORM_IGNORECASE, szOperation, -1, szMinPatchOperation, -1)
        || CSTR_EQUAL == CompareString(lcidLOCALE_INVARIANT, NORM_IGNORECASE, szOperation, -1, szInstallUpdOperation, -1)
        || (fPatch && CSTR_EQUAL == CompareString(lcidLOCALE_INVARIANT, NORM_IGNORECASE, szOperation, -1, szDefaultOperation, -1)))
        fQFE = true;

    // obtain base URL
    if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_BASEURL, &szBaseURL, dwBaseURLSize)))
    {
        ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        goto CleanUp;
    }
    else if (ERROR_SUCCESS == uiRet)
    {
        // presence of BASEURL property indicates assumption of URL source . . .

        // generate the path to the installation package == baseURL + msiFile
        //   note: msiFile is a relative path
        cchTempPath = lstrlen(szBaseURL) + lstrlen(szMsiFile) + 2; // 1 for slash, 1 for null
        szTempPath = new char[cchTempPath ];
        if (!szTempPath)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }
        lstrcpy(szTempPath, szBaseURL);
        // check for trailing slash on szBaseURL
        char *pch = szBaseURL + lstrlen(szBaseURL) + 1; // put at null terminator
        pch = CharPrev(szBaseURL, pch);
        if (*pch != '/')
            lstrcat(szTempPath, szUrlPathSep);
        lstrcat(szTempPath, szMsiFile);

        // canocialize the URL path
        cchInstallPath = cchTempPath*2;
        szInstallPath = new char[cchInstallPath];
        if (!szInstallPath)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }

        dwLastError = 0; // success
        if (!InternetCanonicalizeUrl(szTempPath, szInstallPath, &cchInstallPath, 0))
        {
            dwLastError = GetLastError();
            if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
            {
                // try again
                delete [] szInstallPath;
                szInstallPath = new char[cchInstallPath];
                if (!szInstallPath)
                {
                    ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                    uiRet = ERROR_OUTOFMEMORY;
                    goto CleanUp;
                }
                dwLastError = 0; // reset to success for 2nd attempt
                if (!InternetCanonicalizeUrl(szTempPath, szInstallPath, &cchInstallPath, 0))
                    dwLastError = GetLastError();
            }
        }
        if (0 != dwLastError)
        {
            // error -- invalid path/Url
            PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
            uiRet = dwLastError;
            goto CleanUp;
        }

        // set action text for download
        WIN::LoadString(hInst, IDS_DOWNLOADING_PACKAGE, szText, MAX_STR_CAPTION);
        StringCchPrintf(szAction, sizeof(szAction), szText, szMsiFile);
        if (irmCancel == DownloadUI.SetActionText(szAction))
        {
            ReportUserCancelled(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_INSTALL_USEREXIT;
            goto CleanUp;
        }

        // download the msi file so we can attempt a trust check -- must be local for WinVerifyTrust
        DebugMsg("[Info] Downloading msi file %s for WinVerifyTrust check\n", szInstallPath);

        szMsiCacheFile = new char[MAX_PATH];
        dwMsiCacheFileSize = MAX_PATH;
        if (!szMsiCacheFile)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }

        hr = WIN::URLDownloadToCacheFile(NULL, szInstallPath, szMsiCacheFile, dwMsiCacheFileSize, 0, /* IBindStatusCallback = */ &CDownloadBindStatusCallback(&DownloadUI));
        if (DownloadUI.HasUserCanceled())
        {
            ReportUserCancelled(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_INSTALL_USEREXIT;
            goto CleanUp;
        }
        if (FAILED(hr))
        {
            // error during download -- probably because file not found (or lost connection)
            PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_NOMSI, szInstallPath);
            uiRet = ERROR_FILE_NOT_FOUND;
            goto CleanUp;
        }

        DebugMsg("[Info] Msi file was cached to %s\n", szMsiCacheFile);

        // set action text for trust verification
        WIN::LoadString(hInst, IDS_VALIDATING_SIGNATURE, szText, MAX_STR_CAPTION);
        StringCchPrintf(szAction, sizeof(szAction), szText, szMsiFile);
        if (irmCancel == DownloadUI.SetActionText(szAction))
        {
            ReportUserCancelled(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_INSTALL_USEREXIT;
            goto CleanUp;
        }

        // perform trust check 
        itvEnum itv = IsPackageTrusted(szModuleFile, szMsiCacheFile, DownloadUI.GetCurrentWindow());
        if (itvWintrustNotOnMachine == itv)
        {
            PostError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_NO_WINTRUST);
            uiRet = ERROR_CALL_NOT_IMPLEMENTED;
            goto CleanUp;
        }
        else if (itvUnTrusted == itv)
        {
            PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_UNTRUSTED, szInstallPath);
            uiRet = HRESULT_CODE(TRUST_E_SUBJECT_NOT_TRUSTED);
            goto CleanUp;
        }
    }
    else
    {
        // lack of BASEURL property indicates assumption of Media source

        // generate the path to the Msi file =  szModuleFile + msiFile
        //   note: msiFile is a relative path
        cchTempPath = lstrlen(szModuleFile) + lstrlen(szMsiFile) + 2; // 1 for null terminator, 1 for back slash
        szTempPath = new char[cchTempPath];
        if (!szTempPath)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }

        // find 'setup.exe' in the path so we can remove it
        if (0 == GetFullPathName(szModuleFile, cchTempPath, szTempPath, &szFilePart))
        {
            uiRet = GetLastError();
            PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
            goto CleanUp;
        }
        if (szFilePart)
            *szFilePart = '\0';

        lstrcat(szTempPath, szMsiFile);

        cchInstallPath = 2*cchTempPath;
        szInstallPath = new char[cchInstallPath];
        if (!szInstallPath)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }

        // normalize the path
        cchReturn = GetFullPathName(szTempPath, cchInstallPath, szInstallPath, &szFilePart);
        if (cchReturn > cchInstallPath)
        {
            // try again, with larger buffer
            delete [] szInstallPath;
            cchInstallPath = cchReturn;
            szInstallPath = new char[cchInstallPath];
            if (!szInstallPath)
            {
                ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                uiRet = ERROR_OUTOFMEMORY;
                goto CleanUp;
            }
            cchReturn = GetFullPathName(szTempPath, cchInstallPath, szInstallPath, &szFilePart);
        }
        if (0 == cchReturn)
        {
            // error -- invalid path
            PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
            uiRet = dwLastError;
            goto CleanUp;
        }

        // no download is necessary -- but we can check for the file's existence
        DWORD dwFileAttrib = GetFileAttributes(szInstallPath);
        if (0xFFFFFFFF == dwFileAttrib)
        {
            // package is missing
            PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_NOMSI, szInstallPath);
            uiRet = ERROR_FILE_NOT_FOUND;
            goto CleanUp;
        }
    }

    //
    // good to go -- terminate our UI and let the Windows Installer take over
    //

    // retrieve the optional command line PROPERTY = VALUE strings if available
    if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_PROPERTIES, &szProperties, dwPropertiesSize)))
    {
        ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_OUTOFMEMORY;
        goto CleanUp;
    }
    else if (ERROR_SUCCESS != uiRet)
    {
        // PROPERTY=VALUE pairs not specified
        if (szProperties)
            delete [] szProperties;
        szProperties = NULL;
    }

    DownloadUI.Terminate();

    //
    // perform install -- use registered location of msi.dll so that we can make use of the "delay-reboot"
    //                     upgrade Msi feature
    //


    // find registered location of Msi.dll
    if (ERROR_SUCCESS == (uiRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szInstallerKey, 0, KEY_READ, &hInstallerKey)))
    {
        szRegisteredMsiFolder = new char[MAX_PATH];
        dwRegisteredMsiFolderSize = MAX_PATH;
        if (!szRegisteredMsiFolder)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }

        if (ERROR_MORE_DATA == (uiRet = RegQueryValueEx(hInstallerKey, szInstallerLocationValueName, NULL, &dwType, (BYTE*)szRegisteredMsiFolder, &dwRegisteredMsiFolderSize)))
        {
            // try again with larger buffer
            delete [] szRegisteredMsiFolder;
            szRegisteredMsiFolder = new char[dwRegisteredMsiFolderSize];
            if (!szRegisteredMsiFolder)
            {
                ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                uiRet = ERROR_OUTOFMEMORY;
                goto CleanUp;
            }
            uiRet = RegQueryValueEx(hInstallerKey, szInstallerLocationValueName, NULL, &dwType, (BYTE*)szRegisteredMsiFolder, &dwRegisteredMsiFolderSize);
        }

        if (ERROR_SUCCESS == uiRet && dwType == REG_SZ && dwRegisteredMsiFolderSize > 0)
        {
            // load Msi.dll from registered location
            dwMsiDllLocationSize = dwRegisteredMsiFolderSize + lstrlen(szMsiDll) + 1;
            szMsiDllLocation = new char[dwMsiDllLocationSize];
            if (!szMsiDllLocation)
            {
                ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                uiRet = ERROR_OUTOFMEMORY;
                goto CleanUp;
            }
            lstrcpy(szMsiDllLocation, szRegisteredMsiFolder);
            lstrcat(szMsiDllLocation, szMsiDll);
            hMsi = LoadLibrary(szMsiDllLocation);
        }
        else
        {
            // load Msi.dll from default location
            hMsi = LoadLibrary(MSI_DLL);
        }
    }
    else
    {
        // use default location for loading Msi.dll
        hMsi = LoadLibrary(MSI_DLL);
    }

    if (hMsi)
    {
        pfnMsiSetInternalUI = (PFnMsiSetInternalUI)GetProcAddress(hMsi, MSIAPI_MsiSetInternalUI);
        pfnMsiInstallProduct = (PFnMsiInstallProduct)GetProcAddress(hMsi, MSIAPI_MsiInstallProduct);
        pfnMsiApplyPatch = (PFnMsiApplyPatch)GetProcAddress(hMsi, MSIAPI_MsiApplyPatch);
        pfnMsiReinstallProduct = (PFnMsiReinstallProduct)GetProcAddress(hMsi, MSIAPI_MsiReinstallProduct);
        pfnMsiQueryProductState = (PFnMsiQueryProductState)GetProcAddress(hMsi, MSIAPI_MsiQueryProductState);
        pfnMsiOpenDatabase = (PFnMsiOpenDatabase)GetProcAddress(hMsi, MSIAPI_MsiOpenDatabase);
        pfnMsiDatabaseOpenView = (PFnMsiDatabaseOpenView)GetProcAddress(hMsi, MSIAPI_MsiDatabaseOpenView);
        pfnMsiViewExecute = (PFnMsiViewExecute)GetProcAddress(hMsi, MSIAPI_MsiViewExecute);
        pfnMsiViewFetch = (PFnMsiViewFetch)GetProcAddress(hMsi, MSIAPI_MsiViewFetch);
        pfnMsiRecordGetString = (PFnMsiRecordGetString)GetProcAddress(hMsi, MSIAPI_MsiRecordGetString);
        pfnMsiCloseHandle = (PFnMsiCloseHandle)GetProcAddress(hMsi, MSIAPI_MsiCloseHandle);
    }
    if (!hMsi || !pfnMsiSetInternalUI || !pfnMsiInstallProduct || !pfnMsiApplyPatch || !pfnMsiReinstallProduct || !pfnMsiQueryProductState
        || !pfnMsiDatabaseOpenView || !pfnMsiViewExecute || !pfnMsiViewFetch || !pfnMsiRecordGetString || !pfnMsiCloseHandle)
    {
        PostError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_FAILED_TO_UPGRADE_MSI);
        uiRet = ERROR_INSTALL_FAILURE;
        goto CleanUp;
    }

    DebugMsg("[Info] Setting Internal UI level to FULL...\n");
    pfnMsiSetInternalUI(INSTALLUILEVEL_FULL, 0);

    if (!fPatch)
    {
        // performing install or reinstall/recache
        DebugMsg("[Info] Calling MsiInstallProduct with szInstallPath = %s", szInstallPath); 
        DebugMsg(" and szCommandLine = %s\n", szProperties ? szProperties : "{null}");

        // default operation for a package is INSTALL

        if (fQFE)
        {
            // check to see if this product is already installed
            if (ERROR_SUCCESS == pfnMsiOpenDatabase(szMsiCacheFile ? szMsiCacheFile : szInstallPath, MSIDBOPEN_READONLY, &hDatabase)
                && ERROR_SUCCESS == pfnMsiDatabaseOpenView(hDatabase, sqlProductCode, &hView)
                && ERROR_SUCCESS == pfnMsiViewExecute(hView, 0)
                && ERROR_SUCCESS == pfnMsiViewFetch(hView, &hRec)
                && ERROR_SUCCESS == pfnMsiRecordGetString(hRec, 1, szProductCode, &dwProductCodeSize))
            {
                isProduct = pfnMsiQueryProductState(szProductCode);
                DebugMsg("[Info] MsiQueryProductState returned %d\n", isProduct);
                if (INSTALLSTATE_ADVERTISED != isProduct && INSTALLSTATE_DEFAULT != isProduct)
                {
                    // product is unknown, so this will be a first time install
                    DebugMsg("[Info] The product code '%s' is unknown. Will use first time install logic...\n", szProductCode);
                    fQFE = false;
                }
                else
                {
                    // product is known, use QFE syntax
                    DebugMsg("[Info] The product code '%s' is known. Will use QFE recache and reinstall upgrade logic...\n", szProductCode);
                }
            }
            else
            {
                // some failure occurred when processing the product code, so treat as non-QFE
                DebugMsg("[Info] Unable to process product code. Will treat as first time install...\n");
                fQFE = false;
            }
            if (hDatabase)
                pfnMsiCloseHandle(hDatabase);
            if (hView)
                pfnMsiCloseHandle(hView);
            if (hRec)
                pfnMsiCloseHandle(hRec);
        }
        
        //
        // Set up the properties to be passed into MSIInstallProduct
        //
        if (fQFE && !szProperties)
            cchInstProperties = lstrlen (szDefaultInstallUpdCommandLine);
        else if (szProperties)
            cchInstProperties = lstrlen (szProperties);
        if (emAdminInstall == emExecMode)
            cchInstProperties += lstrlen (szAdminInstallProperty);
        
        szInstProperties = new char[cchInstProperties + 1];
        if (! szInstProperties)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }
        
        if (fQFE && !szProperties)
            lstrcpy (szInstProperties, szDefaultInstallUpdCommandLine);
        else if (szProperties)
            lstrcpy (szInstProperties, szProperties);
        else
            szInstProperties[0] = '\0';
        if (emAdminInstall == emExecMode)
            lstrcat (szInstProperties, szAdminInstallProperty);

        uiRet = pfnMsiInstallProduct(szInstallPath, szInstProperties);
        if (ERROR_SUCCESS != uiRet)
        {
            // attempt to display an error message stored in msi.dll
            PostMsiError(hInst, hMsi, DownloadUI.GetCurrentWindow(), szAppTitle, uiRet);
        }

        DebugMsg("[Info] MsiInstallProduct returned %d\n", uiRet);
    }
    else
    {
        // default Operation for a patch is MINPATCH

        // if szProperties is NULL, use our default value for QFE patches
        if (!szProperties && fQFE)
        {
            DebugMsg("[Info] Patch is a MINPATCH (small or minor update patch) so using default command line '%s'\n", szDefaultMinPatchCommandLine);

            szProperties = new char[lstrlen(szDefaultMinPatchCommandLine) + 1];
            if (!szProperties)
            {
                ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                uiRet = ERROR_OUTOFMEMORY;
                goto CleanUp;
            }
            lstrcpy(szProperties, szDefaultMinPatchCommandLine);
        }

        if (emAdminInstall == emExecMode)
        {
			// performing a patch
			DebugMsg("[Info] Calling MsiApplyPatch with szPatchPackage = %s", szMsiCacheFile);
			DebugMsg(" and szInstallPackage = %s and eInstallType = INSTALLTYPE_NETWORK_IMAGE", szAdminImagePath);
			DebugMsg(" and szCommandLine = %s\n", szProperties ? szProperties : "{null}");

            uiRet = pfnMsiApplyPatch(szMsiCacheFile, szAdminImagePath, INSTALLTYPE_NETWORK_IMAGE, szProperties);
        }
        else
        {
			// performing a patch
			DebugMsg("[Info] Calling MsiApplyPatch with szPatchPackage = %s", szInstallPath);
			DebugMsg(" and szInstallPackage = {null} and eInstallType = INSTALLTYPE_DEFAULT");
			DebugMsg(" and szCommandLine = %s\n", szProperties ? szProperties : "{null}");

            uiRet = pfnMsiApplyPatch(szInstallPath, NULL, INSTALLTYPE_DEFAULT, szProperties);
        }
        if (ERROR_SUCCESS != uiRet)
        {
            // attempt to display an error message stored in msi.dll
            PostMsiError(hInst, hMsi, DownloadUI.GetCurrentWindow(), szAppTitle, uiRet);
        }

        DebugMsg("[Info] MsiApplyPatch returned %d\n", uiRet);
    }

    if (fDelayRebootReq)
    {
        // need to reboot machine for instmsi changes
        WIN::LoadString(hInst, IDS_REBOOT_REQUIRED, szAction, MAX_STR_LENGTH);
        if (IDYES == MessageBox(NULL, szAction, szAppTitle, MB_YESNO|MB_ICONQUESTION))
        {
            if (!fWin9X)
            {
                // must first aquire system shutdown privileges on NT/Win2K
                AcquireShutdownPrivilege();
				// initiate system shutdown for reboot
				WIN::ExitWindowsEx(EWX_REBOOT, PCLEANUI | SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_INSTALLATION);
            }
			else
				// initiate system shutdown for reboot
                 WIN::ExitWindowsEx(EWX_REBOOT, 0);
        }
    }

CleanUp:

    if (szMsiFile)
        delete [] szMsiFile;
    if (szBaseURL)
        delete [] szBaseURL;
    if (szInstallPath)
        delete [] szInstallPath;
    if (szMsiCacheFile)
    {
        WIN::DeleteUrlCacheEntry(szMsiCacheFile);
        delete [] szMsiCacheFile;
    }
    if (szProductName)
        delete [] szProductName;
    if (szMinimumMsi)
        delete [] szMinimumMsi;
    if (szProperties)
        delete [] szProperties;
    if (szTempPath)
        delete [] szTempPath;
    if (szBaseInstMsi)
        delete [] szBaseInstMsi;
    if (szInstMsi)
        delete [] szInstMsi;
    if (szRegisteredMsiFolder)
        delete [] szRegisteredMsiFolder;
    if (szMsiDllLocation)
        delete [] szMsiDllLocation;

    if (hMsi)
        FreeLibrary(hMsi);

    DebugMsg("[Info] Setup exit code is %d\n", uiRet);

    return uiRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\setup.exe\upgrdmsi.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       upgrdmsi.cpp
//
//--------------------------------------------------------------------------

#include "setup.h"
#include "resource.h"

// internet download
#include "wininet.h"  // DeleteUrlCacheEntry, InternetCanonicalizeUrl
#include "urlmon.h"   // URLDownloadToCacheFile

#include "wintrust.h" // WTD_UI_NONE
#include <assert.h>
#include <stdlib.h>
#include "strsafe.h"

#define WIN // scope W32 API

#define MSISIPAPI_DllRegisterServer "DllRegisterServer"
typedef HRESULT (WINAPI* PFnMsiSIPDllRegisterServer)();
/////////////////////////////////////////////////////////////////////////////
// IsMsiUpgradeNecessary
//

bool IsMsiUpgradeNecessary(ULONG ulReqMsiMinVer)
{
    // attempt to load msi.dll in the system directory

    char szSysMsiDll[MAX_PATH] = {0};
    char szSystemFolder[MAX_PATH] = {0};

    DWORD dwRet = WIN::GetSystemDirectory(szSystemFolder, MAX_PATH);
    if (0 == dwRet || MAX_PATH < dwRet)
    {
        // failure or buffer too small; assume upgrade is necessary
        DebugMsg("[Info] Can't obtain system directory; assuming upgrade is necessary");
        return true;
    }

    if (FAILED(StringCchCopy(szSysMsiDll, sizeof(szSysMsiDll)/sizeof(szSysMsiDll[0]), szSystemFolder))
        || FAILED(StringCchCat(szSysMsiDll, sizeof(szSysMsiDll)/sizeof(szSysMsiDll[0]), "\\MSI.DLL")))
    {
        // failure to get path to msi.dll; assume upgrade is necessary
        DebugMsg("[Info] Can't obtain msi.dll path; assuming upgrade is necessary");
        return true;
    }

    HINSTANCE hinstMsiSys = LoadLibrary(szSysMsiDll);
    if (0 == hinstMsiSys)
    {
        // can't load msi.dll; assume upgrade is necessary
        DebugMsg("[Info] Can't load msi.dll; assuming upgrade is necessary");

        return true;
    }
    FreeLibrary(hinstMsiSys);

    // get version on msi.dll
    DWORD dwInstalledMSVer;
    dwRet = GetFileVersionNumber(szSysMsiDll, &dwInstalledMSVer, NULL);
    if (ERROR_SUCCESS != dwRet)
    {
        // can't obtain version information; assume upgrade is necessary
        DebugMsg("[Info] Can't obtain version information; assuming upgrade is necessary");

        return true;
    }

    // compare version in system to the required minimum
    ULONG ulInstalledVer = HIWORD(dwInstalledMSVer) * 100 + LOWORD(dwInstalledMSVer);
    if (ulInstalledVer < ulReqMsiMinVer)
    {
        // upgrade is necessary
        DebugMsg("[Info] Windows Installer upgrade is required.  System Version = %d, Minimum Version = %d.\n", ulInstalledVer, ulReqMsiMinVer);

        return true;
    }

    // no upgrade is necessary
    DebugMsg("[Info] No upgrade is necessary.  System version meets minimum requirements\n");
    return false;
}

/////////////////////////////////////////////////////////////////////////////
// UpgradeMsi
//

UINT UpgradeMsi(HINSTANCE hInst, CDownloadUI *piDownloadUI, LPCSTR szAppTitle, LPCSTR szInstLocation, LPCSTR szInstMsi, ULONG ulMinVer)
{
    char *szTempPath    = 0;
    char *szInstMsiPath = 0;
    char *szFilePart    = 0;

    DWORD cchTempPath    = 0;
    DWORD cchInstMsiPath = 0;
    DWORD cchReturn      = 0;
    DWORD dwLastError    = 0;
    DWORD dwFileAttrib   = 0;
    UINT  uiRet          = 0;

    HRESULT hr           = S_OK;

    // generate the path to the InstMsi file =  szInstLocation + szInstMsi
    //   note: szInstMsi is a relative path

    cchTempPath = lstrlen(szInstLocation) + lstrlen(szInstMsi) + 2; // 1 for null terminator, 1 for back slash
    szTempPath = new char[cchTempPath];
    if (!szTempPath)
    {
        ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_OUTOFMEMORY;
        goto CleanUp;
    }
    memset((void*)szTempPath, 0x00, cchTempPath*sizeof(char));

    // find 'setup.exe' in the path so we can remove it -- this is an already expanded path, that represents
    //  our current running location.  It includes our executable name -- we want to find that and get rid of it
    if (0 == GetFullPathName(szInstLocation, cchTempPath, szTempPath, &szFilePart))
    {
        uiRet = GetLastError();
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
        goto CleanUp;
    }
    if (szFilePart)
        *szFilePart = '\0';

    hr = StringCchCat(szTempPath, cchTempPath, szInstMsi);
    if (FAILED(hr))
    {
        uiRet = HRESULT_CODE(hr);
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
        goto CleanUp;
    }

    cchInstMsiPath = 2*cchTempPath;
    szInstMsiPath = new char[cchInstMsiPath];
    if (!szInstMsiPath)
    {
        ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_OUTOFMEMORY;
        goto CleanUp;
    }

    // normalize the path
    cchReturn = GetFullPathName(szTempPath, cchInstMsiPath, szInstMsiPath, &szFilePart);
    if (cchReturn > cchInstMsiPath)
    {
        // try again, with larger buffer
        delete [] szInstMsiPath;
        cchInstMsiPath = cchReturn;
        szInstMsiPath = new char[cchInstMsiPath];
        if (!szInstMsiPath)
        {
            ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }
        cchReturn = GetFullPathName(szTempPath, cchInstMsiPath, szInstMsiPath, &szFilePart);
    }
    if (0 == cchReturn)
    {
        uiRet = GetLastError();
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
        goto CleanUp;
    }

    // no download is necessary -- but we can check for the file's existence
    dwFileAttrib = GetFileAttributes(szInstMsiPath);
    if (0xFFFFFFFF == dwFileAttrib)
    {
        // instmsi executable is missing
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_NOINSTMSI, szInstMsiPath);
        uiRet = ERROR_FILE_NOT_FOUND;
        goto CleanUp;
    }

    uiRet = ValidateInstmsi(hInst, piDownloadUI, szAppTitle, szInstMsiPath, szInstMsiPath, ulMinVer);

CleanUp:
    if (szTempPath)
        delete [] szTempPath;
    if (szInstMsiPath)
        delete [] szInstMsiPath;

    return uiRet;
}

/////////////////////////////////////////////////////////////////////////////
// DownloadAndUpgradeMsi
//

UINT DownloadAndUpgradeMsi(HINSTANCE hInst, CDownloadUI *piDownloadUI, LPCSTR szAppTitle, LPCSTR szBaseInstMsi, LPCSTR szInstMsi, LPCSTR szModuleFile, ULONG ulMinVer)
{
    char *szTempPath         = 0;
    char *szInstMsiPath      = 0;
    char *szInstMsiCacheFile = 0;
    const char *pch          = 0;

    DWORD cchTempPath         = 0;
    DWORD cchInstMsiPath      = 0;
    DWORD cchInstMsiCacheFile = 0;
    DWORD dwLastError         = 0;
    UINT  uiRet               = 0;
    HRESULT hr                = 0;
    DWORD Status              = ERROR_SUCCESS;

    char szDebugOutput[MAX_STR_LENGTH] = {0};
    char szText[MAX_STR_CAPTION]       = {0};

    // generate the path to the instmsi == INSTLOCATION + szInstMsi
    //   note: szInstMsi is a relative path
    cchTempPath = lstrlen(szBaseInstMsi) + lstrlen(szInstMsi) + 2; // 1 for slash, 1 for null
    szTempPath = new char[cchTempPath];
    if (!szTempPath)
    {
        ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_OUTOFMEMORY;
        goto CleanUp;
    }
    memset((void*)szTempPath, 0x0, cchTempPath*sizeof(char));
    hr = StringCchCopy(szTempPath, cchTempPath, szBaseInstMsi);
    if (FAILED(hr))
    {
        uiRet = HRESULT_CODE(hr);
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
        goto CleanUp;
    }

    // check for trailing slash on szBaseInstMsi
    pch = szBaseInstMsi + lstrlen(szBaseInstMsi) + 1; // put at null terminator
    pch = CharPrev(szBaseInstMsi, pch);
    if (*pch != '/')
    {
        hr = StringCchCat(szTempPath, cchTempPath, szUrlPathSep);
        if (FAILED(hr))
        {
            uiRet = HRESULT_CODE(hr);
            PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
            goto CleanUp;
        }
    }

    hr = StringCchCat(szTempPath, cchTempPath, szInstMsi);
    if (FAILED(hr))
    {
        uiRet = HRESULT_CODE(hr);
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
        goto CleanUp;
    }

    // canocialize the URL path
    cchInstMsiPath = cchTempPath*2;
    szInstMsiPath = new char[cchInstMsiPath];
    if (!szInstMsiPath)
    {
        ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_OUTOFMEMORY;
        goto CleanUp;
    }

    if (!InternetCanonicalizeUrl(szTempPath, szInstMsiPath, &cchInstMsiPath, 0))
    {
        dwLastError = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
        {
            // try again
            delete [] szInstMsiPath;
            szInstMsiPath = new char[cchInstMsiPath];
            if (!szInstMsiPath)
            {
                ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
                uiRet = ERROR_OUTOFMEMORY;
                goto CleanUp;
            }
            dwLastError = 0; // reset to success for 2nd attempt
            if (!InternetCanonicalizeUrl(szTempPath, szInstMsiPath, &cchInstMsiPath, 0))
                dwLastError = GetLastError();
        }
    }
    if (0 != dwLastError)
    {
        // error -- invalid path/Url
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
        uiRet = dwLastError;
        goto CleanUp;
    }

    DebugMsg("[Info] Downloading instmsi from --> %s\n", szInstMsiPath);

    // set action text for download
    WIN::LoadString(hInst, IDS_DOWNLOADING_INSTMSI, szText, MAX_STR_CAPTION);
    if (irmCancel == piDownloadUI->SetActionText(szText))
    {
        ReportUserCancelled(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_INSTALL_USEREXIT;
        goto CleanUp;
    }

    // download the instmsi file so we can run it -- must be local to execute
    szInstMsiCacheFile = new char[MAX_PATH];
    cchInstMsiCacheFile = MAX_PATH;
    if (!szInstMsiCacheFile)
    {
        ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_OUTOFMEMORY;
        goto CleanUp;
    }

    hr = WIN::URLDownloadToCacheFile(NULL, szInstMsiPath, szInstMsiCacheFile, cchInstMsiCacheFile, 0, /* IBindStatusCallback = */ &CDownloadBindStatusCallback(piDownloadUI));
    if (piDownloadUI->HasUserCanceled())
    {
        ReportUserCancelled(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_INSTALL_USEREXIT;
        goto CleanUp;
    }
    if (FAILED(hr))
    {
        // error during download -- probably because file not found (or lost connection)
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_NOINSTMSI, szInstMsiPath);
        uiRet = ERROR_FILE_NOT_FOUND;
        goto CleanUp;
    }


    //
    // Perform trust check on MSI. Note, this must be done in a separate process.
    // This is because MSI 2.0 and higher register sip callbacks for verifying
    // digital signatures on msi files. At this point, it is quite likely that
    // the SIP callbacks have not been registered. So we don't want to load
    // wintrust.dll into this process's image yet, otherwise it will remain unaware
    // of the sip callbacks registered by instmsi and will fail later when it tries
    // to verify the signature on the msi file downloaded from the web.
    //
    Status = ExecuteVerifyInstMsi(szModuleFile, szInstMsiCacheFile);
    if (TRUST_E_PROVIDER_UNKNOWN == Status)
    {
        PostError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_NO_WINTRUST);
        uiRet = ERROR_CALL_NOT_IMPLEMENTED;
        goto CleanUp;
    }
    else if (ERROR_SUCCESS != Status)
    {
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_UNTRUSTED, szInstMsiCacheFile);
        uiRet = HRESULT_CODE(TRUST_E_SUBJECT_NOT_TRUSTED);
        goto CleanUp;
    }

    // continue other validations
    uiRet = ValidateInstmsi(hInst, piDownloadUI, szAppTitle, szInstMsiCacheFile, szModuleFile, ulMinVer);

CleanUp:
    if (szTempPath)
        delete [] szTempPath;
    if (szInstMsiPath)
        delete [] szInstMsiPath;
    if (szInstMsiCacheFile)
    {
        WIN::DeleteUrlCacheEntry(szInstMsiCacheFile);
        delete [] szInstMsiCacheFile;
    }

    return uiRet;
}

/////////////////////////////////////////////////////////////////////////////
// IsInstMsiRequiredVersion
//
//  instmsi version is stamped as rmj+10.rmm.rup.rin
//

bool IsInstMsiRequiredVersion(LPSTR szFilename, ULONG ulMinVer)
{
    // get version on instmsi
    DWORD dwInstMsiMSVer;
    DWORD dwRet = GetFileVersionNumber(szFilename, &dwInstMsiMSVer, NULL);
    if (ERROR_SUCCESS != dwRet)
    {
        // can't obtain version information; assume not proper version
        DebugMsg("[Info] Can't obtain version information for instmsi; assuming it is not the proper version\n");
        return false;
    }

    // compare version at source to required minimum
    ULONG ulSourceVer = (HIWORD(dwInstMsiMSVer) - 10) * 100 + LOWORD(dwInstMsiMSVer);
    if (ulSourceVer < ulMinVer)
    {
        // source version won't get us to our minimum version
        char szDebugOutput[MAX_STR_LENGTH] = {0};
        DebugMsg("[Info] InstMsi is improper version for upgrade. InstMsi Version = %d, Minimum Version = %d.\n", ulSourceVer, ulMinVer);
        
        return false;
    }

    return true;
}

/////////////////////////////////////////////////////////////////////////////
// ValidateInstmsi
//

UINT ValidateInstmsi(HINSTANCE hInst, CDownloadUI *piDownloadUI, LPCSTR szAppTitle, LPSTR szInstMsiPath, LPCSTR szModuleFile, ULONG ulMinVer)
{
    UINT uiRet = ERROR_SUCCESS;

    char szShortPath[MAX_PATH]          = {0};

    // ensure instmsi is right version for Windows Installer upgrade
    if (!IsInstMsiRequiredVersion(szInstMsiPath, ulMinVer))
    {
        // instmsi won't get us the right upgrade
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_INCORRECT_INSTMSI, szInstMsiPath);
        return ERROR_INVALID_PARAMETER;
    }

    // upgrade msi
    uiRet = ExecuteUpgradeMsi(szInstMsiPath);
    switch (uiRet)
    {
    case ERROR_SUCCESS:
    case ERROR_SUCCESS_REBOOT_REQUIRED:
    case ERROR_SUCCESS_REBOOT_INITIATED:
//    case ERROR_INSTALL_REBOOT_NOW:
//    case ERROR_INSTALL_REBOOT:
        {
            // nothing required at this time
            break;
        }
    case ERROR_FILE_NOT_FOUND:
        {
            // instmsi executable not found
            PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_NOINSTMSI, szInstMsiPath);
            break;
        }
    case ERROR_INSTALL_USEREXIT:
        {
            // user cancelled the instmsi upgrade
            ReportUserCancelled(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
            break;
        }
    default: // failure
        {
            // report error
            PostError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_FAILED_TO_UPGRADE_MSI);
            break;
        }
    }
    return uiRet;
}

/////////////////////////////////////////////////////////////////////////////
// ExecuteUpgradeMsi
//

DWORD ExecuteUpgradeMsi(LPSTR szUpgradeMsi)
{
    DebugMsg("[Info] Running instmsi from --> %s\n", szUpgradeMsi);

    DWORD dwResult = 0;

    // build up CreateProcess structures
    STARTUPINFO          sui;
    PROCESS_INFORMATION  pi;

    memset((void*)&pi, 0x00, sizeof(PROCESS_INFORMATION));
    memset((void*)&sui, 0x00, sizeof(STARTUPINFO));
    sui.cb          = sizeof(STARTUPINFO);
    sui.dwFlags     = STARTF_USESHOWWINDOW;
    sui.wShowWindow = SW_SHOW;

    //
    // build command line and specify delayreboot option to instmsi
    //  three acounts for terminating null plus quotes for module
    DWORD cchCommandLine = lstrlen(szUpgradeMsi) + lstrlen(szDelayReboot) + 3;
    char *szCommandLine = new char[cchCommandLine];

    if (!szCommandLine)
        return ERROR_OUTOFMEMORY;
    
    if (FAILED(StringCchCopy(szCommandLine, cchCommandLine, "\""))
        || FAILED(StringCchCat(szCommandLine, cchCommandLine, szUpgradeMsi))
        || FAILED(StringCchCat(szCommandLine, cchCommandLine, "\""))
        || FAILED(StringCchCat(szCommandLine, cchCommandLine, szDelayReboot)))
    {
        delete [] szCommandLine;
        return ERROR_INSTALL_FAILURE;
    }

    //
    // run instmsi process
    if(!WIN::CreateProcess(NULL, szCommandLine, NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE, NULL, NULL, &sui, &pi))
    {
        // failed to launch.
        dwResult = GetLastError();
        delete [] szCommandLine;
        return dwResult;
    }

    dwResult = WaitForProcess(pi.hProcess);
    if(ERROR_SUCCESS != dwResult)
    {
        delete [] szCommandLine;
        return dwResult;
    }

    DWORD dwExitCode = 0;
    WIN::GetExitCodeProcess(pi.hProcess, &dwExitCode);

    WIN::CloseHandle(pi.hProcess);

    delete [] szCommandLine;

    return dwExitCode;
}

/////////////////////////////////////////////////////////////////////////////
// ExecuteVerifyInstMsi
//
DWORD ExecuteVerifyInstMsi(LPCSTR szModuleFile, LPCSTR szInstMsiCachePath)
{
    DWORD dwResult = 0;

    // build up CreateProcess structures
    STARTUPINFO          sui;
    PROCESS_INFORMATION  pi;

    memset((void*)&pi, 0x00, sizeof(PROCESS_INFORMATION));
    memset((void*)&sui, 0x00, sizeof(STARTUPINFO));
    sui.cb          = sizeof(STARTUPINFO);
    sui.dwFlags     = STARTF_USESHOWWINDOW;
    sui.wShowWindow = SW_SHOW;

    //
    // Build command line and specify delayreboot option to instmsi
    // The nine extra characters are required for the following:
    //      2 for the quotes enclosing the module path
    //      2 for /v
    //      2 for the spaces before and after /v
    //      2 for the quotes enclosing the instmsi path
    //      1 for the terminating null.
    //
    DWORD cchCommandLine = lstrlen(szModuleFile) + lstrlen(szInstMsiCachePath) + 9;
    char *szCommandLine = new char[cchCommandLine];

    if (!szCommandLine)
        return ERROR_OUTOFMEMORY;

    if (FAILED(StringCchCopy(szCommandLine, cchCommandLine, "\""))
        || FAILED(StringCchCat(szCommandLine, cchCommandLine, szModuleFile))
        || FAILED(StringCchCat(szCommandLine, cchCommandLine, "\""))
        || FAILED(StringCchCat(szCommandLine, cchCommandLine, " /v \""))
        || FAILED(StringCchCat(szCommandLine, cchCommandLine, szInstMsiCachePath))
        || FAILED(StringCchCat(szCommandLine, cchCommandLine, "\"")))
    {
        delete [] szCommandLine;
        return ERROR_INSTALL_FAILURE;
    }
    
    //
    // Run the verification process. We use a copy of ourselves to do this.
    //
    if(!WIN::CreateProcess(NULL, szCommandLine, NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE, NULL, NULL, &sui, &pi))
    {
        // failed to launch.
        delete [] szCommandLine;
        dwResult = GetLastError();
        return dwResult;
    }

    dwResult = WaitForProcess(pi.hProcess);
    if(ERROR_SUCCESS != dwResult)
    {
        delete [] szCommandLine;
        return dwResult;
    }

    DWORD dwExitCode = 0;
    WIN::GetExitCodeProcess(pi.hProcess, &dwExitCode);

    WIN::CloseHandle(pi.hProcess);

    DebugMsg("[Info] Verification of InstMsi returned %d\n", dwExitCode);

    delete [] szCommandLine;

    return dwExitCode;
}

/////////////////////////////////////////////////////////////////////////////
// WaitForProcess
//

DWORD WaitForProcess(HANDLE handle)
{
    DWORD dwResult = NOERROR;

    MSG msg;
    memset((void*)&msg, 0x00, sizeof(MSG));

    //loop forever to wait
    while (true)
    {
        //wait for object
        switch (WIN::MsgWaitForMultipleObjects(1, &handle, false, INFINITE, QS_ALLINPUT))
        {
        //success!
        case WAIT_OBJECT_0:
            goto Finish;

        //not the process that we're waiting for
        case (WAIT_OBJECT_0 + 1):
            {
                if (WIN::PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
                {
                    WIN::TranslateMessage(&msg);
                    WIN::DispatchMessage(&msg);
                }

                break;
            }
        //did not return an OK; return error status
        default:
            {
                dwResult = WIN::GetLastError();
                goto Finish;
            }
        }
    }

Finish:
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\setup.exe\utils.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       utils.cpp
//
//--------------------------------------------------------------------------

#include "setup.h"
#include "resource.h"
#include "common.h"

#include "msi.h"

#include <assert.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <strsafe.h>

#define WIN // scope W32 API

/////////////////////////////////////////////////////////////////////////////
// VerifyFileSignature
//
DWORD VerifyFileSignature (LPCSTR lpszModule, LPSTR lpszCmdLine)
{
    LPCSTR  pszFirstArgEnd;
    LPCSTR  pszFileName;
    LPCSTR  pszEnd;
    DWORD   Status;
    
    //
    // When this function is called, the first argument has already
    // been verified. So skip the first argument.
    //
    GetNextArgument (lpszCmdLine, NULL, &pszFirstArgEnd, NULL);
    
    // Now get the name of the file whose signature needs to be verified.
    Status = GetNextArgument (CharNextA(pszFirstArgEnd), &pszFileName, &pszEnd, NULL);
    
    // Must supply a filename
    if (ERROR_NO_MORE_ITEMS == Status)
        return ERROR_BAD_ARGUMENTS;
    
    // Should not have any more arguments
    if ('\0' != *(CharNextA(pszEnd)) &&
        ERROR_NO_MORE_ITEMS != GetNextArgument (CharNextA(CharNextA(pszEnd)), NULL, NULL, NULL))
    {
        return ERROR_BAD_ARGUMENTS;
    }
    
    // We have the right arguments. Null terminate the filename.
    *(CharNextA(pszEnd)) = '\0';
    
    switch (IsPackageTrusted(lpszModule, pszFileName, NULL))
    {
    case itvWintrustNotOnMachine:
        return TRUST_E_PROVIDER_UNKNOWN;
    case itvTrusted:
        return ERROR_SUCCESS;
    case itvUnTrusted:
    default:
        return TRUST_E_SUBJECT_NOT_TRUSTED;
    }
}

/////////////////////////////////////////////////////////////////////////////
// GetExecutionMode
//
emEnum GetExecutionMode (LPCSTR lpszCmdLine)
{
    LPCSTR  pszStart = NULL;
    LPCSTR  pszEnd = NULL;
    DWORD   dwStatus = ERROR_SUCCESS;
    bool    fQuoted = false;
    //
    // Check the first argument and set the execution mode accordingly.
    // When run without arguments, it is assumed that the default install
    // preset by the package publisher needs to be performed.
    //
    // In case an invalid option is provided, the help dialog describing the
    // usage must be displayed.
    //
    dwStatus = GetNextArgument (lpszCmdLine, &pszStart, &pszEnd, &fQuoted);
    
    if (ERROR_NO_MORE_ITEMS == dwStatus)
        return emPreset;
    
    // The only allowed values in the first argument are /a, /v and /?
    if (pszEnd != CharNextA(pszStart) || fQuoted)
        return emHelp;
    
    if ('/' != (*pszStart) && '-' != (*pszStart))
        return emHelp;
    
    switch (*pszEnd)
    {
    case 'a':
    case 'A':
        return emAdminInstall;
    case 'v':
    case 'V':
        return emVerify;
    default:
        return emHelp;
    }
}

/////////////////////////////////////////////////////////////////////////////
// GetNextArgument
//
DWORD GetNextArgument (LPCSTR pszCmdLine, LPCSTR *ppszArgStart, LPCSTR *ppszArgEnd, bool * pfQuoted)
{
    bool    fInQuotes = false;
    bool    fFoundArgEnd = false;
    LPCSTR  pszChar = pszCmdLine;
    LPCSTR  pszFirst = NULL;
    LPCSTR  pszLast = NULL;
    
    if (NULL == pszChar)
        return ERROR_NO_MORE_ITEMS;
    
    // Skip leading spaces.
    while (' ' == *pszChar || '\t' == *pszChar)
        pszChar = CharNextA(pszChar);
    
    // Check if we have run out of arguments.
    if ('\0' == (*pszChar))
        return ERROR_NO_MORE_ITEMS;
    
    // Check if we this argument has been enclosed in quotes
    if ('\"' == (*pszChar))
    {
        fInQuotes = true;
        pszChar = CharNextA (pszChar);
    }
        
    pszFirst = pszChar;
    
    // Now look for the end of the argument
    while (! fFoundArgEnd)
    {
        pszChar = CharNextA(pszChar);
        
        if ('\0' == (*pszChar))
            fFoundArgEnd = true;
        
        if (fInQuotes && '\"' == (*pszChar))
            fFoundArgEnd = true;
        
        if (!fInQuotes && ' ' == (*pszChar))
            fFoundArgEnd = true;
        
        if (!fInQuotes && '\t' == (*pszChar))
            fFoundArgEnd = true;
    }
    
    pszLast = CharPrevA (pszFirst, pszChar);
    
    if (ppszArgStart)
        *ppszArgStart = pszFirst;
    
    if (ppszArgEnd)
        *ppszArgEnd = pszLast;
    
    if (pfQuoted)
        *pfQuoted = fInQuotes;
    
    return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
//
//
DWORD GetAdminInstallInfo (bool fPatch, LPSTR lpszCmdLine, LPCSTR * ppszAdminImagePath)
{
    LPCSTR  pszFirstArgEnd;
    LPCSTR  pszFileName;
    LPCSTR  pszEnd;
    DWORD   Status;
    
    //
    // When this function is called, the first argument has already been
    // verified. So skip the first argument.
    //
    GetNextArgument (lpszCmdLine, NULL, &pszFirstArgEnd, NULL);
    
    // See if there is another argument
    Status = GetNextArgument (CharNextA(pszFirstArgEnd), &pszFileName, &pszEnd, NULL);
    
    // If it is not a patch, there should not be any more arguments.
    if (!fPatch)
    {
        if (ERROR_NO_MORE_ITEMS != Status)
            return ERROR_BAD_ARGUMENTS;
        
        // If we are here, then we are done, because we have all the information we need.
        if (ppszAdminImagePath)
            *ppszAdminImagePath = NULL;
        return ERROR_SUCCESS;
    }
    
    // If we are here, this is a patch. Get the path to the admin. install.
    if (ERROR_NO_MORE_ITEMS == Status)
        return ERROR_BAD_ARGUMENTS;     // No path was supplied.
    
    // Should not have any more arguments.
    if ('\0' != *(CharNextA(pszEnd)) &&
        ERROR_NO_MORE_ITEMS != GetNextArgument (CharNextA(CharNextA(pszEnd)), NULL, NULL, NULL))
    {
        return ERROR_BAD_ARGUMENTS;
    }
    
    // We have the right arguments. Null terminate the pathname.
    *(CharNextA(pszEnd)) = '\0';
    
    if (ppszAdminImagePath)
        *ppszAdminImagePath = pszFileName;
    
    return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// LoadResourceString
//
UINT LoadResourceString(HINSTANCE hInst, LPCSTR lpType, LPCSTR lpName, LPSTR lpBuf, DWORD *pdwBufSize)
{
    HRSRC   hRsrc   = 0;
    HGLOBAL hGlobal = 0;
    WCHAR   *pch    = 0;

    if ((hRsrc = WIN::FindResource(hInst, lpName, lpType)) != 0
        && (hGlobal = WIN::LoadResource(hInst, hRsrc)) != 0)
    {
        // resource exists
        if ((pch = (WCHAR*)LockResource(hGlobal)) != 0)
        {
            unsigned int cch = WideCharToMultiByte(CP_ACP, 0, pch, -1, NULL, 0, NULL, NULL);
            if (cch > *pdwBufSize)
            {
                *pdwBufSize = cch;
                return ERROR_MORE_DATA;
            }

            if (0 == WideCharToMultiByte(CP_ACP, 0, pch, -1, lpBuf, *pdwBufSize, NULL, NULL))
                return ERROR_FUNCTION_FAILED;
            *pdwBufSize = cch;

        }
        else
        {
            if (1 > *pdwBufSize)
            {
                *pdwBufSize = 1;
                return ERROR_MORE_DATA;
            }

            *pdwBufSize = 1;
            *lpBuf = 0;
        }
        
        DebugMsg("[Resource] lpName = %s, lpBuf = %s\n", lpName, lpBuf);

        return ERROR_SUCCESS;
    }

    // resource does not exist
    DebugMsg("[Resource] lpName = %s NOT FOUND\n", lpName);

    return ERROR_RESOURCE_NAME_NOT_FOUND;
}

/////////////////////////////////////////////////////////////////////////////
// SetupLoadResourceString
//

UINT SetupLoadResourceString(HINSTANCE hInst, LPCSTR lpName, LPSTR *lppBuf, DWORD dwBufSize)
{
    UINT uiStat = 0;
    if (!*lppBuf)
    {
        dwBufSize = (dwBufSize > 0) ? dwBufSize : 256;
        *lppBuf = new char[dwBufSize];
        if (!*lppBuf)
            return ERROR_OUTOFMEMORY;
    }

    if (ERROR_SUCCESS != (uiStat = LoadResourceString(hInst, RT_INSTALL_PROPERTY, lpName, *lppBuf, &dwBufSize)))
    {
        if (uiStat != ERROR_MORE_DATA)
            return uiStat;

        // resize and try again
        delete [] *lppBuf;
        *lppBuf = new char[dwBufSize];
        if (!*lppBuf)
            return ERROR_OUTOFMEMORY;

        uiStat = LoadResourceString(hInst, RT_INSTALL_PROPERTY, lpName, *lppBuf, &dwBufSize);
    }

    return uiStat;
}

/////////////////////////////////////////////////////////////////////////////
// PostResourceNotFoundError
//

void PostResourceNotFoundError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, LPCSTR szName)
{
    char szError[MAX_STR_LENGTH]  = {0};
    char szFormat[MAX_STR_LENGTH] = {0};

    WIN::LoadString(hInst, IDS_MISSING_RESOURCE, szFormat, sizeof(szFormat)/sizeof(char));
    StringCchPrintf(szError, sizeof(szError), szFormat, szName);
    MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONEXCLAMATION);
}

/////////////////////////////////////////////////////////////////////////////
// ReportUserCancelled
//

void ReportUserCancelled(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle)
{
    char szError[MAX_STR_LENGTH] = {0};

    WIN::LoadString(hInst, IDS_USER_CANCELLED, szError, sizeof(szError)/sizeof(char));
    MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONEXCLAMATION);
}

/////////////////////////////////////////////////////////////////////////////
// PostError
//

void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId)
{
    char szError[MAX_STR_LENGTH]  = {0};

    WIN::LoadString(hInst, uiErrorId, szError, sizeof(szError)/sizeof(char));
    MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONERROR);
}

/////////////////////////////////////////////////////////////////////////////
// PostError
//

void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, LPCSTR szValue)
{
    char szError[MAX_STR_LENGTH]  = {0};
    char szFormat[MAX_STR_LENGTH] = {0};

    WIN::LoadString(hInst, uiErrorId, szFormat, sizeof(szFormat)/sizeof(char));
    StringCchPrintf(szError, sizeof(szError), szFormat, szValue);
    MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONERROR);
}

/////////////////////////////////////////////////////////////////////////////
// PostError
//

void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, LPCSTR szValue, int iValue)
{
    char szError[MAX_STR_LENGTH]  = {0};
    char szFormat[MAX_STR_LENGTH] = {0};

    WIN::LoadString(hInst, uiErrorId, szFormat, sizeof(szFormat)/sizeof(char));
    StringCchPrintf(szError, sizeof(szError), szFormat, szValue, iValue);
    MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONERROR);
}

/////////////////////////////////////////////////////////////////////////////
// PostError
//

void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, int iValue)
{
    char szError[MAX_STR_LENGTH]  = {0};
    char szFormat[MAX_STR_LENGTH] = {0};

    WIN::LoadString(hInst, uiErrorId, szFormat, sizeof(szFormat)/sizeof(char));
    StringCchPrintf(szError, sizeof(szError), szFormat, iValue);
    MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONERROR);
}

/////////////////////////////////////////////////////////////////////////////
// PostFormattedError
//

void PostFormattedError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, LPCSTR szValue)
{
    char szFormat[MAX_STR_LENGTH] = {0};
    const char* szArgs[1] = {szValue};
    LPVOID lpMessage = 0;;

    WIN::LoadString(hInst, uiErrorId, szFormat, sizeof(szFormat)/sizeof(char));
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, (LPVOID)szFormat, 0, 0, (LPSTR)&lpMessage, 0, (va_list*)szArgs);
    if (!lpMessage)
    {
        ReportErrorOutOfMemory(hInst, hwndOwner, szTitle);
        return;
    }
    MessageBox(hwndOwner, (LPCSTR)lpMessage, szTitle, MB_OK | MB_ICONERROR);
    LocalFree(lpMessage);
}

/////////////////////////////////////////////////////////////////////////////
// PostMsiError
//

void PostMsiError(HINSTANCE hInst, HINSTANCE hMsi, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId)
{
    switch (uiErrorId)
    {
    case ERROR_INSTALL_SUSPEND:
    case ERROR_INSTALL_USEREXIT:
    case ERROR_INSTALL_FAILURE:
    case ERROR_SUCCESS_REBOOT_REQUIRED:
    case ERROR_SUCCESS_REBOOT_INITIATED:
    case ERROR_APPHELP_BLOCK:
        break;
    case ERROR_FILE_NOT_FOUND:
    case ERROR_INVALID_NAME:
    case ERROR_PATH_NOT_FOUND:
        uiErrorId = ERROR_INSTALL_PACKAGE_OPEN_FAILED;
    default:
        {
            char szError[MAX_STR_LENGTH] = {0};
            if (0 == WIN::LoadString(hMsi, uiErrorId, szError, sizeof(szError)/sizeof(char)))
            {
                // error string does not exist, use default
                PostError(hInst, hwndOwner, szTitle, IDS_INSTALL_ERROR, uiErrorId);
            }
            else
            {
                MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONERROR);
            }
            return;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// IsTerminalServerInstalled
//
//  Determines whether terminal services are installed
//
bool IsTerminalServerInstalled(bool fWin9X, int iMajorVersion)
{
    const char szTSSearchStr[]   = TEXT("Terminal Server"); // Not localized
    const char szKey[]         = TEXT("System\\CurrentControlSet\\Control\\ProductOptions");
    const char szValue[]       = TEXT("ProductSuite");

    DWORD dwSize = 0;
    HKEY  hKey = 0;
    DWORD dwType = 0;

    // Win9X is not terminal server
    if (fWin9X)
        return false;

    bool fIsTerminalServer = false;

    // On Windows 2000 and greater, the ProductSuite "Terminal Server"
    // value will always be present. Use GetVersionEx to get the right
    // answer.
    if (iMajorVersion > 4)
    {
        OSVERSIONINFOEX osVersionInfo;
        DWORDLONG dwlConditionMask = 0;

        ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
        osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

        if (GetVersionEx((OSVERSIONINFO*)&osVersionInfo)
            && (osVersionInfo.wSuiteMask & VER_SUITE_TERMINAL)
            && !(osVersionInfo.wSuiteMask & VER_SUITE_SINGLEUSERTS))
            fIsTerminalServer = true;
    }
    else
    {
        // Other NT versions, check the registry key
        // If the value we want exists and has a non-zero size...

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey)
            && ERROR_SUCCESS == RegQueryValueEx(hKey, szValue, NULL, &dwType, NULL, &dwSize)
            && dwSize > 0
            && REG_MULTI_SZ == dwType)
        {
            char* szSuiteList = new char[dwSize];
            if (szSuiteList)
            {
                ZeroMemory(szSuiteList, dwSize);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey, szValue, NULL, &dwType, (LPBYTE)szSuiteList, &dwSize))
                {
                    DWORD cchMulti = 0;                    // Length of current member
                    DWORD cchSrch  = lstrlen(szTSSearchStr);    // Constant during search
                    const char *szSubString = szSuiteList; // pointer to current substring

                    while (*szSubString) // Break on consecutive zero bytes
                    {
                        cchMulti = lstrlen(szSubString);
                        if (cchMulti == cchSrch && 0 == lstrcmp(szTSSearchStr, szSubString))
                        {
                            fIsTerminalServer = true;
                            break;
                        }

                        // substring does not match, skip forward the length of the substring
                        // plus 1 for the terminating null.
                        szSubString += (cchMulti + 1);
                    }
                }
                delete [] szSuiteList;
            }
        }

        if (hKey)
            RegCloseKey(hKey);
    }

    return fIsTerminalServer;
}


/////////////////////////////////////////////////////////////////////////////
// AlreadyInProgress
//
//  Attempts to create the MSISETUP mutex. Returns TRUE
//  if mutex already exists or failed to create mutex
//

bool AlreadyInProgress(bool fWin9X, int iMajorVersion)
{
    const char szTSUniqueName[] = "Global\\_MSISETUP_{2956EBA1-9B5A-4679-8618-357136DA66CA}";
    const char szUniqueName[] = "_MSISETUP_{2956EBA1-9B5A-4679-8618-357136DA66CA}";

    // if Windows 2000 or greater or Terminal Server installed, must use Global prefix
    const char *szMutexName = NULL;
    if ((!fWin9X && iMajorVersion >= 5) || IsTerminalServerInstalled(fWin9X, iMajorVersion))
        szMutexName = szTSUniqueName;
    else
        szMutexName = szUniqueName;

    HANDLE hMutex = 0;


    hMutex = WIN::CreateMutex(NULL /*default security descriptor*/, FALSE, szMutexName);
    if (!hMutex || ERROR_ALREADY_EXISTS == GetLastError())
        return true;


    return false;
}

/////////////////////////////////////////////////////////////////////////////
// DisplayUsage
//
void DisplayUsage (HINSTANCE hInst, HWND hwndOwner, LPCSTR szCaption)
{
    char szMessage[MAX_STR_LENGTH];

    WIN::LoadString(hInst, IDS_USAGE, szMessage, sizeof(szMessage)/sizeof(char));
    WIN::MessageBox(hwndOwner, szMessage, szCaption, MB_OK | MB_ICONINFORMATION);
}

/////////////////////////////////////////////////////////////////////////////
// ReportErrorOutOfMemory
//

void ReportErrorOutOfMemory(HINSTANCE hInst, HWND hwndOwner, LPCSTR szCaption)
{
    char szError[MAX_STR_LENGTH];

    WIN::LoadString(hInst, IDS_OUTOFMEM, szError, sizeof(szError)/sizeof(char));
    WIN::MessageBox(hwndOwner, szError, szCaption, MB_OK | MB_ICONERROR);
}


/////////////////////////////////////////////////////////////////////////////
// GetFileVersionNumber
//

DWORD GetFileVersionNumber(LPSTR szFilename, DWORD * pdwMSVer, DWORD * pdwLSVer)
{
    DWORD             dwResult = NOERROR;
    unsigned          uiSize;
    DWORD             dwVerInfoSize;
    DWORD             dwHandle;
    BYTE              *prgbVersionInfo = NULL;
    VS_FIXEDFILEINFO  *lpVSFixedFileInfo = NULL;

    DWORD dwMSVer = 0xffffffff;
    DWORD dwLSVer = 0xffffffff;

    dwVerInfoSize = GetFileVersionInfoSize(szFilename, &dwHandle);
    if (0 != dwVerInfoSize)
    {
        prgbVersionInfo = (LPBYTE) WIN::GlobalAlloc(GPTR, dwVerInfoSize);
        if (NULL == prgbVersionInfo)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto Finish;
        }

        // Read version stamping info
        if (GetFileVersionInfo(szFilename, dwHandle, dwVerInfoSize, prgbVersionInfo))
        {
            // get the value for Translation
            if (VerQueryValue(prgbVersionInfo, "\\", (LPVOID*)&lpVSFixedFileInfo, &uiSize) && (uiSize != 0))
            {
                dwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                dwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
            }
        }
        else
        {
            dwResult = GetLastError();
            goto Finish;
        }
    }
    else
    {
        dwResult = GetLastError();
    }

#ifdef DEBUG
    char szVersion[255];
    StringCchPrintf(szVersion, sizeof(szVersion), "%s is version %d.%d.%d.%d\n", szFilename, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer));
    DebugMsg("[INFO] %s", szVersion);
#endif // DEBUG

Finish:
    if (NULL != prgbVersionInfo)
        WIN::GlobalFree(prgbVersionInfo);
    if (pdwMSVer)
        *pdwMSVer = dwMSVer;
    if (pdwLSVer)
        *pdwLSVer = dwLSVer;

    return dwResult;
}

/////////////////////////////////////////////////////////////////////////////
// IsOSWin9X
//
//  Returns true if running on a Win9X platform
//  Returns false if running on a WinNT platform
//

bool IsOSWin9X(int *piMajVer)
{
    OSVERSIONINFO sInfoOS;
    memset((void*)&sInfoOS, 0x00, sizeof(OSVERSIONINFO));

    sInfoOS.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    WIN::GetVersionEx(&sInfoOS);

    if (piMajVer)
        *piMajVer = sInfoOS.dwMajorVersion;

    if (VER_PLATFORM_WIN32_NT == sInfoOS.dwPlatformId)
        return false;
    else
        return true;
}

//--------------------------------------------------------------------------------------
// ADVAPI32 API -- delay load
//--------------------------------------------------------------------------------------

#define ADVAPI32_DLL "advapi32.dll"

#define ADVAPI32API_CheckTokenMembership "CheckTokenMembership"
typedef BOOL (WINAPI* PFnCheckTokenMembership)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);

#define ADVAPI32API_AdjustTokenPrivileges "AdjustTokenPrivileges"
typedef BOOL (WINAPI* PFnAdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);

#define ADVAPI32API_OpenProcessToken "OpenProcessToken"
typedef BOOL (WINAPI* PFnOpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);

#define ADVAPI32API_LookupPrivilegeValue "LookupPrivilegeValueA"
typedef BOOL (WINAPI* PFnLookupPrivilegeValue)(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid);

/////////////////////////////////////////////////////////////////////////////
// IsAdmin
//
//  Returns true if current user is an administrator (or if on Win9X)
//  Returns false if current user is not an adminstrator
//
//  implemented as per KB Q118626
//

bool IsAdmin(bool fWin9X, int iMajorVersion)
{
    if (fWin9X)
    {
        // convention: always admin on Win9X
        return true;
    }

    // get the administrator sid
    PSID psidAdministrators;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    if(!AllocateAndInitializeSid(&siaNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &psidAdministrators))
        return false;

    // on NT5, use the CheckTokenMembershipAPI to correctly handle cases where
    // the Adiminstrators group might be disabled. bIsAdmin is BOOL for 
    BOOL bIsAdmin = FALSE;
    if (iMajorVersion >= 5) 
    {
        // CheckTokenMembership checks if the SID is enabled in the token. NULL for
        // the token means the token of the current thread. Disabled groups, restricted
        // SIDS, and SE_GROUP_USE_FOR_DENY_ONLY are all considered. If the function
        // returns false, ignore the result.

        HMODULE hAdvapi32 = LoadLibrary(ADVAPI32_DLL);
        if (!hAdvapi32)
            bIsAdmin = FALSE;
        else
        {
            PFnCheckTokenMembership pfnCheckTokenMembership = (PFnCheckTokenMembership)GetProcAddress(hAdvapi32, ADVAPI32API_CheckTokenMembership);
            if (!pfnCheckTokenMembership || !pfnCheckTokenMembership(NULL, psidAdministrators, &bIsAdmin))
                bIsAdmin = FALSE;
        }
        FreeLibrary(hAdvapi32);
        hAdvapi32 = 0;
    }
    else
    {
        // NT4, check groups of user
        HANDLE hAccessToken = 0;
        UCHAR *szInfoBuffer = new UCHAR[1024]; // may need to resize if TokenInfo too big
        DWORD dwInfoBufferSize = 1024;
        DWORD dwRetInfoBufferSize = 0;
        UINT x=0;

        if (szInfoBuffer && WIN::OpenProcessToken(WIN::GetCurrentProcess(), TOKEN_READ, &hAccessToken))
        {
            bool bSuccess = false;
            bSuccess = WIN::GetTokenInformation(hAccessToken, TokenGroups, szInfoBuffer, dwInfoBufferSize, &dwRetInfoBufferSize) == TRUE;

            if(dwRetInfoBufferSize > dwInfoBufferSize)
            {
                delete [] szInfoBuffer;
                szInfoBuffer = new UCHAR[dwRetInfoBufferSize];
                if (szInfoBuffer)
                {
                    dwInfoBufferSize = dwRetInfoBufferSize;
                    bSuccess = WIN::GetTokenInformation(hAccessToken, TokenGroups, szInfoBuffer, dwInfoBufferSize, &dwRetInfoBufferSize) == TRUE;
                }
            }

            WIN::CloseHandle(hAccessToken);
            
            if (bSuccess)
            {
                PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)(UCHAR*)szInfoBuffer;
                for(x=0;x<ptgGroups->GroupCount;x++)
                {
                    if( WIN::EqualSid(psidAdministrators, ptgGroups->Groups[x].Sid) )
                    {
                        bIsAdmin = TRUE;
                        break;
                    }

                }
            }
        }

        if (szInfoBuffer)
        {
            delete [] szInfoBuffer;
            szInfoBuffer = NULL;
        }
    }
    
    WIN::FreeSid(psidAdministrators);
    return bIsAdmin ? true : false;

}

/////////////////////////////////////////////////////////////////////////////
// AcquireShutdownPrivilege
//
//  Attempts to enable the SE_SHUTDOWN_NAME privilege in the process token
//
bool AcquireShutdownPrivilege()
{
    HANDLE hToken = 0;
    TOKEN_PRIVILEGES tkp;

    HMODULE hAdvapi32 = LoadLibrary(ADVAPI32_DLL);
    if (!hAdvapi32)
        return false;

    PFnOpenProcessToken pfnOpenProcessToken = (PFnOpenProcessToken)GetProcAddress(hAdvapi32, ADVAPI32API_OpenProcessToken);
    PFnLookupPrivilegeValue pfnLookupPrivilegeValue = (PFnLookupPrivilegeValue)GetProcAddress(hAdvapi32, ADVAPI32API_LookupPrivilegeValue);
    PFnAdjustTokenPrivileges pfnAdjustTokenPrivileges = (PFnAdjustTokenPrivileges)GetProcAddress(hAdvapi32, ADVAPI32API_AdjustTokenPrivileges);
    if (!pfnOpenProcessToken || !pfnLookupPrivilegeValue || !pfnAdjustTokenPrivileges)
    {
        FreeLibrary(hAdvapi32);
        return false;
    }

    // grab this process's token
    if (!pfnOpenProcessToken(WIN::GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
    {
        FreeLibrary(hAdvapi32);
        return false;
    }

    // get the LUID for the shutdown privilege
    pfnLookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);

    tkp.PrivilegeCount = 1; // one privilege to set
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    // get the shutdown privilege for this process
    pfnAdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);

    // cannot test return value of AdjustTokenPrivileges
    if (ERROR_SUCCESS != WIN::GetLastError())
    {
        FreeLibrary(hAdvapi32);
        return false;
    }

    FreeLibrary(hAdvapi32);

    return true;
}

/////////////////////////////////////////////////////////////////////////////
// SetDiagnosticMode
//
//  Turns on debug output if first char of szDebugEnvVar is set to 1
//

int g_dmDiagnosticMode = -1; // -1 until set, then DebugMsg skips fn call if 0

void SetDiagnosticMode()
{
    g_dmDiagnosticMode = 0; // disable DebugMsg to start

    char rgchBuf[64] = {0};
    if (0 != WIN::GetEnvironmentVariable(szDebugEnvVar, rgchBuf, sizeof(rgchBuf)/sizeof(char))
        && rgchBuf[0] == '1')
    {
        g_dmDiagnosticMode = 1; // enable DebugMsg output
    }
}

/////////////////////////////////////////////////////////////////////////////
// DebugMsg
//
//  Outputs debugging string to debugger if debug output is enabled
//

void DebugMsg(LPCSTR szFormat, ...)
{
    if (-1 == g_dmDiagnosticMode)
    {
        SetDiagnosticMode();
    }

    if (0 == g_dmDiagnosticMode)
        return; // debug output is not enabled

    size_t dwBuf = 512;
    char *szDebug = new char[dwBuf];
    if (!szDebug)
        return ; // out of memory
    
    // store the result debug string
    va_list listDebugArg; 
    va_start(listDebugArg, szFormat); 
    while (-1 == _vsnprintf(szDebug, dwBuf, szFormat, listDebugArg))
    {
        dwBuf *= 2;
        delete[] szDebug;
        szDebug = new char[dwBuf];
        if (!szDebug)
        {
            va_end(listDebugArg);
            return; // out of memory
        }
    }
    va_end(listDebugArg);

    OutputDebugString(szDebug);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\setup.exe\vertrust.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       vertrust.cpp
//
//--------------------------------------------------------------------------

#define WIN // scope W32 API
#define MSI // scope MSI API

#include <windows.h>
#include <tchar.h>

#include "setup.h" // for itvEnum
#include "common.h"

// package trust
#include "wintrust.h"
#include "softpub.h"

//--------------------------------------------------------------------------------------
// CRYPTO API -- delay load
//--------------------------------------------------------------------------------------

#define CRYPT32_DLL "crypt32.dll"

#define CRYPTOAPI_CertDuplicateCertificateContext "CertDuplicateCertificateContext"
typedef PCCERT_CONTEXT (WINAPI* PFnCertDuplicateCertificateContext)(PCCERT_CONTEXT pCertContext);

#define CRYPTOAPI_CertCompareCertificate "CertCompareCertificate"
typedef BOOL (WINAPI* PFnCertCompareCertificate)(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2);

#define CRYPTOAPI_CertFreeCertificateContext "CertFreeCertificateContext"
typedef BOOL (WINAPI* PFnCertFreeCertificateContext)(PCCERT_CONTEXT pCertContext);

//--------------------------------------------------------------------------------------
// WINTRUST API -- delay load
//--------------------------------------------------------------------------------------

#define WINTRUST_DLL "wintrust.dll"

#define WINTRUSTAPI_WinVerifyTrust "WinVerifyTrust"
typedef HRESULT (WINAPI *PFnWinVerifyTrust)(HWND hwnd, GUID *pgActionID, WINTRUST_DATA *pWinTrustData);

#define WINTRUSTAPI_WTHelperProvDataFromStateData "WTHelperProvDataFromStateData"
typedef PCRYPT_PROVIDER_DATA (WINAPI *PFnWTHelperProvDataFromStateData)(HANDLE hStateData);

#define WINTRUSTAPI_WTHelperGetProvSignerFromChain "WTHelperGetProvSignerFromChain"
typedef PCRYPT_PROVIDER_SGNR (WINAPI *PFnWTHelperGetProvSignerFromChain)(PCRYPT_PROVIDER_DATA pProvData, DWORD idxSigner, BOOL fCounterSigner, DWORD idxCounterSigner);

#define WINTRUSTAPI_WTHelperGetProvCertFromChain "WTHelperGetProvCertFromChain"
typedef PCRYPT_PROVIDER_CERT (WINAPI* PFnWTHelperGetProvCertFromChain)(PCRYPT_PROVIDER_SGNR pSgnr, DWORD idxCert);

//--------------------------------------------------------------------------------------
// download provider
//--------------------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// IsFileTrusted
//
itvEnum IsFileTrusted(LPCWSTR lpwFile, HWND hwndParent, DWORD dwUIChoice, bool *pfIsSigned, PCCERT_CONTEXT *ppcSigner)
{
    char szDebugOutput[MAX_STR_LENGTH] = {0};

    itvEnum itv = itvUnTrusted;

    if (pfIsSigned)
        *pfIsSigned = false;
    if (ppcSigner)
        *ppcSigner  = 0;

    GUID guidAction = WINTRUST_ACTION_GENERIC_VERIFY_V2;

    WINTRUST_FILE_INFO sWintrustFileInfo;
    WINTRUST_DATA      sWintrustData;
    HRESULT            hr;

    memset((void*)&sWintrustFileInfo, 0x00, sizeof(WINTRUST_FILE_INFO)); // zero out
    memset((void*)&sWintrustData, 0x00, sizeof(WINTRUST_DATA)); // zero out

    sWintrustFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
    sWintrustFileInfo.pcwszFilePath = lpwFile;
    sWintrustFileInfo.hFile = NULL;

    sWintrustData.cbStruct            = sizeof(WINTRUST_DATA);
    sWintrustData.dwUIChoice          = dwUIChoice;
    sWintrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    sWintrustData.dwUnionChoice       = WTD_CHOICE_FILE;
    sWintrustData.pFile               = &sWintrustFileInfo;
    sWintrustData.dwStateAction       = (ppcSigner) ? WTD_STATEACTION_VERIFY : 0;

    HMODULE hWinTrust = LoadLibrary(WINTRUST_DLL);
    if (!hWinTrust)
    {
        // WinTrust is unavailable on the machine
        return itvWintrustNotOnMachine;
    }
    PFnWinVerifyTrust pfnWinVerifyTrust = (PFnWinVerifyTrust)GetProcAddress(hWinTrust, WINTRUSTAPI_WinVerifyTrust);
    PFnWTHelperProvDataFromStateData pfnWTHelperProvDataFromStateData= (PFnWTHelperProvDataFromStateData)GetProcAddress(hWinTrust, WINTRUSTAPI_WTHelperProvDataFromStateData);
    PFnWTHelperGetProvSignerFromChain pfnWTHelperGetProvSignerFromChain = (PFnWTHelperGetProvSignerFromChain)GetProcAddress(hWinTrust, WINTRUSTAPI_WTHelperGetProvSignerFromChain);
    PFnWTHelperGetProvCertFromChain pfnWTHelperGetProvCertFromChain = (PFnWTHelperGetProvCertFromChain)GetProcAddress(hWinTrust, WINTRUSTAPI_WTHelperGetProvCertFromChain);
    if (!pfnWinVerifyTrust || !pfnWTHelperProvDataFromStateData || !pfnWTHelperGetProvSignerFromChain || !pfnWTHelperGetProvCertFromChain)
    {
        // WinTrust is unavailable on the machine
        FreeLibrary(hWinTrust);
        return itvWintrustNotOnMachine;
    }

    hr = pfnWinVerifyTrust(/* UI Window Handle */ (dwUIChoice == WTD_UI_NONE) ? (HWND)INVALID_HANDLE_VALUE : hwndParent, &guidAction, &sWintrustData);
    DebugMsg("[WVT] WVT returned 0x%X\n", hr);

    itv = (TRUST_E_PROVIDER_UNKNOWN == hr) ? itvWintrustNotOnMachine : ((S_OK == hr) ? itvTrusted : itvUnTrusted); 

    if (itvWintrustNotOnMachine == itv)
    {
        // release state data
        sWintrustData.dwUIChoice = WTD_UI_NONE;
        sWintrustData.dwStateAction = WTD_STATEACTION_CLOSE;
        pfnWinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &guidAction, &sWintrustData);

        FreeLibrary(hWinTrust);
        return itv; // return immediately
    }

    if (pfIsSigned)
        *pfIsSigned = (TRUST_E_NOSIGNATURE == hr) ? false : true;

    if (TRUST_E_NOSIGNATURE == hr)
    {
        // release state data
        sWintrustData.dwUIChoice = WTD_UI_NONE;
        sWintrustData.dwStateAction = WTD_STATEACTION_CLOSE;
        pfnWinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &guidAction, &sWintrustData);

        FreeLibrary(hWinTrust);
        return itv;
    }

    if (ppcSigner)
    {
        CRYPT_PROVIDER_DATA const *psProvData     = NULL;
        CRYPT_PROVIDER_SGNR       *psProvSigner   = NULL;
        CRYPT_PROVIDER_CERT       *psProvCert     = NULL;

        // grab the provider data
        psProvData = pfnWTHelperProvDataFromStateData(sWintrustData.hWVTStateData);
        if (psProvData)
        {
            // grab the signer data from the CRYPT_PROV_DATA
            psProvSigner = pfnWTHelperGetProvSignerFromChain((PCRYPT_PROVIDER_DATA)psProvData, 0 /*first signer*/, FALSE /* not a counter signer */, 0);
            if (psProvSigner)
            {
                // grab the signer cert from CRYPT_PROV_SGNR (pos 0 = signer cert; pos csCertChain-1 = root cert)
                psProvCert = pfnWTHelperGetProvCertFromChain(psProvSigner, 0);
            }
        }
    
        if (!psProvCert)
        {
            // some failure in obtaining the signer cert data
            *ppcSigner = 0;
        }
        else
        {
            // duplicate the cert
            HMODULE hCrypt32 = LoadLibrary(CRYPT32_DLL);
            if (hCrypt32)
            {
                PFnCertDuplicateCertificateContext pfnCertDuplicateCertificateContext = (PFnCertDuplicateCertificateContext)GetProcAddress(hCrypt32, CRYPTOAPI_CertDuplicateCertificateContext);
                if (pfnCertDuplicateCertificateContext)
                    *ppcSigner = pfnCertDuplicateCertificateContext(psProvCert->pCert);
                FreeLibrary(hCrypt32);
            }
        }

        // release state data
        sWintrustData.dwUIChoice = WTD_UI_NONE;
        sWintrustData.dwStateAction = WTD_STATEACTION_CLOSE;
        pfnWinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &guidAction, &sWintrustData);
    }

    FreeLibrary(hWinTrust);
    return itv;
}

/////////////////////////////////////////////////////////////////////////////
// IsPackageTrusted
//

itvEnum IsPackageTrusted(LPCSTR szSetupExe, LPCSTR szPackage, HWND hwndParent)
{
    WCHAR *szwSetup   = 0;
    WCHAR *szwPackage = 0;
    int   cchWide     = 0;

    bool    fPackageIsTrusted = false;
    bool    fSetupExeIsSigned = false;
    bool    fPackageIsSigned  = false;
    itvEnum itv               = itvUnTrusted;

    DWORD dwUILevel = 0;

    char szDebugOutput[MAX_STR_LENGTH] = {0};

    PCCERT_CONTEXT pcExeSigner = 0;
    PCCERT_CONTEXT pcMsiSigner = 0;

    HMODULE hCrypt32 = LoadLibrary(CRYPT32_DLL);
    if (!hCrypt32)
    {
        // no crypto on the machine
        return itvWintrustNotOnMachine;
    }
    PFnCertCompareCertificate pfnCertCompareCertificate = (PFnCertCompareCertificate)GetProcAddress(hCrypt32, CRYPTOAPI_CertCompareCertificate);
    PFnCertFreeCertificateContext pfnCertFreeCertificateContext = (PFnCertFreeCertificateContext)GetProcAddress(hCrypt32, CRYPTOAPI_CertFreeCertificateContext);
    if (!pfnCertCompareCertificate || !pfnCertFreeCertificateContext)
    {
        // no crypt on the machine
        FreeLibrary(hCrypt32);
        return itvWintrustNotOnMachine;
    }

    // convert szSetupExe to WIDE
    cchWide = MultiByteToWideChar(CP_ACP, 0, szSetupExe, -1, 0, 0);
    szwSetup = new WCHAR[cchWide];
    if (!szwSetup)
    {
        // out of memory
        FreeLibrary(hCrypt32);
        return itvUnTrusted;
    }
    if (0 == MultiByteToWideChar(CP_ACP, 0, szSetupExe, -1, szwSetup, cchWide))
    {
        // failed to convert string
        FreeLibrary(hCrypt32);
        delete [] szwSetup;
        return itvUnTrusted;
    }

    //
    // step 1: silently call WinVerifyTrust on szSetupExe, ignore return value - except for ivtWintrustNotOnMachine
    //

    DebugMsg("[WVT] step 1: silently call WinVerifyTrust on szSetupExe, ignoring return value\n");

    if (itvWintrustNotOnMachine == (itv = IsFileTrusted(szwSetup, hwndParent, WTD_UI_NONE, &fSetupExeIsSigned, &pcExeSigner)))
    {
        goto CleanUp;
    }

    DebugMsg("[WVT] fSetupExeIsSigned = %s\n", fSetupExeIsSigned ? "TRUE" : "FALSE");

    // convert szPackage to WIDE
    cchWide = MultiByteToWideChar(CP_ACP, 0, szPackage, -1, 0, 0);
    szwPackage = new WCHAR[cchWide];
    if (!szwPackage)
    {
        // out of memory
        FreeLibrary(hCrypt32);
        return itvUnTrusted;
    }
    if (0 == MultiByteToWideChar(CP_ACP, 0, szPackage, -1, szwPackage, cchWide))
    {
        // failed to convert string
        FreeLibrary(hCrypt32);
        return itvUnTrusted;
    }

    //
    // step 2: silently call WinVerifyTrust on szPackage, ignore return value - except for ivtWintrustNotOnMachine
    //

    if (fSetupExeIsSigned)
    {
        DebugMsg("[WVT] step2: silently call WinVerifyTrust on szPackage, ignoring return value\n");
        if (itvWintrustNotOnMachine == (itv = IsFileTrusted(szwPackage, hwndParent, WTD_UI_NONE, &fPackageIsSigned, &pcMsiSigner)))
        {
            goto CleanUp;
        }

        DebugMsg("[WVT] fPackageIsSigned = %s\n", fPackageIsSigned ? "TRUE" : "FALSE");
    }

    //
    // step 3: call WinVerifyTrust on szPackage, return value matters; use proper UI-level
    //

    if ( !fSetupExeIsSigned  // exe is not signed
        || !fPackageIsSigned // package is not signed
        || !pcExeSigner      // exe signer cert is missing
        || !pcMsiSigner      // package signer cert is missing
        || !pfnCertCompareCertificate(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, pcExeSigner->pCertInfo, pcMsiSigner->pCertInfo)) // signed by different certs
    {
        // always show UI
        DebugMsg("[WVT] step3: last call to WinVerifyTrust using full UI\n");
        dwUILevel = WTD_UI_ALL;
    }
    else
    {
        // show UI only if bad
        DebugMsg("[WVT] step3: last call to WinVerifyTrust showing UI only if something is wrong\n");
        dwUILevel = WTD_UI_NOGOOD;
    }

    itv = IsFileTrusted(szwPackage, hwndParent, dwUILevel, NULL, NULL);

    //
    // cleanup
    //

CleanUp:
    if (szwPackage)
        delete [] szwPackage;
    if (szwSetup)
        delete [] szwSetup;

    if (pcExeSigner)
        pfnCertFreeCertificateContext(pcExeSigner);
    if (pcMsiSigner)
        pfnCertFreeCertificateContext(pcMsiSigner);

    FreeLibrary(hCrypt32);

    return itv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\clientpp.cpp ===
// ClientPP.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "ClientPP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClientPropertyPage property page

IMPLEMENT_DYNCREATE(CClientPropertyPage, CPropertyPage)

CClientPropertyPage::CClientPropertyPage() : CPropertyPage(CClientPropertyPage::IDD)
{
	//{{AFX_DATA_INIT(CClientPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_bClientPropSortUp = TRUE;
	m_iClientLastColumnClick = 0;
	m_iClientLastColumnClickCache = 0;

	m_bCurrentSortUp = FALSE;
	m_pCurrentListSorting = NULL;
	m_pcstrClientPropNameArray = NULL;
}

CClientPropertyPage::~CClientPropertyPage()
{
}

void CClientPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CClientPropertyPage)
	DDX_Control(pDX, IDC_CLIENTPROP, m_lstClientProp);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CClientPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CClientPropertyPage)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_CLIENTPROP, OnColumnClickClientProp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClientPropertyPage message handlers

BOOL CClientPropertyPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	

	RECT r;
	m_lstClientProp.GetClientRect(&r);

	int widthCol1;
	int widthCol2;

	//col 1 & 2 takes up around half of area...
	widthCol1 = widthCol2 = ((r.right - r.left) / 2);
	
	m_lstClientProp.InsertColumn(0, "Property", LVCFMT_LEFT, widthCol1);
	m_lstClientProp.InsertColumn(1, "Value", LVCFMT_LEFT, widthCol2);

    //autosize last column for best look and to get rid of scroll bar
	m_lstClientProp.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);

	m_lstClientProp.SetExtendedStyle(m_lstClientProp.GetExtendedStyle() | LVS_EX_FULLROWSELECT);

	int i, count;
	if (m_pcstrClientPropNameArray)
	{
  	   count = m_pcstrClientPropNameArray->GetSize();
	   for (i = 0; i < count; i++)
	   {
          m_lstClientProp.InsertItem(i, m_pcstrClientPropNameArray->GetAt(i), 0);
		  m_lstClientProp.SetItemData(i, i);
          m_lstClientProp.SetItemText(i, 1, m_pcstrClientPropValueArray->GetAt(i));
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//nmanis, for sorting of columns...
int CALLBACK CClientPropertyPage::CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CClientPropertyPage *pDlg; //we pass "this" in to this callback...
    pDlg = (CClientPropertyPage *) lParamSort; 

    LV_FINDINFO FindItem1;
    LV_FINDINFO FindItem2;

    ZeroMemory(&FindItem1, sizeof(LV_FINDINFO));
    ZeroMemory(&FindItem2, sizeof(LV_FINDINFO));

    FindItem1.flags  = LVFI_PARAM;
    FindItem1.lParam = lParam1;

    FindItem2.flags = LVFI_PARAM;
    FindItem2.lParam = lParam2;

    int iIndexItem1 = pDlg->m_pCurrentListSorting->FindItem(&FindItem1);
    int iIndexItem2 = pDlg->m_pCurrentListSorting->FindItem(&FindItem2);

	if (pDlg->m_pCurrentListSorting)
	{
      CString str1 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem1, pDlg->m_iCurrentColumnSorting);
      CString str2 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem2, pDlg->m_iCurrentColumnSorting);
      switch (pDlg->m_iCurrentColumnSorting)
	  {
        case 0: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     
              break;

        case 1: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

              break;  //no needed, just in case we forget...
	  }
	}

    return 0;
}
//end nmanis, sorting function


void CClientPropertyPage::OnColumnClickClientProp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iClientLastColumnClick = pNMListView->iSubItem;
    if (m_iClientLastColumnClickCache == m_iClientLastColumnClick) //if click on different column, don't toggle
	{
       m_bClientPropSortUp = !m_bClientPropSortUp;  //toggle it...
	}


    m_iClientLastColumnClickCache = m_iClientLastColumnClick;  //save last header clicked

    m_pCurrentListSorting = &m_lstClientProp;
	m_iCurrentColumnSorting = m_iClientLastColumnClick;
	m_bCurrentSortUp = m_bClientPropSortUp;

    //we are going to do a custom sort...
    m_lstClientProp.SortItems(CompareFunc, (LPARAM) this);
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\clientpp.h ===
#if !defined(AFX_CLIENTPROPERTYPAGE_H__153ECD67_C022_4A4F_A246_146A0EFF509B__INCLUDED_)
#define AFX_CLIENTPROPERTYPAGE_H__153ECD67_C022_4A4F_A246_146A0EFF509B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ClientPP.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CClientPropertyPage dialog

class CClientPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CClientPropertyPage)

// Construction
public:
	CClientPropertyPage();
	~CClientPropertyPage();

	static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

	BOOL SetClientPropNames(CStringArray *cstrClientPropNameArray)
	{
        m_pcstrClientPropNameArray = cstrClientPropNameArray;
		return TRUE;
	}

	BOOL SetClientPropValues(CStringArray *cstrClientPropValueArray)
	{
        m_pcstrClientPropValueArray = cstrClientPropValueArray;
		return TRUE;
	}
	
    BOOL m_bClientPropSortUp;


// Dialog Data
	//{{AFX_DATA(CClientPropertyPage)
	enum { IDD = IDD_PROPPAGE_CLIENT };
	CListCtrl	m_lstClientProp;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CClientPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CStringArray *m_pcstrClientPropNameArray;
	CStringArray *m_pcstrClientPropValueArray;

	CListCtrl *m_pCurrentListSorting;
	int       m_iCurrentColumnSorting;
	BOOL      m_bCurrentSortUp;

	int  m_iClientLastColumnClick;
	int  m_iClientLastColumnClickCache;



	// Generated message map functions
	//{{AFX_MSG(CClientPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnColumnClickClientProp(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLIENTPROPERTYPAGE_H__153ECD67_C022_4A4F_A246_146A0EFF509B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\common.h ===
#ifndef COMMON_TYPES_H
#define COMMON_TYPES_H


//how big is our buffer reads in file
#define LOG_BUF_READ_SIZE 8192

//number of lines we identify errors
#define LINES_ERROR 6

//property types...
#define SERVER_PROP 0
#define CLIENT_PROP 1
#define NESTED_PROP 2


//HTML common settings...
#define MAX_HTML_LOG_COLORS 9

struct HTMLColorSetting
{
  char name[64];
  COLORREF value;
};


#define SOLUTIONS_BUFFER 8192

struct HTMLColorSettings
{
	HTMLColorSetting settings[MAX_HTML_LOG_COLORS]; 
};

void InitHTMLColorSettings(HTMLColorSettings &settings1);


//POLICY common settings
#define MAX_MACHINE_POLICIES_MSI11 14
#define MAX_USER_POLICIES_MSI11     5
#define MAX_POLICY_NAME 64

//5-9-2001, make policies 2.0 aware...
#define MAX_MACHINE_POLICIES_MSI20 16
#define MAX_USER_POLICIES_MSI20     5

#define MAX_MACHINE_POLICIES MAX_MACHINE_POLICIES_MSI20
#define MAX_USER_POLICIES    MAX_USER_POLICIES_MSI20
//end 5-9-2001

struct MSIPolicy
{
	BOOL bSet;
    char PolicyName[MAX_POLICY_NAME];
};


struct MachinePolicySettings
{
	int iNumberMachinePolicies;
//5-9-2001, go to 2.0 now, 2.0 has same 1.1/1.2 policies plus 2 new ones, so this is "ok" 
	struct MSIPolicy MachinePolicy[MAX_MACHINE_POLICIES_MSI20];
//end 5-9-2001
};

struct UserPolicySettings
{
	int iNumberUserPolicies;

//5-9-2001, go to 2.0 now
	struct MSIPolicy UserPolicy[MAX_USER_POLICIES_MSI20];
//end 5-9-2001
};

void InitMachinePolicySettings(MachinePolicySettings &policies);
void InitUserPolicySettings(UserPolicySettings &policies);

struct WIErrorInfo
{
	CString cstrError;
	CString cstrSolution;
    BOOL    bIgnorableError;
};

struct WIIgnoredError
{
	CString cstrError;
};

extern "C"   BOOL  g_bNT;
extern "C"   BOOL  g_bRunningInQuietMode;

extern const TCHAR *g_szDefaultOutputLogDir;
extern       TCHAR g_szLogFileToParse[MAX_PATH];
extern const TCHAR *g_szDefaultIgnoredErrors;

extern "C"   BOOL  g_bShowEverything;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\common.cpp ===
#include "stdafx.h"
#include "Common.h"


//in BGR form.  COLORREF needs to use RGB macro to work as COLORREF is bbggrr
struct HTMLColorSettings InitialUserSettings = 
{
	     "(CLIENT) Client Context", 0xFF00FF,  
		 "(SERVER) Server Context", 0xFF0000, 
		 "(CUSTOM) CustomAction Context", 0x00AA00, 
		 "(UNKNOWN) Unknown Context", 0x000000,
		 "(ERROR) Error Area", 0x0000FF, 
		 "(PROPERTY) Property", 0xFFAA00, 
		 "(STATE) State", 0x555555,
		 "(POLICY) Policy", 0x008000,
		 "(IGNORED) Ignored Error", 0x0000AA
};


void InitHTMLColorSettings(HTMLColorSettings &settings1)
{
	int iCount = MAX_HTML_LOG_COLORS;
//	settings1.iNumberColorSettings = iCount;

    for (int i=0; i < iCount; i++)
	{
	  strcpy(settings1.settings[i].name, InitialUserSettings.settings[i].name);
      settings1.settings[i].value = InitialUserSettings.settings[i].value;
	}
}


//5-9-2001, has all 2.0 policies now
char MachinePolicyTable[MAX_MACHINE_POLICIES][MAX_POLICY_NAME] =
{ 
//machine
	"AllowLockDownBrowse",
	"AllowLockdownMedia",
	"AllowLockdownPatch",
	"AlwaysInstallElevated",
	"Debug",
	"DisableBrowse",
	"DisableMSI",
	"DisablePatch",
	"DisableRollback",
    "DisableUserInstalls",
	"EnableAdminTSRemote",
	"EnableUserControl",
	"LimitSystemRestoreCheckpointing",
	"Logging",
	"SafeForScripting",
	"TransformsSecure"
};


char UserPolicyTable[MAX_USER_POLICIES][MAX_POLICY_NAME] =
{
//user
	"AlwaysInstallElevated",
	"DisableMedia",
	"DisableRollback",
	"SearchOrder",
	"TransformsAtSource"
};


//5-9-2001, made policies not dependent on version and what is set in MAX_MACHINE_POLICIES
void InitMachinePolicySettings(MachinePolicySettings &policies)
{
  policies.iNumberMachinePolicies = MAX_MACHINE_POLICIES;

  int iCount = MAX_MACHINE_POLICIES;
  for (int i=0; i < iCount; i++)
  {
	  policies.MachinePolicy[i].bSet = -1;
	  strcpy(policies.MachinePolicy[i].PolicyName, MachinePolicyTable[i]);
  }
}


void InitUserPolicySettings(UserPolicySettings &policies)
{
  policies.iNumberUserPolicies = MAX_USER_POLICIES;

  int iCount = MAX_USER_POLICIES;
  for (int i=0; i < iCount; i++)
  {
	  policies.UserPolicy[i].bSet = -1;
	  strcpy(policies.UserPolicy[i].PolicyName, UserPolicyTable[i]);
  }
}
//end 5-9-2001

BOOL         g_bNT = FALSE;
BOOL         g_bRunningInQuietMode = FALSE;

const TCHAR *g_szDefaultOutputLogDir = _T("c:\\WILogResults\\");
TCHAR        g_szLogFileToParse[MAX_PATH] = "";
const TCHAR  *g_szDefaultIgnoredErrors = _T("2898,2826,2827");
BOOL         g_bShowEverything = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\loganald.cpp ===
// LogAnalD.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "LogAnalD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "PropD.h"
#include "StatesD.h"
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// CLogAnalyzeDlg dialog


CLogAnalyzeDlg::CLogAnalyzeDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CLogAnalyzeDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLogAnalyzeDlg)
	m_cstrSolution = _T("");
	m_cstrError = _T("");
	m_cstrDateTime = _T("");
	m_cstrUser = _T("");
	m_cstrClientCMD = _T("");
	m_bAdminRights = FALSE;
	m_cstrVersion = _T("");
	m_cstrClientPrivDetail = _T("");
	m_cstrServerPrivDetail = _T("");
	m_bShowIgnoredDebugErrors = FALSE;
	//}}AFX_DATA_INIT

//m_cstrProduct = _T(""); 5-16-2001, no longer used...
	m_LineCount = 0;
	m_bErrorFound = FALSE;

	CWILogUtilApp *pApp = (CWILogUtilApp *) AfxGetApp();
	if (pApp)
	{
       m_cstrOutputDir = pApp->GetOutputDirectory();
	}

    m_cstrLegendName = "legend.htm";
	m_cstrDetailsName = "details_";

//does the tool support future versions of WI?
	m_bLogVersionAllowed = TRUE;

	m_dwVersionMajorReject = 3; //reject versions 3.01 and higher by default...  Change in GUI...
	m_dwVersionMinorReject = 01;  

    m_dwVersionMajorLogCreated = 0;
	m_dwVersionMinorLogCreated = 0;
	m_dwVersionBuildLogCreated = 0;

//if we don't find anything, have it set to (none)
	m_cstrUser = _T("(none)");
//	m_cstrProduct = _T("(none)"); //5-16-2001, no longer used...
	m_cstrClientPrivDetail = _T("(none)");
	m_cstrServerPrivDetail = _T("(none)");
}


void CLogAnalyzeDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLogAnalyzeDlg)
	DDX_Text(pDX, IDC_SOLUTION, m_cstrSolution);
	DDX_Text(pDX, IDC_ERROR, m_cstrError);
	DDX_Text(pDX, IDC_DATETIME, m_cstrDateTime);
	DDX_Text(pDX, IDC_USER, m_cstrUser);
	DDX_Text(pDX, IDC_CLIENTCMDLINE, m_cstrClientCMD);
	DDX_Check(pDX, IDC_ADMINRIGHTS, m_bAdminRights);
	DDX_Text(pDX, IDC_VERSION, m_cstrVersion);
	DDX_Text(pDX, IDC_CLIENTPRIVILEDGEDETAIL, m_cstrClientPrivDetail);
	DDX_Text(pDX, IDC_SERVERPRIVILEDGEDETAIL, m_cstrServerPrivDetail);
	DDX_Check(pDX, IDC_SHOW_IGNORED_ERRORS, m_bShowIgnoredDebugErrors);
	//}}AFX_DATA_MAP

	//DDX_Text(pDX, IDC_PRODUCT, m_cstrProduct); //5-16-2001, no longer used...
}


BEGIN_MESSAGE_MAP(CLogAnalyzeDlg, CDialog)
	//{{AFX_MSG_MAP(CLogAnalyzeDlg)
	ON_BN_CLICKED(IDC_SHOWSTATES, OnShowstates)
	ON_BN_CLICKED(IDC_SHOWPROP, OnShowprop)
	ON_BN_CLICKED(IDC_EXPLAINLOG, OnExplainlog)
	ON_BN_CLICKED(IDC_POLICIES, OnPolicies)
	ON_BN_CLICKED(IDC_NEXTERROR, OnNexterror)
	ON_BN_CLICKED(IDC_PREVIOUSERROR, OnPreviouserror)
	ON_COMMAND(ID_OPERATIONS_OPTIONS, OnOperationsOptions)
	ON_COMMAND(ID_OPERATIONS_GENERATEHTMLOUTPUT, OnOperationsGeneratehtmloutput)
	ON_COMMAND(ID_OPERATIONS_SHOWPOLICIES, OnOperationsShowpolicies)
	ON_COMMAND(ID_OPERATIONS_SHOWPROPERTIES, OnOperationsShowproperties)
	ON_COMMAND(ID_OPERATIONS_SHOWSTATES, OnOperationsShowstates)
	ON_BN_CLICKED(IDC_SHOW_IGNORED_ERRORS, OnShowIgnoredErrors)
	ON_BN_CLICKED(IDC_PROPTEST, OnProptest)
	ON_BN_CLICKED(IDC_SAVERESULTS, OnSaveresults)
	ON_BN_CLICKED(IDC_SHOWINTERNALERRORSHELP, OnShowinternalerrorshelp)
	ON_BN_CLICKED(IDC_DELETEOUTPUTDIRCONTENTS, OnDeleteoutputdircontents)
	ON_BN_CLICKED(IDC_SHOWHELP, OnShowhelp)
	ON_BN_CLICKED(IDC_SHOWHOWTOREADLOG, OnShowhowtoreadlog)
	//}}AFX_MSG_MAP

//5-9-2001, add tooltips!!!
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT,0,0xFFFF,OnToolTipNotify)
END_MESSAGE_MAP()


void CLogAnalyzeDlg::ShowLogRejectedMessage()
{
   if (!g_bRunningInQuietMode)
   {
	  CString strVersion;
	  CString strVersionReject;

	  strVersion.Format("Log Version: %d.%d\n", m_dwVersionMajorLogCreated, m_dwVersionMinorLogCreated);
	  strVersionReject.Format("Non-supported versions and higher: %d.%d", m_dwVersionMajorReject, m_dwVersionMinorReject);

	  CString strMessage = "Log file created with version higher than this tool supports\n\n";
	  CString strWarning = strMessage + strVersion + strVersionReject;

	  if (!g_bRunningInQuietMode)
	  {
	     AfxMessageBox(strWarning);
	  }
   }
}

BOOL CLogAnalyzeDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

//5-16-2001
	if (g_bShowEverything)
	{
	    CWnd *pWnd = GetDlgItem(IDC_SHOWPROP);
		if (pWnd)
		{
			pWnd->ShowWindow(SW_SHOW);
		}

		pWnd = GetDlgItem(IDC_DELETEOUTPUTDIRCONTENTS);
		if (pWnd)
		{
			pWnd->ShowWindow(SW_SHOW);
		}
	}
//end 5-16-2001

	AnalyzeLog(); //do the parsing and analysis

	EnableToolTips(TRUE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CLogAnalyzeDlg::OnToolTipNotify(UINT id, NMHDR *pNMH, LRESULT *pResult)
{
       TOOLTIPTEXT *pText = (TOOLTIPTEXT *)pNMH;
       int control_id =  ::GetDlgCtrlID((HWND)pNMH->idFrom);
       if(control_id)
       {
           pText->lpszText = MAKEINTRESOURCE(control_id);
           pText->hinst = AfxGetInstanceHandle();
           return TRUE;
       }
       return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CLogAnalyzeDlg message handlers
void CLogAnalyzeDlg::OnShowstates() 
{
  if (!m_bLogVersionAllowed)
  {
	 ShowLogRejectedMessage();
	 return;
  }

  CStatesDlg dlg;

  dlg.SetComponentNames(&this->m_cstrComponentNameArray);
  dlg.SetComponentInstalled(&this->m_cstrComponentInstalledArray);
  dlg.SetComponentRequest(&this->m_cstrComponentRequestArray);
  dlg.SetComponentAction(&this->m_cstrComponentActionArray);

  dlg.SetFeatureNames(&this->m_cstrFeatureNameArray);
  dlg.SetFeatureInstalled(&this->m_cstrFeatureInstalledArray);
  dlg.SetFeatureRequest(&this->m_cstrFeatureRequestArray);
  dlg.SetFeatureAction(&this->m_cstrFeatureActionArray);

  //5-3-2001, don't show in quiet mode...
  if (!g_bRunningInQuietMode)
	 dlg.DoModal();
}


void CLogAnalyzeDlg::OnShowprop() 
{
  if (!m_bLogVersionAllowed)
  {
	 ShowLogRejectedMessage();
	 return;
  }

  CPropDlg dlg;

  dlg.SetClientPropNames(&this->m_cstrClientPropNameArray);
  dlg.SetClientPropValues(&this->m_cstrClientPropValueArray);

  dlg.SetServerPropNames(&this->m_cstrServerPropNameArray);
  dlg.SetServerPropValues(&this->m_cstrServerPropValueArray);

  dlg.SetNestedPropNames(&this->m_cstrNestedPropNameArray);
  dlg.SetNestedPropValues(&this->m_cstrNestedPropValueArray);

  //5-3-2001, don't show in quiet mode...
  if (!g_bRunningInQuietMode)
     dlg.DoModal();
}


void CLogAnalyzeDlg::DoInitialization()
{
	m_cstrClientPropNameArray.RemoveAll();
	m_cstrClientPropValueArray.RemoveAll();
	
	m_cstrServerPropNameArray.RemoveAll();
	m_cstrServerPropValueArray.RemoveAll();

	m_cstrNestedPropNameArray.RemoveAll();
	m_cstrNestedPropValueArray.RemoveAll();

	m_iTotalNonIgnoredErrors = 0;
	m_iCurrentNonIgnoredError = 0;

    m_iCurrentIgnoredError = 0;
	m_iTotalIgnoredErrors = 0;

	InitMachinePolicySettings(m_MachinePolicySettings);
	InitUserPolicySettings(m_UserPolicySettings);

//init the colors to use when generating HTML...
	InitColorMembers();

	CWILogUtilApp *pApp = (CWILogUtilApp *) AfxGetApp();
	if (pApp)
	{
	   m_cstrIgnoredErrors = pApp->GetIgnoredErrors();
	}
}

void CLogAnalyzeDlg::DoResults()
{
	if (m_iTotalNonIgnoredErrors > 1)
	{
		m_iCurrentNonIgnoredError = 1;
		CWnd *pWnd;
		pWnd = GetDlgItem(IDC_NEXTERROR);
		if (pWnd)
		   pWnd->EnableWindow();

		WIErrorInfo *pErrorInfo;
		pErrorInfo = m_arNonIgnorableErrorArray.GetAt(m_iCurrentNonIgnoredError);
		if (pErrorInfo)
		{
  	 	   m_cstrError = pErrorInfo->cstrError;
           m_cstrSolution = pErrorInfo->cstrSolution;
		}
	}
	else if (m_iTotalNonIgnoredErrors == 1)
	{
		m_iCurrentNonIgnoredError = 1;

		WIErrorInfo *pErrorInfo;
		pErrorInfo = m_arNonIgnorableErrorArray.GetAt(m_iCurrentNonIgnoredError);
		if (pErrorInfo)
		{
  	 	   m_cstrError = pErrorInfo->cstrError;
           m_cstrSolution = pErrorInfo->cstrSolution;
		}
	}
	else if (m_iTotalNonIgnoredErrors == 0)
	{
 	   m_cstrError.LoadString(IDS_NOERRORFOUND);
       m_cstrSolution.LoadString(IDS_NOSOLUTION_NEEDED);
	}

    CString str;
	str.Format("%d", m_iCurrentNonIgnoredError);
	CWnd *pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
	if (pWnd)
	{
		pWnd->SetWindowText(str);
	}                

	str.Format("%d", this->m_iTotalNonIgnoredErrors);
	pWnd = GetDlgItem(IDC_TOTAL_ERRORS);
	if (pWnd)
	{
		pWnd->SetWindowText(str);
	}

	if (m_iTotalIgnoredErrors) //and also a tracker for where current pos is in ignored errors...
	   m_iCurrentIgnoredError = 1;

    if (!g_bRunningInQuietMode)
	   UpdateData(FALSE);
}

//5-4-2001
void CLogAnalyzeDlg::DoSummaryResults(CString &cstrFileName)
{
	FILE *fptr;
    fptr = fopen(cstrFileName, "w");
	if (fptr)
	{
	   CString cstrLine;
	   cstrLine.Format("Summary for log file %s\r\n", m_cstrLogFileName);
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n";
	   fputs(cstrLine, fptr);

	   cstrLine.Format("MSI Version : %s\r\n\r\n", m_cstrVersion) ;
	   fputs(cstrLine, fptr);

   	   cstrLine.Format("Date & Time : %s\r\n\r\n", m_cstrDateTime) ;
	   fputs(cstrLine, fptr);

//5-16-2001, no longer used...
//	   cstrLine.Format("Product     : %s\r\n\r\n", m_cstrProduct);
//	   fputs(cstrLine, fptr);

	   cstrLine.Format("Command Line: %s\r\n\r\n", m_cstrClientCMD);
	   fputs(cstrLine, fptr);

	   cstrLine.Format("User        : %s\r\n\r\n", m_cstrUser);
	   fputs(cstrLine, fptr);

	   CString cstrAnswer = "Yes";
	   if (!m_bAdminRights)
	   {
          cstrAnswer = "No";
	   }
	   
	   cstrLine.Format("Admin Rights: %s\r\n\r\n", cstrAnswer);
   	   fputs(cstrLine, fptr);

	   cstrLine.Format("Client Priviledge Details: %s\r\n\r\n", m_cstrClientPrivDetail);
	   fputs(cstrLine, fptr);

	   cstrLine.Format("Server Priviledge Details: %s\r\n\r\n", m_cstrServerPrivDetail);
	   fputs(cstrLine, fptr);

	   cstrLine = "======================================================\r\n";
	   fputs(cstrLine, fptr);

  	   CString cstrError = "No Error Found!";
	   CString cstrSolution = "No Solution Needed!";

       WIErrorInfo *pErrorInfo = NULL;
	   int iSize = m_arNonIgnorableErrorArray.GetSize();
	   if (iSize) //print out first error found...
 		  pErrorInfo = m_arNonIgnorableErrorArray.GetAt(1); //HACKHACK, 0 is no error record, 1 is first error

	   if (pErrorInfo)
	   {
          cstrError    = pErrorInfo->cstrError;
          cstrSolution = pErrorInfo->cstrSolution;
	   }

   	   cstrLine.Format("Believed Error Found:\r\n\r\n%s\r\n\r\n", cstrError);
	   fputs(cstrLine, fptr);

   	   cstrLine.Format("Proposed Solution To Error:\r\n  %s\r\n\r\n", cstrSolution);
	   fputs(cstrLine, fptr);

       fclose(fptr);
	   fptr = NULL;
	}
}
//end 5-4-2001

//5-4-2001
void CLogAnalyzeDlg::DoPolicyResults(CString &cstrFileName)
{
	FILE *fptr;
    fptr = fopen(cstrFileName, "w");
	if (fptr)
	{
	   CString cstrLine;
	   cstrLine.Format("Policies Set For Log File %s\r\n", m_cstrLogFileName);
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n\r\n";
	   fputs(cstrLine, fptr);

	   cstrLine = "Machine Policies\r\n";
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n";
	   fputs(cstrLine, fptr);

	   int iSize = m_MachinePolicySettings.iNumberMachinePolicies;
	   CString cstrValue;
	   for (int i =0; i < iSize; i++)
	   {
           if (m_MachinePolicySettings.MachinePolicy[i].bSet == -1)
			  cstrValue = "?";
		   else 
			  cstrValue.Format("%d", m_MachinePolicySettings.MachinePolicy[i].bSet);

		   cstrLine.Format("%-25s: %s\r\n", m_MachinePolicySettings.MachinePolicy[i].PolicyName, cstrValue);
		   fputs(cstrLine, fptr);
	   }

	   cstrLine = "\r\nUser Policies\r\n";
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n";
	   fputs(cstrLine, fptr);

   	   int iSize2 = m_UserPolicySettings.iNumberUserPolicies;
	   for (int j =0; j < iSize2; j++)
	   {
           if (m_UserPolicySettings.UserPolicy[j].bSet == -1)
			  cstrValue = "?";
		   else 
			  cstrValue.Format("%d", m_UserPolicySettings.UserPolicy[j].bSet);

		   cstrLine.Format("%-25s: %s\r\n", m_UserPolicySettings.UserPolicy[j].PolicyName, cstrValue);
           fputs(cstrLine, fptr);
	   }

       fclose(fptr);
	   fptr = NULL;
	}
}
//5-4-2001


void CLogAnalyzeDlg::DoErrorResults(CString &cstrFileName)
{
	FILE *fptr;
    fptr = fopen(cstrFileName, "w");
	if (fptr)
	{
	   CString cstrLine;
	   cstrLine.Format("Errors Found For Log File %s\r\n", m_cstrLogFileName);
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n\r\n";
	   fputs(cstrLine, fptr);

	   cstrLine.Format("%d Non-Ignored Errors\r\n", m_iTotalNonIgnoredErrors);
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n";
	   fputs(cstrLine, fptr);


	   {
       CString cstrError = "No Error Found!";
	   CString cstrSolution = "No Solution Needed!";

       WIErrorInfo *pErrorInfo = NULL;
	   int iSize = m_arNonIgnorableErrorArray.GetSize();
	   if (iSize) //print out first error found...
 		  pErrorInfo = m_arNonIgnorableErrorArray.GetAt(1); //HACKHACK, 0 is no error record, 1 is first error

	   if (iSize)
	   {
	     for (int i =1; i < iSize; i++)
		 {
			 pErrorInfo = m_arNonIgnorableErrorArray.GetAt(i);
	         if (pErrorInfo)
			 {
                cstrError    = pErrorInfo->cstrError;
                cstrSolution = pErrorInfo->cstrSolution;
			 }

			 cstrLine = "-------------------------------------------------\r\n";
             fputs(cstrLine, fptr);

             cstrLine.Format("Believed Error Found:\r\n%s\r\n\r\n", cstrError);
	         fputs(cstrLine, fptr);

             cstrLine.Format("Proposed Solution To Error:\r\n  %s\r\n\r\n", cstrSolution);
	         fputs(cstrLine, fptr);
		 }
	   }
	   else //no error!!!
	   {
	       cstrLine = "-------------------------------------------------\r\n";
           fputs(cstrLine, fptr);

  	       cstrLine.Format("Believed Error Found:\r\n%s\r\n\r\n", cstrError);
	       fputs(cstrLine, fptr);

           cstrLine.Format("Proposed Solution To Error:\r\n  %s\r\n\r\n", cstrSolution);
           fputs(cstrLine, fptr);
	   }
	   }
		
   	   cstrLine.Format("\r\n%d Ignored Errors\r\n", m_iTotalIgnoredErrors);
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n";
	   fputs(cstrLine, fptr);

	   {
       CString cstrError = "No Error Found!";
	   CString cstrSolution = "No Solution Needed!";

       WIErrorInfo *pErrorInfo = NULL;
	   int iSize = m_arIgnorableErrorArray.GetSize();
	   if (iSize) //print out first error found...
 		  pErrorInfo = m_arIgnorableErrorArray.GetAt(1); //HACKHACK, 0 is no error record, 1 is first error

	   if (iSize)
	   {
	     for (int i =1; i < iSize; i++)
		 {
			 pErrorInfo = m_arIgnorableErrorArray.GetAt(i);
	         if (pErrorInfo)
			 {
                cstrError    = pErrorInfo->cstrError;
                cstrSolution = pErrorInfo->cstrSolution;
			 }

			 cstrLine = "-------------------------------------------------\r\n";
             fputs(cstrLine, fptr);

             cstrLine.Format("Believed Error Found:\r\n%s\r\n\r\n", cstrError);
	         fputs(cstrLine, fptr);

             cstrLine.Format("Proposed Solution To Error:\r\n  %s\r\n\r\n", cstrSolution);
	         fputs(cstrLine, fptr);
		 }
	   }
	   else //no error!!!
	   {
		   cstrLine = "-------------------------------------------------\r\n";
           fputs(cstrLine, fptr);

		   cstrLine.Format("Believed Error Found:\r\n%s\r\n\r\n", cstrError);
	       fputs(cstrLine, fptr);

           cstrLine.Format("Proposed Solution To Error:\r\n  %s\r\n\r\n", cstrSolution);
           fputs(cstrLine, fptr);
	   }
	   }

       fclose(fptr);
	   fptr = NULL;
	}	
}


void CLogAnalyzeDlg::DoQuietModeResults()
{
	CString cstrFileName;

	//get only log file name...
	int iPos = m_cstrLogFileName.ReverseFind('\\');
	CString strLogNameOnly;

	strLogNameOnly = m_cstrLogFileName;

	char *lpszBuffer = { 0 };
	lpszBuffer = m_cstrLogFileName.GetBuffer(MAX_PATH);

	if (iPos > 0)
	   strLogNameOnly = &lpszBuffer[iPos+1];
    m_cstrLogFileName.ReleaseBuffer();

	CString cstrLogSummary;
	cstrLogSummary = strLogNameOnly + "_Summary.txt";
	cstrFileName =  m_cstrOutputDir + cstrLogSummary;
    DoSummaryResults(cstrFileName);

    CString cstrLogPolicies;
	cstrLogPolicies = strLogNameOnly + "_Policies.txt";
	cstrFileName =  m_cstrOutputDir + cstrLogPolicies;
	DoPolicyResults(cstrFileName);

    CString cstrLogErrors;
	cstrLogErrors = strLogNameOnly + "_Errors.txt";
	cstrFileName =  m_cstrOutputDir + cstrLogErrors;
    DoErrorResults(cstrFileName);
}



BOOL CLogAnalyzeDlg::DoDetectError(char *szLine, BOOL *pbIgnorableError)
{
	BOOL bRet = FALSE;

	int indexStop = LINES_ERROR; 

	if (m_LineCount >= LINES_ERROR)
	{
	  for (int i = 0; i < LINES_ERROR-1; i++)
          strcpy(&m_szErrorLines[i][0], &m_szErrorLines[i+1][0]);

	  strcpy(&m_szErrorLines[i][0], szLine);
	}
	else
	{
//first few lines are header of log...
	   indexStop =  m_LineCount+1;
	   strcpy(&m_szErrorLines[m_LineCount][0], szLine);
	}


	BOOL bInternalInstallerError = FALSE;
	BOOL bOtherError = FALSE;

	int iErrorNumber;

	char szSolutions[SOLUTIONS_BUFFER] = "Could not determine solution";
	bRet = m_LogParser.DetectCustomActionError(szLine, szSolutions, pbIgnorableError);
    if (!bRet) //check the other types of possible errors...
	{
		bRet = m_LogParser.DetectInstallerInternalError(szLine, szSolutions, pbIgnorableError, &iErrorNumber);
        if (!bRet)
		{
		   bRet = m_LogParser.DetectWindowsError(szLine, szSolutions, pbIgnorableError);
		   if (!bRet)
		   {
              bRet = m_LogParser.DetectOtherError(szLine, szSolutions, pbIgnorableError, &iErrorNumber);
			  if (bRet)
                 bOtherError = TRUE; //1601, etc...
		   }
		}
	    else
		{
  	   	   bInternalInstallerError = TRUE; //2351, etc...
		}
	}

	if (bRet)
	{
  	   m_cstrError = &m_szErrorLines[0][0];

	   CString temp;
	   int len;
       for (int i=1; i < indexStop; i++)
	   {
           len = strlen(&m_szErrorLines[i][0]);

		   temp = &m_szErrorLines[i][0];
           
//5-10-2001...
           if (i == indexStop-1)
		   {
              if ((!bInternalInstallerError && !bOtherError) || //not an error we are going to provide HTML link to?
				  g_bRunningInQuietMode) //don't put HTML tags in error number if running in quiet mode...
                 m_cstrError += temp;
			  else //not quiet mode and an error we can generate an HTML jump tag too in our error help file..
			  {
			     if (bInternalInstallerError)
				 {
/*
					char szLine[8192];
					char *szErrFound;

					strcpy(szLine, &m_szErrorLines[i][0]);

					CString strErr;
					strErr.Format("%d", iErrorNumber);
					szErrFound = strstr(szLine, strErr);
					if (szErrFound)
					{
                       //replace the error with an HREF!!!
                       CString strURL;

	  	  	  	       CString cstrOut;
                       cstrOut = m_cstrOutputDir + "\\" + "InternalWIErrors.html";
					   cstrOut.Replace('\\', '/');

					   strURL.Format("file:///%s#ERR%d", cstrOut, iErrorNumber);

//					   strURL.Format("http://www.msn.com");
//					   strURL.Format("file:///%s#ERR%d", cstrOut, iErrorNumber);

	                  
					   int n;
					   char szFirstPart[8192];
					   n = szErrFound - szLine;
					   strncpy(szFirstPart, szLine, n);
                       szFirstPart[n] = '\0';
 
                       CString cstrOutLine;
					   cstrOutLine.Format("%s %s %s", szFirstPart, strURL, szErrFound+4);

					   m_cstrError += cstrOutLine;
					}
*/
					m_cstrError += temp;
				 } 

			     if (bOtherError)
				 {
                    m_cstrError += temp;
				 }
			  }
		   }
		   else
		   {
              m_cstrError += temp;
		   }
//end 5-10-2001...
	   }

       m_cstrSolution = szSolutions;

	   WIErrorInfo *pErrorInfo = new WIErrorInfo;
	   if (pErrorInfo)
	   {
 	      pErrorInfo->cstrError = m_cstrError;
	      pErrorInfo->cstrSolution = szSolutions;
		  pErrorInfo->bIgnorableError = *pbIgnorableError;

//hack hack, makes easier to handle next/previous as this makes array become 1 based, not 0.
		  if ((m_iTotalNonIgnoredErrors == 0) && (!*pbIgnorableError))
		  {
			 WIErrorInfo *pErrorInfo2 = new WIErrorInfo;

			 pErrorInfo2->cstrError.LoadString(IDS_NOERRORFOUND);
			 pErrorInfo2->cstrSolution.LoadString(IDS_NOSOLUTION_NEEDED);
             pErrorInfo2->bIgnorableError = TRUE;

             m_arNonIgnorableErrorArray.Add(pErrorInfo2); //adds first one twice...
		  }

  		  if ((m_iTotalIgnoredErrors == 0) && (*pbIgnorableError))
		  {
			 WIErrorInfo *pErrorInfo2 = new WIErrorInfo;
			 pErrorInfo2->cstrError = "No Error Found!";
    		 pErrorInfo2->cstrSolution = "No solution needed!";
             pErrorInfo2->bIgnorableError = TRUE;

             m_arIgnorableErrorArray.Add(pErrorInfo2); //adds first one twice...
		  }

		 if (!*pbIgnorableError)
		 {
            m_arNonIgnorableErrorArray.Add(pErrorInfo);
            m_iTotalNonIgnoredErrors++;			
		 }
		 else
		 {
            m_arIgnorableErrorArray.Add(pErrorInfo);

			m_iTotalIgnoredErrors++;
		 }
	   }
	   else
	   {
		   //out of memory!!!
	   }
	}

	return bRet;
}


//this is tricky
BOOL CLogAnalyzeDlg::DoDetectProperty(char *szLine)
{
	BOOL bRet = FALSE;

    char szPropName[128] = { 0 };
    char szPropValue[8192] = { 0 };

	int iPropType;

	bRet = m_LogParser.DetectProperty(szLine, szPropName, szPropValue, &iPropType);
	if (bRet)
	{
		if (SERVER_PROP == iPropType)
		{
		   m_cstrServerPropNameArray.Add(szPropName);
		   m_cstrServerPropValueArray.Add(szPropValue);
		}

		if (CLIENT_PROP == iPropType)//client prop
		{
      	   m_cstrClientPropNameArray.Add(szPropName);
		   m_cstrClientPropValueArray.Add(szPropValue);
		}

		if (NESTED_PROP == iPropType)
		{
      	   m_cstrNestedPropNameArray.Add(szPropName);
		   m_cstrNestedPropValueArray.Add(szPropValue);
		}
	}

	return bRet;
}


BOOL CLogAnalyzeDlg::DoDetectStates(char *szLine)
{
	BOOL bRet = FALSE;
	static BOOL bFeatureStateLast = FALSE;
    static BOOL bFeatreState = TRUE;

    char szName[128] = { 0 };
    char szInstalled[64] = { 0 };
	char szRequest[64] = { 0 };
	char szAction[64] = { 0 };

	bRet = m_LogParser.DetectFeatureStates(szLine, szName, szInstalled, szRequest, szAction);
	if (bRet)
	{
	   m_cstrFeatureNameArray.Add(szName);
	   m_cstrFeatureInstalledArray.Add(szInstalled);
	   m_cstrFeatureRequestArray.Add(szRequest);
	   m_cstrFeatureActionArray.Add(szAction);
	}
	else
	{
	   BOOL bInternalComponent = FALSE;
 	   bRet = m_LogParser.DetectComponentStates(szLine, szName, szInstalled, szRequest, szAction, &bInternalComponent);
	   if (bRet)
	   {
//5-16-2001
          if (!g_bShowEverything && bInternalComponent)
		  {
             //don't show it in our UI, but do in HTML.
			 //it was an internal component and verbose switch is not set by end user...
		  }
//end 5-16-2001
		  else
		  {
  		     m_cstrComponentNameArray.Add(szName);
		     m_cstrComponentInstalledArray.Add(szInstalled);
		     m_cstrComponentRequestArray.Add(szRequest);
		     m_cstrComponentActionArray.Add(szAction);
		  }
	   }
	}

	return bRet;
}


BOOL CLogAnalyzeDlg::DoDetectPolicy(char *szLine)
{
	BOOL bRet = FALSE;

    bRet = m_LogParser.DetectPolicyValue(szLine, m_MachinePolicySettings, m_UserPolicySettings);
    return bRet;
}


BOOL CLogAnalyzeDlg::DoDetectElevatedInstall(char *szLine)
{
	BOOL bRet = FALSE;
	BOOL bElevatedInstall = FALSE;
	BOOL bClient = FALSE;

    bRet = m_LogParser.DetectElevatedInstall(szLine, &bElevatedInstall, &bClient);
	if (bRet)
	{
		m_bAdminRights = bElevatedInstall;
        StripLineFeeds(szLine);

		if (bClient)
  	       m_cstrClientPrivDetail = szLine;
		else
		{
		   m_cstrServerPrivDetail = m_cstrLastLine;
           m_cstrServerPrivDetail += szLine;
		}

		if (!g_bRunningInQuietMode)
		   UpdateData(FALSE); //update controls...
	}

    return bRet;
}


//header is in first ten lines or so...
#define HEADER_END 10

//first see if version of log is supported
//we parse the date/time, product, user and the commandline
//Then we will start parsing each line in log
BOOL CLogAnalyzeDlg::DoParse(char *ansibuffer)
{
    int iLineLength = strlen(ansibuffer);

    //line is read in now
    BOOL bState = FALSE;

//following is done to speed up parsing by not doing header stuff every time...
	if (m_LineCount == 1) //parsing first line in file?
	{
       bState = m_LogParser.DetectWindowInstallerVersion(ansibuffer, &m_dwVersionMajorLogCreated, &m_dwVersionMinorLogCreated,  &m_dwVersionBuildLogCreated);

	   m_cstrVersion.Format("%d.%d.%d", m_dwVersionMajorLogCreated, m_dwVersionMinorLogCreated,  m_dwVersionBuildLogCreated);

	   if (!g_bShowEverything)  //go ahead and try to parse any version if hidden switch is on...
	   {
	      if (m_dwVersionMajorLogCreated > m_dwVersionMajorReject) //major version is too great...
		  {
             m_bLogVersionAllowed = FALSE; //stop the logging process...
		     bState = TRUE;
		     return bState;
		  }

	      //major version may be equal or greater and minor version may be too high...
	      if ( (m_dwVersionMajorLogCreated >= m_dwVersionMajorReject) && 
		     (m_dwVersionMinorLogCreated >= m_dwVersionMinorReject))
		  {
             m_bLogVersionAllowed = FALSE; //stop the logging process...
 		     bState = TRUE;
		     return bState; 
		  }
	   }
	}

/*  5-16-2001
	//do date/time
  	if (m_LineCount == 1)				
	{
 		char szDateTime[256];
        bState = m_LogParser.DoDateTimeParse(ansibuffer, szDateTime);              
		if (bState)
		{
			m_cstrDateTime = szDateTime;
		}
	}
*/
//end optimization...

//maybe we could speed up further by checking if m_cstrProduct is non-null?
//nmanis, 2-13-2001, added check below...

//5-16-2001, deemed that this info is not too useful
/*
	//do product parse (everytime until we find it...)
	if (!bState && m_cstrProduct.IsEmpty())
	{
	   char *lpszProduct;
	   lpszProduct = new char[iLineLength];

       bState = m_LogParser.DoProductParse(ansibuffer, lpszProduct);
	   if (bState)
	   {
		  m_cstrProduct = lpszProduct;
	   }

	   delete lpszProduct;
	}
*/

    //do user parse...
    if (!bState)
	{
	   char *lpszUser;
	   lpszUser = new char[iLineLength];

       bState = m_LogParser.DoUserParse(ansibuffer, lpszUser);
	   if (bState)
	   {
		  m_cstrUser = lpszUser;
	   }

	   delete lpszUser;
	}

	//do client command line
	if (m_LineCount <= HEADER_END && !bState)
	{
	   char *lpszCommandLine;
	   lpszCommandLine = new char[iLineLength];
 
	   bState = m_LogParser.DoCommandLineParse(ansibuffer, lpszCommandLine);
	   if (bState)
	   {
          m_cstrClientCMD = lpszCommandLine;
	   }

	   delete lpszCommandLine;
	}

	if (!bState)
	{
       BOOL bIgnorableError = FALSE;
	   
//Added next line back as of Ver 1.0.9
	   bState = DoDetectError(ansibuffer, &bIgnorableError);
	   if (!bState)
	   {
	      bState = DoDetectProperty(ansibuffer);
		  if (!bState)
		  {
             bState = DoDetectStates(ansibuffer);
		     if (!bState)
			 {
                bState = DoDetectPolicy(ansibuffer);
  		        if (!bState)
				{
				    bState = DoDetectElevatedInstall(ansibuffer);
					if (!bState)
					{
                       AddGenericLineToHTML(ansibuffer); //who knows...  annotate with usual stuff...
					}
					else
                    {
                       AddGenericLineToHTML(ansibuffer); //still add line as a generic line to HTML, this could change however...
					}
				}
				else //hit policy line
				{
					AddPolicyLineToHTML(ansibuffer);
				}
			 }
			 else //hit state line...
			 {
                AddStateLineToHTML(ansibuffer);
			 }
		  }
		  else //hit property line...
		  {
             AddPropLineToHTML(ansibuffer);
		  }
	   }
	   else //hit error line...
	   {
          AddErrorLineToHTML(ansibuffer, bIgnorableError);
		  m_bErrorFound = TRUE; //mark current log as having an error we found...
	   }
	}
	else //5-16-2001, make sure header is added too...
	{
       AddGenericLineToHTML(ansibuffer); //still add line as a generic line to HTML, this could change however...
	}

	return bState;
}


BOOL CLogAnalyzeDlg::AnalyzeLog()
{
	//5-3-2001
	DoInitialization();

	BOOL bRet = DetermineLogType(m_cstrLogFileName, &m_bIsUnicodeLog);
	if (bRet)
	{
		//Tell parser object what kind of log we are looking at...
		m_LogParser.SetLogType(m_bIsUnicodeLog);

		char *szOpenMode = "rb";
	    if (!m_bIsUnicodeLog) //logs are different on NT vs.Win9x.  On NT, they are written in UNICODE, open them differently...
           szOpenMode = "r"; //don't open binary if Win9x...

	    FILE *fptr = fopen(m_cstrLogFileName, szOpenMode);
	    if (fptr) //open log...
		{
	       char ansibuffer[LOG_BUF_READ_SIZE+1]; //+1, room to grow...

	       BOOL bEndFile = FALSE;
		   BOOL bError = FALSE;
		   char  *pos = NULL;
		   WCHAR *wpos = NULL;

		   CWaitCursor *pwc = NULL;
	
		   //need to make sure wait cursor does not appear when in quiet mode...
           if (!g_bRunningInQuietMode)
		   {
  	          pwc = new CWaitCursor; //show wait cursor while reading/processing file...
		   }

		   do //start reading log
		   {
		     if (m_bIsUnicodeLog) //logs are different on NT vs. Win9x.  On NT, they are written in UNICODE...
			 {
			    const int HalfBufSize = LOG_BUF_READ_SIZE/2;
		        WCHAR widebuffer[HalfBufSize];

			    wpos = fgetws(widebuffer, HalfBufSize, fptr);
			    bError = wpos ? 0 : 1;

				//convert string to ANSI string, all parsing is done with ANSI strings...
		        WideCharToMultiByte(CP_ACP, 0, widebuffer, HalfBufSize, ansibuffer, LOG_BUF_READ_SIZE, NULL, NULL);
			 }
		     else
			 {
		        //do line by line read with fgets()
		        pos = fgets(ansibuffer, LOG_BUF_READ_SIZE, fptr);
			    bError = pos ? 0 : 1;

//minor hack...
				StripLineFeeds(ansibuffer);
				strcat(ansibuffer, "\r\n");
//minor hack...
			 }

 			 if (!bError) //if line read ok...
			 {
				m_LineCount++; //if no error increment line number just read
				bRet = DoParse(ansibuffer); //bRet will be true if was able to figure out what the line was...

				m_cstrLastLine = ansibuffer; //save last line... 2-13-2001
			 }

		     bEndFile = feof(fptr);
		   }
		   while (!bEndFile && !bError && m_bLogVersionAllowed);

		   if (!g_bRunningInQuietMode)
		   {
  	          if (pwc)
			  {
				  delete pwc;
				  pwc = NULL;
			  }
		   }

		   if (!bEndFile && !bError) //error occured...
		   {
#ifdef _DEBUG
		      if (!g_bRunningInQuietMode)
			  {
				 if (fptr)
				 {
  		            int iError = ferror(fptr);

		            CString cstrErr;
		            cstrErr.Format("Unexpected Error reading file, error = %d", iError);

                    AfxMessageBox(cstrErr);
				 }
			  }
#endif
		   }

		   fclose(fptr);

		   if (m_bLogVersionAllowed) //if this log is allowed, we will update GUI
		   {
  		      if (!m_bErrorFound)
			  {
                 AddErrorLineSuccessToHTML(); //no error hit, update Error area too...
		         m_cstrError = "No Error was found!  Install succeeded?";
			  }

	   	      //update GUI with info now...
              if (!g_bRunningInQuietMode)
                 UpdateData(FALSE);
		   }
		   else
		   {
			   ShowLogRejectedMessage(); //5-16-2001
		   }
		}
	    else  //error opening file, unexpected...
		{
		   if (!g_bRunningInQuietMode)
		   {
		      DWORD dwErr = GetLastError();		  

		      CString cstrErr;
		      cstrErr.Format("Unexpected Error reading file, error = %d", dwErr);

              AfxMessageBox(cstrErr);

		      //do something with dwErr
		   }
		}
	}
	else
	{
		//something wrong with log file, unexpected...  Can't tell if UNICODE or ANSI log
		ASSERT(1);

		 if (!g_bRunningInQuietMode)
		 {
		    //AfxMessageBox("Could not determine if log is UNICODE or ANSI");
		 }
	}

	//5-3-2001
    if (!g_bRunningInQuietMode)
	{
       DoResults();
	}
	else
	{
       //dump the output to HTML File...
       CString cstrOutputHTMLFile;
       DumpHTMLToFile(cstrOutputHTMLFile); //output HTMLized log file...

	   //generate quite mode results...
	   DoQuietModeResults();
	}
	//end, 5-3-2001

	return bRet;
}


//--------------------------------------------------------------------------------------------------
//
//
//  HTML Processing functions below here...
//
//
//--------------------------------------------------------------------------------------------------

/*
Each line in the log file begins with:

	MSI (a) (bbcdd):

where:
a is the type of process (c - client, s - service, a - custom action server)
bb is the last two hex digits of the process id
c is : for a thread acting as itself and ! for a thread acting in the context of a custom action request,
dd is the last two hex digits of the thread id in process bb, unless c is !, in which case it is the last two digits of the thread id in the process hosting the custom action on whose behalf the current thread is acting.

With the understanding that this information is subject to change without notice, you can 
use this information however you wish. Color coding is one possibility. Most of it is not 
very interesting because in the log file it is usually all the same (except for 
client/service). When monitoring debug output, it can be more interesting.


*/

enum 
{
	client = 'c', service = 's', customaction = 'a'
} ProcessTypesEnum;


void FormatFontColorIntoHTML(CString &strFontTag, COLORREF col)
{
	strFontTag.Format("%c#%02x%02x%02x%c>", '"', GetRValue(col),
		              GetGValue(col),
				      GetBValue(col), '"');
			  
}



void CLogAnalyzeDlg::WriteLineWithColor(char *szLine, COLORREF col, CString &cstrLabel)
{
  CString cstrHeader = "<font color="; 
  CString cstrFontColor = "";
  CString cstrFooter = "</font><BR>";

  CString cstrLine = szLine;  

  FormatFontColorIntoHTML(cstrFontColor, col);

  CString line2;
  line2 = cstrHeader + cstrFontColor + cstrLabel + cstrLine + cstrFooter;

  m_cstrHTML.Add(line2);
}


void CLogAnalyzeDlg::AddGenericLineToHTML(char *szLine)
{
  char cTypeProcess  = 0; //c, s, or a
  char cThreadContext = 0; //: or !

  const char *pszProcessTypeToken = "MSI (";
  const char *pszThreadContextToken = ") (";

  //parse line...
  char *pos = strstr(szLine, pszProcessTypeToken);
  if (pos)
  {
	  int lenbuff = strlen(szLine);
	  int lenToken = strlen(pszProcessTypeToken);

	  if (lenbuff > lenToken)
	  {
  	    cTypeProcess = *(pos + lenToken);

		pos = strstr(szLine, pszThreadContextToken);
		if (pos)
		{
           lenToken = strlen(pszProcessTypeToken);
	   	   if (lenbuff > lenToken)
              cThreadContext = *(pos + lenToken); //: or !
        }
	  }
  }

  CString cstrLabel;
  if (cTypeProcess && cThreadContext)
  {
	 switch (cTypeProcess)
	 {
	    case 'c':
	    case 'C': cstrLabel = "(CLIENT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
			      WriteLineWithColor(szLine, m_colClientContext, cstrLabel);
			      break;

	    case 's':
	    case 'S': cstrLabel = "(SERVER)&nbsp;&nbsp&nbsp;&nbsp;&nbsp";
			      WriteLineWithColor(szLine, m_colServerContext, cstrLabel);
			      break;

	    case 'a':
	    case 'A': cstrLabel = "(CUSTOM)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
			      WriteLineWithColor(szLine, m_colCustomActionContext, cstrLabel);
			      break;

		default:  cstrLabel = "(UNKNOWN)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
                  WriteLineWithColor(szLine, m_colUnknownContext, cstrLabel);
	 }
  }
  else
  {
	  cstrLabel = "(UNKNOWN)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
      WriteLineWithColor(szLine, m_colUnknownContext, cstrLabel);
  }
}


void CLogAnalyzeDlg::AddErrorLineSuccessToHTML()
{
  CString cstrErrorBookmark = "<p> <a name=""ERRORAREA_1""></a></p>"; 	
  m_cstrHTML.Add(cstrErrorBookmark); //this is added at bottom if we hit no error
}


void CLogAnalyzeDlg::AddErrorLineWorker(char *szLine, BOOL bIgnored)
{
  if (!bIgnored)
  {
     CString cstrLabel = "(ERROR)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
     WriteLineWithColor(szLine, m_colErrorArea, cstrLabel);
  }
  else
  {
     CString cstrLabel = "(IGNORED)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
     WriteLineWithColor(szLine, m_colIgnoredError, cstrLabel);
  }
}



#define HTML_ERROR_LINES LINES_ERROR

void CLogAnalyzeDlg::AddErrorLineToHTML(char *szLine, BOOL bIgnored)
{
	if (!bIgnored) //non-ignorable error???
	{
       CString cstrErrorBookmark;
       cstrErrorBookmark.Format("<p> <a name=%cERRORAREA_%d%c></a></p>", '"',  m_iTotalNonIgnoredErrors, '"');

	   if (m_LineCount > HTML_ERROR_LINES)
	   {

/* 5-16-2001 fix up for errors, in HTML, only show the error found, not the context...
/*
	      int nCount = m_cstrHTML.GetSize();
	      int RemovePos;
          for (int i=0; i < HTML_ERROR_LINES; i++)
		  {
              RemovePos = nCount - i - 1;
	          if (RemovePos > 0)
			  {
                 m_cstrHTML.RemoveAt(RemovePos);
			  }
		  }
*/

		  m_cstrHTML.Add(cstrErrorBookmark);     //add bookmark
		  m_cstrHTML.Add("NOTE: Look at few lines above for clues on error<BR>"); //add error area stuff after error block

		  AddErrorLineWorker(szLine, bIgnored);

/* 5-16-2001 fix
          for (i=0; i < HTML_ERROR_LINES; i++)
		  {
		      AddErrorLineWorker(&m_szErrorLines[i][0], bIgnored);
		  }
*/
	   }
   	   else
	   {
		  m_cstrHTML.Add(cstrErrorBookmark);     //add bookmark
		  m_cstrHTML.Add("<BR>"); //add error area stuff after error block

	      AddErrorLineWorker(szLine, bIgnored);
	   }
	}
	else //ignorable errors, just ignore this one line....
	{
       AddErrorLineWorker(szLine, bIgnored);
	}
}


void CLogAnalyzeDlg::AddPropLineToHTML(char *szLine)
{
   CString cstrLabel = "(PROPERTY)&nbsp";
   WriteLineWithColor(szLine, m_colProperty, cstrLabel);
}

void CLogAnalyzeDlg::AddStateLineToHTML(char *szLine)
{
   CString cstrLabel = "(STATE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
   WriteLineWithColor(szLine, m_colState, cstrLabel);
}

void CLogAnalyzeDlg::AddPolicyLineToHTML(char *szLine)
{
   CString cstrLabel = "(POLICY)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
   WriteLineWithColor(szLine, m_colPolicy, cstrLabel);
}

// 2-12-2001 changed function name to more appropriate name...
BOOL WriteHTMLResourceToFile(int ResourceName, CString &szFileName)
{
   BOOL bRet = TRUE;

   HMODULE hmod = GetModuleHandle(NULL);
   HRSRC hrsrc = FindResource(hmod, MAKEINTRESOURCE(ResourceName), RT_HTML);
   if (hrsrc)
   {
	  HGLOBAL res = LoadResource(hmod, hrsrc);
	  if (res)
	  {
		  DWORD dwSize = SizeofResource(hmod, hrsrc);
		  LPVOID pVoid = LockResource(res);
		  if (pVoid)
		  {
			 DWORD dwWritten = 0;
  		     FILE  *fptr = fopen(szFileName, "wb");
             if (fptr)
			 {
                dwWritten = fwrite(pVoid, dwSize, 1, fptr);
				ASSERT(1 == dwWritten);
				fclose(fptr);
			 }
		  }
	  }
  }

  return bRet;
}

void AddJumpTags(FILE *fptr, CString &cstrDetailsName, int MaxErrors)
{
	if (fptr)
	{
      HMODULE hmod = GetModuleHandle(NULL);
      HRSRC hrsrc = FindResource(hmod, MAKEINTRESOURCE(IDR_JUMPTAGS), RT_HTML);
      if (hrsrc)
	  {
	     HGLOBAL res = LoadResource(hmod, hrsrc);
	     if (res)
		 {
		    DWORD dwSize = SizeofResource(hmod, hrsrc);
		    LPVOID pVoid = LockResource(res);
		    if (pVoid)
			{
			   DWORD dwWritten = 0;
               dwWritten = fwrite(pVoid, dwSize, 1, fptr);
			   ASSERT(1 == dwWritten);

			   CString strTags;

			   strTags.Format("\n<script language=%cjavascript%c>\n", '"', '"');
			   fputs(strTags, fptr);

			   strTags.Format("var MaxErrors = %d;\n", MaxErrors);
			   fputs(strTags, fptr);

			   //"details_123.htm"
			   cstrDetailsName.Replace('\\', '/');
			   strTags.Format("var DetailsName = %cfile:///%s%c;\n", '"', cstrDetailsName, '"');
			   fputs(strTags, fptr);

   			   strTags.Format("</script>\n");
			   fputs(strTags, fptr);
			}
		 }
	  }
	}
}



//new function to write legend on fly...
BOOL WriteHTMLLogLegend(CString &cstrFilename, CString &cstrDetailsName, int iTotalErrors)
{
  BOOL bRet = TRUE;

  FILE *fptr;
  fptr = fopen(cstrFilename, "wb");
  if (fptr)
  {
	CString strTags;

	strTags = "<HTML>";
	fputs(strTags, fptr);

	strTags = "<BODY>";
	fputs(strTags, fptr);

	fputs("LEGEND", fptr);

    strTags.Format("<TABLE BORDER=1 WIDTH=%c100%c>", '"', '"');
	fputs(strTags, fptr);

    strTags = "<TR>";
	fputs(strTags, fptr);

	HTMLColorSettings settings1;

	InitHTMLColorSettings(settings1);
	CArray<COLORREF, COLORREF> arColors;

	CWILogUtilApp *pApp = (CWILogUtilApp *) AfxGetApp();
	if (pApp)
    {
	   pApp->GetUserColorSettings(arColors);
	   if (arColors.GetSize() == MAX_HTML_LOG_COLORS)
	   {
  	      CString strRowTagStart = "<TD><font color=";
  	      CString strRowTagEnd = "</font></TD>";
		  CString strFontTag;

		  CString strTableRow;
		  COLORREF col;
	      for (int i=0; i < MAX_HTML_LOG_COLORS; i++)
		  {
              col = arColors.GetAt(i);
			  strFontTag.Format("%c#%02x%02x%02x%c>""%s", '"', GetRValue(col), GetGValue(col),
				                GetBValue(col), '"', settings1.settings[i].name);
			  
			  strTableRow = strRowTagStart + strFontTag + strRowTagEnd;
              fputs(strTableRow, fptr);
		  }
	   }
	}

    strTags = "</TR>";
	fputs(strTags, fptr);

    strTags = "</TABLE>";
	fputs(strTags, fptr);

	AddJumpTags(fptr, cstrDetailsName, iTotalErrors);

	strTags = "</BODY>";
	fputs(strTags, fptr);

	strTags = "</HTML>";
	fputs(strTags, fptr);

	fclose(fptr);
  }
  else
  {
     bRet = FALSE;

     //file write failed for legend HTML file
     if (!g_bRunningInQuietMode)
	 {
        CString cstrErr;
        cstrErr.Format("Unexpected error when writing legend file");

	    AfxMessageBox(cstrErr);
	 }
  }

  return bRet;
}




BOOL CLogAnalyzeDlg::WriteHTMLFrame(CString &cstrHTMLFrame, CString &cstrOutputHTMLFile, CString &cstrLegendHTMLFile)
{
  BOOL bRet = FALSE;

  FILE *fptr;
  fptr = fopen(cstrHTMLFrame, "w");

  if (fptr)
  {
     bRet = TRUE; //set flag to true...

	 CString strTags;

	 strTags = "<HTML><HEAD>";
	 fputs(strTags, fptr);

	 strTags = "<title>Log File Details</title></head>";
	 fputs(strTags, fptr);

	 strTags.Format("<frameset rows=%c150,*%c noresize>\n", '"', '"');
	 fputs(strTags, fptr);

	 strTags.Format("<frame SCROLLING=%cno%c name=%cheader%c target=%cmain%c src=%c%s%c>\n", '"', '"', '"', '"', '"', '"', '"', cstrLegendHTMLFile, '"');
	 fputs(strTags, fptr);

	 strTags.Format("<frame name= %cmain%c src=%c", '"', '"', '"');
	 CString strTags2;
	 strTags2.Format("%s%c>\n", cstrOutputHTMLFile, '"');

	 CString strTags3 = strTags + strTags2;
	 fputs(strTags3, fptr);

   	 strTags = "<noframes><body>\n";
	 fputs(strTags, fptr);

   	 strTags = "<p>This page uses frames, but your browser doesn't support them.</p>Go to log.htm to read this log...";
	 fputs(strTags, fptr);

   	 strTags = "</body></noframes>\n";
	 fputs(strTags, fptr);

     strTags = "</frameset></HTML>";
     fputs(strTags, fptr);

     fclose(fptr);
  }
  else
  {
    //file write failed for HTML frame file
    if (!g_bRunningInQuietMode)
	{
       CString cstrErr;
       cstrErr.Format("Unexpected error open details file");

	   AfxMessageBox(cstrErr);
	}
  }

  return bRet;
}


BOOL CLogAnalyzeDlg::DumpHTMLToFile(CString &cstrOutputHTMLFile)
{
//5-16-2001
   BOOL bRet = IsValidDirectory(m_cstrOutputDir);  //create dir first...
   if (bRet)
   {
      CString cstrOutputTempDir;
      cstrOutputTempDir = m_cstrOutputDir + "TMP\\";

      bRet = IsValidDirectory(cstrOutputTempDir);
      if (bRet)
	  {
  	     //5-17-2001
  	     CString cstrCurrentLogName;
	     cstrCurrentLogName = this->m_cstrLogFileName;

	     cstrCurrentLogName.Replace(':', '_'); //covert colons to _
	     cstrCurrentLogName.Replace('\\', '_'); //convert backslashes to _
	     cstrCurrentLogName.Replace(' ', '_'); //convert spaces to _

         m_cstrDetailsName =  m_cstrOutputDir + "TMP\\" + cstrCurrentLogName + ".HTM";
         //end 5-17-2001

         FILE *fptr;
         fptr = fopen( m_cstrDetailsName, "w");

	     bRet = FALSE; //set flag to false...
         if (fptr)
		 {
	        bRet = TRUE; //set flag to true...

	        CString strTags;
  	        strTags.Format("<HTML><BODY> <p><a name=%cTOP_DETAILS%c></a></p>", '"', '"');
	        fputs(strTags, fptr);
 
            int iCount = m_cstrHTML.GetSize();
            for (int i=0; i < iCount; i++)
			{
	            fputs(m_cstrHTML.GetAt(i), fptr);
			}

 	        strTags.Format("<p> <a name=%cBOTTOM_DETAILS%c></a></p></BODY></HTML>", '"', '"');
   	        fputs(strTags, fptr);

            fclose(fptr);
		    fptr = NULL;

            //5-14-2001
            CString cstrFrameName;
		    cstrFrameName =  m_cstrOutputDir + "Details_" + cstrCurrentLogName + ".HTM";

            m_cstrLegendName = cstrOutputTempDir + "legend_" + cstrCurrentLogName + ".HTM";
            bRet = WriteHTMLFrame(cstrFrameName, m_cstrDetailsName, m_cstrLegendName);
            if (bRet)
			{
  	           cstrOutputHTMLFile = cstrFrameName;
               WriteHTMLLogLegend(m_cstrLegendName, m_cstrDetailsName, m_iTotalNonIgnoredErrors);
			}
		 }
         else
		 {
	        bRet = FALSE;

	        //file write failed for details file, (annotated log)
 	        if (!g_bRunningInQuietMode)
			{
		       CString cstrErr;
		       cstrErr.Format("Unexpected error when writing details file");
               AfxMessageBox(cstrErr);
			}
		 }
	  }
	  else
	  {
         bRet = FALSE; //bad temp dir...
         if (!g_bRunningInQuietMode)
		 {
            CString cstrOutDirMsg;
	        cstrOutDirMsg.Format("Could not create directory %s", cstrOutputTempDir);
	        AfxMessageBox(cstrOutDirMsg);
		 }
	  }
   }
   else //bad out dir...
   {
      bRet = FALSE; //
      if (!g_bRunningInQuietMode)
	  {
         CString cstrOutDirMsg;
	     cstrOutDirMsg.Format("Current directory set for output directory: %s is invalid, please select a new one in Options.", this->m_cstrOutputDir);
	     AfxMessageBox(cstrOutDirMsg);
	  }
   }

   return bRet; //return if worked to caller...
}

//5-16-2001, shows HTML file in default system browser, can be Netscape...
void ShowHTMLFile(CString &cstrDirectory, CString &cstrPath)
{
   if (!g_bRunningInQuietMode)
   {
      char lpszBrowser[MAX_PATH];
      HINSTANCE hInst = FindExecutable(cstrPath, cstrDirectory, lpszBrowser);
      if (hInst > (HINSTANCE)32)
	  {
         ShellExecute(NULL, "open", lpszBrowser, cstrPath, cstrDirectory, SW_SHOWMAXIMIZED);
	  }
      else
	  {
 	     if (!g_bRunningInQuietMode)
            AfxMessageBox("No default browser found for .htm files");	 
	  }
   }
}


//show HTML file...
void CLogAnalyzeDlg::OnExplainlog() 
{
  if (!m_bLogVersionAllowed)
  {
	 ShowLogRejectedMessage();
	 return;
  }

  CString cstrOutputFile;
  BOOL bRet = DumpHTMLToFile(cstrOutputFile); //output HTMLized log file...
  if (bRet)
     ShowHTMLFile(m_cstrOutputDir, cstrOutputFile);
  else
  {
      if (!g_bRunningInQuietMode)
	     AfxMessageBox("Error generating HTML File for current log");
  }
}

#include "PolicyD.h"

void CLogAnalyzeDlg::OnPolicies() 
{
  if (!m_bLogVersionAllowed)
  {
	 ShowLogRejectedMessage();
	 return;
  }

  CPoliciesDlg dlg;

  dlg.SetPolicyInformation(m_MachinePolicySettings, m_UserPolicySettings);

  //5-3-2001, don't show in quiet mode...
  if (!g_bRunningInQuietMode)
     dlg.DoModal();
}

void CLogAnalyzeDlg::OnNexterror() 
{
  if (!m_bShowIgnoredDebugErrors) //showing critical errors only...
  {
	 int iSize = m_arNonIgnorableErrorArray.GetSize();
     if ((m_iCurrentNonIgnoredError < m_iTotalNonIgnoredErrors) && iSize)
	 {
        m_iCurrentNonIgnoredError++;

  	    WIErrorInfo *pErrorInfo;
        pErrorInfo = m_arNonIgnorableErrorArray.GetAt(m_iCurrentNonIgnoredError);
	    if (pErrorInfo)
		{
		  m_cstrSolution = pErrorInfo->cstrSolution;
		  m_cstrError = pErrorInfo->cstrError;

		  if (!g_bRunningInQuietMode)
		     UpdateData(FALSE);
		}
	 }

 	 if (m_iCurrentNonIgnoredError == m_iTotalNonIgnoredErrors)
	 {
	    CWnd *pWnd;
	    pWnd = GetDlgItem(IDC_NEXTERROR);
	    if (pWnd)
		{
	       pWnd->EnableWindow(FALSE);	 
		}
	}

    CWnd *pWnd;
    pWnd = GetDlgItem(IDC_PREVIOUSERROR);
    if (pWnd && (m_iTotalNonIgnoredErrors > 1))
	{
	   if (!pWnd->IsWindowEnabled())
          pWnd->EnableWindow(TRUE);
	}
	else
	{
	   pWnd->EnableWindow(FALSE);
	}


	CString str;
	str.Format("%d", m_iCurrentNonIgnoredError);
	pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
	if (pWnd)
	{
       pWnd->SetWindowText(str);
	}
  } 
  else //showing ignorable errors instead...
  {
	 int iSize = m_arIgnorableErrorArray.GetSize();
     if ((m_iCurrentIgnoredError < m_iTotalIgnoredErrors) && iSize)
	 {
        m_iCurrentIgnoredError++;

  	    WIErrorInfo *pErrorInfo;
        pErrorInfo = m_arIgnorableErrorArray.GetAt(m_iCurrentIgnoredError);
	    if (pErrorInfo)
		{
		  m_cstrSolution = pErrorInfo->cstrSolution;
		  m_cstrError = pErrorInfo->cstrError;

          if (!g_bRunningInQuietMode)
		     UpdateData(FALSE);
		}
	 }
 	    
	 if (m_iCurrentIgnoredError == m_iTotalIgnoredErrors)
	 {
	    CWnd *pWnd;
	    pWnd = GetDlgItem(IDC_NEXTERROR);
	    if (pWnd)
		{
	       pWnd->EnableWindow(FALSE);	 
		}
	 }

     CWnd *pWnd;
	 pWnd = GetDlgItem(IDC_PREVIOUSERROR);
	 if (pWnd && (m_iTotalIgnoredErrors > 1))
	 {
	    if (!pWnd->IsWindowEnabled())
           pWnd->EnableWindow(TRUE);
	 }
	 else
	 {
        pWnd->EnableWindow(FALSE);
	 }

	 CString str;
	 str.Format("%d", m_iCurrentIgnoredError);
	 pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
	 if (pWnd)
	 {
		pWnd->SetWindowText(str);
	 }
  }
}


//handle interating through the previous error found from the current error
void CLogAnalyzeDlg::OnPreviouserror() 
{
  if (!m_bShowIgnoredDebugErrors) //showing critical errors only...
  {
     UINT iSize = m_arNonIgnorableErrorArray.GetSize();
     if ((m_iCurrentNonIgnoredError > 1) && (iSize >= m_iCurrentNonIgnoredError))
	 {
        m_iCurrentNonIgnoredError--;

	    WIErrorInfo *pErrorInfo;
        pErrorInfo = m_arNonIgnorableErrorArray.GetAt(m_iCurrentNonIgnoredError);
	    if (pErrorInfo)
		{
		   m_cstrSolution = pErrorInfo->cstrSolution;
		   m_cstrError = pErrorInfo->cstrError;

		   if (!g_bRunningInQuietMode)
   	          UpdateData(FALSE);
		}
	 }

 	 if (m_iCurrentNonIgnoredError <= 1)
	 {
	    CWnd *pWnd;
	    pWnd = GetDlgItem(IDC_PREVIOUSERROR);
	    if (pWnd)
		{
	       pWnd->EnableWindow(FALSE);	 
		}
	 }

     CWnd *pWnd;
	 pWnd = GetDlgItem(IDC_NEXTERROR);
	 if (pWnd && (m_iTotalNonIgnoredErrors > 1))
	 {
	    if (!pWnd->IsWindowEnabled())
           pWnd->EnableWindow(TRUE);
	 }
	 else
	 {
	    pWnd->EnableWindow(FALSE);
	 }

     CString str;
	 str.Format("%d", m_iCurrentNonIgnoredError);
	 pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
	 if (pWnd)
	 {
		pWnd->SetWindowText(str);
	 }
  }
  else
  {
     UINT iSize = m_arIgnorableErrorArray.GetSize();
     if ((m_iCurrentIgnoredError > 1) && (iSize >= m_iCurrentIgnoredError))
	 {
        m_iCurrentIgnoredError--;

	    WIErrorInfo *pErrorInfo;
        pErrorInfo = m_arIgnorableErrorArray.GetAt(m_iCurrentIgnoredError);
	    if (pErrorInfo)
		{
		   m_cstrSolution = pErrorInfo->cstrSolution;
		   m_cstrError = pErrorInfo->cstrError;

		   if (!g_bRunningInQuietMode)
   	          UpdateData(FALSE);
		}
	 }

 	 if (m_iCurrentIgnoredError <= 1)
	 {
	    CWnd *pWnd;
	    pWnd = GetDlgItem(IDC_PREVIOUSERROR);
	    if (pWnd)
		{
	       pWnd->EnableWindow(FALSE);	 
		}
	 }

     CWnd *pWnd;
	 pWnd = GetDlgItem(IDC_NEXTERROR);
	 if (pWnd && (m_iTotalIgnoredErrors > 1))
	 {
	    if (!pWnd->IsWindowEnabled())
           pWnd->EnableWindow(TRUE);
	 }
	 else
	 {
	    pWnd->EnableWindow(FALSE);
	 }

	 CString str;
	 str.Format("%d", m_iCurrentIgnoredError);
	 pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
	 if (pWnd)
	 {
		pWnd->SetWindowText(str);
	 }
  }
}

#include "optionsd.h"

void CLogAnalyzeDlg::OnOperationsOptions() 
{
	COptionsDlg dlg;

	BOOL bRet;
	CWILogUtilApp *pApp = (CWILogUtilApp *) AfxGetApp();
	if (pApp)
	{
		CArray<COLORREF, COLORREF> arColors;
		bRet = pApp->GetUserColorSettings(arColors);
		if (bRet)
		{
           m_cstrIgnoredErrors = pApp->GetIgnoredErrors();
		   dlg.SetIgnoredErrors(m_cstrIgnoredErrors);

           m_cstrOutputDir = pApp->GetOutputDirectory();
		   dlg.SetOutputDirectory(m_cstrOutputDir);

  	       bRet = dlg.SetColors(arColors);
		   if (bRet)
		   {
              //5-3-2001, don't show in quiet mode...
             if (!g_bRunningInQuietMode)
			 {
	            int iRet = dlg.DoModal();
		        if (IDOK == iRet)
				{
			       bRet = dlg.GetColors(arColors);
			       if (bRet)
				   {
			          bRet = pApp->SetUserColorSettings(arColors);
				   }

				   m_cstrOutputDir = dlg.GetOutputDirectory();
                   pApp->SetOutputDirectory(m_cstrOutputDir);

				   m_cstrIgnoredErrors = dlg.GetIgnoredErrors();
                   pApp->SetIgnoredErrors(m_cstrIgnoredErrors);
				}
			 }
		   }
		}
	}
}

void CLogAnalyzeDlg::OnOperationsGeneratehtmloutput() 
{
  OnExplainlog();
}

void CLogAnalyzeDlg::OnOperationsShowpolicies() 
{
  	OnPolicies();
}

void CLogAnalyzeDlg::OnOperationsShowproperties() 
{
	OnShowprop();
}

void CLogAnalyzeDlg::OnOperationsShowstates() 
{
	OnShowstates();
}

//tricky GUI code below...
void CLogAnalyzeDlg::OnShowIgnoredErrors() 
{
  CButton *pButton = (CButton *) GetDlgItem(IDC_SHOW_IGNORED_ERRORS);
  if (pButton)
  {
     int iCheck = pButton->GetCheck();
	 if (iCheck) //currently checked, showing only the errors that were ignored...
	 {
        m_bShowIgnoredDebugErrors = TRUE;
        if (m_iTotalIgnoredErrors > 0)
           m_iCurrentIgnoredError = 1;

        CString str;
		str.Format("%d", m_iCurrentIgnoredError);
		CWnd *pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
		if (pWnd)
		{
			pWnd->SetWindowText(str);
		}                

		str.Format("%d", m_iTotalIgnoredErrors);
		pWnd = GetDlgItem(IDC_TOTAL_ERRORS);
		if (pWnd)
		{
			pWnd->SetWindowText(str);
		}

        pWnd = GetDlgItem(IDC_PREVIOUSERROR);
 	    if (m_iCurrentIgnoredError <= 1)
		{
	       if (pWnd)
	          pWnd->EnableWindow(FALSE);	 
		}
		else
		{
	       if (pWnd)
	          pWnd->EnableWindow(TRUE);	 
		}

        pWnd;
	    pWnd = GetDlgItem(IDC_NEXTERROR);
	    if (pWnd && (m_iTotalIgnoredErrors > 1))
		{
		   if (!pWnd->IsWindowEnabled())
              pWnd->EnableWindow(TRUE);
		}
		else
		{
           if (pWnd)
			  pWnd->EnableWindow(FALSE);
		}

        if (m_iCurrentIgnoredError)
		{
	       WIErrorInfo *pErrorInfo;
           pErrorInfo = m_arIgnorableErrorArray.GetAt(m_iCurrentIgnoredError);
	       if (pErrorInfo)
		   {
		      m_cstrSolution = pErrorInfo->cstrSolution;
		      m_cstrError = pErrorInfo->cstrError;

			  if (!g_bRunningInQuietMode)
   	             UpdateData(FALSE);
		   }
		}
		else //hackhack
		{
 	       m_cstrSolution.LoadString(IDS_NOSOLUTION_NEEDED);
	       m_cstrError.LoadString(IDS_NOERRORFOUND);

		   if (!g_bRunningInQuietMode)
		      UpdateData(FALSE);
		}
	 }
	 else  //not checked...  Showing only non-ignorable errors currently
	 {
        m_bShowIgnoredDebugErrors = FALSE;
        if (m_iTotalNonIgnoredErrors > 0) //reset it back to first pos...
           m_iCurrentNonIgnoredError = 1;

        CString str;
		str.Format("%d", m_iCurrentNonIgnoredError);
		CWnd *pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
		if (pWnd)
		{
			pWnd->SetWindowText(str);
		}                

		str.Format("%d", m_iTotalNonIgnoredErrors);
		pWnd = GetDlgItem(IDC_TOTAL_ERRORS);
		if (pWnd)
		{
			pWnd->SetWindowText(str);
		}

 	    if (m_iCurrentNonIgnoredError <= 1)
		{
	       CWnd *pWnd;
	       pWnd = GetDlgItem(IDC_PREVIOUSERROR);
	       if (pWnd)
		   {
	          pWnd->EnableWindow(FALSE);	 
		   }
		}
		else
		{
           if (pWnd)
  		      pWnd->EnableWindow(TRUE);	 
		}

        pWnd;
	    pWnd = GetDlgItem(IDC_NEXTERROR);
	    if (pWnd && (m_iTotalNonIgnoredErrors > 1))
		{
		   if (!pWnd->IsWindowEnabled())
              pWnd->EnableWindow(TRUE);
		}
		else
		{ 
           pWnd->EnableWindow(FALSE);
		}

        if (m_iCurrentNonIgnoredError)
		{
	       WIErrorInfo *pErrorInfo;
           pErrorInfo = m_arNonIgnorableErrorArray.GetAt(m_iCurrentNonIgnoredError);
	       if (pErrorInfo)
		   {
		      m_cstrSolution = pErrorInfo->cstrSolution;
		      m_cstrError = pErrorInfo->cstrError;

			  if (!g_bRunningInQuietMode)
   	             UpdateData(FALSE);
		   }
		}
		else //hackhack
		{
 	       m_cstrSolution.LoadString(IDS_NOSOLUTION_NEEDED);
	       m_cstrError.LoadString(IDS_NOERRORFOUND);

		   if (!g_bRunningInQuietMode)
		      UpdateData(FALSE);
		}
	 }
  }
}


#include "propsht.h"
#include "clientpp.h"
#include "serverpp.h"
#include "nestedpp.h"

void CLogAnalyzeDlg::OnProptest() 
{
  if (!m_bLogVersionAllowed)
  {
	 ShowLogRejectedMessage();
	 return;
  }

  CMyPropertySheet ps("Properties", NULL, 0);
  ps.m_psh.dwFlags |= PSH_NOAPPLYNOW;

  if (ps.m_psh.dwFlags & PSH_HASHELP)
  {
     ps.m_psh.dwFlags -= PSH_HASHELP;
  }
  
  CClientPropertyPage ClientPage;
  CServerPropertyPage ServerPage;
  CNestedPropertyPage NestedPage;
 
  if (ClientPage.m_psp.dwFlags & PSP_HASHELP)
  {
	  ClientPage.m_psp.dwFlags -= PSP_HASHELP;
  }

  if (ServerPage.m_psp.dwFlags & PSP_HASHELP)
  {
	  ServerPage.m_psp.dwFlags -= PSP_HASHELP;
  }

  if (NestedPage.m_psp.dwFlags & PSP_HASHELP)
  {
	  NestedPage.m_psp.dwFlags -= PSP_HASHELP;
  }

  ClientPage.SetClientPropNames(&this->m_cstrClientPropNameArray);
  ClientPage.SetClientPropValues(&this->m_cstrClientPropValueArray);

  ServerPage.SetServerPropNames(&this->m_cstrServerPropNameArray);
  ServerPage.SetServerPropValues(&this->m_cstrServerPropValueArray);

  NestedPage.SetNestedPropNames(&this->m_cstrNestedPropNameArray);
  NestedPage.SetNestedPropValues(&this->m_cstrNestedPropValueArray);

  ps.AddPage(&ClientPage);
  ps.AddPage(&ServerPage);
  ps.AddPage(&NestedPage);

  //5-3-2001, don't show in quiet mode...
  if (!g_bRunningInQuietMode)
     ps.DoModal();
}

void CLogAnalyzeDlg::OnSaveresults() 
{
     if (!m_bLogVersionAllowed)
	 {
	    ShowLogRejectedMessage();
	    return;
	 }

     DoQuietModeResults();

	 CString strMsg;
	 strMsg.Format("Saved results to %s", m_cstrOutputDir);

     if (!g_bRunningInQuietMode)
	    AfxMessageBox(strMsg);
}



//TODO...
//5-16-2001
void CLogAnalyzeDlg::OnDeleteoutputdircontents() 
{
   if (!g_bRunningInQuietMode) //don't do anything in quite mode...
   {
      int iRet;   

      CString strConfirmStr;
      strConfirmStr.Format("Are you sure you want to delete ALL contents from directory %s", m_cstrOutputDir);
      iRet = MessageBox(strConfirmStr, "Deletion Confirmation", MB_YESNO);
      if (iRet == IDYES)
	  {
         //TODO
	     //do the delete
	     int j = 0;

		 //do nothing....
         BOOL bRet;
	     bRet = IsValidDirectory(m_cstrOutputDir);
	     if (bRet) //ok, good so far
		 {

		 }
	     else
		 {
             if (!g_bRunningInQuietMode)
			 {
		        //do nothing
		        CString cstrOutDirMsg;
		        cstrOutDirMsg.Format("Current directory set for output directory: %s is invalid, please select a new one in Options.", m_cstrOutputDir);
		        AfxMessageBox(cstrOutDirMsg);
			 }
		  }
	  }
      else
	  {
		  //do nothing!
	  }
   }
}


//5-16-2001
void WriteAndShowHTMLFile(int iHTMLResource, CString &cstrDirectory, CString &cstrPath)
{
	BOOL bRet = IsValidDirectory(cstrDirectory);
	if (bRet)
	{
  	   bRet = WriteHTMLResourceToFile(iHTMLResource, cstrPath);
	   if (bRet)
	   {
          ShowHTMLFile(cstrDirectory, cstrPath);
	   }
	   else
	   {
          if (!g_bRunningInQuietMode)
		  {
		     CString cstrErrorMsg;
		     cstrErrorMsg.Format("Error extracting internal errors file to directory %s", cstrDirectory); 

  	         AfxMessageBox(cstrErrorMsg);
		  }
	   }
	}
	else
	{
       if (!g_bRunningInQuietMode)
	   {
          CString cstrOutDirMsg;
	      cstrOutDirMsg.Format("Current directory set for output directory: %s is invalid, please select a new one in Options.", cstrDirectory);
	      AfxMessageBox(cstrOutDirMsg);
	   }
	}
}
//5-16-2001


void CLogAnalyzeDlg::OnShowinternalerrorshelp() 
{
    CString cstrOutHelpDir;
	cstrOutHelpDir = m_cstrOutputDir + "HELP\\";

    BOOL bRet = IsValidDirectory(cstrOutHelpDir);

    CString cstrOutPath;
    cstrOutPath = cstrOutHelpDir + "InternalWIErrors.html";

	WriteAndShowHTMLFile(IDR_ALLERRORS,  cstrOutHelpDir, cstrOutPath);
}


//5-16-2001, TODO....
void CLogAnalyzeDlg::OnShowhelp() 
{
    CString cstrOutHelpDir;
	cstrOutHelpDir = m_cstrOutputDir + "HELP\\";

    BOOL bRet = IsValidDirectory(cstrOutHelpDir);

    CString cstrOutPath;
    cstrOutPath = cstrOutHelpDir + "WILogUtilHelp.html";

	WriteAndShowHTMLFile(IDR_WILOGHELP, cstrOutHelpDir, cstrOutPath);
}

//TODO
void CLogAnalyzeDlg::OnShowhowtoreadlog() 
{
    CString cstrOutHelpDir;
	cstrOutHelpDir = m_cstrOutputDir + "HELP\\";

	BOOL bRet = IsValidDirectory(cstrOutHelpDir);

	CString cstrOutPath;
	cstrOutPath = cstrOutHelpDir + "HowToReadWILogs.html";

    WriteAndShowHTMLFile(IDR_HOWTOREADLOGS,  cstrOutHelpDir, cstrOutPath);
}
//end 5-16-2001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\logparse.h ===
// LogParse.h: interface for the CLogParser class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGPARSER_H__E759EBFC_8B37_40C0_819F_26B111063F44__INCLUDED_)
#define AFX_LOGPARSER_H__E759EBFC_8B37_40C0_819F_26B111063F44__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CLogParser  
{
public:
	CLogParser();
	virtual ~CLogParser();

	BOOL DetectWindowInstallerVersion(char *szLine, DWORD *dwMajor, DWORD *dwMinor, DWORD *dwBuild);

	//standard info about log
	BOOL DoDateTimeParse(char *szLine, char *szDateTime); 
	BOOL DoProductParse(char *szLine, char *szProduct);
	BOOL DoCommandLineParse(char *szLine, char *szCommandline);
	BOOL DoUserParse(char *szLine, char *szUser);

	//policy detection...
    BOOL DetectPolicyValue(char *szLine, 
		                   struct MachinePolicySettings &MachinePolicySettings,
	                       struct UserPolicySettings &UserPolicySettings);

    BOOL ParseMachinePolicy(char *szPolicyString, MachinePolicySettings &MachinePolicy);
    BOOL ParseUserPolicy(char *szPolicyString,  UserPolicySettings &UserPolicy);

	//error detection functions...
	BOOL DetectOtherError(char *szLine, char *szSolutions, BOOL *pbIgnorable, int *piErrorNumber);
    BOOL DetectInstallerInternalError(char *szLine, char *szSolutions, BOOL *pbIgnorable, int *piErrorNumber);

    BOOL DetectWindowsError(char *szLine, char *szSolutions, BOOL *pbIgnorable);
	BOOL DetectCustomActionError(char *szLine, char *szSolutions, BOOL *pbIgnorable);

	//property functions...
	BOOL DetectProperty(char *szLine, char *szPropName, char *szPropValue, int *piPropType);

    BOOL DetectComponentStates(char *szLine, char *szName, char *szInstalled, char *szRequest, char *szAction, BOOL *pbInternalComponent);
	BOOL DetectFeatureStates(char *szLine, char *szName, char *szInstalled, char *szRequest, char *szAction);

	//permission detection functions
    BOOL DetectElevatedInstall(char *szLine, BOOL *pbElevatedInstall, BOOL *pbClient);

	void SetLogType(BOOL bUnicodeLog)	{ m_bIsUnicodeLog = bUnicodeLog; }

protected:
    BOOL m_bIsUnicodeLog;

	//state functions
    BOOL DetectStatesCommon(const char *szTokenSearch, char *szLine, char *szName, char *szInstalled, char *szRequest, char *szAction);
};

#endif // !defined(AFX_LOGPARSER_H__E759EBFC_8B37_40C0_819F_26B111063F44__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\loganald.h ===
#if !defined(AFX_LOGANALYZEDLG_H__7790BEC2_EF8B_4536_ADC0_4ECBB36CEB43__INCLUDED_)
#define AFX_LOGANALYZEDLG_H__7790BEC2_EF8B_4536_ADC0_4ECBB36CEB43__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// LogAnalD.h : header file
//

#include "LogParse.h"


/////////////////////////////////////////////////////////////////////////////
// CLogAnalyzeDlg dialog
class CLogAnalyzeDlg : public CDialog
{
// Construction
public:
	CLogAnalyzeDlg(CWnd* pParent = NULL);   // standard constructor

	void ShowLogRejectedMessage();

	virtual ~CLogAnalyzeDlg() //clean up dynamic memory
	{
		int iCount, i;
		
		iCount = m_arNonIgnorableErrorArray.GetSize();
		for (i=0; i < iCount; i++)
		{
			WIErrorInfo* pErrorInfo = m_arNonIgnorableErrorArray.GetAt(i);
			if (pErrorInfo)
			{
			  delete pErrorInfo;
			  pErrorInfo = NULL;
			}
		}

		iCount = m_arIgnorableErrorArray.GetSize();
		for (i=0; i < iCount; i++)
		{
			WIErrorInfo* pErrorInfo = m_arIgnorableErrorArray.GetAt(i);
			if (pErrorInfo)
			{
			  delete pErrorInfo;
			  pErrorInfo = NULL;
			}
		}
	}

// Dialog Data
	//{{AFX_DATA(CLogAnalyzeDlg)
	enum { IDD = IDD_ADVVIEW_DIALOG1 };
	CString	m_cstrSolution;
	CString	m_cstrError;
	CString	m_cstrDateTime;
	CString	m_cstrUser;
	CString	m_cstrProduct;
	CString	m_cstrClientCMD;
	BOOL	m_bAdminRights;
	CString	m_cstrVersion;
	CString	m_cstrClientPrivDetail;
	CString	m_cstrServerPrivDetail;
	BOOL	m_bShowIgnoredDebugErrors;
	//}}AFX_DATA

	void SetLogfileLocation(CString & cstr) { m_cstrLogFileName = cstr; }

//5-3-2001, moved these up to allow for silent mode operation
	BOOL AnalyzeLog();
//end 5-3-2001

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLogAnalyzeDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
//5-9-2001, added tooltips...    
    BOOL OnToolTipNotify(UINT id, NMHDR *pNMH, LRESULT *pResult);

//general members used...
    long m_LineCount;
	BOOL m_bIsUnicodeLog;

//5-3-2001
	void DoInitialization();
	void DoResults();
	void DoQuietModeResults();
//end 5-3-2001

//5-4-2001
	void DoSummaryResults(CString &cstrFileName);
    void DoPolicyResults(CString &cstrFileName);
    void DoErrorResults(CString &cstrFileName);
//end 5-4-2001

//added 2-13-2001 to hold last line that was done...
	CString m_cstrLastLine;

//following section is for rejecting too high of WI log...
//REJECT LOG FILE SECTION
	BOOL m_bLogVersionAllowed;

	void SetRejectVersions(DWORD dwMajor, DWORD dwMinor)
	{
       m_dwVersionMajorReject = dwMajor;
	   m_dwVersionMinorReject = dwMinor;
	}

//will have version of WI that log was created against...
	DWORD m_dwVersionMajorLogCreated;
	DWORD m_dwVersionMinorLogCreated;
	DWORD m_dwVersionBuildLogCreated;

//has versions that this tool should reject parsing in case of changes...
	DWORD m_dwVersionMajorReject;
	DWORD m_dwVersionMinorReject;
//END SECTION

    CString m_cstrLogFileName;

	CStringArray m_cstrClientPropNameArray;
	CStringArray m_cstrClientPropValueArray;

	CStringArray m_cstrServerPropNameArray;
	CStringArray m_cstrServerPropValueArray;

	CStringArray m_cstrNestedPropNameArray;
	CStringArray m_cstrNestedPropValueArray;

	CStringArray m_cstrComponentNameArray;
	CStringArray m_cstrComponentInstalledArray;
	CStringArray m_cstrComponentRequestArray;
	CStringArray m_cstrComponentActionArray;

	CStringArray m_cstrFeatureNameArray;
	CStringArray m_cstrFeatureInstalledArray;
	CStringArray m_cstrFeatureRequestArray;
	CStringArray m_cstrFeatureActionArray;

//policies that were set when install ran...
	struct MachinePolicySettings m_MachinePolicySettings;
	struct UserPolicySettings m_UserPolicySettings;

//2-13-2001
	CArray<WIErrorInfo*, WIErrorInfo*> m_arNonIgnorableErrorArray;
	CArray<WIErrorInfo*, WIErrorInfo*> m_arIgnorableErrorArray;

	char m_szErrorLines[LINES_ERROR][LOG_BUF_READ_SIZE];
	BOOL m_bErrorFound;

	UINT m_iTotalNonIgnoredErrors;
	UINT m_iCurrentNonIgnoredError;

	UINT m_iTotalIgnoredErrors;
	UINT m_iCurrentIgnoredError;

	CString m_cstrIgnoredErrors;

//SECTION, PARSING HELPER FUNCTIONS	
//the parser...
	CLogParser m_LogParser; //handles reading of log file and interpreting lines in it...
//end the parser

	BOOL DoParse(char *buffer);
	BOOL DoDetectError(char *szLine, BOOL *pbIgnorableError);

	BOOL DoDetectProperty(char *szLine);
	BOOL DoDetectStates(char *szLine);
	BOOL DoDetectPolicy(char *szLine); 	//for getting policies that are set in log file
	BOOL DoDetectElevatedInstall(char *szLine); //checking permissions install run under
//END PARSING FUNCTIONS


//HTML generating functions
	CStringArray m_cstrHTML;

    BOOL WriteHTMLFrame(CString &cstrHTMLFrame, CString &cstrOutputHTMLFile, CString &cstrLegendHTMLFile);
    BOOL DumpHTMLToFile(CString &cstrOutputHTMLFile);

	void AddPolicyLineToHTML(char *ansibuffer);
	void AddGenericLineToHTML(char *ansibuffer);

	void AddErrorLineWorker(char *szLine, BOOL bIgnored);
	void AddErrorLineToHTML(char *ansibuffer, BOOL bIgnorableError);
	void AddErrorLineSuccessToHTML();

	void AddPropLineToHTML(char *ansibuffer);
	void AddStateLineToHTML(char *ansibuffer);

	void WriteLineWithColor(char *szLine, COLORREF col, CString &cstrLabel);
//END HTML functions

//members used by HTML functions
    CString m_cstrOutputDir;
    CString m_cstrDetailsName;
    CString m_cstrLegendName;
 
	COLORREF m_colClientContext;
	COLORREF m_colServerContext;
	COLORREF m_colCustomActionContext;
	COLORREF m_colUnknownContext;
	COLORREF m_colErrorArea;
	COLORREF m_colProperty;
	COLORREF m_colState;
	COLORREF m_colPolicy;
	COLORREF m_colIgnoredError;

	void InitColorMembers()
	{
         CWILogUtilApp *pApp = (CWILogUtilApp *) AfxGetApp();
		 if (pApp)
		 {
		   CArray<COLORREF, COLORREF> UserSelectedHTMLColors;

		   BOOL bRet = pApp->GetUserColorSettings(UserSelectedHTMLColors);
		   int iSize = UserSelectedHTMLColors.GetSize();

	       if (bRet && (iSize == MAX_HTML_LOG_COLORS))
		   {
              m_colClientContext = UserSelectedHTMLColors.GetAt(0);
			  m_colServerContext = UserSelectedHTMLColors.GetAt(1);
			  m_colCustomActionContext = UserSelectedHTMLColors.GetAt(2);
			  m_colUnknownContext = UserSelectedHTMLColors.GetAt(3);
			  m_colErrorArea = UserSelectedHTMLColors.GetAt(4);
			  m_colProperty = UserSelectedHTMLColors.GetAt(5);
              m_colState = UserSelectedHTMLColors.GetAt(6);
			  m_colPolicy = UserSelectedHTMLColors.GetAt(7);
			  m_colIgnoredError = UserSelectedHTMLColors.GetAt(8);
		   }
		 }
	}
//end HTML Members


	// Generated message map functions
	//{{AFX_MSG(CLogAnalyzeDlg)
	afx_msg void OnShowstates();
	afx_msg void OnShowprop();
	virtual BOOL OnInitDialog();
	afx_msg void OnExplainlog();
	afx_msg void OnPolicies();
	afx_msg void OnNexterror();
	afx_msg void OnPreviouserror();
	afx_msg void OnOperationsOptions();
	afx_msg void OnOperationsGeneratehtmloutput();
	afx_msg void OnOperationsShowpolicies();
	afx_msg void OnOperationsShowproperties();
	afx_msg void OnOperationsShowstates();
	afx_msg void OnShowIgnoredErrors();
	afx_msg void OnProptest();
	afx_msg void OnSaveresults();
	afx_msg void OnShowinternalerrorshelp();
	afx_msg void OnDeleteoutputdircontents();
	afx_msg void OnShowhelp();
	afx_msg void OnShowhowtoreadlog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOGANALYZEDLG_H__7790BEC2_EF8B_4536_ADC0_4ECBB36CEB43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\logparse.cpp ===
// LogParse.cpp: implementation of the CLogParser class.
//
//
// Code in this file is the most specific and likely to break in future
// versions of WI.  What could be done and should be done is
// determine which build of WI this was built with.  This tool
// currently can read 1.0, 1.1 and 1.2 logs.  1.5 may break this
// tool and we could have the tool refuse to run with 1.5 until more
// testing is done.  This could be control via an .INI file with this
// app to turn on >= 1.5 log file parsing
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wilogutl.h"
#include "LogParse.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLogParser::CLogParser()
{
}

CLogParser::~CLogParser()
{

}


void CopyVersions(char *szVersion, DWORD *dwMajor, DWORD *dwMinor, DWORD *dwBuild)
{
  char szMajor[2];
  szMajor[0] = szVersion[0];
  szMajor[1] = '\0';

  char szMinor[3];
  szMinor[0] = szVersion[2];
  szMinor[1] = szVersion[3];
  szMinor[2] = '\0';

  char szBuild[5];
  szBuild[0] = szVersion[5];
  szBuild[1] = szVersion[6];
  szBuild[2] = szVersion[7];
  szBuild[3] = szVersion[8];
  szBuild[4] = '\0';

  *dwMajor = atoi(szMajor);
  *dwMinor = atoi(szMinor);
  *dwBuild = atoi(szBuild);
}


BOOL CLogParser::DetectWindowInstallerVersion(char *szLine, DWORD *dwMajor, DWORD *dwMinor, DWORD *dwBuild)
{
	BOOL bRet = FALSE;

	//below based on this...
	//=== Verbose logging started: 7/18/2000  12:46:39  Build type:
    //DEBUG UNICODE 1.11.1820.00  Calling process: D:\WINNT\system32\msiexec.exe ===

	const char *szToken = "Build type:";
	const char *szAnsiToken = "ANSI";
	const char *szUnicodeToken = "UNICODE";
	const char *szCallingProcessToken = "Calling process";

    char *pszTokenFound = strstr(szLine, szToken);
	if (pszTokenFound)
	{
       char *pszAnsiTokenFound = strstr(szLine, szAnsiToken);
	   if (pszAnsiTokenFound)
	   {
          char *pszCallingProcessTokenFound = strstr(szLine, szCallingProcessToken);
		  if (pszCallingProcessTokenFound)
		  {
			  //get version now...
			  char *szVersion = pszAnsiTokenFound + strlen(szAnsiToken) + 1;
			  if (szVersion < pszCallingProcessTokenFound)
			  {
				 CopyVersions(szVersion, dwMajor, dwMinor, dwBuild);
    			 bRet = TRUE;
			  }	  

			  bRet = TRUE;
		  }
	   }
	   else
	   {
		   char *pszUnicodeTokenFound = strstr(szLine, szUnicodeToken);
		   if (pszUnicodeTokenFound)
		   {
              char *pszCallingProcessTokenFound = strstr(szLine, szCallingProcessToken);
			  if (pszCallingProcessTokenFound)
			  {
				  //get version now...
				  char *szVersion = pszUnicodeTokenFound + strlen(szUnicodeToken) + 1;
				  if (szVersion < pszCallingProcessTokenFound)
				  {
				     CopyVersions(szVersion, dwMajor, dwMinor, dwBuild);
					 bRet = TRUE;
				  }
			  }
		   }
	   }
	}

	return bRet;
}


BOOL CLogParser::DoDateTimeParse(char *szLine, char *szDateTime)
{
   BOOL bRet = FALSE;

   //below based on this...
	//=== Verbose logging started: 7/18/2000  12:46:39  Build type:
    //DEBUG UNICODE 1.11.1820.00  Calling process: D:\WINNT\system32\msiexec.exe ===

	const char *szToken = "logging started: ";
	const char *szBuildToken = "Build ";
    char *pszTokenFound = strstr(szLine, szToken);
	if (pszTokenFound)
	{
       char *pszBuildTokenFound = strstr(szLine, szBuildToken);
	   if (pszBuildTokenFound && (pszTokenFound < pszBuildTokenFound))
	   {
          char *szDate = pszTokenFound + strlen(szToken);
		  if (szDate)
		  {
             int iNumCopy = pszBuildTokenFound - szDate;  
			 strncpy(szDateTime, szDate, iNumCopy);

             szDateTime[iNumCopy] = '\0';
			 bRet = TRUE;
		  }
	   }
	}
 
    return bRet;
}


BOOL CLogParser::DoProductParse(char *szLine, char *szProduct)
{
   BOOL bRet = FALSE;

//MSI (c) (F0:B0): Executing op: ProductInfo(ProductKey={DC9359A6-692A-C9E6-FB13-4EE89C504C02},ProductName=Custom Action test,PackageName=34c1d6.msi,Language=1033,Version=16777216,Assignment=1,ObsoleteArg=0,)   

   const char *szToken = "Executing op: ProductInfo(";
   char *pszTokenFound = strstr(szLine, szToken);
   if (pszTokenFound)
   {
      char *szProductFound = pszTokenFound + strlen(szToken);
	  if (szProductFound)
	  {
	     strcpy(szProduct, szProductFound);

		 StripLineFeeds(szProduct); //take off \r\n
		 bRet = TRUE;
	  }
   }

   return bRet;
}



BOOL CLogParser::DoCommandLineParse(char *szLine, char *szCommandLine)
{
   BOOL bRet = FALSE;

//           ******* CommandLine:  
	const char *szToken = "** CommandLine: ";
    char *pszTokenFound = strstr(szLine, szToken);
	if (pszTokenFound)
	{
       char *szCmdLine = pszTokenFound + strlen(szToken);
	   if (szCmdLine)
	   {
	      strcpy(szCommandLine, szCmdLine);

		  int iLen = strlen(szCommandLine);
		  if (iLen <= 2)
		  {
             strcpy(szCommandLine, "(none)");
		  }
		  else
             StripLineFeeds(szCommandLine);

		  bRet = TRUE;
	   }
	}

   return bRet;
}


BOOL CLogParser::DoUserParse(char *szLine, char *szUser)
{
   BOOL bRet = FALSE;

//MSI (c) (F0:18): MainEngineThread: Process token is for: NORTHAMERICA\nmanis
//MSI (c) (F0:18): At the beginning of CreateAndRunEngine: NORTHAMERICA\nmanis [process]
//MSI (c) (F0:18): Resetting cached policy values
//MSI (c) (F0:18): After Impersonating in CreateAndRunEngine: NORTHAMERICA\nmanis [process]

	const char *szToken = "MainEngineThread: Process token is for: ";
    char *pszTokenFound = strstr(szLine, szToken);
	if (pszTokenFound)
	{
       char *szUserFound = pszTokenFound + strlen(szToken);
	   if (szUserFound)
	   {
	      strcpy(szUser, szUserFound);

		  StripLineFeeds(szUser);
		  bRet = TRUE;
	   }
	}
 
    return bRet;
}



//protected methods...
BOOL CLogParser::DetectProperty(char *szLine, char *szPropName, char *szPropValue, int *piPropType)
{
    BOOL bRet = FALSE;

	const char *szProperty = "Property(";
    int len = strlen(szProperty);
    int result = strncmp(szLine, szProperty, len);
    if (!result)
	{
	   const char *pszPropNameToken = ": "; 
	   const char *pszPropValueToken = " = "; 

	   char *pFoundPropNameToken  = strstr(szLine, pszPropNameToken);
	   char *pFoundPropValueToken = strstr(pFoundPropNameToken, pszPropValueToken);
	   if (pFoundPropNameToken && pFoundPropValueToken)
	   {
		  if ((szLine[len] == 'c') || (szLine[len] == 'C'))
			 *piPropType = CLIENT_PROP;

  		  if ((szLine[len] == 's') || (szLine[len] == 'S'))
			 *piPropType = SERVER_PROP;

  		  if ((szLine[len] == 'n') || (szLine[len] == 'N'))
			 *piPropType = NESTED_PROP;

          int lenCopy = 0;
		  lenCopy = (pFoundPropValueToken + strlen(pszPropNameToken)) - (pFoundPropNameToken + strlen(pszPropValueToken));

		  strncpy(szPropName, pFoundPropNameToken + strlen(pszPropNameToken), lenCopy);
          szPropName[lenCopy] = '\0';

		  lenCopy = strlen(pFoundPropValueToken) -  strlen(pszPropValueToken) - 1;

	      strncpy(szPropValue, pFoundPropValueToken + strlen(pszPropValueToken), lenCopy);
		  szPropValue[lenCopy] = '\0';

//5-4-2001
		  StripLineFeeds(szPropValue);
//end 5-4-2001

		  //property dump...
		  bRet = TRUE;
		}
	}

    return bRet;
}


BOOL CLogParser::DetectStatesCommon(const char *szToken, char *szLine, char *szName, char *szInstalled, char *szRequest, char *szAction)
{
	BOOL bRet = FALSE;

	const char *szInstalledToken = "Installed: ";
    const char *szRequestToken = "Request: ";
	const char *szActionToken  = "Action: ";
	const char *szEndStringToken = "\0";

	char *pTokenPos = NULL;
	char *pInstalledPos = NULL;
	char *pRequestPos = NULL;
	char *pActionPos = NULL;
	char *pEndStringPos = NULL;

	pTokenPos = strstr(szLine, szToken);
    pInstalledPos = strstr(szLine, szInstalledToken);
    pRequestPos = strstr(szLine, szRequestToken);
	pActionPos = strstr(szLine, szActionToken);
	pEndStringPos = strstr(szLine, szEndStringToken);

	if (pTokenPos && pInstalledPos && pRequestPos && pActionPos && pEndStringPos)
	{
	   //do the component name...
       int lenCopy = pInstalledPos - pTokenPos;
	   int lenToken = strlen(szToken);
	   if (lenCopy > lenToken)
	   {
		   lenCopy -= lenToken;
  	       strncpy(szName, pTokenPos + lenToken, lenCopy);
           szName[lenCopy] = '\0';
	   }

	   //do the installed value
       lenCopy =  pRequestPos - pInstalledPos;
	   lenToken = strlen(szInstalledToken);
	   if (lenCopy > lenToken)
	   {
		   lenCopy -= lenToken;
	   	   strncpy(szInstalled, pInstalledPos + lenToken, lenCopy);
           szInstalled[lenCopy] = '\0';
	   }

	   //do the request value
	   lenCopy =  pActionPos - pRequestPos;
	   lenToken = strlen(szRequestToken);
	   if (lenCopy > lenToken)
	   {
		   lenCopy -= lenToken;
	   	   strncpy(szRequest, pRequestPos + lenToken, lenCopy);
           szRequest[lenCopy] = '\0';
	   }

       //do the action value
       lenToken = strlen(szActionToken);
   	   strcpy(szAction, pActionPos + lenToken);

//5-4-2001
	   StripLineFeeds(szAction);
//end 5-4-2001

       bRet = TRUE;
	}

	return bRet;
}


BOOL CLogParser::DetectComponentStates(char *szLine, char *szName, char *szInstalled, char *szRequest, char *szAction, BOOL *pbInternalComponent)
{
	const char *szComponentToken = "Component: ";

//5-16-2001
	BOOL bRet;
	bRet = DetectStatesCommon(szComponentToken, szLine, szName, szInstalled, szRequest, szAction);

	if (szName[0] == '_' && szName[1] == '_') //internal property...
	{
       *pbInternalComponent = TRUE;
	}
	else
       *pbInternalComponent = FALSE;

	return bRet;
}


BOOL CLogParser::DetectFeatureStates(char *szLine, char *szName, char *szInstalled, char *szRequest, char *szAction)
{
	const char *szFeatureToken = "Feature: ";

	return DetectStatesCommon(szFeatureToken, szLine, szName, szInstalled, szRequest, szAction);
}





BOOL CLogParser::DetectWindowsError(char *szLine, char *szSolutions, BOOL *pbIgnorableError)
{
    BOOL bRet = FALSE;

	return bRet;
}


//ship ranges...
const int cimsgBase = 1000;   // offset for error messages, must be >=1000 for VBA
const int cidbgBase = 2000;   // offset for debug-only messages

/*
const   imsgHostStart = 1000;  // produced by install host or automation
const   imsgHostEnd   = 1000;  // produced by install host or automation

const   imsgServicesStart = 1100;  // produced by general services, services.h
const   imsgServicesEnd   = 1100;  // produced by general services, services.h

const   imsgDatabaseStart = 1200; // produced by database access, databae.h
const   imsgDatabaseEnd   = 1200; // produced by database access, databae.h

const 	imsgFileStart = 1300; // produced by file/volume services, path.h
const 	imsgFileEnd   = 1300; // produced by file/volume services, path.h

const 	imsgRegistryStart = 1400; // produced by registry services, regkey.h
const 	imsgRegistryEnd   = 1400; // produced by registry services, regkey.h

const 	imsgConfigStart   = 1500; // produced by configuration manager, iconfig.h
const 	imsgConfigEnd   = 1500; // produced by configuration manager, iconfig.h

const 	imsgActionStart  = 1600; // produced by standard actions, actions.h
const 	imsgActionEnd   = 1600; // produced by standard actions, actions.h

const 	imsgEngineStart   = 1700; // produced by engine, engine.h
const 	imsgEngineEnd   = 1700; // produced by engine, engine.h

const 	imsgHandlerStart  = 1800; // associated with UI control, handler.h
const 	imsgHandlerEnd  = 1800; // associated with UI control, handler.h

const 	imsgExecuteStart  = 1900; // produced by execute methods, engine.h
const 	imsgExecuteEnd  = 1900; // produced by execute methods, engine.h


const   idbgHostStart = 2000;  // produced by install host or automation
const   idbgHostEnd   = 2000;  // produced by install host or automation

const   idbgServicesStart = 2100;  // produced by general services, services.h
const   idbgServicesEnd   = 2100;  // produced by general services, services.h

const   idbgDatabaseStart = 2200; // produced by database access, databae.h
const   idbgDatabaseEnd   = 2200; // produced by database access, databae.h

const 	idbgFileStart = 2300; // produced by file/volume services, path.h
const 	idbgFileEnd   = 2300; // produced by file/volume services, path.h

const 	idbgRegistryStart = 2400; // produced by registry services, regkey.h
const 	idbgRegistryEnd   = 2400; // produced by registry services, regkey.h

const 	idbgConfigStart   = 2500; // produced by configuration manager, iconfig.h
const 	idbgConfigEnd   = 2500; // produced by configuration manager, iconfig.h

const 	idbgActionStart  = 2600; // produced by standard actions, actions.h
const 	idbgActionEnd   = 2600; // produced by standard actions, actions.h

const 	idbgEngineStart   = 2700; // produced by engine, engine.h
const 	idbgEngineEnd   = 2700; // produced by engine, engine.h

const 	idbgHandlerStart  = 2800; // associated with UI control, handler.h
const 	idbgHandlerEnd  = 2800; // associated with UI control, handler.h

const 	idbgExecuteStart  = 2900; // produced by execute methods, engine.h
const 	idbgExecuteEnd  = 2900; // produced by execute methods, engine.h
*/

struct ErrorRange
{
	long Begin;
	long End;
};

ErrorRange ShipErrorRangeAr[10] = 
{ 
	{1000, 1099},
	{1100, 1199},
	{1200, 1299},
	{1300, 1399},
	{1400, 1499},
	{1500, 1599},
	{1600, 1699},
	{1700, 1799},
	{1800, 1899},
	{1900, 1999},
};

ErrorRange DebugErrorRangeAr[10] = 
{
	{2000, 2099},
	{2100, 2199},
	{2200, 2299},
	{2300, 2399},
	{2400, 2499},
	{2500, 2599},
	{2600, 2699},
	{2700, 2799},
	{2800, 2899},
	{2900, 2999},
};

//TODO, possibly make this customizable so user can add/delete which errors they want to ignore
//only two so far...  
#define NUM_IGNORE_DEBUG_ERRORS 3

int g_arIgnoreDebugErrors[NUM_IGNORE_DEBUG_ERRORS] = { 2898, 2826, 2827 };
//END TODO

BOOL RealWIError(long iErrorNumber, BOOL *pbIgnorable)
{
  BOOL bRet = FALSE;
  ErrorRange range;
  int iIndex;

  //ship error message???
  if ((iErrorNumber>= cimsgBase) && (iErrorNumber < cidbgBase))
  {
    iIndex = iErrorNumber - cimsgBase;
    range = ShipErrorRangeAr[(iIndex / 100)];
  
    if ((iErrorNumber >= range.Begin) && (iErrorNumber <= range.End))
	{
	  //flag this as an error...
	  bRet = TRUE;
	}
  }
  else if ((iErrorNumber >= cidbgBase) && (iErrorNumber < cidbgBase+1000))
  {
    //debug error message???
    iIndex = iErrorNumber - cidbgBase;
    range = DebugErrorRangeAr[(iIndex / 100)];
  
    if ((iErrorNumber >= range.Begin) && (iErrorNumber <= range.End))
	{
	   BOOL bIgnoreError = FALSE;
       for (int i=0; i < NUM_IGNORE_DEBUG_ERRORS; i++)
	   {
           if (iErrorNumber == g_arIgnoreDebugErrors[i])
		   {
			  bIgnoreError = TRUE;
		   }
	   }

	   if (bIgnoreError) 	    //flag this as an ignored error...
          *pbIgnorable = bIgnoreError;

	   bRet = TRUE;
	}
  }

  return bRet;
}


struct ErrorLookup
{
	long Number;
	char szSolution[1024];
};


#define KNOWN_IGNORED_ERRORS 3
ErrorLookup g_ErrorLookupArray[KNOWN_IGNORED_ERRORS] = 
{
	2898, "Font was created.",
	2826, "Indicates that an item extends beyond the bounds of the given dialog.\r\nNot a big deal, but might be useful to catch if you don't see something you expect to see.",
	2827, "Indicates that a radio button extends beyond the bounds of the given group box.\r\nNot a big deal, but might be useful to catch if you don't see something you expect to see."
};



#define KNOWN_MAJOR_ERRORS    3
#define ERROR_SOL_SIZE     8192


//for hack below to workaround overlap in error codes!!!
#define ERR_DUPLICATE_BASE 1601
#define ERR_DUPLICATE_END 1609


char szDuplicatedErrors[ERR_DUPLICATE_END - ERR_DUPLICATE_BASE][256] =
{
	"The Windows Installer service could not be accessed. Contact your support personnel to verify that the Windows Installer service is properly registered", //1601
    "User cancel installation", //1602
    "Fatal error during installation", //1603
	"Installation suspended, incomplete", //1604
	"This action is only valid for products that are currently installed", //1605
	"Feature ID not registered", //1606
	"Component ID not registered", //1607
	"Unknown property" //1608
};


BOOL DetermineSolution(long iErrorNumber, char *szSolutions)
{
    BOOL bRet = FALSE;
	DWORD dwRet = 0;

	LPVOID lpMsgBuf;
    dwRet = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | 
		                  FORMAT_MESSAGE_IGNORE_INSERTS | 
		                  FORMAT_MESSAGE_ALLOCATE_BUFFER, 
						  0, iErrorNumber, 0, (LPTSTR) &lpMsgBuf, ERROR_SOL_SIZE / 2, 0);

    if ((dwRet != ERROR_RESOURCE_LANG_NOT_FOUND) && dwRet)
	{
       if (strlen((LPTSTR)lpMsgBuf) < ERROR_SOL_SIZE)
	   {
	      bRet = TRUE;
	      strcpy(szSolutions, (LPTSTR)lpMsgBuf);
	   }
	}
	else
	{
		//is this one of the ignored ones???
		for (int i=0; (i <  NUM_IGNORE_DEBUG_ERRORS) && !bRet; i++)
		{
			if (g_ErrorLookupArray[i].Number == iErrorNumber)
			{
				bRet = TRUE;
				strcpy(szSolutions, g_ErrorLookupArray[i].szSolution);
			}
		}

		if (!bRet)
		{
		   //hack, hack...
           if ((iErrorNumber >= ERR_DUPLICATE_BASE) && (iErrorNumber < 1609))
		   {
              strcpy(szSolutions, szDuplicatedErrors[iErrorNumber - ERR_DUPLICATE_BASE]);
			  bRet = TRUE;
		   }
		   else //try to load it from our string table...
		   {
              int iRet = LoadString(NULL, IDS_INTERNAL_ERROR_BASE + iErrorNumber, szSolutions, SOLUTIONS_BUFFER);
  	          if (iRet)
			  {
		         bRet = TRUE;
			  }
			  else
			  {

			  }
		   }
		}
	}

	return bRet;
}



BOOL DetermineInternalErrorSolution(long iErrorNumber, char *szSolutions)
{
    BOOL bRet = FALSE;

	//is this one of the ignored ones???
	for (int i=0; (i <  NUM_IGNORE_DEBUG_ERRORS) && !bRet; i++)
	{
		if (g_ErrorLookupArray[i].Number == iErrorNumber)
		{
			bRet = TRUE;
			strcpy(szSolutions, g_ErrorLookupArray[i].szSolution);
		}
	}

	if (!bRet)
	{
       //do something here to make it better...
	   int iRet = LoadString(NULL, IDS_INTERNAL_ERROR_BASE + iErrorNumber, szSolutions, SOLUTIONS_BUFFER);
	   if (iRet)
	   {
		  bRet = TRUE;
	   }
	}

	return bRet;
}



BOOL CLogParser::DetectInstallerInternalError(char *szLine, char *szSolutions, BOOL *pbIgnorable, int *piErrorNumber)
{
    BOOL bRet = FALSE;

	//Internal Error 2755.3, k:\xml-ma\1105\fre\cd_image\mms xml and file toolkit.msi
	//2755.3

	const char *szInternalErrorToken = "Internal Error ";

	char *lpszInternalErrorFound = strstr(szLine, szInternalErrorToken);
	if (lpszInternalErrorFound)
	{
       //parse the error number now and do a look up on error number in error table...
       char *lpszErrorNumber = lpszInternalErrorFound + strlen(szInternalErrorToken);	   
	   if (lpszErrorNumber)
	   {
           long iErrorNumber;
              
           char szError[16];
 		   int iAmountCopy = 4; //REVIEW, maybe better to do a strstr and look for . instead...

           strncpy(szError, lpszErrorNumber, iAmountCopy);

		   szError[iAmountCopy] = '\0';

  	  	   iErrorNumber = atoi(szError);

		   BOOL bIgnorableError = FALSE;
           bRet = RealWIError(iErrorNumber, &bIgnorableError);
		   if (bRet)
		   {
             *piErrorNumber = iErrorNumber;

             *pbIgnorable = bIgnorableError;
             BOOL bSolutionFound = DetermineInternalErrorSolution(iErrorNumber, szSolutions);
  	  	  	 if (!bSolutionFound)
			 {
			 	//make note of it...
				strcpy(szSolutions, "Solution Unknown");
			 }
		   }
	   }
	}

    return bRet;
}


BOOL CLogParser::DetectOtherError(char *szLine, char *szSolutions, BOOL *pbIgnorableError, int *piErrorNumber)
{
    BOOL bRet = FALSE;

    //MSI (c) (E4:50): MainEngineThread is returning 1602
	const char *szClient = "MSI (c)";
	const char *szErrorToken = "MainEngineThread is returning ";

	char *lpszFound = strstr(szLine, szClient);
	if (lpszFound)
	{
       lpszFound = strstr(szLine, szErrorToken);
	   if (lpszFound)
	   {
          //parse the error number now and do a look up on error number in error table...
          char *lpszErrorNumber = lpszFound + strlen(szErrorToken);	   
	      if (lpszErrorNumber)
		  {
             long iErrorNumber;
             char szError[16];
		     int iAmountCopy = 4;

             strncpy(szError, lpszErrorNumber, iAmountCopy);
		     szError[iAmountCopy] = '\0';

  	  	     iErrorNumber = atoi(szError);

		     BOOL bIgnorableError = FALSE;
             bRet = RealWIError(iErrorNumber, &bIgnorableError);
		     if (bRet)
			 {
                *pbIgnorableError = bIgnorableError;
				*piErrorNumber = iErrorNumber;

                BOOL bSolutionFound = DetermineSolution(iErrorNumber, szSolutions);
				if (!bSolutionFound)
				{
					//make note of it...
					strcpy(szSolutions, "(Solution Unknown)");
				}
			 }
		  }
	   }
	}

	return bRet;
}



BOOL CLogParser::DetectCustomActionError(char *szLine, char *szSolutions, BOOL *pbIgnorableError)
{
  BOOL bRet = FALSE;

  const char *szEndAction = "Action ended";
  const char *szReturnValue = "Return value ";

  int len = strlen(szEndAction);
  int result = _strnicmp(szLine, szEndAction, len);
  if (!result)
  {
	 char *lpszReturnValueFound = strstr(szLine, szReturnValue);
	 if (lpszReturnValueFound)
	 {
        char *lpszValue = lpszReturnValueFound+strlen(szReturnValue);

		if (lpszValue)
		{
           int iValue = atoi(lpszValue);
		   if (iValue == 3)
		   {
              strcpy(szSolutions, "A standard action or custom action caused the failure.");
              bRet = TRUE;
			  *pbIgnorableError = FALSE;
		   }
           else if (iValue == 2)
		   {
              strcpy(szSolutions, "User canceled action.");
              bRet = TRUE;
			  *pbIgnorableError = FALSE;
		   }
		}
	 }
  }

  return bRet;
}
//END Error analysis functions





int GetPolicyValue(char *szPolicyString)
{
	const char *constPolicyVal = "' is";
	char *lpszValue;
	int iValue = -1;

    lpszValue = strstr(szPolicyString, constPolicyVal);
	if (lpszValue)
	{
	   iValue = atoi(lpszValue + strlen(constPolicyVal));
	   ASSERT(iValue >= 0);
	}

	return iValue;
}

BOOL GetPolicyName(char *szPolicyString, char *lpszPolicyName)
{
	BOOL bRet = FALSE;
	char *lpszPolicyNameFound;
    const char *lpconstName = "'";

	lpszPolicyNameFound = strstr(szPolicyString, lpconstName);
    if (lpszPolicyNameFound)
	{
	   int iAmountCopy = lpszPolicyNameFound - szPolicyString;

       strncpy(lpszPolicyName, szPolicyString, iAmountCopy);
       lpszPolicyName[iAmountCopy] = '\0';
	   bRet = TRUE;
    }
	
	return bRet;
}


//will come in like: policyname' is value
BOOL CLogParser::ParseUserPolicy(char *szPolicyString, 	UserPolicySettings &UserPolicies)
{
    BOOL bRet = FALSE;

	char lpszPolicyName[MAX_POLICY_NAME];
	bRet = GetPolicyName(szPolicyString, lpszPolicyName);
	if (bRet)
	{
       int iValue;
       iValue = GetPolicyValue(szPolicyString);

	   BOOL bFound = FALSE;
	   int  iRet;
	   for (int i=0; (i < UserPolicies.iNumberUserPolicies) && !bFound; i++)
	   {
           iRet = _stricmp(lpszPolicyName, UserPolicies.UserPolicy[i].PolicyName);
		   bFound = iRet == 0;
       }

	   if (bFound) //set member...
		  UserPolicies.UserPolicy[i-1].bSet = iValue;

	   bRet = bFound;
	}

	return bRet;
}

//will come in like: policyname' is value
BOOL CLogParser::ParseMachinePolicy(char *szPolicyString, 	MachinePolicySettings &MachinePolicies)
{
    BOOL bRet = FALSE;

	char lpszPolicyName[MAX_POLICY_NAME];
	bRet = GetPolicyName(szPolicyString, lpszPolicyName);
	if (bRet)
	{
	   int iValue;
       iValue = GetPolicyValue(szPolicyString);

	   BOOL bFound = FALSE;
	   int  iRet;
	   for (int i=0; (i < MachinePolicies.iNumberMachinePolicies) && !bFound; i++)
	   {
           iRet = _stricmp(lpszPolicyName, MachinePolicies.MachinePolicy[i].PolicyName);
           bFound = iRet == 0;
       }

	   if (bFound) //set member...
		  MachinePolicies.MachinePolicy[i-1].bSet = iValue;

	   bRet = bFound;
	}

	return bRet;
}



//2-9-2001
BOOL CLogParser::DetectPolicyValue(char *szLine, 
								   MachinePolicySettings &MachinePolicySettings,
                                   UserPolicySettings &UserPolicySettings
)
{
  BOOL bRet = FALSE;

  const char *szUserPolicyValue = "User policy value '";
  const char *szMachinePolicyValue = "Machine policy value '";

  char *lpszFound;
  char *lpszPolicyName;

  lpszFound = strstr(szLine, szUserPolicyValue);
  if (lpszFound) //user policy?
  {
	 lpszPolicyName = lpszFound + strlen(szUserPolicyValue);
	 if (lpszPolicyName)
	 {
        bRet = ParseUserPolicy(lpszPolicyName, UserPolicySettings);
	 }
  }
  else
  {
     lpszFound = strstr(szLine, szMachinePolicyValue); //machine policy?
     if (lpszFound)
	 {
	    lpszPolicyName = lpszFound + strlen(szMachinePolicyValue);
        if (lpszPolicyName)
		{
           bRet = ParseMachinePolicy(lpszPolicyName, MachinePolicySettings);
		}
	 }
  }

  return bRet;
}

//2-13-2001
BOOL CLogParser::DetectElevatedInstall(char *szLine, BOOL *pbElevatedInstall, BOOL *pbClient)
{
     if (!pbElevatedInstall || !pbClient) //bad pointer...
		return FALSE;

	 BOOL bRet = FALSE;
	 BOOL bElevated = -1; //set to neither TRUE or FALSE
	 BOOL bClient = FALSE;

	 //do parse here..
	 const char *szServer = "MSI (s)";
	 const char *szClient = "MSI (c)";

     const char *szAssignment = "Running product";
     const char *szUserPriv = "with user privileges:";
	 const char *szElevatedPriv = "with elevated privileges:";

     char *lpszFound;
     char *lpszSkipProductCode;

     lpszFound = strstr(szLine, szAssignment);
     if (lpszFound) //user policy?
	 {
	   lpszSkipProductCode = lpszFound + strlen(szAssignment);
	   if (lpszSkipProductCode)
	   {
          lpszFound = strstr(lpszSkipProductCode, szUserPriv);
		  if (lpszFound) //user?
		  {
 	         lpszFound = strstr(szLine, szServer);
			 if (lpszFound) //server side user?
			 {
				bClient = FALSE;
  		 	    bElevated = FALSE;
			    bRet = TRUE;

			 }
			 else
			 {
 	           lpszFound = strstr(szLine, szClient); //client side user?
			   if (lpszFound)
			   {
				  bClient = TRUE;
  		 	      bElevated = FALSE;
			      bRet = TRUE;
			   }
			 }
		  }
		  else //elevated???
		  {
			  lpszFound = strstr(lpszSkipProductCode, szElevatedPriv);
			  if (lpszFound)
			  {
   	             lpszFound = strstr(szLine, szServer);
			     if (lpszFound) //server side elevated?
				 {
				    bClient = FALSE;
  		 	        bElevated = TRUE;
			        bRet = TRUE;

				 }
			     else
				 {
 	                lpszFound = strstr(szLine, szClient); //client side elevated?
			        if (lpszFound)
					{
				       bClient = TRUE;
  		 	           bElevated = TRUE;
			           bRet = TRUE;
					}
				 }
			 }
		  }
	   }
	 }
     
	 if (bRet)
	 {
	    *pbElevatedInstall = bElevated;
		*pbClient = bClient;
	 }
    
	 return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\logviewd.cpp ===
// LogViewD.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "LogViewD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDetailedLogViewDlg dialog


CDetailedLogViewDlg::CDetailedLogViewDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDetailedLogViewDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDetailedLogViewDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDetailedLogViewDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDetailedLogViewDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDetailedLogViewDlg, CDialog)
	//{{AFX_MSG_MAP(CDetailedLogViewDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDetailedLogViewDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\nestedpp.h ===
#if !defined(AFX_NESTEDPROPERTYPAGE_H__FC5EAA3F_D8D9_4F19_8587_E7CE86416943__INCLUDED_)
#define AFX_NESTEDPROPERTYPAGE_H__FC5EAA3F_D8D9_4F19_8587_E7CE86416943__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NestedPP.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNestedPropertyPage dialog

class CNestedPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CNestedPropertyPage)

// Construction
public:
	CNestedPropertyPage();
	~CNestedPropertyPage();
	
	static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

    BOOL m_bNestedPropSortUp;

	BOOL SetNestedPropNames(CStringArray *cstrNestedPropNameArray)
	{
        m_pcstrNestedPropNameArray = cstrNestedPropNameArray;
		return TRUE;
	}

	BOOL SetNestedPropValues(CStringArray *cstrNestedPropValueArray)
	{
        m_pcstrNestedPropValueArray = cstrNestedPropValueArray;
		return TRUE;
	}


// Dialog Data
	//{{AFX_DATA(CNestedPropertyPage)
	enum { IDD = IDD_PROPPAGE_NESTED };
	CListCtrl	m_lstNestedProp;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNestedPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CStringArray *m_pcstrNestedPropNameArray;
	CStringArray *m_pcstrNestedPropValueArray;

	CListCtrl *m_pCurrentListSorting;
	int       m_iCurrentColumnSorting;
	BOOL      m_bCurrentSortUp;

	int  m_iNestedLastColumnClick;
	int  m_iNestedLastColumnClickCache;


	// Generated message map functions
	//{{AFX_MSG(CNestedPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnColumnClickNestedProp(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NESTEDPROPERTYPAGE_H__FC5EAA3F_D8D9_4F19_8587_E7CE86416943__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\nestedpp.cpp ===
// NestedPP.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "NestedPP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNestedPropertyPage property page

IMPLEMENT_DYNCREATE(CNestedPropertyPage, CPropertyPage)

CNestedPropertyPage::CNestedPropertyPage() : CPropertyPage(CNestedPropertyPage::IDD)
{
	//{{AFX_DATA_INIT(CNestedPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_bNestedPropSortUp = TRUE;
	m_iNestedLastColumnClick = 0;
	m_iNestedLastColumnClickCache = 0;

	m_bCurrentSortUp = FALSE;
	m_pCurrentListSorting = NULL;

	m_pcstrNestedPropNameArray = NULL;
}

CNestedPropertyPage::~CNestedPropertyPage()
{
}

void CNestedPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNestedPropertyPage)
	DDX_Control(pDX, IDC_NESTEDPROP, m_lstNestedProp);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNestedPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CNestedPropertyPage)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_NESTEDPROP, OnColumnClickNestedProp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNestedPropertyPage message handlers

BOOL CNestedPropertyPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	RECT r;
	m_lstNestedProp.GetClientRect(&r);

	int widthCol1;
	int widthCol2;

	//col 1 & 2 takes up around half of area...
	widthCol1 = widthCol2 = ((r.right - r.left) / 2);
	
	m_lstNestedProp.InsertColumn(0, "Property", LVCFMT_LEFT, widthCol1);
	m_lstNestedProp.InsertColumn(1, "Value", LVCFMT_LEFT, widthCol2);

    //autosize last column for best look and to get rid of scroll bar
	m_lstNestedProp.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);

    m_lstNestedProp.SetExtendedStyle(m_lstNestedProp.GetExtendedStyle() | LVS_EX_FULLROWSELECT);

    int i, count;
	if (m_pcstrNestedPropNameArray)
	{
	    count = this->m_pcstrNestedPropNameArray->GetSize();
	    for (i = 0; i < count; i++)
		{
            m_lstNestedProp.InsertItem(i, m_pcstrNestedPropNameArray->GetAt(i), 0);
		    m_lstNestedProp.SetItemData(i, i);
            m_lstNestedProp.SetItemText(i, 1, m_pcstrNestedPropValueArray->GetAt(i));
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//nmanis, for sorting of columns...
int CALLBACK CNestedPropertyPage::CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CNestedPropertyPage *pDlg; //we pass "this" in to this callback...
    pDlg = (CNestedPropertyPage *) lParamSort; 

    LV_FINDINFO FindItem1;
    LV_FINDINFO FindItem2;

    ZeroMemory(&FindItem1, sizeof(LV_FINDINFO));
    ZeroMemory(&FindItem2, sizeof(LV_FINDINFO));

    FindItem1.flags  = LVFI_PARAM;
    FindItem1.lParam = lParam1;

    FindItem2.flags = LVFI_PARAM;
    FindItem2.lParam = lParam2;

    int iIndexItem1 = pDlg->m_pCurrentListSorting->FindItem(&FindItem1);
    int iIndexItem2 = pDlg->m_pCurrentListSorting->FindItem(&FindItem2);

	if (pDlg->m_pCurrentListSorting)
	{
      CString str1 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem1, pDlg->m_iCurrentColumnSorting);
      CString str2 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem2, pDlg->m_iCurrentColumnSorting);
      switch (pDlg->m_iCurrentColumnSorting)
	  {
        case 0: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     
              break;

        case 1: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

              break;  //no needed, just in case we forget...
	  }
	}

    return 0;
}
//end nmanis, sorting function

void CNestedPropertyPage::OnColumnClickNestedProp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iNestedLastColumnClick = pNMListView->iSubItem;
    if (m_iNestedLastColumnClickCache == m_iNestedLastColumnClick) //if click on different column, don't toggle
       m_bNestedPropSortUp = !m_bNestedPropSortUp;  //toggle it...

    m_iNestedLastColumnClickCache = m_iNestedLastColumnClick;  //save last header clicked

	m_pCurrentListSorting = &m_lstNestedProp;
	m_iCurrentColumnSorting = m_iNestedLastColumnClick;
	m_bCurrentSortUp = m_bNestedPropSortUp;

	m_lstNestedProp.SortItems(CompareFunc, (LPARAM) this);
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\logviewd.h ===
#if !defined(AFX_DETAILEDLOGVIEWDLG_H__9C60973C_2E04_4EBE_95DB_C6CE5AE63EF8__INCLUDED_)
#define AFX_DETAILEDLOGVIEWDLG_H__9C60973C_2E04_4EBE_95DB_C6CE5AE63EF8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// LogViewD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDetailedLogViewDlg dialog

class CDetailedLogViewDlg : public CDialog
{
// Construction
public:
	CDetailedLogViewDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDetailedLogViewDlg)
	enum { IDD = IDD_ADVVIEW_DIALOG1 };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDetailedLogViewDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDetailedLogViewDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DETAILEDLOGVIEWDLG_H__9C60973C_2E04_4EBE_95DB_C6CE5AE63EF8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\optionsd.cpp ===
// OptionsD.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "Optionsd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COptionsDlg dialog


COptionsDlg::COptionsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(COptionsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(COptionsDlg)
	m_cstrOutputDirectory = g_szDefaultOutputLogDir;
	//}}AFX_DATA_INIT
}

void COptionsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COptionsDlg)
	DDX_Control(pDX, IDC_LIST1, m_lstIgnoredErrors);
	DDX_Text(pDX, IDC_OUTPUTDIRECTORY, m_cstrOutputDirectory);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COptionsDlg, CDialog)
	//{{AFX_MSG_MAP(COptionsDlg)
	ON_WM_CTLCOLOR()
	ON_BN_CLICKED(IDOK, OnOk)
	//}}AFX_MSG_MAP
    ON_COMMAND_RANGE(IDC_CHOOSECOLOR_CLIENT, IDC_CHOOSECOLOR_IGNOREDERRORS, OnChooseColor)
END_MESSAGE_MAP()


HBRUSH COptionsDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{
	HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);

	int id = pWnd->GetDlgCtrlID();
	if ((id >= IDC_CLIENTCONTEXT) && (id <= IDC_IGNOREDERROR))
	{
	   int iPos = id - IDC_CLIENTCONTEXT;
       if (m_brArray[iPos].m_hObject)
	   {
		   m_brArray[iPos].DeleteObject();

	   }

   	   COLORREF col;
	   col = m_arColors.GetAt(iPos);

       m_brArray[iPos].CreateSolidBrush(col);

	   hbr = m_brArray[iPos];
	}
	
	return hbr;
}


BOOL COptionsDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	UINT iSize = m_arColors.GetSize();
	if (iSize == MAX_HTML_LOG_COLORS)
	{
	  BOOL bRet;
	  COLORREF col;
	  for (UINT i = 0; i < iSize; i++)
	  {
		  col = m_arColors.GetAt(i);

		  bRet = m_brArray[i].CreateSolidBrush(col);
		  ASSERT(bRet);
	  }
	}

	
	CString cstrErr;
	if (!m_cstrIgnoredErrors.IsEmpty())
	{
/*
//FUTURE TODO, need to parse m_cstrIgnoredErrors
	   BOOL bDone = FALSE;
	   char *lpszFound;
	   do
	   {
		  lpszFound = strstr(m_cstrIgnoredErrors, ",");
		  if (lpszFound)
		  {
			 char *lpszFoundNext;
             lpszFoundNext = strstr(lpszFound+1, ",");
			 if (lpszFoundNext)
			 {
			    int chars = lpszFoundNext - lpszFound;

			    char szError[16];
			    if ((chars > 0) && (chars < 16))
				{
				   strncpy(szError, lpszFound+1, chars-1);
				   szError[chars-1] = '\0';
				   m_lstIgnoredErrors.InsertItem(-1, szError);

				   *lpszFound = ';';
				}
			    else
                   bDone = TRUE;
			 }
			 else //must be last one...
			 {

			 }
			 
       	  }
		  else
			 bDone = TRUE;
	   }

	   while (!bDone);
	//END TODO
*/
	}


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void COptionsDlg::OnChooseColor(UINT iCommandID)
{
  CColorDialog dlg;

  //5-3-2001, don't show in quiet mode...
  if (!g_bRunningInQuietMode)
  {
     int iRet = dlg.DoModal();
     if (IDOK == iRet)
	 {
	    int iPos = iCommandID - IDC_CHOOSECOLOR_CLIENT;

	    COLORREF col;
	    col = dlg.GetColor();
        if (iPos < m_arColors.GetSize())
		{
  	       m_arColors.SetAt(iPos, col);
           if (m_brArray[iPos].m_hObject)
  	          m_brArray[iPos].DeleteObject();

   	       COLORREF col;
	       col = m_arColors.GetAt(iPos);

           m_brArray[iPos].CreateSolidBrush(col);
	       Invalidate();
		}
	 }
  }
}


void COptionsDlg::OnOk() 
{
  UpdateData(TRUE);

  int iLength = m_cstrOutputDirectory.GetLength();
  int iRet = m_cstrOutputDirectory.ReverseFind('\\');
  if (iRet < iLength-1) 
  {
     m_cstrOutputDirectory += "\\"; //add back slash to out dir...
  }

  BOOL bRet = IsValidDirectory(m_cstrOutputDirectory);
  if (bRet)
  {
	 UpdateData(TRUE);

	 if (iRet < iLength-1) 
        m_cstrOutputDirectory += "\\"; //add back slash to out dir...

	 EndDialog(IDOK);
  }
  else
  {
     if (!g_bRunningInQuietMode)
	 {
	    AfxMessageBox("Invalid directory name, please re-enter a valid directory");
	 }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\optionsd.h ===
#if !defined(AFX_OPTIONSDLG_H__E1BA321D_78BC_4A7B_8E7C_5B85B79ADD8B__INCLUDED_)
#define AFX_OPTIONSDLG_H__E1BA321D_78BC_4A7B_8E7C_5B85B79ADD8B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OptionsD.h : header file
//

#include "common.h"

/////////////////////////////////////////////////////////////////////////////
// COptionsDlg dialog

class COptionsDlg : public CDialog
{
// Construction
public:
	COptionsDlg(CWnd* pParent = NULL);   // standard constructor
	~COptionsDlg() 
	{ 
	}

	CString GetIgnoredErrors()
	{
	   return m_cstrIgnoredErrors;
	}

	void SetIgnoredErrors(CString &cstrErrors)
	{
	   m_cstrIgnoredErrors = cstrErrors;
	}

	CString GetOutputDirectory()
	{
		return m_cstrOutputDirectory;
	}

	void SetOutputDirectory(CString &cstrDir)
	{
		m_cstrOutputDirectory = cstrDir;
	}


// Dialog Data
	//{{AFX_DATA(COptionsDlg)
	enum { IDD = IDD_OPTIONS };
	CListCtrl	m_lstIgnoredErrors;
	CString	m_cstrOutputDirectory;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COptionsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
    BOOL SetColors(CArray<COLORREF, COLORREF> &refColors) 
	{
	  BOOL bRet = FALSE;
	  int iSize = refColors.GetSize();
	  COLORREF col;

	  if ((iSize > 0) && (iSize <= MAX_HTML_LOG_COLORS))
	  {
         bRet = TRUE;

	     m_arColors.RemoveAll();
	     for (int i=0; i < iSize; i++)
		 {
		   col = refColors.GetAt(i);
           m_arColors.Add(col);
		 }  
	  }

      return bRet;
	}


	BOOL GetColors(CArray<COLORREF, COLORREF> &refColors)
	{
	  BOOL bRet = FALSE;
	  int iSize = m_arColors.GetSize();
	  COLORREF col;
	  
	  if ((iSize > 0) && (iSize <= MAX_HTML_LOG_COLORS))
	  {
		  bRet = TRUE;

          refColors.RemoveAll();
	   	  for (int i=0; i < iSize; i++)
		  {
            col = m_arColors.GetAt(i);
            refColors.Add(col);
		  }
	  }

      return bRet;
	}

// Implementation
protected:
	CArray<COLORREF, COLORREF> m_arColors; //values...
	CBrush m_brArray[MAX_HTML_LOG_COLORS]; //assume nothing, will get size in OnInitDialog...

	CString m_cstrIgnoredErrors;

	// Generated message map functions
	//{{AFX_MSG(COptionsDlg)
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	virtual BOOL OnInitDialog();
	afx_msg void OnOk();
	afx_msg void OnChoosecolorPolicy();
	//}}AFX_MSG

	afx_msg void OnChooseColor(UINT iCommandID);

	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OPTIONSDLG_H__E1BA321D_78BC_4A7B_8E7C_5B85B79ADD8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\policyd.h ===
#if !defined(AFX_POLICIESDLG_H__83F91A8A_5800_4521_ABF0_36AE0F3224BD__INCLUDED_)
#define AFX_POLICIESDLG_H__83F91A8A_5800_4521_ABF0_36AE0F3224BD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Policyd.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CPoliciesDlg dialog
class CPoliciesDlg : public CDialog
{
// Construction
public:
	CPoliciesDlg(CWnd* pParent = NULL);   // standard constructor

	void SetPolicyInformation(struct MachinePolicySettings &MachinePolicy,
	                          struct UserPolicySettings &UserPolicy)
	{
   	   m_pMachinePolicySettings = &MachinePolicy;
       m_pUserPolicySettings = &UserPolicy;
	}

	CArray<CEdit*, CEdit*> m_arEditArray;
	CArray<CStatic*, CStatic*> m_arStaticArray;

	~CPoliciesDlg()
	{
		int iCount, i;
		
		iCount = m_arEditArray.GetSize();
		for (i=0; i < iCount; i++)
		{
			CEdit *pEdit = m_arEditArray.GetAt(i);
			delete pEdit;
		}

		iCount = m_arStaticArray.GetSize();
		for (i=0; i < iCount; i++)
		{
			CStatic *pStatic = m_arStaticArray.GetAt(i);
			delete pStatic;
		}
	}
	
// Dialog Data
	//{{AFX_DATA(CPoliciesDlg)
	enum { IDD = IDD_POLICIESDLG };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPoliciesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	struct MachinePolicySettings *m_pMachinePolicySettings;
	struct UserPolicySettings    *m_pUserPolicySettings;

	// Generated message map functions
	//{{AFX_MSG(CPoliciesDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_POLICIESDLG_H__83F91A8A_5800_4521_ABF0_36AE0F3224BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\policyd.cpp ===
// Policyd.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "Policyd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPoliciesDlg dialog


CPoliciesDlg::CPoliciesDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPoliciesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPoliciesDlg)
	//}}AFX_DATA_INIT
}


void CPoliciesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPoliciesDlg)
}


BEGIN_MESSAGE_MAP(CPoliciesDlg, CDialog)
	//{{AFX_MSG_MAP(CPoliciesDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CFont g_font;

/////////////////////////////////////////////////////////////////////////////
// CPoliciesDlg message handlers
BOOL CPoliciesDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	DWORD dwEditStyle   = 0;
	DWORD dwEditStyleEx = 0;

	DWORD dwStaticStyle   = 0;
	DWORD dwStaticStyleEx = 0;

	RECT EditRect = { 0 };
	RECT StaticRect = { 0 };

	UINT iStatic = (UINT) IDC_STATIC;

	//set first column for machine policies
	CWnd *pWnd;
	pWnd = GetDlgItem(IDC_MACHINEEDITCOL1);
	if (pWnd)
	{
	  CString str;

	  dwEditStyle = pWnd->GetStyle();
	  dwEditStyleEx = pWnd->GetExStyle();

      pWnd->GetWindowRect(&EditRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&EditRect, 2);
//	  ScreenToClient(&EditRect);

	  if (m_pMachinePolicySettings->MachinePolicy[0].bSet == -1)
		  str = "?";
	  else
		 str.Format("%d", m_pMachinePolicySettings->MachinePolicy[0].bSet);

	  pWnd->SetWindowText(str);
	}

	pWnd = GetDlgItem(IDC_MACHINECOL1);
	if (pWnd)
	{
       dwStaticStyle = pWnd->GetStyle();
	   dwStaticStyleEx = pWnd->GetExStyle();

       pWnd->GetWindowRect(&StaticRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&StaticRect, 2);
  //     ScreenToClient(&StaticRect);

	   pWnd->SetWindowText(m_pMachinePolicySettings->MachinePolicy[0].PolicyName);
	}	   

	int nextEditID = 0;

	CEdit   *pEdit;
	CStatic *pStatic;
    BOOL    bRet;

	RECT EditRectOld = { 0 };
	RECT StaticRectOld = { 0 };

	//create and populate state of each machine policy in first row
	for (int i = 1; i < (m_pMachinePolicySettings->iNumberMachinePolicies / 2); i++)
	{
		nextEditID = IDC_MACHINEEDITCOL1 + i*2;

		EditRectOld = EditRect;
		StaticRectOld = StaticRect;

		pEdit = new CEdit;
		EditRect.top    = EditRectOld.bottom + 7;
		EditRect.bottom = EditRectOld.bottom + (EditRectOld.bottom - EditRectOld.top) + 7;
		bRet = pEdit->CreateEx(dwEditStyleEx, "EDIT", NULL, dwEditStyle, EditRect, this, nextEditID);
		if (bRet)
		{
		  CString str;

		  if (m_pMachinePolicySettings->MachinePolicy[i].bSet == -1)
		     str = "?";
	      else
		     str.Format("%d", m_pMachinePolicySettings->MachinePolicy[i].bSet);

		  pEdit->SetWindowText(str);
          this->m_arEditArray.Add(pEdit);
		}
		else
		   delete pEdit;

		pStatic = new CStatic;
		StaticRect.top    = StaticRectOld.bottom + 7;
		StaticRect.bottom = StaticRectOld.bottom + (StaticRectOld.bottom - StaticRectOld.top) + 7;
		bRet = pStatic->CreateEx(dwStaticStyleEx, "STATIC", m_pMachinePolicySettings->MachinePolicy[i].PolicyName, dwStaticStyle, StaticRect, this, iStatic);
		if (bRet)
           this->m_arStaticArray.Add(pStatic);
		else
		   delete pStatic;
	}

	//set second column for machine policies
	pWnd = GetDlgItem(IDC_MACHINEEDITCOL2);
	if (pWnd)
	{
	  CString str;

	  if (m_pMachinePolicySettings->MachinePolicy[i].bSet == -1)
		  str = "?";
	  else
		 str.Format("%d", m_pMachinePolicySettings->MachinePolicy[i].bSet);
	  pWnd->SetWindowText(str);

      pWnd->GetWindowRect(&EditRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&EditRect, 2);
//	  ScreenToClient(&EditRect);
	}

	pWnd = GetDlgItem(IDC_MACHINEPROPCOL2);
	if (pWnd)
	{
       pWnd->SetWindowText(m_pMachinePolicySettings->MachinePolicy[i].PolicyName);

       pWnd->GetWindowRect(&StaticRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&StaticRect, 2);
//       ScreenToClient(&StaticRect);
	}

//create and populate state of each machine policy in second row
	for (int j = i+1; j < m_pMachinePolicySettings->iNumberMachinePolicies; j++)
	{
		nextEditID = IDC_MACHINEEDITCOL2 + j*2;

		EditRectOld = EditRect;
		StaticRectOld = StaticRect;

		pEdit = new CEdit;
		EditRect.top    = EditRectOld.bottom + 7;
		EditRect.bottom = EditRectOld.bottom + (EditRectOld.bottom - EditRectOld.top) + 7;
		bRet = pEdit->CreateEx(dwEditStyleEx, "EDIT", NULL, dwEditStyle, EditRect, this, nextEditID);
		if (bRet)
		{
		  CString str;

		  if (m_pMachinePolicySettings->MachinePolicy[j].bSet == -1)
		     str = "?";
	      else
		     str.Format("%d", m_pMachinePolicySettings->MachinePolicy[j].bSet);

		  pEdit->SetWindowText(str);
          this->m_arEditArray.Add(pEdit);
		}
		else
		   delete pEdit;

		pStatic = new CStatic;
		StaticRect.top    = StaticRectOld.bottom + 7;
		StaticRect.bottom = StaticRectOld.bottom + (StaticRectOld.bottom - StaticRectOld.top) + 7;
		bRet = pStatic->CreateEx(dwStaticStyleEx, "STATIC", m_pMachinePolicySettings->MachinePolicy[j].PolicyName, dwStaticStyle, StaticRect, this, iStatic);
		if (bRet)
           this->m_arStaticArray.Add(pStatic);
		else
		   delete pStatic;
	}

	//set first column for User policies
	pWnd = GetDlgItem(IDC_USEREDITCOL1);
	if (pWnd)
	{
	  CString str;

      pWnd->GetWindowRect(&EditRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&EditRect, 2);
//      ScreenToClient(&EditRect);
	  if (m_pUserPolicySettings->UserPolicy[0].bSet == -1)
		  str = "?";
	  else
		 str.Format("%d", m_pUserPolicySettings->UserPolicy[0].bSet);

	  pWnd->SetWindowText(str);
	}

	pWnd = GetDlgItem(IDC_USERCOL1);
	if (pWnd)
	{
       pWnd->GetWindowRect(&StaticRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&StaticRect, 2);
 //      ScreenToClient(&StaticRect);

	   pWnd->SetWindowText(m_pUserPolicySettings->UserPolicy[0].PolicyName);
	}	   


{ //so we can reuse i, C++ compiler bug...
//create and populate state of each user policy in first row
	for (int i = 1; i < (m_pUserPolicySettings->iNumberUserPolicies / 2); i++)
	{
		nextEditID = IDC_USEREDITCOL1 + i*2;

		EditRectOld = EditRect;
		StaticRectOld = StaticRect;

		pEdit = new CEdit;
		EditRect.top    = EditRectOld.bottom + 7;
		EditRect.bottom = EditRectOld.bottom + (EditRectOld.bottom - EditRectOld.top) + 7;
		bRet = pEdit->CreateEx(dwEditStyleEx, "EDIT", NULL, dwEditStyle, EditRect, this, nextEditID);
		if (bRet)
		{
		  CString str;

		  if (m_pUserPolicySettings->UserPolicy[i].bSet == -1)
		     str = "?";
	      else
		     str.Format("%d", m_pUserPolicySettings->UserPolicy[i].bSet);

		  pEdit->SetWindowText(str);
          this->m_arEditArray.Add(pEdit);
		}
		else
		   delete pEdit;

		pStatic = new CStatic;
		StaticRect.top    = StaticRectOld.bottom + 7;
		StaticRect.bottom = StaticRectOld.bottom + (StaticRectOld.bottom - StaticRectOld.top) + 7;

		bRet = pStatic->CreateEx(dwStaticStyleEx, "STATIC", m_pUserPolicySettings->UserPolicy[i].PolicyName,
			dwStaticStyle, 	StaticRect,	this, iStatic);

		if (bRet)
           this->m_arStaticArray.Add(pStatic);
		else
		   delete pStatic;
	}

//set second column for machine policies
	pWnd = GetDlgItem(IDC_USEREDITCOL2);
	if (pWnd)
	{
	  CString str;

	  if (m_pUserPolicySettings->UserPolicy[i].bSet == -1)
		  str = "?";
	  else
		 str.Format("%d", m_pUserPolicySettings->UserPolicy[i].bSet);
	  pWnd->SetWindowText(str);

      pWnd->GetWindowRect(&EditRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&EditRect, 2);
 //     ScreenToClient(&EditRect);
	}

	pWnd = GetDlgItem(IDC_USERCOL2);
	if (pWnd)
	{
       pWnd->SetWindowText(m_pUserPolicySettings->UserPolicy[i].PolicyName);

       pWnd->GetWindowRect(&StaticRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&StaticRect, 2);
 //      ScreenToClient(&StaticRect);
	}

//create and populate state of each user policy in second row
	for (int j = i+1; j < m_pUserPolicySettings->iNumberUserPolicies; j++)
	{
		nextEditID = IDC_USEREDITCOL2 + j*2;

		EditRectOld = EditRect;
		StaticRectOld = StaticRect;

		pEdit = new CEdit;
		EditRect.top    = EditRectOld.bottom + 7;
		EditRect.bottom = EditRectOld.bottom + (EditRectOld.bottom - EditRectOld.top) + 7;
		bRet = pEdit->CreateEx(dwEditStyleEx, "EDIT", NULL, dwEditStyle, EditRect, this, nextEditID);
		if (bRet)
		{
		  CString str;

		  if (m_pUserPolicySettings->UserPolicy[j].bSet == -1)
		     str = "?";
	      else
		     str.Format("%d", m_pUserPolicySettings->UserPolicy[j].bSet);

		  pEdit->SetWindowText(str);
          this->m_arEditArray.Add(pEdit);
		}
		else
		   delete pEdit;

		pStatic = new CStatic;
		StaticRect.top    = StaticRectOld.bottom + 7;
		StaticRect.bottom = StaticRectOld.bottom + (StaticRectOld.bottom - StaticRectOld.top) + 7;
		bRet = pStatic->CreateEx(dwStaticStyleEx, "STATIC", m_pUserPolicySettings->UserPolicy[j].PolicyName, dwStaticStyle, StaticRect, this, iStatic);
		if (bRet)
           this->m_arStaticArray.Add(pStatic);
		else
		   delete pStatic;
	}
}

//make sure all controls use same font, stupid MFC problem...
	SendMessageToDescendants(WM_SETFONT, (WPARAM)this->GetFont()->m_hObject, //handle to font
		   MAKELONG ((WORD) FALSE, 0), //See above 
		   FALSE);    // send to all decedents(TRUE) 
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\propd.cpp ===
// PropD.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "PropD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropDlg dialog


CPropDlg::CPropDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPropDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPropDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_bNestedPropSortUp = TRUE;
	m_bClientPropSortUp = TRUE;
	m_bServerPropSortUp = TRUE;

	m_iNestedLastColumnClick = 0;
	m_iClientLastColumnClick = 0;
	m_iServerLastColumnClick = 0;

	m_iNestedLastColumnClickCache = 0;
	m_iClientLastColumnClickCache = 0;
	m_iServerLastColumnClickCache = 0;

	m_bCurrentSortUp = FALSE;
	m_pCurrentListSorting = NULL;

	m_pcstrNestedPropNameArray = NULL;
	m_pcstrClientPropNameArray = NULL;
	m_pcstrServerPropNameArray = NULL;
}


void CPropDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropDlg)
	DDX_Control(pDX, IDC_NESTEDPROP, m_lstNestedProp);
	DDX_Control(pDX, IDC_SERVERPROP, m_lstServerProp);
	DDX_Control(pDX, IDC_CLIENTPROP, m_lstClientProp);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropDlg, CDialog)
	//{{AFX_MSG_MAP(CPropDlg)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_CLIENTPROP, OnColumnClickClientProp)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_NESTEDPROP, OnColumnClickNestedProp)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_SERVERPROP, OnColumnClickServerProp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropDlg message handlers

BOOL CPropDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	RECT r;
	m_lstServerProp.GetClientRect(&r);

	int widthCol1;
	int widthCol2;

	//col 1 & 2 takes up around half of area...
	widthCol1 = widthCol2 = ((r.right - r.left) / 2);
	
	m_lstServerProp.InsertColumn(0, "Property", LVCFMT_LEFT, widthCol1);
	m_lstServerProp.InsertColumn(1, "Value", LVCFMT_LEFT, widthCol2);

	m_lstClientProp.InsertColumn(0, "Property", LVCFMT_LEFT, widthCol1);
	m_lstClientProp.InsertColumn(1, "Value", LVCFMT_LEFT, widthCol2);

	m_lstNestedProp.InsertColumn(0, "Property", LVCFMT_LEFT, widthCol1);
	m_lstNestedProp.InsertColumn(1, "Value", LVCFMT_LEFT, widthCol2);

    //autosize last column for best look and to get rid of scroll bar
	m_lstServerProp.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);
	m_lstClientProp.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);
    m_lstNestedProp.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);


	//full row select...
	m_lstServerProp.SetExtendedStyle(m_lstServerProp.GetExtendedStyle() | LVS_EX_FULLROWSELECT);
	m_lstClientProp.SetExtendedStyle(m_lstClientProp.GetExtendedStyle() | LVS_EX_FULLROWSELECT);
	m_lstNestedProp.SetExtendedStyle(m_lstNestedProp.GetExtendedStyle() | LVS_EX_FULLROWSELECT);

    int count;
	int i;

	if (m_pcstrClientPropNameArray)
	{
  	   count = m_pcstrClientPropNameArray->GetSize();
	   for (i = 0; i < count; i++)
	   {
          m_lstClientProp.InsertItem(i, m_pcstrClientPropNameArray->GetAt(i), 0);
		  m_lstClientProp.SetItemData(i, i);
          m_lstClientProp.SetItemText(i, 1, m_pcstrClientPropValueArray->GetAt(i));
		}
	}

	if (m_pcstrServerPropNameArray)
	{
	    count = m_pcstrServerPropNameArray->GetSize();
	    for (i = 0; i < count; i++)
		{
            m_lstServerProp.InsertItem(i, m_pcstrServerPropNameArray->GetAt(i), 0);
		    m_lstServerProp.SetItemData(i, i);
            m_lstServerProp.SetItemText(i, 1, m_pcstrServerPropValueArray->GetAt(i));
		}
	}

	if (m_pcstrNestedPropNameArray)
	{
	    count = this->m_pcstrNestedPropNameArray->GetSize();
	    for (i = 0; i < count; i++)
		{
            m_lstNestedProp.InsertItem(i, m_pcstrNestedPropNameArray->GetAt(i), 0);
		    m_lstNestedProp.SetItemData(i, i);
            m_lstNestedProp.SetItemText(i, 1, m_pcstrNestedPropValueArray->GetAt(i));
		}
	}

	return TRUE;
}


//nmanis, for sorting of columns...
int CALLBACK CPropDlg::CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CPropDlg *pDlg; //we pass "this" in to this callback...
    pDlg = (CPropDlg *) lParamSort; 

    LV_FINDINFO FindItem1;
    LV_FINDINFO FindItem2;

    ZeroMemory(&FindItem1, sizeof(LV_FINDINFO));
    ZeroMemory(&FindItem2, sizeof(LV_FINDINFO));

    FindItem1.flags  = LVFI_PARAM;
    FindItem1.lParam = lParam1;

    FindItem2.flags = LVFI_PARAM;
    FindItem2.lParam = lParam2;

    int iIndexItem1 = pDlg->m_pCurrentListSorting->FindItem(&FindItem1);
    int iIndexItem2 = pDlg->m_pCurrentListSorting->FindItem(&FindItem2);

	if (pDlg->m_pCurrentListSorting)
	{
      CString str1 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem1, pDlg->m_iCurrentColumnSorting);
      CString str2 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem2, pDlg->m_iCurrentColumnSorting);
      switch (pDlg->m_iCurrentColumnSorting)
	  {
        case 0: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     
              break;

        case 1: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

              break;  //no needed, just in case we forget...
	  }
	}

    return 0;
}
//end nmanis, sorting function


void CPropDlg::OnColumnClickClientProp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iClientLastColumnClick = pNMListView->iSubItem;
    if (m_iClientLastColumnClickCache == m_iClientLastColumnClick) //if click on different column, don't toggle
	{
       m_bClientPropSortUp = !m_bClientPropSortUp;  //toggle it...
	}


    m_iClientLastColumnClickCache = m_iClientLastColumnClick;  //save last header clicked

    m_pCurrentListSorting = &m_lstClientProp;
	m_iCurrentColumnSorting = m_iClientLastColumnClick;
	m_bCurrentSortUp = m_bClientPropSortUp;

    //we are going to do a custom sort...
    m_lstClientProp.SortItems(CompareFunc, (LPARAM) this);
	*pResult = 0;
}


void CPropDlg::OnColumnClickNestedProp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iNestedLastColumnClick = pNMListView->iSubItem;
    if (m_iNestedLastColumnClickCache == m_iNestedLastColumnClick) //if click on different column, don't toggle
       m_bNestedPropSortUp = !m_bNestedPropSortUp;  //toggle it...

    m_iNestedLastColumnClickCache = m_iNestedLastColumnClick;  //save last header clicked

	m_pCurrentListSorting = &m_lstNestedProp;
	m_iCurrentColumnSorting = m_iNestedLastColumnClick;
	m_bCurrentSortUp = m_bNestedPropSortUp;

	m_lstNestedProp.SortItems(CompareFunc, (LPARAM) this);
	*pResult = 0;
}


void CPropDlg::OnColumnClickServerProp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iServerLastColumnClick = pNMListView->iSubItem;
    if (m_iServerLastColumnClickCache == m_iServerLastColumnClick) //if click on different column, don't toggle
       m_bServerPropSortUp = !m_bServerPropSortUp;  //toggle it...

    m_iServerLastColumnClickCache = m_iServerLastColumnClick;  //save last header clicked

	m_pCurrentListSorting = &m_lstServerProp;
	m_iCurrentColumnSorting = m_iServerLastColumnClick;
	m_bCurrentSortUp = m_bServerPropSortUp;

	m_lstServerProp.SortItems(CompareFunc, (LPARAM) this);
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\propsht.cpp ===
// propsht.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "propsht.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMyPropertySheet

IMPLEMENT_DYNAMIC(CMyPropertySheet, CPropertySheet)

CMyPropertySheet::CMyPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CMyPropertySheet::CMyPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

CMyPropertySheet::~CMyPropertySheet()
{
}


BEGIN_MESSAGE_MAP(CMyPropertySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CMyPropertySheet)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMyPropertySheet message handlers

BOOL CMyPropertySheet::OnInitDialog() 
{
	BOOL bResult = CPropertySheet::OnInitDialog();

	//put tabs at bottom...
    CTabCtrl *pTab = GetTabControl();
    if (pTab)
	{
	   long val;
       val = ::GetWindowLong(pTab->m_hWnd, GWL_STYLE);
	   if (!(val & TCS_BOTTOM)) 
	   { 
	     val |= TCS_BOTTOM;
		 ::SetWindowLong(pTab->m_hWnd, GWL_STYLE, val);
	   } 

	   SetActivePage(0);
	}
	
    CWnd* pApplyButton = GetDlgItem (ID_APPLY_NOW);
    ASSERT (pApplyButton);
	if (pApplyButton)
	   pApplyButton->ShowWindow (SW_HIDE);


    CWnd* pCancelButton = GetDlgItem (IDCANCEL);
    ASSERT (pCancelButton);
	if (pCancelButton)
	   pCancelButton->SetWindowText("OK");

	CWnd* pOKButton = GetDlgItem (IDOK);
    ASSERT (pOKButton);
	if (pOKButton)
	   pOKButton->ShowWindow (SW_HIDE);

	return bResult;
}

int CMyPropertySheet::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CPropertySheet::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\propd.h ===
#if !defined(AFX_PROPDLG_H__7D0406B8_7960_4B25_A848_EA6A5C3325E2__INCLUDED_)
#define AFX_PROPDLG_H__7D0406B8_7960_4B25_A848_EA6A5C3325E2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PropD.h : header file
//

#include <afxcmn.h>

/////////////////////////////////////////////////////////////////////////////
// CPropDlg dialog
class CPropDlg : public CDialog
{
// Construction
public:
	CPropDlg(CWnd* pParent = NULL);   // standard constructor

    BOOL m_bNestedPropSortUp;
	BOOL m_bClientPropSortUp;
	BOOL m_bServerPropSortUp;

	static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

// Dialog Data
	//{{AFX_DATA(CPropDlg)
	enum { IDD = IDD_PROPDLG1 };
	CListCtrl	m_lstNestedProp;
	CListCtrl	m_lstServerProp;
	CListCtrl	m_lstClientProp;
	//}}AFX_DATA

	BOOL SetClientPropNames(CStringArray *cstrClientPropNameArray)
	{
        m_pcstrClientPropNameArray = cstrClientPropNameArray;
		return TRUE;
	}

	BOOL SetClientPropValues(CStringArray *cstrClientPropValueArray)
	{
        m_pcstrClientPropValueArray = cstrClientPropValueArray;
		return TRUE;
	}
	
	BOOL SetServerPropNames(CStringArray *cstrServerPropNameArray)
	{
        m_pcstrServerPropNameArray = cstrServerPropNameArray;
		return TRUE;
	}

	BOOL SetServerPropValues(CStringArray *cstrServerPropValueArray)
	{
        m_pcstrServerPropValueArray = cstrServerPropValueArray;
		return TRUE;
	}


	BOOL SetNestedPropNames(CStringArray *cstrNestedPropNameArray)
	{
        m_pcstrNestedPropNameArray = cstrNestedPropNameArray;
		return TRUE;
	}

	BOOL SetNestedPropValues(CStringArray *cstrNestedPropValueArray)
	{
        m_pcstrNestedPropValueArray = cstrNestedPropValueArray;
		return TRUE;
	}


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CStringArray *m_pcstrClientPropNameArray;
	CStringArray *m_pcstrClientPropValueArray;

	CStringArray *m_pcstrServerPropNameArray;
	CStringArray *m_pcstrServerPropValueArray;

	CStringArray *m_pcstrNestedPropNameArray;
	CStringArray *m_pcstrNestedPropValueArray;

	CListCtrl *m_pCurrentListSorting;
	int       m_iCurrentColumnSorting;
	BOOL      m_bCurrentSortUp;

	int  m_iNestedLastColumnClick;
	int  m_iClientLastColumnClick;
	int  m_iServerLastColumnClick;

	int  m_iNestedLastColumnClickCache;
	int  m_iClientLastColumnClickCache;
	int  m_iServerLastColumnClickCache;

	// Generated message map functions
	//{{AFX_MSG(CPropDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnColumnClickClientProp(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClickNestedProp(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClickServerProp(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPDLG_H__7D0406B8_7960_4B25_A848_EA6A5C3325E2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\propsht.h ===
#if !defined(AFX_MYPROPERTYSHEET_H__DF81F4AF_6637_4CBB_9FAF_0B5CB388345E__INCLUDED_)
#define AFX_MYPROPERTYSHEET_H__DF81F4AF_6637_4CBB_9FAF_0B5CB388345E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MyPropertySheet.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMyPropertySheet

class CMyPropertySheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CMyPropertySheet)

// Construction
public:
	CMyPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CMyPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertySheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMyPropertySheet();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMyPropertySheet)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MYPROPERTYSHEET_H__DF81F4AF_6637_4CBB_9FAF_0B5CB388345E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\serverpp.cpp ===
// serverpp.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "serverpp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CServerPropertyPage property page

IMPLEMENT_DYNCREATE(CServerPropertyPage, CPropertyPage)

CServerPropertyPage::CServerPropertyPage() : CPropertyPage(CServerPropertyPage::IDD)
{
	//{{AFX_DATA_INIT(CServerPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bServerPropSortUp = TRUE;
	m_iServerLastColumnClick = 0;
	m_iServerLastColumnClickCache = 0;

	m_bCurrentSortUp = FALSE;
	m_pCurrentListSorting = NULL;
	m_pcstrServerPropNameArray = NULL;
}

CServerPropertyPage::~CServerPropertyPage()
{
}

void CServerPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerPropertyPage)
	DDX_Control(pDX, IDC_SERVERPROP, m_lstServerProp);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CServerPropertyPage)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_SERVERPROP, OnColumnClickServerProp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerPropertyPage message handlers

BOOL CServerPropertyPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	RECT r;
	m_lstServerProp.GetClientRect(&r);

	int widthCol1;
	int widthCol2;

	//col 1 & 2 takes up around half of area...
	widthCol1 = widthCol2 = ((r.right - r.left) / 2);
	
	m_lstServerProp.InsertColumn(0, "Property", LVCFMT_LEFT, widthCol1);
	m_lstServerProp.InsertColumn(1, "Value", LVCFMT_LEFT, widthCol2);

    //autosize last column for best look and to get rid of scroll bar
	m_lstServerProp.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);
	m_lstServerProp.SetExtendedStyle(m_lstServerProp.GetExtendedStyle() | LVS_EX_FULLROWSELECT);

	int i, count;
	if (m_pcstrServerPropNameArray)
	{
	    count = m_pcstrServerPropNameArray->GetSize();
	    for (i = 0; i < count; i++)
		{
            m_lstServerProp.InsertItem(i, m_pcstrServerPropNameArray->GetAt(i), 0);
		    m_lstServerProp.SetItemData(i, i);
            m_lstServerProp.SetItemText(i, 1, m_pcstrServerPropValueArray->GetAt(i));
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


//nmanis, for sorting of columns...
int CALLBACK CServerPropertyPage::CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CServerPropertyPage *pDlg; //we pass "this" in to this callback...
    pDlg = (CServerPropertyPage *) lParamSort; 

    LV_FINDINFO FindItem1;
    LV_FINDINFO FindItem2;

    ZeroMemory(&FindItem1, sizeof(LV_FINDINFO));
    ZeroMemory(&FindItem2, sizeof(LV_FINDINFO));

    FindItem1.flags  = LVFI_PARAM;
    FindItem1.lParam = lParam1;

    FindItem2.flags = LVFI_PARAM;
    FindItem2.lParam = lParam2;

    int iIndexItem1 = pDlg->m_pCurrentListSorting->FindItem(&FindItem1);
    int iIndexItem2 = pDlg->m_pCurrentListSorting->FindItem(&FindItem2);

	if (pDlg->m_pCurrentListSorting)
	{
      CString str1 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem1, pDlg->m_iCurrentColumnSorting);
      CString str2 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem2, pDlg->m_iCurrentColumnSorting);
      switch (pDlg->m_iCurrentColumnSorting)
	  {
        case 0: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     
              break;

        case 1: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

              break;  //no needed, just in case we forget...
	  }
	}

    return 0;
}
//end nmanis, sorting function

void CServerPropertyPage::OnColumnClickServerProp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iServerLastColumnClick = pNMListView->iSubItem;
    if (m_iServerLastColumnClickCache == m_iServerLastColumnClick) //if click on different column, don't toggle
       m_bServerPropSortUp = !m_bServerPropSortUp;  //toggle it...

    m_iServerLastColumnClickCache = m_iServerLastColumnClick;  //save last header clicked

	m_pCurrentListSorting = &m_lstServerProp;
	m_iCurrentColumnSorting = m_iServerLastColumnClick;
	m_bCurrentSortUp = m_bServerPropSortUp;

	m_lstServerProp.SortItems(CompareFunc, (LPARAM) this);
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\serverpp.h ===
#if !defined(AFX_SERVERPROPERTYPAGE_H__11970E3E_6F55_4FEE_887B_991F70728066__INCLUDED_)
#define AFX_SERVERPROPERTYPAGE_H__11970E3E_6F55_4FEE_887B_991F70728066__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ServerPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CServerPropertyPage dialog

class CServerPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CServerPropertyPage)

// Construction
public:
	CServerPropertyPage();
	~CServerPropertyPage();

	static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

	BOOL SetServerPropNames(CStringArray *cstrServerPropNameArray)
	{
        m_pcstrServerPropNameArray = cstrServerPropNameArray;
		return TRUE;
	}

	BOOL SetServerPropValues(CStringArray *cstrServerPropValueArray)
	{
        m_pcstrServerPropValueArray = cstrServerPropValueArray;
		return TRUE;
	}

// Dialog Data
	//{{AFX_DATA(CServerPropertyPage)
	enum { IDD = IDD_PROPPAGE_SERVER };
	CListCtrl	m_lstServerProp;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServerPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	BOOL m_bServerPropSortUp;

// Implementation
protected:
	CStringArray *m_pcstrServerPropNameArray;
	CStringArray *m_pcstrServerPropValueArray;

	CListCtrl *m_pCurrentListSorting;
	int       m_iCurrentColumnSorting;
	BOOL      m_bCurrentSortUp;

	int  m_iServerLastColumnClick;
	int  m_iServerLastColumnClickCache;

	// Generated message map functions
	//{{AFX_MSG(CServerPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnColumnClickServerProp(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SERVERPROPERTYPAGE_H__11970E3E_6F55_4FEE_887B_991F70728066__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ShowInstallLogs.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\statesd.cpp ===
// StatesD.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "statesd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CStatesDlg dialog


CStatesDlg::CStatesDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CStatesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CStatesDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pcstrComponentNameArray = NULL;
	m_pcstrFeatureNameArray = NULL;

//for sorting columns...
	m_iFeatureLastColumnClick = 0;
	m_iComponentLastColumnClick = 0;

	m_iFeatureLastColumnClickCache = 0;
	m_iComponentLastColumnClickCache = 0;

	m_bCurrentSortUp = FALSE;
	m_pCurrentListSorting = NULL;
    m_iCurrentColumnSorting = 0;

	m_bFeatureSortUp = FALSE;
	m_bComponentSortUp = FALSE;
}


void CStatesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStatesDlg)
	DDX_Control(pDX, IDC_FEATURESTATES, m_lstFeatureStates);
	DDX_Control(pDX, IDC_COMPONENTSTATES, m_lstComponentStates);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStatesDlg, CDialog)
	//{{AFX_MSG_MAP(CStatesDlg)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_COMPONENTSTATES, OnColumnClickComponentStates)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_FEATURESTATES, OnColumnClickFeatureStates)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStatesDlg message handlers

BOOL CStatesDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	RECT r;
	m_lstFeatureStates.GetClientRect(&r);

	int widthCol1;
	int widthCol2;

    //col 1 for states takes up around half of area...
	widthCol1 = ((r.right - r.left) / 2);

	//divide rest evenly between three other columns...
    widthCol2 = (((r.right - r.left) / 2) / 3) + 1; //+1 for int rounding errors

	m_lstFeatureStates.InsertColumn(0, "Feature name", LVCFMT_LEFT, widthCol1);
	m_lstFeatureStates.InsertColumn(1, "Installed", LVCFMT_LEFT, widthCol2);
	m_lstFeatureStates.InsertColumn(2, "Request", LVCFMT_LEFT, widthCol2);
	m_lstFeatureStates.InsertColumn(3, "Action", LVCFMT_LEFT, widthCol2);

	m_lstComponentStates.InsertColumn(0, "Component name", LVCFMT_LEFT, widthCol1);
	m_lstComponentStates.InsertColumn(1, "Installed", LVCFMT_LEFT, widthCol2);
	m_lstComponentStates.InsertColumn(2, "Request", LVCFMT_LEFT, widthCol2);
	m_lstComponentStates.InsertColumn(3, "Action", LVCFMT_LEFT, widthCol2);

	//full row select...
	m_lstComponentStates.SetExtendedStyle(m_lstComponentStates.GetExtendedStyle() | LVS_EX_FULLROWSELECT);
	m_lstFeatureStates.SetExtendedStyle(m_lstFeatureStates.GetExtendedStyle() | LVS_EX_FULLROWSELECT);


	int i;
	int nCount;
	
	if (m_pcstrComponentNameArray)
	{
		nCount = m_pcstrComponentNameArray->GetSize();  
	    for (i=0; i < nCount; i++)
		{
		    m_lstComponentStates.InsertItem(i, m_pcstrComponentNameArray->GetAt(i), 0);
	        m_lstComponentStates.SetItemText(i, 1, m_pcstrComponentInstalledArray->GetAt(i));
	        m_lstComponentStates.SetItemText(i, 2, m_pcstrComponentRequestArray->GetAt(i));
	        m_lstComponentStates.SetItemText(i, 3, m_pcstrComponentActionArray->GetAt(i));

		    //for sorting later on...
		    m_lstComponentStates.SetItemData(i, i);
		}
	}

	if (m_pcstrFeatureNameArray)
	{
	   nCount = m_pcstrFeatureNameArray->GetSize();  
	   for (i=0; i < nCount; i++)
	   {
          m_lstFeatureStates.InsertItem(i, m_pcstrFeatureNameArray->GetAt(i), 0);
	      m_lstFeatureStates.SetItemText(i, 1, m_pcstrFeatureInstalledArray->GetAt(i));
	      m_lstFeatureStates.SetItemText(i, 2, m_pcstrFeatureRequestArray->GetAt(i));
	      m_lstFeatureStates.SetItemText(i, 3, m_pcstrFeatureActionArray->GetAt(i));

          //for sorting later on...
		  m_lstFeatureStates.SetItemData(i, i);
	   }
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CStatesDlg::OnColumnClickComponentStates(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iComponentLastColumnClick = pNMListView->iSubItem;
    if (m_iComponentLastColumnClickCache == m_iComponentLastColumnClick) //if click on different column, don't toggle
	{
       m_bComponentSortUp = !m_bComponentSortUp;  //toggle it...
	}

    m_iComponentLastColumnClickCache = m_iComponentLastColumnClick;  //save last header clicked

    m_pCurrentListSorting = &m_lstComponentStates;
	m_iCurrentColumnSorting = m_iComponentLastColumnClick;
	m_bCurrentSortUp = m_bComponentSortUp;

    //we are going to do a custom sort...
    m_lstComponentStates.SortItems(CompareFunc, (LPARAM) this);

	*pResult = 0;
}


void CStatesDlg::OnColumnClickFeatureStates(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iFeatureLastColumnClick = pNMListView->iSubItem;
    if (m_iFeatureLastColumnClickCache == m_iFeatureLastColumnClick) //if click on different column, don't toggle
	{
       m_bFeatureSortUp = !m_bFeatureSortUp;  //toggle it...
	}

    m_iFeatureLastColumnClickCache = m_iFeatureLastColumnClick;  //save last header clicked

    m_pCurrentListSorting = &m_lstFeatureStates;
	m_iCurrentColumnSorting = m_iFeatureLastColumnClick;
	m_bCurrentSortUp = m_bFeatureSortUp;

    //we are going to do a custom sort...
    m_lstFeatureStates.SortItems(CompareFunc, (LPARAM) this);
	
	*pResult = 0;
}

//nmanis, for sorting of columns...
int CALLBACK CStatesDlg::CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CStatesDlg *pDlg; //we pass "this" in to this callback...
    pDlg = (CStatesDlg *) lParamSort; 

    LV_FINDINFO FindItem1;
    LV_FINDINFO FindItem2;

    ZeroMemory(&FindItem1, sizeof(LV_FINDINFO));
    ZeroMemory(&FindItem2, sizeof(LV_FINDINFO));

    FindItem1.flags  = LVFI_PARAM;
    FindItem1.lParam = lParam1;

    FindItem2.flags = LVFI_PARAM;
    FindItem2.lParam = lParam2;

    int iIndexItem1 = pDlg->m_pCurrentListSorting->FindItem(&FindItem1);
    int iIndexItem2 = pDlg->m_pCurrentListSorting->FindItem(&FindItem2);

	if (pDlg->m_pCurrentListSorting)
	{
      CString str1 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem1, pDlg->m_iCurrentColumnSorting);
      CString str2 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem2, pDlg->m_iCurrentColumnSorting);
      switch (pDlg->m_iCurrentColumnSorting)
	  {
        case 0: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     
              break;

        case 1: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

        case 2: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

        case 3: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

              break;  //no needed, just in case we forget...
	  }
	}

    return 0;
}
//end nmanis, sorting function
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\statesd.h ===
#if !defined(AFX_STATESDLG_H__6E91AEDB_6AB7_4574_B567_5DC4928578DC__INCLUDED_)
#define AFX_STATESDLG_H__6E91AEDB_6AB7_4574_B567_5DC4928578DC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// StatesDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CStatesDlg dialog
class CStatesDlg : public CDialog
{
// Construction
public:
	CStatesDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CStatesDlg)
	enum { IDD = IDD_STATESDLG1 };
	CListCtrl	m_lstFeatureStates;
	CListCtrl	m_lstComponentStates;
	//}}AFX_DATA

	//sorting function for columns...
	static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

//sorting vars used in callback CompareFunc
	CListCtrl *m_pCurrentListSorting;
	BOOL m_bCurrentSortUp;
	int  m_iCurrentColumnSorting;
//end sorting vars...
	
	BOOL SetComponentNames(CStringArray *cstrComponentNameArray)
	{
        m_pcstrComponentNameArray = cstrComponentNameArray;
		return TRUE;
	}

	BOOL SetComponentInstalled(CStringArray *cstrComponentInstalledArray)
	{
        m_pcstrComponentInstalledArray = cstrComponentInstalledArray;
		return TRUE;
	}

	BOOL SetComponentRequest(CStringArray *cstrComponentRequestArray)
	{
        m_pcstrComponentRequestArray = cstrComponentRequestArray;
		return TRUE;
	}

	BOOL SetComponentAction(CStringArray *cstrComponentActionArray)
	{
        m_pcstrComponentActionArray = cstrComponentActionArray;
		return TRUE;
	}


	BOOL SetFeatureNames(CStringArray *cstrFeatureNameArray)
	{
        m_pcstrFeatureNameArray = cstrFeatureNameArray;
		return TRUE;
	}

	BOOL SetFeatureInstalled(CStringArray *cstrFeatureInstalledArray)
	{
        m_pcstrFeatureInstalledArray = cstrFeatureInstalledArray;
		return TRUE;
	}

	BOOL SetFeatureRequest(CStringArray *cstrFeatureRequestArray)
	{
        m_pcstrFeatureRequestArray = cstrFeatureRequestArray;
		return TRUE;
	}

	BOOL SetFeatureAction(CStringArray *cstrFeatureActionArray)
	{
        m_pcstrFeatureActionArray = cstrFeatureActionArray;
		return TRUE;
	}

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStatesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CStringArray *m_pcstrComponentNameArray;
	CStringArray *m_pcstrComponentInstalledArray;
	CStringArray *m_pcstrComponentRequestArray;
	CStringArray *m_pcstrComponentActionArray;

	CStringArray *m_pcstrFeatureNameArray;
	CStringArray *m_pcstrFeatureInstalledArray;
	CStringArray *m_pcstrFeatureRequestArray;
	CStringArray *m_pcstrFeatureActionArray;

//used for sorting columns...
	int m_iFeatureLastColumnClick;
	int m_iComponentLastColumnClick;

	int m_iFeatureLastColumnClickCache;
	int m_iComponentLastColumnClickCache;

	BOOL m_bFeatureSortUp;
	BOOL m_bComponentSortUp;
//end sorting vars

	// Generated message map functions
	//{{AFX_MSG(CStatesDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnColumnClickComponentStates(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClickFeatureStates(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STATESDLG_H__6E91AEDB_6AB7_4574_B567_5DC4928578DC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\sources.inc ===
TARGETNAME=wilogutl
!INCLUDE ..\..\..\MsiMake.inc
                  
TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

C_DEFINES=-D"_WIN32_MSM=200" $(C_DEFINES)

UMTYPE=windows

TARGETPATH=$(MSI_BUILD_TARGET)

# 
# Fusionized
# 

SXS_ASSEMBLY_NAME=Microsoft.Windows.MSI.WiLogUtl
SXS_ASSEMBLY_VERSION=2.0 
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=wilogutl.exe.manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1

USE_NATIVE_EH=1


#MSC_OPTIMIZATION=/Odi

USE_MFC=1
USE_STATIC_MFC=1
USE_LIBCMT=1

TARGETLIBS=\
	$(SDK_LIB_PATH)\shell32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\comctl32.lib \
	$(SDK_LIB_PATH)\comdlg32.lib \
	$(SDK_LIB_PATH)\winspool.lib

MFC_LIBS=$(MSI_BIN_PATH)\mfc\*\nafxcw.lib

INCLUDES=$(INC_DIR);$(SDK_INC_PATH);$(O);$(MFC_INCLUDES);$(RES_OBJDIR)

SOURCES=..\clientpp.cpp \
	..\common.cpp \
	..\loganald.cpp \
	..\logparse.cpp \
	..\logviewd.cpp \
	..\nestedpp.cpp \
	..\optionsd.cpp \
	..\policyd.cpp \
	..\propd.cpp \
	..\propsht.cpp \
	..\serverpp.cpp \
	..\showlogd.cpp \
	..\statesd.cpp \
	..\stdafx.cpp \
	..\util.cpp \
	..\wilogutl.cpp \
	..\wilogutl.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\showlogd.h ===
// ShowInstallLogsDlg.h : header file
//

#if !defined(AFX_SHOWINSTALLLOGSDLG_H__CB0487B0_84C3_4D1D_83AE_968A03F9393A__INCLUDED_)
#define AFX_SHOWINSTALLLOGSDLG_H__CB0487B0_84C3_4D1D_83AE_968A03F9393A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <afxtempl.h>
  
struct LogInformation
{
	CString m_strLogName;
	CString m_strPreview;
	BOOL    m_bUnicodeLog;

    LogInformation() : m_strLogName(' ', 256), m_strPreview(' ', 256), m_bUnicodeLog(FALSE)
	{
	}
};

/////////////////////////////////////////////////////////////////////////////
// COpenDlg dialog
class COpenDlg : public CDialog
{
// Construction
public:
	COpenDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(COpenDlg)
	enum { IDD = IDD_SHOWINSTALLLOGS_DIALOG };
	CComboBox	m_cboLogFiles;
	CString	m_strPreview;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COpenDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
//5-9-2001
    BOOL OnToolTipNotify(UINT id, NMHDR *pNMH, LRESULT *pResult);
//end 5-9-2001

	HICON m_hIcon;

	CArray<LogInformation, LogInformation> m_arLogInfo;

	BOOL ParseLog(struct LogInformation *pLogInfoRec);
	BOOL CommonSearch(CString &strDir);


	// Generated message map functions
	//{{AFX_MSG(COpenDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnOpen();
	afx_msg void OnGetlogs();
	afx_msg void OnSelchangeLogfiles();
	afx_msg void OnDetailedDisplay();
	afx_msg void OnFindlog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHOWINSTALLLOGSDLG_H__CB0487B0_84C3_4D1D_83AE_968A03F9393A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\showlogd.cpp ===
// showlogd.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "showlogd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COpenDlg dialog
COpenDlg::COpenDlg(CWnd* pParent /*=NULL*/)
	: CDialog(COpenDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(COpenDlg)
	m_strPreview = _T("");
	//}}AFX_DATA_INIT

	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void COpenDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COpenDlg)
	DDX_Control(pDX, IDC_LOGFILES, m_cboLogFiles);
	DDX_Text(pDX, IDC_PREVIEW, m_strPreview);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(COpenDlg, CDialog)
	//{{AFX_MSG_MAP(COpenDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_OPEN, OnOpen)
	ON_BN_CLICKED(IDC_GETLOGS, OnGetlogs)
	ON_CBN_SELCHANGE(IDC_LOGFILES, OnSelchangeLogfiles)
	ON_BN_CLICKED(IDC_ANALYZE, OnDetailedDisplay)
	ON_BN_CLICKED(IDC_FINDLOG, OnFindlog)
	//}}AFX_MSG_MAP

//5-9-2001, add tooltips!!!
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT,0,0xFFFF,OnToolTipNotify)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COpenDlg message handlers
BOOL COpenDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	EnableToolTips(TRUE);
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}


//5-9-2001
BOOL COpenDlg::OnToolTipNotify(UINT id, NMHDR *pNMH, LRESULT *pResult)
{
       TOOLTIPTEXT *pText = (TOOLTIPTEXT *)pNMH;
       int control_id =  ::GetDlgCtrlID((HWND)pNMH->idFrom);
       if(control_id)
       {
           pText->lpszText = MAKEINTRESOURCE(control_id);
           pText->hinst = AfxGetInstanceHandle();
           return TRUE;
       }
       return FALSE;
}
//end 5-9-2001

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.
void COpenDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR COpenDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


//nmanis, handle when user wants to open log
void COpenDlg::OnOpen() 
{
	int nIndex = m_cboLogFiles.GetCurSel();
	int nCount = m_cboLogFiles.GetCount();

	if ((nIndex != LB_ERR) && (nCount >= 1))
	{
       CString str;
       m_cboLogFiles.GetLBText(nIndex, str);
 	   if (!str.IsEmpty())
	   {
		  CString strNotepad;
		  strNotepad = "notepad.exe ";
		  strNotepad += str;
		  WinExec(strNotepad, SW_SHOW);
	   }
	}
    else if (nCount <= 0)
	{
       if (!g_bRunningInQuietMode)
	      AfxMessageBox("No log files currently in list.");
	}
    else
	{
       if (!g_bRunningInQuietMode)
          AfxMessageBox("Please select a log file first.");
	}
}



//nmanis, buffer size to read in each time
#define LOG_BUF_READ_SIZE 8192

//max lines to preview in pLogInfoRec->m_strPreview
#define MAX_PREVIEW       100

//this is called when just showing the current file selected to view
BOOL COpenDlg::ParseLog(struct LogInformation *pLogInfoRec)
{
	ASSERT(pLogInfoRec != NULL);

	BOOL bRet = DetermineLogType(pLogInfoRec->m_strLogName, &pLogInfoRec->m_bUnicodeLog);
	if (bRet)
	{
		CString buffer = "";
		int  iCount = 0;
		int  iMax = MAX_PREVIEW;
        BOOL bDone = FALSE;

		FILE *fptr;
	    if (pLogInfoRec->m_bUnicodeLog) //logs are different on NT vs.Win9x.  On NT, they are written in UNICODE, open them differently...
	       fptr = fopen(pLogInfoRec->m_strLogName, "rb");
	    else
	       fptr = fopen(pLogInfoRec->m_strLogName, "r");

	    if (fptr)
		{
	       char ansibuffer[LOG_BUF_READ_SIZE+1];

	       BOOL bEndFile = FALSE;
		   BOOL bError = FALSE;
		   char  *pos = NULL;
		   WCHAR *wpos = NULL;

		   do
		   {
		     if (pLogInfoRec->m_bUnicodeLog) //logs are different on NT vs. Win9x.  On NT, they are written in UNICODE...
			 {
			    const int HalfBufSize = LOG_BUF_READ_SIZE/2;
		        WCHAR widebuffer[HalfBufSize];

			    wpos = fgetws(widebuffer, HalfBufSize, fptr);
			    bError = wpos ? 1 : 0;

				//convert string to ANSI string, all parsing is done with ANSI strings...
		        WideCharToMultiByte(CP_ACP, 0, widebuffer, HalfBufSize, ansibuffer, LOG_BUF_READ_SIZE, NULL, NULL);
			 }
		     else
			 {
		        //do line by line read with fgets()
		        pos = fgets(ansibuffer, LOG_BUF_READ_SIZE, fptr);
				int len1 = strlen(ansibuffer);
				if (len1 > 1 && ansibuffer[len1-2] != '\r')
				{
				  ansibuffer[len1 - 2] = '\r';
				  ansibuffer[len1 - 1] = '\n';
				  ansibuffer[len1] = '\0';
				}

			    bError = pos ? 1 : 0;
			 }

			 iCount++;
			 if (iCount > iMax)
  			    bDone = TRUE;

			 buffer += ansibuffer;
		     bEndFile = feof(fptr);
		   }
		   while (!bEndFile && bError && !bDone);

		   if (!bEndFile && !bError) //error occured...
		   {
#ifdef _DEBUG
              if (!g_bRunningInQuietMode)
			  {
		  	     int iError = ferror(fptr);
            
			     CString cstrErr;
		         cstrErr.Format("Unexpected Error reading file, error = %d", iError);

                 AfxMessageBox(cstrErr);
			  }
#endif

		   }

           pLogInfoRec->m_strPreview = buffer;
		   fclose(fptr);
		}
	    else
		{
		  //error opening file, unexpected...
		}
	}
	else
	{
       if (!g_bRunningInQuietMode)
	   {
	      AfxMessageBox("Could not determine if log is UNICODE or ANSI");
	   }
	}

	return bRet;
}



//nmanis, used to look for log files (msi*.log) files in directory passed
BOOL COpenDlg::CommonSearch(CString &strDir)
{
    BOOL bRet = FALSE;
	WIN32_FIND_DATA finddata = { 0 };
	HANDLE hFind = 0;

	CString strSearch;

	strSearch = strDir;
    strSearch += "msi*.log";
	hFind = FindFirstFile(strSearch, &finddata);
    if (hFind == INVALID_HANDLE_VALUE) 
	{
		//no temp files currently in temp dir...
		return bRet;
	}
	else
	{
       m_arLogInfo.RemoveAll(); 
	   m_cboLogFiles.ResetContent();

	   int iCount = 0;
	   struct LogInformation LogInfoRec;

	   LogInfoRec.m_strLogName = strDir;
	   LogInfoRec.m_strLogName += finddata.cFileName;

	   bRet = ParseLog(&LogInfoRec);
	   if (bRet)
	   {
	      m_arLogInfo.Add(LogInfoRec);
          m_cboLogFiles.InsertString(iCount, LogInfoRec.m_strLogName);

          iCount++;
	   }

	   BOOL bMoreFiles = FindNextFile(hFind, &finddata);
	   while (bMoreFiles)
	   {
		  struct LogInformation LogInfoRec2;

	      LogInfoRec2.m_strLogName = strDir;
		  LogInfoRec2.m_strLogName += finddata.cFileName;

	      bRet = ParseLog(&LogInfoRec2);
	      if (bRet)
		  {
             m_arLogInfo.Add(LogInfoRec2);

	         m_cboLogFiles.InsertString(iCount, LogInfoRec2.m_strLogName);

             iCount++;
		  }

          bMoreFiles = FindNextFile(hFind, &finddata);
	   }

       FindClose(hFind);
  	}

    return bRet;
}

//nmanis, used to get logs from temp directory...
void COpenDlg::OnGetlogs() 
{
	char szTempPath[_MAX_PATH];
	char szFullPath[_MAX_PATH];

	DWORD dwLen = 0;
    dwLen = GetTempPath(_MAX_PATH, szTempPath);
    if (!dwLen)
	{
		OutputDebugString("GetTempPath failed in MSI translate process");
		return;
	}

	strcpy(szFullPath, szTempPath);

	CString cstr;
	cstr = szFullPath;
	CommonSearch(cstr);
}


//nmanis, when user picks different file from combo box, change the preview
void COpenDlg::OnSelchangeLogfiles() 
{
	int nIndex = m_cboLogFiles.GetCurSel();;
	int nCount = m_cboLogFiles.GetCount();

//more than one log in combo box?
	if ((nIndex != LB_ERR) && (nCount > 1))
	{
	  
      CString str;
      m_cboLogFiles.GetLBText(nIndex, str);
	  if (!str.IsEmpty())
	  {
		 LogInformation loginfo;

         loginfo = m_arLogInfo.GetAt(nIndex); //get entry in array
		 m_strPreview = loginfo.m_strPreview; //set preview edit control to data from array entry

		 UpdateData(FALSE); //do the update
	  }
	}
}



//look for a log on disk using file dialog
void COpenDlg::OnFindlog() 
{
   static char szFilter[] = "Log files (*.log;*.txt)|*.log; *.txt|All files (*.*)|*.*||";
   CFileDialog dlg(TRUE, "log", "*.log; *.txt", 0, szFilter );

   //5-3-2001, don't show in quiet mode...
   if (!g_bRunningInQuietMode)
   {
      int iRet = dlg.DoModal();
      if (iRet == IDOK)
	  {
	     struct LogInformation LogInfoRec;
	     LogInfoRec.m_strLogName = dlg.GetPathName();
         BOOL bRet = ParseLog(&LogInfoRec); //get one?  If so, parse it
         if (bRet) //parse ok, if so, add to our array
		 {
	        m_arLogInfo.Add(LogInfoRec);

		    int iCount = m_cboLogFiles.GetCount();

            m_cboLogFiles.InsertString(iCount, LogInfoRec.m_strLogName);
            m_cboLogFiles.SetCurSel(iCount);

		    iCount++;
            //m_bIsUnicodeLogFile = LogInfoRec.m_bUnicodeLog;
		    m_strPreview = LogInfoRec.m_strPreview;

		    UpdateData(FALSE);
		 }
	  }
   }
}


#include "loganald.h"

void COpenDlg::OnDetailedDisplay() 
{
  CLogAnalyzeDlg dlg;

  int nIndex = m_cboLogFiles.GetCurSel();;
  int nCount = m_cboLogFiles.GetCount();

  if ((nIndex != LB_ERR) && (nCount >= 1))
  {
      CString str;
      m_cboLogFiles.GetLBText(nIndex, str);
	  if (!str.IsEmpty())
	  {
	  }

	  dlg.SetLogfileLocation(str);
	  
	  //5-3-2001, don't show in quiet mode...
     if (!g_bRunningInQuietMode)
	    dlg.DoModal();
  }
  else if (nCount <= 0)
  {
	  //5-3-2001, don't show in quiet mode...
      if (!g_bRunningInQuietMode)
	     AfxMessageBox("No log files currently in list.");
  }
  else
  {
	  //5-3-2001, don't show in quiet mode...
      if (!g_bRunningInQuietMode)
	     AfxMessageBox("Please select a log file first.");
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__17BDF522_0D39_4C28_9679_C4802E7DF9DA__INCLUDED_)
#define AFX_STDAFX_H__17BDF522_0D39_4C28_9679_C4802E7DF9DA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

//ignore warning C4100: unreferenced formal parameter
#pragma warning (disable:4100)

#include <afxwin.h>         // MFC core and standard components
//#include <afxext.h>         // MFC extensions
//#include <afxdisp.h>        // MFC Automation classes
//#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


#include <afxdlgs.h>  //for CFileDialog
#include <afxtempl.h> //for CArray

//our standard includes that don't change much now
#include "util.h"
#include "common.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__17BDF522_0D39_4C28_9679_C4802E7DF9DA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\util.h ===
#ifndef UTIL_H
#define UTIL_H

BOOL DetermineLogType(CString &cstrLogFileName, BOOL *bIsUnicodeLog);
BOOL StripLineFeeds(char *lpszString);
BOOL IsValidDirectory(CString cstrDir);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\util.cpp ===
#include "stdafx.h"
#include "util.h"

#define LOG_BUF_READ_SIZE 8192

BOOL ANSICheck(char *firstline, BOOL *bIsUnicodeLog)
{
	BOOL bRet = FALSE;

	char *UnicodePos = NULL;
	char *ANSIPos = NULL;

	UnicodePos = strstr(firstline, "UNICODE");
	ANSIPos = strstr(firstline, "ANSI");
	if (UnicodePos)
	{
	   *bIsUnicodeLog = TRUE;
		bRet = TRUE;
	}
	else if (ANSIPos)
	{
        *bIsUnicodeLog = FALSE;
		bRet = TRUE;
	}

	return bRet;
}


BOOL UnicodeCheck(WCHAR *firstline, BOOL *bIsUnicodeLog)
{
  BOOL bRet = FALSE;

  char ansibuffer[LOG_BUF_READ_SIZE+1];
  const int HalfBufSize = LOG_BUF_READ_SIZE/2;

  int iRet = WideCharToMultiByte(CP_ACP, 0, firstline, HalfBufSize, ansibuffer, LOG_BUF_READ_SIZE, NULL, NULL);
  if (iRet)
  {
	  bRet = ANSICheck(ansibuffer, bIsUnicodeLog);
  }

  return bRet;
}

#define BYTE_ORDER_MARK 0xFEFF

//make decision if passed text is unicode...
BOOL BOMCheck(WCHAR *firstline, BOOL *bIsUnicodeLog)
{
  if (firstline && (*firstline == BYTE_ORDER_MARK))
     *bIsUnicodeLog = TRUE;
  else
     *bIsUnicodeLog = FALSE;

  return TRUE;
}


BOOL DetermineLogType(CString &cstrLogFileName, BOOL *bIsUnicodeLog)
{
	BOOL bRet = FALSE;

	FILE *fptr;
	fptr = fopen(cstrLogFileName, "r");
	if (fptr)
	{
		char firstline[LOG_BUF_READ_SIZE];
		char *pos;

		pos = fgets(firstline, LOG_BUF_READ_SIZE, fptr);
		if (pos)
		{
//we could do this instead of calling the ANSICheck and UnicodeCheck functions below...
//			bRet = BOMCheck((WCHAR*)firstline, bIsUnicodeLog);

			bRet = ANSICheck(firstline, bIsUnicodeLog);
			if (!bRet) //ANSI checking failed, try to check by reading in UNICODE...
			{
				fclose(fptr);
				fptr = fopen(cstrLogFileName, "rb");
				if (fptr)
				{
					WCHAR widebuffer[LOG_BUF_READ_SIZE/2];
					WCHAR *wpos;
                    wpos = fgetws(widebuffer, LOG_BUF_READ_SIZE/2, fptr);
					if (wpos)
					{
						bRet = UnicodeCheck(widebuffer, bIsUnicodeLog);
						if (!bRet) //could not find UNICODE or ANSI in log, try something else...
                           bRet = BOMCheck(widebuffer, bIsUnicodeLog);  
					}
					//else, read failed...

					fclose(fptr);
					fptr = NULL;
				}
				//else open failed...
			}
		}
		//else, read failed!
		if (fptr)
           fclose(fptr);
	}
	else
	{
	    CString cstr;
		cstr.Format("Unexpected error reading file %s.  GetLastError = %x", cstrLogFileName, GetLastError());

	    if (!g_bRunningInQuietMode)
		{
		   AfxMessageBox(cstr);
		}
	}

	return bRet;
}

//move to util.cpp
BOOL StripLineFeeds(char *szString)
{
	BOOL bRet = FALSE;
	int iLen = strlen(szString);

	char *lpszFound = strstr(szString, "\r");
	if (lpszFound)
	{
	   int iPos;
	   iPos = lpszFound - szString;
	   if (iPos >= iLen-2) //at the end???
	   {
		  //strip it off dude...
		  *lpszFound = '\0';
		  bRet = TRUE;
	   }
	}

	lpszFound = strstr(szString, "\n");
	if (lpszFound)
	{
	   int iPos;
	   iPos = lpszFound - szString;
	   if (iPos >= iLen-2) //at the end???
	   {
		  //strip it off dude...
		  *lpszFound = '\0';
		  bRet = TRUE;
	   }
	}

	return bRet;
}

//#include "Dbghelp.h"

//5-4-2001
BOOL IsValidDirectory(CString cstrDir)
{
  BOOL bRet;

  //do the create dir and test...
  bRet = CreateDirectory(cstrDir, NULL);
  if (!bRet)
  {
     DWORD dwErr, dwPrevErr;
     dwPrevErr = dwErr = GetLastError();

	 if (ERROR_DISK_FULL == dwErr)
	 {
		 //TODO...
		 //handle this messed up case...
//		 bRet = MakeSureDirectoryPathExists(cstrDir);
	 }

//5-9-2001, fix for Win9x!
     if (!bRet && (ERROR_ALREADY_EXISTS == dwPrevErr)) //no error really...
     {	 
	    if (g_bNT) //do some extra checks...
		{
		   SetLastError(NO_ERROR);
//5-9-2001

           DWORD dwAccess = GENERIC_READ | GENERIC_WRITE;
		   DWORD dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
		   DWORD dwCreate = OPEN_EXISTING;
	       DWORD dwFlags = FILE_FLAG_BACKUP_SEMANTICS;
  
		   HANDLE hFile = CreateFile(cstrDir, dwAccess, dwShare, 0, dwCreate, dwFlags, NULL);
		   if (hFile == INVALID_HANDLE_VALUE)
		   {
	          dwErr = GetLastError();
              if (ERROR_ALREADY_EXISTS == dwErr) //no error really...
			  {
		         bRet = TRUE;
			  }
		   }
		   else
		   {
		      bRet = TRUE;
		      CloseHandle(hFile);
		   }
		}
		else
		{
		   bRet = TRUE; //5-9-2001, Win9x, assume it is ok 
		}
	 }
  }

  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\wilogres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ShowInstallLogs.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_SHOWINSTALLLOGS_DIALOG      102
#define IDS_NOERRORFOUND                102
#define IDS_NOSOLUTION_NEEDED           103
#define IDD_PROPPAGE_CLIENT             106
#define IDR_MAINFRAME                   128
#define IDR_MAINFRAME1                  129
#define IDD_PROPDLG1                    130
#define IDD_ADVVIEW_DIALOG1             132
#define IDD_STATESDLG1                  133
#define IDR_LEGEND                      135
#define IDR_DETAILS                     136
#define IDD_POLICIESDLG                 137
#define IDR_MENU1                       138
#define IDD_OPTIONS                     139
#define IDR_ALLERRORS                   142
#define IDD_PROPPAGE_SERVER             143
#define IDR_JUMPTAGS                    143
#define IDD_PROPPAGE_NESTED             144
#define IDR_HOWTOREADLOGS               144
#define IDR_WILOGHELP                   145
#define IDC_PRODUCT                     1000
#define IDC_USER                        1001
#define IDC_DATETIME                    1002
#define IDC_VERSION                     1003
#define IDC_CLIENTPRIVILEDGEDETAIL      1004
#define IDC_SERVERPRIVILEDGEDETAIL      1005
#define IDC_GETLOGS                     1006
#define IDC_PREVIEW                     1007
#define IDC_MACHINE                     1009
#define IDC_SHARE                       1010
#define IDC_BUTTON1                     1011
#define IDC_BUTTON2                     1012
#define IDC_COMPONENTSTATES             1013
#define IDC_SOLUTION                    1018
#define IDC_CLIENTPROP                  1019
#define IDC_SHOWSTATES                  1019
#define IDC_SERVERCMDLINE               1020
#define IDC_NESTEDPROP                  1020
#define IDC_ERROR                       1021
#define IDC_CLIENTCMDLINE               1022
#define IDC_FEATURESTATES               1023
#define IDC_SHOWPROP                    1023
#define IDC_SERVERPROP                  1024
#define IDC_ADMINRIGHTS                 1024
#define IDC_EXPLAINLOG                  1025
#define IDC_ISUNICODELOG                1026
#define IDC_POLICIES                    1026
#define IDC_FINDLOG2                    1026
#define IDC_DELETEOUTPUTDIRCONTENTS     1027
#define IDC_PREVIOUSERROR               1069
#define IDC_NEXTERROR                   1070
#define IDC_OUTPUTDIRECTORY             1071
#define IDC_OUTPUTFILENAME              1072
#define IDC_CURRENT_ERROR_NUMBER        1076
#define IDC_TOTAL_ERRORS                1077
#define IDC_SHOW_IGNORED_ERRORS         1078
#define IDC_LIST1                       1079
#define IDC_PROPTEST                    1080
#define IDC_SAVERESULTS                 1081
#define IDC_ELEVATEDINSTALL_TEXT        1082
#define IDC_SHOWINTERNALERRORSHELP      1083
#define IDC_ERROR2                      1084
#define IDC_SHOWHELP                    1084
#define IDC_SHOWHOWTOREADLOG            1085
#define IDC_MACHINEEDITCOL1             2000
#define IDC_MACHINECOL1                 2001
#define IDC_OPEN                        2007
#define IDC_ANALYZE                     2008
#define IDC_FINDLOG                     2009
#define IDC_MACHINEEDITCOL2             3000
#define IDC_MACHINEPROPCOL2             3001
#define IDC_LOGFILES                    3010
#define IDC_USEREDITCOL1                4000
#define IDC_USERCOL1                    4001
#define IDC_USEREDITCOL2                5000
#define IDC_USERCOL2                    5001
#define IDC_CLIENTCONTEXT               6000
#define IDC_SERVERCONTEXT               6001
#define IDC_CUSTOMACTIONCONTEXT         6002
#define IDC_UNKNOWNCONTEXT              6003
#define IDC_ERRORAREA                   6004
#define IDC_PROPERTY                    6005
#define IDC_STATE                       6006
#define IDC_POLICY                      6007
#define IDC_IGNOREDERROR                6008
#define IDC_CHOOSECOLOR_CLIENT          7000
#define IDC_CHOOSECOLOR_SERVER          7001
#define IDC_CHOOSECOLOR__CUSTOMACTION   7002
#define IDC_CHOOSECOLOR_UNKNOWN         7003
#define IDC_CHOOSECOLOR_ERRORAREA       7004
#define IDC_CHOOSECOLOR_PROPERTY        7005
#define IDC_CHOOSECOLOR_STATE           7006
#define IDC_CHOOSECOLOR_POLICY          7007
#define IDC_CHOOSECOLOR_IGNOREDERRORS   7008
#define IDS_INTERNAL_ERROR_BASE         10000
#define IDS_WI_ERROR_1000               11000
#define IDS_WI_ERROR_1001               11001
#define IDS_WI_ERROR_1002               11002
#define IDS_WI_ERROR_1003               11003
#define IDS_WI_ERROR_1004               11004
#define IDS_WI_ERROR_1005               11005
#define IDS_WI_ERROR_1006               11006
#define IDS_WI_ERROR_1007               11007
#define IDS_WI_ERROR_1008               11008
#define IDS_WI_ERROR_1009               11009
#define IDS_WI_ERROR_1010               11010
#define IDS_WI_ERROR_1011               11011
#define IDS_WI_ERROR_1012               11012
#define IDS_WI_ERROR_1013               11013
#define IDS_WI_ERROR_1014               11014
#define IDS_WI_ERROR_1015               11015
#define IDS_WI_ERROR_1016               11016
#define IDS_WI_ERROR_1017               11017
#define IDS_WI_ERROR_1018               11018
#define IDS_WI_ERROR_1019               11019
#define IDS_WI_ERROR_1020               11020
#define IDS_WI_ERROR_1021               11021
#define IDS_WI_ERROR_1022               11022
#define IDS_WI_ERROR_1023               11023
#define IDS_WI_ERROR_1024               11024
#define IDS_WI_ERROR_1025               11025
#define IDS_WI_ERROR_1026               11026
#define IDS_WI_ERROR_1027               11027
#define IDS_WI_ERROR_1028               11028
#define IDS_WI_ERROR_1029               11029
#define IDS_WI_ERROR_1030               11030
#define IDS_WI_ERROR_1031               11031
#define IDS_WI_ERROR_1032               11032
#define IDS_WI_ERROR_1033               11033
#define IDS_WI_ERROR_1034               11034
#define IDS_WI_ERROR_1035               11035
#define IDS_WI_ERROR_1036               11036
#define IDS_WI_ERROR_1037               11037
#define IDS_WI_ERROR_1038               11038
#define IDS_WI_ERROR_1039               11039
#define IDS_WI_ERROR_1040               11040
#define IDS_WI_ERROR_1041               11041
#define IDS_WI_ERROR_1042               11042
#define IDS_WI_ERROR_1043               11043
#define IDS_WI_ERROR_1044               11044
#define IDS_WI_ERROR_1045               11045
#define IDS_WI_ERROR_1046               11046
#define IDS_WI_ERROR_1047               11047
#define IDS_WI_ERROR_1048               11048
#define IDS_WI_ERROR_1049               11049
#define IDS_WI_ERROR_1050               11050
#define IDS_WI_ERROR_1051               11051
#define IDS_WI_ERROR_1052               11052
#define IDS_WI_ERROR_1053               11053
#define IDS_WI_ERROR_1054               11054
#define IDS_WI_ERROR_1055               11055
#define IDS_WI_ERROR_1056               11056
#define IDS_WI_ERROR_1057               11057
#define IDS_WI_ERROR_1058               11058
#define IDS_WI_ERROR_1059               11059
#define IDS_WI_ERROR_1060               11060
#define IDS_WI_ERROR_1061               11061
#define IDS_WI_ERROR_1062               11062
#define IDS_WI_ERROR_1063               11063
#define IDS_WI_ERROR_1064               11064
#define IDS_WI_ERROR_1065               11065
#define IDS_WI_ERROR_1066               11066
#define IDS_WI_ERROR_1067               11067
#define IDS_WI_ERROR_1068               11068
#define IDS_WI_ERROR_1069               11069
#define IDS_WI_ERROR_1070               11070
#define IDS_WI_ERROR_1071               11071
#define IDS_WI_ERROR_1072               11072
#define IDS_WI_ERROR_1073               11073
#define IDS_WI_ERROR_1074               11074
#define IDS_WI_ERROR_1075               11075
#define IDS_WI_ERROR_1076               11076
#define IDS_WI_ERROR_1077               11077
#define IDS_WI_ERROR_1078               11078
#define IDS_WI_ERROR_1079               11079
#define IDS_WI_ERROR_1080               11080
#define IDS_WI_ERROR_1081               11081
#define IDS_WI_ERROR_1082               11082
#define IDS_WI_ERROR_1083               11083
#define IDS_WI_ERROR_1084               11084
#define IDS_WI_ERROR_1085               11085
#define IDS_WI_ERROR_1086               11086
#define IDS_WI_ERROR_1087               11087
#define IDS_WI_ERROR_1088               11088
#define IDS_WI_ERROR_1089               11089
#define IDS_WI_ERROR_1090               11090
#define IDS_WI_ERROR_1091               11091
#define IDS_WI_ERROR_1092               11092
#define IDS_WI_ERROR_1093               11093
#define IDS_WI_ERROR_1094               11094
#define IDS_WI_ERROR_1095               11095
#define IDS_WI_ERROR_1096               11096
#define IDS_WI_ERROR_1097               11097
#define IDS_WI_ERROR_1098               11098
#define IDS_WI_ERROR_1099               11099
#define IDS_WI_ERROR_1100               11100
#define IDS_WI_ERROR_1101               11101
#define IDS_WI_ERROR_1102               11102
#define IDS_WI_ERROR_1103               11103
#define IDS_WI_ERROR_1104               11104
#define IDS_WI_ERROR_1105               11105
#define IDS_WI_ERROR_1106               11106
#define IDS_WI_ERROR_1107               11107
#define IDS_WI_ERROR_1108               11108
#define IDS_WI_ERROR_1109               11109
#define IDS_WI_ERROR_1110               11110
#define IDS_WI_ERROR_1111               11111
#define IDS_WI_ERROR_1112               11112
#define IDS_WI_ERROR_1113               11113
#define IDS_WI_ERROR_1114               11114
#define IDS_WI_ERROR_1115               11115
#define IDS_WI_ERROR_1116               11116
#define IDS_WI_ERROR_1117               11117
#define IDS_WI_ERROR_1118               11118
#define IDS_WI_ERROR_1119               11119
#define IDS_WI_ERROR_1120               11120
#define IDS_WI_ERROR_1121               11121
#define IDS_WI_ERROR_1122               11122
#define IDS_WI_ERROR_1123               11123
#define IDS_WI_ERROR_1124               11124
#define IDS_WI_ERROR_1125               11125
#define IDS_WI_ERROR_1126               11126
#define IDS_WI_ERROR_1127               11127
#define IDS_WI_ERROR_1128               11128
#define IDS_WI_ERROR_1129               11129
#define IDS_WI_ERROR_1130               11130
#define IDS_WI_ERROR_1131               11131
#define IDS_WI_ERROR_1132               11132
#define IDS_WI_ERROR_1133               11133
#define IDS_WI_ERROR_1134               11134
#define IDS_WI_ERROR_1135               11135
#define IDS_WI_ERROR_1136               11136
#define IDS_WI_ERROR_1137               11137
#define IDS_WI_ERROR_1138               11138
#define IDS_WI_ERROR_1139               11139
#define IDS_WI_ERROR_1140               11140
#define IDS_WI_ERROR_1141               11141
#define IDS_WI_ERROR_1142               11142
#define IDS_WI_ERROR_1143               11143
#define IDS_WI_ERROR_1144               11144
#define IDS_WI_ERROR_1145               11145
#define IDS_WI_ERROR_1146               11146
#define IDS_WI_ERROR_1147               11147
#define IDS_WI_ERROR_1148               11148
#define IDS_WI_ERROR_1149               11149
#define IDS_WI_ERROR_1150               11150
#define IDS_WI_ERROR_1151               11151
#define IDS_WI_ERROR_1152               11152
#define IDS_WI_ERROR_1153               11153
#define IDS_WI_ERROR_1154               11154
#define IDS_WI_ERROR_1155               11155
#define IDS_WI_ERROR_1156               11156
#define IDS_WI_ERROR_1157               11157
#define IDS_WI_ERROR_1158               11158
#define IDS_WI_ERROR_1159               11159
#define IDS_WI_ERROR_1160               11160
#define IDS_WI_ERROR_1161               11161
#define IDS_WI_ERROR_1162               11162
#define IDS_WI_ERROR_1163               11163
#define IDS_WI_ERROR_1164               11164
#define IDS_WI_ERROR_1165               11165
#define IDS_WI_ERROR_1166               11166
#define IDS_WI_ERROR_1167               11167
#define IDS_WI_ERROR_1168               11168
#define IDS_WI_ERROR_1169               11169
#define IDS_WI_ERROR_1170               11170
#define IDS_WI_ERROR_1171               11171
#define IDS_WI_ERROR_1172               11172
#define IDS_WI_ERROR_1173               11173
#define IDS_WI_ERROR_1174               11174
#define IDS_WI_ERROR_1175               11175
#define IDS_WI_ERROR_1176               11176
#define IDS_WI_ERROR_1177               11177
#define IDS_WI_ERROR_1178               11178
#define IDS_WI_ERROR_1179               11179
#define IDS_WI_ERROR_1180               11180
#define IDS_WI_ERROR_1181               11181
#define IDS_WI_ERROR_1182               11182
#define IDS_WI_ERROR_1183               11183
#define IDS_WI_ERROR_1184               11184
#define IDS_WI_ERROR_1185               11185
#define IDS_WI_ERROR_1186               11186
#define IDS_WI_ERROR_1187               11187
#define IDS_WI_ERROR_1188               11188
#define IDS_WI_ERROR_1189               11189
#define IDS_WI_ERROR_1190               11190
#define IDS_WI_ERROR_1191               11191
#define IDS_WI_ERROR_1192               11192
#define IDS_WI_ERROR_1193               11193
#define IDS_WI_ERROR_1194               11194
#define IDS_WI_ERROR_1195               11195
#define IDS_WI_ERROR_1196               11196
#define IDS_WI_ERROR_1197               11197
#define IDS_WI_ERROR_1198               11198
#define IDS_WI_ERROR_1199               11199
#define IDS_WI_ERROR_1200               11200
#define IDS_WI_ERROR_1201               11201
#define IDS_WI_ERROR_1202               11202
#define IDS_WI_ERROR_1203               11203
#define IDS_WI_ERROR_1204               11204
#define IDS_WI_ERROR_1205               11205
#define IDS_WI_ERROR_1206               11206
#define IDS_WI_ERROR_1207               11207
#define IDS_WI_ERROR_1208               11208
#define IDS_WI_ERROR_1209               11209
#define IDS_WI_ERROR_1210               11210
#define IDS_WI_ERROR_1211               11211
#define IDS_WI_ERROR_1212               11212
#define IDS_WI_ERROR_1213               11213
#define IDS_WI_ERROR_1214               11214
#define IDS_WI_ERROR_1215               11215
#define IDS_WI_ERROR_1216               11216
#define IDS_WI_ERROR_1217               11217
#define IDS_WI_ERROR_1218               11218
#define IDS_WI_ERROR_1219               11219
#define IDS_WI_ERROR_1220               11220
#define IDS_WI_ERROR_1221               11221
#define IDS_WI_ERROR_1222               11222
#define IDS_WI_ERROR_1223               11223
#define IDS_WI_ERROR_1224               11224
#define IDS_WI_ERROR_1225               11225
#define IDS_WI_ERROR_1226               11226
#define IDS_WI_ERROR_1227               11227
#define IDS_WI_ERROR_1228               11228
#define IDS_WI_ERROR_1229               11229
#define IDS_WI_ERROR_1230               11230
#define IDS_WI_ERROR_1231               11231
#define IDS_WI_ERROR_1232               11232
#define IDS_WI_ERROR_1233               11233
#define IDS_WI_ERROR_1234               11234
#define IDS_WI_ERROR_1235               11235
#define IDS_WI_ERROR_1236               11236
#define IDS_WI_ERROR_1237               11237
#define IDS_WI_ERROR_1238               11238
#define IDS_WI_ERROR_1239               11239
#define IDS_WI_ERROR_1240               11240
#define IDS_WI_ERROR_1241               11241
#define IDS_WI_ERROR_1242               11242
#define IDS_WI_ERROR_1243               11243
#define IDS_WI_ERROR_1244               11244
#define IDS_WI_ERROR_1245               11245
#define IDS_WI_ERROR_1246               11246
#define IDS_WI_ERROR_1247               11247
#define IDS_WI_ERROR_1248               11248
#define IDS_WI_ERROR_1249               11249
#define IDS_WI_ERROR_1250               11250
#define IDS_WI_ERROR_1251               11251
#define IDS_WI_ERROR_1252               11252
#define IDS_WI_ERROR_1253               11253
#define IDS_WI_ERROR_1254               11254
#define IDS_WI_ERROR_1255               11255
#define IDS_WI_ERROR_1256               11256
#define IDS_WI_ERROR_1257               11257
#define IDS_WI_ERROR_1258               11258
#define IDS_WI_ERROR_1259               11259
#define IDS_WI_ERROR_1260               11260
#define IDS_WI_ERROR_1261               11261
#define IDS_WI_ERROR_1262               11262
#define IDS_WI_ERROR_1263               11263
#define IDS_WI_ERROR_1264               11264
#define IDS_WI_ERROR_1265               11265
#define IDS_WI_ERROR_1266               11266
#define IDS_WI_ERROR_1267               11267
#define IDS_WI_ERROR_1268               11268
#define IDS_WI_ERROR_1269               11269
#define IDS_WI_ERROR_1270               11270
#define IDS_WI_ERROR_1271               11271
#define IDS_WI_ERROR_1272               11272
#define IDS_WI_ERROR_1273               11273
#define IDS_WI_ERROR_1274               11274
#define IDS_WI_ERROR_1275               11275
#define IDS_WI_ERROR_1276               11276
#define IDS_WI_ERROR_1277               11277
#define IDS_WI_ERROR_1278               11278
#define IDS_WI_ERROR_1279               11279
#define IDS_WI_ERROR_1280               11280
#define IDS_WI_ERROR_1281               11281
#define IDS_WI_ERROR_1282               11282
#define IDS_WI_ERROR_1283               11283
#define IDS_WI_ERROR_1284               11284
#define IDS_WI_ERROR_1285               11285
#define IDS_WI_ERROR_1286               11286
#define IDS_WI_ERROR_1287               11287
#define IDS_WI_ERROR_1288               11288
#define IDS_WI_ERROR_1289               11289
#define IDS_WI_ERROR_1290               11290
#define IDS_WI_ERROR_1291               11291
#define IDS_WI_ERROR_1292               11292
#define IDS_WI_ERROR_1293               11293
#define IDS_WI_ERROR_1294               11294
#define IDS_WI_ERROR_1295               11295
#define IDS_WI_ERROR_1296               11296
#define IDS_WI_ERROR_1297               11297
#define IDS_WI_ERROR_1298               11298
#define IDS_WI_ERROR_1299               11299
#define IDS_WI_ERROR_1300               11300
#define IDS_WI_ERROR_1301               11301
#define IDS_WI_ERROR_1302               11302
#define IDS_WI_ERROR_1303               11303
#define IDS_WI_ERROR_1304               11304
#define IDS_WI_ERROR_1305               11305
#define IDS_WI_ERROR_1306               11306
#define IDS_WI_ERROR_1307               11307
#define IDS_WI_ERROR_1308               11308
#define IDS_WI_ERROR_1309               11309
#define IDS_WI_ERROR_1310               11310
#define IDS_WI_ERROR_1311               11311
#define IDS_WI_ERROR_1312               11312
#define IDS_WI_ERROR_1313               11313
#define IDS_WI_ERROR_1314               11314
#define IDS_WI_ERROR_1315               11315
#define IDS_WI_ERROR_1316               11316
#define IDS_WI_ERROR_1317               11317
#define IDS_WI_ERROR_1318               11318
#define IDS_WI_ERROR_1319               11319
#define IDS_WI_ERROR_1320               11320
#define IDS_WI_ERROR_1321               11321
#define IDS_WI_ERROR_1322               11322
#define IDS_WI_ERROR_1323               11323
#define IDS_WI_ERROR_1324               11324
#define IDS_WI_ERROR_1325               11325
#define IDS_WI_ERROR_1326               11326
#define IDS_WI_ERROR_1327               11327
#define IDS_WI_ERROR_1328               11328
#define IDS_WI_ERROR_1329               11329
#define IDS_WI_ERROR_1330               11330
#define IDS_WI_ERROR_1331               11331
#define IDS_WI_ERROR_1332               11332
#define IDS_WI_ERROR_1333               11333
#define IDS_WI_ERROR_1334               11334
#define IDS_WI_ERROR_1335               11335
#define IDS_WI_ERROR_1336               11336
#define IDS_WI_ERROR_1337               11337
#define IDS_WI_ERROR_1338               11338
#define IDS_WI_ERROR_1339               11339
#define IDS_WI_ERROR_1340               11340
#define IDS_WI_ERROR_1341               11341
#define IDS_WI_ERROR_1342               11342
#define IDS_WI_ERROR_1343               11343
#define IDS_WI_ERROR_1344               11344
#define IDS_WI_ERROR_1345               11345
#define IDS_WI_ERROR_1346               11346
#define IDS_WI_ERROR_1347               11347
#define IDS_WI_ERROR_1348               11348
#define IDS_WI_ERROR_1349               11349
#define IDS_WI_ERROR_1350               11350
#define IDS_WI_ERROR_1351               11351
#define IDS_WI_ERROR_1352               11352
#define IDS_WI_ERROR_1353               11353
#define IDS_WI_ERROR_1354               11354
#define IDS_WI_ERROR_1355               11355
#define IDS_WI_ERROR_1356               11356
#define IDS_WI_ERROR_1357               11357
#define IDS_WI_ERROR_1358               11358
#define IDS_WI_ERROR_1359               11359
#define IDS_WI_ERROR_1360               11360
#define IDS_WI_ERROR_1361               11361
#define IDS_WI_ERROR_1362               11362
#define IDS_WI_ERROR_1363               11363
#define IDS_WI_ERROR_1364               11364
#define IDS_WI_ERROR_1365               11365
#define IDS_WI_ERROR_1366               11366
#define IDS_WI_ERROR_1367               11367
#define IDS_WI_ERROR_1368               11368
#define IDS_WI_ERROR_1369               11369
#define IDS_WI_ERROR_1370               11370
#define IDS_WI_ERROR_1371               11371
#define IDS_WI_ERROR_1372               11372
#define IDS_WI_ERROR_1373               11373
#define IDS_WI_ERROR_1374               11374
#define IDS_WI_ERROR_1375               11375
#define IDS_WI_ERROR_1376               11376
#define IDS_WI_ERROR_1377               11377
#define IDS_WI_ERROR_1378               11378
#define IDS_WI_ERROR_1379               11379
#define IDS_WI_ERROR_1380               11380
#define IDS_WI_ERROR_1381               11381
#define IDS_WI_ERROR_1382               11382
#define IDS_WI_ERROR_1383               11383
#define IDS_WI_ERROR_1384               11384
#define IDS_WI_ERROR_1385               11385
#define IDS_WI_ERROR_1386               11386
#define IDS_WI_ERROR_1387               11387
#define IDS_WI_ERROR_1388               11388
#define IDS_WI_ERROR_1389               11389
#define IDS_WI_ERROR_1390               11390
#define IDS_WI_ERROR_1391               11391
#define IDS_WI_ERROR_1392               11392
#define IDS_WI_ERROR_1393               11393
#define IDS_WI_ERROR_1394               11394
#define IDS_WI_ERROR_1395               11395
#define IDS_WI_ERROR_1396               11396
#define IDS_WI_ERROR_1397               11397
#define IDS_WI_ERROR_1398               11398
#define IDS_WI_ERROR_1399               11399
#define IDS_WI_ERROR_1400               11400
#define IDS_WI_ERROR_1401               11401
#define IDS_WI_ERROR_1402               11402
#define IDS_WI_ERROR_1403               11403
#define IDS_WI_ERROR_1404               11404
#define IDS_WI_ERROR_1405               11405
#define IDS_WI_ERROR_1406               11406
#define IDS_WI_ERROR_1407               11407
#define IDS_WI_ERROR_1408               11408
#define IDS_WI_ERROR_1409               11409
#define IDS_WI_ERROR_1410               11410
#define IDS_WI_ERROR_1411               11411
#define IDS_WI_ERROR_1412               11412
#define IDS_WI_ERROR_1413               11413
#define IDS_WI_ERROR_1414               11414
#define IDS_WI_ERROR_1415               11415
#define IDS_WI_ERROR_1416               11416
#define IDS_WI_ERROR_1417               11417
#define IDS_WI_ERROR_1418               11418
#define IDS_WI_ERROR_1419               11419
#define IDS_WI_ERROR_1420               11420
#define IDS_WI_ERROR_1421               11421
#define IDS_WI_ERROR_1422               11422
#define IDS_WI_ERROR_1423               11423
#define IDS_WI_ERROR_1424               11424
#define IDS_WI_ERROR_1425               11425
#define IDS_WI_ERROR_1426               11426
#define IDS_WI_ERROR_1427               11427
#define IDS_WI_ERROR_1428               11428
#define IDS_WI_ERROR_1429               11429
#define IDS_WI_ERROR_1430               11430
#define IDS_WI_ERROR_1431               11431
#define IDS_WI_ERROR_1432               11432
#define IDS_WI_ERROR_1433               11433
#define IDS_WI_ERROR_1434               11434
#define IDS_WI_ERROR_1435               11435
#define IDS_WI_ERROR_1436               11436
#define IDS_WI_ERROR_1437               11437
#define IDS_WI_ERROR_1438               11438
#define IDS_WI_ERROR_1439               11439
#define IDS_WI_ERROR_1440               11440
#define IDS_WI_ERROR_1441               11441
#define IDS_WI_ERROR_1442               11442
#define IDS_WI_ERROR_1443               11443
#define IDS_WI_ERROR_1444               11444
#define IDS_WI_ERROR_1445               11445
#define IDS_WI_ERROR_1446               11446
#define IDS_WI_ERROR_1447               11447
#define IDS_WI_ERROR_1448               11448
#define IDS_WI_ERROR_1449               11449
#define IDS_WI_ERROR_1450               11450
#define IDS_WI_ERROR_1451               11451
#define IDS_WI_ERROR_1452               11452
#define IDS_WI_ERROR_1453               11453
#define IDS_WI_ERROR_1454               11454
#define IDS_WI_ERROR_1455               11455
#define IDS_WI_ERROR_1456               11456
#define IDS_WI_ERROR_1457               11457
#define IDS_WI_ERROR_1458               11458
#define IDS_WI_ERROR_1459               11459
#define IDS_WI_ERROR_1460               11460
#define IDS_WI_ERROR_1461               11461
#define IDS_WI_ERROR_1462               11462
#define IDS_WI_ERROR_1463               11463
#define IDS_WI_ERROR_1464               11464
#define IDS_WI_ERROR_1465               11465
#define IDS_WI_ERROR_1466               11466
#define IDS_WI_ERROR_1467               11467
#define IDS_WI_ERROR_1468               11468
#define IDS_WI_ERROR_1469               11469
#define IDS_WI_ERROR_1470               11470
#define IDS_WI_ERROR_1471               11471
#define IDS_WI_ERROR_1472               11472
#define IDS_WI_ERROR_1473               11473
#define IDS_WI_ERROR_1474               11474
#define IDS_WI_ERROR_1475               11475
#define IDS_WI_ERROR_1476               11476
#define IDS_WI_ERROR_1477               11477
#define IDS_WI_ERROR_1478               11478
#define IDS_WI_ERROR_1479               11479
#define IDS_WI_ERROR_1480               11480
#define IDS_WI_ERROR_1481               11481
#define IDS_WI_ERROR_1482               11482
#define IDS_WI_ERROR_1483               11483
#define IDS_WI_ERROR_1484               11484
#define IDS_WI_ERROR_1485               11485
#define IDS_WI_ERROR_1486               11486
#define IDS_WI_ERROR_1487               11487
#define IDS_WI_ERROR_1488               11488
#define IDS_WI_ERROR_1489               11489
#define IDS_WI_ERROR_1490               11490
#define IDS_WI_ERROR_1491               11491
#define IDS_WI_ERROR_1492               11492
#define IDS_WI_ERROR_1493               11493
#define IDS_WI_ERROR_1494               11494
#define IDS_WI_ERROR_1495               11495
#define IDS_WI_ERROR_1496               11496
#define IDS_WI_ERROR_1497               11497
#define IDS_WI_ERROR_1498               11498
#define IDS_WI_ERROR_1499               11499
#define IDS_WI_ERROR_1500               11500
#define IDS_WI_ERROR_1501               11501
#define IDS_WI_ERROR_1502               11502
#define IDS_WI_ERROR_1503               11503
#define IDS_WI_ERROR_1504               11504
#define IDS_WI_ERROR_1505               11505
#define IDS_WI_ERROR_1506               11506
#define IDS_WI_ERROR_1507               11507
#define IDS_WI_ERROR_1508               11508
#define IDS_WI_ERROR_1509               11509
#define IDS_WI_ERROR_1510               11510
#define IDS_WI_ERROR_1511               11511
#define IDS_WI_ERROR_1512               11512
#define IDS_WI_ERROR_1513               11513
#define IDS_WI_ERROR_1514               11514
#define IDS_WI_ERROR_1515               11515
#define IDS_WI_ERROR_1516               11516
#define IDS_WI_ERROR_1517               11517
#define IDS_WI_ERROR_1518               11518
#define IDS_WI_ERROR_1519               11519
#define IDS_WI_ERROR_1520               11520
#define IDS_WI_ERROR_1521               11521
#define IDS_WI_ERROR_1522               11522
#define IDS_WI_ERROR_1523               11523
#define IDS_WI_ERROR_1524               11524
#define IDS_WI_ERROR_1525               11525
#define IDS_WI_ERROR_1526               11526
#define IDS_WI_ERROR_1527               11527
#define IDS_WI_ERROR_1528               11528
#define IDS_WI_ERROR_1529               11529
#define IDS_WI_ERROR_1530               11530
#define IDS_WI_ERROR_1531               11531
#define IDS_WI_ERROR_1532               11532
#define IDS_WI_ERROR_1533               11533
#define IDS_WI_ERROR_1534               11534
#define IDS_WI_ERROR_1535               11535
#define IDS_WI_ERROR_1536               11536
#define IDS_WI_ERROR_1537               11537
#define IDS_WI_ERROR_1538               11538
#define IDS_WI_ERROR_1539               11539
#define IDS_WI_ERROR_1540               11540
#define IDS_WI_ERROR_1541               11541
#define IDS_WI_ERROR_1542               11542
#define IDS_WI_ERROR_1543               11543
#define IDS_WI_ERROR_1544               11544
#define IDS_WI_ERROR_1545               11545
#define IDS_WI_ERROR_1546               11546
#define IDS_WI_ERROR_1547               11547
#define IDS_WI_ERROR_1548               11548
#define IDS_WI_ERROR_1549               11549
#define IDS_WI_ERROR_1550               11550
#define IDS_WI_ERROR_1551               11551
#define IDS_WI_ERROR_1552               11552
#define IDS_WI_ERROR_1553               11553
#define IDS_WI_ERROR_1554               11554
#define IDS_WI_ERROR_1555               11555
#define IDS_WI_ERROR_1556               11556
#define IDS_WI_ERROR_1557               11557
#define IDS_WI_ERROR_1558               11558
#define IDS_WI_ERROR_1559               11559
#define IDS_WI_ERROR_1560               11560
#define IDS_WI_ERROR_1561               11561
#define IDS_WI_ERROR_1562               11562
#define IDS_WI_ERROR_1563               11563
#define IDS_WI_ERROR_1564               11564
#define IDS_WI_ERROR_1565               11565
#define IDS_WI_ERROR_1566               11566
#define IDS_WI_ERROR_1567               11567
#define IDS_WI_ERROR_1568               11568
#define IDS_WI_ERROR_1569               11569
#define IDS_WI_ERROR_1570               11570
#define IDS_WI_ERROR_1571               11571
#define IDS_WI_ERROR_1572               11572
#define IDS_WI_ERROR_1573               11573
#define IDS_WI_ERROR_1574               11574
#define IDS_WI_ERROR_1575               11575
#define IDS_WI_ERROR_1576               11576
#define IDS_WI_ERROR_1577               11577
#define IDS_WI_ERROR_1578               11578
#define IDS_WI_ERROR_1579               11579
#define IDS_WI_ERROR_1580               11580
#define IDS_WI_ERROR_1581               11581
#define IDS_WI_ERROR_1582               11582
#define IDS_WI_ERROR_1583               11583
#define IDS_WI_ERROR_1584               11584
#define IDS_WI_ERROR_1585               11585
#define IDS_WI_ERROR_1586               11586
#define IDS_WI_ERROR_1587               11587
#define IDS_WI_ERROR_1588               11588
#define IDS_WI_ERROR_1589               11589
#define IDS_WI_ERROR_1590               11590
#define IDS_WI_ERROR_1591               11591
#define IDS_WI_ERROR_1592               11592
#define IDS_WI_ERROR_1593               11593
#define IDS_WI_ERROR_1594               11594
#define IDS_WI_ERROR_1595               11595
#define IDS_WI_ERROR_1596               11596
#define IDS_WI_ERROR_1597               11597
#define IDS_WI_ERROR_1598               11598
#define IDS_WI_ERROR_1599               11599
#define IDS_WI_ERROR_1600               11600
#define IDS_WI_ERROR_1601               11601
#define IDS_WI_ERROR_1602               11602
#define IDS_WI_ERROR_1603               11603
#define IDS_WI_ERROR_1604               11604
#define IDS_WI_ERROR_1605               11605
#define IDS_WI_ERROR_1606               11606
#define IDS_WI_ERROR_1607               11607
#define IDS_WI_ERROR_1608               11608
#define IDS_WI_ERROR_1609               11609
#define IDS_WI_ERROR_1610               11610
#define IDS_WI_ERROR_1611               11611
#define IDS_WI_ERROR_1612               11612
#define IDS_WI_ERROR_1613               11613
#define IDS_WI_ERROR_1614               11614
#define IDS_WI_ERROR_1615               11615
#define IDS_WI_ERROR_1616               11616
#define IDS_WI_ERROR_1617               11617
#define IDS_WI_ERROR_1618               11618
#define IDS_WI_ERROR_1619               11619
#define IDS_WI_ERROR_1620               11620
#define IDS_WI_ERROR_1621               11621
#define IDS_WI_ERROR_1622               11622
#define IDS_WI_ERROR_1623               11623
#define IDS_WI_ERROR_1624               11624
#define IDS_WI_ERROR_1625               11625
#define IDS_WI_ERROR_1626               11626
#define IDS_WI_ERROR_1627               11627
#define IDS_WI_ERROR_1628               11628
#define IDS_WI_ERROR_1629               11629
#define IDS_WI_ERROR_1630               11630
#define IDS_WI_ERROR_1631               11631
#define IDS_WI_ERROR_1632               11632
#define IDS_WI_ERROR_1633               11633
#define IDS_WI_ERROR_1634               11634
#define IDS_WI_ERROR_1635               11635
#define IDS_WI_ERROR_1636               11636
#define IDS_WI_ERROR_1637               11637
#define IDS_WI_ERROR_1638               11638
#define IDS_WI_ERROR_1639               11639
#define IDS_WI_ERROR_1640               11640
#define IDS_WI_ERROR_1641               11641
#define IDS_WI_ERROR_1642               11642
#define IDS_WI_ERROR_1643               11643
#define IDS_WI_ERROR_1644               11644
#define IDS_WI_ERROR_1645               11645
#define IDS_WI_ERROR_1646               11646
#define IDS_WI_ERROR_1647               11647
#define IDS_WI_ERROR_1648               11648
#define IDS_WI_ERROR_1649               11649
#define IDS_WI_ERROR_1650               11650
#define IDS_WI_ERROR_1651               11651
#define IDS_WI_ERROR_1652               11652
#define IDS_WI_ERROR_1653               11653
#define IDS_WI_ERROR_1654               11654
#define IDS_WI_ERROR_1655               11655
#define IDS_WI_ERROR_1656               11656
#define IDS_WI_ERROR_1657               11657
#define IDS_WI_ERROR_1658               11658
#define IDS_WI_ERROR_1659               11659
#define IDS_WI_ERROR_1660               11660
#define IDS_WI_ERROR_1661               11661
#define IDS_WI_ERROR_1662               11662
#define IDS_WI_ERROR_1663               11663
#define IDS_WI_ERROR_1664               11664
#define IDS_WI_ERROR_1665               11665
#define IDS_WI_ERROR_1666               11666
#define IDS_WI_ERROR_1667               11667
#define IDS_WI_ERROR_1668               11668
#define IDS_WI_ERROR_1669               11669
#define IDS_WI_ERROR_1670               11670
#define IDS_WI_ERROR_1671               11671
#define IDS_WI_ERROR_1672               11672
#define IDS_WI_ERROR_1673               11673
#define IDS_WI_ERROR_1674               11674
#define IDS_WI_ERROR_1675               11675
#define IDS_WI_ERROR_1676               11676
#define IDS_WI_ERROR_1677               11677
#define IDS_WI_ERROR_1678               11678
#define IDS_WI_ERROR_1679               11679
#define IDS_WI_ERROR_1680               11680
#define IDS_WI_ERROR_1681               11681
#define IDS_WI_ERROR_1682               11682
#define IDS_WI_ERROR_1683               11683
#define IDS_WI_ERROR_1684               11684
#define IDS_WI_ERROR_1685               11685
#define IDS_WI_ERROR_1686               11686
#define IDS_WI_ERROR_1687               11687
#define IDS_WI_ERROR_1688               11688
#define IDS_WI_ERROR_1689               11689
#define IDS_WI_ERROR_1690               11690
#define IDS_WI_ERROR_1691               11691
#define IDS_WI_ERROR_1692               11692
#define IDS_WI_ERROR_1693               11693
#define IDS_WI_ERROR_1694               11694
#define IDS_WI_ERROR_1695               11695
#define IDS_WI_ERROR_1696               11696
#define IDS_WI_ERROR_1697               11697
#define IDS_WI_ERROR_1698               11698
#define IDS_WI_ERROR_1699               11699
#define IDS_WI_ERROR_1700               11700
#define IDS_WI_ERROR_1701               11701
#define IDS_WI_ERROR_1702               11702
#define IDS_WI_ERROR_1703               11703
#define IDS_WI_ERROR_1704               11704
#define IDS_WI_ERROR_1705               11705
#define IDS_WI_ERROR_1706               11706
#define IDS_WI_ERROR_1707               11707
#define IDS_WI_ERROR_1708               11708
#define IDS_WI_ERROR_1709               11709
#define IDS_WI_ERROR_1710               11710
#define IDS_WI_ERROR_1711               11711
#define IDS_WI_ERROR_1712               11712
#define IDS_WI_ERROR_1713               11713
#define IDS_WI_ERROR_1714               11714
#define IDS_WI_ERROR_1715               11715
#define IDS_WI_ERROR_1716               11716
#define IDS_WI_ERROR_1717               11717
#define IDS_WI_ERROR_1718               11718
#define IDS_WI_ERROR_1719               11719
#define IDS_WI_ERROR_1720               11720
#define IDS_WI_ERROR_1721               11721
#define IDS_WI_ERROR_1722               11722
#define IDS_WI_ERROR_1723               11723
#define IDS_WI_ERROR_1724               11724
#define IDS_WI_ERROR_1725               11725
#define IDS_WI_ERROR_1726               11726
#define IDS_WI_ERROR_1727               11727
#define IDS_WI_ERROR_1728               11728
#define IDS_WI_ERROR_1729               11729
#define IDS_WI_ERROR_1730               11730
#define IDS_WI_ERROR_1731               11731
#define IDS_WI_ERROR_1732               11732
#define IDS_WI_ERROR_1733               11733
#define IDS_WI_ERROR_1734               11734
#define IDS_WI_ERROR_1735               11735
#define IDS_WI_ERROR_1736               11736
#define IDS_WI_ERROR_1737               11737
#define IDS_WI_ERROR_1738               11738
#define IDS_WI_ERROR_1739               11739
#define IDS_WI_ERROR_1740               11740
#define IDS_WI_ERROR_1741               11741
#define IDS_WI_ERROR_1742               11742
#define IDS_WI_ERROR_1743               11743
#define IDS_WI_ERROR_1744               11744
#define IDS_WI_ERROR_1745               11745
#define IDS_WI_ERROR_1746               11746
#define IDS_WI_ERROR_1747               11747
#define IDS_WI_ERROR_1748               11748
#define IDS_WI_ERROR_1749               11749
#define IDS_WI_ERROR_1750               11750
#define IDS_WI_ERROR_1751               11751
#define IDS_WI_ERROR_1752               11752
#define IDS_WI_ERROR_1753               11753
#define IDS_WI_ERROR_1754               11754
#define IDS_WI_ERROR_1755               11755
#define IDS_WI_ERROR_1756               11756
#define IDS_WI_ERROR_1757               11757
#define IDS_WI_ERROR_1758               11758
#define IDS_WI_ERROR_1759               11759
#define IDS_WI_ERROR_1760               11760
#define IDS_WI_ERROR_1761               11761
#define IDS_WI_ERROR_1762               11762
#define IDS_WI_ERROR_1763               11763
#define IDS_WI_ERROR_1764               11764
#define IDS_WI_ERROR_1765               11765
#define IDS_WI_ERROR_1766               11766
#define IDS_WI_ERROR_1767               11767
#define IDS_WI_ERROR_1768               11768
#define IDS_WI_ERROR_1769               11769
#define IDS_WI_ERROR_1770               11770
#define IDS_WI_ERROR_1771               11771
#define IDS_WI_ERROR_1772               11772
#define IDS_WI_ERROR_1773               11773
#define IDS_WI_ERROR_1774               11774
#define IDS_WI_ERROR_1775               11775
#define IDS_WI_ERROR_1776               11776
#define IDS_WI_ERROR_1777               11777
#define IDS_WI_ERROR_1778               11778
#define IDS_WI_ERROR_1779               11779
#define IDS_WI_ERROR_1780               11780
#define IDS_WI_ERROR_1781               11781
#define IDS_WI_ERROR_1782               11782
#define IDS_WI_ERROR_1783               11783
#define IDS_WI_ERROR_1784               11784
#define IDS_WI_ERROR_1785               11785
#define IDS_WI_ERROR_1786               11786
#define IDS_WI_ERROR_1787               11787
#define IDS_WI_ERROR_1788               11788
#define IDS_WI_ERROR_1789               11789
#define IDS_WI_ERROR_1790               11790
#define IDS_WI_ERROR_1791               11791
#define IDS_WI_ERROR_1792               11792
#define IDS_WI_ERROR_1793               11793
#define IDS_WI_ERROR_1794               11794
#define IDS_WI_ERROR_1795               11795
#define IDS_WI_ERROR_1796               11796
#define IDS_WI_ERROR_1797               11797
#define IDS_WI_ERROR_1798               11798
#define IDS_WI_ERROR_1799               11799
#define IDS_WI_ERROR_1800               11800
#define IDS_WI_ERROR_1801               11801
#define IDS_WI_ERROR_1802               11802
#define IDS_WI_ERROR_1803               11803
#define IDS_WI_ERROR_1804               11804
#define IDS_WI_ERROR_1805               11805
#define IDS_WI_ERROR_1806               11806
#define IDS_WI_ERROR_1807               11807
#define IDS_WI_ERROR_1808               11808
#define IDS_WI_ERROR_1809               11809
#define IDS_WI_ERROR_1810               11810
#define IDS_WI_ERROR_1811               11811
#define IDS_WI_ERROR_1812               11812
#define IDS_WI_ERROR_1813               11813
#define IDS_WI_ERROR_1814               11814
#define IDS_WI_ERROR_1815               11815
#define IDS_WI_ERROR_1816               11816
#define IDS_WI_ERROR_1817               11817
#define IDS_WI_ERROR_1818               11818
#define IDS_WI_ERROR_1819               11819
#define IDS_WI_ERROR_1820               11820
#define IDS_WI_ERROR_1821               11821
#define IDS_WI_ERROR_1822               11822
#define IDS_WI_ERROR_1823               11823
#define IDS_WI_ERROR_1824               11824
#define IDS_WI_ERROR_1825               11825
#define IDS_WI_ERROR_1826               11826
#define IDS_WI_ERROR_1827               11827
#define IDS_WI_ERROR_1828               11828
#define IDS_WI_ERROR_1829               11829
#define IDS_WI_ERROR_1830               11830
#define IDS_WI_ERROR_1831               11831
#define IDS_WI_ERROR_1832               11832
#define IDS_WI_ERROR_1833               11833
#define IDS_WI_ERROR_1834               11834
#define IDS_WI_ERROR_1835               11835
#define IDS_WI_ERROR_1836               11836
#define IDS_WI_ERROR_1837               11837
#define IDS_WI_ERROR_1838               11838
#define IDS_WI_ERROR_1839               11839
#define IDS_WI_ERROR_1840               11840
#define IDS_WI_ERROR_1841               11841
#define IDS_WI_ERROR_1842               11842
#define IDS_WI_ERROR_1843               11843
#define IDS_WI_ERROR_1844               11844
#define IDS_WI_ERROR_1845               11845
#define IDS_WI_ERROR_1846               11846
#define IDS_WI_ERROR_1847               11847
#define IDS_WI_ERROR_1848               11848
#define IDS_WI_ERROR_1849               11849
#define IDS_WI_ERROR_1850               11850
#define IDS_WI_ERROR_1851               11851
#define IDS_WI_ERROR_1852               11852
#define IDS_WI_ERROR_1853               11853
#define IDS_WI_ERROR_1854               11854
#define IDS_WI_ERROR_1855               11855
#define IDS_WI_ERROR_1856               11856
#define IDS_WI_ERROR_1857               11857
#define IDS_WI_ERROR_1858               11858
#define IDS_WI_ERROR_1859               11859
#define IDS_WI_ERROR_1860               11860
#define IDS_WI_ERROR_1861               11861
#define IDS_WI_ERROR_1862               11862
#define IDS_WI_ERROR_1863               11863
#define IDS_WI_ERROR_1864               11864
#define IDS_WI_ERROR_1865               11865
#define IDS_WI_ERROR_1866               11866
#define IDS_WI_ERROR_1867               11867
#define IDS_WI_ERROR_1868               11868
#define IDS_WI_ERROR_1869               11869
#define IDS_WI_ERROR_1870               11870
#define IDS_WI_ERROR_1871               11871
#define IDS_WI_ERROR_1872               11872
#define IDS_WI_ERROR_1873               11873
#define IDS_WI_ERROR_1874               11874
#define IDS_WI_ERROR_1875               11875
#define IDS_WI_ERROR_1876               11876
#define IDS_WI_ERROR_1877               11877
#define IDS_WI_ERROR_1878               11878
#define IDS_WI_ERROR_1879               11879
#define IDS_WI_ERROR_1880               11880
#define IDS_WI_ERROR_1881               11881
#define IDS_WI_ERROR_1882               11882
#define IDS_WI_ERROR_1883               11883
#define IDS_WI_ERROR_1884               11884
#define IDS_WI_ERROR_1885               11885
#define IDS_WI_ERROR_1886               11886
#define IDS_WI_ERROR_1887               11887
#define IDS_WI_ERROR_1888               11888
#define IDS_WI_ERROR_1889               11889
#define IDS_WI_ERROR_1890               11890
#define IDS_WI_ERROR_1891               11891
#define IDS_WI_ERROR_1892               11892
#define IDS_WI_ERROR_1893               11893
#define IDS_WI_ERROR_1894               11894
#define IDS_WI_ERROR_1895               11895
#define IDS_WI_ERROR_1896               11896
#define IDS_WI_ERROR_1897               11897
#define IDS_WI_ERROR_1898               11898
#define IDS_WI_ERROR_1899               11899
#define IDS_WI_ERROR_1900               11900
#define IDS_WI_ERROR_1901               11901
#define IDS_WI_ERROR_1902               11902
#define IDS_WI_ERROR_1903               11903
#define IDS_WI_ERROR_1904               11904
#define IDS_WI_ERROR_1905               11905
#define IDS_WI_ERROR_1906               11906
#define IDS_WI_ERROR_1907               11907
#define IDS_WI_ERROR_1908               11908
#define IDS_WI_ERROR_1909               11909
#define IDS_WI_ERROR_1910               11910
#define IDS_WI_ERROR_1911               11911
#define IDS_WI_ERROR_1912               11912
#define IDS_WI_ERROR_1913               11913
#define IDS_WI_ERROR_1914               11914
#define IDS_WI_ERROR_1915               11915
#define IDS_WI_ERROR_1916               11916
#define IDS_WI_ERROR_1917               11917
#define IDS_WI_ERROR_1918               11918
#define IDS_WI_ERROR_1919               11919
#define IDS_WI_ERROR_1920               11920
#define IDS_WI_ERROR_1921               11921
#define IDS_WI_ERROR_1922               11922
#define IDS_WI_ERROR_1923               11923
#define IDS_WI_ERROR_1924               11924
#define IDS_WI_ERROR_1925               11925
#define IDS_WI_ERROR_1926               11926
#define IDS_WI_ERROR_1927               11927
#define IDS_WI_ERROR_1928               11928
#define IDS_WI_ERROR_1929               11929
#define IDS_WI_ERROR_1930               11930
#define IDS_WI_ERROR_1931               11931
#define IDS_WI_ERROR_1932               11932
#define IDS_WI_ERROR_1933               11933
#define IDS_WI_ERROR_1934               11934
#define IDS_WI_ERROR_1935               11935
#define IDS_WI_ERROR_1936               11936
#define IDS_WI_ERROR_1937               11937
#define IDS_WI_ERROR_1938               11938
#define IDS_WI_ERROR_1939               11939
#define IDS_WI_ERROR_1940               11940
#define IDS_WI_ERROR_1941               11941
#define IDS_WI_ERROR_1942               11942
#define IDS_WI_ERROR_1943               11943
#define IDS_WI_ERROR_1944               11944
#define IDS_WI_ERROR_1945               11945
#define IDS_WI_ERROR_1946               11946
#define IDS_WI_ERROR_1947               11947
#define IDS_WI_ERROR_1948               11948
#define IDS_WI_ERROR_1949               11949
#define IDS_WI_ERROR_1950               11950
#define IDS_WI_ERROR_1951               11951
#define IDS_WI_ERROR_1952               11952
#define IDS_WI_ERROR_1953               11953
#define IDS_WI_ERROR_1954               11954
#define IDS_WI_ERROR_1955               11955
#define IDS_WI_ERROR_1956               11956
#define IDS_WI_ERROR_1957               11957
#define IDS_WI_ERROR_1958               11958
#define IDS_WI_ERROR_1959               11959
#define IDS_WI_ERROR_1960               11960
#define IDS_WI_ERROR_1961               11961
#define IDS_WI_ERROR_1962               11962
#define IDS_WI_ERROR_1963               11963
#define IDS_WI_ERROR_1964               11964
#define IDS_WI_ERROR_1965               11965
#define IDS_WI_ERROR_1966               11966
#define IDS_WI_ERROR_1967               11967
#define IDS_WI_ERROR_1968               11968
#define IDS_WI_ERROR_1969               11969
#define IDS_WI_ERROR_1970               11970
#define IDS_WI_ERROR_1971               11971
#define IDS_WI_ERROR_1972               11972
#define IDS_WI_ERROR_1973               11973
#define IDS_WI_ERROR_1974               11974
#define IDS_WI_ERROR_1975               11975
#define IDS_WI_ERROR_1976               11976
#define IDS_WI_ERROR_1977               11977
#define IDS_WI_ERROR_1978               11978
#define IDS_WI_ERROR_1979               11979
#define IDS_WI_ERROR_1980               11980
#define IDS_WI_ERROR_1981               11981
#define IDS_WI_ERROR_1982               11982
#define IDS_WI_ERROR_1983               11983
#define IDS_WI_ERROR_1984               11984
#define IDS_WI_ERROR_1985               11985
#define IDS_WI_ERROR_1986               11986
#define IDS_WI_ERROR_1987               11987
#define IDS_WI_ERROR_1988               11988
#define IDS_WI_ERROR_1989               11989
#define IDS_WI_ERROR_1990               11990
#define IDS_WI_ERROR_1991               11991
#define IDS_WI_ERROR_1992               11992
#define IDS_WI_ERROR_1993               11993
#define IDS_WI_ERROR_1994               11994
#define IDS_WI_ERROR_1995               11995
#define IDS_WI_ERROR_1996               11996
#define IDS_WI_ERROR_1997               11997
#define IDS_WI_ERROR_1998               11998
#define IDS_WI_ERROR_1999               11999
#define IDS_WI_ERROR_2000               12000
#define IDS_WI_ERROR_2001               12001
#define IDS_WI_ERROR_2002               12002
#define IDS_WI_ERROR_2003               12003
#define IDS_WI_ERROR_2004               12004
#define IDS_WI_ERROR_2005               12005
#define IDS_WI_ERROR_2006               12006
#define IDS_WI_ERROR_2007               12007
#define IDS_WI_ERROR_2008               12008
#define IDS_WI_ERROR_2009               12009
#define IDS_WI_ERROR_2010               12010
#define IDS_WI_ERROR_2011               12011
#define IDS_WI_ERROR_2012               12012
#define IDS_WI_ERROR_2013               12013
#define IDS_WI_ERROR_2014               12014
#define IDS_WI_ERROR_2015               12015
#define IDS_WI_ERROR_2016               12016
#define IDS_WI_ERROR_2017               12017
#define IDS_WI_ERROR_2018               12018
#define IDS_WI_ERROR_2019               12019
#define IDS_WI_ERROR_2020               12020
#define IDS_WI_ERROR_2021               12021
#define IDS_WI_ERROR_2022               12022
#define IDS_WI_ERROR_2023               12023
#define IDS_WI_ERROR_2024               12024
#define IDS_WI_ERROR_2025               12025
#define IDS_WI_ERROR_2026               12026
#define IDS_WI_ERROR_2027               12027
#define IDS_WI_ERROR_2028               12028
#define IDS_WI_ERROR_2029               12029
#define IDS_WI_ERROR_2030               12030
#define IDS_WI_ERROR_2031               12031
#define IDS_WI_ERROR_2032               12032
#define IDS_WI_ERROR_2033               12033
#define IDS_WI_ERROR_2034               12034
#define IDS_WI_ERROR_2035               12035
#define IDS_WI_ERROR_2036               12036
#define IDS_WI_ERROR_2037               12037
#define IDS_WI_ERROR_2038               12038
#define IDS_WI_ERROR_2039               12039
#define IDS_WI_ERROR_2040               12040
#define IDS_WI_ERROR_2041               12041
#define IDS_WI_ERROR_2042               12042
#define IDS_WI_ERROR_2043               12043
#define IDS_WI_ERROR_2044               12044
#define IDS_WI_ERROR_2045               12045
#define IDS_WI_ERROR_2046               12046
#define IDS_WI_ERROR_2047               12047
#define IDS_WI_ERROR_2048               12048
#define IDS_WI_ERROR_2049               12049
#define IDS_WI_ERROR_2050               12050
#define IDS_WI_ERROR_2051               12051
#define IDS_WI_ERROR_2052               12052
#define IDS_WI_ERROR_2053               12053
#define IDS_WI_ERROR_2054               12054
#define IDS_WI_ERROR_2055               12055
#define IDS_WI_ERROR_2056               12056
#define IDS_WI_ERROR_2057               12057
#define IDS_WI_ERROR_2058               12058
#define IDS_WI_ERROR_2059               12059
#define IDS_WI_ERROR_2060               12060
#define IDS_WI_ERROR_2061               12061
#define IDS_WI_ERROR_2062               12062
#define IDS_WI_ERROR_2063               12063
#define IDS_WI_ERROR_2064               12064
#define IDS_WI_ERROR_2065               12065
#define IDS_WI_ERROR_2066               12066
#define IDS_WI_ERROR_2067               12067
#define IDS_WI_ERROR_2068               12068
#define IDS_WI_ERROR_2069               12069
#define IDS_WI_ERROR_2070               12070
#define IDS_WI_ERROR_2071               12071
#define IDS_WI_ERROR_2072               12072
#define IDS_WI_ERROR_2073               12073
#define IDS_WI_ERROR_2074               12074
#define IDS_WI_ERROR_2075               12075
#define IDS_WI_ERROR_2076               12076
#define IDS_WI_ERROR_2077               12077
#define IDS_WI_ERROR_2078               12078
#define IDS_WI_ERROR_2079               12079
#define IDS_WI_ERROR_2080               12080
#define IDS_WI_ERROR_2081               12081
#define IDS_WI_ERROR_2082               12082
#define IDS_WI_ERROR_2083               12083
#define IDS_WI_ERROR_2084               12084
#define IDS_WI_ERROR_2085               12085
#define IDS_WI_ERROR_2086               12086
#define IDS_WI_ERROR_2087               12087
#define IDS_WI_ERROR_2088               12088
#define IDS_WI_ERROR_2089               12089
#define IDS_WI_ERROR_2090               12090
#define IDS_WI_ERROR_2091               12091
#define IDS_WI_ERROR_2092               12092
#define IDS_WI_ERROR_2093               12093
#define IDS_WI_ERROR_2094               12094
#define IDS_WI_ERROR_2095               12095
#define IDS_WI_ERROR_2096               12096
#define IDS_WI_ERROR_2097               12097
#define IDS_WI_ERROR_2098               12098
#define IDS_WI_ERROR_2099               12099
#define IDS_WI_ERROR_2100               12100
#define IDS_WI_ERROR_2101               12101
#define IDS_WI_ERROR_2102               12102
#define IDS_WI_ERROR_2103               12103
#define IDS_WI_ERROR_2104               12104
#define IDS_WI_ERROR_2105               12105
#define IDS_WI_ERROR_2106               12106
#define IDS_WI_ERROR_2107               12107
#define IDS_WI_ERROR_2108               12108
#define IDS_WI_ERROR_2109               12109
#define IDS_WI_ERROR_2110               12110
#define IDS_WI_ERROR_2111               12111
#define IDS_WI_ERROR_2112               12112
#define IDS_WI_ERROR_2113               12113
#define IDS_WI_ERROR_2114               12114
#define IDS_WI_ERROR_2115               12115
#define IDS_WI_ERROR_2116               12116
#define IDS_WI_ERROR_2117               12117
#define IDS_WI_ERROR_2118               12118
#define IDS_WI_ERROR_2119               12119
#define IDS_WI_ERROR_2120               12120
#define IDS_WI_ERROR_2121               12121
#define IDS_WI_ERROR_2122               12122
#define IDS_WI_ERROR_2123               12123
#define IDS_WI_ERROR_2124               12124
#define IDS_WI_ERROR_2125               12125
#define IDS_WI_ERROR_2126               12126
#define IDS_WI_ERROR_2127               12127
#define IDS_WI_ERROR_2128               12128
#define IDS_WI_ERROR_2129               12129
#define IDS_WI_ERROR_2130               12130
#define IDS_WI_ERROR_2131               12131
#define IDS_WI_ERROR_2132               12132
#define IDS_WI_ERROR_2133               12133
#define IDS_WI_ERROR_2134               12134
#define IDS_WI_ERROR_2135               12135
#define IDS_WI_ERROR_2136               12136
#define IDS_WI_ERROR_2137               12137
#define IDS_WI_ERROR_2138               12138
#define IDS_WI_ERROR_2139               12139
#define IDS_WI_ERROR_2140               12140
#define IDS_WI_ERROR_2141               12141
#define IDS_WI_ERROR_2142               12142
#define IDS_WI_ERROR_2143               12143
#define IDS_WI_ERROR_2144               12144
#define IDS_WI_ERROR_2145               12145
#define IDS_WI_ERROR_2146               12146
#define IDS_WI_ERROR_2147               12147
#define IDS_WI_ERROR_2148               12148
#define IDS_WI_ERROR_2149               12149
#define IDS_WI_ERROR_2150               12150
#define IDS_WI_ERROR_2151               12151
#define IDS_WI_ERROR_2152               12152
#define IDS_WI_ERROR_2153               12153
#define IDS_WI_ERROR_2154               12154
#define IDS_WI_ERROR_2155               12155
#define IDS_WI_ERROR_2156               12156
#define IDS_WI_ERROR_2157               12157
#define IDS_WI_ERROR_2158               12158
#define IDS_WI_ERROR_2159               12159
#define IDS_WI_ERROR_2160               12160
#define IDS_WI_ERROR_2161               12161
#define IDS_WI_ERROR_2162               12162
#define IDS_WI_ERROR_2163               12163
#define IDS_WI_ERROR_2164               12164
#define IDS_WI_ERROR_2165               12165
#define IDS_WI_ERROR_2166               12166
#define IDS_WI_ERROR_2167               12167
#define IDS_WI_ERROR_2168               12168
#define IDS_WI_ERROR_2169               12169
#define IDS_WI_ERROR_2170               12170
#define IDS_WI_ERROR_2171               12171
#define IDS_WI_ERROR_2172               12172
#define IDS_WI_ERROR_2173               12173
#define IDS_WI_ERROR_2174               12174
#define IDS_WI_ERROR_2175               12175
#define IDS_WI_ERROR_2176               12176
#define IDS_WI_ERROR_2177               12177
#define IDS_WI_ERROR_2178               12178
#define IDS_WI_ERROR_2179               12179
#define IDS_WI_ERROR_2180               12180
#define IDS_WI_ERROR_2181               12181
#define IDS_WI_ERROR_2182               12182
#define IDS_WI_ERROR_2183               12183
#define IDS_WI_ERROR_2184               12184
#define IDS_WI_ERROR_2185               12185
#define IDS_WI_ERROR_2186               12186
#define IDS_WI_ERROR_2187               12187
#define IDS_WI_ERROR_2188               12188
#define IDS_WI_ERROR_2189               12189
#define IDS_WI_ERROR_2190               12190
#define IDS_WI_ERROR_2191               12191
#define IDS_WI_ERROR_2192               12192
#define IDS_WI_ERROR_2193               12193
#define IDS_WI_ERROR_2194               12194
#define IDS_WI_ERROR_2195               12195
#define IDS_WI_ERROR_2196               12196
#define IDS_WI_ERROR_2197               12197
#define IDS_WI_ERROR_2198               12198
#define IDS_WI_ERROR_2199               12199
#define IDS_WI_ERROR_2200               12200
#define IDS_WI_ERROR_2201               12201
#define IDS_WI_ERROR_2202               12202
#define IDS_WI_ERROR_2203               12203
#define IDS_WI_ERROR_2204               12204
#define IDS_WI_ERROR_2205               12205
#define IDS_WI_ERROR_2206               12206
#define IDS_WI_ERROR_2207               12207
#define IDS_WI_ERROR_2208               12208
#define IDS_WI_ERROR_2209               12209
#define IDS_WI_ERROR_2210               12210
#define IDS_WI_ERROR_2211               12211
#define IDS_WI_ERROR_2212               12212
#define IDS_WI_ERROR_2213               12213
#define IDS_WI_ERROR_2214               12214
#define IDS_WI_ERROR_2215               12215
#define IDS_WI_ERROR_2216               12216
#define IDS_WI_ERROR_2217               12217
#define IDS_WI_ERROR_2218               12218
#define IDS_WI_ERROR_2219               12219
#define IDS_WI_ERROR_2220               12220
#define IDS_WI_ERROR_2221               12221
#define IDS_WI_ERROR_2222               12222
#define IDS_WI_ERROR_2223               12223
#define IDS_WI_ERROR_2224               12224
#define IDS_WI_ERROR_2225               12225
#define IDS_WI_ERROR_2226               12226
#define IDS_WI_ERROR_2227               12227
#define IDS_WI_ERROR_2228               12228
#define IDS_WI_ERROR_2229               12229
#define IDS_WI_ERROR_2230               12230
#define IDS_WI_ERROR_2231               12231
#define IDS_WI_ERROR_2232               12232
#define IDS_WI_ERROR_2233               12233
#define IDS_WI_ERROR_2234               12234
#define IDS_WI_ERROR_2235               12235
#define IDS_WI_ERROR_2236               12236
#define IDS_WI_ERROR_2237               12237
#define IDS_WI_ERROR_2238               12238
#define IDS_WI_ERROR_2239               12239
#define IDS_WI_ERROR_2240               12240
#define IDS_WI_ERROR_2241               12241
#define IDS_WI_ERROR_2242               12242
#define IDS_WI_ERROR_2243               12243
#define IDS_WI_ERROR_2244               12244
#define IDS_WI_ERROR_2245               12245
#define IDS_WI_ERROR_2246               12246
#define IDS_WI_ERROR_2247               12247
#define IDS_WI_ERROR_2248               12248
#define IDS_WI_ERROR_2249               12249
#define IDS_WI_ERROR_2250               12250
#define IDS_WI_ERROR_2251               12251
#define IDS_WI_ERROR_2252               12252
#define IDS_WI_ERROR_2253               12253
#define IDS_WI_ERROR_2254               12254
#define IDS_WI_ERROR_2255               12255
#define IDS_WI_ERROR_2256               12256
#define IDS_WI_ERROR_2257               12257
#define IDS_WI_ERROR_2258               12258
#define IDS_WI_ERROR_2259               12259
#define IDS_WI_ERROR_2260               12260
#define IDS_WI_ERROR_2261               12261
#define IDS_WI_ERROR_2262               12262
#define IDS_WI_ERROR_2263               12263
#define IDS_WI_ERROR_2264               12264
#define IDS_WI_ERROR_2265               12265
#define IDS_WI_ERROR_2266               12266
#define IDS_WI_ERROR_2267               12267
#define IDS_WI_ERROR_2268               12268
#define IDS_WI_ERROR_2269               12269
#define IDS_WI_ERROR_2270               12270
#define IDS_WI_ERROR_2271               12271
#define IDS_WI_ERROR_2272               12272
#define IDS_WI_ERROR_2273               12273
#define IDS_WI_ERROR_2274               12274
#define IDS_WI_ERROR_2275               12275
#define IDS_WI_ERROR_2276               12276
#define IDS_WI_ERROR_2277               12277
#define IDS_WI_ERROR_2278               12278
#define IDS_WI_ERROR_2279               12279
#define IDS_WI_ERROR_2280               12280
#define IDS_WI_ERROR_2281               12281
#define IDS_WI_ERROR_2282               12282
#define IDS_WI_ERROR_2283               12283
#define IDS_WI_ERROR_2284               12284
#define IDS_WI_ERROR_2285               12285
#define IDS_WI_ERROR_2286               12286
#define IDS_WI_ERROR_2287               12287
#define IDS_WI_ERROR_2288               12288
#define IDS_WI_ERROR_2289               12289
#define IDS_WI_ERROR_2290               12290
#define IDS_WI_ERROR_2291               12291
#define IDS_WI_ERROR_2292               12292
#define IDS_WI_ERROR_2293               12293
#define IDS_WI_ERROR_2294               12294
#define IDS_WI_ERROR_2295               12295
#define IDS_WI_ERROR_2296               12296
#define IDS_WI_ERROR_2297               12297
#define IDS_WI_ERROR_2298               12298
#define IDS_WI_ERROR_2299               12299
#define IDS_WI_ERROR_2300               12300
#define IDS_WI_ERROR_2301               12301
#define IDS_WI_ERROR_2302               12302
#define IDS_WI_ERROR_2303               12303
#define IDS_WI_ERROR_2304               12304
#define IDS_WI_ERROR_2305               12305
#define IDS_WI_ERROR_2306               12306
#define IDS_WI_ERROR_2307               12307
#define IDS_WI_ERROR_2308               12308
#define IDS_WI_ERROR_2309               12309
#define IDS_WI_ERROR_2310               12310
#define IDS_WI_ERROR_2311               12311
#define IDS_WI_ERROR_2312               12312
#define IDS_WI_ERROR_2313               12313
#define IDS_WI_ERROR_2314               12314
#define IDS_WI_ERROR_2315               12315
#define IDS_WI_ERROR_2316               12316
#define IDS_WI_ERROR_2317               12317
#define IDS_WI_ERROR_2318               12318
#define IDS_WI_ERROR_2319               12319
#define IDS_WI_ERROR_2320               12320
#define IDS_WI_ERROR_2321               12321
#define IDS_WI_ERROR_2322               12322
#define IDS_WI_ERROR_2323               12323
#define IDS_WI_ERROR_2324               12324
#define IDS_WI_ERROR_2325               12325
#define IDS_WI_ERROR_2326               12326
#define IDS_WI_ERROR_2327               12327
#define IDS_WI_ERROR_2328               12328
#define IDS_WI_ERROR_2329               12329
#define IDS_WI_ERROR_2330               12330
#define IDS_WI_ERROR_2331               12331
#define IDS_WI_ERROR_2332               12332
#define IDS_WI_ERROR_2333               12333
#define IDS_WI_ERROR_2334               12334
#define IDS_WI_ERROR_2335               12335
#define IDS_WI_ERROR_2336               12336
#define IDS_WI_ERROR_2337               12337
#define IDS_WI_ERROR_2338               12338
#define IDS_WI_ERROR_2339               12339
#define IDS_WI_ERROR_2340               12340
#define IDS_WI_ERROR_2341               12341
#define IDS_WI_ERROR_2342               12342
#define IDS_WI_ERROR_2343               12343
#define IDS_WI_ERROR_2344               12344
#define IDS_WI_ERROR_2345               12345
#define IDS_WI_ERROR_2346               12346
#define IDS_WI_ERROR_2347               12347
#define IDS_WI_ERROR_2348               12348
#define IDS_WI_ERROR_2349               12349
#define IDS_WI_ERROR_2350               12350
#define IDS_WI_ERROR_2351               12351
#define IDS_WI_ERROR_2352               12352
#define IDS_WI_ERROR_2353               12353
#define IDS_WI_ERROR_2354               12354
#define IDS_WI_ERROR_2355               12355
#define IDS_WI_ERROR_2356               12356
#define IDS_WI_ERROR_2357               12357
#define IDS_WI_ERROR_2358               12358
#define IDS_WI_ERROR_2359               12359
#define IDS_WI_ERROR_2360               12360
#define IDS_WI_ERROR_2361               12361
#define IDS_WI_ERROR_2362               12362
#define IDS_WI_ERROR_2363               12363
#define IDS_WI_ERROR_2364               12364
#define IDS_WI_ERROR_2365               12365
#define IDS_WI_ERROR_2366               12366
#define IDS_WI_ERROR_2367               12367
#define IDS_WI_ERROR_2368               12368
#define IDS_WI_ERROR_2369               12369
#define IDS_WI_ERROR_2370               12370
#define IDS_WI_ERROR_2371               12371
#define IDS_WI_ERROR_2372               12372
#define IDS_WI_ERROR_2373               12373
#define IDS_WI_ERROR_2374               12374
#define IDS_WI_ERROR_2375               12375
#define IDS_WI_ERROR_2376               12376
#define IDS_WI_ERROR_2377               12377
#define IDS_WI_ERROR_2378               12378
#define IDS_WI_ERROR_2379               12379
#define IDS_WI_ERROR_2380               12380
#define IDS_WI_ERROR_2381               12381
#define IDS_WI_ERROR_2382               12382
#define IDS_WI_ERROR_2383               12383
#define IDS_WI_ERROR_2384               12384
#define IDS_WI_ERROR_2385               12385
#define IDS_WI_ERROR_2386               12386
#define IDS_WI_ERROR_2387               12387
#define IDS_WI_ERROR_2388               12388
#define IDS_WI_ERROR_2389               12389
#define IDS_WI_ERROR_2390               12390
#define IDS_WI_ERROR_2391               12391
#define IDS_WI_ERROR_2392               12392
#define IDS_WI_ERROR_2393               12393
#define IDS_WI_ERROR_2394               12394
#define IDS_WI_ERROR_2395               12395
#define IDS_WI_ERROR_2396               12396
#define IDS_WI_ERROR_2397               12397
#define IDS_WI_ERROR_2398               12398
#define IDS_WI_ERROR_2399               12399
#define IDS_WI_ERROR_2400               12400
#define IDS_WI_ERROR_2401               12401
#define IDS_WI_ERROR_2402               12402
#define IDS_WI_ERROR_2403               12403
#define IDS_WI_ERROR_2404               12404
#define IDS_WI_ERROR_2405               12405
#define IDS_WI_ERROR_2406               12406
#define IDS_WI_ERROR_2407               12407
#define IDS_WI_ERROR_2408               12408
#define IDS_WI_ERROR_2409               12409
#define IDS_WI_ERROR_2410               12410
#define IDS_WI_ERROR_2411               12411
#define IDS_WI_ERROR_2412               12412
#define IDS_WI_ERROR_2413               12413
#define IDS_WI_ERROR_2414               12414
#define IDS_WI_ERROR_2415               12415
#define IDS_WI_ERROR_2416               12416
#define IDS_WI_ERROR_2417               12417
#define IDS_WI_ERROR_2418               12418
#define IDS_WI_ERROR_2419               12419
#define IDS_WI_ERROR_2420               12420
#define IDS_WI_ERROR_2421               12421
#define IDS_WI_ERROR_2422               12422
#define IDS_WI_ERROR_2423               12423
#define IDS_WI_ERROR_2424               12424
#define IDS_WI_ERROR_2425               12425
#define IDS_WI_ERROR_2426               12426
#define IDS_WI_ERROR_2427               12427
#define IDS_WI_ERROR_2428               12428
#define IDS_WI_ERROR_2429               12429
#define IDS_WI_ERROR_2430               12430
#define IDS_WI_ERROR_2431               12431
#define IDS_WI_ERROR_2432               12432
#define IDS_WI_ERROR_2433               12433
#define IDS_WI_ERROR_2434               12434
#define IDS_WI_ERROR_2435               12435
#define IDS_WI_ERROR_2436               12436
#define IDS_WI_ERROR_2437               12437
#define IDS_WI_ERROR_2438               12438
#define IDS_WI_ERROR_2439               12439
#define IDS_WI_ERROR_2440               12440
#define IDS_WI_ERROR_2441               12441
#define IDS_WI_ERROR_2442               12442
#define IDS_WI_ERROR_2443               12443
#define IDS_WI_ERROR_2444               12444
#define IDS_WI_ERROR_2445               12445
#define IDS_WI_ERROR_2446               12446
#define IDS_WI_ERROR_2447               12447
#define IDS_WI_ERROR_2448               12448
#define IDS_WI_ERROR_2449               12449
#define IDS_WI_ERROR_2450               12450
#define IDS_WI_ERROR_2451               12451
#define IDS_WI_ERROR_2452               12452
#define IDS_WI_ERROR_2453               12453
#define IDS_WI_ERROR_2454               12454
#define IDS_WI_ERROR_2455               12455
#define IDS_WI_ERROR_2456               12456
#define IDS_WI_ERROR_2457               12457
#define IDS_WI_ERROR_2458               12458
#define IDS_WI_ERROR_2459               12459
#define IDS_WI_ERROR_2460               12460
#define IDS_WI_ERROR_2461               12461
#define IDS_WI_ERROR_2462               12462
#define IDS_WI_ERROR_2463               12463
#define IDS_WI_ERROR_2464               12464
#define IDS_WI_ERROR_2465               12465
#define IDS_WI_ERROR_2466               12466
#define IDS_WI_ERROR_2467               12467
#define IDS_WI_ERROR_2468               12468
#define IDS_WI_ERROR_2469               12469
#define IDS_WI_ERROR_2470               12470
#define IDS_WI_ERROR_2471               12471
#define IDS_WI_ERROR_2472               12472
#define IDS_WI_ERROR_2473               12473
#define IDS_WI_ERROR_2474               12474
#define IDS_WI_ERROR_2475               12475
#define IDS_WI_ERROR_2476               12476
#define IDS_WI_ERROR_2477               12477
#define IDS_WI_ERROR_2478               12478
#define IDS_WI_ERROR_2479               12479
#define IDS_WI_ERROR_2480               12480
#define IDS_WI_ERROR_2481               12481
#define IDS_WI_ERROR_2482               12482
#define IDS_WI_ERROR_2483               12483
#define IDS_WI_ERROR_2484               12484
#define IDS_WI_ERROR_2485               12485
#define IDS_WI_ERROR_2486               12486
#define IDS_WI_ERROR_2487               12487
#define IDS_WI_ERROR_2488               12488
#define IDS_WI_ERROR_2489               12489
#define IDS_WI_ERROR_2490               12490
#define IDS_WI_ERROR_2491               12491
#define IDS_WI_ERROR_2492               12492
#define IDS_WI_ERROR_2493               12493
#define IDS_WI_ERROR_2494               12494
#define IDS_WI_ERROR_2495               12495
#define IDS_WI_ERROR_2496               12496
#define IDS_WI_ERROR_2497               12497
#define IDS_WI_ERROR_2498               12498
#define IDS_WI_ERROR_2499               12499
#define IDS_WI_ERROR_2500               12500
#define IDS_WI_ERROR_2501               12501
#define IDS_WI_ERROR_2502               12502
#define IDS_WI_ERROR_2503               12503
#define IDS_WI_ERROR_2504               12504
#define IDS_WI_ERROR_2505               12505
#define IDS_WI_ERROR_2506               12506
#define IDS_WI_ERROR_2507               12507
#define IDS_WI_ERROR_2508               12508
#define IDS_WI_ERROR_2509               12509
#define IDS_WI_ERROR_2510               12510
#define IDS_WI_ERROR_2511               12511
#define IDS_WI_ERROR_2512               12512
#define IDS_WI_ERROR_2513               12513
#define IDS_WI_ERROR_2514               12514
#define IDS_WI_ERROR_2515               12515
#define IDS_WI_ERROR_2516               12516
#define IDS_WI_ERROR_2517               12517
#define IDS_WI_ERROR_2518               12518
#define IDS_WI_ERROR_2519               12519
#define IDS_WI_ERROR_2520               12520
#define IDS_WI_ERROR_2521               12521
#define IDS_WI_ERROR_2522               12522
#define IDS_WI_ERROR_2523               12523
#define IDS_WI_ERROR_2524               12524
#define IDS_WI_ERROR_2525               12525
#define IDS_WI_ERROR_2526               12526
#define IDS_WI_ERROR_2527               12527
#define IDS_WI_ERROR_2528               12528
#define IDS_WI_ERROR_2529               12529
#define IDS_WI_ERROR_2530               12530
#define IDS_WI_ERROR_2531               12531
#define IDS_WI_ERROR_2532               12532
#define IDS_WI_ERROR_2533               12533
#define IDS_WI_ERROR_2534               12534
#define IDS_WI_ERROR_2535               12535
#define IDS_WI_ERROR_2536               12536
#define IDS_WI_ERROR_2537               12537
#define IDS_WI_ERROR_2538               12538
#define IDS_WI_ERROR_2539               12539
#define IDS_WI_ERROR_2540               12540
#define IDS_WI_ERROR_2541               12541
#define IDS_WI_ERROR_2542               12542
#define IDS_WI_ERROR_2543               12543
#define IDS_WI_ERROR_2544               12544
#define IDS_WI_ERROR_2545               12545
#define IDS_WI_ERROR_2546               12546
#define IDS_WI_ERROR_2547               12547
#define IDS_WI_ERROR_2548               12548
#define IDS_WI_ERROR_2549               12549
#define IDS_WI_ERROR_2550               12550
#define IDS_WI_ERROR_2551               12551
#define IDS_WI_ERROR_2552               12552
#define IDS_WI_ERROR_2553               12553
#define IDS_WI_ERROR_2554               12554
#define IDS_WI_ERROR_2555               12555
#define IDS_WI_ERROR_2556               12556
#define IDS_WI_ERROR_2557               12557
#define IDS_WI_ERROR_2558               12558
#define IDS_WI_ERROR_2559               12559
#define IDS_WI_ERROR_2560               12560
#define IDS_WI_ERROR_2561               12561
#define IDS_WI_ERROR_2562               12562
#define IDS_WI_ERROR_2563               12563
#define IDS_WI_ERROR_2564               12564
#define IDS_WI_ERROR_2565               12565
#define IDS_WI_ERROR_2566               12566
#define IDS_WI_ERROR_2567               12567
#define IDS_WI_ERROR_2568               12568
#define IDS_WI_ERROR_2569               12569
#define IDS_WI_ERROR_2570               12570
#define IDS_WI_ERROR_2571               12571
#define IDS_WI_ERROR_2572               12572
#define IDS_WI_ERROR_2573               12573
#define IDS_WI_ERROR_2574               12574
#define IDS_WI_ERROR_2575               12575
#define IDS_WI_ERROR_2576               12576
#define IDS_WI_ERROR_2577               12577
#define IDS_WI_ERROR_2578               12578
#define IDS_WI_ERROR_2579               12579
#define IDS_WI_ERROR_2580               12580
#define IDS_WI_ERROR_2581               12581
#define IDS_WI_ERROR_2582               12582
#define IDS_WI_ERROR_2583               12583
#define IDS_WI_ERROR_2584               12584
#define IDS_WI_ERROR_2585               12585
#define IDS_WI_ERROR_2586               12586
#define IDS_WI_ERROR_2587               12587
#define IDS_WI_ERROR_2588               12588
#define IDS_WI_ERROR_2589               12589
#define IDS_WI_ERROR_2590               12590
#define IDS_WI_ERROR_2591               12591
#define IDS_WI_ERROR_2592               12592
#define IDS_WI_ERROR_2593               12593
#define IDS_WI_ERROR_2594               12594
#define IDS_WI_ERROR_2595               12595
#define IDS_WI_ERROR_2596               12596
#define IDS_WI_ERROR_2597               12597
#define IDS_WI_ERROR_2598               12598
#define IDS_WI_ERROR_2599               12599
#define IDS_WI_ERROR_2600               12600
#define IDS_WI_ERROR_2601               12601
#define IDS_WI_ERROR_2602               12602
#define IDS_WI_ERROR_2603               12603
#define IDS_WI_ERROR_2604               12604
#define IDS_WI_ERROR_2605               12605
#define IDS_WI_ERROR_2606               12606
#define IDS_WI_ERROR_2607               12607
#define IDS_WI_ERROR_2608               12608
#define IDS_WI_ERROR_2609               12609
#define IDS_WI_ERROR_2610               12610
#define IDS_WI_ERROR_2611               12611
#define IDS_WI_ERROR_2612               12612
#define IDS_WI_ERROR_2613               12613
#define IDS_WI_ERROR_2614               12614
#define IDS_WI_ERROR_2615               12615
#define IDS_WI_ERROR_2616               12616
#define IDS_WI_ERROR_2617               12617
#define IDS_WI_ERROR_2618               12618
#define IDS_WI_ERROR_2619               12619
#define IDS_WI_ERROR_2620               12620
#define IDS_WI_ERROR_2621               12621
#define IDS_WI_ERROR_2622               12622
#define IDS_WI_ERROR_2623               12623
#define IDS_WI_ERROR_2624               12624
#define IDS_WI_ERROR_2625               12625
#define IDS_WI_ERROR_2626               12626
#define IDS_WI_ERROR_2627               12627
#define IDS_WI_ERROR_2628               12628
#define IDS_WI_ERROR_2629               12629
#define IDS_WI_ERROR_2630               12630
#define IDS_WI_ERROR_2631               12631
#define IDS_WI_ERROR_2632               12632
#define IDS_WI_ERROR_2633               12633
#define IDS_WI_ERROR_2634               12634
#define IDS_WI_ERROR_2635               12635
#define IDS_WI_ERROR_2636               12636
#define IDS_WI_ERROR_2637               12637
#define IDS_WI_ERROR_2638               12638
#define IDS_WI_ERROR_2639               12639
#define IDS_WI_ERROR_2640               12640
#define IDS_WI_ERROR_2641               12641
#define IDS_WI_ERROR_2642               12642
#define IDS_WI_ERROR_2643               12643
#define IDS_WI_ERROR_2644               12644
#define IDS_WI_ERROR_2645               12645
#define IDS_WI_ERROR_2646               12646
#define IDS_WI_ERROR_2647               12647
#define IDS_WI_ERROR_2648               12648
#define IDS_WI_ERROR_2649               12649
#define IDS_WI_ERROR_2650               12650
#define IDS_WI_ERROR_2651               12651
#define IDS_WI_ERROR_2652               12652
#define IDS_WI_ERROR_2653               12653
#define IDS_WI_ERROR_2654               12654
#define IDS_WI_ERROR_2655               12655
#define IDS_WI_ERROR_2656               12656
#define IDS_WI_ERROR_2657               12657
#define IDS_WI_ERROR_2658               12658
#define IDS_WI_ERROR_2659               12659
#define IDS_WI_ERROR_2660               12660
#define IDS_WI_ERROR_2661               12661
#define IDS_WI_ERROR_2662               12662
#define IDS_WI_ERROR_2663               12663
#define IDS_WI_ERROR_2664               12664
#define IDS_WI_ERROR_2665               12665
#define IDS_WI_ERROR_2666               12666
#define IDS_WI_ERROR_2667               12667
#define IDS_WI_ERROR_2668               12668
#define IDS_WI_ERROR_2669               12669
#define IDS_WI_ERROR_2670               12670
#define IDS_WI_ERROR_2671               12671
#define IDS_WI_ERROR_2672               12672
#define IDS_WI_ERROR_2673               12673
#define IDS_WI_ERROR_2674               12674
#define IDS_WI_ERROR_2675               12675
#define IDS_WI_ERROR_2676               12676
#define IDS_WI_ERROR_2677               12677
#define IDS_WI_ERROR_2678               12678
#define IDS_WI_ERROR_2679               12679
#define IDS_WI_ERROR_2680               12680
#define IDS_WI_ERROR_2681               12681
#define IDS_WI_ERROR_2682               12682
#define IDS_WI_ERROR_2683               12683
#define IDS_WI_ERROR_2684               12684
#define IDS_WI_ERROR_2685               12685
#define IDS_WI_ERROR_2686               12686
#define IDS_WI_ERROR_2687               12687
#define IDS_WI_ERROR_2688               12688
#define IDS_WI_ERROR_2689               12689
#define IDS_WI_ERROR_2690               12690
#define IDS_WI_ERROR_2691               12691
#define IDS_WI_ERROR_2692               12692
#define IDS_WI_ERROR_2693               12693
#define IDS_WI_ERROR_2694               12694
#define IDS_WI_ERROR_2695               12695
#define IDS_WI_ERROR_2696               12696
#define IDS_WI_ERROR_2697               12697
#define IDS_WI_ERROR_2698               12698
#define IDS_WI_ERROR_2699               12699
#define IDS_WI_ERROR_2700               12700
#define IDS_WI_ERROR_2701               12701
#define IDS_WI_ERROR_2702               12702
#define IDS_WI_ERROR_2703               12703
#define IDS_WI_ERROR_2704               12704
#define IDS_WI_ERROR_2705               12705
#define IDS_WI_ERROR_2706               12706
#define IDS_WI_ERROR_2707               12707
#define IDS_WI_ERROR_2708               12708
#define IDS_WI_ERROR_2709               12709
#define IDS_WI_ERROR_2710               12710
#define IDS_WI_ERROR_2711               12711
#define IDS_WI_ERROR_2712               12712
#define IDS_WI_ERROR_2713               12713
#define IDS_WI_ERROR_2714               12714
#define IDS_WI_ERROR_2715               12715
#define IDS_WI_ERROR_2716               12716
#define IDS_WI_ERROR_2717               12717
#define IDS_WI_ERROR_2718               12718
#define IDS_WI_ERROR_2719               12719
#define IDS_WI_ERROR_2720               12720
#define IDS_WI_ERROR_2721               12721
#define IDS_WI_ERROR_2722               12722
#define IDS_WI_ERROR_2723               12723
#define IDS_WI_ERROR_2724               12724
#define IDS_WI_ERROR_2725               12725
#define IDS_WI_ERROR_2726               12726
#define IDS_WI_ERROR_2727               12727
#define IDS_WI_ERROR_2728               12728
#define IDS_WI_ERROR_2729               12729
#define IDS_WI_ERROR_2730               12730
#define IDS_WI_ERROR_2731               12731
#define IDS_WI_ERROR_2732               12732
#define IDS_WI_ERROR_2733               12733
#define IDS_WI_ERROR_2734               12734
#define IDS_WI_ERROR_2735               12735
#define IDS_WI_ERROR_2736               12736
#define IDS_WI_ERROR_2737               12737
#define IDS_WI_ERROR_2738               12738
#define IDS_WI_ERROR_2739               12739
#define IDS_WI_ERROR_2740               12740
#define IDS_WI_ERROR_2741               12741
#define IDS_WI_ERROR_2742               12742
#define IDS_WI_ERROR_2743               12743
#define IDS_WI_ERROR_2744               12744
#define IDS_WI_ERROR_2745               12745
#define IDS_WI_ERROR_2746               12746
#define IDS_WI_ERROR_2747               12747
#define IDS_WI_ERROR_2748               12748
#define IDS_WI_ERROR_2749               12749
#define IDS_WI_ERROR_2750               12750
#define IDS_WI_ERROR_2751               12751
#define IDS_WI_ERROR_2752               12752
#define IDS_WI_ERROR_2753               12753
#define IDS_WI_ERROR_2754               12754
#define IDS_WI_ERROR_2755               12755
#define IDS_WI_ERROR_2756               12756
#define IDS_WI_ERROR_2757               12757
#define IDS_WI_ERROR_2758               12758
#define IDS_WI_ERROR_2759               12759
#define IDS_WI_ERROR_2760               12760
#define IDS_WI_ERROR_2761               12761
#define IDS_WI_ERROR_2762               12762
#define IDS_WI_ERROR_2763               12763
#define IDS_WI_ERROR_2764               12764
#define IDS_WI_ERROR_2765               12765
#define IDS_WI_ERROR_2766               12766
#define IDS_WI_ERROR_2767               12767
#define IDS_WI_ERROR_2768               12768
#define IDS_WI_ERROR_2769               12769
#define IDS_WI_ERROR_2770               12770
#define IDS_WI_ERROR_2771               12771
#define IDS_WI_ERROR_2772               12772
#define IDS_WI_ERROR_2773               12773
#define IDS_WI_ERROR_2774               12774
#define IDS_WI_ERROR_2775               12775
#define IDS_WI_ERROR_2776               12776
#define IDS_WI_ERROR_2777               12777
#define IDS_WI_ERROR_2778               12778
#define IDS_WI_ERROR_2779               12779
#define IDS_WI_ERROR_2780               12780
#define IDS_WI_ERROR_2781               12781
#define IDS_WI_ERROR_2782               12782
#define IDS_WI_ERROR_2783               12783
#define IDS_WI_ERROR_2784               12784
#define IDS_WI_ERROR_2785               12785
#define IDS_WI_ERROR_2786               12786
#define IDS_WI_ERROR_2787               12787
#define IDS_WI_ERROR_2788               12788
#define IDS_WI_ERROR_2789               12789
#define IDS_WI_ERROR_2790               12790
#define IDS_WI_ERROR_2791               12791
#define IDS_WI_ERROR_2792               12792
#define IDS_WI_ERROR_2793               12793
#define IDS_WI_ERROR_2794               12794
#define IDS_WI_ERROR_2795               12795
#define IDS_WI_ERROR_2796               12796
#define IDS_WI_ERROR_2797               12797
#define IDS_WI_ERROR_2798               12798
#define IDS_WI_ERROR_2799               12799
#define IDS_WI_ERROR_2800               12800
#define IDS_WI_ERROR_2801               12801
#define IDS_WI_ERROR_2802               12802
#define IDS_WI_ERROR_2803               12803
#define IDS_WI_ERROR_2804               12804
#define IDS_WI_ERROR_2805               12805
#define IDS_WI_ERROR_2806               12806
#define IDS_WI_ERROR_2807               12807
#define IDS_WI_ERROR_2808               12808
#define IDS_WI_ERROR_2809               12809
#define IDS_WI_ERROR_2810               12810
#define IDS_WI_ERROR_2811               12811
#define IDS_WI_ERROR_2812               12812
#define IDS_WI_ERROR_2813               12813
#define IDS_WI_ERROR_2814               12814
#define IDS_WI_ERROR_2815               12815
#define IDS_WI_ERROR_2816               12816
#define IDS_WI_ERROR_2817               12817
#define IDS_WI_ERROR_2818               12818
#define IDS_WI_ERROR_2819               12819
#define IDS_WI_ERROR_2820               12820
#define IDS_WI_ERROR_2821               12821
#define IDS_WI_ERROR_2822               12822
#define IDS_WI_ERROR_2823               12823
#define IDS_WI_ERROR_2824               12824
#define IDS_WI_ERROR_2825               12825
#define IDS_WI_ERROR_2826               12826
#define IDS_WI_ERROR_2827               12827
#define IDS_WI_ERROR_2828               12828
#define IDS_WI_ERROR_2829               12829
#define IDS_WI_ERROR_2830               12830
#define IDS_WI_ERROR_2831               12831
#define IDS_WI_ERROR_2832               12832
#define IDS_WI_ERROR_2833               12833
#define IDS_WI_ERROR_2834               12834
#define IDS_WI_ERROR_2835               12835
#define IDS_WI_ERROR_2836               12836
#define IDS_WI_ERROR_2837               12837
#define IDS_WI_ERROR_2838               12838
#define IDS_WI_ERROR_2839               12839
#define IDS_WI_ERROR_2840               12840
#define IDS_WI_ERROR_2841               12841
#define IDS_WI_ERROR_2842               12842
#define IDS_WI_ERROR_2843               12843
#define IDS_WI_ERROR_2844               12844
#define IDS_WI_ERROR_2845               12845
#define IDS_WI_ERROR_2846               12846
#define IDS_WI_ERROR_2847               12847
#define IDS_WI_ERROR_2848               12848
#define IDS_WI_ERROR_2849               12849
#define IDS_WI_ERROR_2850               12850
#define IDS_WI_ERROR_2851               12851
#define IDS_WI_ERROR_2852               12852
#define IDS_WI_ERROR_2853               12853
#define IDS_WI_ERROR_2854               12854
#define IDS_WI_ERROR_2855               12855
#define IDS_WI_ERROR_2856               12856
#define IDS_WI_ERROR_2857               12857
#define IDS_WI_ERROR_2858               12858
#define IDS_WI_ERROR_2859               12859
#define IDS_WI_ERROR_2860               12860
#define IDS_WI_ERROR_2861               12861
#define IDS_WI_ERROR_2862               12862
#define IDS_WI_ERROR_2863               12863
#define IDS_WI_ERROR_2864               12864
#define IDS_WI_ERROR_2865               12865
#define IDS_WI_ERROR_2866               12866
#define IDS_WI_ERROR_2867               12867
#define IDS_WI_ERROR_2868               12868
#define IDS_WI_ERROR_2869               12869
#define IDS_WI_ERROR_2870               12870
#define IDS_WI_ERROR_2871               12871
#define IDS_WI_ERROR_2872               12872
#define IDS_WI_ERROR_2873               12873
#define IDS_WI_ERROR_2874               12874
#define IDS_WI_ERROR_2875               12875
#define IDS_WI_ERROR_2876               12876
#define IDS_WI_ERROR_2877               12877
#define IDS_WI_ERROR_2878               12878
#define IDS_WI_ERROR_2879               12879
#define IDS_WI_ERROR_2880               12880
#define IDS_WI_ERROR_2881               12881
#define IDS_WI_ERROR_2882               12882
#define IDS_WI_ERROR_2883               12883
#define IDS_WI_ERROR_2884               12884
#define IDS_WI_ERROR_2885               12885
#define IDS_WI_ERROR_2886               12886
#define IDS_WI_ERROR_2887               12887
#define IDS_WI_ERROR_2888               12888
#define IDS_WI_ERROR_2889               12889
#define IDS_WI_ERROR_2890               12890
#define IDS_WI_ERROR_2891               12891
#define IDS_WI_ERROR_2892               12892
#define IDS_WI_ERROR_2893               12893
#define IDS_WI_ERROR_2894               12894
#define IDS_WI_ERROR_2895               12895
#define IDS_WI_ERROR_2896               12896
#define IDS_WI_ERROR_2897               12897
#define IDS_WI_ERROR_2898               12898
#define IDS_WI_ERROR_2899               12899
#define IDS_WI_ERROR_2900               12900
#define IDS_WI_ERROR_2901               12901
#define IDS_WI_ERROR_2902               12902
#define IDS_WI_ERROR_2903               12903
#define IDS_WI_ERROR_2904               12904
#define IDS_WI_ERROR_2905               12905
#define IDS_WI_ERROR_2906               12906
#define IDS_WI_ERROR_2907               12907
#define IDS_WI_ERROR_2908               12908
#define IDS_WI_ERROR_2909               12909
#define IDS_WI_ERROR_2910               12910
#define IDS_WI_ERROR_2911               12911
#define IDS_WI_ERROR_2912               12912
#define IDS_WI_ERROR_2913               12913
#define IDS_WI_ERROR_2914               12914
#define IDS_WI_ERROR_2915               12915
#define IDS_WI_ERROR_2916               12916
#define IDS_WI_ERROR_2917               12917
#define IDS_WI_ERROR_2918               12918
#define IDS_WI_ERROR_2919               12919
#define IDS_WI_ERROR_2920               12920
#define IDS_WI_ERROR_2921               12921
#define IDS_WI_ERROR_2922               12922
#define IDS_WI_ERROR_2923               12923
#define IDS_WI_ERROR_2924               12924
#define IDS_WI_ERROR_2925               12925
#define IDS_WI_ERROR_2926               12926
#define IDS_WI_ERROR_2927               12927
#define IDS_WI_ERROR_2928               12928
#define IDS_WI_ERROR_2929               12929
#define IDS_WI_ERROR_2930               12930
#define IDS_WI_ERROR_2931               12931
#define IDS_WI_ERROR_2932               12932
#define IDS_WI_ERROR_2933               12933
#define IDS_WI_ERROR_2934               12934
#define IDS_WI_ERROR_2935               12935
#define IDS_WI_ERROR_2936               12936
#define IDS_WI_ERROR_2937               12937
#define IDS_WI_ERROR_2938               12938
#define IDS_WI_ERROR_2939               12939
#define IDS_WI_ERROR_2940               12940
#define IDS_WI_ERROR_2941               12941
#define IDS_WI_ERROR_2942               12942
#define IDS_WI_ERROR_2943               12943
#define IDS_WI_ERROR_2944               12944
#define IDS_WI_ERROR_2945               12945
#define IDS_WI_ERROR_2946               12946
#define IDS_WI_ERROR_2947               12947
#define IDS_WI_ERROR_2948               12948
#define IDS_WI_ERROR_2949               12949
#define IDS_WI_ERROR_2950               12950
#define IDS_WI_ERROR_2951               12951
#define IDS_WI_ERROR_2952               12952
#define IDS_WI_ERROR_2953               12953
#define IDS_WI_ERROR_2954               12954
#define IDS_WI_ERROR_2955               12955
#define IDS_WI_ERROR_2956               12956
#define IDS_WI_ERROR_2957               12957
#define IDS_WI_ERROR_2958               12958
#define IDS_WI_ERROR_2959               12959
#define IDS_WI_ERROR_2960               12960
#define IDS_WI_ERROR_2961               12961
#define IDS_WI_ERROR_2962               12962
#define IDS_WI_ERROR_2963               12963
#define IDS_WI_ERROR_2964               12964
#define IDS_WI_ERROR_2965               12965
#define IDS_WI_ERROR_2966               12966
#define IDS_WI_ERROR_2967               12967
#define IDS_WI_ERROR_2968               12968
#define IDS_WI_ERROR_2969               12969
#define IDS_WI_ERROR_2970               12970
#define IDS_WI_ERROR_2971               12971
#define IDS_WI_ERROR_2972               12972
#define IDS_WI_ERROR_2973               12973
#define IDS_WI_ERROR_2974               12974
#define IDS_WI_ERROR_2975               12975
#define IDS_WI_ERROR_2976               12976
#define IDS_WI_ERROR_2977               12977
#define IDS_WI_ERROR_2978               12978
#define IDS_WI_ERROR_2979               12979
#define IDS_WI_ERROR_2980               12980
#define IDS_WI_ERROR_2981               12981
#define IDS_WI_ERROR_2982               12982
#define IDS_WI_ERROR_2983               12983
#define IDS_WI_ERROR_2984               12984
#define IDS_WI_ERROR_2985               12985
#define IDS_WI_ERROR_2986               12986
#define IDS_WI_ERROR_2987               12987
#define IDS_WI_ERROR_2988               12988
#define IDS_WI_ERROR_2989               12989
#define IDS_WI_ERROR_2990               12990
#define IDS_WI_ERROR_2991               12991
#define IDS_WI_ERROR_2992               12992
#define IDS_WI_ERROR_2993               12993
#define IDS_WI_ERROR_2994               12994
#define IDS_WI_ERROR_2995               12995
#define IDS_WI_ERROR_2996               12996
#define IDS_WI_ERROR_2997               12997
#define IDS_WI_ERROR_2998               12998
#define IDS_WI_ERROR_2999               12999
#define ID_OPERATIONS_SHOWPROPERTIES    32771
#define ID_OPERATIONS_SHOWSTATES        32772
#define ID_OPERATIONS_SHOWPOLICIES      32773
#define ID_OPERATIONS_GENERATEHTMLOUTPUT 32774
#define ID_OPERATIONS_OPTIONS           32776

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        146
#define _APS_NEXT_COMMAND_VALUE         32777
#define _APS_NEXT_CONTROL_VALUE         1086
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\wilogutl.cpp ===
// wilogutl.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "wilogutl.h"
#include "showlogd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWILogUtilApp

BEGIN_MESSAGE_MAP(CWILogUtilApp, CWinApp)
	//{{AFX_MSG_MAP(CWILogUtilApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWILogUtilApp construction

CWILogUtilApp::CWILogUtilApp()
{
	m_cstrOutputDirectory = g_szDefaultOutputLogDir;
	m_bBadExceptionHit = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWILogUtilApp object

CWILogUtilApp theApp;

BOOL DoesFileExist(CString &cstrLogFileName)
{
	BOOL bRet = FALSE;

	if (!cstrLogFileName.IsEmpty())
	{
       FILE *fptr;
	   fptr = fopen(cstrLogFileName, "r");
	   if (fptr)
	   {
		  bRet = TRUE;

		  fclose(fptr);
	   }
	}

	return bRet;
}



BOOL DoLogFile(char *szLine,
			   char *szLogFileName)
{
	BOOL bRet = FALSE;

    szLine++; //skip /
    szLine++; //skip l
 
    if (szLine[0] == ' ')
    {
       szLine++; //skip space
	}

	char *lpszMSILogFileNameFound;
	lpszMSILogFileNameFound = strstr(szLine, "/");
	if (lpszMSILogFileNameFound)
	{
	    int nBytesCopy = lpszMSILogFileNameFound - szLine - 1; //-1 is for "/" string
		if ((nBytesCopy > 0) && (nBytesCopy < MAX_PATH))
		{
           strncpy(szLogFileName, szLine, nBytesCopy);
           szLogFileName[nBytesCopy] = '\0';

		   bRet = TRUE;
		}
		else
		   bRet = FALSE; //buffer too small...
	}
	else //must be last one passed or commandline was invalid....
	{
		strcpy(szLogFileName, szLine);
		bRet = TRUE;
	}

	return bRet;
}

//nmanis, 5-4-2001
BOOL DoOutputDir(char *szLine,
			     char *szOutDirName)
{
	BOOL bRet = FALSE;

    szLine++; //skip /
    szLine++; //skip l
 
    if (szLine[0] == ' ')
    {
       szLine++; //skip space
	}

	char *lpszOutDirFound;
	lpszOutDirFound= strstr(szLine, "/");
	if (lpszOutDirFound)
	{
	    int nBytesCopy = lpszOutDirFound - szLine - 1; //-1 is for "/" string
		if ((nBytesCopy > 0) && (nBytesCopy < MAX_PATH))
		{
           strncpy(szOutDirName, szLine, nBytesCopy);
           szOutDirName[nBytesCopy] = '\0';

		   bRet = TRUE;
		}
		else
		   bRet = FALSE; //buffer too small...
	}
	else //must be last one passed or commandline was invalid....
	{
		strcpy(szOutDirName, szLine);
		bRet = TRUE;
	}

	return bRet;
}
//end nmanis, 5-4-2001
				 
//5-9-2001
#define CMD_OK                  0
#define BAD_OUTPUT_DIR          1
#define BAD_LOGFILE_NAME        2
#define MISSING_LOG_SWITCH      3
#define MISSING_QUIET_SWITCH    4

int g_iBadCmdRet = CMD_OK;
char g_szCmdError[5][256] = { "No Error", "Bad output directory specified", 
"Bad log file name specified", "Missing required switch /l for the log file name",
"Missing required switch /q for quiet mode" }; 

//returns CMD_OK if no error
//returns BAD_OUTPUT_DIR   if bad dir, non-existant
//returns BAD_LOGFILE_NAME if bad log file, non-existant
//returns MISSING_REQUIRED_SWITCH if invalid switches, missing required switch /q, /Q or /l, /L
int CWILogUtilApp::DoCommandLine()
{
	int  iRet = CMD_OK;
	BOOL bRet = TRUE;
	BOOL bLogFound = FALSE;

	char szLogFileName[MAX_PATH];
	char szOutDir[MAX_PATH];

	char *lpszCmdLine = GetCommandLine();
    if (lpszCmdLine)
    {
//5-16-2001
	   char *lpszPSSModeOn;
       lpszPSSModeOn = strstr(lpszCmdLine, "/v");
	   if (lpszPSSModeOn)
	   {
          g_bShowEverything = TRUE;
	   }

       lpszPSSModeOn = strstr(lpszCmdLine, "/V");
	   if (lpszPSSModeOn)
	   {
          g_bShowEverything = TRUE;
	   }
//end 5-16-2001

	   char *lpszQuiteMode;
       lpszQuiteMode = strstr(lpszCmdLine, "/q");
	   if (lpszQuiteMode)
	   {
          g_bRunningInQuietMode = TRUE;
	   }

	   lpszQuiteMode = strstr(lpszCmdLine, "/Q");
	   if (lpszQuiteMode)
          g_bRunningInQuietMode = TRUE;

       char *lpszMSILogFilePassed;
	   lpszMSILogFilePassed = strstr(lpszCmdLine, "/l");
	   if (lpszMSILogFilePassed)
	      bLogFound = DoLogFile(lpszMSILogFilePassed, szLogFileName);

	   if (!bLogFound)
	   {
	      lpszMSILogFilePassed = strstr(lpszCmdLine, "/L");
          if (lpszMSILogFilePassed)
             bLogFound = DoLogFile(lpszMSILogFilePassed, szLogFileName);
	   }

	   if (bLogFound)
	   {
		  CString cstrFile;
		  cstrFile = szLogFileName;
		  cstrFile.TrimRight(); //clean up any trailing spaces...
		  cstrFile.TrimLeft();  //clean up any leading spaces...

		  char szQuote[2];
		  szQuote[0] = '"';
		  szQuote[1] = '\0';

		  cstrFile.TrimRight(szQuote); //clean up any trailing quotes...
		  cstrFile.TrimLeft(szQuote); //clean up any leading quotes...

		  char szShortPath[MAX_PATH];
		  DWORD dwRet = GetShortPathName(cstrFile, szShortPath, MAX_PATH);
		  if (dwRet)
		  {
			 //converted...
             cstrFile = szShortPath; //use the short path for the file...
		  }
			 
		  bRet = DoesFileExist(cstrFile);
		  if (bRet)
		  {
			 strcpy(g_szLogFileToParse, cstrFile.GetBuffer(MAX_PATH));
			 cstrFile.ReleaseBuffer();
		  }
		  else
		  {
			 //invalid log file passed, fail out...
			 iRet = BAD_LOGFILE_NAME; //5-9-2001
		  }
	   }
	   else //5-9-2001
	   {
		  if (g_bRunningInQuietMode) //only required if running in quiet mode...
             iRet = MISSING_LOG_SWITCH;
	   }

//nmanis, 5-4-2001, fixed Win9x bug on 5-9-2001
	   if (bRet && bLogFound && g_bRunningInQuietMode) //5-9-2001, well, before doing any optional work, make sure required worked first!
	   {
          char *lpszOutDirPassed;
	      BOOL bOutDirFound = FALSE;
	      lpszOutDirPassed = strstr(lpszCmdLine, "/o");
	      if (lpszOutDirPassed)
	         bOutDirFound = DoOutputDir(lpszOutDirPassed, szOutDir);

	      if (!bOutDirFound)
		  {
	         lpszOutDirPassed = strstr(lpszCmdLine, "/O");
             if (lpszOutDirPassed)
                bOutDirFound = DoOutputDir(lpszOutDirPassed, szOutDir);
		  }

	      if (bOutDirFound)
		  {
             int iLength = strlen(szOutDir);
			 if (iLength)
			 {
               if (szOutDir[iLength-1] != '\\') 
			   {
			 	  strcat(szOutDir, "\\");
			   }

		       bRet = IsValidDirectory(szOutDir);
		       if (bRet)
			   {
                  m_cstrOutputDirectory = szOutDir;
			   }
			   //else, //else, ignore log dir passed
			 }
			 //else, ignore log dir passed
		  }
	   }
//end nmanis, 5-4-2001, 5-9-2001
    }

	//5-9-2001
	//if a log was passed, but not quiet mode, well, it is incorrect
	if (!g_bRunningInQuietMode && bLogFound)
       iRet = MISSING_QUIET_SWITCH;	    

	return iRet;
}


#include "loganald.h"

/////////////////////////////////////////////////////////////////////////////
// CWILogUtilApp initialization
BOOL CWILogUtilApp::InitInstance()
{
    //handle all exceptions up to this point...
	try
	{
//nmanis, do the OS check early...
  	   OSVERSIONINFO ver = { 0 };

	   ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	   GetVersionEx(&ver);
	   if (VER_PLATFORM_WIN32_NT == ver.dwPlatformId)
          g_bNT = TRUE;

  	   int nResponse;

//nmanis, no Ax controls means leaner .EXE...
// 	   AfxEnableControlContainer();

	   SetRegistryKey(_T("PSS"));
	   InitHTMLColorSettings(UserSettings); //initial settings for program...

	   CString strValue;
	   CString strRet;
	   UINT    nValue;

       //read in the colors dude, reading/writing with strings as MFC GetProfileInt can not handle larger values (> 32767)
	   for (int i=0; i < MAX_HTML_LOG_COLORS; i++)
	   {
	 	   strValue.Format("%d", UserSettings.settings[i].value);

		   strRet = GetProfileString("Settings", UserSettings.settings[i].name, strValue);

           nValue = atoi(strRet);//convert to a int
		   this->m_arColors.Add(nValue);
	   }

	   m_cstrOutputDirectory = GetProfileString("Settings", "OutputDir", g_szDefaultOutputLogDir);
	   m_cstrIgnoredErrors = GetProfileString("Settings", "IgnoredErrors", g_szDefaultIgnoredErrors);

//5-9-2001
	   g_iBadCmdRet = DoCommandLine();
	   if (g_iBadCmdRet != CMD_OK)
	   { 
		  CString str;
		  str.Format("WILogUtil.EXE: Invalid command line passed to executable. Return error %d.  %s\n",  g_iBadCmdRet, g_szCmdError[ g_iBadCmdRet]);

          //invalid command line passed to executable, could be bad parameters...
		  OutputDebugString(str);
		  return FALSE;
	   }
//end 5-9-2001

	   if (!g_bRunningInQuietMode)
	   {
  	      COpenDlg dlg;
	      m_pMainWnd = &dlg;

          nResponse = dlg.DoModal();
	      if (nResponse == IDOK)
		  {
		  }
	      else if (nResponse == IDCANCEL)
		  {
		  }
	   }
	   else
	   {
		     //5-17-2001, don't show error messages in quiet mode via gui...
             SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);

			 CString strFile;
			 strFile = g_szLogFileToParse;

		     CLogAnalyzeDlg dlg;

             dlg.SetLogfileLocation(strFile);
			 dlg.AnalyzeLog();
	   }
	}
	catch(...)
	{
       if (!g_bRunningInQuietMode)
	   {
          AfxMessageBox("Unhandled exception in program.  Program will now close.");
	   }

	   //got exception somehow, catch it!
	   m_bBadExceptionHit = TRUE;
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}


int CWILogUtilApp::ExitInstance() 
{
	int iSize = m_arColors.GetSize();

	if (!m_bBadExceptionHit && (iSize == MAX_HTML_LOG_COLORS) && 
		!g_bRunningInQuietMode)  //don't let quiet command line override the GUI settings...
	{
       CString strValue;
	   UINT    nValue;
	   BOOL    bRet;

       //read in the colors dude...
       for (int i=0; i < MAX_HTML_LOG_COLORS; i++)
	   {
		 nValue = m_arColors.GetAt(i);
	 	 strValue.Format("%d", nValue); //format as a string...

		 bRet = WriteProfileString("Settings", UserSettings.settings[i].name, strValue);
	   }

       bRet = WriteProfileString("Settings", "OutputDir", m_cstrOutputDirectory);

//5-4-2001
	   //write out ignored errors to registry as well...
	   bRet = WriteProfileString("Settings", "IgnoredErrors", m_cstrIgnoredErrors);
//5-4-2001
	}

//5-9-2001
	int iRet;
	iRet = CWinApp::ExitInstance();

	if (g_iBadCmdRet)
       iRet = g_iBadCmdRet;

	return iRet;
//end 5-9-2001
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\wilogutl\wilogutl.h ===
// wilogutl.h : main header file for the SHOWINSTALLLOGS application
//

#if !defined(AFX_SHOWINSTALLLOGS_H__EEC979FD_C301_48B5_BE22_D4C5CEE50166__INCLUDED_)
#define AFX_SHOWINSTALLLOGS_H__EEC979FD_C301_48B5_BE22_D4C5CEE50166__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "wilogres.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CWILogUtilApp:
// See wilogutl.cpp for the implementation of this class
//

class CWILogUtilApp : public CWinApp
{
public:
	CWILogUtilApp();

	CString GetOutputDirectory()
	{
       return m_cstrOutputDirectory;
	}

	CString GetIgnoredErrors()
	{
	   return m_cstrIgnoredErrors;
	}

	void SetIgnoredErrors(CString &cstrErrors)
	{
	   m_cstrIgnoredErrors = cstrErrors;
	}
	

	void SetOutputDirectory(CString &cstrOut)
	{
       m_cstrOutputDirectory = cstrOut;
	}

    BOOL GetUserColorSettings(CArray<COLORREF, COLORREF> &outColors)
	{
		BOOL bRet = FALSE;
		int iArraySize = m_arColors.GetSize();

        if (iArraySize)
		{
			bRet = TRUE;

			COLORREF col;
			outColors.RemoveAll();
 			for (int i=0; i < iArraySize; i++)
			{
				col = m_arColors.GetAt(i);
				outColors.Add(col);
			}
		}

		return bRet;
	}

	BOOL SetUserColorSettings(CArray<COLORREF, COLORREF> &inColors)
	{
		BOOL bRet = FALSE;
		int iArraySize = inColors.GetSize();

        if (iArraySize)
		{
			bRet = TRUE;

			COLORREF col;
			m_arColors.RemoveAll();
 			for (int i=0; i < iArraySize; i++)
			{
				col = inColors.GetAt(i);
				m_arColors.Add(col);
			}
		}

		return bRet;
	}

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWILogUtilApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CWILogUtilApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
   BOOL DoCommandLine();

   BOOL    m_bBadExceptionHit; 

   CString m_cstrOutputDirectory;
   CString m_cstrIgnoredErrors;

   CArray <COLORREF, COLORREF> m_arColors;
   struct HTMLColorSettings UserSettings;
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHOWINSTALLLOGS_H__EEC979FD_C301_48B5_BE22_D4C5CEE50166__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\commandopt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       CommandOpt.h
//
//    This file contains the definition of CommandOpt class 
//--------------------------------------------------------------------------

#ifndef XMSI_COMMANDOPT_H
#define XMSI_COMMANDOPT_H

#include <Windows.h>
#include <tchar.h>
#include <stdio.h>

class CommandOpt {
public:
	CommandOpt():m_bValidation(false),m_bVerbose(false),m_pLogFile(NULL),
				 m_szURL(NULL), m_szInputSkuFilter(NULL) {}

	~CommandOpt() 
	{
		if (m_pLogFile) fclose(m_pLogFile);
	}

	// Real work is done here
	UINT ParseCommandOptions(int argc, TCHAR *argv[]);
	
	// Print Usage
	void PrintUsage();

	// member access functions
	bool GetValidationMode() {return m_bValidation;}
	bool GetVerboseMode() {return m_bVerbose;}
	FILE *GetLogFile() {return m_pLogFile;}
	LPTSTR GetURL() {return m_szURL;}
	LPTSTR GetInputSkuFilter() {return m_szInputSkuFilter;}

private:
	bool m_bValidation;
	bool m_bVerbose;
	FILE *m_pLogFile;
	LPTSTR m_szURL;
	LPTSTR m_szInputSkuFilter;
};

#endif //XMSI_COMMANDOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\component.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       Component.cpp
//
//    This file contains the implementation of Component class 
//--------------------------------------------------------------------------

#include "wmc.h"

////////////////////////////////////////////////////////////////////////////
// Constructor: allocate memory for member variables
////////////////////////////////////////////////////////////////////////////
Component::Component()
{
	m_pSkuSet = new SkuSet(g_cSkus);
	assert(m_pSkuSet);

	m_pSkuSetValuesFeatureUse = new SkuSetValues();
	assert(m_pSkuSetValuesFeatureUse);
	m_pSkuSetValuesFeatureUse->SetValType(STRING_LIST);

	for (int i=0; i<5; i++)
	{
		m_rgpSkuSetValuesOwnership[i] = new SkuSetValues();
		assert(m_rgpSkuSetValuesOwnership);
		m_rgpSkuSetValuesOwnership[i]->SetValType(FM_PAIR);
	}
	
	m_pSkuSetValuesKeyPath = new SkuSetValues();
	assert(m_pSkuSetValuesKeyPath);
	m_pSkuSetValuesKeyPath->SetValType(STRING);

}

////////////////////////////////////////////////////////////////////////////
// Destructor: release memory
////////////////////////////////////////////////////////////////////////////
Component::~Component()
{
	if (m_pSkuSet)
		delete m_pSkuSet;

	if (m_pSkuSetValuesFeatureUse)
		delete m_pSkuSetValuesFeatureUse;

	for (int i=0; i<5; i++)
	{
		if (m_rgpSkuSetValuesOwnership[i])
			delete m_rgpSkuSetValuesOwnership[i];
	}

	if (m_pSkuSetValuesKeyPath)
		delete m_pSkuSetValuesKeyPath;
}

////////////////////////////////////////////////////////////////////////////
// SetSkuSet: update the set of SKUs that will install this component
////////////////////////////////////////////////////////////////////////////
void 
Component::SetSkuSet(SkuSet *pSkuSet)
{
	assert(pSkuSet);

	assert(m_pSkuSet);
	*m_pSkuSet |= *pSkuSet;
}

////////////////////////////////////////////////////////////////////////////
// GetSkuSet: returns the set of SKUs that will install this component
//			  caller should free the value returned
////////////////////////////////////////////////////////////////////////////
SkuSet *
Component::GetSkuSet()
{
	SkuSet *pSkuSetRetVal = new SkuSet(g_cSkus);
	assert(pSkuSetRetVal);

	assert(m_pSkuSet);
	*pSkuSetRetVal = *m_pSkuSet;
	return pSkuSetRetVal;
}

// The function tells how to update the feature set
// the type of values stored in *pIsValOut and isValOld are both
// STRING_LIST; the type of value stored in isValNew is LPTSTR.
// In the function, the output value is essentailly a set of strings
// that include all the strings stored in the old value plus the string
// stored in the new value.
// the function doesn't destroy isValOld or isValNew
HRESULT UpdateFeatureSet(IntStringValue *pIsValOut, IntStringValue isValOld, 
						 IntStringValue isValNew)
{
	set<LPTSTR, Cstring_less>::iterator it;

	set<LPTSTR, Cstring_less> *pSetStringOut = 
		new set<LPTSTR, Cstring_less>;
	assert(pSetStringOut);

	set<LPTSTR, Cstring_less> *pSetStringOld = isValOld.pSetString;

	// copy the strings stored in isValOld to *pSetStringOut
	for(it = pSetStringOld->begin(); it != pSetStringOld->end(); ++it)
	{
		if (*it)
		{
			LPTSTR sz = _tcsdup(*it);
			assert(sz);
			pSetStringOut->insert(sz);
		}		
	}

	// make a copy of the string stored in the new value
	LPTSTR szNew = _tcsdup(isValNew.szVal);
	assert(szNew);
	// insert the new value
	pSetStringOut->insert(szNew);

	// return the built StringSet
	pIsValOut->pSetString = pSetStringOut;

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// SetUsedByFeature: Add the passed-in feature to the set of features that use
//                   this component for the specified SkuSet. 
//					 Caller should free the arguments
////////////////////////////////////////////////////////////////////////////
void 
Component::SetUsedByFeature(LPTSTR szFeature, SkuSet *pSkuSet)
{
	assert(pSkuSet);
	if (pSkuSet->testClear())
		return;

	// make a copy of arguments
	SkuSet *pSkuSetNew = new SkuSet(g_cSkus);
	assert(pSkuSetNew);
	*pSkuSetNew = *pSkuSet;

	LPTSTR sz = _tcsdup(szFeature);
	assert(sz);

	IntStringValue isValNew;
	isValNew.szVal = sz;

	// update the list that is holding the Features
	m_pSkuSetValuesFeatureUse->SplitInsert(pSkuSetNew, isValNew, UpdateFeatureSet);
}

////////////////////////////////////////////////////////////////////////////
// GetFeatureUse: return the list of Features that use this component via
//				  a SkuSetValues object
//				  Caller should NOT destroy the value returned since it 
//				  is just a pointer to the value stored inside this component
////////////////////////////////////////////////////////////////////////////
SkuSetValues *
Component::GetFeatureUse()
{
	return m_pSkuSetValuesFeatureUse;
}

// The function tells how to update the Ownership Info stored in a
// SkuSetValues object. The type of all the IsVals used are FM_PAIR -
// a pair of Feature and Module IDs. In the function, the module of the
// old value (module 1) is compared with the module of the new value
// (module 2).  whoever lies lower in the module tree wins, meaning that
// the feature associated with that module stays in the data structure,
// i.e., that feature has the corresponding ownership.
// the function doesn't destroy isValOld or isValNew
HRESULT UpdateOwnership(IntStringValue *pIsValOut, IntStringValue isValOld, 
						 IntStringValue isValNew)
{
	extern HRESULT CompareModuleRel(LPTSTR szModule1, LPTSTR szModule2, 
										int *iResult);

	HRESULT hr = S_OK;

	LPTSTR szModuleOld = (isValOld.pFOM)->szModule;
	LPTSTR szModuleNew = (isValNew.pFOM)->szModule;

	int iCmpResult = 0;
	// compare the relationship of the 2 modules in the module tree
	hr = CompareModuleRel(szModuleOld, szModuleNew, &iCmpResult);

	// checking for conflict of ownership claiming
	if (SUCCEEDED(hr) && (0 == iCmpResult))
	{
		_tprintf(TEXT("Compile Error: Ambiguous ownership claiming:\n\t"));
		_tprintf(TEXT("Feature %s claim ownership of Module %s\n\t"),
					(isValOld.pFOM)->szFeature, szModuleOld);
		_tprintf(TEXT("Feature %s claim ownership of Module %s\n\t"),
					(isValNew.pFOM)->szFeature, szModuleNew);
		hr = E_FAIL;
	}

	if (FAILED(hr)) return hr;

	FOM *pFOMOut = new FOM;

	// ModuleNew wins
	if (-1 == iCmpResult)
	{
		pFOMOut->szModule = _tcsdup(szModuleNew);
		assert(pFOMOut->szModule);
		pFOMOut->szFeature = _tcsdup((isValNew.pFOM)->szFeature);
		assert(pFOMOut->szFeature);
	}
	else if (1 == iCmpResult)
	{
		pFOMOut->szModule = _tcsdup(szModuleOld);
		assert(pFOMOut->szModule);
		pFOMOut->szFeature = _tcsdup((isValOld.pFOM)->szFeature);
		assert(pFOMOut->szFeature);
	}
	else
		// shouldn't happen
		assert(1);

	// return the built FOM
	pIsValOut->pFOM = pFOMOut;

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// SetOwnership: pSkuSetValuesOwnership contains the information of 5 types
//				 of ownerships in bitfields. This function checks the 
//				 bitfield and stores each type of ownership info in a 
//				 seperate SkuSetValus object
////////////////////////////////////////////////////////////////////////////
HRESULT 
Component::SetOwnership(FOM *pFOM, SkuSetValues *pSkuSetValuesOwnership)
{
	assert(pFOM && pSkuSetValuesOwnership);

	HRESULT hr = S_OK;
	SkuSetVal *pSkuSetValTemp = NULL;

	// loop through the passed in ownership info list
	for (pSkuSetValTemp =  pSkuSetValuesOwnership->Start();
		 pSkuSetValTemp != pSkuSetValuesOwnership->End();
		 pSkuSetValTemp =  pSkuSetValuesOwnership->Next())
	{
		assert(pSkuSetValTemp);
		int iOwnershipInfo = pSkuSetValTemp->isVal.intVal;

		for (int i=0; i<cAttrBits_TakeOwnership; i++)
		{
			// check for each type of ownership info
			if ( (iOwnershipInfo & rgAttrBits_TakeOwnership[i].uiBit)
					== rgAttrBits_TakeOwnership[i].uiBit)
			{
				// make a copy of the passed-in value and insert
				// into the SkuSetValues object for this particular
				// type of ownership info
				LPTSTR szFeatureNew = _tcsdup(pFOM->szFeature);
				assert(szFeatureNew);
				LPTSTR szModuleNew = _tcsdup(pFOM->szModule);
				assert(szModuleNew);
				FOM *pFOMNew = new FOM;
				assert(pFOMNew);
				pFOMNew->szFeature = szFeatureNew;
				pFOMNew->szModule = szModuleNew;

				SkuSet *pSkuSetNew = new SkuSet(g_cSkus);
				assert(pSkuSetNew);
				*pSkuSetNew = *(pSkuSetValTemp->pSkuSet);

				IntStringValue isValNew;
				isValNew.pFOM = pFOMNew;
				hr = m_rgpSkuSetValuesOwnership[i]->SplitInsert(pSkuSetNew,
																isValNew, 
															UpdateOwnership);
				if (FAILED(hr)) break;
			}
		}

		if (FAILED(hr)) break;
	}

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in Function: Component::SetOwnership\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// GetOwnership: given a NodeIndex specifying the type of ownership
//				 the function returns the ownership info of the specified
//				 SKUs via ppSkuSetValues
////////////////////////////////////////////////////////////////////////////
HRESULT
Component::GetOwnership(NodeIndex ni, SkuSet *pSkuSet,
						SkuSetValues **ppSkuSetValuesRetVal)
{
	assert(pSkuSet);
	if (pSkuSet->testClear())
		return S_FALSE;

	HRESULT hr = S_OK;

	// the index starts from OWNSHORTCUTS
	int iIndex = (int)ni - (int)OWNSHORTCUTS;

	hr = m_rgpSkuSetValuesOwnership[iIndex]->GetValueSkuSet(pSkuSet, 
													ppSkuSetValuesRetVal);

	// error: some SKUs don't have this ownership specified 
	if (FAILED(hr))
	{
		_tprintf(TEXT("don't have the ownership information for %s specified\n"),
				 rgXMSINodes[ni].szNodeName);
	}

	return hr;
}

// KeyPath cannot/shouldn't be updated. If this function is called, 
// there are more than one entities that are claiming to be KeyPath of 
// a Component in a SKU. Return E_FAIL to signal the error. 
HRESULT UpdateKeyPath(IntStringValue *pIsValOut, IntStringValue isValOld, 
						 IntStringValue isValNew)
{
	_tprintf(TEXT("Compile Error: multiple KeyPath specified \n"));
	return E_FAIL;
}


////////////////////////////////////////////////////////////////////////////
// SetKeyPath: set the KeyPath information for this component for the specified
//			   SKUs. 
////////////////////////////////////////////////////////////////////////////
HRESULT
Component::SetKeyPath(LPTSTR szKeyPath, SkuSet *pSkuSet)
{
	assert(pSkuSet);
	HRESULT hr = S_OK;
	if (pSkuSet->testClear())
		return S_FALSE;

	// make a copy of arguments
	SkuSet *pSkuSetNew = new SkuSet(g_cSkus);
	assert(pSkuSetNew);
	*pSkuSetNew = *pSkuSet;

	LPTSTR sz = _tcsdup(szKeyPath);
	assert(sz);

	IntStringValue isValNew;
	isValNew.szVal = sz;

	// update the list that is holding the KeyPath
	hr = m_pSkuSetValuesKeyPath->SplitInsert(pSkuSetNew, isValNew, 
											 UpdateKeyPath);

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// GetKeyPath: Retrieve the KeyPath information for this component for
//			   the specified SKUs.
////////////////////////////////////////////////////////////////////////////
HRESULT 
Component::GetKeyPath(SkuSet *pSkuSet, SkuSetValues **ppSkuSetValuesRetVal)
{ 
	assert(pSkuSet);
	if (pSkuSet->testClear())
		return S_FALSE;

	HRESULT hr = S_OK;

	hr = m_pSkuSetValuesKeyPath->GetValueSkuSet(pSkuSet, ppSkuSetValuesRetVal);

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Print: for debug purpose, print out the content (Features that use this
//		  Component; KeyPath; Ownership info) of this Component
////////////////////////////////////////////////////////////////////////////
void
Component::Print()
{
	_tprintf(TEXT("SkuSets:\n"));
	if (m_pSkuSet)
		m_pSkuSet->print();

	_tprintf(TEXT("Used by Feature:\n"));
	if (m_pSkuSetValuesFeatureUse)
		m_pSkuSetValuesFeatureUse->Print();

	_tprintf(TEXT("KeyPath: \n"));
	if (m_pSkuSetValuesKeyPath)
		m_pSkuSetValuesKeyPath->Print();

	for (int i=0; i<5; i++)
	{
		NodeIndex ni = (NodeIndex)(i+OWNSHORTCUTS);
		_tprintf(TEXT("%s\n"), rgXMSINodes[ni].szNodeName);
		if(m_rgpSkuSetValuesOwnership[i])
			m_rgpSkuSetValuesOwnership[i]->Print();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\commandopt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       CommandOpt.h
//
//    This file contains the implementation of CommandOpt class 
//--------------------------------------------------------------------------

#include "CommandOpt.h"

void
CommandOpt::PrintUsage()
{
	/* Issue: format */
    _ftprintf(stderr, 
		TEXT("Usage: wmi <options> -i WIML_File SKU_Filter \n"));
    _ftprintf(stderr, 
		TEXT("Converts a setup package written in WIML to MSI packages\n"));
    _ftprintf(stderr, 
		TEXT("Options are:\n"));
    _ftprintf(stderr, 
		TEXT("\t-c           Validation only\n"));
    _ftprintf(stderr, 
		TEXT("\t-v           Verbose mode\n"));
    _ftprintf(stderr, 
		TEXT("\t-l Log_File  Output written into specified file\n"));
    _ftprintf(stderr, 
		TEXT("\n"));
}

UINT
CommandOpt::ParseCommandOptions(int argc, TCHAR *argv[])
{
	int i;

	if (1 == argc)
	{
		PrintUsage();
		return ERROR_BAD_ARGUMENTS;
	}

    for (i = 1; i < argc; i++)
    {
        LPTSTR arg = argv[i];
        if (arg[0] == TEXT('-'))
        {
            switch (arg[1])
            {
            case 'c': 
			case 'C'://Issue: 
                m_bValidation = true;
#ifdef DEBUG
				_tprintf(TEXT("Validation Only\n"));
#endif
                break;
            case 'v':
			case 'V':
                m_bVerbose = true;
#ifdef DEBUG
				_tprintf(TEXT("Verbose mode\n"));
#endif
                break;
            case 'l':
			case 'L':
                if ( (m_pLogFile = _tfopen(argv[++i], TEXT("a"))) == NULL)
				{
					_tprintf(
						TEXT("Error: Unable to open specified log file: %s"), 
									argv[i]);
					return ERROR_FILE_NOT_FOUND;
				}
#ifdef DEBUG
				_tprintf(TEXT("Log file name: %s\n"), argv[i]);
#endif
                break;
            case 'i':
			case 'I':
                 m_szURL= argv[++i];
#ifdef DEBUG
				_tprintf(TEXT("WIML file name: %s\n"), argv[i]);
#endif
                break;
			default:
				_tprintf(TEXT("Error: unrecognized option -%c\n"), arg[1]);
				PrintUsage();
				return ERROR_BAD_ARGUMENTS;
            }
        }
		// This is a command-line SKU filter.
        else 
        {
			if (m_szInputSkuFilter != NULL)
			{
				_tprintf(TEXT("Error: only one Sku Filter is allowed\n"));
				return ERROR_BAD_ARGUMENTS;
			}
			m_szInputSkuFilter = arg;

#ifdef DEBUG
			_tprintf(TEXT("SKU filter from command line: %s\n"), 
								m_szInputSkuFilter);
#endif			
        }
    }

	if (NULL == m_szURL) 
	{
		_tprintf(
			TEXT("Error: Please specify the URL of the input package\n"));
		return ERROR_BAD_ARGUMENTS;
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\component.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:     Component.h
// 
//    This file contains the definition of Class Component
//--------------------------------------------------------------------------


#ifndef XMSI_COMPONENT_H
#define XMSI_COMPONENT_H

#include <Windows.h>
#include <tchar.h>
#include <stdio.h>
#include "wmc.h"

using namespace std;

struct Cstring_less {
	 bool operator()(LPCTSTR p, LPCTSTR q) const { return _tcscmp(p, q)<0; }
};

class Component {
public:
	Component():m_setFeaturesUse(), m_szKeyPath(NULL){}

	~Component();
	
	bool UsedByFeature(LPTSTR szFeatureID);

	void SetUsedByFeature(LPTSTR szFeatureID);

	// member access functions
	LPTSTR GetKeyPath() {return m_szKeyPath;}
	void SetKeyPath(LPTSTR szKeyPath);

private:
	// store the ID of all the <Feature>s that use this component
	set<LPTSTR, Cstring_less> m_setFeaturesUse; 
	LPTSTR m_szKeyPath;
};

#endif //XMSI_COMMANDOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\componentfuncs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       componentFuncs.h
//              
//				The part of the program that deals with <Component> and
//              its subentities in the input XML file
//--------------------------------------------------------------------------

#ifndef XMSI_COMPONENTFUNCS_H
#define XMSI_COMPONENTFUNCS_H

#include "wmc.h"
#include "utilities.h"

HRESULT ProcessComponents();
	HRESULT ProcessComponent(PIXMLDOMNode &pNodeComponent, LPTSTR szComponent,
							 SkuSet *pSkuSet);
		HRESULT ProcessGUID(PIXMLDOMNode &pNode, int iColumn,  
							ElementEntry *pEE, SkuSet *pSkuSet);
		HRESULT ProcessComponentDir(PIXMLDOMNode &pNodeComponentDir, 
									int iColumn, ElementEntry *pEE, 
									SkuSet *pSkuSet);
		HRESULT ProcessComponentAttributes(PIXMLDOMNode &pNodeComponentAttributes,
										   int iColumn,  ElementEntry *pEE,
										   SkuSet *pSkuSet);
		HRESULT ProcessCreateFolder(PIXMLDOMNode &pNodeCreateFolder,
							IntStringValue isVal, SkuSet *pSkuSet);
			HRESULT ProcessLockPermission(PIXMLDOMNode &pNodeLockPermission,
										  IntStringValue isValLockPermission, 
										  SkuSet *pSkuSet);
		HRESULT ProcessFile(PIXMLDOMNode &pNodeFile, IntStringValue isValComponent,
							SkuSet *pSkuSet);
			HRESULT ProcessFileName(PIXMLDOMNode &pNode, int iColumn,  
									ElementEntry *pEE, SkuSet *pSkuSet);
			HRESULT ProcessFileVersion(PIXMLDOMNode &pNode, int iColumn,  
									   ElementEntry *pEE, SkuSet *pSkuSet);
			HRESULT ProcessFileAttributes(PIXMLDOMNode &pNode, int iColumn,  
										  ElementEntry *pEE, SkuSet *pSkuSet);
			/* ProcessFBS processes <Font> <BindImage> <SelfReg> */
			HRESULT ProcessFBS(PIXMLDOMNode &pNode, int iColumn,  
								ElementEntry *pEE, SkuSet *pSkuSet);
		HRESULT ProcessMoveFile(PIXMLDOMNode &pNodeFile, 
								IntStringValue isValComponent, SkuSet *pSkuSet);
			HRESULT ProcessCopyFile(PIXMLDOMNode &pNode, int iColumn,  
									ElementEntry *pEE, SkuSet *pSkuSet);
		HRESULT ProcessRemoveFile(PIXMLDOMNode &pNodeRemoveFile, 
								IntStringValue isValComponent, SkuSet *pSkuSet);
			HRESULT ProcessInstallMode(PIXMLDOMNode &pNode, int iColumn,
									ElementEntry *pEE, SkuSet *pSkuSet);	
		HRESULT ProcessIniFile(PIXMLDOMNode &pNodeIniFile, 
			  				   IntStringValue isValComponent, SkuSet *pSkuSet);
			HRESULT ProcessAction(PIXMLDOMNode &pNodeAction, int iColumn,
							      ElementEntry *pEE, SkuSet *pSkuSet);
		HRESULT ProcessRemoveIniFile(PIXMLDOMNode &pNodeRemoveIniFile, 
									 IntStringValue isValComponent, 
									 SkuSet *pSkuSet);
			HRESULT ProcessValue(PIXMLDOMNode &pNodeValue, int iColumn,  
								 ElementEntry *pEE, SkuSet *pSkuSet);
		HRESULT ProcessRegistry(PIXMLDOMNode &pNodeRegistry, 
								IntStringValue isValComponent, SkuSet *pSkuSet);
			HRESULT ProcessDelete(PIXMLDOMNode &pNodeDelete, 
								  IntStringValue isValCRK, SkuSet *pSkuSet);
			HRESULT ProcessCreate(PIXMLDOMNode &pNodeCreate, 
								  IntStringValue isValCRK, SkuSet *pSkuSet);

///////////////////////////////////////////////////////////////////////////
// <Component>
Node_Func_H_XIES rgNodeFuncs_Component[] = {
//	 NodeIndex			ProcessFunc				  ValueType	  column #	
{	XMSI_GUID,			ProcessGUID,				STRING,		1		},
{	COMPONENTDIR,		ProcessComponentDir,		STRING,		2		},
{	COMPONENTATTRIBUTES,ProcessComponentAttributes,	INTEGER,	3		},
{	CONDITION,			ProcessSimpleElement,		STRING,		4		},
{	PLACEHOLDER,		NULL/* */,					STRING,		5		}
};

const int cNodeFuncs_Component = 
			sizeof(rgNodeFuncs_Component)/sizeof(Node_Func_H_XIES);

EnumBit rgEnumBits_RunFrom_Component[] = {
{	TEXT("Local"),				0										 },
{	TEXT("Source"),			msidbComponentAttributesSourceOnly			 },
{	TEXT("Both"),			msidbComponentAttributesOptional			 },
};

const int cEnumBits_RunFrom_Component = 
			sizeof(rgEnumBits_RunFrom_Component)/sizeof(EnumBit);


AttrBit_SKU rgAttrBits_Component[] = {
{SHAREDDLLREFCOUNT,			msidbComponentAttributesSharedDllRefCount	},
{PERMANENT,					msidbComponentAttributesPermanent			},
{TRANSITIVE,				msidbComponentAttributesTransitive			},
{NEVEROVERWRITE,			msidbComponentAttributesNeverOverwrite		}
};

const int cAttrBits_Component = 
			sizeof(rgAttrBits_Component)/sizeof(AttrBit_SKU);
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// <File>
Node_Func_H_XIES rgNodeFuncs_File[] = {
//	 NodeIndex			ProcessFunc				ValueType	column #	
{	FILENAME,		ProcessFileName,			STRING,			1	},
{	FILESIZE,		ProcessSimpleElement,		INTEGER,		2	},
{	FILEVERSION,	ProcessFileVersion,			STRING,			3	},
{	FILELANGUAGE,	ProcessSimpleElement,		STRING,			4	},
{	FILEATTRIBUTES,	ProcessFileAttributes,		INTEGER,		5	},
{	FONT,			ProcessFBS,					STRING,			6	},
{	BINDIMAGE,		ProcessFBS,					STRING,			7	},
{	SELFREG,		ProcessFBS,					INTEGER,		8	}
};

const int cNodeFuncs_File =
			 sizeof(rgNodeFuncs_File)/sizeof(Node_Func_H_XIES);

EnumBit rgEnumBits_Compressed_File[] = {
{	TEXT("Default"),		0											 },
{	TEXT("No"),				msidbFileAttributesNoncompressed			 },
{	TEXT("Yes"),			msidbFileAttributesCompressed				 },
};

const int cEnumBits_Compressed_File = 
			sizeof(rgEnumBits_Compressed_File)/sizeof(EnumBit);

AttrBit_SKU rgAttrBits_File[] = {
	{READONLY,			msidbFileAttributesReadOnly			},
	{HIDDEN,			msidbFileAttributesHidden			},
	{SYSTEM,			msidbFileAttributesSystem			},
	{VITAL,				msidbFileAttributesVital			},
	{CHECKSUM,			msidbFileAttributesChecksum			}
};
const int cAttrBits_File = sizeof(rgAttrBits_File)/sizeof(AttrBit_SKU);
//////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// <MoveFile>
Node_Func_H_XIES rgNodeFuncs_MoveFile[] = {
//	 NodeIndex			ProcessFunc				ValueType	column #	
{	SOURCENAME,		ProcessSimpleElement,		STRING,			1	},
{	DESTNAME,		ProcessSimpleElement,		STRING,			2	},
{	SOURCEFOLDER,	ProcessSimpleElement,		STRING,			3	},
{	DESTFOLDER,		ProcessSimpleElement,		STRING,			4	},
{	COPYFILE,		ProcessCopyFile,			INTEGER,		5	}
};

const int cNodeFuncs_MoveFile =
			 sizeof(rgNodeFuncs_MoveFile)/sizeof(Node_Func_H_XIES);
//////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// <RemoveFile>
Node_Func_H_XIES rgNodeFuncs_RemoveFile[] = {
//	 NodeIndex				ProcessFunc				ValueType	column #	
{	FNAME_REMOVEFILE,		ProcessSimpleElement,		STRING,			1	},
{	DIRPROPERTY_INIFILE,	ProcessSimpleElement,		STRING,			2	},
{	XMSI_INSTALLMODE,		ProcessInstallMode,			INTEGER,		3	}
};

const int cNodeFuncs_RemoveFile =
			 sizeof(rgNodeFuncs_RemoveFile)/sizeof(Node_Func_H_XIES);
//////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// <IniFile>
Node_Func_H_XIES rgNodeFuncs_IniFile[] = {
//	NodeIndex				ProcessFunc				ValueType	column #	
{	FNAME_INIFILE,			ProcessSimpleElement,	STRING,			1	},
{	DIRPROPERTY_INIFILE,	ProcessSimpleElement,	STRING,			2	},
{	SECTION,				ProcessSimpleElement,	STRING,			3	},
{	KEY,					ProcessSimpleElement,	STRING,			4	},
{	VALUE_INIFILE,			ProcessSimpleElement,	STRING,			5	},
{	ACTION,					ProcessAction,			INTEGER,		6	}
};

const int cNodeFuncs_IniFile =
			 sizeof(rgNodeFuncs_IniFile)/sizeof(Node_Func_H_XIES);
//////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// <RemoveIniFile>
Node_Func_H_XIES rgNodeFuncs_RemoveIniFile[] = {
//	NodeIndex					ProcessFunc				ValueType	column #	
{	FNAME_REMOVEINIFILE,		ProcessSimpleElement,	STRING,			1	},
{	DIRPROPERTY_REMOVEINIFILE,	ProcessSimpleElement,	STRING,			2	},
{	SECTION,					ProcessSimpleElement,	STRING,			3	},
{	KEY,						ProcessSimpleElement,	STRING,			4	},
/* Note: because it is inside ProcessValue that the value of Action column 
   is Set. So the following process order has to be enforced */
{	ACTION_REMOVEINIFILE,		NULL,					INTEGER,		5	},
{	VALUE_REMOVEINIFILE,		ProcessValue,			STRING,			6	},
};

const int cNodeFuncs_RemoveIniFile =
			 sizeof(rgNodeFuncs_RemoveIniFile)/sizeof(Node_Func_H_XIES);
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Globals

// Key: File ID		Value: the set of SKUs that can reference this File ID
map<LPTSTR, SkuSet *, Cstring_less> g_mapFiles;
//////////////////////////////////////////////////////////////////////////

#endif //XMSI_COMPONENTFUNCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msitools\xmsi\componentfuncs.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       componentFuncs.cpp
//              This file contains the functions that process <Component>
//              and its subentities in the input package
//--------------------------------------------------------------------------

#include "componentFuncs.h"

////////////////////////////////////////////////////////////////////////////
// ProcessComponents:
//   This function is the root of the sub function tree corresponding to 
//	 process <Component> part. When this function is called from 
//   ProcessProductFamily, a list of component objects has been established,
//	 Starting from here, those components are processed one by one.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessComponents()
{
	HRESULT hr = S_OK;
	
	map<LPTSTR, Component *, Cstring_less>::iterator iter;

	// process the Component objects stored one by one
	for (iter = g_mapComponents.begin(); iter != g_mapComponents.end(); iter++)
	{
		LPTSTR szComponent = (*iter).first;

		// Process the set of Features that use this Component and insert
		// into FeatureComponents table
		SkuSetValues *pSkuSetValuesFeatures = NULL;
		Component *pComponent = (*iter).second;
		pSkuSetValuesFeatures = pComponent->GetFeatureUse();
		if (!pSkuSetValuesFeatures->Empty())
		{
			SkuSetVal *pSkuSetVal = NULL;
			for (pSkuSetVal = pSkuSetValuesFeatures->Start();
				 pSkuSetVal != pSkuSetValuesFeatures->End();
				 pSkuSetVal = pSkuSetValuesFeatures->Next())
			{
				SkuSet *pSkuSet = pSkuSetVal->pSkuSet;
				// create FeatureComponents table
				hr = CreateTable_SKU(TEXT("FeatureComponents"), pSkuSet);
				if (FAILED(hr)) break;
				// insert all the Features stored into DB
				set<LPTSTR, Cstring_less> *pSet = 
								(pSkuSetVal->isVal.pSetString);
				set<LPTSTR, Cstring_less>::iterator it;
				for (it = pSet->begin(); it != pSet->end(); it++)
				{
					LPTSTR szFeature = (*it);
					hr = InsertFeatureComponents(szFeature, szComponent,
												 pSkuSet, -1);
					if (FAILED(hr)) break;
				}
				if (FAILED(hr)) break;
			}
			if (FAILED(hr)) break;
		}

		// Call ProcessComponent to process all the subentities of 
		// this Component
		SkuSet *pSkuSet = pComponent->GetSkuSet();
		PIXMLDOMNode pNodeComponent = pComponent->m_pNodeComponent;
		hr = ProcessComponent(pNodeComponent, szComponent, pSkuSet);
		delete pSkuSet;
		if (FAILED(hr)) break;
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessComponents\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessComponent
//   This function process <Component> entity
//         1) insert into <FeatureComponents> table
//         2) Process all the subentities include <Files>
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessComponent(PIXMLDOMNode &pNodeComponent, LPTSTR szComponent, 
						 SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeComponent != NULL);

	SkuSetValues *pSkuSetValuesKeyPath = NULL;
	SkuSet skuSetCommon(g_cSkus); // the SkuSet that shars the common column 
								  // values

	// Values to be inserted into the DB 
	LPTSTR szComponentId = NULL;
	LPTSTR szDirectory_ = NULL;
	int iAttributes = MSI_NULL_INTEGER;
	LPTSTR szCondition = NULL;
	LPTSTR szKeyPath = NULL;

	// Construct an ElementEntry object. 
	ElementEntry *pEEComponent = new ElementEntry(5, pSkuSet);
	assert(pEEComponent);

	// send the Component ID down to children nodes
	IntStringValue isValInfo;
	isValInfo.szVal = szComponent;
	pEEComponent->m_isValInfo = isValInfo;

	hr = CreateTable_SKU(TEXT("Component"), pSkuSet);

	if (SUCCEEDED(hr))
	{
		// Call ProcessChildrenArray to get back column values of all SKUs 
		// via the ElementEntry object
		hr = ProcessChildrenArray_H_XIES(pNodeComponent, rgNodeFuncs_Component,
										 cNodeFuncs_Component, pEEComponent, 
										 pSkuSet);
	}

	// Process <CreateFolder>s
	// Issue: need to check for duplicate primary key <Dir, Com>
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, CREATEFOLDER, false,
									 isValInfo, ProcessCreateFolder, pSkuSet);

	// Process <File>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, XMSI_FILE,
									 false, isValInfo,
									 ProcessFile,
									 pSkuSet);

	// Process <MoveFile>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, MOVEFILE,
									 false, isValInfo,
									 ProcessMoveFile,
									 pSkuSet);

	// Process <RemoveFile>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, REMOVEFILE,
									 false, isValInfo,
									 ProcessRemoveFile,
									 pSkuSet);

	// Process <IniFile>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, INIFILE,
									 false, isValInfo,
									 ProcessIniFile,
									 pSkuSet);

	// Process <RemoveIniFile>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, REMOVEINIFILE,
									 false, isValInfo,
									 ProcessRemoveIniFile,
									 pSkuSet);

	// Process <Registry>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, XMSI_REGISTRY,
									 false, isValInfo,
									 ProcessRegistry,
									 pSkuSet);

	// Get KeyPath information
	if (SUCCEEDED(hr))
	{
		hr = g_mapComponents[szComponent]->GetKeyPath(pSkuSet, 
													  &pSkuSetValuesKeyPath);
		if (SUCCEEDED(hr))
		{
			hr = pEEComponent->SetValueSkuSetValues(pSkuSetValuesKeyPath, 5);
			if (pSkuSetValuesKeyPath)
				delete pSkuSetValuesKeyPath;
		}
		else
			_tprintf(TEXT(" don't have a KeyPath specified for Component %s\n"),
					 szComponent);
	}


	// Finalize the values stored in *pEE
	if (SUCCEEDED(hr))
		hr = pEEComponent->Finalize();

	// insert the values into the DB
	if (SUCCEEDED(hr))
	{
		// Process Common values first
		skuSetCommon = pEEComponent->GetCommonSkuSet();

		printf("Common Set:");
		skuSetCommon.print();

		if (!skuSetCommon.testClear())
		{
			szComponentId = pEEComponent->GetCommonValue(1).szVal;
			szDirectory_  = pEEComponent->GetCommonValue(2).szVal;
			iAttributes   = pEEComponent->GetCommonValue(3).intVal;
			szCondition   = pEEComponent->GetCommonValue(4).szVal;
			szKeyPath     = pEEComponent->GetCommonValue(5).szVal;

			// insert into DB
			hr = InsertComponent(szComponent, szComponentId, szDirectory_,
								 iAttributes, szCondition, szKeyPath,
								 &skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szComponentId = pEEComponent->GetValue(1,i).szVal;
					szDirectory_ = pEEComponent->GetValue(2,i).szVal;
					iAttributes = pEEComponent->GetValue(3,i).intVal;
					szCondition = pEEComponent->GetValue(4,i).szVal;
					szKeyPath = pEEComponent->GetValue(5,i).szVal;
			
					// insert into DB
					hr = InsertComponent(szComponent, szComponentId, 
										 szDirectory_, iAttributes, 
										 szCondition, szKeyPath, NULL, i);
				}
			}
		}
	}

	delete pEEComponent;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessComponent\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessGUID
//   This function:
//         1) Process <GUID> entity and put the value inside *pEE
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessGUID(PIXMLDOMNode &pNodeGUID, int iColumn, 
					ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeGUID != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeGUID)));
#endif

	// Get the value of the element.
	IntStringValue isValGUID;

	if (SUCCEEDED(hr = ProcessAttribute(pNodeGUID, 
										rgXMSINodes[XMSI_GUID].szAttributeName,
										STRING, &isValGUID, pSkuSet)))
	{
		if (NULL == isValGUID.szVal)
		{
			_tprintf(TEXT("Compile Error: Missing required attribute")
					 TEXT("\'%s\' of <%s>\n"), 
					 rgXMSINodes[XMSI_GUID].szAttributeName,
					 rgXMSINodes[XMSI_GUID].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			// Convert to all uppercase and add { }
			hr = FormatGUID(isValGUID.szVal);

			// insert the value into the ElementEntry.
			if (SUCCEEDED(hr))
				hr = pEE->SetValue(isValGUID, iColumn, pSkuSet);
		}
	}

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessGUID\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessComponentDir
//   This function:
//         1) Process <ComponentDir> entity and return its value via szVal
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessComponentDir(PIXMLDOMNode &pNodeComponentDir, int iColumn,  
							ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	int i = 0;

	assert(pNodeComponentDir != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeComponentDir)));
#endif

	LPTSTR szComponent = pEE->m_isValInfo.szVal;

	// Process Ref attribute
	hr = ProcessRefElement(pNodeComponentDir, iColumn, pEE, pSkuSet);

	// Process KeyPath attribute
	if (SUCCEEDED(hr))
		hr = ProcessKeyPath(pNodeComponentDir, szComponent, TEXT(""), 
							pSkuSet);

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessComponentDir\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: Process
// This function processes <ComponentAttributes> entity under <Component> 
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessComponentAttributes(PIXMLDOMNode &pNodeComponentAttributes, 
								   int iColumn, ElementEntry *pEE, 
								   SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeComponentAttributes != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeComponentAttributes)));
#endif

	// Process <RunFrom> child
	hr = ProcessEnumAttributes(pNodeComponentAttributes, FAVOR, 
							   rgEnumBits_RunFrom_Component,
							   cEnumBits_RunFrom_Component, pEE, iColumn, 
							   pSkuSet);

	// Process all on/off children elements
	if (SUCCEEDED(hr))
		hr = ProcessOnOffAttributes_SKU(pNodeComponentAttributes, 
										rgAttrBits_Component,
										cAttrBits_Component, pEE, iColumn,
										pSkuSet);
#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessComponentAttributes\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessCreateFolder
//   This function:
//         1) Process <CreateFolder> entity and insert the info into 
//			  the CreateFolder table
//		   2) Process children <LockPermission>s
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessCreateFolder(PIXMLDOMNode &pNodeCreateFolder,
							IntStringValue isVal, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeCreateFolder!=NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeCreateFolder)));
#endif
	
	LPTSTR szComponent = isVal.szVal;

	// create the CreateFolder table if necessary
	hr = CreateTable_SKU(TEXT("CreateFolder"), pSkuSet);

	if (FAILED(hr)) return hr;
	
	// get the Ref attribute 
	IntStringValue isValCreateFolder;
	isValCreateFolder.szVal = NULL;
	if (SUCCEEDED(hr = ProcessAttribute(pNodeCreateFolder,
							  		    rgXMSINodes[CREATEFOLDER].szAttributeName,
										STRING, &isValCreateFolder, pSkuSet)))
	{
		if (NULL == isValCreateFolder.szVal)
		{
			_tprintf(TEXT("Compile Error: Missing required attribute")
					 TEXT("\'%s\' of <%s>\n"), 
					 rgXMSINodes[CREATEFOLDER].szAttributeName,
					 rgXMSINodes[CREATEFOLDER].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			SkuSetValues *pSkuSetValuesRetVal = NULL;
			LPTSTR szRef = isValCreateFolder.szVal;

			// The dir referred should be in the data structure already
			assert(0 != g_mapDirectoryRefs_SKU.count(szRef));

			// return a list of <SkuSet, Directory> pairs
			hr = g_mapDirectoryRefs_SKU[szRef]->
								GetValueSkuSet(pSkuSet, &pSkuSetValuesRetVal);

			if (SUCCEEDED(hr))
			{
				// go over the list returned, get Directory value for each sub
				// SkuSets and insert into DB
				SkuSetVal *pSkuSetVal = NULL;
				for (pSkuSetVal = pSkuSetValuesRetVal->Start(); 
					 pSkuSetVal != pSkuSetValuesRetVal->End(); 
					 pSkuSetVal = pSkuSetValuesRetVal->Next())
				
				{
					LPTSTR szDir = pSkuSetVal->isVal.szVal;
					SkuSet *pSkuSetTemp = pSkuSetVal->pSkuSet;

					if (FAILED(hr = InsertCreateFolder(szDir, szComponent, 
													   pSkuSetTemp, -1)))
						break;
									
					// Process children <LockPermission>s
					// Issue: need to ensure there is no duplicate primary key
					//		  LockOjbect + Table + Domain + User
					IntStringValue isValLockPermission;
					TableLockObj *pTableLockObjTemp = new TableLockObj;
					pTableLockObjTemp->szLockObject = szDir;
					pTableLockObjTemp->szTable = TEXT("CreateFolder");
					isValLockPermission.pTableLockObj = pTableLockObjTemp;
					if (FAILED(hr = ProcessChildrenList_SKU(pNodeCreateFolder, 
															LOCKPERMISSION, 
															false,
															isValLockPermission, 
															ProcessLockPermission, 
															pSkuSetTemp)))
						break;

					delete pTableLockObjTemp;
				}

				if (pSkuSetValuesRetVal)
					delete pSkuSetValuesRetVal;

			}

			delete[] isValCreateFolder.szVal;
		}	
	}	



#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessCreateFolder\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessLockPermission
//   This function:
//         1) Process <LockPermission> node and insert into LockPermissions
//			  table;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessLockPermission(PIXMLDOMNode &pNodeLockPermission,
							IntStringValue isValLockPermission, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeLockPermission!=NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeLockPermission)));
#endif
	
	LPTSTR szLockObject = isValLockPermission.pTableLockObj->szLockObject;
	LPTSTR szTable = isValLockPermission.pTableLockObj->szTable;
	LPTSTR szUser = NULL;
	LPTSTR szDomain = NULL;
	int iPermission = MSI_NULL_INTEGER;

	// create the CreateFolder table if necessary
	if (FAILED(hr = CreateTable_SKU(TEXT("LockPermissions"), pSkuSet)))
		return hr;
	
	IntStringValue isValUser;
	isValUser.szVal = NULL;

	// get the User attribute (Required)
	if (SUCCEEDED(hr = ProcessAttribute(pNodeLockPermission,
							  		    TEXT("User"),
										STRING, &isValUser, pSkuSet)))
	{
		if (NULL == isValUser.szVal)
		{
			_tprintf(TEXT("Compile Error: Missing required attribute")
					 TEXT("\'%s\' of <%s>\n"), 
					 TEXT("User"),
					 rgXMSINodes[CREATEFOLDER].szNodeName);
			hr = E_FAIL;
		}
		else
			szUser = isValUser.szVal;
	}

	// get the Domain Attribute (Not Required)
	if (SUCCEEDED(hr))
	{
		IntStringValue isValDomain;
		isValDomain.szVal = NULL;
		hr = ProcessAttribute(pNodeLockPermission,TEXT("Domain"), STRING, 
						  &isValDomain, pSkuSet);
		szDomain = isValDomain.szVal;
	}

	// get the Permission attribute (Required)
	if (SUCCEEDED(hr))
	{
		IntStringValue isValPermission;
		isValPermission.szVal = NULL;
		if (SUCCEEDED(hr = ProcessAttribute(pNodeLockPermission, 
											TEXT("Permission"),
											INTEGER,
											&isValPermission, pSkuSet)))
		{
			if (MSI_NULL_INTEGER == isValPermission.intVal)
			{
				_tprintf(TEXT("Compile Error: Missing required attribute")
						 TEXT("\'%s\' of <%s>\n"), 
						 TEXT("Permission"),
						 rgXMSINodes[CREATEFOLDER].szNodeName);
				hr = E_FAIL;
			}
			else
				iPermission = isValPermission.intVal;
		}
	}

	// insert into the DB LockPermissions table
	if (SUCCEEDED(hr))
		hr = InsertLockPermissions(szLockObject, szTable, szDomain, szUser, 
								   iPermission, pSkuSet, -1);
#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessCreateFolder\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFile
//   This function:
//         1) Process all subentities of <File> include <FileName>, <FileSize>
//            <FileVersion>, <FileLanguage>, <FileAttributes>, <Font>,
//			  <BindImage>, <SelfReg>;
//         2) Insert into the File table;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFile(PIXMLDOMNode &pNodeFile, IntStringValue isValComponent,
					SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeFile != NULL);

	SkuSet skuSetCommon(g_cSkus); // the SkuSet that shars the common column 
								  // values

	// Values to be inserted into the DB 
	LPTSTR szFile		= NULL;
	LPTSTR szComponent  = isValComponent.szVal;
	LPTSTR szFileName   = NULL;
	UINT   uiFileSize   = NULL;
	LPTSTR szVersion    = NULL;
	LPTSTR szLanguage   = NULL;
	UINT   uiAttributes = MSI_NULL_INTEGER;

	// create the File DB table
	hr = CreateTable_SKU(TEXT("File"), pSkuSet);

	if (FAILED(hr))	return hr;

	// Construct an ElementEntry object. 
	ElementEntry *pEEFile = new ElementEntry(8, pSkuSet);
	assert(pEEFile);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeFile, TEXT("ID"), STRING, &isValID, pSkuSet);

	// if there is no ID specified, compiler generates one
	if (SUCCEEDED(hr))
	{
		if (!isValID.szVal)
		{
			isValID.szVal = GetName(TEXT("File"));
#ifdef DEBUG
			_tprintf(TEXT("Processing <File> with compiler generated ")
					 TEXT("primary key = %s\n"), isValID.szVal);
#endif
		}
		else
		{
#ifdef DEBUG
			_tprintf(TEXT("Processing <File ID=\"%s\">\n"), isValID.szVal);
#else
		;
#endif
		}
	}

	// at this point, a primary key should exist for this file
	szFile = isValID.szVal;
	assert(szFile);
	IntStringValue isValInfo;
	isValInfo.szVal = szFile;
	pEEFile->m_isValInfo = isValInfo;

	// insert the FileID - SkuSet relationship into the global data structure
	// so that the compiler can check whether a FileID reference is allowed
	// for any given SKU
	if (!g_mapFiles.count(szFile))
	{
		LPTSTR szFile_Map = _tcsdup(szFile);
		assert(szFile_Map);
		SkuSet *pSkuSet_Map = new SkuSet(g_cSkus);
		assert(pSkuSet_Map);
		*pSkuSet_Map = *pSkuSet;
		g_mapFiles.insert(LS_ValType(szFile_Map, pSkuSet_Map));
	}

	// Process KeyPath attribute
	if (SUCCEEDED(hr))
		hr = ProcessKeyPath(pNodeFile, szComponent, szFile, pSkuSet);


	// Call ProcessChildrenArray to get back column values of all SKUs 
	// via the ElementEntry object
	if (SUCCEEDED(hr))
		hr = ProcessChildrenArray_H_XIES(pNodeFile, rgNodeFuncs_File,
										 cNodeFuncs_File, pEEFile, 
										 pSkuSet);

	// Process children <LockPermission>s
	// Issue: need to ensure there is no duplicate primary key
	//		  LockOjbect + Table + Domain + User
	if (SUCCEEDED(hr))
	{
		IntStringValue isValLockPermission;
		TableLockObj *pTableLockObjTemp = new TableLockObj;
		pTableLockObjTemp->szLockObject = szFile;
		pTableLockObjTemp->szTable = TEXT("CreateFolder");
		isValLockPermission.pTableLockObj = pTableLockObjTemp;
		hr = ProcessChildrenList_SKU(pNodeFile, LOCKPERMISSION,
									false, isValLockPermission, 
									ProcessLockPermission, pSkuSet);
		delete pTableLockObjTemp;
	}
	
	// Finalize the values stored in *pEE
	if (SUCCEEDED(hr))
		hr = pEEFile->Finalize();

	if (SUCCEEDED(hr))
	{
		// Process Common values first
		skuSetCommon = pEEFile->GetCommonSkuSet();

		if (!skuSetCommon.testClear())
		{
			szFileName	 = pEEFile->GetCommonValue(1).szVal;
			uiFileSize	 = pEEFile->GetCommonValue(2).intVal;
			szVersion	 = pEEFile->GetCommonValue(3).szVal;
			szLanguage	 = pEEFile->GetCommonValue(4).szVal;
			uiAttributes = pEEFile->GetCommonValue(5).intVal;

			// insert into DB
			hr = InsertFile(szFile, szComponent, szFileName, uiFileSize,
							szVersion, szLanguage, uiAttributes,
							/*ISSUE: Sequence */ 1,
							&skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szFileName	 = pEEFile->GetValue(1, i).szVal;
					uiFileSize	 = pEEFile->GetValue(2, i).intVal;
					szVersion	 = pEEFile->GetValue(3, i).szVal;
					szLanguage	 = pEEFile->GetValue(4, i).szVal;
					uiAttributes = pEEFile->GetValue(5, i).intVal;
			
					// insert into DB
					hr = InsertFile(szFile, szComponent, szFileName, 
									uiFileSize, szVersion, szLanguage, 
									uiAttributes, 
									/*ISSUE: Sequence */ 1,
									NULL, i);
				}
			}
		}
	}

	delete pEEFile;

	if (szFile)
		delete[] szFile;


#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessFile\n"));
#endif

	return hr;
}

///////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFileName
//   This function:
//         1) Process <FileName> entity and return its value via szVal
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFileName(PIXMLDOMNode &pNodeFileName, int iColumn,  
						ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeFileName);
	assert(pEE);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeFileName)));
#endif

	// Get the value of FileName. It is either short or short|Long 
	IntStringValue isValFileName;
	hr = ProcessShortLong_SKU(pNodeFileName, &isValFileName, pSkuSet);

	// insert the value into the ElementEntry. 
	if (SUCCEEDED(hr))
		hr = pEE->SetValue(isValFileName, iColumn, pSkuSet);

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessFileName\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFileVersion
//   This function:
//         1) Process <FileVersion> entity and return its value via szVal
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFileVersion(PIXMLDOMNode &pNodeFileVersion, int iColumn, 
						   ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeFileVersion != NULL);
	assert(pEE);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeFileVersion)));
#endif

	IntStringValue isValValue;
	isValValue.szVal = NULL;
	IntStringValue isValSameAs;
	isValSameAs.szVal = NULL;
	HRESULT hrValue = S_OK;
	HRESULT hrSameAs = S_OK;

	hrValue = 
		ProcessAttribute(pNodeFileVersion, TEXT("Value"), STRING, &isValValue, 
						 pSkuSet);
	hrSameAs = 
		ProcessAttribute(pNodeFileVersion, TEXT("SameAs"), STRING, &isValSameAs, 
						 pSkuSet);

	if (SUCCEEDED(hrValue) && SUCCEEDED(hrSameAs))
	{
		// Both Value and SameAs attribute exist - Error
		if ( (S_FALSE != hrValue) && (S_FALSE != hrSameAs) )
		{
			_tprintf(TEXT("Compile Error: Value and SameAs attributes")
					 TEXT("cannot both exist for <FileVersion>\n"));
			hr = E_FAIL;
		}
		else 
		{
			// SameAs is speicified
			if (S_FALSE == hrValue)
			{
				LPTSTR szSameAs = isValSameAs.szVal;
				// check for the FileID reference is valid for this SkuSet
				assert(g_mapFiles.count(szSameAs));
				SkuSet *pSkuSetTemp = g_mapFiles[szSameAs];
				// *pSkuSet should be included in *pSkuSetTemp
				SkuSet skuSetTemp = SkuSetMinus(*pSkuSet, *pSkuSetTemp);
				if (!skuSetTemp.testClear())
				{
					_tprintf(TEXT("Compile Error: File Reference: %s ")
							 TEXT("is not valid in SKU "), szSameAs);
					PrintSkuIDs(&skuSetTemp);
					hr = E_FAIL;
				}
				else
					hr = pEE->SetValue(isValSameAs, iColumn, pSkuSet);
			}
			// Value is speicified
			if (S_FALSE == hrSameAs)
				hr = pEE->SetValue(isValValue, iColumn, pSkuSet);
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessFileVersion\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFileAttributes
//   This function:
//         1) Process <FileAttributes> entity and return its value via iVal
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFileAttributes(PIXMLDOMNode &pNodeFileAttributes, int iColumn,
						   ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	assert(pNodeFileAttributes != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeFileAttributes)));
#endif

	// Process all on/off children elements
	if (SUCCEEDED(hr))
		hr = ProcessOnOffAttributes_SKU(pNodeFileAttributes, 
										rgAttrBits_File,
										cAttrBits_File, pEE, iColumn,
										pSkuSet);
	// Process <Compressed> child
	hr = ProcessEnumAttributes(pNodeFileAttributes, COMPRESSED, 
							   rgEnumBits_Compressed_File,
							   cEnumBits_Compressed_File, pEE, iColumn, 
							   pSkuSet);

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessFileAttributes\n"));
#endif
	return hr;
}
////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFBS
//   This function processes <Font>, <BindImage>, <SelfReg> entity 
//	and insert into Font, BindImage, SelfReg DB tables respectively. It
//  also inserts the value into the ElementEntry object to do the uniqueness
//	validation
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFBS(PIXMLDOMNode &pNodeFBS, int iColumn, ElementEntry *pEE,
				   SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeFBS != NULL);
	assert(pEE);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeFBS)));
#endif

	NodeIndex ni = pEE->GetNodeIndex(iColumn);
	LPTSTR szAttributeName = rgXMSINodes[ni].szAttributeName;
	ValType vt = pEE->GetValType(iColumn);

	IntStringValue isVal;
	LPTSTR szFile = pEE->m_isValInfo.szVal;

	// get the attribute 
	if (SUCCEEDED(hr = ProcessAttribute(pNodeFBS, szAttributeName, 
										vt, &isVal, pSkuSet)))
	{
		// checking for missing required attribute
		if (S_FALSE == hr)
		{
			_tprintf(TEXT("Compile Error: Missing required attribute")
					 TEXT("\'%s\' of <%s>\n"), 
					 rgXMSINodes[ni].szAttributeName,
					 rgXMSINodes[ni].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			if (SUCCEEDED(hr = pEE->SetValue(isVal, iColumn, pSkuSet)))
			{
				// create table and insert into DB
				switch (ni) 
				{
				case FONT:
					hr = CreateTable_SKU(TEXT("Font"), pSkuSet);
					if (SUCCEEDED(hr))
						hr = InsertFont(szFile, isVal.szVal, pSkuSet, -1);
					break;
				case BINDIMAGE:
					hr = CreateTable_SKU(TEXT("BindImage"), pSkuSet);
					if (SUCCEEDED(hr))
						hr = InsertFont(szFile, isVal.szVal, pSkuSet, -1);
					break;
				case SELFREG:
					hr = CreateTable_SKU(TEXT("SelfReg"), pSkuSet);
					if (SUCCEEDED(hr))
						hr = InsertSelfReg(szFile, isVal.intVal, pSkuSet, -1);
					break;
				}
			}
		}
	}

#ifdef DEBUG
	if (FAILED(hr))	_tprintf(TEXT("Error in function: ProcessFBS\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessMoveFile
//   This function:
//         1) Process all subentities of <MoveFile> include <SourceName>, 
//			  <DestName>, <SourceFolder>, <DestFolder>, <CopyFile>;
//         2) Insert into the MoveFile table;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessMoveFile(PIXMLDOMNode &pNodeMoveFile, 
						IntStringValue isValComponent, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeMoveFile != NULL);

	SkuSet skuSetCommon(g_cSkus); // the SkuSet that shars the common column 
								  // values

	// Values to be inserted into the DB 
	LPTSTR szFileKey	  = NULL;
	LPTSTR szComponent_   = isValComponent.szVal;
	LPTSTR szSourceName   = NULL;
	LPTSTR szDestName     = NULL;
	LPTSTR szSourceFolder = NULL;
	LPTSTR szDestFolder	  = NULL;
	UINT   uiOptions      = MSI_NULL_INTEGER;

	// create the File DB table
	hr = CreateTable_SKU(TEXT("MoveFile"), pSkuSet);

	if (FAILED(hr))	return hr;

	// Construct an ElementEntry object. 
	ElementEntry *pEEMoveFile = new ElementEntry(5, pSkuSet);
	assert(pEEMoveFile);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeMoveFile, TEXT("ID"), STRING, &isValID, pSkuSet);

	// if there is no ID specified, compiler generates one
	if (SUCCEEDED(hr))
	{
		if (!isValID.szVal)
		{
			isValID.szVal = GetName(TEXT("MoveFile"));
#ifdef DEBUG
			_tprintf(TEXT("Processing <MoveFile> with compiler generated ")
					 TEXT("primary key = %s\n"), isValID.szVal);
#endif
		}
		else
		{
#ifdef DEBUG
			_tprintf(TEXT("Processing <MoveFile ID=\"%s\">\n"), isValID.szVal);
#else
		;
#endif
		}
		// at this point, a primary key should exist for this MoveFile
		szFileKey = isValID.szVal;
		assert(szFileKey);

	}

	// Call ProcessChildrenArray to get back column values of all SKUs 
	// via the ElementEntry object
	if (SUCCEEDED(hr))
	{
		// because <CopyFile> actually DEset a bit, So the column value
		// for Options has to be set to default first
		IntStringValue isValOptions;
		isValOptions.intVal = msidbMoveFileOptionsMove;
		pEEMoveFile->SetNodeIndex(COPYFILE, 5);
		pEEMoveFile->SetValType(INTEGER, 5);
		hr = pEEMoveFile->SetValueSplit(isValOptions, 5, pSkuSet, NULL);

		if (SUCCEEDED(hr))
			hr = ProcessChildrenArray_H_XIES(pNodeMoveFile, rgNodeFuncs_MoveFile,
											 cNodeFuncs_MoveFile, pEEMoveFile, 
											 pSkuSet);
	}
	
	// Finalize the values stored in *pEE
	if (SUCCEEDED(hr))
		hr = pEEMoveFile->Finalize();

	if (SUCCEEDED(hr))
	{
		// Process Common values first
		skuSetCommon = pEEMoveFile->GetCommonSkuSet();

		if (!skuSetCommon.testClear())
		{
			szSourceName   = pEEMoveFile->GetCommonValue(1).szVal;
			szDestName	   = pEEMoveFile->GetCommonValue(2).szVal;
			szSourceFolder = pEEMoveFile->GetCommonValue(3).szVal;
			szDestFolder   = pEEMoveFile->GetCommonValue(4).szVal;
			uiOptions	   = pEEMoveFile->GetCommonValue(5).intVal;

			// insert into DB
			hr = InsertMoveFile(szFileKey, szComponent_, szSourceName, 
								szDestName, szSourceFolder, szDestFolder, 
								uiOptions, &skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szSourceName   = pEEMoveFile->GetValue(1,i).szVal;
					szDestName	   = pEEMoveFile->GetValue(2,i).szVal;
					szSourceFolder = pEEMoveFile->GetValue(3,i).szVal;
					szDestFolder   = pEEMoveFile->GetValue(4,i).szVal;
					uiOptions	   = pEEMoveFile->GetValue(5,i).intVal;

					// insert into DB
					hr = InsertMoveFile(szFileKey, szComponent_, szSourceName, 
										szDestName, szSourceFolder, 
										szDestFolder, uiOptions, NULL, i);
				}
			}
		}
	}

	delete pEEMoveFile;

	if (szFileKey)
		delete[] szFileKey;


#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessMoveFile\n"));
#endif

	return hr;
}


// Helper function: tells how to update an IntStringValue storing the value
// of the Options column of MoveFile table. It sets the stored value to 
// be 0
HRESULT UpdateMoveFileOptions(IntStringValue *pisValOut, IntStringValue isValOld, 
							  IntStringValue isValNew)
{
	pisValOut->intVal = isValNew.intVal;

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessCopyFile
//   This function:
//         1) Process <CopyFile> entity and set the Options Column in the
//	  MoveFile Table.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessCopyFile(PIXMLDOMNode &pNodeCopyFile, int iColumn,  
						ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeCopyFile != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeCopyFile)));
#endif
	
	IntStringValue isVal;
	isVal.intVal = 0;
	hr = pEE->SetValueSplit(isVal, iColumn, pSkuSet, UpdateMoveFileOptions);

#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessCopyFile\n"));
#endif

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessRemoveFile
//   This function:
//         1) Process all subentities of <RemoveFile> include <FName>, 
//			  <DirProperty>, <InstallMode>;
//         2) Insert into the RemoveFile table;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessRemoveFile(PIXMLDOMNode &pNodeRemoveFile, 
						  IntStringValue isValComponent, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeRemoveFile != NULL);

	SkuSet skuSetCommon(g_cSkus); // the SkuSet that shares the common column 
								  // values

	// Values to be inserted into the DB 
	LPTSTR szFileKey	  = NULL;
	LPTSTR szComponent_   = isValComponent.szVal;
	LPTSTR szFileName     = NULL;
	LPTSTR szDirProperty  = NULL;
	UINT   uiInstallMode  = MSI_NULL_INTEGER;

	// create the File DB table
	hr = CreateTable_SKU(TEXT("RemoveFile"), pSkuSet);

	if (FAILED(hr))	return hr;

	// Construct an ElementEntry object. 
	ElementEntry *pEERemoveFile = new ElementEntry(3, pSkuSet);
	assert(pEERemoveFile);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeRemoveFile, TEXT("ID"), STRING, &isValID, pSkuSet);

	// if there is no ID specified, compiler generates one
	if (SUCCEEDED(hr))
	{
		if (!isValID.szVal)
		{
			isValID.szVal = GetName(TEXT("RemoveFile"));
#ifdef DEBUG
			_tprintf(TEXT("Processing <RemoveFile> with compiler generated ")
					 TEXT("primary key = %s\n"), isValID.szVal);
#endif
		}
		else
		{
#ifdef DEBUG
			_tprintf(TEXT("Processing <RemoveFile ID=\"%s\">\n"), isValID.szVal);
#else
		;
#endif
		}
		// at this point, a primary key should exist for this RemoveFile
		szFileKey = isValID.szVal;
		assert(szFileKey);
	}

	// Call ProcessChildrenArray to get back column values of all SKUs 
	// via the ElementEntry object
	if (SUCCEEDED(hr))
		hr = ProcessChildrenArray_H_XIES(pNodeRemoveFile, rgNodeFuncs_RemoveFile,
										 cNodeFuncs_RemoveFile, pEERemoveFile, 
										 pSkuSet);
	
	// Finalize the values stored in *pEE
	if (SUCCEEDED(hr))
		hr = pEERemoveFile->Finalize();

	if (SUCCEEDED(hr))
	{
		// Process Common values first
		skuSetCommon = pEERemoveFile->GetCommonSkuSet();

		if (!skuSetCommon.testClear())
		{
			szFileName     = pEERemoveFile->GetCommonValue(1).szVal;
			szDirProperty  = pEERemoveFile->GetCommonValue(2).szVal;
			uiInstallMode  = pEERemoveFile->GetCommonValue(3).intVal;

			// insert into DB
			hr = InsertRemoveFile(szFileKey, szComponent_, szFileName, 
								  szDirProperty, uiInstallMode,
								  &skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szFileName	  = pEERemoveFile->GetValue(1,i).szVal;
					szDirProperty = pEERemoveFile->GetValue(2,i).szVal;
					uiInstallMode = pEERemoveFile->GetValue(3,i).intVal;

					// insert into DB
					hr = InsertRemoveFile(szFileKey, szComponent_, szFileName, 
										  szDirProperty, uiInstallMode,
										  NULL, i);
				}
			}
		}
	}

	delete pEERemoveFile;

	if (szFileKey)
		delete[] szFileKey;


#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessRemoveFile\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessInstallMode
//   This function:
//         1) Process <InstallMode> entity and set the InstallMode Column in the
//	  RemoveFile Table.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessInstallMode(PIXMLDOMNode &pNodeInstallMode, int iColumn,
						   ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeInstallMode != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeInstallMode)));
#endif

	LPTSTR szValue = NULL;

	// get Value attribute 
	IntStringValue isValValue;
	isValValue.szVal = NULL;
	if (SUCCEEDED(hr = ProcessAttribute(pNodeInstallMode, 
										rgXMSINodes[XMSI_INSTALLMODE].szAttributeName,
							  		    STRING,
										&isValValue,
										pSkuSet)))
	{
		if (NULL == isValValue.szVal)
		{
			_tprintf(TEXT("Compile Error: Missing required attribute")
					 TEXT("\'%s\' of <%s>\n"), 
					 rgXMSINodes[XMSI_INSTALLMODE].szNodeName,
					 rgXMSINodes[XMSI_INSTALLMODE].szNodeName);
			hr = E_FAIL;
		}
		else
			szValue = isValValue.szVal;
	}

	// get the numeric value of InstallMode column in DB
	if (SUCCEEDED(hr))
	{
		IntStringValue isVal;
		isVal.intVal = 0;

		if (0 =