ha Stack size/offset = 48 */
#endif
/* 1402 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValues */

/* 1404 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1406 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1410 */	NdrFcShort( 0x18 ),	/* 24 */
#ifndef _ALPHA_
/* 1412 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1414 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1416 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1418 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1422 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1424 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1426 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1430 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1432 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1434 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1436 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1438 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 1440 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1442 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1444 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter OptionValues */

/* 1446 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1448 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1450 */	NdrFcShort( 0x276 ),	/* Type Offset=630 */

	/* Return value */

/* 1452 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1454 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1456 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfig */

/* 1458 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1460 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1464 */	NdrFcShort( 0x19 ),	/* 25 */
#ifndef _ALPHA_
/* 1466 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1468 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1470 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1472 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1474 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1476 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1478 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1480 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1482 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1484 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1486 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1488 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1490 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1492 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 1494 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1496 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 1500 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1502 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1504 */	NdrFcShort( 0x3d6 ),	/* Type Offset=982 */

	/* Return value */

/* 1506 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1508 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1510 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfig */

/* 1512 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1514 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1518 */	NdrFcShort( 0x1a ),	/* 26 */
#ifndef _ALPHA_
/* 1520 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1522 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1524 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1526 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1530 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1532 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1534 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1540 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1542 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1544 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1546 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 1548 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1550 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1552 */	NdrFcShort( 0x406 ),	/* Type Offset=1030 */

	/* Return value */

/* 1554 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1556 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1558 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpScanDatabase */

/* 1560 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1562 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1566 */	NdrFcShort( 0x1b ),	/* 27 */
#ifndef _ALPHA_
/* 1568 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1570 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1572 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1574 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1576 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1578 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1580 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1582 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1584 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1588 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1590 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1592 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1594 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1596 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1598 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1600 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter FixFlag */

/* 1602 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1604 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1606 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScanList */

/* 1608 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1610 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1612 */	NdrFcShort( 0x40e ),	/* Type Offset=1038 */

	/* Return value */

/* 1614 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1616 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1618 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetVersion */

/* 1620 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1622 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1626 */	NdrFcShort( 0x1c ),	/* 28 */
#ifndef _ALPHA_
/* 1628 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1630 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1632 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1634 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1636 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1638 */	NdrFcShort( 0x40 ),	/* 64 */
/* 1640 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1642 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1644 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1646 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1648 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1650 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1652 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1654 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MajorVersion */

/* 1656 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1658 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1660 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter MinorVersion */

/* 1662 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1664 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1666 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1668 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1670 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1672 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElementV4 */

/* 1674 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1676 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1680 */	NdrFcShort( 0x1d ),	/* 29 */
#ifndef _ALPHA_
/* 1682 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1684 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1686 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1688 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1690 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1692 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1694 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1696 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1700 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1702 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1704 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1706 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1708 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1710 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1712 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1714 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 1716 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1718 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1720 */	NdrFcShort( 0x494 ),	/* Type Offset=1172 */

	/* Return value */

/* 1722 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1724 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1726 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElementsV4 */

/* 1728 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1730 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1734 */	NdrFcShort( 0x1e ),	/* 30 */
#ifndef _ALPHA_
/* 1736 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
#else
			NdrFcShort( 0x48 ),	/* Alpha Stack size/offset = 72 */
#endif
/* 1738 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1740 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1742 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1744 */	NdrFcShort( 0x32 ),	/* 50 */
/* 1746 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1748 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 1750 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1752 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1754 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1758 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1760 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1762 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1764 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1766 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1768 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 1770 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1772 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1774 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1776 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 1778 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1780 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1782 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1784 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1786 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 1788 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1790 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1792 */	NdrFcShort( 0x4a2 ),	/* Type Offset=1186 */

	/* Parameter ElementsRead */

/* 1794 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1796 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 1798 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 1800 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1802 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 1804 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1806 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1808 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 1810 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElementV4 */

/* 1812 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1814 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1818 */	NdrFcShort( 0x1f ),	/* 31 */
#ifndef _ALPHA_
/* 1820 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1822 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1824 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1826 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1828 */	NdrFcShort( 0xe ),	/* 14 */
/* 1830 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1832 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1834 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1836 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1838 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1840 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1842 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1844 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1846 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1848 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1850 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1852 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 1854 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1856 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1858 */	NdrFcShort( 0x494 ),	/* Type Offset=1172 */

	/* Parameter ForceFlag */

/* 1860 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1862 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1864 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 1866 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1868 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfoV4 */

/* 1872 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1874 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1878 */	NdrFcShort( 0x20 ),	/* 32 */
#ifndef _ALPHA_
/* 1880 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1882 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1884 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1886 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1890 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1892 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1894 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1896 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1898 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1900 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1902 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1904 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1906 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1908 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1910 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1912 */	NdrFcShort( 0x4d8 ),	/* Type Offset=1240 */

	/* Return value */

/* 1914 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1916 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1918 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfoV4 */

/* 1920 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1922 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1926 */	NdrFcShort( 0x21 ),	/* 33 */
#ifndef _ALPHA_
/* 1928 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1930 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1932 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1934 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1936 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1938 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1940 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1942 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1944 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1946 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1948 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1950 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1952 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1954 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1956 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1958 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1960 */	NdrFcShort( 0x4d8 ),	/* Type Offset=1240 */

	/* Return value */

/* 1962 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1964 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1966 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfoV4 */

/* 1968 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1970 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1974 */	NdrFcShort( 0x22 ),	/* 34 */
#ifndef _ALPHA_
/* 1976 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1978 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1980 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1982 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1986 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1988 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1990 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1992 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1994 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1996 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1998 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2000 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2002 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 2004 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 2006 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2008 */	NdrFcShort( 0x308 ),	/* Type Offset=776 */

	/* Parameter ClientInfo */

/* 2010 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2012 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2014 */	NdrFcShort( 0x4fc ),	/* Type Offset=1276 */

	/* Return value */

/* 2016 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2018 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2020 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClientsV4 */

/* 2022 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2024 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2028 */	NdrFcShort( 0x23 ),	/* 35 */
#ifndef _ALPHA_
/* 2030 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 2032 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2034 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2036 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2038 */	NdrFcShort( 0x2c ),	/* 44 */
/* 2040 */	NdrFcShort( 0x5c ),	/* 92 */
/* 2042 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 2044 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2046 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2048 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2050 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2052 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2054 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2056 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2058 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2060 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2062 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 2064 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 2066 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2068 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 2070 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2072 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2074 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 2076 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2078 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2080 */	NdrFcShort( 0x504 ),	/* Type Offset=1284 */

	/* Parameter ClientsRead */

/* 2082 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 2084 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2086 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 2088 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 2090 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2092 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2094 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2096 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 2098 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSuperScopeV4 */

/* 2100 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2102 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2106 */	NdrFcShort( 0x24 ),	/* 36 */
#ifndef _ALPHA_
/* 2108 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2110 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2112 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2114 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2116 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2118 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2120 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2122 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2126 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2128 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2130 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2132 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2134 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2136 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2138 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2140 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SuperScopeName */

/* 2142 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2144 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2146 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ChangeExisting */

/* 2148 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2150 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2152 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2154 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2156 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSuperScopeInfoV4 */

/* 2160 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2166 */	NdrFcShort( 0x25 ),	/* 37 */
#ifndef _ALPHA_
/* 2168 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2170 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2172 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2174 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2178 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2180 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2182 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2184 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2188 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2190 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2192 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2194 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeTable */

/* 2196 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2198 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2200 */	NdrFcShort( 0x540 ),	/* Type Offset=1344 */

	/* Return value */

/* 2202 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2204 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2206 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSuperScopeV4 */

/* 2208 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2210 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2214 */	NdrFcShort( 0x26 ),	/* 38 */
#ifndef _ALPHA_
/* 2216 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2218 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2220 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2222 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2226 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2228 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2230 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2232 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2236 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2238 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2240 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2242 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeName */

/* 2244 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 2246 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2248 */	NdrFcShort( 0x596 ),	/* Type Offset=1430 */

	/* Return value */

/* 2250 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2252 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfigV4 */

/* 2256 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2258 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2262 */	NdrFcShort( 0x27 ),	/* 39 */
#ifndef _ALPHA_
/* 2264 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2266 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2268 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2270 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2274 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2276 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2278 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 2280 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2282 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2284 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2286 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2288 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2290 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 2292 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2294 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2296 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 2298 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 2300 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2302 */	NdrFcShort( 0x5a8 ),	/* Type Offset=1448 */

	/* Return value */

/* 2304 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2306 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2308 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfigV4 */

/* 2310 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2312 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2316 */	NdrFcShort( 0x28 ),	/* 40 */
#ifndef _ALPHA_
/* 2318 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2320 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2322 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2324 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2328 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2330 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2332 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2334 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2338 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2340 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2342 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2344 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 2346 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2348 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2350 */	NdrFcShort( 0x5e6 ),	/* Type Offset=1510 */

	/* Return value */

/* 2352 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2354 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2356 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x0,	/* FC_RP */
/*  8 */	NdrFcShort( 0x22 ),	/* Offset= 34 (42) */
/* 10 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 12 */	NdrFcShort( 0xc ),	/* 12 */
/* 14 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 16 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 18 */	NdrFcShort( 0x4 ),	/* 4 */
/* 20 */	NdrFcShort( 0x4 ),	/* 4 */
/* 22 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 24 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 26 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 28 */	NdrFcShort( 0x8 ),	/* 8 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 34 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 36 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 38 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 44 */	NdrFcShort( 0x20 ),	/* 32 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0xc ),	/* Offset= 12 (60) */
/* 50 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 52 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 54 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 56 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (10) */
/* 58 */	0xd,		/* FC_ENUM16 */
			0x5b,		/* FC_END */
/* 60 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 62 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 64 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 66 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 68 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 70 */	NdrFcShort( 0x2 ),	/* Offset= 2 (72) */
/* 72 */	
			0x12, 0x0,	/* FC_UP */
/* 74 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (42) */
/* 76 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 78 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 80 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 82 */	NdrFcShort( 0x2 ),	/* Offset= 2 (84) */
/* 84 */	
			0x12, 0x0,	/* FC_UP */
/* 86 */	NdrFcShort( 0xe ),	/* Offset= 14 (100) */
/* 88 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 90 */	NdrFcShort( 0x4 ),	/* 4 */
/* 92 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 98 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 100 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 104 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 106 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 108 */	NdrFcShort( 0x4 ),	/* 4 */
/* 110 */	NdrFcShort( 0x4 ),	/* 4 */
/* 112 */	0x12, 0x0,	/* FC_UP */
/* 114 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (88) */
/* 116 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 118 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 120 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 122 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 124 */	
			0x11, 0x0,	/* FC_RP */
/* 126 */	NdrFcShort( 0x78 ),	/* Offset= 120 (246) */
/* 128 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 130 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 136 */	NdrFcShort( 0x2 ),	/* Offset= 2 (138) */
/* 138 */	NdrFcShort( 0x4 ),	/* 4 */
/* 140 */	NdrFcShort( 0x5 ),	/* 5 */
/* 142 */	NdrFcLong( 0x0 ),	/* 0 */
/* 146 */	NdrFcShort( 0x1c ),	/* Offset= 28 (174) */
/* 148 */	NdrFcLong( 0x1 ),	/* 1 */
/* 152 */	NdrFcShort( 0x22 ),	/* Offset= 34 (186) */
/* 154 */	NdrFcLong( 0x2 ),	/* 2 */
/* 158 */	NdrFcShort( 0x20 ),	/* Offset= 32 (190) */
/* 160 */	NdrFcLong( 0x3 ),	/* 3 */
/* 164 */	NdrFcShort( 0xa ),	/* Offset= 10 (174) */
/* 166 */	NdrFcLong( 0x4 ),	/* 4 */
/* 170 */	NdrFcShort( 0x4 ),	/* Offset= 4 (174) */
/* 172 */	NdrFcShort( 0x0 ),	/* Offset= 0 (172) */
/* 174 */	
			0x12, 0x0,	/* FC_UP */
/* 176 */	NdrFcShort( 0x2 ),	/* Offset= 2 (178) */
/* 178 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 180 */	NdrFcShort( 0x8 ),	/* 8 */
/* 182 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 184 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 186 */	
			0x12, 0x0,	/* FC_UP */
/* 188 */	NdrFcShort( 0xffffff4e ),	/* Offset= -178 (10) */
/* 190 */	
			0x12, 0x0,	/* FC_UP */
/* 192 */	NdrFcShort( 0x22 ),	/* Offset= 34 (226) */
/* 194 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 196 */	NdrFcShort( 0x1 ),	/* 1 */
/* 198 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 204 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 206 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 212 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 214 */	NdrFcShort( 0x4 ),	/* 4 */
/* 216 */	NdrFcShort( 0x4 ),	/* 4 */
/* 218 */	0x12, 0x0,	/* FC_UP */
/* 220 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (194) */
/* 222 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 224 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 226 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 228 */	NdrFcShort( 0x8 ),	/* 8 */
/* 230 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 232 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 234 */	NdrFcShort( 0x4 ),	/* 4 */
/* 236 */	NdrFcShort( 0x4 ),	/* 4 */
/* 238 */	0x12, 0x0,	/* FC_UP */
/* 240 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (206) */
/* 242 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 244 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 246 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 248 */	NdrFcShort( 0x8 ),	/* 8 */
/* 250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 252 */	NdrFcShort( 0x0 ),	/* Offset= 0 (252) */
/* 254 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 256 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff7f ),	/* Offset= -129 (128) */
			0x5b,		/* FC_END */
/* 260 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 262 */	NdrFcShort( 0x2 ),	/* Offset= 2 (264) */
/* 264 */	
			0x12, 0x0,	/* FC_UP */
/* 266 */	NdrFcShort( 0x18 ),	/* Offset= 24 (290) */
/* 268 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */
/* 276 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 278 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 282 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 284 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 286 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (246) */
/* 288 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 290 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 292 */	NdrFcShort( 0x8 ),	/* 8 */
/* 294 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 296 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 298 */	NdrFcShort( 0x4 ),	/* 4 */
/* 300 */	NdrFcShort( 0x4 ),	/* 4 */
/* 302 */	0x12, 0x0,	/* FC_UP */
/* 304 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (268) */
/* 306 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 308 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 310 */	
			0x11, 0x0,	/* FC_RP */
/* 312 */	NdrFcShort( 0x7a ),	/* Offset= 122 (434) */
/* 314 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 316 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 318 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 320 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 322 */	NdrFcShort( 0x2 ),	/* Offset= 2 (324) */
/* 324 */	NdrFcShort( 0x8 ),	/* 8 */
/* 326 */	NdrFcShort( 0x8 ),	/* 8 */
/* 328 */	NdrFcLong( 0x0 ),	/* 0 */
/* 332 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 334 */	NdrFcLong( 0x1 ),	/* 1 */
/* 338 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 340 */	NdrFcLong( 0x2 ),	/* 2 */
/* 344 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 346 */	NdrFcLong( 0x3 ),	/* 3 */
/* 350 */	NdrFcShort( 0xffffff54 ),	/* Offset= -172 (178) */
/* 352 */	NdrFcLong( 0x4 ),	/* 4 */
/* 356 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 358 */	NdrFcLong( 0x5 ),	/* 5 */
/* 362 */	NdrFcShort( 0xfffffe98 ),	/* Offset= -360 (2) */
/* 364 */	NdrFcLong( 0x6 ),	/* 6 */
/* 368 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (206) */
/* 370 */	NdrFcLong( 0x7 ),	/* 7 */
/* 374 */	NdrFcShort( 0xffffff58 ),	/* Offset= -168 (206) */
/* 376 */	NdrFcShort( 0x0 ),	/* Offset= 0 (376) */
/* 378 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 380 */	NdrFcShort( 0xc ),	/* 12 */
/* 382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 384 */	NdrFcShort( 0x0 ),	/* Offset= 0 (384) */
/* 386 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 388 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb5 ),	/* Offset= -75 (314) */
			0x5b,		/* FC_END */
/* 392 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 396 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 400 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 402 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 406 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 408 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 410 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (378) */
/* 412 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 414 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 416 */	NdrFcShort( 0x8 ),	/* 8 */
/* 418 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 420 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 422 */	NdrFcShort( 0x4 ),	/* 4 */
/* 424 */	NdrFcShort( 0x4 ),	/* 4 */
/* 426 */	0x12, 0x0,	/* FC_UP */
/* 428 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (392) */
/* 430 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 432 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 434 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 436 */	NdrFcShort( 0x18 ),	/* 24 */
/* 438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 440 */	NdrFcShort( 0xc ),	/* Offset= 12 (452) */
/* 442 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 444 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 446 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffdf ),	/* Offset= -33 (414) */
			0xd,		/* FC_ENUM16 */
/* 450 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 452 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 454 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 456 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 458 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 460 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 462 */	NdrFcShort( 0x2 ),	/* Offset= 2 (464) */
/* 464 */	
			0x12, 0x0,	/* FC_UP */
/* 466 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (434) */
/* 468 */	
			0x11, 0x0,	/* FC_RP */
/* 470 */	NdrFcShort( 0x30 ),	/* Offset= 48 (518) */
/* 472 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 474 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 476 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 478 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 480 */	NdrFcShort( 0x2 ),	/* Offset= 2 (482) */
/* 482 */	NdrFcShort( 0x8 ),	/* 8 */
/* 484 */	NdrFcShort( 0x5 ),	/* 5 */
/* 486 */	NdrFcLong( 0x0 ),	/* 0 */
/* 490 */	NdrFcShort( 0x0 ),	/* Offset= 0 (490) */
/* 492 */	NdrFcLong( 0x1 ),	/* 1 */
/* 496 */	NdrFcShort( 0x0 ),	/* Offset= 0 (496) */
/* 498 */	NdrFcLong( 0x2 ),	/* 2 */
/* 502 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 504 */	NdrFcLong( 0x3 ),	/* 3 */
/* 508 */	NdrFcShort( 0xfffffeb6 ),	/* Offset= -330 (178) */
/* 510 */	NdrFcLong( 0x4 ),	/* 4 */
/* 514 */	NdrFcShort( 0xfffffe00 ),	/* Offset= -512 (2) */
/* 516 */	NdrFcShort( 0x0 ),	/* Offset= 0 (516) */
/* 518 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 520 */	NdrFcShort( 0xc ),	/* 12 */
/* 522 */	NdrFcShort( 0x0 ),	/* 0 */
/* 524 */	NdrFcShort( 0x0 ),	/* Offset= 0 (524) */
/* 526 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 528 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc7 ),	/* Offset= -57 (472) */
			0x5b,		/* FC_END */
/* 532 */	
			0x11, 0x0,	/* FC_RP */
/* 534 */	NdrFcShort( 0xffffff88 ),	/* Offset= -120 (414) */
/* 536 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 538 */	NdrFcShort( 0x2 ),	/* Offset= 2 (540) */
/* 540 */	
			0x12, 0x0,	/* FC_UP */
/* 542 */	NdrFcShort( 0x18 ),	/* Offset= 24 (566) */
/* 544 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 546 */	NdrFcShort( 0x0 ),	/* 0 */
/* 548 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 550 */	NdrFcShort( 0x4 ),	/* 4 */
/* 552 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 554 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 558 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 560 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 562 */	NdrFcShort( 0xffffff48 ),	/* Offset= -184 (378) */
/* 564 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 566 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 568 */	NdrFcShort( 0xc ),	/* 12 */
/* 570 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 572 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 574 */	NdrFcShort( 0x8 ),	/* 8 */
/* 576 */	NdrFcShort( 0x8 ),	/* 8 */
/* 578 */	0x12, 0x0,	/* FC_UP */
/* 580 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (544) */
/* 582 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 584 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 586 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 588 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 590 */	NdrFcShort( 0x2 ),	/* Offset= 2 (592) */
/* 592 */	
			0x12, 0x0,	/* FC_UP */
/* 594 */	NdrFcShort( 0x24 ),	/* Offset= 36 (630) */
/* 596 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 598 */	NdrFcShort( 0xc ),	/* 12 */
/* 600 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 602 */	NdrFcShort( 0x0 ),	/* 0 */
/* 604 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 606 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 608 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 610 */	NdrFcShort( 0xc ),	/* 12 */
/* 612 */	NdrFcShort( 0x0 ),	/* 0 */
/* 614 */	NdrFcShort( 0x1 ),	/* 1 */
/* 616 */	NdrFcShort( 0x8 ),	/* 8 */
/* 618 */	NdrFcShort( 0x8 ),	/* 8 */
/* 620 */	0x12, 0x0,	/* FC_UP */
/* 622 */	NdrFcShort( 0xffffffb2 ),	/* Offset= -78 (544) */
/* 624 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 626 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc3 ),	/* Offset= -61 (566) */
			0x5b,		/* FC_END */
/* 630 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 634 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 636 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 638 */	NdrFcShort( 0x4 ),	/* 4 */
/* 640 */	NdrFcShort( 0x4 ),	/* 4 */
/* 642 */	0x12, 0x0,	/* FC_UP */
/* 644 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (596) */
/* 646 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 648 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 650 */	
			0x11, 0x0,	/* FC_RP */
/* 652 */	NdrFcShort( 0xe ),	/* Offset= 14 (666) */
/* 654 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 656 */	NdrFcShort( 0x1 ),	/* 1 */
/* 658 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 660 */	NdrFcShort( 0x8 ),	/* 8 */
/* 662 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 664 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 666 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 668 */	NdrFcShort( 0x2c ),	/* 44 */
/* 670 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 672 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 674 */	NdrFcShort( 0xc ),	/* 12 */
/* 676 */	NdrFcShort( 0xc ),	/* 12 */
/* 678 */	0x12, 0x0,	/* FC_UP */
/* 680 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (654) */
/* 682 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 684 */	NdrFcShort( 0x10 ),	/* 16 */
/* 686 */	NdrFcShort( 0x10 ),	/* 16 */
/* 688 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 690 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 692 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 694 */	NdrFcShort( 0x14 ),	/* 20 */
/* 696 */	NdrFcShort( 0x14 ),	/* 20 */
/* 698 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 700 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 702 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 704 */	NdrFcShort( 0x24 ),	/* 36 */
/* 706 */	NdrFcShort( 0x24 ),	/* 36 */
/* 708 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 710 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 712 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 714 */	NdrFcShort( 0x28 ),	/* 40 */
/* 716 */	NdrFcShort( 0x28 ),	/* 40 */
/* 718 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 720 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 722 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 724 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 726 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 728 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 730 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffdd7 ),	/* Offset= -553 (178) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 734 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd2b ),	/* Offset= -725 (10) */
			0x5b,		/* FC_END */
/* 738 */	
			0x11, 0x0,	/* FC_RP */
/* 740 */	NdrFcShort( 0x24 ),	/* Offset= 36 (776) */
/* 742 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 744 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 746 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 748 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 750 */	NdrFcShort( 0x2 ),	/* Offset= 2 (752) */
/* 752 */	NdrFcShort( 0x8 ),	/* 8 */
/* 754 */	NdrFcShort( 0x3 ),	/* 3 */
/* 756 */	NdrFcLong( 0x0 ),	/* 0 */
/* 760 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 762 */	NdrFcLong( 0x1 ),	/* 1 */
/* 766 */	NdrFcShort( 0xfffffdd0 ),	/* Offset= -560 (206) */
/* 768 */	NdrFcLong( 0x2 ),	/* 2 */
/* 772 */	NdrFcShort( 0xfffffcfe ),	/* Offset= -770 (2) */
/* 774 */	NdrFcShort( 0x0 ),	/* Offset= 0 (774) */
/* 776 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 778 */	NdrFcShort( 0xc ),	/* 12 */
/* 780 */	NdrFcShort( 0x0 ),	/* 0 */
/* 782 */	NdrFcShort( 0x0 ),	/* Offset= 0 (782) */
/* 784 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 786 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd3 ),	/* Offset= -45 (742) */
			0x5b,		/* FC_END */
/* 790 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 792 */	NdrFcShort( 0x2 ),	/* Offset= 2 (794) */
/* 794 */	
			0x12, 0x0,	/* FC_UP */
/* 796 */	NdrFcShort( 0xffffff7e ),	/* Offset= -130 (666) */
/* 798 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 800 */	NdrFcShort( 0x2 ),	/* Offset= 2 (802) */
/* 802 */	
			0x12, 0x0,	/* FC_UP */
/* 804 */	NdrFcShort( 0x22 ),	/* Offset= 34 (838) */
/* 806 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 808 */	NdrFcShort( 0x4 ),	/* 4 */
/* 810 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 812 */	NdrFcShort( 0x0 ),	/* 0 */
/* 814 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 816 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 818 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 820 */	NdrFcShort( 0x4 ),	/* 4 */
/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 824 */	NdrFcShort( 0x1 ),	/* 1 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	NdrFcShort( 0x0 ),	/* 0 */
/* 830 */	0x12, 0x0,	/* FC_UP */
/* 832 */	NdrFcShort( 0xffffff5a ),	/* Offset= -166 (666) */
/* 834 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 836 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 838 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 840 */	NdrFcShort( 0x8 ),	/* 8 */
/* 842 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 844 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 846 */	NdrFcShort( 0x4 ),	/* 4 */
/* 848 */	NdrFcShort( 0x4 ),	/* 4 */
/* 850 */	0x12, 0x0,	/* FC_UP */
/* 852 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (806) */
/* 854 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 856 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 858 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 860 */	NdrFcShort( 0x2 ),	/* Offset= 2 (862) */
/* 862 */	
			0x12, 0x0,	/* FC_UP */
/* 864 */	NdrFcShort( 0x1c ),	/* Offset= 28 (892) */
/* 866 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 868 */	NdrFcShort( 0x10 ),	/* 16 */
/* 870 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 872 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 874 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 876 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 878 */	NdrFcShort( 0x10 ),	/* 16 */
/* 880 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 882 */	NdrFcShort( 0x24 ),	/* 36 */
/* 884 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 886 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 888 */	NdrFcShort( 0xffffffea ),	/* Offset= -22 (866) */
/* 890 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 892 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 894 */	NdrFcShort( 0x2c ),	/* 44 */
/* 896 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 898 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 900 */	NdrFcShort( 0x28 ),	/* 40 */
/* 902 */	NdrFcShort( 0x28 ),	/* 40 */
/* 904 */	0x12, 0x0,	/* FC_UP */
/* 906 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (876) */
/* 908 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 910 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 912 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 914 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 916 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 918 */	NdrFcShort( 0xfffffd1c ),	/* Offset= -740 (178) */
/* 920 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 922 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 924 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 926 */	NdrFcShort( 0x2 ),	/* Offset= 2 (928) */
/* 928 */	
			0x12, 0x0,	/* FC_UP */
/* 930 */	NdrFcShort( 0x18 ),	/* Offset= 24 (954) */
/* 932 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 934 */	NdrFcShort( 0x0 ),	/* 0 */
/* 936 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 938 */	NdrFcShort( 0x0 ),	/* 0 */
/* 940 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 942 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 946 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 948 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 950 */	NdrFcShort( 0xfffffdfc ),	/* Offset= -516 (434) */
/* 952 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 954 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 956 */	NdrFcShort( 0x8 ),	/* 8 */
/* 958 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 960 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 962 */	NdrFcShort( 0x4 ),	/* 4 */
/* 964 */	NdrFcShort( 0x4 ),	/* 4 */
/* 966 */	0x12, 0x0,	/* FC_UP */
/* 968 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (932) */
/* 970 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 972 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 974 */	
			0x11, 0x0,	/* FC_RP */
/* 976 */	NdrFcShort( 0xfffffea6 ),	/* Offset= -346 (630) */
/* 978 */	
			0x11, 0x0,	/* FC_RP */
/* 980 */	NdrFcShort( 0x2 ),	/* Offset= 2 (982) */
/* 982 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 984 */	NdrFcShort( 0x24 ),	/* 36 */
/* 986 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 988 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 990 */	NdrFcShort( 0x4 ),	/* 4 */
/* 992 */	NdrFcShort( 0x4 ),	/* 4 */
/* 994 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 996 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 998 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1000 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1002 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1004 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1006 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1008 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1010 */	NdrFcShort( 0xc ),	/* 12 */
/* 1012 */	NdrFcShort( 0xc ),	/* 12 */
/* 1014 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1016 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1018 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1020 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1022 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1024 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1026 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1028 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1030 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1032 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1034) */
/* 1034 */	
			0x12, 0x0,	/* FC_UP */
/* 1036 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (982) */
/* 1038 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1040 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1042) */
/* 1042 */	
			0x12, 0x0,	/* FC_UP */
/* 1044 */	NdrFcShort( 0x24 ),	/* Offset= 36 (1080) */
/* 1046 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1048 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1050 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1052 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1052) */
/* 1054 */	0x8,		/* FC_LONG */
			0xd,		/* FC_ENUM16 */
/* 1056 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1058 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1062 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1064 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1066 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1068 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1072 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1074 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1076 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1046) */
/* 1078 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1080 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1082 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1084 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1086 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1088 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1090 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1092 */	0x12, 0x0,	/* FC_UP */
/* 1094 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1058) */
/* 1096 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1098 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1100 */	
			0x11, 0x0,	/* FC_RP */
/* 1102 */	NdrFcShort( 0x46 ),	/* Offset= 70 (1172) */
/* 1104 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 1106 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 1108 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1110 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1112 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1114) */
/* 1114 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1116 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1118 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1122 */	NdrFcShort( 0xfffffc4c ),	/* Offset= -948 (174) */
/* 1124 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1128 */	NdrFcShort( 0xfffffc52 ),	/* Offset= -942 (186) */
/* 1130 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1134 */	NdrFcShort( 0x10 ),	/* Offset= 16 (1150) */
/* 1136 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1140 */	NdrFcShort( 0xfffffc3a ),	/* Offset= -966 (174) */
/* 1142 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1146 */	NdrFcShort( 0xfffffc34 ),	/* Offset= -972 (174) */
/* 1148 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1148) */
/* 1150 */	
			0x12, 0x0,	/* FC_UP */
/* 1152 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1154) */
/* 1154 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1156 */	NdrFcShort( 0xc ),	/* 12 */
/* 1158 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1160 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1168) */
/* 1162 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1164 */	0x2,		/* FC_CHAR */
			0x3f,		/* FC_STRUCTPAD3 */
/* 1166 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1168 */	
			0x12, 0x0,	/* FC_UP */
/* 1170 */	NdrFcShort( 0xfffffc3c ),	/* Offset= -964 (206) */
/* 1172 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 1174 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1178 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1178) */
/* 1180 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1182 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb1 ),	/* Offset= -79 (1104) */
			0x5b,		/* FC_END */
/* 1186 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1188 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1190) */
/* 1190 */	
			0x12, 0x0,	/* FC_UP */
/* 1192 */	NdrFcShort( 0x18 ),	/* Offset= 24 (1216) */
/* 1194 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1198 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1202 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1204 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1208 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1210 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1212 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (1172) */
/* 1214 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1216 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1218 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1220 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1222 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1224 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1226 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1228 */	0x12, 0x0,	/* FC_UP */
/* 1230 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1194) */
/* 1232 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1234 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1236 */	
			0x11, 0x0,	/* FC_RP */
/* 1238 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1240) */
/* 1240 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1242 */	NdrFcShort( 0x30 ),	/* 48 */
/* 1244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1246 */	NdrFcShort( 0x16 ),	/* Offset= 22 (1268) */
/* 1248 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1250 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1252 */	NdrFcShort( 0xfffffbea ),	/* Offset= -1046 (206) */
/* 1254 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1256 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1258 */	NdrFcShort( 0xfffffbc8 ),	/* Offset= -1080 (178) */
/* 1260 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1262 */	NdrFcShort( 0xfffffb1c ),	/* Offset= -1252 (10) */
/* 1264 */	0x2,		/* FC_CHAR */
			0x3f,		/* FC_STRUCTPAD3 */
/* 1266 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1268 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1270 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1272 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1274 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1276 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1278 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1280) */
/* 1280 */	
			0x12, 0x0,	/* FC_UP */
/* 1282 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1240) */
/* 1284 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1286 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1288) */
/* 1288 */	
			0x12, 0x0,	/* FC_UP */
/* 1290 */	NdrFcShort( 0x22 ),	/* Offset= 34 (1324) */
/* 1292 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1294 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1296 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1298 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1300 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1302 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1304 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1306 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1310 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1312 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1316 */	0x12, 0x0,	/* FC_UP */
/* 1318 */	NdrFcShort( 0xffffffb2 ),	/* Offset= -78 (1240) */
/* 1320 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1322 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1324 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1326 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1328 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1330 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1332 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1334 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1336 */	0x12, 0x0,	/* FC_UP */
/* 1338 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1292) */
/* 1340 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1342 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1344 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1346 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1348) */
/* 1348 */	
			0x12, 0x0,	/* FC_UP */
/* 1350 */	NdrFcShort( 0x3a ),	/* Offset= 58 (1408) */
/* 1352 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1354 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1356 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1358 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1360 */	NdrFcShort( 0xc ),	/* 12 */
/* 1362 */	NdrFcShort( 0xc ),	/* 12 */
/* 1364 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1366 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1368 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1370 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1372 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1374 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1376 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1378 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1380 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1382 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1384 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1386 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1388 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1390 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1392 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1394 */	NdrFcShort( 0xc ),	/* 12 */
/* 1396 */	NdrFcShort( 0xc ),	/* 12 */
/* 1398 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1400 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1402 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1404 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffcb ),	/* Offset= -53 (1352) */
			0x5b,		/* FC_END */
/* 1408 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1410 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1412 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1414 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1416 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1418 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1420 */	0x12, 0x0,	/* FC_UP */
/* 1422 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (1374) */
/* 1424 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1426 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1428 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1430 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1432 */	
			0x11, 0x0,	/* FC_RP */
/* 1434 */	NdrFcShort( 0xe ),	/* Offset= 14 (1448) */
/* 1436 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1438 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1440 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1442 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1444 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1446 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 1448 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1450 */	NdrFcShort( 0x34 ),	/* 52 */
/* 1452 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1454 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1456 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1458 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1460 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1462 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1464 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1466 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1468 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1470 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1472 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1474 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1476 */	NdrFcShort( 0xc ),	/* 12 */
/* 1478 */	NdrFcShort( 0xc ),	/* 12 */
/* 1480 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1482 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1484 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1486 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1488 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1490 */	0x12, 0x0,	/* FC_UP */
/* 1492 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (1436) */
/* 1494 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1496 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1498 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1500 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1502 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1504 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1506 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1508 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1510 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1512 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1514) */
/* 1514 */	
			0x12, 0x0,	/* FC_UP */
/* 1516 */	NdrFcShort( 0xffffffbc ),	/* Offset= -68 (1448) */

			0x0
        }
    };

static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR * )(pStubMsg->StackTop - 4);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = ( unsigned long ) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR * )(pStubMsg->StackTop - 4);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = ( unsigned long ) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static const EXPR_EVAL ExprEvalRoutines[] = 
    {
    dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000
    ,dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001
    };


static const unsigned short dhcpsrv_FormatStringOffsetTable[] =
    {
    0,
    54,
    108,
    162,
    234,
    288,
    372,
    432,
    486,
    540,
    594,
    648,
    696,
    756,
    816,
    894,
    948,
    996,
    1044,
    1098,
    1146,
    1224,
    1284,
    1332,
    1404,
    1458,
    1512,
    1560,
    1620,
    1674,
    1728,
    1812,
    1872,
    1920,
    1968,
    2022,
    2100,
    2160,
    2208,
    2256,
    2310
    };


static const MIDL_STUB_DESC dhcpsrv_StubDesc = 
    {
    (void __RPC_FAR *)& dhcpsrv___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    ExprEvalRoutines,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000143, /* MIDL Version 6.0.323 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION dhcpsrv_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE dhcpsrv_DispatchTable = 
    {
    41,
    dhcpsrv_table
    };

static const SERVER_ROUTINE dhcpsrv_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)R_DhcpCreateSubnet,
    (SERVER_ROUTINE)R_DhcpSetSubnetInfo,
    (SERVER_ROUTINE)R_DhcpGetSubnetInfo,
    (SERVER_ROUTINE)R_DhcpEnumSubnets,
    (SERVER_ROUTINE)R_DhcpAddSubnetElement,
    (SERVER_ROUTINE)R_DhcpEnumSubnetElements,
    (SERVER_ROUTINE)R_DhcpRemoveSubnetElement,
    (SERVER_ROUTINE)R_DhcpDeleteSubnet,
    (SERVER_ROUTINE)R_DhcpCreateOption,
    (SERVER_ROUTINE)R_DhcpSetOptionInfo,
    (SERVER_ROUTINE)R_DhcpGetOptionInfo,
    (SERVER_ROUTINE)R_DhcpRemoveOption,
    (SERVER_ROUTINE)R_DhcpSetOptionValue,
    (SERVER_ROUTINE)R_DhcpGetOptionValue,
    (SERVER_ROUTINE)R_DhcpEnumOptionValues,
    (SERVER_ROUTINE)R_DhcpRemoveOptionValue,
    (SERVER_ROUTINE)R_DhcpCreateClientInfo,
    (SERVER_ROUTINE)R_DhcpSetClientInfo,
    (SERVER_ROUTINE)R_DhcpGetClientInfo,
    (SERVER_ROUTINE)R_DhcpDeleteClientInfo,
    (SERVER_ROUTINE)R_DhcpEnumSubnetClients,
    (SERVER_ROUTINE)R_DhcpGetClientOptions,
    (SERVER_ROUTINE)R_DhcpGetMibInfo,
    (SERVER_ROUTINE)R_DhcpEnumOptions,
    (SERVER_ROUTINE)R_DhcpSetOptionValues,
    (SERVER_ROUTINE)R_DhcpServerSetConfig,
    (SERVER_ROUTINE)R_DhcpServerGetConfig,
    (SERVER_ROUTINE)R_DhcpScanDatabase,
    (SERVER_ROUTINE)R_DhcpGetVersion,
    (SERVER_ROUTINE)R_DhcpAddSubnetElementV4,
    (SERVER_ROUTINE)R_DhcpEnumSubnetElementsV4,
    (SERVER_ROUTINE)R_DhcpRemoveSubnetElementV4,
    (SERVER_ROUTINE)R_DhcpCreateClientInfoV4,
    (SERVER_ROUTINE)R_DhcpSetClientInfoV4,
    (SERVER_ROUTINE)R_DhcpGetClientInfoV4,
    (SERVER_ROUTINE)R_DhcpEnumSubnetClientsV4,
    (SERVER_ROUTINE)R_DhcpSetSuperScopeV4,
    (SERVER_ROUTINE)R_DhcpGetSuperScopeInfoV4,
    (SERVER_ROUTINE)R_DhcpDeleteSuperScopeV4,
    (SERVER_ROUTINE)R_DhcpServerSetConfigV4,
    (SERVER_ROUTINE)R_DhcpServerGetConfigV4
    };

static const MIDL_SERVER_INFO dhcpsrv_ServerInfo = 
    {
    &dhcpsrv_StubDesc,
    dhcpsrv_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    dhcpsrv_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0323 */
/* Compiler settings for dhcp_srv.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, oldnames, robust dhcp_bug_compatibility
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#include <string.h>
#include "dhcp_srv.h"

#define TYPE_FORMAT_STRING_SIZE   1331                              
#define PROC_FORMAT_STRING_SIZE   2441                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: dhcpsrv, ver. 1.0,
   GUID={0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}} */


extern const MIDL_SERVER_INFO dhcpsrv_ServerInfo;

extern RPC_DISPATCH_TABLE dhcpsrv_DispatchTable;

static const RPC_SERVER_INTERFACE dhcpsrv___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &dhcpsrv_DispatchTable,
    0,
    0,
    0,
    &dhcpsrv_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE dhcpsrv_ServerIfHandle = (RPC_IF_HANDLE)& dhcpsrv___RpcServerInterface;

extern const MIDL_STUB_DESC dhcpsrv_StubDesc;

extern const EXPR_EVAL ExprEvalRoutines[];

#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure R_DhcpCreateSubnet */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 10 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 14 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 22 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 32 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 34 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 36 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 38 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 40 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 42 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 44 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 46 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 48 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Return value */

/* 50 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 52 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 54 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSubnetInfo */

/* 56 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 58 */	NdrFcLong( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x1 ),	/* 1 */
/* 64 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 66 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 68 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 70 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 72 */	NdrFcShort( 0x8 ),	/* 8 */
/* 74 */	NdrFcShort( 0x8 ),	/* 8 */
/* 76 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 78 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* 0 */
/* 84 */	NdrFcShort( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 88 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 90 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 92 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 94 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 96 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 98 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 100 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 102 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 104 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 108 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSubnetInfo */

/* 112 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x2 ),	/* 2 */
/* 120 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 122 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 124 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 126 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 128 */	NdrFcShort( 0x8 ),	/* 8 */
/* 130 */	NdrFcShort( 0x8 ),	/* 8 */
/* 132 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 134 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
/* 138 */	NdrFcShort( 0x0 ),	/* 0 */
/* 140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 142 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 144 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 146 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 148 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 152 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 156 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 158 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 160 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Return value */

/* 162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 164 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnets */

/* 168 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0x3 ),	/* 3 */
/* 176 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 178 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 180 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 182 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 184 */	NdrFcShort( 0x24 ),	/* 36 */
/* 186 */	NdrFcShort( 0x5c ),	/* 92 */
/* 188 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 190 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 192 */	NdrFcShort( 0x1 ),	/* 1 */
/* 194 */	NdrFcShort( 0x0 ),	/* 0 */
/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 200 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 202 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 204 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 206 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 208 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 212 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 214 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 216 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumInfo */

/* 218 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 220 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 222 */	NdrFcShort( 0x48 ),	/* Type Offset=72 */

	/* Parameter ElementsRead */

/* 224 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 226 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 228 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 230 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 232 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 236 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 238 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElement */

/* 242 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 244 */	NdrFcLong( 0x0 ),	/* 0 */
/* 248 */	NdrFcShort( 0x4 ),	/* 4 */
/* 250 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 252 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 254 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 256 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 258 */	NdrFcShort( 0x8 ),	/* 8 */
/* 260 */	NdrFcShort( 0x8 ),	/* 8 */
/* 262 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 264 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 268 */	NdrFcShort( 0x2 ),	/* 2 */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 274 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 276 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 278 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 280 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 282 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 284 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 286 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 288 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 290 */	NdrFcShort( 0xe2 ),	/* Type Offset=226 */

	/* Return value */

/* 292 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 294 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 296 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElements */

/* 298 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 300 */	NdrFcLong( 0x0 ),	/* 0 */
/* 304 */	NdrFcShort( 0x5 ),	/* 5 */
/* 306 */	NdrFcShort( 0x48 ),	/* ia64, axp64 Stack size/offset = 72 */
/* 308 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 310 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 312 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 314 */	NdrFcShort( 0x32 ),	/* 50 */
/* 316 */	NdrFcShort( 0x5c ),	/* 92 */
/* 318 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 320 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 322 */	NdrFcShort( 0x3 ),	/* 3 */
/* 324 */	NdrFcShort( 0x0 ),	/* 0 */
/* 326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 328 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 330 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 332 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 334 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 336 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 338 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 340 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 342 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 344 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 346 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 348 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 350 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 354 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 356 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 360 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 362 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 364 */	NdrFcShort( 0xf2 ),	/* Type Offset=242 */

	/* Parameter ElementsRead */

/* 366 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 368 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 370 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 372 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 374 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 378 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 380 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 382 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElement */

/* 384 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 386 */	NdrFcLong( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x6 ),	/* 6 */
/* 392 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 394 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 396 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 398 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 400 */	NdrFcShort( 0xe ),	/* 14 */
/* 402 */	NdrFcShort( 0x8 ),	/* 8 */
/* 404 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 406 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 410 */	NdrFcShort( 0x2 ),	/* 2 */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 416 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 418 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 420 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 422 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 424 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 426 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 428 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 430 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 432 */	NdrFcShort( 0xe2 ),	/* Type Offset=226 */

	/* Parameter ForceFlag */

/* 434 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 436 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 438 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 440 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 442 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 444 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSubnet */

/* 446 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 448 */	NdrFcLong( 0x0 ),	/* 0 */
/* 452 */	NdrFcShort( 0x7 ),	/* 7 */
/* 454 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 456 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 458 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 460 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 462 */	NdrFcShort( 0xe ),	/* 14 */
/* 464 */	NdrFcShort( 0x8 ),	/* 8 */
/* 466 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 468 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 470 */	NdrFcShort( 0x0 ),	/* 0 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 476 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 478 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 480 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 482 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 484 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 486 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 488 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ForceFlag */

/* 490 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 492 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 494 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 496 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 498 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 500 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateOption */

/* 502 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 504 */	NdrFcLong( 0x0 ),	/* 0 */
/* 508 */	NdrFcShort( 0x8 ),	/* 8 */
/* 510 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 512 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 514 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 516 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 518 */	NdrFcShort( 0x8 ),	/* 8 */
/* 520 */	NdrFcShort( 0x8 ),	/* 8 */
/* 522 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 524 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 528 */	NdrFcShort( 0x4 ),	/* 4 */
/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
/* 532 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 534 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 536 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 538 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 540 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 542 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 544 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 546 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 548 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 550 */	NdrFcShort( 0x19a ),	/* Type Offset=410 */

	/* Return value */

/* 552 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 554 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 556 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionInfo */

/* 558 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 560 */	NdrFcLong( 0x0 ),	/* 0 */
/* 564 */	NdrFcShort( 0x9 ),	/* 9 */
/* 566 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 568 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 570 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 572 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 574 */	NdrFcShort( 0x8 ),	/* 8 */
/* 576 */	NdrFcShort( 0x8 ),	/* 8 */
/* 578 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 580 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 582 */	NdrFcShort( 0x0 ),	/* 0 */
/* 584 */	NdrFcShort( 0x4 ),	/* 4 */
/* 586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 588 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 590 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 592 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 594 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 596 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 598 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 600 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 602 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 604 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 606 */	NdrFcShort( 0x19a ),	/* Type Offset=410 */

	/* Return value */

/* 608 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 610 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 612 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionInfo */

/* 614 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 616 */	NdrFcLong( 0x0 ),	/* 0 */
/* 620 */	NdrFcShort( 0xa ),	/* 10 */
/* 622 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 624 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 626 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 628 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 630 */	NdrFcShort( 0x8 ),	/* 8 */
/* 632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 634 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 636 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 638 */	NdrFcShort( 0x4 ),	/* 4 */
/* 640 */	NdrFcShort( 0x0 ),	/* 0 */
/* 642 */	NdrFcShort( 0x0 ),	/* 0 */
/* 644 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 646 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 648 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 650 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 652 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 654 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 658 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 660 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 662 */	NdrFcShort( 0x1b6 ),	/* Type Offset=438 */

	/* Return value */

/* 664 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 666 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 668 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOption */

/* 670 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 672 */	NdrFcLong( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0xb ),	/* 11 */
/* 678 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 680 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 682 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 684 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 686 */	NdrFcShort( 0x8 ),	/* 8 */
/* 688 */	NdrFcShort( 0x8 ),	/* 8 */
/* 690 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 692 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 694 */	NdrFcShort( 0x0 ),	/* 0 */
/* 696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 700 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 702 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 704 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 706 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 708 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 710 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 712 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 714 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 716 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 718 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValue */

/* 720 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 722 */	NdrFcLong( 0x0 ),	/* 0 */
/* 726 */	NdrFcShort( 0xc ),	/* 12 */
/* 728 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 730 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 732 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 734 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 736 */	NdrFcShort( 0x8 ),	/* 8 */
/* 738 */	NdrFcShort( 0x8 ),	/* 8 */
/* 740 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 742 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 746 */	NdrFcShort( 0x5 ),	/* 5 */
/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 750 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 752 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 754 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 756 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 758 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 760 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 762 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 764 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 766 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 768 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter OptionValue */

/* 770 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 772 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 774 */	NdrFcShort( 0x18a ),	/* Type Offset=394 */

	/* Return value */

/* 776 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 778 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 780 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionValue */

/* 782 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 784 */	NdrFcLong( 0x0 ),	/* 0 */
/* 788 */	NdrFcShort( 0xd ),	/* 13 */
/* 790 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 792 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 794 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 796 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 798 */	NdrFcShort( 0x8 ),	/* 8 */
/* 800 */	NdrFcShort( 0x8 ),	/* 8 */
/* 802 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 804 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 806 */	NdrFcShort( 0x4 ),	/* 4 */
/* 808 */	NdrFcShort( 0x1 ),	/* 1 */
/* 810 */	NdrFcShort( 0x0 ),	/* 0 */
/* 812 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 814 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 816 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 818 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 820 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 822 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 824 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 826 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 828 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 830 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter OptionValue */

/* 832 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 834 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 836 */	NdrFcShort( 0x204 ),	/* Type Offset=516 */

	/* Return value */

/* 838 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 840 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 842 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptionValues */

/* 844 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 846 */	NdrFcLong( 0x0 ),	/* 0 */
/* 850 */	NdrFcShort( 0xe ),	/* 14 */
/* 852 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 854 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 856 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 858 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 860 */	NdrFcShort( 0x24 ),	/* 36 */
/* 862 */	NdrFcShort( 0x5c ),	/* 92 */
/* 864 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 866 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 868 */	NdrFcShort( 0x5 ),	/* 5 */
/* 870 */	NdrFcShort( 0x1 ),	/* 1 */
/* 872 */	NdrFcShort( 0x0 ),	/* 0 */
/* 874 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 876 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 878 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 880 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 882 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 884 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 886 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter ResumeHandle */

/* 888 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 890 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 892 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 894 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 896 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 898 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionValues */

/* 900 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 902 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 904 */	NdrFcShort( 0x21c ),	/* Type Offset=540 */

	/* Parameter OptionsRead */

/* 906 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 908 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 910 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 912 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 914 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 916 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 918 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 920 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 922 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOptionValue */

/* 924 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 926 */	NdrFcLong( 0x0 ),	/* 0 */
/* 930 */	NdrFcShort( 0xf ),	/* 15 */
/* 932 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 934 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 936 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 938 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 940 */	NdrFcShort( 0x8 ),	/* 8 */
/* 942 */	NdrFcShort( 0x8 ),	/* 8 */
/* 944 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 946 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 948 */	NdrFcShort( 0x0 ),	/* 0 */
/* 950 */	NdrFcShort( 0x1 ),	/* 1 */
/* 952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 956 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 958 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 960 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 962 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 964 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 966 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 968 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 970 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 972 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Return value */

/* 974 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 976 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 978 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfo */

/* 980 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 982 */	NdrFcLong( 0x0 ),	/* 0 */
/* 986 */	NdrFcShort( 0x10 ),	/* 16 */
/* 988 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 990 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 992 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 994 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 996 */	NdrFcShort( 0x0 ),	/* 0 */
/* 998 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1000 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1002 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1004 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1006 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1008 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1010 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1012 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1014 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1016 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1018 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1020 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1022 */	NdrFcShort( 0x24e ),	/* Type Offset=590 */

	/* Return value */

/* 1024 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1026 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1028 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfo */

/* 1030 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1032 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1036 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1038 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1040 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1042 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1044 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1046 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1048 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1050 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1052 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1054 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1056 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1058 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1062 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1064 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1066 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1068 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1070 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1072 */	NdrFcShort( 0x24e ),	/* Type Offset=590 */

	/* Return value */

/* 1074 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1076 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1078 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfo */

/* 1080 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1082 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1086 */	NdrFcShort( 0x12 ),	/* 18 */
/* 1088 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1090 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1092 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1094 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1096 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1098 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1100 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1102 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1104 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1106 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1110 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1112 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1114 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1116 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 1118 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1120 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1122 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Parameter ClientInfo */

/* 1124 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1126 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1128 */	NdrFcShort( 0x2a6 ),	/* Type Offset=678 */

	/* Return value */

/* 1130 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1132 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1134 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteClientInfo */

/* 1136 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1138 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1142 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1144 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1146 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1148 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1150 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1156 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1158 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1162 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1166 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1168 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1170 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1172 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1174 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1176 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1178 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Return value */

/* 1180 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1182 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClients */

/* 1186 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1188 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1192 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1194 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 1196 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1198 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1200 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1202 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1204 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1206 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1208 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1210 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1216 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1218 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1220 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1222 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1224 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1226 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1228 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1230 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1232 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1236 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1238 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 1242 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1244 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1246 */	NdrFcShort( 0x2ae ),	/* Type Offset=686 */

	/* Parameter ClientsRead */

/* 1248 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1250 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1252 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 1254 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1256 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 1258 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1260 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1262 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 1264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientOptions */

/* 1266 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1268 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1272 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1274 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1276 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1278 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1280 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1282 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1284 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1286 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1288 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1290 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1296 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1298 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1300 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1302 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientIpAddress */

/* 1304 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1306 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1308 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientSubnetMask */

/* 1310 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1312 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1314 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientOptions */

/* 1316 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1318 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1320 */	NdrFcShort( 0x2dc ),	/* Type Offset=732 */

	/* Return value */

/* 1322 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1324 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1326 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetMibInfo */

/* 1328 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1330 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1334 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1336 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1338 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1340 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1342 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1346 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1348 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1350 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1352 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1358 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1360 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1362 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1364 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MibInfo */

/* 1366 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1368 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1370 */	NdrFcShort( 0x2f4 ),	/* Type Offset=756 */

	/* Return value */

/* 1372 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1374 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptions */

/* 1378 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1380 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1384 */	NdrFcShort( 0x17 ),	/* 23 */
/* 1386 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 1388 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1390 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1392 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1394 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1396 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1398 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 1400 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1402 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1404 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1408 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1410 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1412 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1414 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 1416 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1418 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1420 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1422 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1424 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1426 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Options */

/* 1428 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1430 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1432 */	NdrFcShort( 0x330 ),	/* Type Offset=816 */

	/* Parameter OptionsRead */

/* 1434 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1436 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1438 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 1440 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1442 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1444 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1446 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1448 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 1450 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValues */

/* 1452 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1454 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1458 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1460 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1462 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1464 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1466 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1470 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1472 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1474 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1476 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1478 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1480 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1482 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1484 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1486 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1488 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 1490 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1492 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1494 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter OptionValues */

/* 1496 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1498 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1500 */	NdrFcShort( 0x23a ),	/* Type Offset=570 */

	/* Return value */

/* 1502 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1504 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1506 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfig */

/* 1508 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1510 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1514 */	NdrFcShort( 0x19 ),	/* 25 */
/* 1516 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1518 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1520 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1522 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1524 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1526 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1528 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1530 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1532 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1540 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1542 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1544 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 1546 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1548 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1550 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 1552 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1554 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1556 */	NdrFcShort( 0x366 ),	/* Type Offset=870 */

	/* Return value */

/* 1558 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1560 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfig */

/* 1564 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1566 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1570 */	NdrFcShort( 0x1a ),	/* 26 */
/* 1572 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1574 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1576 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1578 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1580 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1582 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1584 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1586 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1588 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1592 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1594 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1596 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1598 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1600 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 1602 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1604 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1606 */	NdrFcShort( 0x386 ),	/* Type Offset=902 */

	/* Return value */

/* 1608 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1610 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1612 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpScanDatabase */

/* 1614 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1616 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1620 */	NdrFcShort( 0x1b ),	/* 27 */
/* 1622 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1624 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1626 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1628 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1630 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1634 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1636 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1638 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1640 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1642 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1644 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1646 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1648 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1650 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1652 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1654 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter FixFlag */

/* 1658 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1660 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1662 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScanList */

/* 1664 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1666 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1668 */	NdrFcShort( 0x38e ),	/* Type Offset=910 */

	/* Return value */

/* 1670 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1672 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1674 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetVersion */

/* 1676 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1678 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1682 */	NdrFcShort( 0x1c ),	/* 28 */
/* 1684 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1686 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1688 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1690 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1692 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1694 */	NdrFcShort( 0x40 ),	/* 64 */
/* 1696 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1698 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1700 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1702 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1704 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1706 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1708 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1710 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1712 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MajorVersion */

/* 1714 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1716 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1718 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter MinorVersion */

/* 1720 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1722 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1726 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1728 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElementV4 */

/* 1732 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1734 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1738 */	NdrFcShort( 0x1d ),	/* 29 */
/* 1740 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1742 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1744 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1746 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1748 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1750 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1752 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1754 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1758 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1760 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1762 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1764 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1766 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1768 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1770 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1772 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1774 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 1776 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1778 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1780 */	NdrFcShort( 0x410 ),	/* Type Offset=1040 */

	/* Return value */

/* 1782 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1784 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1786 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElementsV4 */

/* 1788 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1790 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1794 */	NdrFcShort( 0x1e ),	/* 30 */
/* 1796 */	NdrFcShort( 0x48 ),	/* ia64, axp64 Stack size/offset = 72 */
/* 1798 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1800 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1802 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1804 */	NdrFcShort( 0x32 ),	/* 50 */
/* 1806 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1808 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 1810 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1812 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1814 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1818 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1820 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1822 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1824 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1826 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1828 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1830 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 1832 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1834 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1836 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1838 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1840 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1842 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1844 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1846 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1848 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 1850 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1852 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1854 */	NdrFcShort( 0x420 ),	/* Type Offset=1056 */

	/* Parameter ElementsRead */

/* 1856 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1858 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 1860 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 1862 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1864 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 1866 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1868 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1870 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 1872 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElementV4 */

/* 1874 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1876 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1880 */	NdrFcShort( 0x1f ),	/* 31 */
/* 1882 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1884 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1886 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1888 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1890 */	NdrFcShort( 0xe ),	/* 14 */
/* 1892 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1894 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1896 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1898 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1900 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1902 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1904 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1906 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1908 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1910 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1912 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1914 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1916 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 1918 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1920 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1922 */	NdrFcShort( 0x410 ),	/* Type Offset=1040 */

	/* Parameter ForceFlag */

/* 1924 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1926 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1928 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 1930 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1932 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfoV4 */

/* 1936 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1938 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1942 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1944 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1946 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1948 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1950 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1954 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1956 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1958 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1960 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1962 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1964 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1966 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1968 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1970 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1972 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1974 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1976 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1978 */	NdrFcShort( 0x452 ),	/* Type Offset=1106 */

	/* Return value */

/* 1980 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1982 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1984 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfoV4 */

/* 1986 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1988 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1992 */	NdrFcShort( 0x21 ),	/* 33 */
/* 1994 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1996 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1998 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2000 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2004 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2006 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2008 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 2010 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2012 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2014 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2016 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2018 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2020 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2022 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 2024 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2026 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2028 */	NdrFcShort( 0x452 ),	/* Type Offset=1106 */

	/* Return value */

/* 2030 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2032 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2034 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfoV4 */

/* 2036 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2038 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2042 */	NdrFcShort( 0x22 ),	/* 34 */
/* 2044 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2046 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2048 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2050 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2052 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2054 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2056 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2058 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 2060 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2062 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2064 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2066 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2068 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2070 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2072 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 2074 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2076 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2078 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Parameter ClientInfo */

/* 2080 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2082 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2084 */	NdrFcShort( 0x476 ),	/* Type Offset=1142 */

	/* Return value */

/* 2086 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2088 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClientsV4 */

/* 2092 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2094 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2098 */	NdrFcShort( 0x23 ),	/* 35 */
/* 2100 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 2102 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2104 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2106 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2108 */	NdrFcShort( 0x2c ),	/* 44 */
/* 2110 */	NdrFcShort( 0x5c ),	/* 92 */
/* 2112 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 2114 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2116 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2122 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2124 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2126 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2128 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2130 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2132 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2134 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 2136 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2138 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2140 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 2142 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2144 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2146 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 2148 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2150 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2152 */	NdrFcShort( 0x47e ),	/* Type Offset=1150 */

	/* Parameter ClientsRead */

/* 2154 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2156 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 2160 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2162 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 2164 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2166 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2168 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 2170 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSuperScopeV4 */

/* 2172 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2174 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2178 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2180 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2182 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2184 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2186 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2188 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2190 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2192 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2194 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2202 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2204 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2206 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2208 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2210 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2212 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SuperScopeName */

/* 2216 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2218 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2220 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ChangeExisting */

/* 2222 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2224 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2228 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2230 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2232 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSuperScopeInfoV4 */

/* 2234 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2236 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2240 */	NdrFcShort( 0x25 ),	/* 37 */
/* 2242 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2244 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2246 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2248 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2252 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2254 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2256 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2258 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2264 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2266 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2268 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2270 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeTable */

/* 2272 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2274 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2276 */	NdrFcShort( 0x4ac ),	/* Type Offset=1196 */

	/* Return value */

/* 2278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2280 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSuperScopeV4 */

/* 2284 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2290 */	NdrFcShort( 0x26 ),	/* 38 */
/* 2292 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2294 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2296 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2298 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2302 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2304 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2306 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2312 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2314 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2316 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2318 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2320 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeName */

/* 2322 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2324 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2326 */	NdrFcShort( 0x4ee ),	/* Type Offset=1262 */

	/* Return value */

/* 2328 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2330 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2332 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfigV4 */

/* 2334 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2336 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2340 */	NdrFcShort( 0x27 ),	/* 39 */
/* 2342 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2344 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2346 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2348 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2350 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2354 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2356 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 2358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2360 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2364 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2366 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2368 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2370 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 2372 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2374 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 2378 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2380 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2382 */	NdrFcShort( 0x500 ),	/* Type Offset=1280 */

	/* Return value */

/* 2384 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2386 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2388 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfigV4 */

/* 2390 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2392 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2396 */	NdrFcShort( 0x28 ),	/* 40 */
/* 2398 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2400 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2402 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2404 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2408 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2410 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2412 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2414 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2416 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2420 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2422 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2424 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2426 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 2428 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2430 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2432 */	NdrFcShort( 0x52a ),	/* Type Offset=1322 */

	/* Return value */

/* 2434 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2436 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2438 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x0,	/* FC_RP */
/*  8 */	NdrFcShort( 0x18 ),	/* Offset= 24 (32) */
/* 10 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 12 */	NdrFcShort( 0x18 ),	/* 24 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* Offset= 8 (24) */
/* 18 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 20 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 22 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 24 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 26 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 28 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 30 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 32 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 34 */	NdrFcShort( 0x38 ),	/* 56 */
/* 36 */	NdrFcShort( 0x0 ),	/* 0 */
/* 38 */	NdrFcShort( 0xe ),	/* Offset= 14 (52) */
/* 40 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 42 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 44 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 46 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (10) */
/* 48 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 50 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 52 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 54 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 56 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 58 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 60 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 62 */	NdrFcShort( 0x2 ),	/* Offset= 2 (64) */
/* 64 */	
			0x12, 0x0,	/* FC_UP */
/* 66 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (32) */
/* 68 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 70 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 72 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
/* 76 */	
			0x12, 0x0,	/* FC_UP */
/* 78 */	NdrFcShort( 0xe ),	/* Offset= 14 (92) */
/* 80 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 82 */	NdrFcShort( 0x4 ),	/* 4 */
/* 84 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */
/* 88 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 90 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 92 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 94 */	NdrFcShort( 0x10 ),	/* 16 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x6 ),	/* Offset= 6 (104) */
/* 100 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 102 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 104 */	
			0x12, 0x0,	/* FC_UP */
/* 106 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (80) */
/* 108 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 110 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 112 */	
			0x11, 0x0,	/* FC_RP */
/* 114 */	NdrFcShort( 0x70 ),	/* Offset= 112 (226) */
/* 116 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 118 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 122 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 124 */	NdrFcShort( 0x2 ),	/* Offset= 2 (126) */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	NdrFcShort( 0x5 ),	/* 5 */
/* 130 */	NdrFcLong( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x1c ),	/* Offset= 28 (162) */
/* 136 */	NdrFcLong( 0x1 ),	/* 1 */
/* 140 */	NdrFcShort( 0x22 ),	/* Offset= 34 (174) */
/* 142 */	NdrFcLong( 0x2 ),	/* 2 */
/* 146 */	NdrFcShort( 0x20 ),	/* Offset= 32 (178) */
/* 148 */	NdrFcLong( 0x3 ),	/* 3 */
/* 152 */	NdrFcShort( 0xa ),	/* Offset= 10 (162) */
/* 154 */	NdrFcLong( 0x4 ),	/* 4 */
/* 158 */	NdrFcShort( 0x4 ),	/* Offset= 4 (162) */
/* 160 */	NdrFcShort( 0x0 ),	/* Offset= 0 (160) */
/* 162 */	
			0x12, 0x0,	/* FC_UP */
/* 164 */	NdrFcShort( 0x2 ),	/* Offset= 2 (166) */
/* 166 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 168 */	NdrFcShort( 0x8 ),	/* 8 */
/* 170 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 172 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 174 */	
			0x12, 0x0,	/* FC_UP */
/* 176 */	NdrFcShort( 0xffffff5a ),	/* Offset= -166 (10) */
/* 178 */	
			0x12, 0x0,	/* FC_UP */
/* 180 */	NdrFcShort( 0x1e ),	/* Offset= 30 (210) */
/* 182 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 184 */	NdrFcShort( 0x1 ),	/* 1 */
/* 186 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 190 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 192 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 194 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 196 */	NdrFcShort( 0x10 ),	/* 16 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	NdrFcShort( 0x6 ),	/* Offset= 6 (206) */
/* 202 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 204 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 206 */	
			0x12, 0x0,	/* FC_UP */
/* 208 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (182) */
/* 210 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 212 */	NdrFcShort( 0x10 ),	/* 16 */
/* 214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 216 */	NdrFcShort( 0x6 ),	/* Offset= 6 (222) */
/* 218 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 220 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 222 */	
			0x12, 0x0,	/* FC_UP */
/* 224 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (194) */
/* 226 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 228 */	NdrFcShort( 0x10 ),	/* 16 */
/* 230 */	NdrFcShort( 0x0 ),	/* 0 */
/* 232 */	NdrFcShort( 0x0 ),	/* Offset= 0 (232) */
/* 234 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 236 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 238 */	NdrFcShort( 0xffffff86 ),	/* Offset= -122 (116) */
/* 240 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 242 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 244 */	NdrFcShort( 0x2 ),	/* Offset= 2 (246) */
/* 246 */	
			0x12, 0x0,	/* FC_UP */
/* 248 */	NdrFcShort( 0x18 ),	/* Offset= 24 (272) */
/* 250 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 252 */	NdrFcShort( 0x0 ),	/* 0 */
/* 254 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 256 */	NdrFcShort( 0x0 ),	/* 0 */
/* 258 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 260 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 264 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 266 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 268 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (226) */
/* 270 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 272 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 274 */	NdrFcShort( 0x10 ),	/* 16 */
/* 276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 278 */	NdrFcShort( 0x6 ),	/* Offset= 6 (284) */
/* 280 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 282 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 284 */	
			0x12, 0x0,	/* FC_UP */
/* 286 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (250) */
/* 288 */	
			0x11, 0x0,	/* FC_RP */
/* 290 */	NdrFcShort( 0x78 ),	/* Offset= 120 (410) */
/* 292 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 294 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 296 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 298 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 300 */	NdrFcShort( 0x2 ),	/* Offset= 2 (302) */
/* 302 */	NdrFcShort( 0x10 ),	/* 16 */
/* 304 */	NdrFcShort( 0x8 ),	/* 8 */
/* 306 */	NdrFcLong( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 312 */	NdrFcLong( 0x1 ),	/* 1 */
/* 316 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 318 */	NdrFcLong( 0x2 ),	/* 2 */
/* 322 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 324 */	NdrFcLong( 0x3 ),	/* 3 */
/* 328 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (166) */
/* 330 */	NdrFcLong( 0x4 ),	/* 4 */
/* 334 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 336 */	NdrFcLong( 0x5 ),	/* 5 */
/* 340 */	NdrFcShort( 0xfffffeae ),	/* Offset= -338 (2) */
/* 342 */	NdrFcLong( 0x6 ),	/* 6 */
/* 346 */	NdrFcShort( 0xffffff68 ),	/* Offset= -152 (194) */
/* 348 */	NdrFcLong( 0x7 ),	/* 7 */
/* 352 */	NdrFcShort( 0xffffff62 ),	/* Offset= -158 (194) */
/* 354 */	NdrFcShort( 0x0 ),	/* Offset= 0 (354) */
/* 356 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 358 */	NdrFcShort( 0x18 ),	/* 24 */
/* 360 */	NdrFcShort( 0x0 ),	/* 0 */
/* 362 */	NdrFcShort( 0x0 ),	/* Offset= 0 (362) */
/* 364 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 366 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 368 */	NdrFcShort( 0xffffffb4 ),	/* Offset= -76 (292) */
/* 370 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 372 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 382 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 386 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 388 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 390 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (356) */
/* 392 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 394 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 396 */	NdrFcShort( 0x10 ),	/* 16 */
/* 398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 400 */	NdrFcShort( 0x6 ),	/* Offset= 6 (406) */
/* 402 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 404 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 406 */	
			0x12, 0x0,	/* FC_UP */
/* 408 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (372) */
/* 410 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 412 */	NdrFcShort( 0x30 ),	/* 48 */
/* 414 */	NdrFcShort( 0x0 ),	/* 0 */
/* 416 */	NdrFcShort( 0xe ),	/* Offset= 14 (430) */
/* 418 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 420 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 422 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 424 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (394) */
/* 426 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 428 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 430 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 432 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 434 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 436 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 438 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 440 */	NdrFcShort( 0x2 ),	/* Offset= 2 (442) */
/* 442 */	
			0x12, 0x0,	/* FC_UP */
/* 444 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (410) */
/* 446 */	
			0x11, 0x0,	/* FC_RP */
/* 448 */	NdrFcShort( 0x30 ),	/* Offset= 48 (496) */
/* 450 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 452 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 454 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 456 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 458 */	NdrFcShort( 0x2 ),	/* Offset= 2 (460) */
/* 460 */	NdrFcShort( 0x8 ),	/* 8 */
/* 462 */	NdrFcShort( 0x5 ),	/* 5 */
/* 464 */	NdrFcLong( 0x0 ),	/* 0 */
/* 468 */	NdrFcShort( 0x0 ),	/* Offset= 0 (468) */
/* 470 */	NdrFcLong( 0x1 ),	/* 1 */
/* 474 */	NdrFcShort( 0x0 ),	/* Offset= 0 (474) */
/* 476 */	NdrFcLong( 0x2 ),	/* 2 */
/* 480 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 482 */	NdrFcLong( 0x3 ),	/* 3 */
/* 486 */	NdrFcShort( 0xfffffec0 ),	/* Offset= -320 (166) */
/* 488 */	NdrFcLong( 0x4 ),	/* 4 */
/* 492 */	NdrFcShort( 0xfffffe16 ),	/* Offset= -490 (2) */
/* 494 */	NdrFcShort( 0x0 ),	/* Offset= 0 (494) */
/* 496 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 498 */	NdrFcShort( 0x10 ),	/* 16 */
/* 500 */	NdrFcShort( 0x0 ),	/* 0 */
/* 502 */	NdrFcShort( 0x0 ),	/* Offset= 0 (502) */
/* 504 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 506 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 508 */	NdrFcShort( 0xffffffc6 ),	/* Offset= -58 (450) */
/* 510 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 512 */	
			0x11, 0x0,	/* FC_RP */
/* 514 */	NdrFcShort( 0xffffff88 ),	/* Offset= -120 (394) */
/* 516 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 518 */	NdrFcShort( 0x2 ),	/* Offset= 2 (520) */
/* 520 */	
			0x12, 0x0,	/* FC_UP */
/* 522 */	NdrFcShort( 0x2 ),	/* Offset= 2 (524) */
/* 524 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 526 */	NdrFcShort( 0x18 ),	/* 24 */
/* 528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 530 */	NdrFcShort( 0x0 ),	/* Offset= 0 (530) */
/* 532 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 534 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 536 */	NdrFcShort( 0xffffff72 ),	/* Offset= -142 (394) */
/* 538 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 540 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 542 */	NdrFcShort( 0x2 ),	/* Offset= 2 (544) */
/* 544 */	
			0x12, 0x0,	/* FC_UP */
/* 546 */	NdrFcShort( 0x18 ),	/* Offset= 24 (570) */
/* 548 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 550 */	NdrFcShort( 0x0 ),	/* 0 */
/* 552 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 554 */	NdrFcShort( 0x0 ),	/* 0 */
/* 556 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 558 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 562 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 564 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 566 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (524) */
/* 568 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 570 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 572 */	NdrFcShort( 0x10 ),	/* 16 */
/* 574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 576 */	NdrFcShort( 0x6 ),	/* Offset= 6 (582) */
/* 578 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 580 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 582 */	
			0x12, 0x0,	/* FC_UP */
/* 584 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (548) */
/* 586 */	
			0x11, 0x0,	/* FC_RP */
/* 588 */	NdrFcShort( 0x2 ),	/* Offset= 2 (590) */
/* 590 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 592 */	NdrFcShort( 0x48 ),	/* 72 */
/* 594 */	NdrFcShort( 0x0 ),	/* 0 */
/* 596 */	NdrFcShort( 0x14 ),	/* Offset= 20 (616) */
/* 598 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 600 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 602 */	NdrFcShort( 0xfffffe68 ),	/* Offset= -408 (194) */
/* 604 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 606 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 608 */	NdrFcShort( 0xfffffe46 ),	/* Offset= -442 (166) */
/* 610 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 612 */	NdrFcShort( 0xfffffda6 ),	/* Offset= -602 (10) */
/* 614 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 616 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 618 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 620 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 622 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 624 */	
			0x11, 0x0,	/* FC_RP */
/* 626 */	NdrFcShort( 0x24 ),	/* Offset= 36 (662) */
/* 628 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 630 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 632 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 634 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 636 */	NdrFcShort( 0x2 ),	/* Offset= 2 (638) */
/* 638 */	NdrFcShort( 0x10 ),	/* 16 */
/* 640 */	NdrFcShort( 0x3 ),	/* 3 */
/* 642 */	NdrFcLong( 0x0 ),	/* 0 */
/* 646 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 648 */	NdrFcLong( 0x1 ),	/* 1 */
/* 652 */	NdrFcShort( 0xfffffe36 ),	/* Offset= -458 (194) */
/* 654 */	NdrFcLong( 0x2 ),	/* 2 */
/* 658 */	NdrFcShort( 0xfffffd70 ),	/* Offset= -656 (2) */
/* 660 */	NdrFcShort( 0x0 ),	/* Offset= 0 (660) */
/* 662 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 664 */	NdrFcShort( 0x18 ),	/* 24 */
/* 666 */	NdrFcShort( 0x0 ),	/* 0 */
/* 668 */	NdrFcShort( 0x0 ),	/* Offset= 0 (668) */
/* 670 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 672 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 674 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (628) */
/* 676 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 678 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 680 */	NdrFcShort( 0x2 ),	/* Offset= 2 (682) */
/* 682 */	
			0x12, 0x0,	/* FC_UP */
/* 684 */	NdrFcShort( 0xffffffa2 ),	/* Offset= -94 (590) */
/* 686 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 688 */	NdrFcShort( 0x2 ),	/* Offset= 2 (690) */
/* 690 */	
			0x12, 0x0,	/* FC_UP */
/* 692 */	NdrFcShort( 0x18 ),	/* Offset= 24 (716) */
/* 694 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 698 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 700 */	NdrFcShort( 0x0 ),	/* 0 */
/* 702 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 704 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 708 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 710 */	
			0x12, 0x0,	/* FC_UP */
/* 712 */	NdrFcShort( 0xffffff86 ),	/* Offset= -122 (590) */
/* 714 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 716 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 718 */	NdrFcShort( 0x10 ),	/* 16 */
/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 722 */	NdrFcShort( 0x6 ),	/* Offset= 6 (728) */
/* 724 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 726 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 728 */	
			0x12, 0x0,	/* FC_UP */
/* 730 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (694) */
/* 732 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 734 */	NdrFcShort( 0x2 ),	/* Offset= 2 (736) */
/* 736 */	
			0x12, 0x0,	/* FC_UP */
/* 738 */	NdrFcShort( 0x2 ),	/* Offset= 2 (740) */
/* 740 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 742 */	NdrFcShort( 0x10 ),	/* 16 */
/* 744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 746 */	NdrFcShort( 0x6 ),	/* Offset= 6 (752) */
/* 748 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 750 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 752 */	
			0x12, 0x0,	/* FC_UP */
/* 754 */	NdrFcShort( 0xffffff32 ),	/* Offset= -206 (548) */
/* 756 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 758 */	NdrFcShort( 0x2 ),	/* Offset= 2 (760) */
/* 760 */	
			0x12, 0x0,	/* FC_UP */
/* 762 */	NdrFcShort( 0x1c ),	/* Offset= 28 (790) */
/* 764 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 766 */	NdrFcShort( 0x10 ),	/* 16 */
/* 768 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 770 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 772 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 774 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 776 */	NdrFcShort( 0x10 ),	/* 16 */
/* 778 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 780 */	NdrFcShort( 0x24 ),	/* 36 */
/* 782 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 784 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 786 */	NdrFcShort( 0xffffffea ),	/* Offset= -22 (764) */
/* 788 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 790 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 792 */	NdrFcShort( 0x30 ),	/* 48 */
/* 794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 796 */	NdrFcShort( 0x10 ),	/* Offset= 16 (812) */
/* 798 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 800 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 802 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 804 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 806 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd7f ),	/* Offset= -641 (166) */
			0x8,		/* FC_LONG */
/* 810 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 812 */	
			0x12, 0x0,	/* FC_UP */
/* 814 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (774) */
/* 816 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 818 */	NdrFcShort( 0x2 ),	/* Offset= 2 (820) */
/* 820 */	
			0x12, 0x0,	/* FC_UP */
/* 822 */	NdrFcShort( 0x18 ),	/* Offset= 24 (846) */
/* 824 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 830 */	NdrFcShort( 0x0 ),	/* 0 */
/* 832 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 834 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 838 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 840 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 842 */	NdrFcShort( 0xfffffe50 ),	/* Offset= -432 (410) */
/* 844 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 846 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 848 */	NdrFcShort( 0x10 ),	/* 16 */
/* 850 */	NdrFcShort( 0x0 ),	/* 0 */
/* 852 */	NdrFcShort( 0x6 ),	/* Offset= 6 (858) */
/* 854 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 856 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 858 */	
			0x12, 0x0,	/* FC_UP */
/* 860 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (824) */
/* 862 */	
			0x11, 0x0,	/* FC_RP */
/* 864 */	NdrFcShort( 0xfffffeda ),	/* Offset= -294 (570) */
/* 866 */	
			0x11, 0x0,	/* FC_RP */
/* 868 */	NdrFcShort( 0x2 ),	/* Offset= 2 (870) */
/* 870 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 872 */	NdrFcShort( 0x38 ),	/* 56 */
/* 874 */	NdrFcShort( 0x0 ),	/* 0 */
/* 876 */	NdrFcShort( 0xe ),	/* Offset= 14 (890) */
/* 878 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 880 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 882 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 884 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 886 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 888 */	0x40,		/* FC_STRUCTPAD4 */
			0x5b,		/* FC_END */
/* 890 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 892 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 894 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 896 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 898 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 900 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 902 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 904 */	NdrFcShort( 0x2 ),	/* Offset= 2 (906) */
/* 906 */	
			0x12, 0x0,	/* FC_UP */
/* 908 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (870) */
/* 910 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 912 */	NdrFcShort( 0x2 ),	/* Offset= 2 (914) */
/* 914 */	
			0x12, 0x0,	/* FC_UP */
/* 916 */	NdrFcShort( 0x24 ),	/* Offset= 36 (952) */
/* 918 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 920 */	NdrFcShort( 0x8 ),	/* 8 */
/* 922 */	NdrFcShort( 0x0 ),	/* 0 */
/* 924 */	NdrFcShort( 0x0 ),	/* Offset= 0 (924) */
/* 926 */	0x8,		/* FC_LONG */
			0xd,		/* FC_ENUM16 */
/* 928 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 930 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 932 */	NdrFcShort( 0x0 ),	/* 0 */
/* 934 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 936 */	NdrFcShort( 0x0 ),	/* 0 */
/* 938 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 940 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 944 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 946 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 948 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (918) */
/* 950 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 952 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 954 */	NdrFcShort( 0x10 ),	/* 16 */
/* 956 */	NdrFcShort( 0x0 ),	/* 0 */
/* 958 */	NdrFcShort( 0x6 ),	/* Offset= 6 (964) */
/* 960 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 962 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 964 */	
			0x12, 0x0,	/* FC_UP */
/* 966 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (930) */
/* 968 */	
			0x11, 0x0,	/* FC_RP */
/* 970 */	NdrFcShort( 0x46 ),	/* Offset= 70 (1040) */
/* 972 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 974 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 976 */	NdrFcShort( 0x1 ),	/* 1 */
/* 978 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 980 */	NdrFcShort( 0x2 ),	/* Offset= 2 (982) */
/* 982 */	NdrFcShort( 0x8 ),	/* 8 */
/* 984 */	NdrFcShort( 0x5 ),	/* 5 */
/* 986 */	NdrFcLong( 0x0 ),	/* 0 */
/* 990 */	NdrFcShort( 0xfffffcc4 ),	/* Offset= -828 (162) */
/* 992 */	NdrFcLong( 0x1 ),	/* 1 */
/* 996 */	NdrFcShort( 0xfffffcca ),	/* Offset= -822 (174) */
/* 998 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1002 */	NdrFcShort( 0x10 ),	/* Offset= 16 (1018) */
/* 1004 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1008 */	NdrFcShort( 0xfffffcb2 ),	/* Offset= -846 (162) */
/* 1010 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1014 */	NdrFcShort( 0xfffffcac ),	/* Offset= -852 (162) */
/* 1016 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1016) */
/* 1018 */	
			0x12, 0x0,	/* FC_UP */
/* 1020 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1022) */
/* 1022 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1024 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1026 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1028 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1036) */
/* 1030 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1032 */	0x36,		/* FC_POINTER */
			0x2,		/* FC_CHAR */
/* 1034 */	0x43,		/* FC_STRUCTPAD7 */
			0x5b,		/* FC_END */
/* 1036 */	
			0x12, 0x0,	/* FC_UP */
/* 1038 */	NdrFcShort( 0xfffffcb4 ),	/* Offset= -844 (194) */
/* 1040 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 1042 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1044 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1046 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1046) */
/* 1048 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 1050 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1052 */	NdrFcShort( 0xffffffb0 ),	/* Offset= -80 (972) */
/* 1054 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1056 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1058 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1060) */
/* 1060 */	
			0x12, 0x0,	/* FC_UP */
/* 1062 */	NdrFcShort( 0x18 ),	/* Offset= 24 (1086) */
/* 1064 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1066 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1068 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1070 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1072 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1074 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1078 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1080 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1082 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1040) */
/* 1084 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1086 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1088 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1090 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1092 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1098) */
/* 1094 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1096 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1098 */	
			0x12, 0x0,	/* FC_UP */
/* 1100 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1064) */
/* 1102 */	
			0x11, 0x0,	/* FC_RP */
/* 1104 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1106) */
/* 1106 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1108 */	NdrFcShort( 0x50 ),	/* 80 */
/* 1110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1112 */	NdrFcShort( 0x16 ),	/* Offset= 22 (1134) */
/* 1114 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1116 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1118 */	NdrFcShort( 0xfffffc64 ),	/* Offset= -924 (194) */
/* 1120 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1122 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1124 */	NdrFcShort( 0xfffffc42 ),	/* Offset= -958 (166) */
/* 1126 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1128 */	NdrFcShort( 0xfffffba2 ),	/* Offset= -1118 (10) */
/* 1130 */	0x2,		/* FC_CHAR */
			0x43,		/* FC_STRUCTPAD7 */
/* 1132 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1134 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1136 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1138 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1140 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1142 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1144 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1146) */
/* 1146 */	
			0x12, 0x0,	/* FC_UP */
/* 1148 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1106) */
/* 1150 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1152 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1154) */
/* 1154 */	
			0x12, 0x0,	/* FC_UP */
/* 1156 */	NdrFcShort( 0x18 ),	/* Offset= 24 (1180) */
/* 1158 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1162 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1166 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1168 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1172 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1174 */	
			0x12, 0x0,	/* FC_UP */
/* 1176 */	NdrFcShort( 0xffffffba ),	/* Offset= -70 (1106) */
/* 1178 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1180 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1182 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1186 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1192) */
/* 1188 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1190 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1192 */	
			0x12, 0x0,	/* FC_UP */
/* 1194 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1158) */
/* 1196 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1198 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1200) */
/* 1200 */	
			0x12, 0x0,	/* FC_UP */
/* 1202 */	NdrFcShort( 0x2a ),	/* Offset= 42 (1244) */
/* 1204 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1206 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1210 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1218) */
/* 1212 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1214 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1216 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1218 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1220 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1222 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1226 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1230 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1232 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1236 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1238 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1240 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1204) */
/* 1242 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1244 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1246 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1250 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1256) */
/* 1252 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1254 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1256 */	
			0x12, 0x0,	/* FC_UP */
/* 1258 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1222) */
/* 1260 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1262 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1264 */	
			0x11, 0x0,	/* FC_RP */
/* 1266 */	NdrFcShort( 0xe ),	/* Offset= 14 (1280) */
/* 1268 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1270 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1272 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1274 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1276 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1278 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 1280 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1282 */	NdrFcShort( 0x50 ),	/* 80 */
/* 1284 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1286 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1306) */
/* 1288 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1290 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1292 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 1294 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1296 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1298 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1300 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 1302 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1304 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1306 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1308 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1310 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1312 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1314 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1316 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1318 */	
			0x12, 0x0,	/* FC_UP */
/* 1320 */	NdrFcShort( 0xffffffcc ),	/* Offset= -52 (1268) */
/* 1322 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1324 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1326) */
/* 1326 */	
			0x12, 0x0,	/* FC_UP */
/* 1328 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (1280) */

			0x0
        }
    };

static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR * )(pStubMsg->StackTop - 8);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR * )(pStubMsg->StackTop - 8);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static const EXPR_EVAL ExprEvalRoutines[] = 
    {
    dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000
    ,dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001
    };


static const unsigned short dhcpsrv_FormatStringOffsetTable[] =
    {
    0,
    56,
    112,
    168,
    242,
    298,
    384,
    446,
    502,
    558,
    614,
    670,
    720,
    782,
    844,
    924,
    980,
    1030,
    1080,
    1136,
    1186,
    1266,
    1328,
    1378,
    1452,
    1508,
    1564,
    1614,
    1676,
    1732,
    1788,
    1874,
    1936,
    1986,
    2036,
    2092,
    2172,
    2234,
    2284,
    2334,
    2390
    };


static const MIDL_STUB_DESC dhcpsrv_StubDesc = 
    {
    (void __RPC_FAR *)& dhcpsrv___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    ExprEvalRoutines,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000143, /* MIDL Version 6.0.323 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION dhcpsrv_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE dhcpsrv_DispatchTable = 
    {
    41,
    dhcpsrv_table
    };

static const SERVER_ROUTINE dhcpsrv_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)R_DhcpCreateSubnet,
    (SERVER_ROUTINE)R_DhcpSetSubnetInfo,
    (SERVER_ROUTINE)R_DhcpGetSubnetInfo,
    (SERVER_ROUTINE)R_DhcpEnumSubnets,
    (SERVER_ROUTINE)R_DhcpAddSubnetElement,
    (SERVER_ROUTINE)R_DhcpEnumSubnetElements,
    (SERVER_ROUTINE)R_DhcpRemoveSubnetElement,
    (SERVER_ROUTINE)R_DhcpDeleteSubnet,
    (SERVER_ROUTINE)R_DhcpCreateOption,
    (SERVER_ROUTINE)R_DhcpSetOptionInfo,
    (SERVER_ROUTINE)R_DhcpGetOptionInfo,
    (SERVER_ROUTINE)R_DhcpRemoveOption,
    (SERVER_ROUTINE)R_DhcpSetOptionValue,
    (SERVER_ROUTINE)R_DhcpGetOptionValue,
    (SERVER_ROUTINE)R_DhcpEnumOptionValues,
    (SERVER_ROUTINE)R_DhcpRemoveOptionValue,
    (SERVER_ROUTINE)R_DhcpCreateClientInfo,
    (SERVER_ROUTINE)R_DhcpSetClientInfo,
    (SERVER_ROUTINE)R_DhcpGetClientInfo,
    (SERVER_ROUTINE)R_DhcpDeleteClientInfo,
    (SERVER_ROUTINE)R_DhcpEnumSubnetClients,
    (SERVER_ROUTINE)R_DhcpGetClientOptions,
    (SERVER_ROUTINE)R_DhcpGetMibInfo,
    (SERVER_ROUTINE)R_DhcpEnumOptions,
    (SERVER_ROUTINE)R_DhcpSetOptionValues,
    (SERVER_ROUTINE)R_DhcpServerSetConfig,
    (SERVER_ROUTINE)R_DhcpServerGetConfig,
    (SERVER_ROUTINE)R_DhcpScanDatabase,
    (SERVER_ROUTINE)R_DhcpGetVersion,
    (SERVER_ROUTINE)R_DhcpAddSubnetElementV4,
    (SERVER_ROUTINE)R_DhcpEnumSubnetElementsV4,
    (SERVER_ROUTINE)R_DhcpRemoveSubnetElementV4,
    (SERVER_ROUTINE)R_DhcpCreateClientInfoV4,
    (SERVER_ROUTINE)R_DhcpSetClientInfoV4,
    (SERVER_ROUTINE)R_DhcpGetClientInfoV4,
    (SERVER_ROUTINE)R_DhcpEnumSubnetClientsV4,
    (SERVER_ROUTINE)R_DhcpSetSuperScopeV4,
    (SERVER_ROUTINE)R_DhcpGetSuperScopeInfoV4,
    (SERVER_ROUTINE)R_DhcpDeleteSuperScopeV4,
    (SERVER_ROUTINE)R_DhcpServerSetConfigV4,
    (SERVER_ROUTINE)R_DhcpServerGetConfigV4
    };

static const MIDL_SERVER_INFO dhcpsrv_ServerInfo = 
    {
    &dhcpsrv_StubDesc,
    dhcpsrv_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    dhcpsrv_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\dnsdb.c ===
/*++
   
Copyright (c) 1994 Microsoft Corporation

Module Name: 
    dnsdb.c

Abstract: 
    This module contains functions that work between Database and the 
    DhcpServer proper (more like database.c and other files).

    It helps implement Dynamic Dns Updates for the server side part.

Environment:
    User mode Win32 NT

--*/

#include "dhcppch.h"
#include <align.h>

LIST_ENTRY DhcpGlobalDnsCallbackList;
CRITICAL_SECTION DhcpGlobalDnsMemoryCriticalSection;
#define LOCK_MEM() EnterCriticalSection(&DhcpGlobalDnsMemoryCriticalSection)
#define UNLOCK_MEM() LeaveCriticalSection(&DhcpGlobalDnsMemoryCriticalSection)

//
//  To get better response, and to prevent memory leaks in this module,
//  the memory is managed with the following functions.
//  Only one structure is allocated with this function... This is the DNS context
//  structure (that will be defined later) -- that is used so that when DNS
//  calls back with a success code, we can clean up the database.
//
//  The three functions are implemented near the end.
//
LPVOID
DhcpDnsAllocateMemory(
    IN ULONG Size
    );

VOID
DhcpDnsFreeMemory(
    IN OUT LPVOID AllocatedPtr
    );

VOID
DhcpDnsAsyncDelete(
    IN DHCP_IP_ADDRESS IpAddress,
    IN LPWSTR ClientName,
    IN BYTE AddressState
    );

VOID
DhcpDnsAsyncAdd(
    IN DHCP_IP_ADDRESS IpAddress,
    IN LPWSTR ClientName,
    IN BYTE AddressState
);

VOID
DhcpDoDynDnsRefresh(
    IN DHCP_IP_ADDRESS IpAddress
    )
/*++

Routine Description:
    This routine reads the database for the current address specified and
    if the database indicates the record has not yet been registered (or
    de-registered ) with the DNS server yet, it refreshes the information
    without writing to the database.

    N.B -- It is assumed that the database lock is already taken.

Argument:
    IpAddress of record to refresh.

--*/
{
    DWORD Error, Size;
    CHAR AddressState;
    LPWSTR ClientName = NULL;

    if( USE_NO_DNS ) return;

    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        (PVOID) &IpAddress,
        sizeof(IpAddress)
        );

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "JetOpenKey(%s):%ld\n",
                   inet_ntoa(*(struct in_addr *)&IpAddress), Error)); 
        return;
    }

    Size = sizeof(AddressState);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        &Size
    );

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "JetGetValue(State, %s):%ld\n",
                   inet_ntoa(*(struct in_addr *)&IpAddress), Error));
        return;
    }

    //
    // If the record has the "yet-to-register" bit cleared, then no DNS
    // activity is pending so far as this record is concerned.
    //

    if( !IsAddressUnRegistered(AddressState) ) {
        DhcpPrint((DEBUG_ERRORS, "IsAddressUnRegistred(%2X,%s)=FALSE\n",
                   AddressState, inet_ntoa(*(struct in_addr *)&IpAddress)));
        return;
    }

    Size = 0;
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
        &ClientName,
        &Size
    );

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "JetGetValue(Name, %s):%ld\n",
                   inet_ntoa(*(struct in_addr *)&IpAddress), Error));
        return;
    }

    if( NULL == ClientName ) {
        //
        // Cannot have no name and the UNREGISTERED bit set..
        //
        DhcpAssert(FALSE);
        return;
    }

    //
    // Delete it in DNS if it is yet to be de-registered, otherwise just 
    // register with DNS again.
    //

    if( IsAddressDeleted(AddressState) ) {
        DhcpDnsAsyncDelete(IpAddress, ClientName, AddressState);
    } else if( IsAddressUnRegistered(AddressState) ) {
        DhcpDnsAsyncAdd(IpAddress, ClientName, AddressState);
    }

    if( ClientName ) DhcpFreeMemory(ClientName);
}

BOOL
DhcpDoDynDnsCheckDelete(
    IN DHCP_IP_ADDRESS IpAddress
)
/*++

Routine Description:
    This routine is called in several places, and it checks to see if DNS
    activity needs to be done before deleting the record for the given ip
    address.  If the given IP address has been successfully registered with
    DNS and requires to be removed (cleanup bit set), then it schedules a
    DNS de-registration and over-writes the time information in the record
    to indicate the time this scheduling has happened.....
    Also, the hw-address is munged so that that particular hw-addrses may
    appear in some other record without violating the hw-address
    uniqueness consistency of the database.  (No munging happens for
    reservations ofcourse).

    N.B  The database lock must be taken and the record pointer must point
    to the record given the by the IP address above..

Return Value:
    TRUE -- the record can be deleted either because no pending DNS
    activity for the record or because the record was deleted long back
    before and the DNS de-registration hasn't succeeded -- no point
    retrying again..

    FALSE -- DNS activity has been scheduled... record should not be
    deleted yet.

--*/
{
    DWORD Error, Size;
    BYTE OldAddressState, AddressState;
    LPWSTR ClientName;
    BYTE DummyHwAddress[sizeof(DWORD)+1+4];

    if( USE_NO_DNS ) return TRUE;

    DhcpPrint((DEBUG_DNS, "DhcpDoDynDnsCheckDelete %s\n",
               inet_ntoa( * (struct in_addr *) &IpAddress)));

    //
    // Get Address state information.  
    //

    Size = sizeof(AddressState);
    if( ERROR_SUCCESS != (Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        &Size))) {
        DhcpPrint((DEBUG_ERRORS, "Failed to get state: %ld\n", Error));
        return TRUE;
    }
    OldAddressState = AddressState;

    if( !IsAddressCleanupRequired(OldAddressState)) {
        DhcpPrint((DEBUG_DNS, "Deleting record %s because "
                   "cleanup not required\n",
                   inet_ntoa(*(struct in_addr *)&IpAddress)));

        //
        // OK to delete if no cleanup required for this record..
        //
        return TRUE;
    }

    Size = 0;
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
        &ClientName,
        &Size
        );

    if(ERROR_SUCCESS != Error) {
        DhcpAssert(FALSE);
        DhcpPrint((DEBUG_ERRORS, "Could not get Client Name!\n"));
        return TRUE;
    }

    //
    // Set AddressState to DOOMED so that this record is not
    // mistaken for a valid IP address..
    //
    SetAddressStateDoomed(AddressState);

    //
    // Schedule a DNS delete for the record..
    //
    DhcpDnsAsyncDelete(IpAddress, ClientName, AddressState);

    //
    // Free ClientName as it was allocated by the DhcpJetGetValue
    // function. 
    if(ClientName) DhcpFreeMemory(ClientName); ClientName = NULL;

    //
    // Now set the address state OR'ed with DELETE bit on.
    //
    AddressState = AddressDeleted(AddressState);
    AddressState = AddressUnRegistered(AddressState);

    //
    // Now write this back onto the record.
    //
    Error = DhcpJetPrepareUpdate(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        &IpAddress,
        sizeof(IpAddress),
        FALSE
        );

    if(ERROR_SUCCESS != Error) {
        DhcpAssert(FALSE);
        DhcpPrint((DEBUG_ERRORS, "Could not write to "
                   "the database..:%ld\n", Error));
        //
        // Write failure?  just delete the darned record.
        //
        return TRUE;
    }

    //
    // Now munge hw-address if this is not a reservation..
    //

    Size = sizeof(AddressState);
    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        Size);
    DhcpAssert( ERROR_SUCCESS == Error );

    if( !DhcpServerIsAddressReserved( 
        DhcpGetCurrentServer(), IpAddress )) { 
        DhcpPrint((DEBUG_DNS, "Munging hw address "
                   "of non reservation client (deletion)\n"));

        Size = sizeof(DummyHwAddress);
        memset(DummyHwAddress, 0, sizeof(DummyHwAddress));
        memcpy(DummyHwAddress, (LPBYTE)&IpAddress, sizeof(IpAddress));
        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
            DummyHwAddress,
            Size
        );
        DhcpAssert(ERROR_SUCCESS == Error );
    } else {
        DhcpPrint((DEBUG_DNS, "Not munging hw addr of reservation..\n"));
    }

    //
    // If old address deleted, check time stamp to figure out if we need 
    // to delete the record or just wait a while to try DNS de-registration
    // again.. 
    //

    if( IsAddressDeleted(OldAddressState) ) do {
        DATE_TIME TimeDiff, TimeNow = DhcpGetDateTime();
        FILETIME  LeaseExpires;

        //
        // Check if the time is lesser than now; If not, set lease expiry
        // time to now. 
        //

        Size = sizeof(LeaseExpires);
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
            &LeaseExpires,
            &Size
            );

        DhcpAssert(ERROR_SUCCESS == Error);
        if( ERROR_SUCCESS != Error ) break;

        if( CompareFileTime( (FILETIME *) &TimeNow, &LeaseExpires) <0) {
            //
            // have to reset the expiry time to NOW! (as lease not yet
            // expired, but need to fake expiration)
            //
            DhcpPrint((DEBUG_TRACE, "Setting expiry time to now..\n"));
            Error = DhcpJetSetValue(
                DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
                &TimeNow,
                sizeof(LeaseExpires)
            );
            break;
        }
        
        //
        // if it has been in this DELETED state for way too long, just
        // delete it. 
        //
        *(ULONGLONG UNALIGNED *)&TimeDiff =
            ((*(ULONGLONG UNALIGNED *)&TimeNow) - 
             (*(ULONGLONG UNALIGNED *)&LeaseExpires))/ 1000; 
        DhcpPrint((DEBUG_DNS, "Already deleted for [%u] micro-seconds!\n",
                   TimeDiff)); 
        DhcpPrint((DEBUG_DNS, "Max retry dns reg. time = %u"
                   " micro-seconds!\n", MAX_RETRY_DNS_REGISTRATION_TIME));

        if( *(ULONGLONG UNALIGNED *)&TimeDiff >=
            MAX_RETRY_DNS_REGISTRATION_TIME ) {
            //
            // the above comparison is in NANO seconds!
            //
            DhcpPrint((DEBUG_DNS, "Deleting really old ip address\n"));
            return TRUE;
        }

        //
        // This isn't a loop... Just don't like GOTOs much.
        //
    } while(0);
    
    //
    // Now commit changes. If we do NOT commit, nothing ever happens to the
    // changes!! 
    //
    if(ERROR_SUCCESS == Error) {
        Error = DhcpJetCommitUpdate();
    }

    if(ERROR_SUCCESS != Error) {
        DhcpAssert(FALSE);
        DhcpPrint((DEBUG_ERRORS, "Could not setval  to the"
                     " database..:%ld\n", Error)); 
        //
        // if we could not write this, might as well kill the record.
        //
        return TRUE;
    }

    //
    // OK. Did it.
    //
    DhcpPrint((DEBUG_TRACE, "Set Address state of %ws (%s) to %08x\n",
               L"", // had intended, machine name, but have freed it already..;-)
               inet_ntoa(* (struct in_addr *) &IpAddress),
               AddressState
        ));
    //
    // Should not delete.
    //

    return FALSE;
}

VOID
DhcpDoDynDnsCreateEntryWork(
    IN LPDHCP_IP_ADDRESS ClientIpAddress,
    IN BYTE bClientType,
    IN LPWSTR MachineName,
    IN OUT LPBYTE pAddressState,
    IN OUT LPBOOL pOpenExisting,
    IN BOOL BadAddress
)
/*++

Routine Description:
    This routine does the DynDns work associated with creating a new client
    entry...

    It checks to see if this is a new client, and if so does as required.
    If it is an update to an old client, then it undoes the previous DNS
    registration (if any) and redoes the new DNS registration.

    Because of this the value for the pOpenExisting variable may change.
    It also modifies the AddressState variable to indicate if DNS is
    pending etc..

    Also, if AddressState has the DOWNLEVEL bit turned on, then both A 
    and PTR registrations are done.   If the AddressState has the CLEANUP
    bit set, then the address will be removed on deletion..

    N.B. It is assumed that the database locks have been taken.
    
    N.B  Also, JetUpdate must be called by the caller to update info.  If
    not, something serious might happen. (?)

--*/
{
    DWORD Error, Size;
    BYTE PrevState;
    BOOL RecordExists = FALSE;
    LPWSTR OldClientName = NULL;

    if( USE_NO_DNS ) return;

    if( IS_ADDRESS_STATE_DECLINED(*pAddressState) ) {
        BadAddress = TRUE;
    }

    DhcpPrint((DEBUG_DNS, "DhcpDoDynDnsCreateEntryWork %s "
               "Open%sExisting %sAddress\n",
               inet_ntoa( * (struct in_addr *) ClientIpAddress),
               (*pOpenExisting)? "" : "Non",
               BadAddress?"Bad" :"Good"));
    DhcpPrint((DEBUG_DNS, "Machine is <%ws>\n",
               MachineName?MachineName:L"NULL")); 

    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        (PVOID) ClientIpAddress,
        sizeof(*ClientIpAddress)
        );

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_TRACE, "Could not do JetOpenKey(IPADDRESS %s):"
                   "%ld\n", 
                   inet_ntoa( * (struct in_addr *) ClientIpAddress), 
                   Error));
    }

    RecordExists = (ERROR_SUCCESS == Error); 

    if( RecordExists ) {
        DhcpPrint((DEBUG_TRACE, "Record Exists for Client %ws, %s\n",
                   MachineName, 
                   inet_ntoa(*(struct in_addr *) ClientIpAddress)));

        Size = sizeof(*pAddressState);
        if( ERROR_SUCCESS != DhcpJetGetValue(
            DhcpGlobalClientTable[STATE_INDEX].ColHandle,
            &PrevState,
            &Size)) {
            DhcpPrint((DEBUG_TRACE, "Failed to get state: %ld\n", Error));
            DhcpAssert(FALSE);
            return;
        }

        DhcpPrint((DEBUG_TRACE, "PrevState: 0x%2x\n", (int) PrevState));

        Size = 0;
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
            &OldClientName,
            &Size);

        if(ERROR_SUCCESS != Error)
            DhcpPrint((DEBUG_TRACE, "Could not get machine "
                       "name: %ld\n", Error));
        else DhcpPrint((DEBUG_TRACE, "OldClientName = %ws\n",
                        OldClientName?OldClientName:L"NULL"));
    }

    if( !*pOpenExisting ) {
        //
        // We DO NOT expect a record in this case.
        // What this means is that either there really is NO record,
        // Or there is a record marked DELETED, but is still there waiting for
        // Async Delete to work.
        // In the first case, we  are fine; the second case is common with the
        // OpenExisting = TRUE case. So, all that is done here is to check if
        // an un-DELETED record, exists.. if so, we return immediately as then,
        // the calling function would also be aborting.. (soon).
        //

        if( RecordExists && !IsAddressDeleted(PrevState) ) {
            DhcpPrint((DEBUG_ERRORS, "Trying to open with OpenExisting flag"
                       " set to FALSE" 
                       " and there is a record for this ip address!\n"));
            if(OldClientName) DhcpFreeMemory(OldClientName);
            return ;
        }

        //
        // Note that if record exists, we have to let the caller know abt
        // this.
        //
        if( RecordExists ) (*pOpenExisting) = TRUE;
    }

    //
    // Ok, we either have no record, or if !OpenExisting a deleted record, else
    // any record.  In any case, we call Async Delete to delete this record in the
    // hope that this call atleast might succeed. But, we'd lose track of this async
    // call as the db could get updated right after that. (well, not much chance..)
    // We also, may make sure that we DO NOT call this function if the client names
    // match.  
    //

    if( RecordExists ) {
        if( !IS_ADDRESS_STATE_OFFERED(PrevState) && OldClientName && 
            IsAddressCleanupRequired(PrevState) ) {
            BOOL fDel = TRUE;
            
            //
            // Do DNS deletion iff address wasnt ACK'ed before.
            //

            if( !BadAddress ) {
                if( MachineName && OldClientName
                    && 0 == _wcsicmp(MachineName, OldClientName)
                    ) {
                    fDel = FALSE;
                }
            }

            if( fDel ) {
                DhcpDnsAsyncDelete(
                    *ClientIpAddress, OldClientName, PrevState
                    );
            }
        }
    }


    //
    // No more work to do for bad addresses.
    //
    if( BadAddress ) {
        if(OldClientName) DhcpFreeMemory(OldClientName);
        return;
    }

    //
    //  Now we need to call the Async Register routine to do the Dns Stuff.
    //  But before that, we need to avoid bug 65666
    //

    if(!IS_ADDRESS_STATE_OFFERED(*pAddressState)) {
        DhcpPrint((DEBUG_TRACE, "Not offering..So bug 65666 is not a problem\n"));
    } else if(!IS_ADDRESS_STATE_ACTIVE(PrevState)) {
        DhcpPrint((DEBUG_TRACE, "PrevState is Not active..\n"));
    } else {
        //
        // Now change the state so that it is active.
        //
        SetAddressStateActive((*pAddressState));
        DhcpPrint((DEBUG_TRACE,"OK, changed state to: 0x%lx\n", (int)(*pAddressState)));
    }

    //
    // OK. Set the UnRegistered bit on. (only for non-null names + ACTIVE
    // leases)
    //
    if( MachineName && wcslen(MachineName) 
        && IS_ADDRESS_STATE_ACTIVE((*pAddressState)) 
        && IsAddressUnRegistered(*pAddressState) ) {
        
        DhcpDnsAsyncAdd(
            *ClientIpAddress, MachineName, (*pAddressState)
            );
    } else {
        //
        // Clear off the DNS bits off this record
        //
        (*pAddressState) = GetAddressState((*pAddressState));
    }

    DhcpPrint((DEBUG_DNS, "Returning, but OpenExisting=%d,"
               " AddressState=0x%02x\n", 
               (*pOpenExisting), (*pAddressState)));
    if(OldClientName) DhcpFreeMemory(OldClientName);
}


VOID
DhcpDoDynDnsReservationWork(
    IN DHCP_IP_ADDRESS ClientIpAddress,
    IN LPWSTR OldClientName,
    IN BYTE AddressState
)
/*++

Routine Description;
   This routine takes care of anything that needs to be done when a
   reservation is removed.  Currently it just calls the AsyncDelete
   routine. 

   N.B Databse locsk must be taken by caller as well as leaving the databse
   current record pointing at the record for ClientIpAddress.

--*/
{

    if( USE_NO_DNS ) return;
    DhcpPrint((DEBUG_TRACE,
               " DhcpDoDynDnsReservationWork for %s <%ws> (state: %d)\n", 
               inet_ntoa( * (struct in_addr *) &ClientIpAddress),
               OldClientName?OldClientName:L"NULL",
               AddressState
        ));

    DhcpDnsAsyncDelete(
        ClientIpAddress, OldClientName, AddressState
        );
    return ;
}


VOID
DhcpRealDeleteClient(
    IN DHCP_IP_ADDRESS IpAddress,
    IN LPWSTR ClientName,
    IN BYTE AddressState
)
/*++

Routine Description:
    This routine deletes the record for the given IpAddress from off the
    database provided that the ClientName and AddressState match in the
    database.  (If they don't match, something happened to the earlier
    record and the routine returns silently).

--*/
{
    DWORD Error, Size;
    LPWSTR OldClientName = NULL;
    BYTE PrevState;
    BOOL TransactBegin = FALSE;


    if( USE_NO_DNS ) DhcpAssert(FALSE);
    DhcpPrint((DEBUG_DNS, "DhcpRealDeleteClient(%s,%ws, %08x) entered\n",
               inet_ntoa(*(struct in_addr *) &IpAddress),
               ClientName?ClientName:L"NULL",
               AddressState));

    AddressState = GetAddressState(AddressState);
    LOCK_DATABASE();

    Error = DhcpJetBeginTransaction();

    if(ERROR_SUCCESS != Error) {
        UNLOCK_DATABASE();
        DhcpPrint((DEBUG_ERRORS, "Could not start transaction: %ld\n", Error));
        return;
    }

    Size = sizeof(IpAddress);
    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        (PVOID )&IpAddress,
        Size
        );

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Deleting deleted key? %ws, %s\n",
                   ClientName?ClientName:L"NULL",
                   inet_ntoa(*(struct in_addr *)&IpAddress)));
        goto Cleanup;
    }

    //
    // OK. Got this record. Now get the ClientName and AddressState.
    //
    Size = sizeof(PrevState);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &PrevState,
        &Size
        );
    
    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "could not get State info for %ws, %s\n", 
                   ClientName?ClientName:L"NULL", 
                   inet_ntoa(*(struct in_addr *)&IpAddress))); 

        goto Cleanup;
    } else DhcpPrint((DEBUG_TRACE, "Read AddressState=%08x\n", PrevState));

    if( !IsAddressDeleted(PrevState) || 
        !IsAddressUnRegistered(PrevState) ||
        AddressState != GetAddressState(PrevState)) {
        
        DhcpPrint((DEBUG_ERRORS, "Client tried to delete unregistered or undeleted record\n"));
        goto Cleanup;
    }

    //
    // Let DhcpJetGetValue allocate space for us.
    //
    Size = 0;
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
        &OldClientName,
        &Size);

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Could not get machine name for %ws, %s\n",
                   ClientName?ClientName:L"NULL",
                   inet_ntoa(*(struct in_addr *)&IpAddress)));
        goto Cleanup;
    } else DhcpPrint((DEBUG_TRACE, "Read MachineName=%ws\n",
                      OldClientName?OldClientName:L"NULL")); 

    //
    // Now compare the stuff. (check if they are null?)
    //
    if( ClientName == NULL ) {
        if( OldClientName != NULL ) goto Cleanup;
    } else if( wcscmp(ClientName, OldClientName?OldClientName:L"")) {  
        DhcpPrint((DEBUG_ERRORS, "Name changed before deleting?"
                   "ignored deleting\n"));
        goto Cleanup;
    }

    //
    // Now  do the actual deletion.
    //
    Error = JetDelete(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle
        );

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "JetDelete failed!\n"));
    }

  Cleanup:
    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Jet failed %ld\n", Error));
        Error = DhcpJetRollBack();
        DhcpAssert(ERROR_SUCCESS == Error);
    } else {
        Error = DhcpJetCommitTransaction();
        DhcpAssert(ERROR_SUCCESS == Error);
    }
    UNLOCK_DATABASE();

    if(OldClientName) DhcpFreeMemory(OldClientName);
    return;
}

VOID
DhcpFlipRegisteredBit(
    IN DHCP_IP_ADDRESS IpAddress,
    IN LPWSTR ClientName,
    IN BYTE AddressState
)
/*++

Routine Description:
    This routine flips the UNREGISTERED bit to mark the record as having
    completed registration.

    Same checks are done as for DhcpRealDeleteClient.
--*/
{
    DWORD Error, Size;
    LPWSTR OldClientName = NULL;
    BYTE PrevState;
    BOOL TransactBegin = FALSE;

    if( USE_NO_DNS ) DhcpAssert(FALSE);
    DhcpAssert(NULL != ClientName);

    DhcpPrint((DEBUG_DNS, "DhcpFlipRegisteredBit(%s, %ws, %08x\n",
               inet_ntoa(*(struct in_addr *)&IpAddress),
               ClientName?ClientName:L"NULL",
               AddressState));

    AddressState = GetAddressState(AddressState);
    LOCK_DATABASE();

    Error = DhcpJetBeginTransaction();

    if(ERROR_SUCCESS != Error) {
        UNLOCK_DATABASE();
        DhcpPrint((DEBUG_ERRORS, "Could not start transaction: %ld\n", Error));
        return;
    }

    Size = sizeof(IpAddress);
    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        (PVOID) &IpAddress,
        Size);

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Deleting deleted key? %ws, %s\n",
                   ClientName?ClientName:L"NULL",
                   inet_ntoa(*(struct in_addr *)&IpAddress)));
        goto Cleanup;
    }

    //
    // OK. Got this record. Now get the ClientName and AddressState.
    //
    Size = sizeof(PrevState);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &PrevState,
        &Size);

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "could not get State info for %ws, %s\n",
                   ClientName?ClientName:L"NULL",
                   inet_ntoa(*(struct in_addr *)&IpAddress)));

        goto Cleanup;
    }

    //
    // cannot flip bits for deleted clients or unregistered clients.
    //
    if( IsAddressDeleted(PrevState) || !IsAddressUnRegistered(PrevState) ||
        AddressState != GetAddressState(PrevState)) {
        DhcpPrint((DEBUG_ERRORS, "Client tried to delete unregistered"
                   " or deleted record\n"));
        goto Cleanup;
    }

    //
    // Let DhcpJetGetValue allocate space for us.
    //
    Size = 0;
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
        &OldClientName,
        &Size);

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Could not get machine name for %ws, %s\n",
                   ClientName?ClientName:L"NULL",
                   inet_ntoa(*(struct in_addr *)&IpAddress)));
        goto Cleanup;
    }

    //
    // Now compare the stuff. (or if both are null) (ClientName cannot be
    // null)
    //
    if(ClientName == OldClientName 
       || wcscmp(ClientName, OldClientName?OldClientName:L"")) { 
        DhcpPrint((DEBUG_ERRORS, "Name changed before deleting?"
                   " ignored deleting\n")); 
        goto Cleanup;
    }

    //
    // Now do set the variable to the value needed.
    //
    Error = DhcpJetPrepareUpdate(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        &IpAddress,
        sizeof(IpAddress),
        FALSE); // This record has to exist to write to.

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Could not jetPrepareUpdate record\n"));
        goto Cleanup;
    }

    //
    // remember to keep downlevel clients downlevel.
    //
    if(IsUpdateAPTRRequired(PrevState))
        AddressState = AddressUpdateAPTR(AddressState);

    if(IsAddressCleanupRequired(PrevState))
        AddressState = AddressCleanupRequired(AddressState);

    DhcpPrint((DEBUG_TRACE, "State is to be reset for client to: %08x\n",
               AddressState));
    Size = sizeof(AddressState);
    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        Size
        );

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "JetUpdate state failed!\n"));
    }

    Error = DhcpJetCommitUpdate();

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, " Jetupdate failed\n"));
    }

  Cleanup:
    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Jet failed %ld\n", Error));
        Error = DhcpJetRollBack();
        DhcpAssert(ERROR_SUCCESS == Error);
    } else {
        Error = DhcpJetCommitTransaction();
        DhcpAssert(ERROR_SUCCESS == Error);
    }
    UNLOCK_DATABASE();

    if(OldClientName)
        DhcpFreeMemory(OldClientName);
    return;
}

//
//  This structure holds the Dns context so that when the async routine calls
//  back with success or failure, we would be able to proceed and find out what
//  record should be updated.
//
typedef struct {
    LIST_ENTRY Entry;
    PVOID Ctxt;
    DHCP_IP_ADDRESS IpAddress;
    LPWSTR ClientName;
    BYTE AddressState;
    enum DhcpDnsOp {
        DhcpDnsDeleteRecord,
        DhcpDnsAddRecord
    } DnsOp;
} DHCP_DNS_CONTEXT, *PDHCP_DNS_CONTEXT;

VOID
DhcpDnsCallBack(
    IN DWORD Status,
    IN LPVOID Ctxt
)
/*++

Routine Description:
    This routine is called back by DNS whenever it is done with the
    registrations.  If DNS was updated successfully, the database is
    updated accordingly.

    Currently Status can take multiple values of which only
    DNSDHCP_FWD_FAILED and DNSDHCP_SUCCESS are assumed to be success
    codes..

--*/
{
    DWORD Error;
    PDHCP_DNS_CONTEXT pDnsCtxt = *(PDHCP_DNS_CONTEXT *)Ctxt;

    if( DhcpGlobalServiceStopping ) return ;
    if( USE_NO_DNS ) { DhcpAssert(FALSE); return ; }

    DhcpAssert(pDnsCtxt);
    DhcpPrint((DEBUG_DNS, "DhcpDnsCallBack %ld entered\n", Status));

    //
    // if a forward failed, we dont care much.
    //
    if(DNSDHCP_FWD_FAILED == Status) Status = DNSDHCP_SUCCESS;

    //
    // if anything else happened, dont change data base.
    // but still have to free the data.
    //
    if(DNSDHCP_SUCCESS != Status) {
        DhcpUpdateAuditLogEx( DHCP_IP_DDNS_LOG_FAILED,
                              GETSTRING( DHCP_IP_DDNS_LOG_FAILED_NAME ),
                              pDnsCtxt->IpAddress,
                              NULL, 0,
                              pDnsCtxt->ClientName,
                              Status );
        DhcpDnsFreeMemory(Ctxt);
        DhcpPrint((DEBUG_DNS, "DhcpDnsCallBAck failed\n"));

        return;
    }

    if(!pDnsCtxt) {
        DhcpPrint((DEBUG_ERRORS, "DhcpDnsCallBack called with"
                   " null ptr\n")); 
        DhcpAssert(FALSE);
        return;
    }

    if( DhcpGlobalImpersonated ) {
        DhcpPrint((DEBUG_TRACE, "Impersonated, so scheduling to  another thread"));

        pDnsCtxt->Ctxt = Ctxt;
        LOCK_MEM();
        InsertTailList(&DhcpGlobalDnsCallbackList, &pDnsCtxt->Entry);
        UNLOCK_MEM();

        SetEvent( DhcpGlobalRecomputeTimerEvent );
        DhcpPrint((DEBUG_TRACE, "DhcpDnsCallBAck done\n"));
        return;
    } 

    //
    // Now find if we have to flip or delete..
    //
    if(DhcpDnsDeleteRecord == pDnsCtxt->DnsOp) {
        DhcpPrint((DEBUG_TRACE, "DhcpDnsCallBack Delete was called\n")); 
        DhcpRealDeleteClient(
            pDnsCtxt->IpAddress, 
            pDnsCtxt->ClientName, 
            pDnsCtxt->AddressState
            );
    } else {
        DhcpAssert(DhcpDnsAddRecord == pDnsCtxt->DnsOp);
        DhcpPrint((DEBUG_TRACE, "DhcpDnsCallBack Add  was called\n"));
        DhcpFlipRegisteredBit(
            pDnsCtxt->IpAddress,
            pDnsCtxt->ClientName, 
            pDnsCtxt->AddressState
            );
    }

    DhcpUpdateAuditLogEx( DHCP_IP_DDNS_LOG_SUCCESSFUL,
                          GETSTRING( DHCP_IP_DDNS_LOG_SUCCESSFUL_NAME ),
                          pDnsCtxt->IpAddress,
                          NULL, 0,
                          pDnsCtxt->ClientName,
                          Status );

    //
    // Now free this memory.
    //
    DhcpDnsFreeMemory(Ctxt);
    DhcpPrint((DEBUG_TRACE, "DhcpDnsCallBAck done\n"));
}

VOID
DhcpDnsHandleCallbacks(
    VOID
    )
{
    PLIST_ENTRY ThisEntry;
    PDHCP_DNS_CONTEXT pDnsCtxt;
    BOOL fListEmpty = IsListEmpty(&DhcpGlobalDnsCallbackList);
    
    if(!fListEmpty) DhcpPrint((DEBUG_TRACE, "+DhcpDnsHandleCallbacks"));
    LOCK_MEM();
    while(!IsListEmpty(&DhcpGlobalDnsCallbackList) ) {
        ThisEntry = RemoveHeadList(&DhcpGlobalDnsCallbackList);
        UNLOCK_MEM();
        
        pDnsCtxt = CONTAINING_RECORD(ThisEntry, DHCP_DNS_CONTEXT, Entry);

        if( DhcpDnsDeleteRecord == pDnsCtxt->DnsOp ) {
            DhcpPrint((DEBUG_TRACE, "DhcpDnsCallBAck Delete\n"));
            DhcpRealDeleteClient(
                pDnsCtxt->IpAddress, pDnsCtxt->ClientName,
                pDnsCtxt->AddressState );
        } else {
            DhcpAssert(DhcpDnsAddRecord == pDnsCtxt->DnsOp);
            DhcpPrint((DEBUG_TRACE, "DhcpDnsCallBack Add\n"));
            DhcpFlipRegisteredBit(
                pDnsCtxt->IpAddress,
                pDnsCtxt->ClientName, 
                pDnsCtxt->AddressState
                );
        }            
        DhcpDnsFreeMemory(pDnsCtxt->Ctxt);

        LOCK_MEM();
    }
    UNLOCK_MEM();
    if(!fListEmpty) DhcpPrint((DEBUG_TRACE, "-DhcpDnsHandleCallbacks"));
}
    
PIP_ADDRESS
GetDnsServerList(
    IN DHCP_IP_ADDRESS IpAddress,
    OUT PULONG DnsServerCount
)
/*++

Routine Description:
    This routine retrieves the DNS information for the given Ip address.
    Currently it does not take the USER Class information for the Ip
    address and hence would end up picking up the "default" DNS servers.. 
    
    The classid thing needs to be fixed.. ?

--*/
{
    DWORD Error;
    PIP_ADDRESS DnsServers;
    ULONG Size, Unused;

    DnsServers = NULL;
    Size = 0;
    Error = DhcpGetParameterForAddress(
        IpAddress,
        0 /* no class id ..???? */,
        OPTION_DOMAIN_NAME_SERVERS,
        (LPBYTE *)&DnsServers,
        &Size,
        &Unused
        );
    if( ERROR_SUCCESS != Error ) {
        *DnsServerCount = 0;
        return NULL;
    }

    *DnsServerCount = Size / sizeof(PIP_ADDRESS);
    if( *DnsServerCount ) return DnsServers;
    *DnsServerCount = 0;
    if( DnsServers ) DhcpFreeMemory( DnsServers );
    return NULL;
}

VOID
DhcpDnsAsyncDelete(
    IN DHCP_IP_ADDRESS IpAddress,
    IN LPWSTR ClientName,
    IN BYTE AddressState
) 
/*++

Routine Description:
    This routine schedules a DNS delete for the IP address given by
    IpAddress and based on values for AddressState, it schedules the
    deregistration for A / PTR .

    (N.B The DNSAPI routine takes a callback which provides the status of
    the operation..)
--*/
{
    PDHCP_DNS_CONTEXT *pCtxt = NULL;
    REGISTER_HOST_ENTRY HostEntry;
    DWORD Size = 0, dwFlags;
    DNS_STATUS Status;
    PIP_ADDRESS DnsServers;
    ULONG DnsServerCount;

    if(!ClientName) ClientName = L"";

    DhcpPrint((DEBUG_DNS, "DhcpDnsAsyncDelete: %s [%ws] %08x\n",
               inet_ntoa(*(struct in_addr *) &IpAddress),
               ClientName?ClientName:L"NULL",
               AddressState));
    
    DhcpAssert(ClientName);

    Size += ROUND_UP_COUNT(sizeof(DHCP_DNS_CONTEXT), ALIGN_WORST);
    Size += ROUND_UP_COUNT(sizeof(WCHAR)*(1+wcslen(ClientName)), ALIGN_WORST);

    if(NULL == (pCtxt = (PDHCP_DNS_CONTEXT *)DhcpDnsAllocateMemory(Size))) {
        DhcpPrint((DEBUG_ERRORS, "Could not get enough memory\n"));
        return;
    }

    //
    // Now fill in the allocated structure with details.
    //
    InitializeListHead(&(*pCtxt)->Entry);
    (*pCtxt)->Ctxt = NULL;
    (*pCtxt)->IpAddress = IpAddress;
    (*pCtxt)->AddressState = AddressState;
    (*pCtxt)->ClientName = ROUND_UP_POINTER(
        ((LPBYTE)(*pCtxt)) + sizeof(**pCtxt), ALIGN_WORST
        );
    wcscpy((*pCtxt)->ClientName, ClientName);
    ClientName = ((*pCtxt))->ClientName;
    DhcpPrint((DEBUG_TRACE, "FQDN================%ws\n", ClientName));

    ((*pCtxt))->DnsOp = DhcpDnsDeleteRecord;

    //
    // Now should call the async routine to do our stuff.
    //
    HostEntry.Addr.ipAddr = htonl(IpAddress);

    //
    // Now call the deleting routine.
    //
    dwFlags = DYNDNS_DELETE_ENTRY;
    HostEntry.dwOptions = REGISTER_HOST_PTR;
    if ( IS_DOWN_LEVEL( AddressState )) {
        HostEntry.dwOptions |= REGISTER_HOST_A;
        dwFlags |= DYNDNS_REG_FORWARD;
    }

    DnsServers = GetDnsServerList( IpAddress, &DnsServerCount);

    Status = DnsDhcpSrvRegisterHostName(
                HostEntry,
                ClientName,
                DynamicDNSTimeToLive,
                dwFlags,
                DhcpDnsCallBack,
                pCtxt,
                DnsServers,
                DnsServerCount );

    if( DnsServers ) DhcpFreeMemory( DnsServers );

    DhcpPrint((DEBUG_DNS, "FQDN <%ws> {%s,%s%s} dwFlags=[%s%s] Status = %ld\n",
               ClientName,
               inet_ntoa(*(struct in_addr *)&HostEntry.Addr.ipAddr),
               (HostEntry.dwOptions & REGISTER_HOST_A) ? "A" : " ",
               (HostEntry.dwOptions & REGISTER_HOST_PTR) ? "PTR" : "   ",
               (dwFlags & DYNDNS_REG_FORWARD ) ? "FWD+" : "    ",
               (dwFlags & DYNDNS_ADD_ENTRY ) ? "ADD" : "DEL",
               Status
    ));

    DhcpUpdateAuditLogEx( DHCP_IP_DDNS_LOG_REQUEST,
                          GETSTRING( DHCP_IP_DDNS_LOG_REQUEST_NAME ),
                          HostEntry.Addr.ipAddr,
                          NULL, 0,
                          ClientName,
                          Status );

    if(ERROR_SUCCESS != Status) {
        DhcpPrint((DEBUG_ERRORS, "Dns delete failure %ld\n", Status));
        DhcpDnsFreeMemory(pCtxt);
    }
}

VOID
DhcpDnsAsyncAdd(
    IN DHCP_IP_ADDRESS IpAddress,
    IN LPWSTR ClientName,
    IN BYTE AddressState
) 
/*++

Routine Description:
    The counterpart for the deletion function is the Add function that tries to
    add a name to Dns. And when the call back executes, if all the names,etc
    match, it flips the required bit.


--*/
{
    PDHCP_DNS_CONTEXT (*pCtxt) = NULL;
    REGISTER_HOST_ENTRY HostEntry;
    DWORD Size = 0, dwFlags;
    DNS_STATUS Status;
    PIP_ADDRESS DnsServers;
    ULONG DnsServerCount;

    if( USE_NO_DNS ) return;

    if(!ClientName) ClientName = L"";
    DhcpPrint((DEBUG_DNS, "DhcpDnsAsyncAdd: %s %ws %08x\n",
               inet_ntoa(*(struct in_addr *) &IpAddress),
               ClientName?ClientName:L"NULL",
               AddressState));

    if(!wcslen(ClientName)) {
        //
        // cannot have empty client names for registration!
        //
        DhcpPrint((DEBUG_ERRORS, "Cant register null names!\n"));
        // DhcpAssert(FALSE);
        return;
    }
    DhcpAssert(ClientName);

    Size += ROUND_UP_COUNT(sizeof(DHCP_DNS_CONTEXT), ALIGN_WORST);
    Size += ROUND_UP_COUNT(
        sizeof(WCHAR)*(1+wcslen(ClientName)), ALIGN_WORST
        );

    if(NULL == (pCtxt = (PDHCP_DNS_CONTEXT *)DhcpDnsAllocateMemory(Size))) {
        DhcpPrint((DEBUG_ERRORS, "Could not get enough memory\n"));
        return;
    }

    //
    // Now fill in the allocated structure with details.
    //
    InitializeListHead(&((*pCtxt)->Entry));
    (*pCtxt)->IpAddress = IpAddress;
    (*pCtxt)->AddressState = AddressState;
    (*pCtxt)->ClientName = ROUND_UP_POINTER(
        ((LPBYTE)((*pCtxt))) + sizeof(*(*pCtxt)), ALIGN_WORST
        );
    wcscpy((*pCtxt)->ClientName, ClientName);
    ClientName = ((*pCtxt))->ClientName;

    ((*pCtxt))->DnsOp = DhcpDnsAddRecord;

    HostEntry . Addr . ipAddr = htonl(IpAddress);
    HostEntry . dwOptions = REGISTER_HOST_PTR;
    if(IS_DOWN_LEVEL(AddressState))
        HostEntry . dwOptions |= REGISTER_HOST_A;

    //
    // Now call the registration routine.
    //
    dwFlags = DYNDNS_ADD_ENTRY;
    if(IS_DOWN_LEVEL(AddressState)) dwFlags |= DYNDNS_REG_FORWARD;

    DnsServers = GetDnsServerList( IpAddress, &DnsServerCount );

    Status = DnsDhcpSrvRegisterHostName(
                HostEntry,
                ClientName,
                DynamicDNSTimeToLive,
                dwFlags,
                DhcpDnsCallBack,
                pCtxt,
                DnsServers,
                DnsServerCount );

    if( DnsServers ) DhcpFreeMemory( DnsServers );

    DhcpPrint((DEBUG_DNS, "FQDN <%ws> {%s,%s%s} dwFlags=[%s%s] Status = %ld\n",
               ClientName,
               inet_ntoa(*(struct in_addr *)&HostEntry.Addr.ipAddr),
               (HostEntry.dwOptions & REGISTER_HOST_A) ? "A" : " ",
               (HostEntry.dwOptions & REGISTER_HOST_PTR) ? "PTR" : "   ",
               (dwFlags & DYNDNS_REG_FORWARD ) ? "FWD+" : "    ",
               (dwFlags & DYNDNS_ADD_ENTRY ) ? "ADD" : "DEL",
               Status
    ));

    DhcpUpdateAuditLogEx( DHCP_IP_DDNS_LOG_REQUEST,
                          GETSTRING( DHCP_IP_DDNS_LOG_REQUEST_NAME ),
                          HostEntry.Addr.ipAddr,
                          NULL, 0,
                          ClientName,
                          Status );

    if(ERROR_SUCCESS != Status) {
        DhcpPrint((DEBUG_ERRORS, "Dns add failure %ld\n", Status));
        DhcpDnsFreeMemory(pCtxt);
    }
}

//
//  The memory functions are here.  Memory is handled through two lists.. the
//  Free and available list.  This way memory can be re-used without having to
//  worry about anything.  Also, if less than X memory is used, half the
//  unused memory is released....  that way, too much memory is not taken up.
//  Also memory is not indefinitely allocated:
//  The way this works is: each time the start allocation routine is called, it
//  would check for the last time a successful free was done; if a free was not
//  done for a very long time (check below for times: 15 min DBG, 1.5hr o/w),
//  then it refuses to allocate memory.
//  Also, memory is picked off the free list, as long as it is available. If it
//  is not available, then a bunch of addresses are allocated and added to the
//  free list, so that future allocations are fast.
//

//
//  Here is the memory block data-structure.  It is a simple linked list of
//  nodes with each node containing an actual pointer to size.
//
typedef struct {
    LIST_ENTRY   Ptr;          // Flink,Blink pointers
    DWORD        mSize;        // Size of allocated memory below.
    LPVOID       Memory;       // The actual memory allocated.
#if DBG
    BYTE         TestByte;     // this is always set to TEST_BYTE_VAL...
#endif
} MEM_NODE, *MEM_LIST;

LIST_ENTRY  FreeList, UsedList;
DWORD     FreeListSize = 0, UsedListSize = 0;
time_t    LastFreedTime = 0;
DWORD     nPendingAllocations = 0;

#if DBG
#define ALLOWED_ALLOCATION_TIME           (15*60) // seconds; 15 minutes
#define MAX_ALLOWED_ALLOCATIONS           1000    // atmost 1000 pending dns requests
#else
#define ALLOWED_ALLOCATION_TIME           (90*60) // seconds; 1.5 hrs
#define MAX_ALLOWED_ALLOCATIONS           5000    // be a little more flexible in real life
#endif

#define MIN_ALLOCATION_UNIT               15      // allocate in units of 15
#define MEM_NODE_SIZE              ROUND_UP_COUNT(sizeof(MEM_NODE),ALIGN_WORST)

//
// This gives just 60 bytes for a client name... but most often this is
// accurate enough.
//

#define MINIMUM_UNIT_SIZE          (sizeof(DHCP_DNS_CONTEXT) + 60*sizeof(WCHAR))

#define TEST_BYTE_VAL              0x55

//
// Two helper functions.. DhcpAddMemorytoFreeList would add a pointer to the
// Freelist and increment the free list counter..  DhcpAddMemoryToUsedList is just
// the same thing done to the Used list.
//
VOID
DhcpAddMemoryToUsedList(
    IN OUT MEM_LIST Ptr
    ) 
{
    //
    // Zero in the stuff as far as
    //
    memset((LPBYTE)Ptr + MEM_NODE_SIZE, 0x00, MINIMUM_UNIT_SIZE);

    //
    // Now add it to the right list.
    //
    InsertHeadList(&UsedList, &Ptr->Ptr);
    UsedListSize ++;

    //
    // Now check the pointers, and if debug, the TestByte also.
    //
    DhcpAssert( !DBG || Ptr->TestByte == TEST_BYTE_VAL);
    DhcpAssert(Ptr->mSize);
    DhcpAssert(Ptr->Memory == (LPBYTE)Ptr + MEM_NODE_SIZE);
}

VOID
DhcpAddMemoryToFreeList(
    IN OUT MEM_LIST Ptr
    ) 
{
    //
    // Zero in the stuff as far as
    //
    memset((LPBYTE)Ptr, 0x00, MEM_NODE_SIZE + MINIMUM_UNIT_SIZE);

    //
    // Now add it to the right list.
    //
    InsertHeadList(&FreeList, &Ptr->Ptr);
    FreeListSize ++;

    //
    // Now fill in the pointers, and if debug, the TestByte also.
    //
#if DBG
    Ptr->TestByte = TEST_BYTE_VAL;
#endif
    Ptr->Memory = (LPBYTE)Ptr + MEM_NODE_SIZE;
}

//
// Now comes the un-pooled function.  This function allocates memory, but does
// not try to allocate a set, instead.. allocates just exactly one node.
//
LPVOID
DhcpAllocateLotsOfDnsMemory(
    IN DWORD Size
    )
{
    MEM_LIST mList;

    if(NULL == (mList = DhcpAllocateMemory(MEM_NODE_SIZE + Size)))
        return NULL;

    memset(mList, 0x00, MEM_NODE_SIZE);
#if DBG
    mList->TestByte = TEST_BYTE_VAL;
#endif
    mList ->Memory = (LPBYTE)mList + MEM_NODE_SIZE;
    mList->mSize = Size;

    DhcpAddMemoryToUsedList(mList);

    return &(mList->Memory);
}

//
// This function returns the address of the LPVOID variable which holds the
// first address of the memory allocated...
//
LPVOID
DhcpDnsAllocateMemory(
    IN DWORD Size
    ) 
{
    time_t timeNow = time(NULL);
    LPVOID RetVal = NULL;
    PLIST_ENTRY listEntry;

    LOCK_MEM();
    if( 0 == Size ) {
        DhcpAssert(FALSE);
        goto EndF;
    }

    //
    // First check if we are really allowed to proceed.
    //
    if( nPendingAllocations < MAX_ALLOWED_ALLOCATIONS ) {
        nPendingAllocations ++;
    } else goto EndF;

    if( 2 * MINIMUM_UNIT_SIZE < Size ) {
        RetVal = DhcpAllocateLotsOfDnsMemory(Size);
        goto EndF;
    }

    if( MINIMUM_UNIT_SIZE > Size ) Size = MINIMUM_UNIT_SIZE;


    //
    // Now check if we have memory already, if not really allocate memory.
    //
    if( 0 == FreeListSize ) {
        DWORD i, SizeToAllocate;

        SizeToAllocate = MEM_NODE_SIZE + Size;
        for( i = 0; i < MIN_ALLOCATION_UNIT; i ++ ) {
            LPVOID Ptr = NULL;

            if( NULL == (Ptr = DhcpAllocateMemory(SizeToAllocate) ))
                goto EndF;
            DhcpAddMemoryToFreeList(Ptr);
            ((MEM_LIST)Ptr)->mSize = Size;
        }
    }

    DhcpAssert( 0 != FreeListSize );

    //
    // Now we can pick off the free list one item which is of the right
    // size. 
    //
    listEntry = FreeList.Flink;
    while( &FreeList != listEntry ) {
        MEM_LIST MemList = CONTAINING_RECORD(listEntry, MEM_NODE, Ptr);
        DWORD    mSize;

        DhcpAssert(MemList);
        mSize = MemList->mSize;

        if( Size <= mSize ) { // memory is sufficient.
            RetVal = &MemList->Memory;
            RemoveEntryList(&(MemList->Ptr));
            FreeListSize --;
            DhcpAddMemoryToUsedList(MemList);
            goto EndF;
        }

        listEntry = listEntry -> Flink;
    }

    //
    // Did not find anything anywhere... so do a special allocate.
    //
    RetVal = DhcpAllocateLotsOfDnsMemory(Size);

  EndF:
    UNLOCK_MEM();
    return RetVal;
}

//
// The allocated pointer is whatever is returned by the DnsAllocateMemory function.
// So, this is the address of the field Memory in the MEM_NODE structure. With this
// info, get the structure, and free the structure and other stuff.. If this address
// is invalid, then assert.
//
VOID
DhcpDnsFreeMemory(
    LPVOID AllocatedPtr
    ) 
{
    time_t timeNow = time(NULL);
    MEM_LIST MemList;
    DWORD Size;

    if( 0 == UsedListSize ) {
        DhcpAssert(FALSE);
        return;
    }

    LOCK_MEM();
    DhcpAssert(nPendingAllocations);
    nPendingAllocations --;

    //
    // Try to find out this address in the UsedList..
    //
    MemList = CONTAINING_RECORD(AllocatedPtr, MEM_NODE, Memory);


#if DBG
    DhcpAssert( TEST_BYTE_VAL == MemList->TestByte );
#endif

    RemoveEntryList(&(MemList->Ptr));
    UsedListSize --;
    if( 0 == UsedListSize ) {
        //
        // if no pending entry, mark LastFreedTime to zero so we dont stop
        // sending dns requests.
        //
        LastFreedTime = 0;
    }

    //
    // Now add this to the free list, unless the free list is already
    // bloated.
    //
    if( MIN_ALLOCATION_UNIT < FreeListSize && UsedListSize < FreeListSize ) {
        DhcpFreeMemory(MemList);
        goto EndF;
    }

    Size = MemList->mSize;

    if( 2 * MINIMUM_UNIT_SIZE < Size ) {
        //
        // this was allocated via DhcpAllocateLotsOfDnsMemory -- just free these..
        //
        DhcpFreeMemory(MemList);
        goto EndF;
    }

    DhcpAddMemoryToFreeList(MemList);
    MemList->mSize = Size;

  EndF:
    UNLOCK_MEM();
    return;
}

//
//  Initialize the critical section so that LOCK_MEM and UNLOCK_MEM work.
//
static ULONG Initialized = 0;

VOID
DhcpInitDnsMemory( 
    VOID 
    ) 
{
    DWORD Error;

    if( 0 != Initialized ) return;
    Initialized ++;

    try {
        InitializeCriticalSection( &DhcpGlobalDnsMemoryCriticalSection );
        InitializeListHead(&UsedList);
        InitializeListHead(&FreeList);
        InitializeListHead(&DhcpGlobalDnsCallbackList); 
    } except( EXCEPTION_EXECUTE_HANDLER ) {

        Error = GetLastError( );
    }
}

//
//  Cleanup the list of unused and free memory nodes..
//
VOID
DhcpCleanupDnsMemory( 
    VOID 
    ) 
{
    PLIST_ENTRY listEntry;

    Initialized -- ;
    if( 0 != Initialized ) return;
    LOCK_MEM();

    DhcpDnsHandleCallbacks();
    DhcpPrint((DEBUG_TRACE, "Used: %ld, Free: %ld DNS Memory nodes\n",
               UsedListSize, FreeListSize));

    if( 0 == FreeListSize ) DhcpAssert(IsListEmpty(&FreeList));
    if( 0 == UsedListSize ) DhcpAssert(IsListEmpty(&UsedList));

    listEntry = UsedList.Flink;
    while(listEntry != &UsedList) {
        MEM_LIST mNode = CONTAINING_RECORD(listEntry, MEM_NODE, Ptr);

        listEntry = listEntry->Flink;
        RemoveEntryList(&(mNode->Ptr));
        DhcpFreeMemory(mNode);
    }

    listEntry = FreeList.Flink;
    while(listEntry != &FreeList) {
        MEM_LIST mNode = CONTAINING_RECORD(listEntry, MEM_NODE, Ptr);

        listEntry = listEntry->Flink;
        RemoveEntryList(&(mNode->Ptr));
        DhcpFreeMemory(mNode);
    }

    UNLOCK_MEM();
    FreeListSize = 0;
    UsedListSize = 0;
    nPendingAllocations = 0;

    DeleteCriticalSection(&DhcpGlobalDnsMemoryCriticalSection);
}

//
//  End of file.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\iptbl.c ===
/*++

Copyright (C) 1998 Microsoft Corporation.

Module Name:
    iptbl.c

Abstract:
    this module implements retreiving the IPAddress/Interface table
    from tcpip driver and maintains the winsock notification needed
    to update the table as well.

Environment:
    User mode Win32.

--*/

#if 0

How it all works:

This module initialization takes care of posting a winsock address
change notification so that any address change is notified.  On each
address change, the IP address table is completely retrieved and for
any new items the specified constructor is called and for any items
that have to be deleted too, the specified destructor is called before
the item is deleted.

Nothing is done if the subnet-mask is changed and nothing is done if
zero IP addresses are added or deleted.

Internally, this module keeps an array of
IP-Address,InterfaceName,SubnetMask
entries with the first two being the "key".

N.B.  It is up to the caller to create sockets etc. And note that if
an address goes and comes right back, no notifications will be given.
That is up to the user to handle too.

#endif 0

#include <dhcppch.h>
#include <guiddef.h>
#include <iphlpapi.h>
#include "convguid.h"
#include "iptbl.h"

#define TCPPREFIX_LEN sizeof("\\DEVICE\\TCPIP")

//
// The global endpoint table looks like this
//

typedef struct _ENDPOINT_TBL {
    //
    // How many times has this been initialized;
    //
    LONG InitCount;

    //
    // The critical section (allocated elsewhere) that
    // protects this global data.
    //
    PCRITICAL_SECTION CS;

    //
    // The Hook to be called into.
    //
    ENDPOINT_CALLBACK_RTN Callback;
    
    //
    // Socket to post notifications on.
    //
    SOCKET NotifySock;
    WSAOVERLAPPED Overlap;
    
    //
    // The following table is allocated by increasing
    // each time by about 10%.
    //
    HANDLE hHeap;
    ULONG nEndPointsAllocated;
    ULONG nEndPoints;
    PVOID EndPoints;
    ULONG EndPointEntrySize;
} ENDPOINT_TBL, *PENDPOINT_TBL;

//
// global variables and defines.
//

#define TEMP_SLEEP_TIME (4*1000)

ENDPOINT_TBL DhcpGlobalEndPointTable;

DWORD fHandlingAddrChange = 0;

//
// Endpoint accessing routines.
//
#define GET_ENDPOINT(Tbl, i) GetEndPointEntry((Tbl),(i))

PENDPOINT_ENTRY
GetEndPointEntry(
    IN PENDPOINT_TBL Tbl,
    IN ULONG Index
    )
/*++

Routine Description:
    Access the "Index"th element of the Tbl.
    N.B. It is assumed that Index is valid.
    N.B. It is assumed that locks have been taken on Tbl.
Return value:
    table endpoitn entry.

--*/
{
    PBYTE EpStart = Tbl->EndPoints;
    return (PENDPOINT_ENTRY)(EpStart + Index * Tbl->EndPointEntrySize);
}

#define DELETE_ENDPOINT(Tbl,i)  DeleteEndPointEntry((Tbl),(i))

VOID
DeleteEndPointEntry(
    IN OUT PENDPOINT_TBL Tbl,
    IN ULONG Index
    )
/*++

Routine Description:
    This routine deletes the entry identified by the Index and moves
    the other elements up so that the gap is filled.

    N.B. It is assumed that Index is valid.
    N.B. It is assumed that locks have been taken on Tbl.
    N.B. No memory is freed.

--*/
{
    PENDPOINT_ENTRY Ep = GET_ENDPOINT(Tbl,Index);
    PENDPOINT_ENTRY Ep2 = GET_ENDPOINT(Tbl,(Index+1));

    //
    // first notify higher layer.
    //
    
    Tbl->Callback(
        REASON_ENDPOINT_DELETED,
        Ep
        );
    
    Tbl->nEndPoints --;
    
    //
    // Deleting the last element in the table is cool.
    //
    if( Index != Tbl->nEndPoints  ) {
        RtlCopyMemory(
            Ep, Ep2, (Tbl->nEndPoints - Index)*Tbl->EndPointEntrySize
            );
    }
}

#define ADD_ENDPOINT  AddEndPointEntry

ULONG
AddEndPointEntry(
    IN OUT PENDPOINT_TBL Tbl,
    IN GUID *IfGuid,
    IN ULONG IpAddress,
    IN ULONG IpIndex,
    IN ULONG IpContext,
    IN ULONG SubnetMask
    )
{
    PENDPOINT_ENTRY Entry;
    
    if( Tbl->nEndPoints == Tbl->nEndPointsAllocated ) {
        //
        // Not enough space. Need to allocate more space.
        //
        PVOID NewMem ;
        ULONG NewSize, NewSizeAllocated;

        NewSize = (Tbl->nEndPointsAllocated + 100);
        NewSize += (NewSize >> 3);
        NewSizeAllocated = NewSize*Tbl->EndPointEntrySize;

        if( NULL == Tbl->EndPoints ) {
            //
            // Never allocated before. Try now.
            //
            NewMem = HeapAlloc(Tbl->hHeap, 0, NewSizeAllocated );
            if( NULL == NewMem ) {
                NewSize = 10;
                NewSizeAllocated = NewSize * Tbl->EndPointEntrySize;
                
                NewMem = HeapAlloc(Tbl->hHeap, 0, NewSizeAllocated );
            }
        } else {
            //
            // Memory already exists? Then just reallocate it.
            //
            NewMem = HeapReAlloc(
                Tbl->hHeap, 0, Tbl->EndPoints, NewSizeAllocated
                );
        }

        if( NULL == NewMem ) {
            //
            // Couldn't allocate memory? Thats too bad. We will give
            // up now
            //
            return GetLastError();
        }

        //
        // We have allocated new memory. update pointers.
        //
        Tbl->nEndPointsAllocated = NewSize;
        Tbl->EndPoints = NewMem;        
    }

    //
    // Now just add this at the end of the table.
    //
    Entry = GET_ENDPOINT(Tbl, Tbl->nEndPoints );
    Tbl->nEndPoints ++;

    RtlZeroMemory(Entry, Tbl->EndPointEntrySize );
    Entry->IfGuid = *IfGuid;
    Entry->IpAddress = IpAddress;
    Entry->IpIndex = IpIndex;
    Entry->IpContext = IpContext;
    Entry->SubnetMask = SubnetMask;

    //
    // Now notify caller.
    //
    Tbl->Callback(
        REASON_ENDPOINT_CREATED,
        Entry
        );

    return ERROR_SUCCESS;
}

VOID
WalkthroughEndpoints(
    IN PVOID Context,
    IN BOOL (_stdcall *WalkthroughRoutine)(
        IN OUT PENDPOINT_ENTRY Entry,
        IN PVOID Context
        )
    )
/*++

Routine Description:
    This routine walks through the table of endpoints and calls the
    WalkthroughRoutine provided, for each of the endpoint entries.

    If the WalkthroughRoutine returns FALSE, then the enumeration is
    aborted and the routine returns.

    N.B The global endpoint lock is taken while enumerating.  So, this
    operation should happen fast or else several things may get
    blocked.

Arguments:
    Context -- the context to pass to the enumeration routine.
    WalkthroughRoutine -- enumeration rtn to be called on each
        endpoint.

--*/
{
    ULONG i;
    PENDPOINT_TBL Tbl = &DhcpGlobalEndPointTable;

    if( 0 == Tbl->InitCount ) return ;

    EnterCriticalSection(Tbl->CS);
    do {
        if( 0 == Tbl->InitCount ) break;

        for( i = 0; i < Tbl->nEndPoints ; i ++ ) {
            BOOL fStatus;

            fStatus = WalkthroughRoutine(
                GET_ENDPOINT(Tbl,i),
                Context
                );
            if( FALSE == fStatus ) break;
        }
    } while ( 0 );
    LeaveCriticalSection(Tbl->CS);
}

//
// Address change notification handler is defined at a later
// point.
//
void CALLBACK AddrChangeHandler(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED Overlap,
    IN DWORD dwFlags
    );


ULONG
PostAddrChangeNotification(
    IN SOCKET Sock,
    IN OUT LPWSAOVERLAPPED Overlap,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE AddrChangeHandler,
    OUT BOOL *fImmediatelyCompleted
    )
/*++

Routine Description:
    This routine posts an address change notification with winsock.
    N.B.  It is possible that the address has already changed -- in
    this case the routine returns NO_ERROR and
    (*fImmediatelyCompleted) is set to TRUE to indicate this happend.

Arguments:
    Sock -- socket to use for posting the event.
    Overlap -- the overlapped structure to use.
    AddrChangeHandler -- the handler that shoudl be called on changes.
    fImmediatelyCompleted -- this is set to TRUE if the event happens
        immediately. In this case the handler wont automatically get
        called.


Return Values:
    NO_ERROR -- either the change already happened
       (fImmediatelyCompleted would be set to TRUE then) or the change
       notification handler was successfully registered.
    Winsock errors
    
--*/    
{
    ULONG Status, unused;

    *fImmediatelyCompleted = FALSE;
    RtlZeroMemory(Overlap, sizeof(*Overlap));
    Status = WSAIoctl(
        Sock,
        SIO_ADDRESS_LIST_CHANGE,
        NULL, 0, NULL, 0, &unused,
        Overlap, AddrChangeHandler
        );
    if( NO_ERROR == Status ) {
        //
        // Completed right away.  tell that to caller.
        //
        *fImmediatelyCompleted = TRUE;
        return NO_ERROR;
    }
    
    //
    // it _must_ be SOCKET_ERROR.
    //

    if( SOCKET_ERROR == Status ) Status = WSAGetLastError();
    if( WSA_IO_PENDING == Status ) {
        //
        // The notification was successfully posted.
        //
        Status = NO_ERROR;
    }
    return Status;
}

ULONG
CreateAddrListChangeSocket(
    OUT SOCKET *Sock,
    OUT LPWSAOVERLAPPED Overlap,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE AddrChangeHandler
    )
/*++

Routine Description:
    This routine creates a socket to receive address change
    notifications on, and also register the provided handler for the
    same.

    N.B. If there are some addresses already present, then the
    notification wont happen, but it will be faked and the
    notifyhandler routine would be artificially called from within
    this routine.

Arguments:
    Sock -- variable that will contain the socket on successful
        return from this routine.
    Overlap -- the overlap structure to use for performing this
        operation.
    AddrChangeHandler -- handler that has to be called whenever any
        address change happens.

Return Values:
    NO_ERROR -- everything went fine.
    Winsock errors
    
--*/
{
    ULONG Status;
    BOOL fChanged;
    
    (*Sock) = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if( INVALID_SOCKET == (*Sock) ) {
        //
        // Couldn't as much as create a socket?
        //
        return WSAGetLastError();
    }

    Status = PostAddrChangeNotification(
        *Sock, Overlap, AddrChangeHandler, &fChanged
        );
    //
    // Apparently the above routine gives notifications only if things
    // change -- so for first time around we just fake a notification.
    //
    fChanged = TRUE; 
    if( NO_ERROR == Status ) {
        if( fChanged ) {
            //
            // Ugh.  Somethings have happened already.  Fake a AddrChangeHandler
            //
            AddrChangeHandler(
                0,
                0,
                Overlap,
                0
                );
        }
    } else {
        closesocket(*Sock);
        *Sock = INVALID_SOCKET;
    }
    
    return Status;
}

ULONG
DestroyAddrListChangeSocket(
    IN OUT SOCKET *Sock
    )
/*++

Routine Description:
    This routine destroys the socket on which a notification had been
    posted. This automatically cancels any pending notifications (but
    not one that is in progress).

Arguments:
    Sock -- socket to destroy.


Return Values:
    Winsock errors;

--*/
{
    SOCKET CapturedSockValue = (*Sock);
    (*Sock) = INVALID_SOCKET;

    if( SOCKET_ERROR == closesocket(CapturedSockValue)) {
        return WSAGetLastError();
    }

    return NO_ERROR;
}

//
// This the routine that is called to initialize this module.
//
ULONG
IpTblInitialize(
    IN OUT PCRITICAL_SECTION CS,
    IN ULONG EndPointEntrySize,
    IN ENDPOINT_CALLBACK_RTN Callback,
    IN HANDLE hHeap
    )
/*++

Routine Description:
    This routine attempts to initialize the IP address table.
    N.B. It can be called multiple times if the same set of parameters
    are used. (Else, it returns an error).

Arguments:
    CS -- the critical section used by all entries in this routine.
    EndPointEntrySize -- this is the size of the total endpoint
        inclusive of user allocated data region as well as the core 
        ENDPOINT_ENTRY structure.
    Callback -- the routine to call to add or delete endpoints
    hHeap -- heap to allocate off of.
    
Return Value:
    NO_ERROR if everything went fine.
    ERROR_CAN_NOT_COMPLETE if unable to complete operation.
    winsock errors 
    
--*/
{
    ULONG Status = NO_ERROR;
    
    EnterCriticalSection(CS);
    do {
        fHandlingAddrChange = 0;
        if( DhcpGlobalEndPointTable.InitCount ) {
            if( DhcpGlobalEndPointTable.CS != CS ) {
                //
                // Oops. Serious trouble.
                //
                Status = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }
        DhcpGlobalEndPointTable.InitCount ++;
        DhcpGlobalEndPointTable.CS = CS;
        DhcpGlobalEndPointTable.Callback = Callback;
        DhcpGlobalEndPointTable.EndPointEntrySize = EndPointEntrySize;
        DhcpGlobalEndPointTable.hHeap = hHeap;

        Status = CreateAddrListChangeSocket(
            &DhcpGlobalEndPointTable.NotifySock,
            &DhcpGlobalEndPointTable.Overlap,
            AddrChangeHandler
            );
        if( NO_ERROR != Status ) {
            DhcpGlobalEndPointTable.InitCount --;
            break;
        }
    } while ( 0 );
    LeaveCriticalSection(CS);
    return Status;

}

VOID
IpTblCleanup(
    VOID
    )
/*++

Routine Description:
    Thsi routine undoes the effect of hte previous routine and it
    makes sure that no callbacks are executed after the routine
    returns.

--*/
{
    PCRITICAL_SECTION CS;

    if( 0 == DhcpGlobalEndPointTable.InitCount ) return;

    // Are we currently handling address change?
    // set the flag if not already set
    if ( InterlockedCompareExchange( &fHandlingAddrChange, 1, 0 )) {
        return;
    } // if

    CountRwLockAcquireForWrite( &SocketRwLock );
    CS = DhcpGlobalEndPointTable.CS;
    EnterCriticalSection(CS);
    do {
        ULONG i;

        if( 0 == DhcpGlobalEndPointTable.InitCount ) break;

        DhcpGlobalEndPointTable.InitCount --;
        if( 0 != DhcpGlobalEndPointTable.InitCount ) {
            //
            // Someone else has the table open! 
            //
            break;
        }

        for( i = 0; i < DhcpGlobalEndPointTable.nEndPoints; i ++ ) {
            DhcpGlobalEndPointTable.Callback(
                REASON_ENDPOINT_DELETED,
                GET_ENDPOINT(&DhcpGlobalEndPointTable,i)
                );
        }

        HeapFree(
            DhcpGlobalEndPointTable.hHeap, 0,
            DhcpGlobalEndPointTable.EndPoints
            );
        DestroyAddrListChangeSocket(&DhcpGlobalEndPointTable.NotifySock);
        RtlZeroMemory(
            &DhcpGlobalEndPointTable, sizeof(DhcpGlobalEndPointTable)
            );
    } while ( 0 );
    LeaveCriticalSection(CS);
    CountRwLockRelease( &SocketRwLock );

    // Done with address changes, unset flag
    DhcpAssert( 1 == fHandlingAddrChange );
    InterlockedExchange( &fHandlingAddrChange, 0 );

} // IpTblCleanup()

//
// Real address change notification handler
//
void HandleAddressChange(
    IN OUT PENDPOINT_TBL Tbl
    );

void CALLBACK AddrChangeHandler(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED Overlap,
    IN DWORD dwFlags
    )
/*++

Routine Description:
    This routine is called whenever any address change happens.
    This routine does not do anything if there was an error (only
    possibility is that the socket was closed underneath).

    It starts off by delaying handling the notifications by sleeping
    for 10 seconds.  Then the real notifications are handled under the
    global Critical section.

Arguments:
    dwError -- was the operation successful?
    cbTransferred -- unused
    Overlap -- the overlap buffer.
    dwFlags -- unused

--*/
{
    ULONG Status;
    PENDPOINT_TBL EpTbl;

    UNREFERENCED_PARAMETER(cbTransferred);
    UNREFERENCED_PARAMETER(dwFlags);

    if( NO_ERROR != dwError ) {
        return;
    }

    // Are we currently handling address change?
    // set the flag if not already set
    if ( InterlockedCompareExchange( &fHandlingAddrChange, 1, 0 )) {
        return;
    } // if

    EpTbl = (PENDPOINT_TBL)(
        ((PBYTE)Overlap) - FIELD_OFFSET(ENDPOINT_TBL, Overlap)
        );

    HandleAddressChange(EpTbl);

    // Done with address changes, unset flag
    DhcpAssert( 1 == fHandlingAddrChange );
    InterlockedExchange( &fHandlingAddrChange, 0 );
} // AddrChangeHandler()

VOID
UpdateTable(
    IN OUT PENDPOINT_TBL Tbl
    );

void HandleAddressChange(
    IN OUT PENDPOINT_TBL Tbl
    )
/*++

Routine Description:
    See AddrChangeHandler.

--*/
{
    ULONG Status;
    BOOL fFired;

    if( 0 == Tbl->InitCount ) {
        //
        // De-initialzed?
        //
        return;
    }

    //
    // obtain the socket lock so endpoint changes are
    // protected.
    //
    CountRwLockAcquireForWrite( &SocketRwLock );

    EnterCriticalSection(Tbl->CS);
    do {
        if( 0 == Tbl->InitCount ) break;

        //
        // Wait for 10 seconds before posting any real notifications.
        //
        Sleep(TEMP_SLEEP_TIME);

        //
        // reregister the notifications. ignore anything that has
        // changed until now.
        //
        do {
            Status = PostAddrChangeNotification(
                Tbl->NotifySock, &Tbl->Overlap, AddrChangeHandler, &fFired
                );
            if( NO_ERROR != Status ) break;
        } while ( fFired );

        //
        // Now do the real meat of the work.
        //
        UpdateTable(Tbl);
    } while ( 0 );
    LeaveCriticalSection(Tbl->CS);

    //
    // Done with the endpoint changes
    //
    CountRwLockRelease( &SocketRwLock );

} // HandleAddressChange()

typedef
BOOL
(*PWALTHROUGH_RTN)(
    IN PVOID Context,
    IN PMIB_IPADDRROW AddrInfo,
    IN PIP_ADAPTER_INDEX_MAP IfInfo
    )
/*++

Routine Description:
    This is the prototype of the routine to be used to walkthrough
    the IPAddrTable and IfInfo.  For each entry in the addr table,
    the ifrow and ipaddrrow for that is passed to the routine.
    Both of the above should not be modified in any way.
    
Return Values:
    return FALSE to indicate that walkthrough should stop.
    return TRUE to indicate that walkthrough should continue.

--*/
;

VOID
WalkthroughEntries(
    IN PIP_INTERFACE_INFO IfInfo,
    IN PMIB_IPADDRTABLE AddrTable,
    IN PWALTHROUGH_RTN Routine,
    IN PVOID Context
    )
{
    LONG i;
    ULONG j;
    
    if( NULL == IfInfo || NULL == AddrTable ) {
        //
        // What do we do about the addresss?
        // For now, we just ignore.
        //
        return;
    }

    for(i = 0; i < IfInfo->NumAdapters ; i ++ ) {
        //
        // Now walk through the addr table for
        // entries for this interface.
        //
        ULONG Index = IfInfo->Adapter[i].Index;
        
        for( j = 0; j < AddrTable->dwNumEntries ; j ++ ) {
            if( Index == AddrTable->table[j].dwIndex ) {
                //
                // found another address on this interface.
                //
                BOOL fStatus = Routine(
                    Context,
                    &AddrTable->table[j],
                    &IfInfo->Adapter[i]
                    );
                if( FALSE == fStatus ) {
                    //
                    // end this routine right away.
                    //
                    return ;
                }
            }
        }
    }
}

typedef struct _search_context {
    ULONG IpAddress;
    ULONG IpIndex;
    LPCWSTR AdapterName;
    PULONG SubnetMask;
    BOOL fFound;
} SRCH_CTXT;

BOOL
SearchForEntryRoutine(
    IN PVOID Context,
    IN PMIB_IPADDRROW AddrInfo,
    IN PIP_ADAPTER_INDEX_MAP IfInfo
    )
/*++
    See PWALTHROUGH_RTN declaration.
    This routine returns FALSE if the current element is the
    required element.

--*/
{
    SRCH_CTXT *Ctxt = Context;
    //
    // first check IP address and index
    //

    if( AddrInfo->dwAddr != Ctxt->IpAddress ) return TRUE;
    if( AddrInfo->dwIndex != Ctxt->IpIndex ) return TRUE;

    //
    // Now case insensitive search for adapter name.
    //
    if( 0 != _wcsicmp(Ctxt->AdapterName, TCPPREFIX_LEN + IfInfo->Name ) )
        return TRUE;

    //
    // Ok everything matches.  Now set the subnet mask if it
    // had changed meanwhile.
    //
    if( *(Ctxt->SubnetMask) != AddrInfo->dwMask ) {
        *(Ctxt->SubnetMask) = AddrInfo->dwMask;
    }

    //
    // Since the match happened -- don't need to do anything more.
    // just return FALSE to indicate search has to stop.
    //
    Ctxt->fFound = TRUE;
    return FALSE;
}

BOOL
SearchForEntry(
    IN PIP_INTERFACE_INFO IfInfo,
    IN PMIB_IPADDRTABLE AddrTable,
    IN LPCWSTR AdapterName,
    IN ULONG IpAddress,
    IN ULONG IpIndex,
    OUT ULONG *SubnetMask
    )
/*++

Routine Description:
    This routine walks the AddrTable,IfInfo and for each entry in
    that, it checks to see if it is the same as the AdapterName,
    IpAddress and IpIndex triple.  If so, it sets the SubnetMask to
    any new value (if it had changed) and returns TRUE.

    If no matches were found, this routine returns FALSE.

    AdapterName comparisons are case insensitive.

    N.B.  Walking the IpAddrTable is done by calling
    WalkthroughEntries with a routine that will handle comparing each
    item.

Arguments:
    IfInfo -- list of interfaces (used for adatper name)
    AddrTable -- list of addresses
    AdapterName -- the adapter name to compare.
    IpAddress -- ip address to compare
    IpIndex -- index to compare.
    SubnetMask -- if an entry is found with diff mask, update mask
        here.

Return Values:
    TRUE -- match found.
    FALSE -- no match found.

--*/
{
    SRCH_CTXT Ctxt = {
        IpAddress,
        IpIndex,
        AdapterName,
        SubnetMask,
        FALSE
    };

    WalkthroughEntries(
        IfInfo,
        AddrTable,
        SearchForEntryRoutine,
        &Ctxt
        );

    return Ctxt.fFound;
}

BOOL
AddEntriesRoutine(
    IN PVOID Context,
    IN PMIB_IPADDRROW AddrInfo,
    IN PIP_ADAPTER_INDEX_MAP IfInfo
    )
/*++

Routine Description:
    This routine attempts to add the specified address as an entry in
    the endpoint table, if one didnt exist.  It also calls the
    callback at this time to indicate this to higher layer.

    N.B. This routine ignores any zero addresses.

Arguments:
    Context -- this is actually the Tbl structure.
    AddrInfo -- info on the address
    IfInfo -- info on interface this address bleongs to.

Return Value:
    always TRUE.
--*/
{
    GUID IfGuid;
    ULONG i;
    PENDPOINT_TBL Tbl = Context;
    
    //
    // Ignore zero addresses.
    //
    if( 0 == AddrInfo->dwAddr ) return TRUE;

    //
    // If interface name isn't a guid, then drop interface.
    //
    if( !ConvertGuidFromIfNameString(&IfGuid, TCPPREFIX_LEN + IfInfo->Name) ) {
        return TRUE;
    }

    //
    // Now comes the meat of the work of walking through the
    // end point table looking for this same entry.
    //

    for( i = 0; i < Tbl->nEndPoints; i ++ ) {
        PENDPOINT_ENTRY Entry = GET_ENDPOINT(Tbl, i);

        if( Entry->IpAddress != AddrInfo->dwAddr ) continue;
        if( Entry->IpIndex != AddrInfo->dwIndex ) continue;
        if( !RtlEqualMemory(
            &Entry->IfGuid,&IfGuid,sizeof(IfGuid)) ) {
            continue;
        }

        //
        // ooo. found a match! so, we can't add this entry.
        //
        return TRUE;
    }

    //
    // Ok, entry isn't found.  Now try to allocate space for
    // it and add it if possible.
    //

    ADD_ENDPOINT(
        Tbl, &IfGuid, AddrInfo->dwAddr,
        AddrInfo->dwIndex, AddrInfo->dwReasmSize, AddrInfo->dwMask
        );

    return TRUE;
}

BOOL _stdcall RefreshEndPointsRoutine(
    IN PENDPOINT_ENTRY Entry,
    IN PENDPOINT_TBL Tbl
    )
{
    Tbl->Callback(
        REASON_ENDPOINT_REFRESHED,
        Entry 
       );
    return TRUE;
}
    
VOID
UpdateTable(
    IN OUT PENDPOINT_TBL Tbl
    )
/*++

Routine Description:
    This routine updates the table by retrieving all info from IP.
    It also calls the notificiation handler in Tbl->Callback.

Arguments:
    Tbl to update.

Return Value:
    none

--*/
{
    PIP_INTERFACE_INFO IfInfo;
    PMIB_IPADDRTABLE AddrTable;
    ULONG Status, Size, i;

    //
    // First get the IF table.
    //
    
    IfInfo = NULL; Size = 0;
    do {
        Status = GetInterfaceInfo(
            IfInfo,
            &Size
            );
        if( ERROR_INSUFFICIENT_BUFFER != Status ) break;
        if( IfInfo ) HeapFree(Tbl->hHeap, 0, IfInfo);
        if( 0 == Size ) {
            IfInfo = NULL;
            Status = NO_ERROR;
            break;
        }
        IfInfo = HeapAlloc(Tbl->hHeap, 0, Size);
        if( NULL == IfInfo ) {
            Status = GetLastError();
            break;
        }
    } while ( TRUE );

    if( NO_ERROR != Status ) return;
    
    //
    // Next get the addr table
    //

    AddrTable = NULL; Size = 0;
    do {
        Status = GetIpAddrTable(
            AddrTable,
            &Size,
            FALSE
            );
        if( ERROR_INSUFFICIENT_BUFFER != Status ) break;
        if( AddrTable ) HeapFree(Tbl->hHeap, 0, AddrTable);
        if( 0 == Size ) {
            AddrTable = NULL;
            Status = NO_ERROR;
            break;
        }
        AddrTable = HeapAlloc(Tbl->hHeap, 0, Size);
        if( NULL == AddrTable ) {
            Status = GetLastError();
            break;
        }
    } while (TRUE );

    if( NO_ERROR != Status ) {
        if(IfInfo ) HeapFree(Tbl->hHeap, 0, IfInfo );
        return;
    }

    //
    // Now first walk through the endpoint table and see if
    // any of old entries are not valid anymore.
    //
    for( i = 0 ; i < Tbl->nEndPoints ; i ++ ) {
        PENDPOINT_ENTRY Entry = GET_ENDPOINT(Tbl, i);
        WCHAR GuidString[50];
        BOOL fStatus;

        fStatus = ConvertGuidToIfNameString(
            &Entry->IfGuid, GuidString,
            sizeof(GuidString)/sizeof(WCHAR)
            );
        if( FALSE == fStatus ) {
            //
            // Couldn't convert? Can't really happen.
            //
            //RtlAssert( "FALSE", __FILE__, __LINE__, NULL);
            continue;
        }

        //
        // Now see if there is any adapter with the
        // same set of GuidString, Entry->IpAddress, Entry->IpIndex
        //
        fStatus = SearchForEntry(
            IfInfo, AddrTable,
            GuidString, Entry->IpAddress, Entry->IpIndex,
            &Entry->SubnetMask
            );
        if( FALSE != fStatus ) {
            //
            // Cool. The entry was also present in the newer IP table.
            // nothing to do for this entry.
            //
            continue;
        }

        //
        // if this isn't found, then this entry doesn't exist
        // anymore -- so delete this.
        //
        // Now we can ignore this entry and move the rest of
        // the stuff out of the way.
        //
        DELETE_ENDPOINT(Tbl, i);
        i -- ;
    }

    //
    // We have deleted all endpoints that need to be deleted.
    // Now walk through the IP table and add all entries that
    // have to be added.
    //

    WalkthroughEntries(
        IfInfo, AddrTable,
        AddEntriesRoutine,
        Tbl
        );

    //
    // Now free the tables concerned.
    //
    if( IfInfo ) HeapFree( Tbl->hHeap, 0, IfInfo );
    if( AddrTable ) HeapFree( Tbl->hHeap, 0, AddrTable );

    //
    // Now give a chance to update everything.
    //
    WalkthroughEndpoints(
        Tbl,
        RefreshEndPointsRoutine
        );

} // UpdateTable()

BOOL
IsIpAddrBound(
    IN DWORD IpAddr
)
{
    ENDPOINT_ENTRY *pEndPoint;
    PENDPOINT_TBL   pTbl;
    BOOL            found = FALSE;
    DWORD           index;

    pTbl = &DhcpGlobalEndPointTable;
    EnterCriticalSection( pTbl->CS );

    for ( index = 0; 
	  ( index < pTbl->nEndPoints ) && ( found == FALSE );
	  index++ ) {
	pEndPoint = GetEndPointEntry( pTbl, index );
	if ( pEndPoint->IpAddress == IpAddr ) {
	    found = TRUE;
	}
    } // while
    LeaveCriticalSection( pTbl->CS );

    return found;
} // IsIpAddrBound()


//
// End of file.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\iptbl.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:
    iptbl.h

Abstract:
    implements the IP addr table notification mechanism.

Environment:
    Usermode Win32, NT5+

--*/

#ifndef IPTBL_H_INCLUDED
#define IPTBL_H_INCLUDED

#ifdef _cplusplus
extern "C" {
#endif


//
// Each endpoint has the following struct.
//

#define MAX_GUID_STRING_SIZE 60

typedef struct _ENDPOINT_ENTRY {
    GUID IfGuid;
    ULONG IpAddress;
    ULONG IpIndex;
    ULONG SubnetMask;
    ULONG IpContext;
    //
    // This area is followed by any user-allocated data.
    //
} ENDPOINT_ENTRY, *PENDPOINT_ENTRY;


//
// this is the routine that is called back when changes occur.
//
#define REASON_ENDPOINT_CREATED   0x01
#define REASON_ENDPOINT_DELETED   0x02
#define REASON_ENDPOINT_REFRESHED 0x03

typedef VOID (_stdcall *ENDPOINT_CALLBACK_RTN)(
    IN ULONG Reason,
    IN OUT PENDPOINT_ENTRY EndPoint
    );

VOID
WalkthroughEndpoints(
    IN PVOID Context,
    IN BOOL (_stdcall *WalkthroughRoutine)(
        IN OUT PENDPOINT_ENTRY Entry,
        IN PVOID Context
        )
    );

//
// This the routine that is called to initialize this module.
//
ULONG
IpTblInitialize(
    IN OUT PCRITICAL_SECTION CS,
    IN ULONG EndPointEntrySize,
    IN ENDPOINT_CALLBACK_RTN Callback,
    IN HANDLE hHeap
    );

VOID
IpTblCleanup(
    VOID
    );

BOOL
IsIpAddrBound(
    IN DWORD IpAddr
);

#ifdef _cplusplus
}
#endif

#endif  IPTBL_H_INCLUDED
//
// end of file.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\lock.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:
    lock.c

Abstract:
    Implement recursive read write locks

Environment:
    User mode win32 NT

--*/
#include <dhcppch.h>

DWORD
RwLockInit(
    IN OUT PRW_LOCK Lock
) 
{
    Lock->fInit = FALSE;
    Lock->fWriterWaiting = FALSE;
    Lock->TlsIndex = TlsAlloc();
    if( 0xFFFFFFFF == Lock->TlsIndex ) {
        //
        // Could not allocate thread local space?
        //
        return GetLastError();
    }

    Lock->LockCount = 0;
    if ( !InitializeCriticalSectionAndSpinCount( &Lock->Lock, 0 )) {
        return( GetLastError( ) );
    }

    Lock->ReadersDoneEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if( NULL == Lock->ReadersDoneEvent ) {
        ULONG Error = GetLastError();

        TlsFree(Lock->TlsIndex);
        DeleteCriticalSection( &Lock->Lock );
        return Error;
    }

    Lock->fInit = TRUE;
    return ERROR_SUCCESS;
} // RwLockInit()

DWORD
RwLockCleanup(
    IN OUT PRW_LOCK Lock
) 
{
    BOOL Status;

    if ( !Lock->fInit ) {
        return ERROR_SUCCESS;
    }
    DhcpAssert( 0 == Lock->LockCount);

    Status = TlsFree(Lock->TlsIndex);
    if( FALSE == Status ) { 
        DhcpAssert(FALSE); 
        return GetLastError(); 
    }
    DeleteCriticalSection(&Lock->Lock);

    return ERROR_SUCCESS;
} // RwLockCleanup()

VOID
RwLockAcquireForRead(
    IN OUT PRW_LOCK Lock
) 
{
    DWORD TlsIndex, Status;
    LONG LockState;

    TlsIndex = Lock->TlsIndex;
    DhcpAssert( 0xFFFFFFFF != TlsIndex);

    LockState = (LONG)((ULONG_PTR)TlsGetValue(TlsIndex));
    if( LockState > 0 ) {
        //
        // already taken this read lock
        //
        LockState ++;
        Status = TlsSetValue(TlsIndex, ULongToPtr(LockState));
        DhcpAssert( 0 != Status);
        return;
    }

    if( LockState < 0 ) {
        //
        // already taken  a # of write locks, pretend this is one too
        //
        LockState --;
        Status = TlsSetValue(TlsIndex, ULongToPtr(LockState));
        DhcpAssert( 0 != Status);
        return;
    }

    EnterCriticalSection(&Lock->Lock);
    InterlockedIncrement( &Lock->LockCount );
    LeaveCriticalSection(&Lock->Lock);
    
    LockState = 1;
    Status = TlsSetValue(TlsIndex, ULongToPtr(LockState));
    DhcpAssert(0 != Status);

} // RwLockAcquireForRead()

VOID
RwLockAcquireForWrite(
    IN OUT PRW_LOCK Lock
) 
{
    DWORD TlsIndex, Status;
    LONG LockState;

    TlsIndex = Lock->TlsIndex;
    DhcpAssert( 0xFFFFFFFF != TlsIndex);

    LockState = (LONG)((ULONG_PTR)TlsGetValue(TlsIndex));
    if( LockState > 0 ) {
        //
        // already taken # of read locks? Can't take write locks then!
        //
        DhcpAssert(FALSE);
        return;
    }

    if( LockState < 0 ) {
        //
        // already taken  a # of write locks, ok, take once more
        //
        LockState --;
        Status = TlsSetValue(TlsIndex, ULongToPtr(LockState));
        DhcpAssert( 0 != Status);
        return;
    }

    EnterCriticalSection(&Lock->Lock);
    LockState = -1;
    Status = TlsSetValue(TlsIndex, ULongToPtr(LockState));
    DhcpAssert(0 != Status);

    if( InterlockedDecrement( &Lock->LockCount ) >= 0 ) {
        //
        // Wait for all the readers to get done..
        //
        WaitForSingleObject(Lock->ReadersDoneEvent, INFINITE );
    }

} // RwLockAcquireForWrite()

VOID
RwLockRelease(
    IN OUT PRW_LOCK Lock
) 
{
    DWORD TlsIndex, Status;
    LONG LockState;
    BOOL fReadLock;

    TlsIndex = Lock->TlsIndex;
    DhcpAssert( 0xFFFFFFFF != TlsIndex);

    LockState = (LONG)((ULONG_PTR)TlsGetValue(TlsIndex));
    DhcpAssert(0 != LockState);

    fReadLock = (LockState > 0);
    if( fReadLock ) {
        LockState -- ;
    } else {
        LockState ++ ;
    }

    Status = TlsSetValue( TlsIndex, ULongToPtr( LockState) );
    DhcpAssert( 0 != Status );

    if( LockState != 0 ) {
        //
        // Recursively taken? Just unwind recursion..
        // nothing more to do.
        //
        return;
    }

    //
    // If this is a write lock, we have to check to see 
    //
    if( FALSE == fReadLock ) {
        //
        // Reduce count to zero
        //
        DhcpAssert( Lock->LockCount == -1 );
        Lock->LockCount = 0;
        LeaveCriticalSection( &Lock->Lock );
        return;
    }

    //
    // Releasing a read lock -- check if we are the last to release
    // if so, and if any writer pending, allow writer..
    //

    if( InterlockedDecrement( &Lock->LockCount ) < 0 ) {
        SetEvent( Lock->ReadersDoneEvent );
    }

} // RwLockRelease()

//
// specific requirements for dhcp server -- code for that follows
//
RW_LOCK DhcpGlobalReadWriteLock;

//
// This lock is used to synchronize the access to sockets
//
RW_LOCK SocketRwLock;

DWORD
DhcpReadWriteInit(
    VOID
)
{
    DWORD Error;

    do {
        Error = RwLockInit( &DhcpGlobalReadWriteLock );
        if ( ERROR_SUCCESS != Error ) {
            break;
        }

        Error = RwLockInit( &SocketRwLock );
        if ( ERROR_SUCCESS != Error ) {
            break;
        }

    } while ( FALSE );

    if ( ERROR_SUCCESS != Error ) {
        RwLockCleanup( &DhcpGlobalReadWriteLock );
        RwLockCleanup( &SocketRwLock );
    }

    return Error;
} // DhcpReadWriteInit()

VOID
DhcpReadWriteCleanup(
    VOID
)
{
    RwLockCleanup( &DhcpGlobalReadWriteLock );
    RwLockCleanup( &SocketRwLock );
} // DhcpReadWriteCleanup()

VOID
DhcpAcquireReadLock(
    VOID
)
{
    RwLockAcquireForRead( &DhcpGlobalReadWriteLock );
}

VOID
DhcpAcquireWriteLock(
    VOID
)
{
    RwLockAcquireForWrite( &DhcpGlobalReadWriteLock );
}

VOID
DhcpReleaseWriteLock(
    VOID
)
{
    RwLockRelease( &DhcpGlobalReadWriteLock );
}

VOID
DhcpReleaseReadLock(
    VOID
)
{
    RwLockRelease( &DhcpGlobalReadWriteLock );
}

VOID
CountRwLockAcquireForRead(
    IN OUT PRW_LOCK Lock
)
{
    DWORD Status;

    EnterCriticalSection(&Lock->Lock);
    InterlockedIncrement( &Lock->LockCount );
    DhcpPrint(( DEBUG_TRACE_CALLS, "Read Lock Acquired : Count = %ld\n", Lock->LockCount ));
    LeaveCriticalSection(&Lock->Lock);

} // CountRwLockAcquireForRead()

VOID
CountRwLockAcquireForWrite(
    IN OUT PRW_LOCK Lock
)
{
    DhcpPrint(( DEBUG_TRACE_CALLS, "Acquiring Write lock : Count = %ld\n", Lock->LockCount ));
    EnterCriticalSection( &Lock->Lock );
    Lock->fWriterWaiting = TRUE;
    // check if there are any readers active
    if ( InterlockedExchangeAdd( &Lock->LockCount, 0 ) > 0 ) {
        //
        // Wait for all the readers to get done..
        //
        DhcpPrint(( DEBUG_TRACE_CALLS, "Waiting for readers to be done : count = %ld\n",
                    Lock->LockCount ));
        WaitForSingleObject( Lock->ReadersDoneEvent, INFINITE );
    }
    Lock->LockCount = -1;
    DhcpPrint(( DEBUG_TRACE_CALLS, "WriteLock Acquired : Count = %ld\n", Lock->LockCount ));
} // CountRwLockAcquireForWrite()

VOID
CountRwLockRelease(
    IN OUT PRW_LOCK Lock
)
{
    LONG Count;

    Count = InterlockedDecrement( &Lock->LockCount );
    if ( 0 <= Count ) {
        // releasing a read lock
        DhcpPrint(( DEBUG_TRACE_CALLS, "Read lock released : Count = %ld\n", Lock->LockCount ));
        if (( Lock->fWriterWaiting ) && ( 0 == Count )) {
            SetEvent( Lock->ReadersDoneEvent );
        }
    }
    else {
        // Releasing a write lock
        DhcpPrint(( DEBUG_TRACE_CALLS, "Write lock releasing : Count = %ld\n", Lock->LockCount ));
        DhcpAssert( -2 == Lock->LockCount ); // There can only be one writer
        Lock->LockCount = 0;
        Lock->fWriterWaiting = FALSE;
        DhcpPrint(( DEBUG_TRACE_CALLS, "Write lock released : Count = %ld\n", Lock->LockCount ));
        LeaveCriticalSection( &Lock->Lock );
    }

} // CountRwLockRelease()


//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\lock.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//========================================================================

#ifndef SERVER_LOCK_H
#define SERVER_LOCK_H

typedef struct _RW_LOCK {
    BOOL  fInit;          // Is this lock initialized?
    BOOL  fWriterWaiting; // Is a writer waiting on the lock?
    DWORD TlsIndex;
    LONG LockCount;
    CRITICAL_SECTION Lock;
    HANDLE ReadersDoneEvent;
} RW_LOCK, *PRW_LOCK, *LPRW_LOCK;

//
// specific requirements for dhcp server -- code for that follows
//
EXTERN RW_LOCK DhcpGlobalReadWriteLock;

//
// This lock is used to synchronize the access to sockets
//
EXTERN RW_LOCK SocketRwLock;

DWORD
DhcpReadWriteInit(
    VOID
) ;


VOID
DhcpReadWriteCleanup(
    VOID
) ;


VOID
DhcpAcquireReadLock(
    VOID
) ;


VOID
DhcpAcquireWriteLock(
    VOID
) ;


VOID
DhcpReleaseWriteLock(
    VOID
) ;


VOID
DhcpReleaseReadLock(
    VOID
) ;

//
// Count RW locks are different from the other RW lock.
// These are the differences:
//    1. If a thread already has count RW read lock,
//       it cannot obtain another read lock if a writer
//       is waiting for the lock. The other RW allows this.
//    2. It is intended for locks associated with resources.
//       Eg. received DHCP packet.
//

VOID CountRwLockAcquireForRead( IN OUT PRW_LOCK Lock );
VOID CountRwLockAcquireForWrite( IN OUT PRW_LOCK Lock );
VOID CountRwLockRelease( IN OUT PRW_LOCK Lock );

#endif

//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\makefile.inc ===
$(O)\dhcptest.res: dhcptest.rc
$(O)\roguet.res: roguet.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\main.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This is the main routine for the DHCP server service.

Author:

    Madan Appiah (madana)  10-Sep-1993
    Manny Weiser (mannyw)  11-Aug-1992

Environment:

    User Mode - Win32

Revision History:

    Cheng Yang (t-cheny) 30-May-1996  superscope
    Cheng Yang (t-cheny) 24-Jun-1996  IP address detection, audit log

--*/

#include    <dhcppch.h>
#define GLOBAL_DATA_ALLOCATE                       // alloc globl data in global.h
#undef  GLOBAL_DATA
#include    <global.h>
#include    <dhcp_srv.h>
#include    <dhcp2_srv.h>
#include    <dsreg.h>
#include    <iptbl.h>
#include    <endpoint.h>


LONG DhcpGlobalDataRefCount = 0;

#define PREALLOCATE_CRITICAL_SECTION_FLAG 0x80000000

BOOL fJetDatabaseCritSectInit = FALSE;
BOOL fRegCritSectInit = FALSE;
BOOL fInProgressCritSectInit = FALSE;
BOOL fMemoryCritSectInit = FALSE;
BOOL fProcessMessageCritSectInit = FALSE;

extern
DWORD       DhcpDsInitDS(                         // initialize DS structs.. <dhcpds.h>
    IN      DWORD                  Flags,         // initialization optiosn.. must be zero
    IN      LPVOID                 IdInfo         // future use param
);

extern
VOID        DhcpDsCleanupDS(                      // undo DhcpDsInitDS
    VOID
);
#include <mdhcpsrv.h>

DWORD
Initialize(                                       // global data struct init..
    BOOLEAN ServiceStartup,
    BOOLEAN RestartInit
    );

VOID
Shutdown(
    IN DWORD ErrorCode,
    BOOLEAN ServiceEnd,
    BOOLEAN RestartClose
    );

DWORD
ClearDhcpError(
    DWORD Error
)
{

    if (( Error >= ERROR_FIRST_DHCP_SERVER_ERROR ) &&
	( Error <= ERROR_LAST_DHCP_SERVER_ERROR )) {

	DhcpGlobalServiceStatus.dwServiceSpecificExitCode = Error;
	return ERROR_SERVICE_SPECIFIC_ERROR;
    } // if

    return Error;
} // ClearDhcpErrors()

//DOC  UpdateStatus updates the dhcp service status with the Service Controller.
//DOC  RETURN VALUE is Win32 error code as returned from SetServiceStatus()
DWORD
UpdateStatus(                                     // send service status to controller
    VOID
)
{
    DWORD                          Error = ERROR_SUCCESS;
    BOOL                           SetServiceStatusRetVal;
    
    if ( 0 != DhcpGlobalServiceStatusHandle ) {
        SetServiceStatusRetVal =
            SetServiceStatus( DhcpGlobalServiceStatusHandle,
                              &DhcpGlobalServiceStatus );

        if( !SetServiceStatusRetVal ) {               // shouldn't really happen
            Error = GetLastError();
            DhcpPrint((DEBUG_ERRORS, "SetServiceStatus failed, %ld.\n", Error ));
        }
    } // if 

    return Error;
} // UpdateStatus()

//DOC LoadStrings loads a bunch of strings defined via the .mc file into an
//DOC array for sake of efficiency.
//DOC RETURN VALUE is TRUE if everything went ok, else returns FALSE.
BOOL
LoadStrings(                                      // load required strings
    VOID
) {
   DWORD                           dwSuccess;
   HMODULE                         hModule;
   DWORD                           dwID;
   VOID                            FreeStrings(); // defined right below..

   hModule = LoadLibrary( DHCP_SERVER_MODULE_NAME );
   memset( g_ppszStrings, 0, DHCP_CSTRINGS * sizeof( WCHAR * ) );

   for ( dwID = DHCP_FIRST_STRING; dwID <= DHCP_LAST_STRING; dwID++ ) {
       dwSuccess = FormatMessage(                 // format the required string
          FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
          hModule,                                // search local process
          dwID,                                   // string ID
          MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT),
          (WCHAR*) ( g_ppszStrings + dwID - DHCP_FIRST_STRING ),
          1,
          NULL
      );

      if (!dwSuccess) break;
   }

   FreeLibrary(hModule);                          // error or success, got to free.

   if( dwID <= DHCP_LAST_STRING ) {               // error!
       FreeStrings();
       return FALSE;
   }

   return TRUE;                                   // everything went fine.
}

//DOC FreeStrings free's the strings in the array loaded by LoadStrings.
VOID
FreeStrings(                                      // free's string loaded by LoadStrings
    VOID
)
{
   int                             i;

   for( i = 0; i < DHCP_CSTRINGS; i++ ) {
       if (g_ppszStrings[i] != NULL) {
           (LocalFree)( g_ppszStrings[i] );           // avoid all #defines and use (LocalFree)
           g_ppszStrings[i] = NULL;
       }
   }
}


WCHAR *
GetString(                                        // used only in chk'ed builds..
    DWORD dwID
)
{
    // if you hit this assert, change DHCP_LAST_STRING in global.h
    DhcpAssert( dwID <= DHCP_LAST_STRING );

    return g_ppszStrings[ dwID - DHCP_FIRST_STRING ];
}

ULONG
DhcpInitGlobalData (
    BOOLEAN ServiceStartup
)
{
    ULONG Error = ERROR_SUCCESS;
    BOOLEAN restartInit = FALSE;

    // This call was previously buried inside DhcpInitGlobalData.  
    // It caused a deadlock because BINL grabs first DhcpGlobalBinlSyncCritSect, then
    // gcsDHCPBINL (in TellBinlState, called from InformBinl); while DHCP calls grabs them
    // in the opposite order.
    // Now, this call to InformBinl is made whenever StartupService is true and depends on
    // nothing else.  Moreover, what it makes BINL do is initialize socket endpoints, which
    // can be safely done here since I think the variables initalised by DHCP before the
    // call, previously, are not affected adversely by BINL.
    if( ServiceStartup ) {
        InformBinl( DHCP_STARTING );
    }

    EnterCriticalSection( &DhcpGlobalBinlSyncCritSect );

    DhcpGlobalDataRefCount++;

    if (DhcpGlobalDataRefCount > 1) {

        if (ServiceStartup) {

            restartInit = TRUE;

        } else {

            LeaveCriticalSection( &DhcpGlobalBinlSyncCritSect );
            return Error;
        }
    }

    Error = Initialize( ServiceStartup, restartInit );

    LeaveCriticalSection( &DhcpGlobalBinlSyncCritSect );
    return Error;
}

VOID
DhcpCleanUpGlobalData (
    ULONG Error,
    BOOLEAN ServiceEnd
)
{
    BOOLEAN restartEnd = FALSE;

    EnterCriticalSection( &DhcpGlobalBinlSyncCritSect );

    DhcpGlobalDataRefCount--;

    if ( DhcpGlobalDataRefCount > 0 ) {

        if (ServiceEnd) {

            restartEnd = TRUE;

        } else {

            LeaveCriticalSection( &DhcpGlobalBinlSyncCritSect );
            return;
        }
    } // if

    Shutdown( Error, ServiceEnd, restartEnd );
    LeaveCriticalSection( &DhcpGlobalBinlSyncCritSect );
    return;
}


DWORD
InitializeData(                                   // init bunch of memory ...
    VOID
)
{
    DWORD                          Length;
    DWORD                          Error;

    DhcpLeaseExtension = DHCP_LEASE_EXTENSION;
    DhcpGlobalScavengerTimeout = DHCP_SCAVENGER_INTERVAL;

    Error = DhcpPendingListInit();                // init pending list structures
    if( ERROR_SUCCESS != Error ) return Error;

    Length = MAX_COMPUTERNAME_LENGTH + 1;         // get the server name
    if( !GetComputerName( DhcpGlobalServerName, &Length ) ) {
        Error = GetLastError();                   // need to use gethostname..
        DhcpPrint(( DEBUG_ERRORS, "Can't get computer name, %ld.\n", Error ));

        return Error ;
    }

    DhcpAssert( Length <= MAX_COMPUTERNAME_LENGTH );
    DhcpGlobalServerName[Length] = L'\0';
    DhcpGlobalServerNameLen = (Length + 1) * sizeof(WCHAR);

    return ERROR_SUCCESS;
}


VOID
CleanupData(                                      // sundry cleanup..
    VOID
) {
    DhcpPendingListCleanup();

    //
    // delete security objects.
    //

    if( DhcpGlobalSecurityDescriptor != NULL ) {
        NetpDeleteSecurityObject( &DhcpGlobalSecurityDescriptor );
        DhcpGlobalSecurityDescriptor = NULL;
    }

    if( DhcpSid ) {
        DhcpFreeMemory( DhcpSid );
        DhcpSid = NULL;
    }
    if ( NULL != DhcpAdminSid ) {
        DhcpFreeMemory( DhcpAdminSid );
        DhcpAdminSid = NULL;
    }

    //
    // delete well known SIDs if they are allocated already.
    //

    if( DhcpGlobalWellKnownSIDsMade ) {
        NetpFreeWellKnownSids();
        DhcpGlobalWellKnownSIDsMade = FALSE;
    }

    if( DhcpGlobalOemDatabasePath != NULL ) {
        DhcpFreeMemory( DhcpGlobalOemDatabasePath );
        DhcpGlobalOemDatabasePath = NULL;
    }

    if ( NULL != DhcpGlobalOemDatabaseName ) {
        DhcpFreeMemory( DhcpGlobalOemDatabaseName );
        DhcpGlobalOemDatabaseName = NULL;
    }

    if( DhcpGlobalOemBackupPath != NULL ) {
        DhcpFreeMemory( DhcpGlobalOemBackupPath );
        DhcpGlobalOemBackupPath = NULL;
    }

    if( DhcpGlobalOemRestorePath != NULL ) {
        DhcpFreeMemory( DhcpGlobalOemRestorePath );
        DhcpGlobalOemRestorePath = NULL;
    }

    if( DhcpGlobalOemJetBackupPath != NULL ) {
        DhcpFreeMemory( DhcpGlobalOemJetBackupPath );
        DhcpGlobalOemJetBackupPath = NULL;
    }

    if( DhcpGlobalOemJetRestorePath != NULL ) {
        DhcpFreeMemory( DhcpGlobalOemJetRestorePath );
        DhcpGlobalOemJetRestorePath = NULL;
    }
    
    if( DhcpGlobalBackupConfigFileName != NULL ) {
        DhcpFreeMemory( DhcpGlobalBackupConfigFileName );
        DhcpGlobalBackupConfigFileName = NULL;
    }

    if( DhcpGlobalRecomputeTimerEvent != NULL ) {
        CloseHandle( DhcpGlobalRecomputeTimerEvent );
        DhcpGlobalRecomputeTimerEvent = NULL;
    }

    if( DhcpGlobalProcessTerminationEvent != NULL ) {
        CloseHandle( DhcpGlobalProcessTerminationEvent );
        DhcpGlobalProcessTerminationEvent = NULL;
    }

    if( DhcpGlobalRogueWaitEvent != NULL ) {
        CloseHandle( DhcpGlobalRogueWaitEvent );
        DhcpGlobalRogueWaitEvent = NULL;
    }

    if( DhcpGlobalAddrToInstTable ) {
        DhcpFreeMemory(DhcpGlobalAddrToInstTable);
        DhcpGlobalAddrToInstTable = NULL;
    }

    if( DhcpGlobalTCPHandle != NULL ) {
        CloseHandle( DhcpGlobalTCPHandle );
        DhcpGlobalTCPHandle = NULL;
    }

    if ( DhcpGlobalEndpointReadyEvent ) {
        CloseHandle( DhcpGlobalEndpointReadyEvent );
        DhcpGlobalEndpointReadyEvent = NULL;
    }

    DhcpConfigCleanup();

} // CleanupData()

DWORD
InitializeRpc(                                    // initialize rpc like we want
    VOID
)
{
    RPC_STATUS                     rpcStatus;     // RPC_STATUS is Windows error.
    RPC_STATUS                     rpcStatus2;
    RPC_BINDING_VECTOR            *bindingVector;
    BOOL                           RpcOverTcpIP = FALSE;
    BOOL                           Bool;


    //
    // Read "RpcAPIProtocolBinding" parameter (DWORD) from registry,
    // if it is 1 - use "ncacn_ip_tcp" protocol.
    // if it is 2 - use "ncacn_np" protocol.
    // if it is 3 - use both.
    //

    //
    // if none is specified, use "ncacn_ip_tcp".
    //

    if( !(DhcpGlobalRpcProtocols & DHCP_SERVER_USE_RPC_OVER_ALL) ) {
        DhcpGlobalRpcProtocols = DHCP_SERVER_USE_RPC_OVER_TCPIP;
    }

    //
    // if we are asked to use RPC over TCPIP, do so.
    //

    if( DhcpGlobalRpcProtocols & DHCP_SERVER_USE_RPC_OVER_TCPIP ) {

        rpcStatus = RpcServerUseProtseq(
            L"ncacn_ip_tcp",                      // protocol string.
            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,       // max concurrent calls
            NULL //DhcpGlobalSecurityDescriptor
        );

        if (rpcStatus != RPC_S_OK) {
            return rpcStatus;
        }

        RpcOverTcpIP = TRUE;
    }

    //
    // if we are asked to use RPC over Named Pipe, do so.
    //

    if( DhcpGlobalRpcProtocols & DHCP_SERVER_USE_RPC_OVER_NP ) {

        rpcStatus = RpcServerUseProtseqEp(
            L"ncacn_np",                          // protocol string.
            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,       // maximum concurrent calls
            DHCP_NAMED_PIPE,                      // endpoint
            NULL// RPC bug DhcpGlobalSecurityDescriptor
        );

        if( (rpcStatus != RPC_S_DUPLICATE_ENDPOINT) &&
                (rpcStatus != RPC_S_OK) ) {

            if( DHCP_SERVER_USE_RPC_OVER_NP ==
                DhcpGlobalRpcProtocols ) {
                return rpcStatus;
            }

            //
            // just log an event
            //
            
            DhcpServerEventLog(
                EVENT_SERVER_INIT_RPC_FAILED,
                EVENTLOG_WARNING_TYPE, rpcStatus );
            
        }
        rpcStatus = RPC_S_OK;
    }

    //
    // if we are asked to use RPC over LPC, do so.
    //
    // We need this protocol for the following two reasons.
    //
    // 1. performance.
    // 2. due to a bug in the security checking when rpc is made from
    // one local system process to another local system process using
    // other protocols.
    //

    if( DhcpGlobalRpcProtocols & DHCP_SERVER_USE_RPC_OVER_LPC ) {

        rpcStatus = RpcServerUseProtseqEp(
            L"ncalrpc",                           // protocol string.
            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,       // maximum concurrent calls
            DHCP_LPC_EP,                          // endpoint
            NULL// RPC bug DhcpGlobalSecurityDescriptor
        );

        if ( (rpcStatus != RPC_S_DUPLICATE_ENDPOINT) &&
                (rpcStatus != RPC_S_OK) ) {
            return rpcStatus;
        }
        rpcStatus = RPC_S_OK;
    }

    rpcStatus = RpcServerInqBindings(&bindingVector);

    if (rpcStatus != RPC_S_OK) {
        return(rpcStatus);
    }

    rpcStatus = RpcEpRegisterNoReplaceW(
        dhcpsrv_ServerIfHandle,
        bindingVector,
        NULL,                                     // Uuid vector.
        L""                                       // annotation.
    );
    if ( rpcStatus != RPC_S_OK ) {
        return rpcStatus;
    }

    rpcStatus2 = RpcEpRegisterNoReplaceW(
        dhcpsrv2_ServerIfHandle,
        bindingVector,
        NULL,
        L""
    );

    if ( rpcStatus != RPC_S_OK ) {
        return rpcStatus;
    }

    //
    // free binding vector.
    //

    rpcStatus = RpcBindingVectorFree( &bindingVector );

    DhcpAssert( rpcStatus == RPC_S_OK );
    rpcStatus = RPC_S_OK;

    rpcStatus = RpcServerRegisterIf(dhcpsrv_ServerIfHandle, 0, 0);
    if ( rpcStatus != RPC_S_OK ) {
        return rpcStatus;
    }

    rpcStatus = RpcServerRegisterIf(dhcpsrv2_ServerIfHandle, 0, 0);
    if ( rpcStatus != RPC_S_OK ) {
        return rpcStatus;
    }

    if( RpcOverTcpIP == TRUE ) {
        LPWSTR PrincName;

        rpcStatus = RpcServerRegisterAuthInfo(
            DHCP_SERVER_SECURITY,                 // app name to security provider.
            DHCP_SERVER_SECURITY_AUTH_ID,         // Auth package ID.
            NULL,                                 // Encryption function handle.
            NULL                                  // argment pointer to Encrypt function.
        );

        if ( rpcStatus ) {
            return rpcStatus;
        }

        rpcStatus = RpcServerInqDefaultPrincName(
            RPC_C_AUTHN_GSS_NEGOTIATE, &PrincName );

        if( RPC_S_OK != rpcStatus ) return rpcStatus;

        rpcStatus = RpcServerRegisterAuthInfo(
            PrincName, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, 0 );

        RpcStringFree( &PrincName );

        if( RPC_S_OK != rpcStatus ) return rpcStatus;
    }

    rpcStatus = TcpsvcsGlobalData->StartRpcServerListen();

    DhcpGlobalRpcStarted = TRUE;
    return(rpcStatus);

} // InitializeRPC()

//DOC ServiceControlHandler is the entrypoint into the dhcp server
//DOC from the service controller.
VOID
ServiceControlHandler(                            // hdl SC operations
    IN      DWORD                  Opcode         // operation type..
) 
{
    DhcpPrint(( DEBUG_INIT, "Inside ServiceControlHandler(): Opcode = %d\n",
                Opcode ));
    switch ( Opcode ) {
    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        if (DhcpGlobalServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) {
            if( Opcode == SERVICE_CONTROL_SHUTDOWN ) {

                //
                // set this flag, so that service shut down will be
                // faster.
                //

                DhcpGlobalSystemShuttingDown = TRUE;
            }

            DhcpGlobalServiceStopping = TRUE;
            DhcpPrint(( DEBUG_MISC, "Service is stop pending.\n"));
            DhcpGlobalServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
            DhcpGlobalServiceStatus.dwCheckPoint = 1;

            UpdateStatus();                       // send response to controller

            if (! SetEvent(DhcpGlobalProcessTerminationEvent)) {

                //
                // Problem with setting event to terminate dhcp
                // service.
                //

                DhcpPrint(( DEBUG_ERRORS, "DHCP Server: Error "
                            "setting DoneEvent %lu\n",
                            GetLastError()));

                DhcpAssert(FALSE);
            }

            DhcpPrint((DEBUG_TRACE, "Set termination event!\n"));

            if( TRUE ) {                          //  Ask the worker threads to quit
                DWORD              Error;         //  Shouldnt really have errs here

                Error = DhcpNotifyWorkerThreadsQuit();
                if( ERROR_SUCCESS != Error ) {
                    DhcpPrint((DEBUG_ERRORS, "NotifyWorkerThreadsQuit:%ld\n",Error));
                }
            }

            return;
        }
        break;

    case SERVICE_CONTROL_PAUSE:

        DhcpGlobalServiceStatus.dwCurrentState = SERVICE_PAUSED;
        CALLOUT_CONTROL(DHCP_CONTROL_PAUSE);
        DhcpPrint(( DEBUG_INIT, "Service is paused.\n"));
        break;

    case SERVICE_CONTROL_CONTINUE:

        DhcpGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
        CALLOUT_CONTROL(DHCP_CONTROL_CONTINUE);
        DhcpPrint(( DEBUG_INIT, "Service is Continued.\n"));
        InformBinl(DHCP_STARTING);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        DhcpPrint(( DEBUG_INIT, "Service is interrogated.\n"));
        DhcpGlobalServiceStatus.dwCheckPoint++;
        break;

    case SERVICE_CONTROL_NETBINDADD:
    case SERVICE_CONTROL_NETBINDREMOVE:
    case SERVICE_CONTROL_NETBINDENABLE:
    case SERVICE_CONTROL_NETBINDDISABLE:
        DhcpPrint(( DEBUG_INIT, "Service: NETBIND* stuff\n" ));
        DhcpUpdateEndpointBindings();
        break;
    default:
        DhcpPrint(( DEBUG_INIT, "Service received unknown control.\n"));
        break;
    }

    UpdateStatus();                               // send status response
} // ServiceControllerHandler()

//
// Handle database and configuration restore.
//

DWORD
PerformRestore( VOID )
{

    LPWSTR RestoreConfigFileName;
    DWORD Error;
    LPWSTR TmpFile = L"dhcpparm.tmp";

    DhcpPrint(( DEBUG_MISC,
		"Restoring Configuration from %s\n", 
		DhcpGlobalOemJetRestorePath ));


    RestoreConfigFileName =
	DhcpAllocateMemory( sizeof( WCHAR ) * strlen( DhcpGlobalOemJetRestorePath ) +
			    sizeof( WCHAR ) * wcslen( DHCP_KEY_CONNECT ) +
			    sizeof( WCHAR ) * wcslen( DHCP_BACKUP_CONFIG_FILE_NAME ) +
			    sizeof( WCHAR ) * 1 );

    if ( DhcpGlobalOemJetRestorePath == NULL ) {
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    RestoreConfigFileName = 
	DhcpOemToUnicode( DhcpGlobalOemJetRestorePath, 
			  RestoreConfigFileName );
    wcscat( RestoreConfigFileName, DHCP_KEY_CONNECT );
    wcscat( RestoreConfigFileName, DHCP_BACKUP_CONFIG_FILE_NAME );

    LOCK_REGISTRY();
    
    do {

	//
	// Save a backup copy of the current parameters key
	//

	Error = DhcpBackupConfiguration( TmpFile );
	if ( ERROR_SUCCESS != Error ) {
	    DhcpServerEventLog( EVENT_SERVER_CONFIG_RESTORE_FAILED,
				EVENTLOG_ERROR_TYPE,
				Error );
	    break;
	}

	// Restore from the specified backup path
	Error = DhcpRestoreConfiguration( RestoreConfigFileName );

	if ( Error != ERROR_SUCCESS ) {
	    DhcpPrint(( DEBUG_ERRORS,
			"DhcpRestoreConfiguration failed, %ld.\n", Error ));

	    DhcpServerEventLog( EVENT_SERVER_CONFIG_RESTORE_FAILED,
				EVENTLOG_ERROR_TYPE,
				Error );
	    break;
	} // if 

	DhcpPrint(( DEBUG_MISC,
		    "Restoring database from %s\n",
		    DhcpGlobalOemJetRestorePath ));

	Error = DhcpRestoreDatabase( DhcpGlobalOemJetRestorePath );

	if( ERROR_SUCCESS != Error ) {
	    DhcpPrint(( DEBUG_ERRORS, "DhcpRestoreDatabase failed, %ld\n",
			Error ));

	    DhcpServerEventLog( EVENT_SERVER_DATABASE_RESTORE_FAILED,
				EVENTLOG_ERROR_TYPE, Error );
	    break;
	}  // if
    } while ( FALSE );

    if ( ERROR_SUCCESS == Error ) {
	DhcpServerEventLog( EVENT_SERVER_DATABASE_RESTORE_SUCCEEDED,
			    EVENTLOG_INFORMATION_TYPE, 0 );
    }
    else {
	// restore failed. copy the saved configuration back.

	DhcpGlobalRestoreStatus = Error;

	Error = DhcpRestoreConfiguration( TmpFile );

    } // else

    DhcpPrint(( DEBUG_REGISTRY,
		"Deleting RestoreBackupPath ...\n" ));
    RegDeleteValue( DhcpGlobalRegParam,
		    DHCP_RESTORE_PATH_VALUE );

    UNLOCK_REGISTRY();

    if ( NULL != RestoreConfigFileName ) {
	DhcpFreeMemory( RestoreConfigFileName );
    }

    DeleteFile( TmpFile );

    return Error;
} // PerformRestore()

//
// Defined in rpcapi1.c
//
DWORD
SetDefaultConfigInfo(
    VOID
    );


//DOC Initialize does the global data-structure initialization and it also
//DOC starts up the service itself.
//DOC RETURN VALUE: 0 is success, +ve  is Win32 err, -ve is service specific err.
DWORD
Initialize(                                       // global data struct init..
    BOOLEAN ServiceStartup,
    BOOLEAN RestartInit
) {
    DWORD                          threadId;
    DWORD                          Error = ERROR_SUCCESS;
    WSADATA                        wsaData;
    DWORD                          i;
    DWORD                          DsThreadId;
    HANDLE                         DsThreadHandle;

    //
    // Initialize dhcp to receive service requests by registering the
    // control handler.
    //

    DhcpGlobalServiceStatusHandle =
        RegisterServiceCtrlHandler( DHCP_SERVER, ServiceControlHandler );

    if ( DhcpGlobalServiceStatusHandle == 0 ) {
        Error = GetLastError();
        DhcpPrint((DEBUG_INIT, "RegisterServiceCtrlHandlerW failed, "
                   "%ld.\n", Error));

        DhcpServerEventLog( EVENT_SERVER_FAILED_REGISTER_SC,
                            EVENTLOG_ERROR_TYPE,
                            Error );

        return ClearDhcpError(Error);
    }
    //
    // Initialize all the status fields so that subsequent calls to
    // SetServiceStatus need to only update fields that changed.
    //

    DhcpGlobalServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    DhcpGlobalServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    DhcpGlobalServiceStatus.dwControlsAccepted = 0;
    DhcpGlobalServiceStatus.dwCheckPoint = 1;
    DhcpGlobalServiceStatus.dwWaitHint = 18000000; // 3 minutes.
    DhcpGlobalServiceStatus.dwWin32ExitCode = ERROR_SUCCESS;
    DhcpGlobalServiceStatus.dwServiceSpecificExitCode = 0;

    UpdateStatus();

    if (! RestartInit) {

        //
        // prepare to use the debug heap
        //

        INIT_DEBUG_HEAP( HEAPX_NORMAL );

        //
        // Initialize globals
        //

        // set to TRUE after rogue detection part decides it's ok to service
        DhcpGlobalOkToService = FALSE;

        g_hAuditLog = NULL;

        DhcpGlobalSystemShuttingDown = FALSE;
        DhcpGlobalServerPort = DHCP_SERVR_PORT;
        DhcpGlobalClientPort = DHCP_CLIENT_PORT;
    }
    if (ServiceStartup) {

        DhcpGlobalServiceStopping = FALSE;
        DhcpLeaseExtension = 0;
        DhcpGlobalCleanupInterval = DHCP_DATABASE_CLEANUP_INTERVAL;

        DhcpGlobalRpcProtocols = 0;

        DhcpGlobalScavengeIpAddressInterval = DHCP_SCAVENGE_IP_ADDRESS;
        DhcpGlobalScavengeIpAddress = FALSE;

        DhcpGlobalDetectConflictRetries = DEFAULT_DETECT_CONFLICT_RETRIES;
        DhcpGlobalBackupInterval = DEFAULT_BACKUP_INTERVAL;
        DhcpGlobalDatabaseLoggingFlag = DEFAULT_LOGGING_FLAG;
        DhcpGlobalRestoreFlag = DEFAULT_RESTORE_FLAG;

        DhcpGlobalAuditLogFlag = DEFAULT_AUDIT_LOG_FLAG;
        DhcpGlobalRecomputeTimerEvent = NULL;
        DhcpGlobalRpcStarted = FALSE;
        DhcpGlobalOemDatabasePath = NULL;
        DhcpGlobalOemBackupPath = NULL;
        DhcpGlobalOemRestorePath = NULL;
        DhcpGlobalOemJetBackupPath = NULL;
        DhcpGlobalOemJetRestorePath = NULL;
        DhcpGlobalOemDatabaseName = NULL;
        DhcpGlobalBackupConfigFileName = NULL;
        DhcpGlobalRegSoftwareRoot = NULL;
        DhcpGlobalRegRoot = NULL;
        DhcpGlobalRegConfig = NULL;
        DhcpGlobalRegSubnets = NULL;
        DhcpGlobalRegMScopes = NULL;
        DhcpGlobalRegOptionInfo = NULL;
        DhcpGlobalRegGlobalOptions = NULL;
        DhcpGlobalRegSuperScope = NULL;    // added by t-cheny: superscope
        DhcpGlobalRegParam = NULL;

        DhcpGlobalDSDomainAnsi = NULL;
        DhcpGlobalJetServerSession = 0;
        DhcpGlobalDatabaseHandle = 0;
        DhcpGlobalClientTableHandle = 0;
        DhcpGlobalClientTable = NULL;

        DhcpGlobalScavengerTimeout = 0;
        DhcpGlobalProcessorHandle = NULL;
        DhcpGlobalMessageHandle = NULL;
        DhcpGlobalProcessTerminationEvent = NULL;
        DhcpGlobalRogueWaitEvent = NULL;
        DhcpGlobalTotalNumSubnets = 0;     // added by t-cheny: superscope
        DhcpGlobalNumberOfNetsActive = 0;
        DhcpGlobalSubnetsListModified = TRUE;
        DhcpGlobalSubnetsListEmpty = FALSE;

        DhcpGlobalBindingsAware = TRUE;
        DhcpGlobalImpersonated = FALSE;

        DhcpGlobalSecurityDescriptor = NULL;
        DhcpSid = NULL;
        DhcpGlobalWellKnownSIDsMade = FALSE;
        DhcpGlobalRestoreStatus = NO_ERROR;

        if ( InitializeCriticalSectionAndSpinCount( &DhcpGlobalJetDatabaseCritSect,
                                                     PREALLOCATE_CRITICAL_SECTION_FLAG )) {
            fJetDatabaseCritSectInit = TRUE;
        }
        else {
            Error = GetLastError();
            DhcpPrint(( DEBUG_INIT, "JetDatabaseCritSect Initialization failed : %ld\n", Error ));
            return ClearDhcpError( Error );
        }

        if ( InitializeCriticalSectionAndSpinCount( &DhcpGlobalRegCritSect,
                                                     PREALLOCATE_CRITICAL_SECTION_FLAG )) {
            fRegCritSectInit = TRUE;
        }
        else {
            Error = GetLastError();
            DhcpPrint(( DEBUG_INIT, "RegCritSect Initialization failed : %ld\n", Error ));
            return ClearDhcpError( Error );
        }

        DhcpGlobalServerStartTime.dwLowDateTime = 0;
        DhcpGlobalServerStartTime.dwHighDateTime = 0;

        DhcpGlobalUseNoDns = TRUE;
        DhcpGlobalThisServer = NULL;
    }
    if (! RestartInit) {

        if ( InitializeCriticalSectionAndSpinCount( &DhcpGlobalInProgressCritSect,
                                                     PREALLOCATE_CRITICAL_SECTION_FLAG )) {
            fInProgressCritSectInit = TRUE;
        }
        else {
            Error = GetLastError();
            DhcpPrint(( DEBUG_INIT, "InProgressCritSect Initialization failed : %ld\n", Error ));
            return ClearDhcpError( Error );
        }
        if ( InitializeCriticalSectionAndSpinCount( &DhcpGlobalMemoryCritSect,
                                                     PREALLOCATE_CRITICAL_SECTION_FLAG )) {
            fMemoryCritSectInit = TRUE;
        }
        else {
            Error = GetLastError();
            DhcpPrint(( DEBUG_INIT, "MemoryCritSect Initialization failed : %ld\n", Error ));
            return ClearDhcpError( Error );
        }
        if ( InitializeCriticalSectionAndSpinCount( &g_ProcessMessageCritSect,
                                                     PREALLOCATE_CRITICAL_SECTION_FLAG )) {
            fProcessMessageCritSectInit = TRUE;
        }
        else {
            Error = GetLastError();
            DhcpPrint(( DEBUG_INIT, "g_ProcessMessageCritSect Initialization failed : %ld\n", Error ));
            return ClearDhcpError( Error );
        }

        InitializeListHead(&DhcpGlobalFreeRecvList);
        InitializeListHead(&DhcpGlobalActiveRecvList);

        DhcpGlobalMessageQueueLength = DHCP_RECV_QUEUE_LENGTH;
        DhcpGlobalRecvEvent = NULL;


#if DBG
        DhcpGlobalDebugFlag = 0xFFFF | DEBUG_LOG_IN_FILE | DEBUG_ALLOC;

        Error = DhcpMemInit();
        if( ERROR_SUCCESS != Error ) {
	    return ClearDhcpError( Error );
	}


        DhcpGlobalDebugFileHandle = NULL;

        DhcpGlobalDebugFileMaxSize = DEFAULT_MAXIMUM_DEBUGFILE_SIZE;
        DhcpGlobalDebugSharePath = NULL;

        //
        // Open debug log file.
        //

        DhcpOpenDebugFile( FALSE );  // not a reopen.
#endif
    }
    if (ServiceStartup) {
        DhcpInitDnsMemory();
        DhcpInitializeMadcap();

        Error = PerfInit();
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint(( DEBUG_INIT, "PerfInit failed %ld\n", Error));
            return Error;
        }

        //
        // Create the process termination event.
        //

        DhcpGlobalProcessTerminationEvent =
            CreateEvent(
                NULL,      // no security descriptor
                TRUE,      // MANUAL reset
                FALSE,     // initial state: not signalled
                NULL);     // no name

        if ( DhcpGlobalProcessTerminationEvent == NULL ) {
            Error = GetLastError();
            DhcpPrint((DEBUG_INIT, "Can't create ProcessTerminationEvent, "
                        "%ld.\n", Error));
            return ClearDhcpError(Error);
        }


        DhcpGlobalRogueWaitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if( NULL == DhcpGlobalRogueWaitEvent ) {
            Error = GetLastError();
            DhcpPrint((DEBUG_INIT, "Can't create RogueWaitEvent: %ld\n", Error));
            return ClearDhcpError( Error);
        }


        //
        // create the ProcessMessage termination event
        //

        g_hevtProcessMessageComplete = CreateEvent(
            NULL,
            FALSE,
            FALSE,
            NULL
        );

        if ( !g_hevtProcessMessageComplete ) {
            Error = GetLastError();

            DhcpPrint( (DEBUG_INIT,
                        "Initialize(...) CreateEvent returned error %x\n",
                        Error )
                    );

            return ClearDhcpError( Error );
        }

    }

    if (! RestartInit) {

        DhcpPrint(( DEBUG_INIT, "Initializing .. \n", 0 ));

        //
        // load localized messages from the string table
        //

        if ( !LoadStrings() )
        {
            DhcpPrint(( DEBUG_INIT, "Unable to load string table.\n" ));

            DhcpServerEventLog(
                    EVENT_SERVER_INIT_DATA_FAILED,
                    EVENTLOG_ERROR_TYPE,
                    ERROR_NOT_ENOUGH_MEMORY );

            return ClearDhcpError( ERROR_NOT_ENOUGH_MEMORY );
        }
    }
    if (ServiceStartup) {

        //
        // start up winsock
        //
        //

        Error = WSAStartup( WS_VERSION_REQUIRED, &wsaData);
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_INIT, "WSAStartup failed, %ld.\n", Error ));

            DhcpServerEventLog(
                EVENT_SERVER_INIT_WINSOCK_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            return ClearDhcpError(Error);
        }

        Error = InitializeData();
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_INIT, "Data initialization failed, %ld.\n",
                            Error ));

            DhcpServerEventLog(
                EVENT_SERVER_INIT_DATA_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            return ClearDhcpError(Error);
        }

        DhcpPrint(( DEBUG_INIT, "Data initialization succeeded.\n", 0 ));

    } // if service startup

    if (! RestartInit) {

        Error = DhcpDsInitDS(0,NULL);                 // Ignore DS errors for now.
        Error = ERROR_SUCCESS;                        // ignore errors..
    }

    Error = DhcpInitSecrets();

    if( ERROR_SUCCESS != Error ) {

        DhcpPrint((DEBUG_INIT, "Can't initialize LSA secrets stuff: %ld\n", Error));
        return ClearDhcpError( Error );

    }

    if (ServiceStartup) {
        //
        // Create well know SID for netlogon.dll
        //

        Error = RtlNtStatusToDosError( NetpCreateWellKnownSids( NULL ) );

        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "Can't create Well Known SIDs.\n", Error));
            return ClearDhcpError(Error);
        }

        DhcpGlobalWellKnownSIDsMade = TRUE;

        //
        // Create the security descriptors we'll use for the APIs
        //

        Error = DhcpCreateSecurityObjects();

        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "Can't create security object.\n", Error));
            return ClearDhcpError(Error);
        }

	// DhcpInitializeRegistry() not only initializes the registry,
	// but also tries to create the directories specified in the registry.
	// So the directories specified must be accessible upon startup time
	// otherwise the service will not startup.

        Error = DhcpInitializeRegistry();             // older init proc. appendage, will go sometime.
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "New Registry initialization failed, %ld.\n", Error ));
            DhcpServerEventLog(
                EVENT_SERVER_INIT_REGISTRY_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error
            );
            return ClearDhcpError(Error);
        }
        DhcpPrint(( DEBUG_INIT, "Registry initialization succeeded.\n", 0));

#if DBG
        //
        // break in the debugger if we are asked to do so.
        //

        if(DhcpGlobalDebugFlag & DEBUG_STARTUP_BRK) {
            // Here comes the kludge... NTSD will not be able to
            // get this because we wont know the pid of tcpsvcs.exe
            // to catch this.... So, we print messages and sleep
            // for about a minute to enable others to catch it.
            // To avoid problems, we sleep 10 seconds at a time,
            // and print messages, and do this 6 times. (Updating
            // SC with hearbeats....)
            DWORD k;

            for( k = 0 ; k < 6 && (DhcpGlobalDebugFlag & DEBUG_STARTUP_BRK) ; k ++ ) {
                DhcpPrint((DEBUG_MISC, "Going to break into debugger soon\n"));
                Sleep(5000);
            }

            DebugBreak();
        } // if break on start

#endif
        //
        // restore the database and registry configurations if we are asked
        // to do so.
        //

        if( NULL != DhcpGlobalOemJetRestorePath ) {
	    Error = PerformRestore();

	    // will return true unless the original configuration was not
	    // restored and the restore operation failed.
	    if ( ERROR_SUCCESS != Error ) {
		return ClearDhcpError(Error);
	    }


	    // The registry entries have changed. reinitialize the registry
	    // for the new settings to take effect

	    DhcpCleanupRegistry();

	    Error = DhcpInitializeRegistry();
	    if ( Error != ERROR_SUCCESS ) {
		DhcpPrint(( DEBUG_ERRORS,
			    "New Registry initialization failed, %ld.\n", Error ));
		DhcpServerEventLog( EVENT_SERVER_INIT_REGISTRY_FAILED,
				    EVENTLOG_ERROR_TYPE, Error );
		return ClearDhcpError(Error);
	    }

        } // if we need to restore 

        if( DhcpGlobalRestoreFlag ) {

            Error = DhcpRestoreConfiguration( DhcpGlobalBackupConfigFileName );

            if ( Error != ERROR_SUCCESS ) {
                DhcpPrint(( DEBUG_ERRORS,
                    "DhcpRestoreConfiguration failed, %ld.\n", Error ));

                DhcpServerEventLog(
                    EVENT_SERVER_CONFIG_RESTORE_FAILED,
                    EVENTLOG_ERROR_TYPE,
                    Error );

                return ClearDhcpError(Error);
            }

            Error = DhcpRestoreDatabase( DhcpGlobalOemJetBackupPath );

            if ( Error != ERROR_SUCCESS ) {
                DhcpPrint(( DEBUG_ERRORS,
                    "DhcpRestoreDatabase failed, %ld.\n", Error ));

                DhcpServerEventLog(
                    EVENT_SERVER_DATABASE_RESTORE_FAILED,
                    EVENTLOG_ERROR_TYPE,
                    Error );

                return ClearDhcpError(Error);
            }

            DhcpServerEventLog(
                EVENT_SERVER_DATABASE_RESTORE_SUCCEEDED,
                EVENTLOG_INFORMATION_TYPE,
                0
                );

            //
            // reset restore flag in registry, so that we don't do the
            // restore again in the next reboot.
            //

            DhcpGlobalRestoreFlag = FALSE;
            Error = RegSetValueEx(
                DhcpGlobalRegParam,
                DHCP_RESTORE_FLAG_VALUE,
                0,
                DHCP_RESTORE_FLAG_VALUE_TYPE,
                (LPBYTE)&DhcpGlobalRestoreFlag,
                sizeof(DhcpGlobalRestoreFlag)
                );

            DhcpAssert( Error == ERROR_SUCCESS );
        } // if DhcpGlobalRestoreFlag

	DhcpPrint(( DEBUG_MISC,
		    "Initializing Auditlog .. \n" ));

        Error = DhcpAuditLogInit();
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_INIT, "AuditLog failed 0x%lx\n", Error));
            return ClearDhcpError(Error);
        }

	DhcpPrint(( DEBUG_MISC,
		    "Initializing database ... \n" ));

        Error = DhcpInitializeDatabase();
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "Database init failed, %ld.\n", Error ));

            DhcpServerEventLog(
                EVENT_SERVER_INIT_DATABASE_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            //
            // the database/logfile may be corrupt, try to restore the
            // database from backup and retry database initialization once
            // again
            //

            Error = DhcpRestoreDatabase( DhcpGlobalOemJetBackupPath );

            if ( Error != ERROR_SUCCESS ) {
                DhcpPrint(( DEBUG_ERRORS,
                    "DhcpRestoreDatabase failed, %ld.\n", Error ));

                DhcpServerEventLog(
                    EVENT_SERVER_DATABASE_RESTORE_FAILED,
                    EVENTLOG_ERROR_TYPE,
                    Error );

                // Delete critical sections defined so far
                if ( fJetDatabaseCritSectInit ) {
                    DeleteCriticalSection( &DhcpGlobalJetDatabaseCritSect );
                }
                DhcpCleanupDnsMemory();
                return ClearDhcpError(Error);
            } // if

            DhcpServerEventLog(
                EVENT_SERVER_DATABASE_RESTORE_SUCCEEDED,
                EVENTLOG_INFORMATION_TYPE,
                0
                );

            Error = DhcpInitializeDatabase();

            if ( Error != ERROR_SUCCESS ) {
                DhcpPrint(( DEBUG_ERRORS,
                    "Database init failed again, %ld.\n", Error ));

                DhcpServerEventLog(
                    EVENT_SERVER_INIT_DATABASE_FAILED,
                    EVENTLOG_ERROR_TYPE,
                    Error );

                return ClearDhcpError(Error);
            }
        } // if InitializeDatabase() failed

        DhcpPrint(( DEBUG_INIT, "Database initialization succeeded.\n", 0));


        Error = DhcpConfigInit();                   // do the main reg. init. here.
        if( ERROR_SUCCESS != Error ) {                // could not get critical info
            DhcpPrint(( DEBUG_ERRORS, "Error reading config : %ld\n", Error));
            DhcpServerEventLog(
                EVENT_SERVER_INIT_CONFIG_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error
            );

            return ClearDhcpError(Error);
        }

        DhcpPrint((DEBUG_INIT, "Configuration Initialized\n"));


        //
        // Now set default configuration
        //

        Error = SetDefaultConfigInfo();
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_INIT, "Default configuration set failed 0x%lx\n", Error));
            Error = ERROR_SUCCESS;
        }

        //
        // Get TCP/IP ARP entity table for seeding arp cache entries
        //
        Error = GetAddressToInstanceTable();
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint((DEBUG_ERRORS, "could not get address to instance table, %ld\n",Error));
        }

        DhcpGlobalRecomputeTimerEvent =
            CreateEvent( NULL, FALSE, FALSE, NULL );

        if (DhcpGlobalRecomputeTimerEvent  == NULL ) {
            Error = GetLastError();
            DhcpPrint((DEBUG_INIT, "Can't create RecomputeTimerEvent, %ld.\n", Error));
            return ClearDhcpError(Error);
        }


        //
        // Start the DynamicDns engine.
        //

        if( TRUE == DhcpGlobalUseNoDns ) {

	    Error = DynamicDnsInit();
	    if ( ERROR_SUCCESS != Error ) {
		return ClearDhcpError(Error);
	    }
        } // if 

        CalloutInit();

        Error = DhcpInitializeClientToServer();
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "Client-to-server initialization "
                            "failed, %ld.\n", Error));

            DhcpServerEventLog(
                EVENT_SERVER_INIT_SOCK_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            return ClearDhcpError(Error);
        }

        DhcpPrint(( DEBUG_INIT, "Client-to-server initialization succeeded.\n", 0 ));


        DhcpGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
        DhcpGlobalServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                                     SERVICE_ACCEPT_SHUTDOWN |
                                                     SERVICE_ACCEPT_PAUSE_CONTINUE
                                                     | SERVICE_ACCEPT_NETBINDCHANGE
                                                        ;
        DhcpGlobalServiceStatus.dwCheckPoint = 0;

        UpdateStatus();
    } // if servicestartup

    if (ServiceStartup) {

        Error = DhcpRogueInit(NULL, DhcpGlobalRogueWaitEvent, DhcpGlobalProcessTerminationEvent);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_INIT, "DhcpRogueInit: %ld\n", Error));
            return ClearDhcpError(Error);
        }

        //
        // finally set the server startup time.
        //

        DhcpGlobalServerStartTime = DhcpGetDateTime();

        Error = InitializeRpc();
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "Rpc initialization failed, %ld.\n", Error ));

            DhcpServerEventLog(
                EVENT_SERVER_INIT_RPC_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            return ClearDhcpError(Error);
        }

        DhcpPrint(( DEBUG_INIT, "Rpc initialization succeeded.\n", 0));

    } // if service startup

    return ClearDhcpError(ERROR_SUCCESS);
} // Initialize()



VOID
Shutdown(
    IN DWORD ErrorCode,
    BOOLEAN ServiceEnd,
    BOOLEAN RestartClose
    )
/*++

Routine Description:

    This function shuts down the dhcp service.

Arguments:

    ErrorCode - Supplies the error code of the failure

Return Value:

    None.

--*/
{
    DWORD   Error;
    BOOL    fThreadPoolIsEmpty;
    DWORD   i;

    if (ServiceEnd) {

        DhcpPrint((DEBUG_MISC, "Shutdown started ..\n" ));


        // don't service any more requests (no need for crit sect, it's ok to
        // service one or two more requests if we hit that timing window)

        DhcpGlobalOkToService = FALSE;

        //
        // note that the service is stopping..
        //

        DhcpGlobalServiceStopping = TRUE;

        //
        // record the shutdown in audit log
        //

        DhcpUpdateAuditLog(
            DHCP_IP_LOG_STOP,
            GETSTRING( DHCP_IP_LOG_STOP_NAME ),
            0,
            NULL,
            0,
            NULL
        );

        //
        // LOG an event if this is not a normal shutdown.
        //

        if( ErrorCode != ERROR_SUCCESS ) {

            DhcpServerEventLog(
                EVENT_SERVER_SHUTDOWN,
                EVENTLOG_ERROR_TYPE,
                ErrorCode );

        }

        //
        // Service is shuting down, may be due to some service problem or
        // the administrator is stopping the service. Inform the service
        // controller.
        //

        DhcpGlobalServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        DhcpGlobalServiceStatus.dwCheckPoint = 1;

        //
        // Send the status response.
        //

        UpdateStatus();

        //
        // stop RPC interface.
        //

        if( DhcpGlobalRpcStarted ) {

            RPC_BINDING_VECTOR *bindingVector;

            Error = RpcServerInqBindings(&bindingVector);
            if (Error == RPC_S_OK) {

                Error = RpcEpUnregister(
                                dhcpsrv_ServerIfHandle,
                                bindingVector,
                                NULL );               // Uuid vector.
                DhcpPrint(( DEBUG_ERRORS, "RpcEpUnregister( 1st handle) failed : %lx \n",
                            Error ));
                Error = RpcEpUnregister(
                                dhcpsrv2_ServerIfHandle,
                                bindingVector,
                                NULL );               // Uuid vector.

                DhcpPrint(( DEBUG_ERRORS, "RpcEpUnregister( 2nd handle) failed : %lx \n",
                            Error ));
                //
                // free binding vector.
                //

                Error = RpcBindingVectorFree( &bindingVector );
            }
            else {
                DhcpPrint(( DEBUG_ERRORS, "RpcServerInqBindings() failed : %lx \n",
                            Error ));
            }

            //
            // wait for all calls to complete.
            //

            Error = RpcServerUnregisterIf( dhcpsrv_ServerIfHandle, 0, TRUE );
            DhcpPrint(( DEBUG_ERRORS, "RpcEpUnregisterIf( 1st handle) failed : %lx \n",
                        Error ));

            Error = RpcServerUnregisterIf( dhcpsrv2_ServerIfHandle, 0, TRUE );
            DhcpPrint(( DEBUG_ERRORS, "RpcEpUnregisterIf( 2nd handle) failed : %lx \n",
                        Error ));
            //
            // stop server listen.
            //
            Error = TcpsvcsGlobalData->StopRpcServerListen();
            DhcpGlobalRpcStarted = FALSE;
        } // if rpc started

        DhcpPrint((DEBUG_MISC, "RPC shut down.\n" ));

        if( DhcpGlobalProcessTerminationEvent != NULL ) {

            DATE_TIME TimeNow;

            //
            // set Termination Event so that other threads know about the
            // shut down.
            //

            SetEvent( DhcpGlobalProcessTerminationEvent );

            //
            // ENDPOINT: Cleanup rogue detection sockets..
            //

            //
            // shut down client to server : This kills all processing threads, msg thread
            // and the ping threads
            //

            DhcpCleanupClientToServer();

            //
            // wait for the rogue detect thread to complete.
            // (this thread will be alive only if we still haven't determined if
            // this dhcp server is authorized to service, or if we are running on
            // SAM server).
            //

            DhcpRogueCleanup(NULL);

            if (DhcpGlobalDSDomainAnsi) {
                LocalFree(DhcpGlobalDSDomainAnsi);
                DhcpGlobalDSDomainAnsi = NULL;
            }

            //
            // Cleanup all pending client requests.
            //

            // TimeNow = DhcpGetDateTime();
            // Error = CleanupClientRequests( &TimeNow, TRUE );
        }

        DhcpPrint((DEBUG_MISC, "Client requests cleaned up.\n" ));

        //
        // cleanup perf related stuff
        //
        PerfCleanup();

	DhcpPrint(( DEBUG_MISC, "Perf cleanedup.\n" ));

        //
        // cleanup Dhcp DNS
        //

        if ( FALSE == DhcpGlobalUseNoDns ) {    //  Get DNS to quit, as it quits fast
            if(ERROR_SUCCESS != DnsDhcpSrvRegisterTerm()) {
                DhcpAssert(FALSE);
            }
        } // if

        DhcpCleanupDnsMemory();             //   Cleanup all memory that was allocated to do DNS stuff

        DhcpPrint((DEBUG_MISC, "DhcpDns cleaned up.\n"));

        //
        // Cleanup database.
        //

        DhcpCleanupDatabase( ErrorCode );

        DhcpPrint((DEBUG_MISC, "Database cleaned up.\n" ));


        //
        // Cleanup Regsitry.
        //

        DhcpCleanupRegistry();

        DhcpPrint((DEBUG_MISC, "Registry cleaned up.\n" ));

        CalloutCleanup();

        //
        // cleanup misc stuff
        //

        DhcpAuditLogCleanup();
    } // if serviceend
    if (!RestartClose) {

        DhcpCleanupSecrets();
    }

    DhcpDsCleanupDS();

    if (ServiceEnd) {

        CleanupData();

        DhcpPrint((DEBUG_MISC, "Shutdown Completed.\n" ));
    }

    if (!RestartClose) {

        if ( fInProgressCritSectInit ) {
            DeleteCriticalSection(&DhcpGlobalInProgressCritSect);
        }

        if ( fProcessMessageCritSectInit ) {
            DeleteCriticalSection( &g_ProcessMessageCritSect );
        }

        if ( fMemoryCritSectInit ) {
            DeleteCriticalSection(&DhcpGlobalMemoryCritSect);
        }

        if ( fRegCritSectInit ) {
            DeleteCriticalSection( &DhcpGlobalRegCritSect );
        }

        if ( fJetDatabaseCritSectInit ) {
            DeleteCriticalSection( &DhcpGlobalJetDatabaseCritSect );
        }

        DhcpDsCleanupDS();

        FreeStrings();
#if DBG

        EnterCriticalSection( &DhcpGlobalDebugFileCritSect );
        if ( DhcpGlobalDebugFileHandle != NULL ) {
            CloseHandle( DhcpGlobalDebugFileHandle );
            DhcpGlobalDebugFileHandle = NULL;
        }

        if( DhcpGlobalDebugSharePath != NULL ) {
            DhcpFreeMemory( DhcpGlobalDebugSharePath );
            DhcpGlobalDebugSharePath = NULL;
        }
        LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );

#endif DBG

        //
        // don't use DhcpPrint past this point
        //

        //
        // unitialize the debug heap
        //

        UNINIT_DEBUG_HEAP();
    }

    if (ServiceEnd) {
        DhcpGlobalServiceStatus.dwCurrentState = SERVICE_STOPPED;
        DhcpGlobalServiceStatus.dwControlsAccepted = 0;
        DhcpGlobalServiceStatus.dwWin32ExitCode = ErrorCode;

        DhcpGlobalServiceStatus.dwCheckPoint = 0;
        DhcpGlobalServiceStatus.dwWaitHint = 0;

        UpdateStatus();

        //
        // Free up the jet dll handle.
        //
    }
    if (!RestartClose) {

        DhcpMemCleanup();
    }
} // Shutdown()


VOID
ServiceEntry(
    DWORD NumArgs,
    LPWSTR *ArgsArray,
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    )
/*++

Routine Description:

    This is the main routine of the DHCP server service.  After
    the service has been initialized, this thread will wait on
    DhcpGlobalProcessTerminationEvent for a signal to terminate the service.

Arguments:

    NumArgs - Supplies the number of strings specified in ArgsArray.

    ArgsArray -  Supplies string arguments that are specified in the
        StartService API call.  This parameter is ignored.

Return Value:

    None.

--*/
{
    DWORD Error;

    UNREFERENCED_PARAMETER(NumArgs);
    UNREFERENCED_PARAMETER(ArgsArray);

    DhcpPrint(( DEBUG_INIT, "ServiceEntry()\n" ));

    //
    // copy the process global data pointer to service global variable.
    //

    TcpsvcsGlobalData = pGlobalData;
#if DBG
    DhcpGlobalDebugFlag = DEBUG_LOG_IN_FILE | DEBUG_ALLOC;
#endif

    Error = DhcpInitGlobalData( TRUE );

    if ( Error == ERROR_SUCCESS) {

        //
        // record the startup in audit log
        //

        DhcpUpdateAuditLog(
                    DHCP_IP_LOG_START,
                    GETSTRING( DHCP_IP_LOG_START_NAME ),
                    0,
                    NULL,
                    0,
                    NULL
                    );

        //
        // perform Scavenge task until we are told to stop.
        //

        Error = Scavenger();
    }

    InformBinl(DHCP_STOPPED);
    DhcpCleanUpGlobalData( Error, TRUE );
    InformBinl(DHCP_READY_TO_UNLOAD);
    return;
} // ServiceEntry()

BOOLEAN
DllMain(
    IN HINSTANCE DllHandle,
    IN ULONG Reason,
    IN LPVOID lpReserved OPTIONAL
    )
{
    NTSTATUS Error;
    extern HMODULE Self ;

    Self = DllHandle;

    //
    // Handle attaching dhcpssvc.dll to a new process.
    //

    if (Reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls( DllHandle );

        //
        //  we need to initialize everything that other components may need
        //  even if our service isn't running.
        //

        InitializeCriticalSection(&DhcpGlobalBinlSyncCritSect);
        InitializeCriticalSection(&DhcpGlobalEndPointCS);
#if DBG
        InitializeCriticalSection( &DhcpGlobalDebugFileCritSect );
#endif DBG

        //
        // When DLL_PROCESS_DETACH and lpReserved is NULL, then a FreeLibrary
        // call is being made.  If lpReserved is Non-NULL, and ExitProcess is
        // in progress.  These cleanup routines will only be called when
        // a FreeLibrary is being called.  ExitProcess will automatically
        // clean up all process resources, handles, and pending io.
        //
    } else if ((Reason == DLL_PROCESS_DETACH) &&
               (lpReserved == NULL)) {

        DeleteCriticalSection( &DhcpGlobalBinlSyncCritSect );
        DeleteCriticalSection( &DhcpGlobalEndPointCS );
#if DBG
        DeleteCriticalSection( &DhcpGlobalDebugFileCritSect );
#endif DBG

    }

    return TRUE;
}


//--------------------------------------------------------------------------------
//  End of file
//--------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\mdhcpdb.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  mdhcpdb.c

  Abstract:

  This module contains the functions for interfacing with the JET
  database API pertaining to MDHCP.

  Author:

  Munil Shah

  Environment:

  User Mode - Win32

  Revision History:

  --*/

#include "dhcppch.h"
#include "mdhcpsrv.h"





//
//  Structure of the MDHCP table is as follows.
//
//
//      Columns :
//
//          Name                Type
//
//      1. IpAddress            JET_coltypLongBinary - List of ipaddresses.
//      2. ClientId             JET_coltypBinary - Binary data, < 255 bytes.
//      3. ClientInfo           JET_coltypBinary - Textual info of the client.
//      4. State                JET_coltypUnsignedByte - 1-byte integer, unsigned.
//      5. Flags                JET_coltypLong - 4 byte integer, signed.
//      6. ScopeId              JET_coltypBinary - Binary data, < 255 bytes.
//      7. LeaseStart           JET_coltypCurrency - 8-byte integer, signed
//      8. LeaseEnd             JET_coltypCurrency - 8-byte integer, signed
//      9. ServerIpAddress      JET_coltypBinary - Max 16-byte
//      10. ServerName           JET_coltypBinary - Binary data, < 255 bytes
//

//
// global data structure.
// ColName and ColType are constant, so they are initialized here.
// ColType is initialized when the database is created or reopened.
//


STATIC TABLE_INFO MCastClientTable[] = {
    { MCAST_TBL_IPADDRESS_STR        , 0, JET_coltypLongBinary },
    { MCAST_TBL_CLIENT_ID_STR        , 0, JET_coltypBinary },
    { MCAST_TBL_CLIENT_INFO_STR      , 0, JET_coltypLongBinary },
    { MCAST_TBL_STATE_STR            , 0, JET_coltypUnsignedByte },
    { MCAST_TBL_FLAGS_STR            , 0, JET_coltypLong },
    { MCAST_TBL_SCOPE_ID_STR         , 0, JET_coltypBinary },
    { MCAST_TBL_LEASE_START_STR      , 0, JET_coltypCurrency },
    { MCAST_TBL_LEASE_END_STR  ,       0, JET_coltypCurrency },
    { MCAST_TBL_SERVER_IP_ADDRESS_STR, 0, JET_coltypLongBinary },
    { MCAST_TBL_SERVER_NAME_STR,    0, JET_coltypBinary },
};


DWORD
DhcpOpenMCastDbTable(
    JET_SESID   SessId,
    JET_DBID    DbId
)
    /*++

      Routine Description:

      This routine creates/opens MCast client table and initializes it.

      Arguments:

      JetSessID - Session handle

      JetDbID - database handle

      Return Value:

      JET errors.

      --*/
{

    JET_ERR JetError;
    DWORD Error = NO_ERROR;
    JET_COLUMNDEF   ColumnDef;
    CHAR *IndexKey;
    DWORD i;

    //
    // hook the client table pointer.
    //

    MadcapGlobalClientTable = MCastClientTable;

    //
    // Create Table.
    //

    JetError = JetOpenTable(
        SessId,
        DbId,
        MCAST_CLIENT_TABLE_NAME,
        NULL,
        0,
        0,
        &MadcapGlobalClientTableHandle );
    DhcpPrint((DEBUG_MISC, "JetOpenTable - MCast Table\n")); // JET TRACE

    // if table exist, read the table columns.
    if ( JET_errSuccess == JetError) {
        // read columns.
        for ( i = 0; i < MCAST_MAX_COLUMN; i++ ) {
            JetError = JetGetTableColumnInfo(
                SessId,
                MadcapGlobalClientTableHandle,
                MadcapGlobalClientTable[i].ColName,
                &ColumnDef,
                sizeof(ColumnDef),
                0);
            Error = DhcpMapJetError( JetError, "M:GetTableColumnInfo" );
            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            MadcapGlobalClientTable[i].ColHandle  = ColumnDef.columnid;
            DhcpPrint((DEBUG_MISC, "JetGetTableColumnInfo, name %s, handle %ld\n",
                       MadcapGlobalClientTable[i].ColName, MadcapGlobalClientTable[i].ColHandle)); // JET TRACE
        }

    // if the table does not exist, create it. O/w bail
    } else if ( JET_errObjectNotFound != JetError ) {
        Error = DhcpMapJetError( JetError, "M:OpenTable" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;
    } else {

        JetError = JetCreateTable(
            SessId,
            DbId,
            MCAST_CLIENT_TABLE_NAME,
            DB_TABLE_SIZE,
            DB_TABLE_DENSITY,
            &MadcapGlobalClientTableHandle );
        DhcpPrint((DEBUG_MISC, "JetCreateTable - MCast Table, %ld\n", JetError)); // JET TRACE

        Error = DhcpMapJetError( JetError, "M:CreateTAble" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        // create columns.
        // Init fields of columndef that do not change between addition of
        // columns

        ColumnDef.cbStruct  = sizeof(ColumnDef);
        ColumnDef.columnid  = 0;
        ColumnDef.wCountry  = 1;
        ColumnDef.langid    = DB_LANGID;
        ColumnDef.cp        = DB_CP;
        ColumnDef.wCollate  = 0;
        ColumnDef.cbMax     = 0;
        ColumnDef.grbit     = 0; // variable length binary and text data.

        for ( i = 0; i < MCAST_MAX_COLUMN; i++ ) {

            ColumnDef.coltyp   = MadcapGlobalClientTable[i].ColType;
            JetError = JetAddColumn(
                SessId,
                MadcapGlobalClientTableHandle,
                MadcapGlobalClientTable[i].ColName,
                &ColumnDef,
                NULL, // no optinal value.
                0,
                &MadcapGlobalClientTable[i].ColHandle );

            Error = DhcpMapJetError( JetError, "M:AddColumn" );
            if( Error != ERROR_SUCCESS ) goto Cleanup;

            DhcpPrint((DEBUG_MISC,"JetAddColumn - name %s, handle %ld\n",
                       MadcapGlobalClientTable[i].ColName, MadcapGlobalClientTable[i].ColHandle));

        }
        // finally create index.
        IndexKey =  "+" MCAST_TBL_IPADDRESS_STR "\0";
        JetError = JetCreateIndex(
            SessId,
            MadcapGlobalClientTableHandle,
            MadcapGlobalClientTable[MCAST_TBL_IPADDRESS].ColName,
            JET_bitIndexPrimary,
            // ?? JET_bitIndexClustered will degrade frequent
            // update response time.
            IndexKey,
            strlen(IndexKey) + 2, // for two termination chars
            50
        );

        Error = DhcpMapJetError( JetError, "M:CreateIndex" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        IndexKey =  "+" MCAST_TBL_CLIENT_ID_STR "\0";
        JetError = JetCreateIndex(
            SessId,
            MadcapGlobalClientTableHandle,
            MadcapGlobalClientTable[MCAST_TBL_CLIENT_ID].ColName,
            JET_bitIndexUnique,
            IndexKey,
            strlen(IndexKey) + 2, // for two termination chars
            50
        );

        Error = DhcpMapJetError( JetError, "M:CreateIndex" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

    }



  Cleanup:

    if( Error != ERROR_SUCCESS ) {

        DhcpPrint(( DEBUG_JET, "could not open mcast client table, %ld.\n", Error ));
    }
    else {

        DhcpPrint(( DEBUG_JET, "Succssfully opened mcast client ..\n" ));
    }

    return(Error);
}

DWORD
MadcapJetOpenKey(
    PDB_CTX pDbCtx,
    char *ColumnName,
    PVOID Key,
    DWORD KeySize
)
    /*++

      Routine Description:

      This function opens a key for the named index.

      Arguments:

      ColumnName - The column name of an index column.

      Key - The key to look up.

      KeySize - The size of the specified key, in bytes.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetSetCurrentIndex(
        pDbCtx->SessId,
        pDbCtx->TblId,
        ColumnName );

    Error = DhcpMapJetError( JetError,"M:OpenKey" );
    if( Error != ERROR_SUCCESS ) {
        DhcpMapJetError( JetError, ColumnName);
        return(Error);
    }

    JetError = JetMakeKey(
        pDbCtx->SessId,
        pDbCtx->TblId,
        Key,
        KeySize,
        JET_bitNewKey );

    Error = DhcpMapJetError( JetError, "M:MakeKey" );
    if( Error != ERROR_SUCCESS ) {
        DhcpMapJetError(JetError, ColumnName);
        return(Error);
    }

    JetError = JetSeek( pDbCtx->SessId, pDbCtx->TblId, JET_bitSeekEQ );
    return( DhcpMapJetError( JetError, "M:OpenKey:Seek" ));
}



DWORD
MadcapJetBeginTransaction(
    PDB_CTX pDbCtx
)
    /*++

      Routine Description:

      This functions starts a dhcp database transaction.

      Arguments:

      none.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetBeginTransaction( pDbCtx->SessId );

    Error = DhcpMapJetError( JetError, "M:BeginTransaction" );
    return(Error);
}



DWORD
MadcapJetRollBack(
    PDB_CTX pDbCtx
)
    /*++

      Routine Description:

      This functions rolls back a dhcp database transaction.

      Arguments:

      none.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetRollback(
        pDbCtx->SessId,
        0 ); // Rollback the last transaction.

    Error = DhcpMapJetError( JetError, "M:Rollback" );
    return(Error);
}




DWORD
MadcapJetCommitTransaction(
    PDB_CTX pDbCtx
)
    /*++

      Routine Description:

      This functions commits a dhcp database transaction.

      Arguments:

      none.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    // Change JET_bitCommitFlush to JET_bitCommitLazyFlush as
    // Jet97 does not seem to have JET_bitCommitFlush

    JetError = JetCommitTransaction(
        pDbCtx->SessId,
        JET_bitCommitLazyFlush);

    Error = DhcpMapJetError( JetError, "M:CommitTransaction" );
    return(Error);
}




DWORD
MadcapJetPrepareUpdate(
    PDB_CTX pDbCtx,
    char *ColumnName,
    PVOID Key,
    DWORD KeySize,
    BOOL NewRecord
)
    /*++

      Routine Description:

      This function prepares the database for the creation of a new record,
      or updating an existing record.

      Arguments:

      ColumnName - The column name of an index column.

      Key - The key to update/create.

      KeySize - The size of the specified key, in bytes.

      NewRecord - TRUE to create the key, FALSE to update an existing key.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    if ( !NewRecord ) {
        JetError = JetSetCurrentIndex(
            pDbCtx->SessId,
            pDbCtx->TblId,
            ColumnName );

        Error = DhcpMapJetError( JetError, "M:PrepareUpdate" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError(JetError, ColumnName);
            return( Error );
        }

        JetError = JetMakeKey(
            pDbCtx->SessId,
            pDbCtx->TblId,
            Key,
            KeySize,
            JET_bitNewKey );

        Error = DhcpMapJetError( JetError, "M:prepareupdate:MakeKey" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError(JetError, ColumnName);
            return( Error );
        }

        JetError = JetSeek(
            pDbCtx->SessId,
            pDbCtx->TblId,
            JET_bitSeekEQ );

        Error = DhcpMapJetError( JetError, "M:PrepareUpdate:Seek" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError(JetError, ColumnName);
            return( Error );
        }

    }

    JetError = JetPrepareUpdate(
        pDbCtx->SessId,
        pDbCtx->TblId,
        NewRecord ? JET_prepInsert : JET_prepReplace );

    return( DhcpMapJetError( JetError, "M:PrepareUpdate:PrepareUpdate" ));
}



DWORD
MadcapJetCommitUpdate(
    PDB_CTX pDbCtx
)
    /*++

      Routine Description:

      This function commits an update to the database.  The record specified
      by the last call to DhcpJetPrepareUpdate() is committed.

      Arguments:

      None.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;

    JetError = JetUpdate(
        pDbCtx->SessId,
        pDbCtx->TblId,
        NULL,
        0,
        NULL );

    return( DhcpMapJetError( JetError, "M:CommitUpdate" ));
}



DWORD
MadcapJetSetValue(
    PDB_CTX pDbCtx,
    JET_COLUMNID KeyColumnId,
    PVOID Data,
    DWORD DataSize
)
    /*++

      Routine Description:

      This function updates the value of an entry in the current record.

      Arguments:

      KeyColumnId - The Id of the column (value) to update.

      Data - A pointer to the new value for the column.

      DataSize - The size of the data, in bytes.

      Return Value:

      None.

      --*/
{
    JET_ERR JetError;

    JetError = JetSetColumn(
        pDbCtx->SessId,
        pDbCtx->TblId,
        KeyColumnId,
        Data,
        DataSize,
        0,
        NULL );

    return( DhcpMapJetError( JetError, "M:SetValue" ) );
}



DWORD
MadcapJetGetValue(
    PDB_CTX pDbCtx,
    JET_COLUMNID ColumnId,
    PVOID Data,
    PDWORD DataSize
)
    /*++

      Routine Description:

      This function read the value of an entry in the current record.

      Arguments:

      ColumnId - The Id of the column (value) to read.

      Data - Pointer to a location where the data that is read from the
      database returned,  or pointer to a location where data is.

      DataSize - if the pointed value is non-zero then the Data points to
      a buffer otherwise this function allocates buffer for return data
      and returns buffer pointer in Data.

      Return Value:

      None.

      --*/
{
    JET_ERR JetError;
    DWORD Error;
    DWORD ActualDataSize;
    DWORD NewActualDataSize;
    LPBYTE DataBuffer = NULL;

    if( *DataSize  != 0 ) {

        JetError = JetRetrieveColumn(
            pDbCtx->SessId,
            pDbCtx->TblId,
            ColumnId,
            Data,
            *DataSize,
            DataSize,
            0,
            NULL );

        Error = DhcpMapJetError( JetError, "M:RetrieveColumn1" );
        goto Cleanup;
    }

    //
    // determine the size of data.
    //

    JetError = JetRetrieveColumn(
        pDbCtx->SessId,
        pDbCtx->TblId,
        ColumnId,
        NULL,
        0,
        &ActualDataSize,
        0,
        NULL );

    //
    // JET_wrnBufferTruncated is expected warning.
    //

    if( JetError != JET_wrnBufferTruncated ) {
        Error = DhcpMapJetError( JetError, "M:RetrieveColukmn2" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }
    else {
        Error = ERROR_SUCCESS;
    }

    if( ActualDataSize == 0 ) {
        //
        // field is NULL.
        //
        *(LPBYTE *)Data = NULL;
        goto Cleanup;
    }

    DataBuffer = MIDL_user_allocate( ActualDataSize );

    if( DataBuffer == NULL ) {
        *(LPBYTE *)Data = NULL;
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    JetError = JetRetrieveColumn(
        pDbCtx->SessId,
        pDbCtx->TblId,
        ColumnId,
        DataBuffer,
        ActualDataSize,
        &NewActualDataSize,
        0,
        NULL );

    Error = DhcpMapJetError( JetError, "M:RetrieveColumn3" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    DhcpAssert( ActualDataSize == NewActualDataSize );
    *(LPBYTE *)Data = DataBuffer;
    *DataSize = ActualDataSize;

    Error = ERROR_SUCCESS;

  Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // freeup local buffer.
        //

        if( DataBuffer != NULL ) {
            MIDL_user_free( DataBuffer );
        }
    }

    return( Error );
}



DWORD
MadcapJetPrepareSearch(
    PDB_CTX pDbCtx,
    char *ColumnName,
    BOOL SearchFromStart,
    PVOID Key,
    DWORD KeySize
)
    /*++

      Routine Description:

      This function prepares for a search of the client database.

      Arguments:

      ColumnName - The column name to use as the index column.

      SearchFromStart - If TRUE, search from the first record in the
      database.  If FALSE, search from the specified key.

      Key - The key to start the search.

      KeySize - The size, in bytes, of key.

      Return Value:

      None.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetSetCurrentIndex(
        pDbCtx->SessId,
        pDbCtx->TblId,
        ColumnName );

    Error = DhcpMapJetError( JetError, "M:PrepareSearch:SetcurrentIndex" );
    if( Error != ERROR_SUCCESS ) {
        DhcpMapJetError( JetError, ColumnName );
        return( Error );
    }

    if ( SearchFromStart ) {
        JetError = JetMove(
            pDbCtx->SessId,
            pDbCtx->TblId,
            JET_MoveFirst,
            0 );
    } else {
        JetError =  JetMakeKey(
            pDbCtx->SessId,
            pDbCtx->TblId,
            Key,
            KeySize,
            JET_bitNewKey );

        Error = DhcpMapJetError( JetError, "M:PrepareSearch:MakeKey" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError( JetError, ColumnName );
            return( Error );
        }

        JetError = JetSeek(
            pDbCtx->SessId,
            pDbCtx->TblId,
            JET_bitSeekGT );
    }

    return( DhcpMapJetError( JetError, "M:PrepareSearch:Move/Seek" ) );
}



DWORD
MadcapJetNextRecord(
    PDB_CTX pDbCtx
)
    /*++

      Routine Description:

      This function advances to the next record in a search.

      Arguments:

      None.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;

    JetError = JetMove(
        pDbCtx->SessId,
        pDbCtx->TblId,
        JET_MoveNext,
        0 );

    return( DhcpMapJetError( JetError, "M:NextRecord" ) );
}



DWORD
MadcapJetDeleteCurrentRecord(
    PDB_CTX pDbCtx
)
    /*++

      Routine Description:

      This function deletes the current record.

      Arguments:

      None.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;

    JetError = JetDelete( pDbCtx->SessId, pDbCtx->TblId );
    return( DhcpMapJetError( JetError, "M:DeleteCurrentRecord" ) );
}

DWORD
MadcapJetGetRecordPosition(
    IN PDB_CTX pDbCtx,
    IN JET_RECPOS *pRecPos,
    IN DWORD    Size
)
{
    JET_ERR JetError;

    JetError = JetGetRecordPosition(
                    pDbCtx->SessId,
                    pDbCtx->TblId,
                    pRecPos,
                    Size );

    return( DhcpMapJetError( JetError, "M:GetCurrRecord" ) );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\mdhcpmsc.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  mdhcpdb.c

  Abstract:

  This module contains the functions for interfacing with the JET
  database API pertaining to MDHCP.

  Author:

  Munil Shah

  Environment:

  User Mode - Win32

  Revision History:

  --*/

#include "dhcppch.h"
#include "mdhcpsrv.h"

DWORD
DhcpDeleteMScope(
    IN LPWSTR MScopeName,
    IN DWORD ForceFlag
    );

BOOL
MadcapGetIpAddressFromClientId(
    PBYTE   ClientId,
    DWORD   ClientIdLength,
    PVOID   IpAddress,
    PDWORD  IpAddressLength
)
    /*++

      Routine Description:

      This function looks up the IP address corresponding to the given
      hardware address.

      Arguments:

      ClientId - pointer to a buffer where the hw address is returned.
      ClientIdLength - length of the above buffer.
      IpAddress - Pointer to buffer where ip address is to be copied(
                    when *ipaddresslength is nonzero)
                  Otherwise it is a pointer to a buffer pointer value
                     of which is assigned when the buffer is created
                     by this routine.

      IpAddressLength - Pointer to size of above buffer, if 0 then this
                        routine will allocate.

      Return Value:

      TRUE - The IP address was found.
      FALSE - The IP address could not be found.


      --*/
{
    DWORD Error;
    DWORD Size;
    DB_CTX  DbCtx;

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    Error = MadcapJetOpenKey(
        &DbCtx,
        MCAST_COL_NAME(MCAST_TBL_CLIENT_ID),
        ClientId,
        ClientIdLength );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    //
    // Get the ip address information for this client.
    //
    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
        IpAddress,
        IpAddressLength );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }


    return( TRUE );
}

BOOL
MadcapGetClientIdFromIpAddress(
    PBYTE IpAddress,
    DWORD IpAddressLength,
    PVOID ClientId,
    PDWORD ClientIdLength
)
    /*++

      Routine Description:

      This function looks up the IP address corresponding to the given
      hardware address.

      Arguments:

      IpAddress - Pointer to Ipaddress of a record whose hw address is requested.
      IpAddressLength - Length of the above buffer.
      ClientId - pointer to a buffer where the client id is returned (when
                    *clientidlength is nonzero)
                 Otherwise it is a pointer to buffer pointer which will be
                    allocated by this routine.
      ClientIdLength - Pointer to the length of the above buffer.

      Return Value:

      TRUE - The IP address was found.
      FALSE - The IP address could not be found.  *IpAddress = -1.


      --*/
{
    DWORD Error;
    DWORD Size;
    DB_CTX  DbCtx;

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    Error = MadcapJetOpenKey(
        &DbCtx,
        MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
        IpAddress,
        IpAddressLength );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    //
    // Get the ip address information for this client.
    //

    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_CLIENT_ID),
        ClientId,
        ClientIdLength );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }


    return( TRUE );
}

DWORD
MadcapGetRemainingLeaseTime(
    PBYTE ClientId,
    DWORD ClientIdLength,
    DWORD *LeaseTime
)
    /*++

      Routine Description:

      This function looks up remaining leasetime for the client whose
      id is given.

      Arguments:

      ClientId - pointer to a buffer where the hw address is returned.
      ClientIdLength - length of the above buffer.
      LeaseTime - Returns the remaining lease time.

      Return Value:

        Returns jet error.

      --*/
{
    DWORD Error;
    DWORD Size;
    DWORD EndTimeLen;
    DB_CTX  DbCtx;
    DATE_TIME       CurrentTime;
    LARGE_INTEGER   Difference;
    DATE_TIME       EndTime;


    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    Error = MadcapJetOpenKey(
        &DbCtx,
        MCAST_COL_NAME(MCAST_TBL_CLIENT_ID),
        ClientId,
        ClientIdLength );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // Get the Lease duration information for this client.
    //
    CurrentTime = DhcpCalculateTime(0);
    EndTimeLen = sizeof(EndTime);
    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_LEASE_END),
        &EndTime,
        &EndTimeLen );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    if (((LARGE_INTEGER *)&EndTime)->QuadPart <= ((LARGE_INTEGER *)&CurrentTime)->QuadPart) {
        *LeaseTime = 0;
        return ERROR_SUCCESS;
    }
    Difference.QuadPart = ((LARGE_INTEGER *)&EndTime)->QuadPart - ((LARGE_INTEGER *)&CurrentTime)->QuadPart;
    Difference.QuadPart /= 10000000;
    *LeaseTime = Difference.LowPart;

    return( ERROR_SUCCESS );
}

DWORD
MadcapCreateClientEntry(
    LPBYTE                ClientIpAddress,
    DWORD                 ClientIpAddressLength,
    DWORD                 ScopeId,
    LPBYTE                ClientId,
    DWORD                 ClientIdLength,
    LPWSTR                ClientInfo OPTIONAL,
    DATE_TIME             LeaseStarts,
    DATE_TIME             LeaseTerminates,
    DWORD                 ServerIpAddress,
    BYTE                  AddressState,
    DWORD                 AddressFlags,
    BOOL                  OpenExisting
    )
/*++

Routine Description:

    This function creates a client entry in the client database.

Arguments:

    ClientIpAddress - A pointer to the IP address of the client.

    ClientIpAddressLength - The length of the above buffer.

    ClientId - The unique id of this client.

    ClientIdLength - The length, in bytes, of the hardware address.

    ClientInfo - The textual info of the client.

    LeaseDuration - The duration of the lease, in seconds.

    ServerIpAddress - IpAddress of the server on the net where the
        client gets response.

    AddressState - The new state of the address.

    OpenExisting - If the client already exists in the database.
        TRUE - Overwrite the information for this client.
        FALSE - Do not over overwrite existing information.  Return an error.

        Ignored if this client does not exist in the database.

    Packet -  the original wrapper to put information if we have to schedule a
        ping for conflict detection; NULL ==> dont schedule, just do synchronously

    Status -  the DWORD here is ERROR_SUCCESS whenever a ping is NOT scheduled.

Return Value:

    The status of the operation.

--*/
{
    DHCP_IP_ADDRESS SubnetMask;
    DWORD Error,LocalError;
    BOOL AddressAlloted = FALSE;
    BOOL TransactBegin = FALSE;
    JET_ERR JetError = JET_errSuccess;
    WCHAR   CurClientInformation[ MACHINE_INFO_SIZE / sizeof(WCHAR) ];
    DWORD   CurClientInformationSize = MACHINE_INFO_SIZE;
    LPBYTE HWAddr;
    DWORD HWAddrLength;
    BYTE  bAllowedClientTypes;
    BYTE PreviousAddressState;
    DWORD Size;
    DB_CTX  DbCtx;


    DhcpAssert(0 != ClientIpAddress);

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    //
    // lock both registry and database locks here to avoid dead lock.
    //

    LOCK_DATABASE();

    //
    // start transaction before a create/update database record.
    //

    Error = MadcapJetBeginTransaction(&DbCtx);

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    TransactBegin = TRUE;

    Error = MadcapJetPrepareUpdate(
        &DbCtx,
        MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
        ClientIpAddress,
        ClientIpAddressLength,
        !OpenExisting );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // if new record update constant info.
    //

    if( !OpenExisting ) {

        Error = MadcapJetSetValue(
            &DbCtx,
            MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
            ClientIpAddress,
            ClientIpAddressLength);

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

    }

    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_SCOPE_ID),
                &ScopeId,
                sizeof(ScopeId));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_STATE),
                &AddressState,
                sizeof(AddressState));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_FLAGS),
                &AddressFlags,
                sizeof(AddressFlags));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    // ClientHarwardAddress can't be NULL.
    DhcpAssert( (ClientId != NULL) &&
                (ClientIdLength > 0) );


    Error = MadcapJetSetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_CLIENT_ID),
        ClientId,
        ClientIdLength
    );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if ( !OpenExisting || ClientInfo ) {
        Error = MadcapJetSetValue(
                  &DbCtx,
                  MCAST_COL_HANDLE(MCAST_TBL_CLIENT_INFO),
                  ClientInfo,
                  (ClientInfo == NULL) ? 0 :
                    (wcslen(ClientInfo) + 1) * sizeof(WCHAR) );
    }

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }



    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_LEASE_START),
                &LeaseStarts,
                sizeof(LeaseStarts));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_LEASE_END),
                &LeaseTerminates,
                sizeof(LeaseTerminates));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_SERVER_NAME),
                DhcpGlobalServerName,
                DhcpGlobalServerNameLen );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_SERVER_IP_ADDRESS),
                &ServerIpAddress,
                sizeof(ServerIpAddress) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }


    //
    // commit changes.
    //

    JetError = JetUpdate(
                    DhcpGlobalJetServerSession,
                    MadcapGlobalClientTableHandle,
                    NULL,
                    0,
                    NULL );
    if( JET_errKeyDuplicate == JetError ) {
        DhcpAssert( FALSE );
        Error = ERROR_DHCP_JET_ERROR;
    } else {
        Error = DhcpMapJetError(JetError, "MCreateClientEntry:Update");
    }
Cleanup:

    if ( Error != ERROR_SUCCESS ) {
        LocalError = MadcapJetRollBack(&DbCtx);
        DhcpAssert( LocalError == ERROR_SUCCESS );
        DhcpPrint(( DEBUG_ERRORS, "Can't create client entry in the "
                    "database, %ld.\n", Error));
    }
    else {
        //
        // commit the transaction before we return.
        LocalError = MadcapJetCommitTransaction(&DbCtx);
        DhcpAssert( LocalError == ERROR_SUCCESS );
    }

    UNLOCK_DATABASE();
    return( Error );
}

DWORD
MadcapValidateClientByIpAddr(
    DHCP_IP_ADDRESS ClientIpAddress,
    PVOID ClientId,
    DWORD ClientIdLength
    )
/*++

Routine Description:

    This function verifies that an IP address and hardware address match.

Arguments:

    ClientIpAddress - The IP address of the client.

    ClientId - The hardware address of the client

    ClientIdLenght - The length, in bytes, of the hardware address.

Return Value:

    The status of the operation.

--*/
{
    LPBYTE LocalClientId = NULL;
    LPSTR                          IpAddressString;
    DWORD Length;
    DWORD Error;
    DB_CTX  DbCtx;


    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    Error = MadcapJetOpenKey(
                &DbCtx,
                MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
                &ClientIpAddress,
                sizeof(ClientIpAddress));

    if ( Error != ERROR_SUCCESS ) {
        Error = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }


    Length = 0;
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_CLIENT_ID),
                &LocalClientId,
                &Length);

    DhcpAssert( Length != 0 );

    if (Length == ClientIdLength &&
        (RtlCompareMemory(
                (LPBYTE) LocalClientId ,
                (LPBYTE) ClientId ,
                Length) == Length ))
    {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }


    IpAddressString = DhcpIpAddressToDottedString(ClientIpAddress);
    if ( NULL == IpAddressString ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    if ( RtlCompareMemory(
            LocalClientId,
            IpAddressString,
            strlen(IpAddressString)) == strlen(IpAddressString)) {
        // reconciled address.
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    Error  = ERROR_GEN_FAILURE;

Cleanup:

    if( LocalClientId != NULL ) {
        MIDL_user_free( LocalClientId );
    }

    return( Error );
}

DWORD
MadcapValidateClientByClientId(
    LPBYTE ClientIpAddress,
    DWORD  ClientIpAddressLength,
    PVOID  ClientId,
    DWORD  ClientIdLength
    )
/*++

Routine Description:

    This function verifies that an IP address and hardware address match.

Arguments:

    ClientIpAddress - Pointer to the IP address of the client.

    ClientIpAddressLength - Length of the above buffer.

    ClientId - The client id of the client

    ClientIdLenght - The length, in bytes, of the client id.

Return Value:

    The status of the operation.

--*/
{
    DWORD   Error;
    DB_CTX  DbCtx;
    LPBYTE  LocalIpAddress = NULL;
    DWORD   LocalLength;


    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    Error = MadcapJetOpenKey(
                &DbCtx,
                MCAST_COL_NAME(MCAST_TBL_CLIENT_ID),
                ClientId,
                ClientIdLength);

    if ( Error != ERROR_SUCCESS ) {
        return ERROR_FILE_NOT_FOUND;
    }


    LocalLength = 0;
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
                &LocalIpAddress,
                &LocalLength);

    DhcpAssert( 0 == LocalLength % sizeof(DHCP_IP_ADDRESS) );

    if (LocalLength == ClientIpAddressLength &&
        (RtlCompareMemory(
                (LPBYTE) LocalIpAddress ,
                (LPBYTE) ClientIpAddress ,
                LocalLength) == LocalLength ))
    {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    Error = ERROR_GEN_FAILURE ;
Cleanup:

    if( LocalIpAddress != NULL ) {
        MIDL_user_free( LocalIpAddress );
    }

    return( Error );

}

DWORD
MadcapRemoveClientEntryByIpAddress(
    DHCP_IP_ADDRESS ClientIpAddress,
    BOOL ReleaseAddress
    )
/*++

Routine Description:

    This routine removes a client entry in the madcap database
    and releases the IP address..

Arguments:

    ClientIpAddress -- Ip address of client to remove database entry..

Return Values:

    Jet errors

--*/
{
    JET_ERR JetError;
    DWORD Error;
    BOOL TransactBegin = FALSE;
    BYTE State;
    DWORD Size;
    BOOL  Reserved = FALSE;
    DB_CTX  DbCtx;
    DWORD MScopeId;

    // lock both registry and database locks here to avoid dead lock.
    LOCK_DATABASE();

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    // start transaction before a create/update database record.
    Error = MadcapJetBeginTransaction(&DbCtx);
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    TransactBegin = TRUE;

    Error = MadcapJetOpenKey(
        &DbCtx,
        MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
        &ClientIpAddress,
        sizeof( DHCP_IP_ADDRESS )
        );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    Size = sizeof(MScopeId);
    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_SCOPE_ID),
        &MScopeId,
        &Size);
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    JetError = JetDelete(
        DhcpGlobalJetServerSession,
        MadcapGlobalClientTableHandle );
    Error = DhcpMapJetError( JetError, "M:Remove:Delete" );

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_ERRORS, "Could not delete client entry: %ld\n", JetError));
        goto Cleanup;
    }

    // Finally, mark the IP address available in bitmap.
    if( ReleaseAddress == TRUE ) {
        PM_SUBNET   pMScope;
        DWORD       Error2;
        Error2 = DhcpMScopeReleaseAddress( MScopeId, ClientIpAddress);
        if (ERROR_SUCCESS != Error2) {
            // MBUG: log an event.
            DhcpPrint((DEBUG_ERRORS, "Could not delete mclient %lx from bitmap in scope id %lx, error %ld\n",
                       ClientIpAddress, MScopeId, Error2));
            goto Cleanup;
        }
    }

Cleanup:

    if ( (Error != ERROR_SUCCESS) &&
            (Error != ERROR_DHCP_RESERVED_CLIENT) ) {
        // if the transaction has been started, than roll back to the
        // start point, so that we will not leave the database
        // inconsistence.
        if( TransactBegin == TRUE ) {
            DWORD LocalError;
            LocalError = MadcapJetRollBack(&DbCtx);
            DhcpAssert( LocalError == ERROR_SUCCESS );
        }
        DhcpPrint(( DEBUG_ERRORS, "Can't remove client entry from the "
                    "database, %ld.\n", Error));
    }
    else {
        // commit the transaction before we return.
        DWORD LocalError;
        DhcpAssert( TransactBegin == TRUE );
        LocalError = MadcapJetCommitTransaction(&DbCtx);
        DhcpAssert( LocalError == ERROR_SUCCESS );
    }
    UNLOCK_DATABASE();
    return( Error );

}


DWORD
MadcapRemoveClientEntryByClientId(
    LPBYTE ClientId,
    DWORD ClientIdLength,
    BOOL ReleaseAddress
    )
/*++

Routine Description:

    This function removes a client entry from the client database.

Arguments:

    ClientIpAddress - The IP address of the client.

    HardwareAddress - client's hardware address.

    HardwareAddressLength - client's hardware address length.

    ReleaseAddress - if this flag is TRUE, release the address bit from
        registry, otherwise don't.

    DeletePendingRecord - if this flag is TRUE, the record is deleted
        only if the state of the record is ADDRESS_STATE_OFFERED.

Return Value:

    The status of the operation.

--*/
{
    JET_ERR JetError;
    DWORD Error;
    BOOL TransactBegin = FALSE;
    BYTE State;
    DWORD Size;
    BOOL  Reserved = FALSE;
    DB_CTX  DbCtx;
    DWORD MScopeId;
    DHCP_IP_ADDRESS ClientIpAddress;


    // lock both registry and database locks here to avoid dead lock.
    LOCK_DATABASE();

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    // start transaction before a create/update database record.
    Error = MadcapJetBeginTransaction(&DbCtx);
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    TransactBegin = TRUE;

    Error = MadcapJetOpenKey(
                    &DbCtx,
                    MCAST_COL_NAME(MCAST_TBL_CLIENT_ID),
                    ClientId,
                    ClientIdLength
                    );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    Size = sizeof(ClientIpAddress);
    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
        &ClientIpAddress,
        &Size);
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    Size = sizeof(MScopeId);
    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_SCOPE_ID),
        &MScopeId,
        &Size);
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    JetError = JetDelete(
        DhcpGlobalJetServerSession,
        MadcapGlobalClientTableHandle );
    Error = DhcpMapJetError( JetError, "M:Remove:Delete" );

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_ERRORS, "Could not delete client entry: %ld\n", JetError));
        goto Cleanup;
    }

    // Finally, mark the IP address available in bitmap.
    if( ReleaseAddress == TRUE ) {
        PM_SUBNET   pMScope;
        DWORD       Error2;
        Error2 = DhcpMScopeReleaseAddress( MScopeId, ClientIpAddress);
        if (ERROR_SUCCESS != Error2) {
            // MBUG: log an event.
            DhcpPrint((DEBUG_ERRORS, "Could not delete mclient %lx from bitmap in scope id %lx, error %ld\n",
                       ClientIpAddress, MScopeId, Error2));
            goto Cleanup;
        }
    }

Cleanup:

    if ( (Error != ERROR_SUCCESS) &&
            (Error != ERROR_DHCP_RESERVED_CLIENT) ) {
        // if the transaction has been started, than roll back to the
        // start point, so that we will not leave the database
        // inconsistence.
        if( TransactBegin == TRUE ) {
            DWORD LocalError;
            LocalError = MadcapJetRollBack(&DbCtx);
            DhcpAssert( LocalError == ERROR_SUCCESS );
        }
        DhcpPrint(( DEBUG_ERRORS, "Can't remove client entry from the "
                    "database, %ld.\n", Error));
    }
    else {
        // commit the transaction before we return.
        DWORD LocalError;
        DhcpAssert( TransactBegin == TRUE );
        LocalError = MadcapJetCommitTransaction(&DbCtx);
        DhcpAssert( LocalError == ERROR_SUCCESS );
    }
    UNLOCK_DATABASE();
    return( Error );
}

MadcapGetCurrentClientInfo(
    LPDHCP_MCLIENT_INFO *ClientInfo,
    LPDWORD InfoSize, // optional parameter.
    LPBOOL ValidClient, // optional parameter.
    DWORD  MScopeId
    )
/*++

Routine Description:

    This function retrieves current client information information. It
    allocates MIDL memory for the client structure (and for variable
    length structure fields). The caller is responsible to lock the
    database when this function is called.

Arguments:

    ClientInfo - pointer to a location where the client info structure
                    pointer is returned.

    InfoSize - pointer to a DWORD location where the number of bytes
                    consumed in the ClientInfo is returned.

    ValidClient - when this parameter is specified this
        function packs the current record only if the client

            1. belongs to the specified subnet.
            2. address state is ADDRESS_STATE_ACTIVE.

    SubnetAddress - the subnet address to filter client.

Return Value:

    Jet Errors.

--*/
{
    DWORD Error;
    LPDHCP_MCLIENT_INFO LocalClientInfo = NULL;
    DWORD LocalInfoSize = 0;
    DWORD Size;
    DHCP_IP_ADDRESS IpAddress;
    DHCP_IP_ADDRESS ClientSubnetAddress;
    DHCP_IP_ADDRESS realSubnetMask;
    BYTE AddressState;
    DWORD LocalMScopeId, AddressFlags;
    DB_CTX  DbCtx;

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    DhcpAssert( *ClientInfo == NULL );

    //
    // allocate return Buffer.
    //

    LocalClientInfo = MIDL_user_allocate( sizeof(DHCP_MCLIENT_INFO) );
    if( LocalClientInfo == NULL ) return ERROR_NOT_ENOUGH_MEMORY;

    LocalInfoSize = sizeof(DHCP_MCLIENT_INFO);
    //
    // read IpAddress and SubnetMask to filter unwanted clients.
    //

    Size = sizeof(IpAddress);
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
                &IpAddress,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(IpAddress) );
    LocalClientInfo->ClientIpAddress = IpAddress;

    Size = sizeof(LocalMScopeId);
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_SCOPE_ID),
                &LocalMScopeId,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalMScopeId) );
    LocalClientInfo->MScopeId = LocalMScopeId;

    // filter client if we are asked to do so.
    if( ValidClient != NULL ) {

        // don't filter client if the scopeid is 0
        if( (MScopeId != 0) &&
                (MScopeId != LocalMScopeId )) {
            *ValidClient = FALSE;
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }

        *ValidClient = TRUE;
    }

    Size = sizeof(AddressFlags);
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_FLAGS),
                &AddressFlags,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(AddressFlags) );
    LocalClientInfo->AddressFlags = AddressFlags;

    Size = sizeof(AddressState);
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_STATE),
                &AddressState,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(AddressState) );
    LocalClientInfo->AddressState = AddressState;

    //
    // read additional client info from database.
    //

    LocalClientInfo->ClientId.DataLength = 0;
        // let DhcpJetGetValue allocates name buffer.
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_CLIENT_ID),
                &LocalClientInfo->ClientId.Data,
                &LocalClientInfo->ClientId.DataLength );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    LocalInfoSize += LocalClientInfo->ClientId.DataLength;

    Size = 0; // let DhcpJetGetValue allocates name buffer.
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_CLIENT_INFO),
                &LocalClientInfo->ClientName,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if( LocalClientInfo->ClientName != NULL ) {
        DhcpAssert( (wcslen(LocalClientInfo->ClientName) + 1) *
                        sizeof(WCHAR) == Size );
    }
    else {
        DhcpAssert( Size == 0 );
    }

    LocalInfoSize += Size;

    Size = sizeof( LocalClientInfo->ClientLeaseStarts );
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_LEASE_START),
                &LocalClientInfo->ClientLeaseStarts,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalClientInfo->ClientLeaseStarts ) );

    Size = sizeof( LocalClientInfo->ClientLeaseEnds );
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_LEASE_END),
                &LocalClientInfo->ClientLeaseEnds,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalClientInfo->ClientLeaseEnds ) );

    RtlZeroMemory(
        &LocalClientInfo->OwnerHost, sizeof(LocalClientInfo->OwnerHost)
        );

    Size = sizeof( LocalClientInfo->OwnerHost.IpAddress );
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_SERVER_IP_ADDRESS),
                &LocalClientInfo->OwnerHost.IpAddress,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalClientInfo->OwnerHost.IpAddress) );


    Size = 0;
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_SERVER_NAME),
                &LocalClientInfo->OwnerHost.NetBiosName,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }


    if ( LocalClientInfo->OwnerHost.NetBiosName != NULL ) {
        DhcpAssert( Size ==
            (wcslen(LocalClientInfo->OwnerHost.NetBiosName) + 1) *
                sizeof(WCHAR) );

    }
    else {
        DhcpAssert( Size == 0 );
    }
    LocalInfoSize += Size;

    *ClientInfo = LocalClientInfo;

Cleanup:

    if( Error != ERROR_SUCCESS ) {
        // if we aren't successful, return alloted memory.
        if( LocalClientInfo != NULL ) {
            _fgs__DHCP_MCLIENT_INFO ( LocalClientInfo );
        }
        LocalInfoSize = 0;
    }

    if( InfoSize != NULL ) {
        *InfoSize =  LocalInfoSize;
    }

    return( Error );
}

DWORD
MadcapRetractOffer(                                      // remove pending list and database entries
    IN      PDHCP_REQUEST_CONTEXT    RequestContext,
    IN      LPMADCAP_SERVER_OPTIONS  MadcapOptions,
    IN      LPBYTE                   ClientId,
    IN      DWORD                    ClientIdLength
)
{
    DWORD                          Error;
    DHCP_IP_ADDRESS                desiredIpAddress = 0;
    LPDHCP_PENDING_CTXT            PendingCtxt;


    DhcpPrint((DEBUG_MSTOC, "Retracting offer (clnt accepted from %s)\n",
               DhcpIpAddressToDottedString(MadcapOptions->Server?*(MadcapOptions->Server):-1)));

    // Remove the pending entry and delete the record from the
    // database.

    LOCK_INPROGRESS_LIST();
    Error = DhcpFindPendingCtxt(
        ClientId,
        ClientIdLength,
        0,
        &PendingCtxt
    );
    if( ERROR_SUCCESS == Error ) {
        desiredIpAddress = PendingCtxt->Address;

        // is this a DHCP context?
        if ( !CLASSD_HOST_ADDR( desiredIpAddress )) {
            UNLOCK_INPROGRESS_LIST();
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
        Error = DhcpRemovePendingCtxt(PendingCtxt);
        DhcpAssert(ERROR_SUCCESS == Error);
        Error = MadcapDeletePendingCtxt(PendingCtxt);
        DhcpAssert(ERROR_SUCCESS == Error);
    }
    UNLOCK_INPROGRESS_LIST();

    LOCK_DATABASE();
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_MISC, "Retract offer: client has no records\n" ));
        UNLOCK_DATABASE();
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    } else {
        DhcpPrint((DEBUG_MISC, "Deleting pending client entry, %s.\n",
                   DhcpIpAddressToDottedString(desiredIpAddress)
        ));
    }

    Error = MadcapRemoveClientEntryByClientId(
        ClientId,
        ClientIdLength,
        TRUE                                          // release address from bit map.
    );
    UNLOCK_DATABASE();

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS, "[RetractOffer] RemoveClientEntry(%s): %ld [0x%lx]\n",
                    DhcpIpAddressToDottedString(desiredIpAddress), Error, Error ));
    }

    return ERROR_DHCP_INVALID_DHCP_CLIENT;
}


DWORD
GetMCastDatabaseList(
    DWORD   ScopeId,
    LPDHCP_IP_ADDRESS *DatabaseList,
    DWORD *DatabaseListCount
    )
/*++

Routine Description:

    Read ipaddresses of the database entries that belong to the given
    subnet.

Arguments:

    SubnetAddress : Address of the subnet scope to verify.

    DatabaseList : pointer to list of ip address. caller should free up
        the memory after use.

    DatabaseListCount : count of ip addresses in the above list.

Return Value:

    WINDOWS errors.
--*/
{

    DWORD Error;
    JET_ERR JetError;
    JET_RECPOS JetRecordPosition;
    DWORD TotalExpRecCount = 1;
    DWORD RecordCount = 0;
    LPDHCP_IP_ADDRESS IpList = NULL;
    DWORD i;
    DB_CTX  DbCtx;
    DWORD   LocalScopeId;


    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    // move the database pointer to the begining.
    Error = MadcapJetPrepareSearch(
                &DbCtx,
                MCAST_COL_NAME( MCAST_TBL_IPADDRESS),
                TRUE,   // Search from start
                NULL,
                0
                );

    if( Error != ERROR_SUCCESS ) {
        if( Error == ERROR_NO_MORE_ITEMS ) {
            *DatabaseList = NULL;
            *DatabaseListCount = 0;

            Error = ERROR_SUCCESS;
        }
        goto Cleanup;
    }

    // determine total number of records in the database.
    // There is no way to determine the total number of records, other
    // than  walk through the db. do it.
    while ( (Error = MadcapJetNextRecord(&DbCtx) ) == ERROR_SUCCESS )  {
         TotalExpRecCount++;
    }

    if ( Error != ERROR_NO_MORE_ITEMS ) {
        goto Cleanup;
    }

    // move back the database pointer to the begining.
    Error = MadcapJetPrepareSearch(
                &DbCtx,
                MCAST_COL_NAME( MCAST_TBL_IPADDRESS),
                TRUE,   // Search from start
                NULL,
                0
                );


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    // allocate memory for return list.
    IpList = DhcpAllocateMemory( sizeof(DHCP_IP_ADDRESS) * TotalExpRecCount );

    if( IpList == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // read database entries.
    for( i = 0; i < TotalExpRecCount; i++ ) {

        DHCP_IP_ADDRESS IpAddress;
        DHCP_IP_ADDRESS realSubnetMask;
        DWORD Size;

        // read ip address of the current record.
        Size = sizeof(IpAddress);
        Error = MadcapJetGetValue(
                    &DbCtx,
                    MCAST_COL_HANDLE( MCAST_TBL_IPADDRESS ),
                    &IpAddress,
                    &Size );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpAssert( Size == sizeof(IpAddress) );
        Size = sizeof(LocalScopeId);
        Error = MadcapJetGetValue(
                    &DbCtx,
                    MCAST_COL_HANDLE( MCAST_TBL_SCOPE_ID),
                    &LocalScopeId,
                    &Size );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpAssert( Size == sizeof(LocalScopeId) );
        if( LocalScopeId == ScopeId ) {
            // append this address to list.
            IpList[RecordCount++] = IpAddress;
        }

        // move to next record.
        Error = MadcapJetNextRecord(&DbCtx);
        if( Error != ERROR_SUCCESS ) {
            if( Error == ERROR_NO_MORE_ITEMS ) {
                Error = ERROR_SUCCESS;
                break;
            }
            goto Cleanup;
        }
    }

#if DBG
    // we should be pointing to end of database.
    Error = MadcapJetNextRecord(&DbCtx);
    DhcpAssert( Error == ERROR_NO_MORE_ITEMS );
    Error = ERROR_SUCCESS;
#endif // DBG

    *DatabaseList = IpList;
    IpList = NULL;
    *DatabaseListCount = RecordCount;

Cleanup:

    if( IpList != NULL ) {
        DhcpFreeMemory( IpList );
    }

    return( Error );
}

DWORD
DhcpDeleteMScopeClients(
    DWORD MScopeId
    )
/*++

Routine Description:

    This functions cleans up all clients records of the specified MScope
    from the database.

Arguments:

    MScopeId : MScopeId whose clients should be cleaned off.

Return Value:

    Database error code or ERROR_SUCCESS.

--*/
{
    DWORD Error;
    DWORD ReturnError = ERROR_SUCCESS;
    DB_CTX  DbCtx;

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    LOCK_DATABASE();
    Error = MadcapJetPrepareSearch(
                &DbCtx,
                MCAST_COL_NAME( MCAST_TBL_IPADDRESS ),
                TRUE,   // Search from start
                NULL,
                0 );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    // Walk through the entire database looking looking for the
    // specified subnet clients.
    for ( ;; ) {

        DWORD Size;
        DHCP_IP_ADDRESS IpAddress;
        DWORD       LocalMScopeId;

        // read IpAddress and MScopeId
        Size = sizeof(IpAddress);
        Error = MadcapJetGetValue(
                    &DbCtx,
                    MCAST_COL_HANDLE( MCAST_TBL_IPADDRESS ),
                    &IpAddress,
                    &Size );

        if( Error != ERROR_SUCCESS ) goto Cleanup;
        DhcpAssert( Size == sizeof(IpAddress) );

        Size = sizeof(LocalMScopeId);
        Error = MadcapJetGetValue(
                    &DbCtx,
                    MCAST_COL_HANDLE( MCAST_TBL_SCOPE_ID ),
                    &LocalMScopeId,
                    &Size );

        if( Error != ERROR_SUCCESS ) goto Cleanup;
        DhcpAssert( Size == sizeof(LocalMScopeId) );

        if( MScopeId == LocalMScopeId ) {
            // found a specified subnet client record , delete it.
            Error = MadcapJetBeginTransaction(&DbCtx);
            if( Error != ERROR_SUCCESS ) goto Cleanup;

            Error = MadcapJetDeleteCurrentRecord(&DbCtx);

            if( Error != ERROR_SUCCESS ) {
                DhcpPrint(( DEBUG_ERRORS,"Cleanup current database record failed, %ld.\n",Error ));
                ReturnError = Error;
                Error = MadcapJetRollBack(&DbCtx);
                if( Error != ERROR_SUCCESS ) goto Cleanup;
            } else {
                Error = MadcapJetCommitTransaction(&DbCtx);
                if( Error != ERROR_SUCCESS ) goto Cleanup;
            }
        }

        // move to next record.
        Error = MadcapJetNextRecord(&DbCtx);
        if( Error != ERROR_SUCCESS ) {
            if( Error == ERROR_NO_MORE_ITEMS ) {
                Error = ERROR_SUCCESS;
                break;
            }
            goto Cleanup;
        }
    }

Cleanup:
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS, "DhcpDeleteSubnetClients failed, %ld.\n", Error ));
    }
    else  {
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteSubnetClients finished successfully.\n" ));
    }
    UNLOCK_DATABASE();
    return(Error);
}

DWORD
ChangeMScopeIdInDb(
    DWORD   OldMScopeId,
    DWORD   NewMScopeId
    )
/*++

Routine Description:

    This functions changes up all clients records of the specified MScope
    to new scope id.

Arguments:

    OldMScopeId : MScopeId whose clients should be changed.

    NewMScopeId : The value of new scope id.

Return Value:

    Database error code or ERROR_SUCCESS.

--*/
{
    DWORD Error;
    DWORD ReturnError = ERROR_SUCCESS;
    DB_CTX  DbCtx;

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    LOCK_DATABASE();
    Error = MadcapJetPrepareSearch(
                &DbCtx,
                MCAST_COL_NAME( MCAST_TBL_IPADDRESS ),
                TRUE,   // Search from start
                NULL,
                0 );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    // Walk through the entire database looking looking for the
    // specified subnet clients.
    for ( ;; ) {

        DWORD Size;
        DHCP_IP_ADDRESS IpAddress;
        DWORD       LocalMScopeId;

        Size = sizeof(LocalMScopeId);
        Error = MadcapJetGetValue(
                    &DbCtx,
                    MCAST_COL_HANDLE( MCAST_TBL_SCOPE_ID ),
                    &LocalMScopeId,
                    &Size );

        if( Error != ERROR_SUCCESS ) goto Cleanup;
        DhcpAssert( Size == sizeof(LocalMScopeId) );

        if( OldMScopeId == LocalMScopeId ) {
            // found a specified subnet client record , delete it.
            Error = MadcapJetBeginTransaction(&DbCtx);
            if( Error != ERROR_SUCCESS ) goto Cleanup;

            Error = MadcapJetSetValue(
                        &DbCtx,
                        MCAST_COL_HANDLE(MCAST_TBL_SCOPE_ID),
                        &NewMScopeId,
                        sizeof(NewMScopeId));

            if( Error != ERROR_SUCCESS ) {
                DhcpPrint(( DEBUG_ERRORS,"Change of MScopeId on current database record failed, %ld.\n",Error ));
                ReturnError = Error;
                Error = MadcapJetRollBack(&DbCtx);
                if( Error != ERROR_SUCCESS ) goto Cleanup;
            } else {
                Error = MadcapJetCommitTransaction(&DbCtx);
                if( Error != ERROR_SUCCESS ) goto Cleanup;
            }
        }

        // move to next record.
        Error = MadcapJetNextRecord(&DbCtx);
        if( Error != ERROR_SUCCESS ) {
            if( Error == ERROR_NO_MORE_ITEMS ) {
                Error = ERROR_SUCCESS;
                break;
            }
            goto Cleanup;
        }
    }

Cleanup:
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS, "ChangeMScopeIdInDb failed, %ld.\n", Error ));
    }
    else  {
        DhcpPrint(( DEBUG_APIS, "ChangeMScopeIdInDb finished successfully.\n" ));
    }
    UNLOCK_DATABASE();
    return(Error);
}

VOID
DeleteExpiredMcastScopes(
    IN      DATE_TIME*             TimeNow
    )
{
    PM_SERVER                       pServer;
    PM_SUBNET                       pScope;
    ARRAY_LOCATION                  Loc;
    DWORD                           Error;

    DhcpAcquireWriteLock();
    pServer = DhcpGetCurrentServer();

    Error = MemArrayInitLoc(&(pServer->MScopes), &Loc);
    if ( ERROR_FILE_NOT_FOUND == Error ) {
        DhcpReleaseWriteLock();
        return;
    }

    while ( ERROR_FILE_NOT_FOUND != Error ) {
        Error = MemArrayGetElement(
            &(pServer->MScopes), &Loc, (LPVOID *)&pScope
            );
        DhcpAssert(ERROR_SUCCESS == Error);
        if (CompareFileTime(
            (FILETIME *)&pScope->ExpiryTime, (FILETIME *)TimeNow
            ) < 0 ) {
            //
            // DELETE SCOPE HERE.
            //
            DhcpPrint(
                ( DEBUG_SCAVENGER,
                  "DeleteExpiredMcastScopes :deleting expired mscope %ws\n",
                  pScope->Name));

            DhcpDeleteMScope(pScope->Name, DhcpFullForce);
        }
        
        Error = MemArrayNextLoc(&(pServer->MScopes), &Loc);
    }
    
    DhcpReleaseWriteLock();
    return;
}

DWORD
CleanupMCastDatabase(
    IN      DATE_TIME*             TimeNow,            // current time standard
    IN      DATE_TIME*             DoomTime,           // Time when the records become 'doom'
    IN      BOOL                   DeleteExpiredLeases,// expired leases be deleted right away? or just set state="doomed"
    OUT     ULONG*                 nExpired,
    OUT     ULONG*                 nDeleted
)
{
    JET_ERR                        JetError;
    DWORD                          Error;
    FILETIME                       leaseExpires;
    DWORD                          dataSize;
    DHCP_IP_ADDRESS                ipAddress;
    DHCP_IP_ADDRESS                NextIpAddress;
    BYTE                           AddressState;
    BOOL                           DatabaseLocked = FALSE;
    BOOL                           RegistryLocked = FALSE;
    DWORD                          i;
    BYTE                            bAllowedClientTypes;
    DB_CTX                          DbCtx;
    DWORD                           MScopeId;
    DWORD                          ReturnError = ERROR_SUCCESS;


    DhcpPrint(( DEBUG_MISC, "Cleaning up Multicast database table.\n"));

    (*nExpired) = (*nDeleted) = 0;

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);
    // Get the first user record's IpAddress.
    LOCK_DATABASE();
    DatabaseLocked = TRUE;
    Error = MadcapJetPrepareSearch(
        &DbCtx,
        MCAST_COL_NAME( MCAST_TBL_IPADDRESS ),
        TRUE,   // Search from start
        NULL,
        0
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    dataSize = sizeof( NextIpAddress );
    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE( MCAST_TBL_IPADDRESS ),
        &NextIpAddress,
        &dataSize
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;
    DhcpAssert( dataSize == sizeof( NextIpAddress )) ;

    UNLOCK_DATABASE();
    DatabaseLocked = FALSE;

    // Walk through the entire database looking for expired leases to
    // free up.
    for ( ;; ) {

        // return to caller when the service is shutting down.
        if( (WaitForSingleObject( DhcpGlobalProcessTerminationEvent, 0 ) == 0) ) {
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }

        // lock both registry and database locks here to avoid dead lock.

        if( FALSE == DatabaseLocked ) {
            LOCK_DATABASE();
            DatabaseLocked = TRUE;
        }

        // Seek to the next record.
        JetError = JetSetCurrentIndex(
            DhcpGlobalJetServerSession,
            MadcapGlobalClientTableHandle,
            MCAST_COL_NAME(MCAST_TBL_IPADDRESS)
        );

        Error = DhcpMapJetError( JetError, "M:Cleanup:SetcurrentIndex" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        JetError = JetMakeKey(
            DhcpGlobalJetServerSession,
            MadcapGlobalClientTableHandle,
            &NextIpAddress,
            sizeof( NextIpAddress ),
            JET_bitNewKey
        );

        Error = DhcpMapJetError( JetError, "M:Cleanup:MakeKey" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        // Seek to the next record or greater to process. When we
        // processed last record we noted down the next record to
        // process, however the next record may have been deleted when
        // we unlocked the database lock. So moving to the next or
        // greater record will make us to move forward.

        JetError = JetSeek(
            DhcpGlobalJetServerSession,
            MadcapGlobalClientTableHandle,
            JET_bitSeekGE
        );

        // #if0 when JET_errNoCurrentRecord removed (see scavengr.c@v25);
        // that code tried to go back to start of file when scanned everything.

        Error = DhcpMapJetError( JetError, "M:Cleanup:Seek" );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        // read the IP address of current record.
        dataSize = sizeof( ipAddress );
        Error = MadcapJetGetValue(
            &DbCtx,
            MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
            &ipAddress,
            &dataSize
        );
        if( Error != ERROR_SUCCESS ) {
            goto ContinueError;
        }
        DhcpAssert( dataSize == sizeof( ipAddress )) ;

        // read the MScopeId of current record.
        dataSize = sizeof( MScopeId );
        Error = MadcapJetGetValue(
            &DbCtx,
            MCAST_COL_HANDLE(MCAST_TBL_SCOPE_ID),
            &MScopeId,
            &dataSize
        );
        if( Error != ERROR_SUCCESS ) {
            goto ContinueError;
        }
        DhcpAssert( dataSize == sizeof( MScopeId )) ;

        //
        // if this is reserved entry don't delete.
        //

        if( DhcpMScopeIsAddressReserved(MScopeId, ipAddress) ) {
            Error = ERROR_SUCCESS;
            goto ContinueError;
        }

        dataSize = sizeof( leaseExpires );
        Error = MadcapJetGetValue(
            &DbCtx,
            MCAST_COL_HANDLE( MCAST_TBL_LEASE_END),
            &leaseExpires,
            &dataSize
        );

        if( Error != ERROR_SUCCESS ) {
            goto ContinueError;
        }

        DhcpAssert(dataSize == sizeof( leaseExpires ) );


        // if the LeaseExpired value is not zero and the lease has
        // expired then delete the entry.

        if( CompareFileTime( &leaseExpires, (FILETIME *)TimeNow ) < 0 ) {
            // This lease has expired.  Clear the record.
            // Delete this lease if
            //  1. we are asked to delete all expired leases. or
            //  2. the record passed doom time.
            //

            if( DeleteExpiredLeases ||
                    CompareFileTime(
                        &leaseExpires, (FILETIME *)DoomTime ) < 0 ) {

                DhcpPrint(( DEBUG_SCAVENGER, "Deleting Client Record %s.\n",
                    DhcpIpAddressToDottedString(ipAddress) ));

                Error = DhcpMScopeReleaseAddress( MScopeId, ipAddress );

                if( Error != ERROR_SUCCESS ) {
                    //
                    // This is not a big error and should not stop scavenge.
                    //
                    Error = ERROR_SUCCESS;
                    goto ContinueError;
                }

                Error = MadcapJetBeginTransaction(&DbCtx);

                if( Error != ERROR_SUCCESS ) {
                    goto Cleanup;
                }

                Error = MadcapJetDeleteCurrentRecord(&DbCtx);

                if( Error != ERROR_SUCCESS ) {
                    Error = MadcapJetRollBack(&DbCtx);
                    if( Error != ERROR_SUCCESS ) {
                        goto Cleanup;
                    }
                    goto ContinueError;
                }

                Error = MadcapJetCommitTransaction(&DbCtx);

                if( Error != ERROR_SUCCESS ) {
                    goto Cleanup;
                }
                (*nDeleted) ++;
            }
            else {

                //
                // read address State.
                //

                dataSize = sizeof( AddressState );
                Error = MadcapJetGetValue(
                            &DbCtx,
                            MCAST_COL_HANDLE( MCAST_TBL_STATE ),
                            &AddressState,
                            &dataSize );

                if( Error != ERROR_SUCCESS ) {
                    goto ContinueError;
                }

                DhcpAssert( dataSize == sizeof( AddressState )) ;

                if( ! IS_ADDRESS_STATE_DOOMED(AddressState) ) {
                    //
                    // set state to DOOM.
                    //

                    Error = MadcapJetBeginTransaction(&DbCtx);

                    if( Error != ERROR_SUCCESS ) {
                        goto Cleanup;
                    }

                    JetError = JetPrepareUpdate(
                                    DhcpGlobalJetServerSession,
                                    MadcapGlobalClientTableHandle,
                                    JET_prepReplace );

                    Error = DhcpMapJetError( JetError, "M:Cleanup:PrepUpdate" );

                    if( Error == ERROR_SUCCESS ) {

                        SetAddressStateDoomed(AddressState);
                        Error = MadcapJetSetValue(
                                    &DbCtx,
                                    MCAST_COL_HANDLE(MCAST_TBL_STATE),
                                    &AddressState,
                                    sizeof(AddressState) );

                        if( Error == ERROR_SUCCESS ) {
                            Error = MadcapJetCommitUpdate(&DbCtx);
                        }
                    }

                    if( Error != ERROR_SUCCESS ) {

                        Error = MadcapJetRollBack(&DbCtx);
                        if( Error != ERROR_SUCCESS ) {
                            goto Cleanup;
                        }

                        goto ContinueError;
                    }

                    Error = MadcapJetCommitTransaction(&DbCtx);

                    if( Error != ERROR_SUCCESS ) {
                        goto Cleanup;
                    }

                    (*nExpired) ++;
                }
            }
        }

ContinueError:

        if( Error != ERROR_SUCCESS ) {

            DhcpPrint(( DEBUG_ERRORS,
                "Cleanup current database record failed, %ld.\n",
                    Error ));

            ReturnError = Error;
        }

        Error = MadcapJetNextRecord(&DbCtx);

        if( Error == ERROR_NO_MORE_ITEMS ) {
            Error = ERROR_SUCCESS;
            break;
        }

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // get next record Ip Address.
        //

        dataSize = sizeof( NextIpAddress );
        Error = MadcapJetGetValue(
                    &DbCtx,
                    MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
                    &NextIpAddress,
                    &dataSize );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        DhcpAssert( dataSize == sizeof( NextIpAddress )) ;

        //
        // unlock the registry and database locks after each user record
        // processed, so that other threads will get chance to look into
        // the registry and/or database.
        //
        // Since we have noted down the next user record to process,
        // when we resume to process again we know where to start.
        //

        if( TRUE == DatabaseLocked ) {
            UNLOCK_DATABASE();
            DatabaseLocked = FALSE;
        }
    }

    DhcpAssert( Error == ERROR_SUCCESS );

Cleanup:

    if( DatabaseLocked ) {
        UNLOCK_DATABASE();
    }

    return ReturnError;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\mdhcpdb.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/

#define MCAST_CLIENT_TABLE_NAME       "MCastClientTableVer3"

#define MCAST_TBL_IPADDRESS_STR "MCastIpAddr"
#define MCAST_TBL_CLIENT_ID_STR "MCastClientID"
#define MCAST_TBL_CLIENT_INFO_STR "MCastClientInfo"
#define MCAST_TBL_STATE_STR     "MCastState"
#define MCAST_TBL_FLAGS_STR     "MCastFlags"
#define MCAST_TBL_SCOPE_ID_STR     "ScopeId"
#define MCAST_TBL_LEASE_START_STR   "MCastLeaseStart"
#define MCAST_TBL_LEASE_END_STR     "MCastLeaseEnd"
#define MCAST_TBL_SERVER_IP_ADDRESS_STR "MCastServerIp"
#define MCAST_TBL_SERVER_NAME_STR "MCastServerName"


enum {
    MCAST_TBL_IPADDRESS,
    MCAST_TBL_CLIENT_ID,
    MCAST_TBL_CLIENT_INFO,
    MCAST_TBL_STATE,
    MCAST_TBL_FLAGS,
    MCAST_TBL_SCOPE_ID,
    MCAST_TBL_LEASE_START,
    MCAST_TBL_LEASE_END,
    MCAST_TBL_SERVER_IP_ADDRESS,
    MCAST_TBL_SERVER_NAME,
    MCAST_MAX_COLUMN
};

typedef struct _DB_CTX {
    JET_DBID  DbId;
    JET_SESID SessId;
    JET_TABLEID TblId;
} DB_CTX, *PDB_CTX;

typedef struct _DB_COLUMN_CTX {
    char *  Name;
    JET_COLUMNID ColHandle;
    PVOID   Data;
    union {
        DWORD   DataLen;
        PDWORD  pDataLen;
    };
} DB_COLUMN_CTX, *PDB_COLUMN_CTX;

#define INIT_DB_CTX( _ctx, _sessid, _tblid ) {    \
    (_ctx)->SessId = _sessid;                       \
    (_ctx)->TblId = _tblid;                       \
}

#define MCAST_COL_HANDLE( _colid ) MadcapGlobalClientTable[_colid].ColHandle
#define MCAST_COL_NAME( _colid ) MadcapGlobalClientTable[_colid].ColName

#define INIT_DB_COLUMN_CTX( _ctx, _name, _id, _data, _datalen ) {    \
    (_ctx)->Name = _name;                       \
    (_ctx)->ColHandle = _id;                       \
   (_ctx)->Data = _data;                       \
   (_ctx)->DataLen = (DWORD)_datalen                       \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\mdhcppro.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/

DWORD
MadcapJetOpenKey(
    PDB_CTX pDbCtx,
    char *ColumnName,
    PVOID Key,
    DWORD KeySize
);


DWORD
MadcapJetBeginTransaction(
    PDB_CTX pDbCtx
);

DWORD
MadcapJetRollBack(
    PDB_CTX pDbCtx
);

DWORD
MadcapJetCommitTransaction(
    PDB_CTX pDbCtx
);

DWORD
MadcapJetPrepareUpdate(
    PDB_CTX pDbCtx,
    char *ColumnName,
    PVOID Key,
    DWORD KeySize,
    BOOL NewRecord
);

DWORD
MadcapJetCommitUpdate(
    PDB_CTX pDbCtx
);

DWORD
MadcapJetSetValue(
    PDB_CTX pDbCtx,
    JET_COLUMNID KeyColumnId,
    PVOID Data,
    DWORD DataSize
);

DWORD
MadcapJetGetValue(
    PDB_CTX pDbCtx,
    JET_COLUMNID ColumnId,
    PVOID Data,
    PDWORD DataSize
);

DWORD
MadcapJetPrepareSearch(
    PDB_CTX pDbCtx,
    char *ColumnName,
    BOOL SearchFromStart,
    PVOID Key,
    DWORD KeySize
);

DWORD
MadcapJetNextRecord(
    PDB_CTX pDbCtx
);

DWORD
MadcapJetDeleteCurrentRecord(
    PDB_CTX pDbCtx
);

DWORD
MadcapJetGetRecordPosition(
    IN PDB_CTX pDbCtx,
    IN JET_RECPOS *pRecPos,
    IN DWORD    Size
);


// mdhcpsrc.c
DWORD
DhcpInitializeMadcap();

DWORD
ProcessMadcapInform(
    LPDHCP_REQUEST_CONTEXT      RequestContext,
    LPMADCAP_SERVER_OPTIONS     DhcpOptions,
    PBOOL                       SendResponse
    );

DWORD
ProcessMadcapDiscover(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    PBOOL                       SendResponse
    );


DWORD
ProcessMadcapDiscoverAndRequest(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    WORD                        MsgType,
    PBOOL                       SendResponse
    );

DWORD
ProcessMadcapRenew(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    PBOOL                       SendResponse
    );

DWORD
ProcessMadcapRelease(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    PBOOL                       SendResponse
    );

DWORD
MadcapReleaseAddress(
    IN      PM_SUBNET           pSubnet,
    IN      DHCP_IP_ADDRESS        Address
);

// mdhcpmsc.c

BOOL
MadcapGetIpAddressFromClientId(
    PBYTE ClientId,
    DWORD ClientIdLength,
    PVOID IpAddress,
    PDWORD IpAddressLength
);

BOOL
MadcapGetClientIdFromIpAddress(
    PBYTE IpAddress,
    DWORD IpAddressLength,
    PVOID ClientId,
    PDWORD ClientIdLength
);

DWORD
MadcapGetRemainingLeaseTime(
    PBYTE ClientId,
    DWORD ClientIdLength,
    DWORD *LeaseTime
);

DWORD
MadcapCreateClientEntry(
    LPBYTE                ClientIpAddress,
    DWORD                 ClientIpAddressLength,
    DWORD                 ScopeId,
    LPBYTE                ClientId,
    DWORD                 ClientIdLength,
    LPWSTR                ClientInfo OPTIONAL,
    DATE_TIME             LeaseStarts,
    DATE_TIME             LeaseTerminates,
    DWORD                 ServerIpAddress,
    BYTE                  AddressState,
    DWORD                 AddressFlags,
    BOOL                  OpenExisting
    );

DWORD
MadcapValidateClientByClientId(
    LPBYTE ClientIpAddress,
    DWORD   ClientIpAddressLength,
    PVOID   ClientId,
    DWORD   ClientIdLength
    );

DWORD
MadcapRemoveClientEntryByClientId(
    LPBYTE  ClientId,
    DWORD   ClientIdLength,
    BOOL ReleaseAddress
    );

DWORD
MadcapRemoveClientEntryByIpAddress(
    DHCP_IP_ADDRESS ClientIpAddress,
    BOOL ReleaseAddress
    );


DWORD
MadcapRetractOffer(                                      // remove pending list and database entries
    IN      PDHCP_REQUEST_CONTEXT  RequestContext,
    IN      LPMADCAP_SERVER_OPTIONS  DhcpOptions,
    IN      LPBYTE                 ClientId,
    IN      DWORD                  ClientIdLength
);

MadcapGetCurrentClientInfo(
    LPDHCP_MCLIENT_INFO *ClientInfo,
    LPDWORD InfoSize, // optional parameter.
    LPBOOL ValidClient, // optional parameter.
    DWORD  MScopeId
    );

DWORD
GetMCastDatabaseList(
    DWORD   ScopeId,
    LPDHCP_IP_ADDRESS *DatabaseList,
    DWORD *DatabaseListCount
    );

DWORD
DhcpDeleteMScopeClients(
    DWORD MScopeId
    );

DWORD
ChangeMScopeIdInDb(
    DWORD   OldMScopeId,
    DWORD   NewMScopeId
    );

DWORD
CleanupMCastDatabase(
    IN      DATE_TIME*             TimeNow,            // current time standard
    IN      DATE_TIME*             DoomTime,           // Time when the records become 'doom'
    IN      BOOL                   DeleteExpiredLeases,// expired leases be deleted right away? or just set state="doomed"
    OUT     ULONG*                 nExpiredLeases,
    OUT     ULONG*                 nDeletedLeases
);

VOID
DeleteExpiredMcastScopes(
    IN      DATE_TIME*             TimeNow
    );

// Other missing prototypes.
// MBUG: these guys should eventually go into the right place.


VOID
PrintHWAddress(
    IN      LPBYTE                 HWAddress,
    IN      LONG                   HWAddressLength
);

























=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\mdhcpsrv.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  mdhcpdb.c

  Abstract:

  This module contains the functions for interfacing with the JET
  database API pertaining to MADCAP.

  Author:

  Munil Shah

  Environment:

  User Mode - Win32

  Revision History:

  --*/

#include "dhcppch.h"
#define MADCAP_DATA_ALLOCATE    // allocate global data defined in mdhcpsrv.h
#include "mdhcpsrv.h"


#define     DEF_ERROR_OPT_SIZE      16
#define     DEFAULT_LEASE_DURATION  (30*24*60*60)

DWORD
DhcpInitializeMadcap()
{
    RtlZeroMemory(&MadcapGlobalMibCounters,sizeof(MadcapGlobalMibCounters));
    return ERROR_SUCCESS;
}


WIDE_OPTION UNALIGNED *                                           // ptr to add additional options
FormatMadcapCommonMessage(                                 // format the packet for an INFORM
    IN      LPDHCP_REQUEST_CONTEXT pCtxt,    // format for this context
    IN      LPMADCAP_SERVER_OPTIONS  pOptions,
    IN      BYTE                   MessageType,
    IN      DHCP_IP_ADDRESS        ServerAddress
) {

    DWORD                          size;
    DWORD                          Error;
    WIDE_OPTION  UNALIGNED *       option;
    LPBYTE                         OptionEnd;
    PMADCAP_MESSAGE                dhcpReceiveMessage, dhcpSendMessage;
    BYTE                           ServerId[6];
    WORD                           AddrFamily = htons(MADCAP_ADDR_FAMILY_V4);


    dhcpReceiveMessage  = (PMADCAP_MESSAGE)pCtxt->ReceiveBuffer;
    dhcpSendMessage     = (PMADCAP_MESSAGE)pCtxt->SendBuffer;

    RtlZeroMemory( dhcpSendMessage, DHCP_SEND_MESSAGE_SIZE );

    dhcpSendMessage->Version = MADCAP_VERSION;
    dhcpSendMessage->MessageType = MessageType;
    dhcpSendMessage->AddressFamily = htons(MADCAP_ADDR_FAMILY_V4);
    dhcpSendMessage->TransactionID = dhcpReceiveMessage->TransactionID;

    option = &dhcpSendMessage->Option;
    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;



    option = AppendWideOption(        // ==> use this client id as option
        option,
        MADCAP_OPTION_LEASE_ID,
        pOptions->Guid,
        (WORD)pOptions->GuidLength,
        OptionEnd
    );

    memcpy(ServerId, &AddrFamily, 2);
    memcpy(ServerId + 2, &ServerAddress, 4);

    option = AppendWideOption(
        option,
        MADCAP_OPTION_SERVER_ID,
        ServerId,
        sizeof(ServerId),
        OptionEnd );

    return( option );
}

BOOL
ValidateMadcapMessage(
    IN      LPMADCAP_SERVER_OPTIONS     pOptions,
    IN      WORD                        MessageType,
    IN  OUT PBYTE                       NakData,
    IN  OUT WORD                        *NakDataLen,
    OUT     BOOL                        *DropIt
    )

/*++

Routine Description:

   This routine validates madcap message for any semantic errors.If
   there is any error, this routine provides information for the
   ERROR option to be sent via NAK.

Arguments:

   pOptions - Pointer to incoming options.

   MessageType - The type of message

   NakData - The data pertaining to error option. This buffer is allocated
             by the caller.

   NakDataLen - (IN) Length of the above buffer. (OUT) length of error option

   DropIt - whether or not this message should be dropped instead of nak.

Return Value:

   TRUE - if no NAK is to be generated. FALSE otherwise.

--*/
{
    WORD    Ecode;
    PBYTE   ExtraData;
    WORD    i;

    // assume minumum size, currently all types of errors are really small
    DhcpAssert(*NakDataLen >= 6);
    *DropIt = FALSE;       // return value
    *NakDataLen = 0;       // return value
    Ecode = -1;            // assume no error
    ExtraData = NakData+2;   // start past ecode

    do {
        // first check for common errors
        // in general we do not want to NAK packets with missing options
        // even though the draft says we should. Those packets are seriously
        // broken and there is not much value in naking it.

        // is current time ok?
        if (pOptions->Time) {
            DWORD   Skew;
            DWORD   TimeNow = (DWORD)time(NULL);
            Skew =  abs(ntohl(*pOptions->Time) - TimeNow);
            if ( Skew > DhcpGlobalClockSkewAllowance) {
                Ecode = MADCAP_NAK_CLOCK_SKEW;
                *(DWORD UNALIGNED *)(ExtraData) = htonl(Skew);
                *NakDataLen += 4;
                DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - clock skew %ld\n",Skew ));
                break;
            }
        } else {
            // we better not have start time option, because that
            // must be accompanied by current time option.
            if (pOptions->LeaseStartTime || pOptions->MaxStartTime) {
                Ecode = MADCAP_NAK_INVALID_REQ;
                *(WORD UNALIGNED *)(ExtraData) = htons(MADCAP_OPTION_TIME);
                *NakDataLen += 4;
                DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - missing time option\n"));
                break;
            }
        }

        // is client asking for some required features which we don't support?
        // currently we don't support any optional features
        if (pOptions->Features[REQUIRED_FEATURES]) {
            Ecode = MADCAP_NAK_UNSUPPORTED_FEATURE;
            RtlCopyMemory(
                ExtraData,
                &pOptions->Features[REQUIRED_FEATURES],
                pOptions->FeatureCount[REQUIRED_FEATURES]*2
                );
            *NakDataLen += pOptions->FeatureCount[REQUIRED_FEATURES]*2;
            DhcpPrint(( DEBUG_ERRORS,
                        "ValidateMadcapMessage - Required feature %d not supported\n",
                        *(pOptions->Features[REQUIRED_FEATURES]) ));
            break;
        }

	// Check for client id. We NAK the message with zero length client id
	if (0 == pOptions->GuidLength) {
	  *(WORD UNALIGNED *)(NakData) = htons(MADCAP_OPTION_LEASE_ID);
	  *NakDataLen += 2;
	  return FALSE;
	} // if

        // now check for errors specific to message
        switch (MessageType) {
        case MADCAP_INFORM_MESSAGE: {
            WORD    MustOpt[] = {MADCAP_OPTION_LEASE_ID, MADCAP_OPTION_REQUEST_LIST};
            for (i=0; i<sizeof(MustOpt)/sizeof(MustOpt[0]); i++) {
                if (!pOptions->OptPresent[MustOpt[i]]) {
                    *DropIt = TRUE;
                    DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - INFORM with no %d option\n",MustOpt[i] ));
                    break;
                }
            }
            break;
        }
        case MADCAP_DISCOVER_MESSAGE: {
            WORD    MustOpt[] = {MADCAP_OPTION_LEASE_ID, MADCAP_OPTION_MCAST_SCOPE};
            for (i=0; i<sizeof(MustOpt)/sizeof(MustOpt[0]); i++) {
                if (!pOptions->OptPresent[MustOpt[i]]) {
                    *DropIt = TRUE;
                    DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - DISCOVER with no %d option\n",MustOpt[i] ));
                    break;
                }
            }
            break;
        }
        case MADCAP_REQUEST_MESSAGE: {
            WORD    MustOpt[] = {MADCAP_OPTION_LEASE_ID, MADCAP_OPTION_MCAST_SCOPE};
            for (i=0; i<sizeof(MustOpt)/sizeof(MustOpt[0]); i++) {
                if (!pOptions->OptPresent[MustOpt[i]]) {
                    *DropIt = TRUE;
                    DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - REQUEST with no %d option\n",MustOpt[i] ));
                    break;
                }
            }
            break;
        }
        case MADCAP_RENEW_MESSAGE: {
            WORD    MustOpt[] = {MADCAP_OPTION_LEASE_ID};
            for (i=0; i<sizeof(MustOpt)/sizeof(MustOpt[0]); i++) {
                if (!pOptions->OptPresent[MustOpt[i]]) {
                    *DropIt = TRUE;
                    DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - RENEW with no %d option\n",MustOpt[i] ));
                    break;
                }
            }
            break;
        }
        case MADCAP_RELEASE_MESSAGE: {
            WORD    MustOpt[] = {MADCAP_OPTION_LEASE_ID};
            for (i=0; i<sizeof(MustOpt)/sizeof(MustOpt[0]); i++) {
                if (!pOptions->OptPresent[MustOpt[i]]) {
                    *DropIt = TRUE;
                    DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - RENEW with no %d option\n",MustOpt[i] ));
                    break;
                }
            }
            break;
        }
        default:
            DhcpAssert(FALSE);
        }
    } while ( FALSE );

    if (*DropIt) {
        return FALSE;
    } else if ((WORD)-1 != Ecode) {
        *(WORD UNALIGNED *)(NakData) = htons(Ecode);
        *NakDataLen += 2;
        return FALSE;
    } else {
        return TRUE;
    }
}

WIDE_OPTION UNALIGNED *
ConsiderAppendingMadcapOption(                               // conditionally append option to message (if the option is valid)
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,         // ctxt of the client
    IN      WIDE_OPTION  UNALIGNED *Option,
    IN      WORD                 OptionType,         // what option is this?
    IN      LPBYTE                 OptionEnd          // cutoff upto which we can fill options
    )

/*++

Routine Description:

   This routine tries to verify if it is OK to append the option requested and
   if it is not one of the options manually added by the DHCP server, then it is
   appended at the point given by "Option" (assuming it would fit in without outrunning
   "OptionEnd" ).   The format in which it is appended is as per the wire protocol.

Arguments:

   ClientCtxt - This is the bunch of parameters like client class, vendor class etc.

   Option - The location where to start appending the option

   OptionType - The actual OPTION ID to retrieve the value of and append.

   OptionEnd - The end marker for this buffer (the option is not appended if we
       would have to overrun this marker while trying to append)

Return Value:

   The location in memory AFTER the option has been appended (in case the option was
   not appended, this would be the same as "Option" ).

--*/

{
    LPBYTE                         optionValue;
    WORD                           optionSize;
    DWORD                          status;
    DWORD                          option4BVal;


    switch ( OptionType ) {
    case MADCAP_OPTION_MCAST_SCOPE_LIST:
        status = MadcapGetMScopeListOption(
            ClientCtxt->EndPointIpAddress,
            &optionValue,
            &optionSize
        );

        if ( status == ERROR_SUCCESS ) {
            Option = AppendWideOption(
                Option,
                OptionType,
                (PVOID)optionValue,
                optionSize,
                OptionEnd
            );

            //
            // Release the buffer returned by DhcpGetParameter()
            //

            DhcpFreeMemory( optionValue );

        }
        break;

    case MADCAP_OPTION_TIME:
        option4BVal = (DWORD) time(NULL);
        optionSize = 4;
        optionValue = (LPBYTE)&option4BVal;
        Option = AppendWideOption(
            Option,
            OptionType,
            (PVOID)optionValue,
            optionSize,
            OptionEnd
        );
        break;
    case MADCAP_OPTION_FEATURE_LIST: {
        // we dont support any features.
        BYTE    Features[6] = {0,0,0,0,0,0};
        optionSize = 6;
        optionValue = Features;
        Option = AppendWideOption(
            Option,
            OptionType,
            (PVOID)optionValue,
            optionSize,
            OptionEnd
        );
    }
    break;
    default:

        break;

    }

    return Option;
}

WIDE_OPTION UNALIGNED *
AppendMadcapRequestedParameters(                       // if the client requested parameters, add those to the message
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,         // clients context
    IN      LPBYTE                 RequestedList,      // list of options requested by client
    IN      DWORD                  ListLength,         // how long is the list
    OUT     WIDE_OPTION UNALIGNED *Option,             // this is where to start adding the options
    IN      LPBYTE                 OptionEnd          // cutoff pt in the buffer up to which options can be filled
)
{
    WORD           OptionType;
    WIDE_OPTION UNALIGNED *NextOption;
    WIDE_OPTION UNALIGNED *PrevOption;

    NextOption = PrevOption = Option;

    while ( ListLength >= 2) {
        OptionType = ntohs(*(WORD UNALIGNED *)RequestedList);
        NextOption = ConsiderAppendingMadcapOption(
            ClientCtxt,
            PrevOption,
            OptionType,
            OptionEnd
        );
        if (NextOption == PrevOption) {
            // this means that we could not add this requested option
            // fail the whole request by sending the original option
            // pointer.

            // Maybe not!
            // return Option;
            DhcpPrint((DEBUG_ERRORS,"AppendMadcapRequestedParameters: did not add requested opt %ld\n",OptionType));
        }
        ListLength -= 2;
        RequestedList += 2;
        PrevOption = NextOption;
    }

    return NextOption;
}

DWORD
ProcessMadcapInform(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    PBOOL                       SendResponse
    )
    /*++
      ...
      --*/
{
    DWORD                       Error;
    BYTE                       *ClientId,
                               *OptionEnd ;
    DWORD                       ClientIdLength;
    WIDE_OPTION UNALIGNED      *Option;
    LPMADCAP_MESSAGE            dhcpReceiveMessage,dhcpSendMessage;
    WIDE_OPTION UNALIGNED      *CurrOption;
    WCHAR                       ClientInfoBuff[DHCP_IP_KEY_LEN];
    WCHAR                      *ClientInfo;
    DHCP_IP_ADDRESS             ClientIpAddress;
    BYTE                        NakData[DEF_ERROR_OPT_SIZE];
    WORD                        NakDataLen;
    BOOL                        DropIt;

    DhcpPrint((DEBUG_MSTOC, "Processing Madcap Inform\n"));

    dhcpReceiveMessage  = (LPMADCAP_MESSAGE)pCtxt->ReceiveBuffer;
    dhcpSendMessage     = (LPMADCAP_MESSAGE)pCtxt->SendBuffer;
    *SendResponse       = DropIt = FALSE;
    Option              = NULL;
    OptionEnd           = NULL;
    ClientId            = pOptions->Guid;
    ClientIdLength      = pOptions->GuidLength;
    ClientIpAddress     = ((struct sockaddr_in *)&pCtxt->SourceName)->sin_addr.s_addr;
    ClientInfo          = DhcpRegIpAddressToKey(ntohl(ClientIpAddress),ClientInfoBuff);
    Error               = ERROR_SUCCESS;

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Informs);

    // validation
    NakDataLen = DEF_ERROR_OPT_SIZE;
    if (!ValidateMadcapMessage(
            pOptions,
            MADCAP_INFORM_MESSAGE,
            NakData,
            &NakDataLen,
            &DropIt
            )){
        if (DropIt) {
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
        goto Nak;
    }
    // Initialize nak data
    *(WORD UNALIGNED *)NakData = htons(MADCAP_NAK_REQ_NOT_COMPLETED);
    *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_NONE);
    NakDataLen = 4;


    // Here come the actual formatting of the ack!
    Option = FormatMadcapCommonMessage(
        pCtxt,
        pOptions,
        MADCAP_ACK_MESSAGE,
        pCtxt->EndPointIpAddress
        );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    // Finally, add client requested parameters.
    CurrOption = Option;
    Option = AppendMadcapRequestedParameters(
                pCtxt,
                pOptions->RequestList,
                pOptions->RequestListLength,
                Option,
                OptionEnd
                );
    //check if we could add any options.if we didn't then
    // we don't want to send ack.
    if (CurrOption == Option) {
        Error = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    *SendResponse = TRUE;
    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Acks);
    DhcpPrint(( DEBUG_MSTOC,"MadcapInform Acked\n" ));
    goto Cleanup;

Nak:
    // Here come the actual formatting of the Nak!
    Option = FormatMadcapCommonMessage(
        pCtxt,
        pOptions,
        MADCAP_NACK_MESSAGE,
        pCtxt->EndPointIpAddress
        );


    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_ERROR,
                 NakData,
                 NakDataLen,
                 OptionEnd );

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    // dont log all kinds of NACK. Only ones which are useful for diagnosis
    if (ClientIdLength) {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_NACK,
            GETSTRING( DHCP_IP_LOG_NACK_NAME ),
            0,
            ClientId,
            ClientIdLength,
            ClientInfo
        );
    }

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Naks);
    *SendResponse = TRUE;
    Error = ERROR_SUCCESS;
    DhcpPrint(( DEBUG_MSTOC,"MadcapInform Nacked\n" ));


Cleanup:
    if (ERROR_SUCCESS != Error) {
        DhcpPrint(( DEBUG_MSTOC,"MadcapInform Dropped\n" ));
    }

    return( Error );
}

DWORD
MadcapIsRequestedAddressValid(
    LPDHCP_REQUEST_CONTEXT  pCtxt,
    DHCP_IP_ADDRESS         RequestedIpAddress
    )
{
    DWORD   Error;
    //
    // check requested IP address belongs to the appropriate net and
    // it is free.
    //
    if( DhcpSubnetIsAddressExcluded(pCtxt->Subnet, RequestedIpAddress ) ||
        DhcpSubnetIsAddressOutOfRange( pCtxt->Subnet, RequestedIpAddress, FALSE )) {
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    if( DhcpRequestSpecificAddress(pCtxt, RequestedIpAddress) ) {
        // sure, we can offer the requested address.
        return ERROR_SUCCESS;
    } else {
        PBYTE StoredClientId;
        DWORD StoredClientIdLength;
        DHCP_IP_ADDRESS RequestedNetIpAddress;
        BOOL Found;

        // check to see the requested address is a reconciled address, if so
        // we can give it to this requesting client.
        LOCK_DATABASE();
        StoredClientIdLength = 0;
        Found = MadcapGetClientIdFromIpAddress(
                    (PBYTE)&RequestedIpAddress,
                    sizeof ( RequestedIpAddress),
                    &StoredClientId,
                    &StoredClientIdLength
                    );

        UNLOCK_DATABASE();
        Error = ERROR_DHCP_INVALID_DHCP_CLIENT;
        if ( Found ) {
            LPSTR IpAddressString;


            // match the client id and client ipaddress string.
            RequestedNetIpAddress = ntohl(RequestedIpAddress);
            IpAddressString = inet_ntoa( *(struct in_addr *)&RequestedNetIpAddress);

            if( (strlen(StoredClientId) == strlen(IpAddressString)) &&
                    (strcmp(StoredClientId, IpAddressString) == 0) ) {
                Error = ERROR_SUCCESS;
            }
            MIDL_user_free( StoredClientId);
        }
        return Error;
    }
}

DWORD
GetMCastLeaseInfo(
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    OUT     LPDWORD                LeaseDurationPtr,
    IN      DWORD UNALIGNED       *RequestLeaseTime,
    IN      DWORD UNALIGNED       *MinLeaseTime,
    IN      DWORD UNALIGNED       *LeaseStartTime,
    IN      DWORD UNALIGNED       *MaxStartTime,
    OUT     WORD  UNALIGNED       *ErrorOption
)
/*++

Routine Description:


Arguments:

    ClientCtxt - The client ctxt structure for the client to be used to figure out
        the client class and other information.

    LeaseDurationPtr - This DWORD will be filled with the # of seconds the lease is
        to be given out to the client.

    RequestedLeaseTime -- If specified, and if this lease duration is lesser than
        the duration as specified in the configuration, then, this is the duration
        that the client would be returned in LeaseDurationPtr.

    MinLeaseTime - If specified, Minimum lease duration requested by client.

    LeaseStartTime - If specified, desired start time

    MaxStartTime - If specified, max start time

    ErrorOption - If anything fails, the option which caused this

Return Value:

    Win32 Error code.

--*/
{
    LPBYTE                         OptionData;
    DWORD                          Error;
    DWORD                          LocalLeaseDuration;
    DWORD                          LocalLeaseStartTime;
    DWORD                          LocalStartTime;
    DWORD                          OptionDataLength;
    DWORD                          dwUnused;
    DWORD                          LocalRequestedLeaseTime;

    LocalLeaseDuration = 0;
    LocalStartTime = 0;
    LocalRequestedLeaseTime = 0;
    LocalLeaseStartTime = 0;
    OptionDataLength = 0;
    OptionData = NULL;

    Error = DhcpGetParameter(
        0,
        ClientCtxt,
        MADCAP_OPTION_LEASE_TIME,
        &OptionData,
        &OptionDataLength,
        NULL /* dont care if this is reservation option, subnet option etc */
    );

    if ( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_ERRORS, "Unable to read lease value from mscope, %ld.\n", Error));
        LocalLeaseDuration = DEFAULT_LEASE_DURATION;
        OptionData = NULL;
        OptionDataLength = 0;
    } else {
        DhcpAssert( OptionDataLength == sizeof(LocalLeaseDuration) );
        LocalLeaseDuration = *(DWORD *)OptionData;
        LocalLeaseDuration = ntohl( LocalLeaseDuration );

        DhcpFreeMemory( OptionData );
        OptionData = NULL;
        OptionDataLength = 0;
    }

    // did client specify requested lease time?
    if ( ARGUMENT_PRESENT(RequestLeaseTime) ) {
        LocalRequestedLeaseTime =  ntohl( *RequestLeaseTime );
        // Add allowance for clock skew
        LocalRequestedLeaseTime += DhcpGlobalExtraAllocationTime;
    }

    // did client specify start time?
    if (ARGUMENT_PRESENT(LeaseStartTime)) {
        DWORD   CurrentTime = (DWORD)time(NULL);
        LocalLeaseStartTime = ntohl(*LeaseStartTime);
        // does his start time begin in future?
        if (LocalLeaseStartTime >= CurrentTime) {
            // since we always allocate at current time, we need to add
            // the slack for future start time.
            LocalRequestedLeaseTime += (LocalLeaseStartTime - CurrentTime);
        } else {
            // Wow! his start time begins in past!
            DWORD TimeInPast = CurrentTime - LocalLeaseStartTime;
            // cut his lease time by amount requeted in past
            if (LocalRequestedLeaseTime > TimeInPast) {
                LocalRequestedLeaseTime -= TimeInPast;
            } else {
                // this guy starts in past and ends in past! weird!
                *ErrorOption = htons(MADCAP_OPTION_START_TIME);
                return ERROR_DHCP_INVALID_DHCP_CLIENT;;
            }
        }
    }

    // If client requests a shorter lease than what we usually give, shorten it!
    if ( LocalLeaseDuration > LocalRequestedLeaseTime ) {
        if (LocalRequestedLeaseTime) {
            LocalLeaseDuration = LocalRequestedLeaseTime;
        }
    } else {
        // actually he is requesting more than what we can give.
        // if he requested min lease, we need to make sure we can honor it.
        if (ARGUMENT_PRESENT(MinLeaseTime)) {
            DWORD   LocalMinLeaseTime = ntohl(*MinLeaseTime);
            if (LocalMinLeaseTime > LocalLeaseDuration) {
                // we cannot honor his min lease time
                *ErrorOption = htons(MADCAP_OPTION_LEASE_TIME);
                return ERROR_DHCP_INVALID_DHCP_CLIENT;;
            }
        }
    }

    if (LocalLeaseDuration) {
        *LeaseDurationPtr = LocalLeaseDuration;
        return ERROR_SUCCESS;
    } else {
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

}

DWORD
ProcessMadcapDiscoverAndRequest(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    WORD                        MsgType,
    PBOOL                       SendResponse
    )
/*++

Routine Description:

    This routine processes madcap discover, multicast request and
    unicast request messages.

Arguments:

    pCtxt - A pointer to the current request context.

    pOptions - A pointer to a preallocated pOptions structure.

    MsgType - Discover or request

    SendResponse - Pointer to boolean which gets set to true if
                    a response is to be sent to a client.

Return Value:

    Windows Error.

--*/
{
    DWORD                   Error,Error2;
    DWORD                   LeaseDuration;
    BYTE                   *ClientId,
                           *OptionEnd ;
    DWORD                   ClientIdLength;
    WIDE_OPTION UNALIGNED  *Option;
    LPMADCAP_MESSAGE        dhcpReceiveMessage,
                            dhcpSendMessage;
    LPDHCP_PENDING_CTXT     pPending;
    DHCP_IP_ADDRESS         IpAddress;
    DWORD                   ScopeId;
    DWORD                  *RequestedAddrList;
    WORD                    RequestedAddrCount;
    DWORD                  *AllocatedAddrList;
    WORD                    AllocatedAddrCount;
    BOOL                    DbLockHeld;
    BOOL                    PendingClientFound, DbClientFound;
    WCHAR                   ClientInfoBuff[DHCP_IP_KEY_LEN];
    WCHAR                  *ClientInfo;
    DHCP_IP_ADDRESS         ClientIpAddress;
    BYTE                    NakData[DEF_ERROR_OPT_SIZE];
    WORD                    NakDataLen;
    BOOL                    DropIt;
    BOOL                    DiscoverMsg, McastRequest;


    DhcpPrint(( DEBUG_MSTOC, "Processing MadcapDiscoverAndRequest.\n" ));

    dhcpReceiveMessage  = (LPMADCAP_MESSAGE)pCtxt->ReceiveBuffer;
    dhcpSendMessage     = (LPMADCAP_MESSAGE)pCtxt->SendBuffer;
    RequestedAddrList   = AllocatedAddrList = NULL;
    RequestedAddrCount  = AllocatedAddrCount = 0;
    PendingClientFound  = DbClientFound = FALSE;
    DbLockHeld          = FALSE;
    *SendResponse       = DropIt = FALSE;
    DiscoverMsg         = McastRequest = FALSE;
    LeaseDuration       = 0;
    IpAddress           = 0;
    ScopeId             = 0;
    Option              = NULL;
    OptionEnd           = NULL;
    ClientId            = pOptions->Guid;
    ClientIdLength      = pOptions->GuidLength;
    ClientIpAddress     = ((struct sockaddr_in *)&pCtxt->SourceName)->sin_addr.s_addr;
    ClientInfo          = DhcpRegIpAddressToKey(ntohl(ClientIpAddress),ClientInfoBuff);
    Error               = ERROR_SUCCESS;


    if( MADCAP_DISCOVER_MESSAGE == MsgType ) {
        InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Discovers);
    } else {
        InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Requests);
    }

    // validation
    NakDataLen = DEF_ERROR_OPT_SIZE;
    if (!ValidateMadcapMessage(
            pOptions,
            MsgType,
            NakData,
            &NakDataLen,
            &DropIt
            )){
        if (DropIt) {
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
        goto Nak;
    }
#if DBG
    PrintHWAddress( ClientId, ClientIdLength );
#endif

    // Initialize nak data
    *(WORD UNALIGNED *)NakData = htons(MADCAP_NAK_REQ_NOT_COMPLETED);
    *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_NONE);
    NakDataLen = 4;

    // is this request part of four packet exchange protocol or is it
    // part of two packet exchange protocol
    if (MADCAP_DISCOVER_MESSAGE == MsgType) {
        DhcpPrint(( DEBUG_MSTOC, "MadcapDiscoverAndRequest: it's DISCOVER.\n" ));
        DiscoverMsg = TRUE;
    } else if (pOptions->Server) {
        DhcpPrint(( DEBUG_MSTOC, "MadcapDiscoverAndRequest: it's MULTICAST REQUEST.\n" ));
        McastRequest = TRUE;
    }

    if (pOptions->MinAddrCount) {
        WORD    MinAddrCount = ntohs(*pOptions->MinAddrCount);
        // MBUG: Can't do more than one ip
        if (MinAddrCount > 1) {
            *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_ADDR_COUNT);
            goto Nak;
        }
    }
    // first validate the scopeid option
    ScopeId = ntohl(*pOptions->ScopeId);
    Error = DhcpServerFindMScope(
                pCtxt->Server,
                ScopeId,
                NULL,
                &pCtxt->Subnet
                );
    if (ERROR_SUCCESS != Error) {
        DhcpPrint(( DEBUG_ERRORS, "ProcessMadcapDiscoverAndRequest could not find MScope id %ld\n", ScopeId ));
        *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_MCAST_SCOPE);
        goto Nak;
    }
    // is this scope disabled?
    if( DhcpSubnetIsDisabled(pCtxt->Subnet, TRUE) ) {
        *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_MCAST_SCOPE);
        goto Nak;
    }

    // did client specify specific address list?
    if (pOptions->AddrRangeList) {
        Error = ExpandMadcapAddressList(
                    pOptions->AddrRangeList,
                    pOptions->AddrRangeListSize,
                    NULL,
                    &RequestedAddrCount
                    );
        if (ERROR_BUFFER_OVERFLOW != Error) {
            goto Cleanup;
        }
        RequestedAddrList = DhcpAllocateMemory(RequestedAddrCount*sizeof(DWORD));
        if (!RequestedAddrList ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        Error = ExpandMadcapAddressList(
                    pOptions->AddrRangeList,
                    pOptions->AddrRangeListSize,
                    RequestedAddrList,
                    &RequestedAddrCount
                    );
        if (ERROR_SUCCESS != Error) {
            goto Cleanup;
        }
        // retrieve the first ip requested by the client
        IpAddress  = ntohl( RequestedAddrList[0]);
    }
    // MBUG: Currently we don't support more than one ip
    RequestedAddrCount = 1;

    AllocatedAddrList = DhcpAllocateMemory(RequestedAddrCount*sizeof(DWORD));
    if (!AllocatedAddrList) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // make sure that the requested ip is good
    if ( IpAddress ) {
        IpAddress = ntohl(RequestedAddrList[0]);
        Error = DhcpGetMScopeForAddress( IpAddress, pCtxt );
        if (ERROR_SUCCESS != Error ) {
            DhcpPrint(( DEBUG_ERRORS, "ProcessMadcapDiscoverAndRequest could not find MScope for reqested ip %s\n",
                        DhcpIpAddressToDottedString(IpAddress) ));
            *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_MCAST_SCOPE);
            goto Nak;
        }
        // make sure the requested scopeid matches with the scopeid of the requested address.
        if (ScopeId != pCtxt->Subnet->MScopeId) {
            DhcpPrint(( DEBUG_ERRORS, "ProcessMadcapDiscoverAndRequest reqested ip %s not in the requested scope id %ld\n",
                        DhcpIpAddressToDottedString(IpAddress), ScopeId ));
            *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_MCAST_SCOPE);
            goto Nak;
        }
    }

    //
    // If the client specified a server identifier option, we should
    // drop this packet unless the identified server is this one.
    if ( McastRequest && *pOptions->Server != pCtxt->EndPointIpAddress ) {
         DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: Ignoring request, retracting offer\n"));
         Error = MadcapRetractOffer(
                    pCtxt,
                    pOptions,
				    ClientId,
				    ClientIdLength
				  );
         goto Cleanup;
    }

    // find out if we can honor the lease duration
    Error = GetMCastLeaseInfo(
                pCtxt,
                &LeaseDuration,
                pOptions->RequestLeaseTime,
                pOptions->MinLeaseTime,
                pOptions->LeaseStartTime,
                pOptions->MaxStartTime ,
                (WORD UNALIGNED *)(NakData+2)
                );

    if (ERROR_SUCCESS != Error) {
        goto Nak;
    }
#if DBG
    {
        time_t scratchTime;

        scratchTime = LeaseDuration;

        DhcpPrint(( DEBUG_MSTOC, "MadcapDiscoverAndRequest: providing lease upto %.19s\n",
                    asctime(localtime(&scratchTime)) ));
    }
#endif

    // Now lookup the client both in pending list and database.
    LOCK_INPROGRESS_LIST();
    Error = DhcpFindPendingCtxt(
        ClientId,
        ClientIdLength,
        0,
        &pPending
    );
    if( ERROR_SUCCESS == Error ) {                     // there is some pending ctxt with this address
        if( IpAddress && IpAddress != pPending->Address ) {
            DhcpPrint((DEBUG_ERRORS,
                       "ProcessMadcapDiscoverAndRequest: Nacking %lx - pending ctx has different Addr %lx\n",
                       IpAddress, pPending->Address));
            UNLOCK_INPROGRESS_LIST();
            goto Nak;
        }
        DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: pending record found %s\n",
                   DhcpIpAddressToDottedString(IpAddress)));
        IpAddress = pPending->Address;

        // is this a DHCP context?
        if ( !CLASSD_HOST_ADDR( pPending->Address )) {
            UNLOCK_INPROGRESS_LIST();
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }

        DhcpAssert( !pPending->Processing );
        PendingClientFound = TRUE;
        // everything looks ok, remove and free the context and proceed
        Error = DhcpRemovePendingCtxt(pPending);
        DhcpAssert(ERROR_SUCCESS == Error);
        DhcpFreeMemory(pPending);
    }
    UNLOCK_INPROGRESS_LIST();

    // Now look him up in the DB.
    //
    LOCK_DATABASE();
    DbLockHeld = TRUE;
    // if we know the ipaddress then look him up in the DB.
    // if he exists then make sure there is no inconsistency,
    // if inconsistent then send NAK
    // else do nothing and send ACK. Atleast, don't renew it as the client
    // is supposed to send the renewal packet.
    if (IpAddress) {
        Error = MadcapValidateClientByClientId(
                    (LPBYTE)&IpAddress,
                    sizeof (IpAddress),
                    ClientId,
                    ClientIdLength);
        if ( ERROR_SUCCESS == Error ) {
            DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: database record found %s\n",
                       DhcpIpAddressToDottedString(IpAddress)));
            DbClientFound = TRUE;
        } else if ( Error != ERROR_FILE_NOT_FOUND ){
            DhcpPrint((DEBUG_MSTOC,
                       "ProcessMadcapDiscoverAndRequest: conflict with the database clientid entry\n"));
            goto Nak;
        }
    } else {
        DWORD   IpAddressLen = sizeof (IpAddress);
        if (MadcapGetIpAddressFromClientId(
                  ClientId,
                  ClientIdLength,
                  &IpAddress,
                  &IpAddressLen
                  ) ) {
            DbClientFound = TRUE;
            DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: database record found %s\n",
                       DhcpIpAddressToDottedString(IpAddress)));
        } else {
            DhcpPrint((DEBUG_ERRORS,"ProcessMadcapDiscoverAndRequest - could not find ipaddress from client id\n"));
        }
    }

    if ( !PendingClientFound && !DbClientFound ) {
        if (DiscoverMsg || !McastRequest) {
            if (IpAddress) {
                DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: requesting specific address %s\n",
                           DhcpIpAddressToDottedString(IpAddress)));
                if (!DhcpRequestSpecificMAddress(pCtxt, IpAddress)) {
                    DhcpPrint(( DEBUG_ERRORS, "ProcessMadcapDiscoverAndRequest could not allocate specific address, %ld\n", Error));
                    Error = ERROR_DHCP_ADDRESS_NOT_AVAILABLE;
                }
            } else {
                // we need to determine a brand new address for this client.
                Error = DhcpRequestSomeAddress(                    // try to get some address..
                    pCtxt,
                    &IpAddress,
                    FALSE
                );
                if ( ERROR_SUCCESS != Error ) {
                    DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: allocating address %s\n",
                               DhcpIpAddressToDottedString(IpAddress)));
                }

            }
            if ( ERROR_SUCCESS != Error ) {
                if( Error == ERROR_DHCP_RANGE_FULL ) {             // failed because of lack of addresses
                    DhcpGlobalScavengeIpAddress = TRUE;            // flag scanvenger to scavenge ip addresses
                }

                DhcpPrint(( DEBUG_ERRORS, "ProcessMadcapDiscoverAndRequest could not allocate new address, %ld\n", Error));
                goto Nak;
            }
        } else {
            DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: could not find client entry in db or pending list\n"));
            goto Nak;
        }
    }

    DhcpAssert(IpAddress);

    // If IpAddress is out of range, then ignore this request.
    if( DhcpSubnetIsAddressOutOfRange(pCtxt->Subnet,IpAddress, FALSE) ||
        DhcpSubnetIsAddressExcluded(pCtxt->Subnet,IpAddress) ) {

        DhcpPrint((DEBUG_MSTOC,
                   "ProcessMadcapDiscoverAndRequest: OutOfRange/Excluded ipaddress\n"));
        goto Nak;
    }


    AllocatedAddrList[AllocatedAddrCount++] = htonl(IpAddress);

    if (!DiscoverMsg) {
        Error = MadcapCreateClientEntry(
            (LPBYTE)&IpAddress,  // desired ip address
            sizeof (IpAddress),
            ScopeId,
            ClientId,
            ClientIdLength,
            ClientInfo,
            DhcpCalculateTime( 0 ),
            DhcpCalculateTime( LeaseDuration ),
            ntohl(pCtxt->EndPointIpAddress),
            ADDRESS_STATE_ACTIVE,
            0,   // no flags currently.
            DbClientFound
        );
        if ( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_MSTOC, "ProcessMadcapDiscoverAndRequest:Releasing attempted address: 0x%lx\n", IpAddress));
            Error2 = DhcpSubnetReleaseAddress(pCtxt->Subnet, IpAddress);
            DhcpAssert(ERROR_SUCCESS == Error2);
            goto Cleanup;
        }

        UNLOCK_DATABASE();
        DbLockHeld = FALSE;

        DhcpUpdateAuditLog(
            DHCP_IP_LOG_ASSIGN,
            GETSTRING( DHCP_IP_LOG_ASSIGN_NAME ),
            IpAddress,
            ClientId,
            ClientIdLength,
            ClientInfo
        );

    } else {
        UNLOCK_DATABASE();
        DbLockHeld = FALSE;

        LOCK_INPROGRESS_LIST();                        // locks unnecessary as must have already been taken? 
        Error = DhcpAddPendingCtxt(
            ClientId,
            ClientIdLength,
            IpAddress,
            LeaseDuration,
            0,
            0,
            ScopeId,
            DhcpCalculateTime( MADCAP_OFFER_HOLD ),
            FALSE                                      // this record has been processed, nothing more to do
        );
        UNLOCK_INPROGRESS_LIST();
        DhcpAssert(ERROR_SUCCESS == Error);            // expect everything to go well here

    }

Ack:
    if (DbLockHeld) {
        UNLOCK_DATABASE();
        DbLockHeld = FALSE;
    }
    Option = FormatMadcapCommonMessage(
                pCtxt,
                pOptions,
                (BYTE)(DiscoverMsg?MADCAP_OFFER_MESSAGE:MADCAP_ACK_MESSAGE),
                pCtxt->EndPointIpAddress
                );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    Option = AppendMadcapAddressList(
                Option,
                AllocatedAddrList,
                AllocatedAddrCount,
                OptionEnd
                );

    ScopeId = htonl(ScopeId);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_MCAST_SCOPE,
                 &ScopeId,
                 sizeof(ScopeId),
                 OptionEnd );

    LeaseDuration = htonl(LeaseDuration);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_LEASE_TIME,
                 &LeaseDuration,
                 sizeof(LeaseDuration),
                 OptionEnd );


    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    DhcpPrint(( DEBUG_MSTOC,
        "ProcessMadcapDiscoverAndRequest committed, address %s (%ws).\n",
            DhcpIpAddressToDottedString(IpAddress),
            ClientInfo ));

    Error = ERROR_SUCCESS;
    *SendResponse = TRUE;
    if (DiscoverMsg) {
        InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Offers);
        DhcpPrint(( DEBUG_MSTOC, "ProcessMadcapDiscoverAndRequest Offered.\n" ));
    } else {
        InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Acks);
        DhcpPrint(( DEBUG_MSTOC, "ProcessMadcapDiscoverAndRequest Acked.\n" ));
    }
    goto Cleanup;

Nak:
    if (DbLockHeld) {
        UNLOCK_DATABASE();
        DbLockHeld = FALSE;
    }
    DhcpPrint(( DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: %s Nack'd.\n",
            DhcpIpAddressToDottedString ( IpAddress ) ));

    Option = FormatMadcapCommonMessage(
                pCtxt,
                pOptions,
                MADCAP_NACK_MESSAGE,
                pCtxt->EndPointIpAddress
                );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    DhcpAssert(NakDataLen);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_ERROR,
                 NakData,
                 NakDataLen,
                 OptionEnd );

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    // dont log all kinds of NACK. Only those useful for diagnosis
    if (ClientIdLength) {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_NACK,
            GETSTRING( DHCP_IP_LOG_NACK_NAME ),
            IpAddress,
            ClientId,
            ClientIdLength,
            ClientInfo
        );
    }

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Naks);
    *SendResponse = TRUE;
    Error = ERROR_SUCCESS;
    DhcpPrint(( DEBUG_MSTOC, "ProcessMadcapDiscoverAndRequest Nacked.\n" ));

Cleanup:
    if (DbLockHeld) {
        UNLOCK_DATABASE();
    }

    if (RequestedAddrList) {
        DhcpFreeMemory(RequestedAddrList);
    }
    if (AllocatedAddrList) {
        DhcpFreeMemory(AllocatedAddrList);
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_MSTOC, "ProcessMadcapDiscoverAndRequest failed, %ld.\n", Error ));
    }

    return( Error );
}

DWORD
ProcessMadcapRenew(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    PBOOL                       SendResponse
    )
/*++

Routine Description:

    This function processes a DHCP Request request packet.

Arguments:

    pCtxt - A pointer to the current request context.

    pOptions - A pointer to a preallocated pOptions structure.

Return Value:

    Windows Error.

--*/
{
    DWORD                   Error,Error2,
                            LeaseDuration;
    BYTE                   *ClientId,
                           *OptionEnd ;
    DWORD                   ClientIdLength;
    WIDE_OPTION  UNALIGNED *Option;
    LPMADCAP_MESSAGE        dhcpReceiveMessage,
                            dhcpSendMessage;
    LPDHCP_PENDING_CTXT     pPending;
    DHCP_IP_ADDRESS         IpAddress;
    DWORD                   IpAddressLen;
    DWORD                   ScopeId;
    DWORD                  *AllocatedAddrList;
    WORD                    AllocatedAddrCount;
    BOOL                    DbLockHeld;
    WCHAR                   ClientInfoBuff[DHCP_IP_KEY_LEN];
    WCHAR                  *ClientInfo;
    DHCP_IP_ADDRESS         ClientIpAddress;
    BYTE                    NakData[DEF_ERROR_OPT_SIZE];
    WORD                    NakDataLen;
    BOOL                    DropIt;

    DhcpPrint(( DEBUG_MSTOC, "Processing MADCAPRENEW.\n" ));

    dhcpReceiveMessage  = (LPMADCAP_MESSAGE)pCtxt->ReceiveBuffer;
    dhcpSendMessage     = (LPMADCAP_MESSAGE)pCtxt->SendBuffer;
    AllocatedAddrList   = NULL;
    AllocatedAddrCount  = 0;
    DbLockHeld          = FALSE;
    *SendResponse       = DropIt = FALSE;
    LeaseDuration       = 0;
    IpAddress           = 0;
    ScopeId             = 0;
    Option              = NULL;
    OptionEnd           = NULL;
    ClientId            = pOptions->Guid;
    ClientIdLength      = pOptions->GuidLength;
    ClientIpAddress     = ((struct sockaddr_in *)&pCtxt->SourceName)->sin_addr.s_addr;
    ClientInfo          = DhcpRegIpAddressToKey(ntohl(ClientIpAddress),ClientInfoBuff);
    Error               = ERROR_SUCCESS;


    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Renews);

    // validation
    NakDataLen = DEF_ERROR_OPT_SIZE;
    if (!ValidateMadcapMessage(
            pOptions,
            MADCAP_RENEW_MESSAGE,
            NakData,
            &NakDataLen,
            &DropIt
            )){
        if (DropIt) {
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
        goto Nak;
    }

    // Initialize nak data
    *(WORD UNALIGNED *)NakData = htons(MADCAP_NAK_REQ_NOT_COMPLETED);
    *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_NONE);
    NakDataLen = 4;

#if DBG
    PrintHWAddress( ClientId, ClientIdLength );
#endif

    LOCK_DATABASE();
    DbLockHeld = TRUE;
    // first lookup this client using its id.If we cannot find him in the db
    // then nak him
    IpAddressLen = sizeof (IpAddress);
    if (!MadcapGetIpAddressFromClientId(
              ClientId,
              ClientIdLength,
              &IpAddress,
              &IpAddressLen
              ) ) {
        *(WORD UNALIGNED *)NakData = htons(MADCAP_NAK_INVALID_LEASE_ID);
        NakDataLen = 2;

        DhcpPrint((DEBUG_ERRORS,"ProcessMadcapRenew - could not find ipaddress from client id\n"));
        goto Nak;
    }

    AllocatedAddrList = DhcpAllocateMemory(1*sizeof(DWORD));
    if (!AllocatedAddrList) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Error = DhcpGetMScopeForAddress(IpAddress,pCtxt);
    if (ERROR_SUCCESS != Error) {
        DhcpPrint(( DEBUG_ERRORS, "MadcapRenew could not find MScope for %s\n",
                    DhcpIpAddressToDottedString( IpAddress ) ));
        // this shouldn't really happen.
        DhcpAssert(FALSE);
        goto Cleanup;
    }
    ScopeId = pCtxt->Subnet->MScopeId;

    if( DhcpSubnetIsDisabled(pCtxt->Subnet, TRUE) ) {
        goto Nak;
    }

    AllocatedAddrList[AllocatedAddrCount++] = htonl(IpAddress);
    GetMCastLeaseInfo(
        pCtxt,
        &LeaseDuration,
        pOptions->RequestLeaseTime,
        pOptions->MinLeaseTime,
        pOptions->LeaseStartTime,
        pOptions->MaxStartTime,
        (WORD UNALIGNED *)(NakData+2)
        );

    Error = MadcapCreateClientEntry(
        (LPBYTE)&IpAddress,  // desired ip address
        sizeof(IpAddress),
        ScopeId,
        ClientId,
        ClientIdLength,
        ClientInfo,
        DhcpCalculateTime( 0 ),
        DhcpCalculateTime( LeaseDuration ),
        ntohl(pCtxt->EndPointIpAddress),
        ADDRESS_STATE_ACTIVE,
        0,   // no flags currently.
        TRUE
    );


    UNLOCK_DATABASE();
    DbLockHeld = FALSE;

    if ( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_MSTOC, "Could not update DB for : 0x%lx\n", IpAddress));
        DhcpAssert(FALSE);
        goto Cleanup;
    }

    DhcpUpdateAuditLog(
        DHCP_IP_LOG_ASSIGN,
        GETSTRING( DHCP_IP_LOG_RENEW_NAME ),
        IpAddress,
        ClientId,
        ClientIdLength,
        NULL
    );

    Option = FormatMadcapCommonMessage(
                pCtxt,
                pOptions,
                MADCAP_ACK_MESSAGE,
                pCtxt->EndPointIpAddress
                );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    Option = AppendMadcapAddressList(
                Option,
                AllocatedAddrList,
                AllocatedAddrCount,
                OptionEnd
                );
    LeaseDuration = htonl(LeaseDuration);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_LEASE_TIME,
                 &LeaseDuration,
                 sizeof(LeaseDuration),
                 OptionEnd );

    ScopeId = htonl(ScopeId);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_MCAST_SCOPE,
                 &ScopeId,
                 sizeof(ScopeId),
                 OptionEnd );

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    DhcpPrint(( DEBUG_MSTOC,"MadcapRenew committed, address %s \n",
            DhcpIpAddressToDottedString(IpAddress)));

    Error = ERROR_SUCCESS;
    *SendResponse = TRUE;
    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Acks);
    DhcpPrint(( DEBUG_MSTOC, "MadcapRenew acked.\n"));
    goto Cleanup;

Nak:
    if (DbLockHeld) {
        UNLOCK_DATABASE();
        DbLockHeld = FALSE;
    }
    DhcpPrint(( DEBUG_MSTOC,"Invalid MADCAPRENEW for %s Nack'd.\n",
            DhcpIpAddressToDottedString ( IpAddress ) ));

    Option = FormatMadcapCommonMessage(
                pCtxt,
                pOptions,
                MADCAP_NACK_MESSAGE,
                pCtxt->EndPointIpAddress
                );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    DhcpAssert(NakDataLen);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_ERROR,
                 NakData,
                 NakDataLen,
                 OptionEnd );

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    // dont log all kinds of NACK. Only those useful for diagnosis
    if (ClientIdLength) {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_NACK,
            GETSTRING( DHCP_IP_LOG_NACK_NAME ),
            IpAddress,
            ClientId,
            ClientIdLength,
            ClientInfo
        );
    }

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Naks);
    *SendResponse = TRUE;
    Error = ERROR_SUCCESS;
    DhcpPrint(( DEBUG_MSTOC, "MadcapRenew Nacked.\n"));

Cleanup:
    if (DbLockHeld) {
        UNLOCK_DATABASE();
    }

    if (AllocatedAddrList) {
        DhcpFreeMemory(AllocatedAddrList);
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_MSTOC, "MadcapRenew failed, %ld.\n", Error ));
    }

    return( Error );
}

DWORD
ProcessMadcapRelease(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    PBOOL                       SendResponse
    )
/*++

Routine Description:

    This function processes a DHCP Release request packet.

Arguments:

    pCtxt - A pointer to the current request context.

    pOptions - A pointer to a preallocated pOptions structure.

Return Value:

    FALSE - Do not send a response.

--*/
{
    DWORD                   Error,Error2;
    DHCP_IP_ADDRESS         ClientIpAddress;
    DHCP_IP_ADDRESS         IpAddress = 0;
    DWORD                   IpAddressLen;
    LPMADCAP_MESSAGE        dhcpReceiveMessage;
    LPMADCAP_MESSAGE        dhcpSendMessage;
    LPDHCP_PENDING_CTXT     pPending = NULL;
    BYTE                    *ClientId;
    DWORD                   ClientIdLength;
    WCHAR                   *pwszName;
    WIDE_OPTION  UNALIGNED *Option;
    LPBYTE                  OptionEnd;
    DB_CTX                  DbCtx;
    WCHAR                   ClientInfoBuff[DHCP_IP_KEY_LEN];
    WCHAR                  *ClientInfo;
    BYTE                    NakData[DEF_ERROR_OPT_SIZE];
    WORD                    NakDataLen;
    BOOL                    DropIt;

    DhcpPrint(( DEBUG_MSTOC, "MadcapRelease arrived.\n" ));

    dhcpReceiveMessage  = (LPMADCAP_MESSAGE)pCtxt->ReceiveBuffer;
    dhcpSendMessage     = (LPMADCAP_MESSAGE)pCtxt->SendBuffer;
    *SendResponse       = DropIt = FALSE;
    IpAddress           = 0;
    IpAddressLen        = 0;
    Option              = NULL;
    OptionEnd           = NULL;
    ClientId            = pOptions->Guid;
    ClientIdLength      = pOptions->GuidLength;
    ClientIpAddress     = ((struct sockaddr_in *)&pCtxt->SourceName)->sin_addr.s_addr;
    ClientInfo          = DhcpRegIpAddressToKey(ntohl(ClientIpAddress),ClientInfoBuff);
    Error               = ERROR_SUCCESS;

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Releases);

    // validation
    NakDataLen = DEF_ERROR_OPT_SIZE;
    if (!ValidateMadcapMessage(
            pOptions,
            MADCAP_RELEASE_MESSAGE,
            NakData,
            &NakDataLen,
            &DropIt
            )){
        if (DropIt) {
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
        goto Nak;
    }
    // Initialize nak data
    *(WORD UNALIGNED *)NakData = htons(MADCAP_NAK_REQ_NOT_COMPLETED);
    *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_NONE);
    NakDataLen = 4;

#if DBG
    PrintHWAddress( ClientId, ClientIdLength );
#endif

    LOCK_DATABASE();

    // find the client in the database.
    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);
    IpAddressLen = sizeof (IpAddress);
    if (!MadcapGetIpAddressFromClientId(
            ClientId,
            ClientIdLength,
            &IpAddress,
            &IpAddressLen
            )) {
        UNLOCK_DATABASE();
        *(WORD UNALIGNED *)NakData = htons(MADCAP_NAK_INVALID_LEASE_ID);
        NakDataLen = 2;
        goto Nak;
    }

    DhcpPrint(( DEBUG_MSTOC, "MadcapRelease address, %s.\n",
                DhcpIpAddressToDottedString(IpAddress) ));

    Error = MadcapRemoveClientEntryByClientId(
                ClientId,
                ClientIdLength,
                TRUE);       // release address from bit map.

    if (Error == ERROR_SUCCESS) {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_RELEASE,
            GETSTRING( DHCP_IP_LOG_RELEASE_NAME ),
            IpAddress,
            ClientId,
            ClientIdLength,
            NULL
        );
    }

    UNLOCK_DATABASE();


    // finally if there is any pending request for this client,
    // remove it now.
    LOCK_INPROGRESS_LIST();
    Error2 = DhcpFindPendingCtxt(
        ClientId,
        ClientIdLength,
        0,
        &pPending
    );
    if( ERROR_SUCCESS == Error2 ) {

        // is this a DHCP context?
        if ( !CLASSD_HOST_ADDR( pPending->Address )) {
            UNLOCK_INPROGRESS_LIST();
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }

        Error2 = DhcpRemovePendingCtxt(
            pPending
        );
        DhcpAssert( ERROR_SUCCESS == Error2);
        Error2 = MadcapDeletePendingCtxt(
            pPending
        );
        DhcpAssert( ERROR_SUCCESS == Error2 );
    }
    UNLOCK_INPROGRESS_LIST();

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_MSTOC, "DhcpRelease failed, %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // send a response.
    //
    Option = FormatMadcapCommonMessage(
                pCtxt,
                pOptions,
                MADCAP_ACK_MESSAGE,
                pCtxt->EndPointIpAddress
                );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    DhcpAssert( pCtxt->SendMessageSize <= DHCP_SEND_MESSAGE_SIZE );

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Acks);
    *SendResponse = TRUE;
    DhcpPrint(( DEBUG_MSTOC,"MadcapRelease for %s Acked.\n",
            DhcpIpAddressToDottedString ( IpAddress ) ));
    goto Cleanup;

Nak:
    DhcpPrint(( DEBUG_MSTOC,"MadcapRelease for %s Nack'd.\n",
            DhcpIpAddressToDottedString ( IpAddress ) ));

    Option = FormatMadcapCommonMessage(
                pCtxt,
                pOptions,
                MADCAP_NACK_MESSAGE,
                pCtxt->EndPointIpAddress
                );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    DhcpAssert(NakDataLen);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_ERROR,
                 NakData,
                 NakDataLen,
                 OptionEnd );

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    // dont log all kinds of NACK. Only those useful for diagnosis
    if (ClientIdLength) {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_NACK,
            GETSTRING( DHCP_IP_LOG_NACK_NAME ),
            IpAddress,
            ClientId,
            ClientIdLength,
            ClientInfo
        );
    }

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Naks);
    *SendResponse = TRUE;
    Error = ERROR_SUCCESS;

Cleanup:
    if (ERROR_SUCCESS != Error) {

        DhcpPrint(( DEBUG_MSTOC, "MadcapRelease failed %ld\n", Error));
    }
    return( Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\mdhcpsrv.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/

#include "mdhcpdb.h"
#include "mdhcppro.h"
#include <ws2tcpip.h>


#ifdef MADCAP_DATA_ALLOCATE
#define MADCAP_EXTERN
#else
#define MADCAP_EXTERN extern
#endif

// mib counters
typedef
struct _MADCAP_MIB_COUNTERS {
    DWORD   Discovers;
    DWORD Offers;
    DWORD Requests;
    DWORD Renews;
    DWORD Acks;
    DWORD Naks;
    DWORD Releases;
    DWORD Informs;
} MADCAP_MIB_COUNTERS, *LPMADCAP_MIB_COUNTERS;

// externs
MADCAP_EXTERN TABLE_INFO *MadcapGlobalClientTable;   // point to static memory.
MADCAP_EXTERN JET_TABLEID MadcapGlobalClientTableHandle;
MADCAP_EXTERN int  MadcapGlobalTTL;
MADCAP_EXTERN MADCAP_MIB_COUNTERS MadcapGlobalMibCounters;

// misc stuff which eventually go in the right place.

#define     INVALID_MSCOPE_ID      0x0
#define     INVALID_MSCOPE_NAME    NULL


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\mdhcsapi.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
//
// Subnet APIs
//
#include "dhcppch.h"
#include "dhcp2_srv.h"
#include "mdhcpsrv.h"
#include "rpcapi.h"

#include "uniqid.h"

DWORD
DhcpCreateMScope(
    LPWSTR   pMScopeName,
    LPDHCP_MSCOPE_INFO pMScopeInfo
)
{
    DWORD                          Error, Error2;
    PM_SUBNET                      pMScope;
    PM_SUBNET                      pOldMScope = NULL;

    DhcpAssert( pMScopeName && pMScopeInfo );

    if (wcscmp(pMScopeName, pMScopeInfo->MScopeName ))
        return ERROR_INVALID_PARAMETER;

    if( !DhcpServerValidateNewMScopeId(DhcpGetCurrentServer(),pMScopeInfo->MScopeId) )
        return ERROR_DHCP_MSCOPE_EXISTS;
    if( !DhcpServerValidateNewMScopeName(DhcpGetCurrentServer(),pMScopeInfo->MScopeName) )
        return ERROR_DHCP_MSCOPE_EXISTS;

    Error = MemMScopeInit(
        &pMScope,
        pMScopeInfo->MScopeId,
        pMScopeInfo->MScopeState,
        pMScopeInfo->MScopeAddressPolicy,
        pMScopeInfo->TTL,
        pMScopeName,
        pMScopeInfo->MScopeComment,
        pMScopeInfo->LangTag,
        pMScopeInfo->ExpiryTime
        );

    if( ERROR_SUCCESS != Error ) return Error;
    DhcpAssert(pMScope);

    Error = MemServerAddMScope( DhcpGetCurrentServer(), pMScope,
				INVALID_UNIQ_ID );

    if( ERROR_SUCCESS != Error ) {
        Error2 = MemSubnetCleanup(pMScope);
        DhcpAssert(ERROR_SUCCESS == Error2);
        return Error;
    }

    return Error;
}

DWORD
DhcpModifyMScope(
    LPWSTR   pMScopeName,
    LPDHCP_MSCOPE_INFO pMScopeInfo
)
{
    DWORD                          Error, Error2;
    PM_SUBNET                      pMScope;
    PM_SUBNET                      pOldMScope = NULL;
    BOOL                           NewName = FALSE;

    DhcpAssert( pMScopeName && pMScopeInfo );

    Error = DhcpServerFindMScope(
        DhcpGetCurrentServer(),
        INVALID_MSCOPE_ID,
        pMScopeName,
        &pOldMScope
        );

    if ( ERROR_SUCCESS != Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;

    // never change the scopeid.
    if (pMScopeInfo->MScopeId != pOldMScope->MScopeId ) {
        if( !DhcpServerValidateNewMScopeId(DhcpGetCurrentServer(),pMScopeInfo->MScopeId) )
            return ERROR_DHCP_SUBNET_EXITS;
        Error = ChangeMScopeIdInDb(pOldMScope->MScopeId, pMScopeInfo->MScopeId);
        if (ERROR_SUCCESS != Error) {
            return Error;
        }
    }

    // if we want to change the name, make sure the new name is valid.
    if (wcscmp(pMScopeInfo->MScopeName, pMScopeName) ){
        if( !DhcpServerValidateNewMScopeName(DhcpGetCurrentServer(),pMScopeInfo->MScopeName) )
            return ERROR_DHCP_SUBNET_EXITS;
    }

    // modify the values.
    Error = MemMScopeModify(
                pOldMScope,
                pMScopeInfo->MScopeId, // never change the scope id.
                pMScopeInfo->MScopeState,
                pMScopeInfo->MScopeAddressPolicy,
                pMScopeInfo->TTL,
                pMScopeInfo->MScopeName,
                pMScopeInfo->MScopeComment,
                pMScopeInfo->LangTag,
                pMScopeInfo->ExpiryTime
                );

    if( ERROR_SUCCESS != Error ) return Error;

    return Error;
}

DWORD
R_DhcpSetMScopeInfo(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR   pMScopeName,
    LPDHCP_MSCOPE_INFO pMScopeInfo,
    BOOL    NewScope
    )
/*++

Routine Description:

    This function creates a new subnet structure in the server
    registry database. The server will start managing the new subnet
    and distribute IP address to clients from that subnet. However
    the administrator should call DhcpAddSubnetElement() to add an
    address range for distribution. The PrimaryHost field specified in
    the SubnetInfo should be same as the server pointed by
    ServerIpAddress.

Arguments:

    ServerIpAddress : IP address string of the DHCP server (Primary).

    SubnetAddress : IP Address of the new subnet.

    SubnetInfo : Pointer to the new subnet information structure.

Return Value:

    ERROR_DHCP_MSCOPE_EXISTS - if the subnet is already managed.

    ERROR_INVALID_PARAMETER - if the information structure contains an
        inconsistent fields.

    other WINDOWS errors.

--*/
{
    DWORD Error;
    WCHAR KeyBuffer[DHCP_IP_KEY_LEN];
    LPWSTR KeyName;
    HKEY KeyHandle = NULL;
    HKEY SubkeyHandle = NULL;
    DWORD KeyDisposition;
    EXCLUDED_IP_RANGES ExcludedIpRanges;
    DWORD MScopeId;
    
    DhcpPrint(( DEBUG_APIS, "R_DhcpCreateMScope is called, NewScope %d\n",NewScope));

    if (!pMScopeName || !pMScopeInfo ) {
        return ERROR_INVALID_PARAMETER;
    }
    if (wcslen(pMScopeName) >= MAX_PATH) {
        return (ERROR_DHCP_SCOPE_NAME_TOO_LONG);
    }
    if ( INVALID_MSCOPE_ID == pMScopeInfo->MScopeId ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpSetMScopeInfo" );
    if( NO_ERROR != Error ) return Error;
    
    if (NewScope) {

        Error = DhcpCreateMScope(
                    pMScopeName,
                    pMScopeInfo
                    );
    } else {
        Error = DhcpModifyMScope(
                    pMScopeName,
                    pMScopeInfo
                    );
    }

    MScopeId = pMScopeInfo->MScopeId;
    if( 0 == MScopeId ) MScopeId = INVALID_MSCOPE_ID;
    
    return DhcpEndWriteApiEx(
        "DhcpSetMScopeInfo", Error, FALSE, FALSE, 0,
        MScopeId, 0 );
}

DWORD
DhcpGetMScopeInfo(
    IN      LPWSTR                 pMScopeName,
    IN      LPDHCP_MSCOPE_INFO     pMScopeInfo
)
{
    DWORD                          Error;
    PM_SUBNET                      pMScope;

    Error = MemServerFindMScope(
        DhcpGetCurrentServer(),
        INVALID_MSCOPE_ID,
        pMScopeName,
        &pMScope
        );

    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;
    if( ERROR_SUCCESS != Error) return Error;

    DhcpAssert(NULL != pMScope);

    pMScopeInfo->MScopeName     = CloneLPWSTR(pMScope->Name);
    pMScopeInfo->MScopeId       = pMScope->MScopeId;
    pMScopeInfo->MScopeComment  = CloneLPWSTR(pMScope->Description);
    pMScopeInfo->MScopeState    = pMScope->State;
    pMScopeInfo->MScopeAddressPolicy = pMScope->Policy;
    pMScopeInfo->TTL            = pMScope->TTL;
    pMScopeInfo->ExpiryTime     = pMScope->ExpiryTime;
    pMScopeInfo->LangTag         = CloneLPWSTR(pMScope->LangTag);
    pMScopeInfo->MScopeFlags    = 0;
    pMScopeInfo->PrimaryHost.IpAddress = inet_addr("127.0.0.1");
    pMScopeInfo->PrimaryHost.NetBiosName = CloneLPWSTR(L"");
    pMScopeInfo->PrimaryHost.HostName = CloneLPWSTR(L"");

    return ERROR_SUCCESS;
}

DWORD
R_DhcpGetMScopeInfo(
    LPWSTR ServerIpAddress,
    LPWSTR   pMScopeName,
    LPDHCP_MSCOPE_INFO *pMScopeInfo
    )
/*++

Routine Description:

    This function retrieves the information of the subnet managed by
    the server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    SubnetInfo : Pointer to a location where the subnet information
        structure pointer is returned. Caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    Other WINDOWS errors.

--*/
{
    DWORD                          Error;
    LPDHCP_MSCOPE_INFO             LocalMScopeInfo;

    *pMScopeInfo = NULL;

    if (!pMScopeName) return ERROR_INVALID_PARAMETER;

    Error = DhcpBeginReadApi( "DhcpGetMScopeInfo" );
    if( ERROR_SUCCESS != Error ) return Error;

    LocalMScopeInfo = MIDL_user_allocate(sizeof(DHCP_MSCOPE_INFO));
    if( NULL == LocalMScopeInfo ) {
        DhcpEndReadApi( "DhcpGetMScopeInfo", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpGetMScopeInfo(pMScopeName, LocalMScopeInfo);

    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalMScopeInfo);
    } else {
        *pMScopeInfo = LocalMScopeInfo;
    }

    DhcpEndReadApi( "DhcpGetMScopeInfo", Error );
    return Error;
}

DWORD
DhcpEnumMScopes(
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN OUT  LPDHCP_MSCOPE_TABLE    EnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error, Error2;
    DWORD                          Index;
    DWORD                          Count;
    DWORD                          FilledSize;
    DWORD                          nMScopes;
    DWORD                          nToRead;
    PARRAY                         pMScopes;
    PM_SUBNET                      pMScope;
    ARRAY_LOCATION                 Loc;
    LPWSTR                        *pMScopeNames;

    EnumInfo->NumElements = 0;
    EnumInfo->pMScopeNames = NULL;

    pMScopes = & (DhcpGetCurrentServer()->MScopes);
    nMScopes = MemArraySize(pMScopes);
    if( 0 == nMScopes || nMScopes <= *ResumeHandle)
        return ERROR_NO_MORE_ITEMS;

    if( nMScopes - *ResumeHandle > PreferredMaximum )
        nToRead = PreferredMaximum;
    else nToRead = nMScopes - *ResumeHandle;

    pMScopeNames = MIDL_user_allocate(sizeof(LPWSTR)*nToRead);
    if( NULL == pMScopeNames ) return ERROR_NOT_ENOUGH_MEMORY;

    // zero out the memory.
    RtlZeroMemory( pMScopeNames,sizeof(LPWSTR)*nToRead);

    Error = MemArrayInitLoc(pMScopes, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);

    for(Index = 0; Index < *ResumeHandle; Index ++ ) {
        Error = MemArrayNextLoc(pMScopes, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    Count = Index;
    for( Index = 0; Index < nToRead; Index ++ ) {
        LPWSTR  pLocalScopeName;
        Error = MemArrayGetElement(pMScopes, &Loc, &pMScope);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != pMScope );

        pMScopeNames[Index] = MIDL_user_allocate( WSTRSIZE( pMScope->Name ) );
        if ( !pMScopeNames[Index] ) { Error = ERROR_NOT_ENOUGH_MEMORY;goto Cleanup;}
        wcscpy(pMScopeNames[Index], pMScope->Name );

        Error = MemArrayNextLoc(pMScopes, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || Count + Index + 1 == nMScopes ); // the Index was not yet incremented => +1
    }

    *nRead = Index;
    *nTotal = nMScopes - Count;
    *ResumeHandle = Count + Index;

    EnumInfo->NumElements = Index;
    EnumInfo->pMScopeNames = pMScopeNames;

    return ERROR_SUCCESS;

Cleanup:
    for ( Index = 0; Index < nToRead; Index++ ) {
        if ( pMScopeNames[Index] ) MIDL_user_free( pMScopeNames[Index] );
    }
    MIDL_user_free( pMScopeNames );
    return Error;
}

DWORD
R_DhcpEnumMScopes(
    DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_MSCOPE_TABLE *MScopeTable,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the available subnets.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    EnumInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up the buffer after use
        by calling DhcpRPCFreeMemory().

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD                          Error;
    LPDHCP_MSCOPE_TABLE            LocalMScopeTable;

    *MScopeTable = NULL;

    Error = DhcpBeginReadApi( "DhcpEnumMScopes" );    
    if( ERROR_SUCCESS != Error ) return Error;

    LocalMScopeTable = MIDL_user_allocate(sizeof(DHCP_MSCOPE_TABLE));
    if( NULL == LocalMScopeTable ) {
        DhcpEndReadApi( "DhcpEnumMScopes", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    Error = DhcpEnumMScopes(ResumeHandle, PreferredMaximum, LocalMScopeTable, ElementsRead, ElementsTotal);

    if( ERROR_SUCCESS != Error && ERROR_MORE_DATA != Error ) {
        MIDL_user_free(LocalMScopeTable);
    } else {
        *MScopeTable = LocalMScopeTable;
    }

    DhcpEndReadApi( "DhcpEnumMScopes", Error );
    return Error;
}

DWORD
R_DhcpAddMScopeElement(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR  pMScopeName,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 AddElementInfo
    )
/*++

Routine Description:

    This function adds an enumerable type of subnet elements to the
    specified subnet. The new elements that are added to the subnet will
    come into effect immediately.

    This function emulates the RPC interface used by NT 4.0 DHCP Server.
    It is provided for backward compatibilty with older version of the
    DHCP Administrator application.

    NOTE: It is not clear now how do we handle the new secondary hosts.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    AddElementInfo : Pointer to an element information structure
        containing new element that is added to the subnet.
        DhcpIPClusters element type is invalid to specify.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    Other WINDOWS errors.
--*/


{
    DWORD                          Error;
    PM_SUBNET                      pMScope;
    DWORD                          MscopeId;
    
    if (!pMScopeName || !AddElementInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( DhcpReservedIps == AddElementInfo->ElementType ) {
        return ERROR_INVALID_PARAMETER;
    }

    MscopeId = 0;
    Error = DhcpBeginWriteApi( "DhcpAddMScopeElement" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerFindMScope(
                DhcpGetCurrentServer(),
                INVALID_MSCOPE_ID,
                pMScopeName,
                &pMScope);

    if( ERROR_FILE_NOT_FOUND == Error ) {
        DhcpEndWriteApi( "DhcpAddMScopeElement", Error );
        return ERROR_DHCP_SUBNET_NOT_PRESENT;
    }
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpAddSubnetElement(pMScope, AddElementInfo, FALSE);
        MscopeId = pMScope->MScopeId;
        if( 0 == MscopeId ) MscopeId = INVALID_MSCOPE_ID;
    }

    return DhcpEndWriteApiEx(
        "DhcpAddMScopeElement", Error, FALSE, FALSE, 0, MscopeId,
        0 );
}




DWORD
R_DhcpEnumMScopeElements
(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR          pMScopeName,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the eumerable fields of a subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    EnumElementType : Type of the subnet element that are enumerated.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    EnumElementInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up the buffer after use
        by calling DhcpRPCFreeMemory().

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD                          Error;
    PM_SUBNET                      pMScope;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalElementEnumInfo;

    if (!pMScopeName) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( DhcpReservedIps == EnumElementType ) {
        return ERROR_INVALID_PARAMETER;
    }

    *EnumElementInfo = NULL;
    *ElementsRead = 0;
    *ElementsTotal = 0;

    Error = DhcpBeginReadApi( "DhcpEnumMScopeElements" );
    if( ERROR_SUCCESS != Error ) return Error;
    
    LocalElementEnumInfo = MIDL_user_allocate(sizeof(DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4));
    if( NULL == LocalElementEnumInfo ) {
        DhcpEndReadApi( "DhcpEnumMScopeElements", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    Error = MemServerFindMScope(
                DhcpGetCurrentServer(),
                INVALID_MSCOPE_ID,
                pMScopeName,
                &pMScope);

    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpEnumSubnetElements(
            pMScope,
            EnumElementType,
            ResumeHandle,
            PreferredMaximum,
            FALSE,
            LocalElementEnumInfo,
            ElementsRead,
            ElementsTotal
        );
    }

    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalElementEnumInfo);
    } else {
        *EnumElementInfo = LocalElementEnumInfo;
    }

    DhcpEndReadApi( "DhcpEnumMScopeElements", Error );
    return Error;

}


DWORD
R_DhcpRemoveMScopeElement(
    LPWSTR ServerIpAddress,
    LPWSTR          pMScopeName,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet element from managing. If the subnet
    element is in use (for example, if the IpRange is in use) then it
    returns error according to the ForceFlag specified.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    RemoveElementInfo : Pointer to an element information structure
        containing element that should be removed from the subnet.
        DhcpIPClusters element type is invalid to specify.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    ERROR_DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.
--*/
{
    DWORD                          Error;
    PM_SUBNET                      pMScope;
    DWORD                          MscopeId = 0;

    if (!pMScopeName) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( DhcpReservedIps == RemoveElementInfo->ElementType ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpRemoveMScopeElement" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerFindMScope(
                DhcpGetCurrentServer(),
                INVALID_MSCOPE_ID,
                pMScopeName,
                &pMScope);

    if( ERROR_SUCCESS != Error ) {
        DhcpEndWriteApi( "DhcpRemoveMScopeElement", Error );
        return Error;
    }

    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpRemoveSubnetElement(pMScope, RemoveElementInfo, FALSE, ForceFlag);
        MscopeId = pMScope->MScopeId;
        if( 0 == MscopeId ) MscopeId = INVALID_MSCOPE_ID;
    }

    return DhcpEndWriteApiEx(
        "DhcpRemoveMScopeElement", Error, FALSE, FALSE, 0, MscopeId,
        0 );
}

DWORD
MScopeInUse(
    LPWSTR  pMScopeName
    )
/*++

Routine Description:

    This routine determines if a givem mscope is in use or not.

Arguments:

    pMScopeName - the name of the mscope.

Return Value:

    DHCP_SUBNET_CANT_REMOVE - if the subnet is in use.

    Other registry errors.

--*/
{
    DWORD Error;
    DWORD Resumehandle = 0;
    LPDHCP_MCLIENT_INFO_ARRAY ClientInfo = NULL;
    DWORD ClientsRead;
    DWORD ClientsTotal;

    // enumurate clients that belong to the given subnet.
    //
    // We can specify big enough buffer to hold one or two clients
    // info, all we want to know is, is there atleast a client belong
    // to this subnet.
    Error = R_DhcpEnumMScopeClients(
                NULL,
                pMScopeName,
                &Resumehandle,
                1024,  // 1K buffer.
                &ClientInfo,
                &ClientsRead,
                &ClientsTotal );

    if( Error == ERROR_NO_MORE_ITEMS ) {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }
    if( (Error == ERROR_SUCCESS) || (Error == ERROR_MORE_DATA) ) {
        if( ClientsRead != 0 ) {
            Error = ERROR_DHCP_ELEMENT_CANT_REMOVE;
        }
        else {
            Error = ERROR_SUCCESS;
        }
    }
Cleanup:
    if( ClientInfo != NULL ) {
        _fgs__DHCP_MCLIENT_INFO_ARRAY( ClientInfo );
        MIDL_user_free( ClientInfo );
    }
    return( Error );
}

DWORD
DhcpDeleteMScope(
    IN      LPWSTR                 pMScopeName,
    IN      DWORD                  ForceFlag
)
{
    DWORD                          Error;
    PM_SUBNET                      MScope;

    // If force on, it should remove every record in the database for this subnet..
    if( ForceFlag != DhcpFullForce ) {
        Error = MScopeInUse(pMScopeName);
        if( ERROR_SUCCESS != Error ) return Error;
    }


    Error = MemServerDelMScope(
        DhcpGetCurrentServer(),
        INVALID_MSCOPE_ID,
        pMScopeName,
        &MScope
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;
    if( ERROR_SUCCESS != Error ) return Error;

    // delete the records from the database.
    Error = DhcpDeleteMScopeClients(MScope->MScopeId);
    // ignore the above error? 

    MemSubnetFree(MScope);                        // evaporate this subnet all all related stuff
    return NO_ERROR;
}

DWORD
R_DhcpDeleteMScope(
    LPWSTR ServerIpAddress,
    LPWSTR pMScopeName,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet from DHCP server management. If the
    subnet is in use (for example, if the IpRange is in use)
    then it returns error according to the ForceFlag specified.


Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ForceFlag : Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    ERROR_DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.

--*/
{
    DWORD                          Error;
    DWORD                          MscopeId = 0;
    PM_MSCOPE                      pMScope;
    
    Error = DhcpBeginWriteApi( "DhcpDeleteMScope" );
    if( ERROR_SUCCESS != Error ) return Error;


    Error = MemServerFindMScope(
                DhcpGetCurrentServer(),
                INVALID_MSCOPE_ID,
                pMScopeName,
                &pMScope);

    if( NO_ERROR == Error ) {
        MscopeId = pMScope->MScopeId;
        if( 0 == MscopeId ) MscopeId = INVALID_MSCOPE_ID;
    }
    
    Error = DhcpDeleteMScope(pMScopeName, ForceFlag);


    return DhcpEndWriteApiEx(
        "DhcpDeleteMScope", Error, FALSE, FALSE, 0, MscopeId,
        0 );
}

//
// Client APIs
//

//
// Client APIs
//


DWORD
R_DhcpCreateMClientInfo(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR          pMScopeName,
    LPDHCP_MCLIENT_INFO ClientInfo
    )
/*++

Routine Description:

    This function creates a client record in server's database. Also
    this marks the specified client IP address as unavailable (or
    distributed). This function returns error under the following cases :

    1. If the specified client IP address is not within the server
        management.

    2. If the specified client IP address is already unavailable.

    3. If the specified client record is already in the server's
        database.

    This function may be used to distribute IP addresses manually.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_AVAILABLE - if the specified client IP
        address is not available. May be in use by some other client.

    ERROR_DHCP_CLIENT_EXISTS - if the client record exists already in
        server's database.

    Other WINDOWS errors.
--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD
R_DhcpSetMClientInfo(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_MCLIENT_INFO ClientInfo
    )
/*++

Routine Description:

    This function sets client information record on the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the client information structure
        contains inconsistent data.

    Other WINDOWS errors.
--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD
R_DhcpGetMClientInfo(
    DHCP_SRV_HANDLE     ServerIpAddress,
    LPDHCP_SEARCH_INFO  SearchInfo,
    LPDHCP_MCLIENT_INFO  *ClientInfo
    )
/*++

Routine Description:

    This function retrieves client information record from the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SearchInfo : Pointer to a search information record which is the key
        for the client's record search.

    ClientInfo : Pointer to a location where the pointer to the client
        information structure is returned. This caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the search information invalid.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    LPDHCP_MCLIENT_INFO LocalClientInfo = NULL;
    DB_CTX  DbCtx;

    DhcpAssert( SearchInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    LOCK_DATABASE();

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    //
    // open appropriate record and set current position.
    //

    switch( SearchInfo->SearchType ) {
    case DhcpClientIpAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpGetMClientInfo is called, (%s).\n",
                        DhcpIpAddressToDottedString(
                            SearchInfo->SearchInfo.ClientIpAddress) ));
        Error = MadcapJetOpenKey(
                    &DbCtx,
                    MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
                    &SearchInfo->SearchInfo.ClientIpAddress,
                    sizeof( DHCP_IP_ADDRESS ) );

        break;
    case DhcpClientHardwareAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpGetMClientInfo is called "
                        "with HW address.\n"));
        Error = MadcapJetOpenKey(
                    &DbCtx,
                    MCAST_COL_NAME(MCAST_TBL_CLIENT_ID),
                    SearchInfo->SearchInfo.ClientHardwareAddress.Data,
                    SearchInfo->SearchInfo.ClientHardwareAddress.DataLength );

        break;
    default:
        DhcpPrint(( DEBUG_APIS, "DhcpGetMClientInfo is called "
                        "with invalid parameter.\n"));
        Error = ERROR_INVALID_PARAMETER;
        break;
    }


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = MadcapGetCurrentClientInfo( ClientInfo, NULL, NULL, 0 );

Cleanup:

    UNLOCK_DATABASE();

    if( Error != ERROR_SUCCESS ) {

        DhcpPrint(( DEBUG_APIS, "DhcpGetMClientInfo failed, %ld.\n",
                        Error ));
    }

    return( Error );
}


DWORD
R_DhcpDeleteMClientInfo(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_SEARCH_INFO ClientInfo
    )
/*++

Routine Description:

    This function deletes the specified client record. Also it frees up
    the client IP address for redistribution.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to a client information which is the key for
        the client's record search.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    DHCP_IP_ADDRESS FreeIpAddress;
    DWORD Size;
    LPBYTE ClientId = NULL;
    DWORD ClientIdLength = 0;
    BOOL TransactBegin = FALSE;
    BYTE bAllowedClientTypes;
    BYTE AddressState;
    BOOL AlreadyDeleted = FALSE;

    DhcpAssert( ClientInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }


    switch( ClientInfo->SearchType ) {
    case DhcpClientHardwareAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteMClientInfo is called "
                        "with client id.\n"));
        Error = MadcapRemoveClientEntryByClientId(
                    ClientInfo->SearchInfo.ClientHardwareAddress.Data,
                    ClientInfo->SearchInfo.ClientHardwareAddress.DataLength,
                    TRUE
                    );
        break;

    case DhcpClientIpAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteMClientInfo is called "
                    "with Ip Address (%s)\n",
                    DhcpIpAddressToDottedString(
                        ClientInfo->SearchInfo.ClientIpAddress
                        )
                    ));
        Error = MadcapRemoveClientEntryByIpAddress(
            ClientInfo->SearchInfo.ClientIpAddress,
            TRUE
            );
        break;
        
    default:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteMClientInfo is called "
                        "with invalid parameter.\n"));
        Error = ERROR_INVALID_PARAMETER;
        break;
    }

    return(Error);
}

DWORD
R_DhcpEnumMScopeClients(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR          pMScopeName,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_MCLIENT_INFO_ARRAY *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet. However it returns clients from all subnets if the subnet
    address specified is zero.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet. Client filter is disabled
        and clients from all subnet are returned if this subnet address
        is zero.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    JET_ERR JetError;
    DWORD i;
    JET_RECPOS JetRecordPosition;
    LPDHCP_MCLIENT_INFO_ARRAY LocalEnumInfo = NULL;
    DWORD ElementsCount;
    DB_CTX  DbCtx;
    PM_SUBNET   pMScope;

    DWORD RemainingRecords;
    DWORD ConsumedSize;
    DHCP_RESUME_HANDLE LocalResumeHandle = 0;

    if (!pMScopeName) {
        return ERROR_INVALID_PARAMETER;
    }

    DhcpAssert( *ClientInfo == NULL );

    Error = DhcpBeginReadApi( "DhcpEnumMScopeClients" );
    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    Error = DhcpServerFindMScope(
        DhcpGetCurrentServer(),
        INVALID_MSCOPE_ID,
        pMScopeName,
        &pMScope
        );

    if ( ERROR_SUCCESS != Error ) {
        DhcpEndReadApi( "DhcpEnumMScopeClients", Error );
        return ERROR_DHCP_SUBNET_NOT_PRESENT;
    }
    LOCK_DATABASE();


    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    // position the current record pointer to appropriate position.
    if( *ResumeHandle == 0 ) {
        // fresh enumeration, start from begining.
        Error = MadcapJetPrepareSearch(
                    &DbCtx,
                    MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
                    TRUE,   // Search from start
                    NULL,
                    0
                    );
    } else {
        // start from the record where we stopped last time.
        // we place the IpAddress of last record in the resume handle.

        DhcpAssert( sizeof(*ResumeHandle) == sizeof(DHCP_IP_ADDRESS) );
        Error = MadcapJetPrepareSearch(
                    &DbCtx,
                    MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
                    FALSE,
                    ResumeHandle,
                    sizeof(*ResumeHandle) );
     }

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    // now query remaining records in the database.
    Error = MadcapJetGetRecordPosition(
                    &DbCtx,
                    &JetRecordPosition,
                    sizeof(JET_RECPOS) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpPrint(( DEBUG_APIS, "JetGetRecordPosition returned, "
                    "entriesLT = %ld, "
                    "entriesInRange = %ld, "
                    "entriesTotal = %ld.\n",
                        JetRecordPosition.centriesLT,
                        JetRecordPosition.centriesInRange,
                        JetRecordPosition.centriesTotal ));

#if 0
    //
    // IpAddress is unique, we find exactly one record for this key.
    //

    DhcpAssert( JetRecordPosition.centriesInRange == 1 );

    RemainingRecords = JetRecordPosition.centriesTotal -
                            JetRecordPosition.centriesLT;

    DhcpAssert( (INT)RemainingRecords > 0 );

    if( RemainingRecords == 0 ) {
        Error = ERROR_NO_MORE_ITEMS;
        goto Cleanup;
    }

#else
    // ?? always return big value, until we know a reliable way to
    // determine the remaining records.
    RemainingRecords = 0x7FFFFFFF;
#endif

    // limit resource.
    if( PreferredMaximum > DHCP_ENUM_BUFFER_SIZE_LIMIT ) {
        PreferredMaximum = DHCP_ENUM_BUFFER_SIZE_LIMIT;
    }

    // if the PreferredMaximum buffer size is too small ..
    if( PreferredMaximum < DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN ) {
        PreferredMaximum = DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN;
    }

    // allocate enum array.
    // determine possible number of records that can be returned in
    // PreferredMaximum buffer;
    ElementsCount =
        ( PreferredMaximum - sizeof(DHCP_MCLIENT_INFO_ARRAY) ) /
            (sizeof(LPDHCP_MCLIENT_INFO) + sizeof(DHCP_MCLIENT_INFO));

    LocalEnumInfo = MIDL_user_allocate( sizeof(DHCP_MCLIENT_INFO_ARRAY) );

    if( LocalEnumInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalEnumInfo->NumElements = 0;
    LocalEnumInfo->Clients =
        MIDL_user_allocate(sizeof(LPDHCP_MCLIENT_INFO) * ElementsCount);
    if( LocalEnumInfo->Clients == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    ConsumedSize = sizeof(DHCP_MCLIENT_INFO_ARRAY);
    for( i = 0;
                // if we have filled up the return buffer.
            (LocalEnumInfo->NumElements < ElementsCount) &&
                // no more record in the database.
            (i < RemainingRecords);
                        i++ ) {

        LPDHCP_MCLIENT_INFO CurrentClientInfo;
        DWORD CurrentInfoSize;
        DWORD NewSize;
        BOOL ValidClient;

        //
        // read current record.
        //


        CurrentClientInfo = NULL;
        CurrentInfoSize = 0;
        ValidClient = FALSE;

        Error = MadcapGetCurrentClientInfo(
                    &CurrentClientInfo,
                    &CurrentInfoSize,
                    &ValidClient,
                    pMScope->MScopeId );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        if( ValidClient ) {

            //
            // client belongs to the requested subnet, so pack it.
            //

            NewSize =
                ConsumedSize +
                    CurrentInfoSize +
                        sizeof(LPDHCP_MCLIENT_INFO); // for pointer.

            if( NewSize < PreferredMaximum ) {

                //
                // we have space for the current record.
                //

                LocalEnumInfo->Clients[LocalEnumInfo->NumElements] =
                    CurrentClientInfo;
                LocalEnumInfo->NumElements++;

                ConsumedSize = NewSize;
            }
            else {

                //
                // we have filled the buffer.
                //

                Error = ERROR_MORE_DATA;

                if( 0 ) {
                    //
                    //  resume handle has to be the LAST ip address RETURNED.
                    //  this is the next one.. so don't do this..
                    //
                    LocalResumeHandle =
                        (DHCP_RESUME_HANDLE)CurrentClientInfo->ClientIpAddress;
                }
                
                //
                // free last record.
                //

                _fgs__DHCP_MCLIENT_INFO ( CurrentClientInfo );

                break;
            }

        }

        //
        // move to next record.
        //

        Error = MadcapJetNextRecord(&DbCtx);

        if( Error != ERROR_SUCCESS ) {

            if( Error == ERROR_NO_MORE_ITEMS ) {
                break;
            }

            goto Cleanup;
        }
    }

    *ClientInfo = LocalEnumInfo;
    *ClientsRead = LocalEnumInfo->NumElements;

    if( Error == ERROR_NO_MORE_ITEMS ) {

        *ClientsTotal = LocalEnumInfo->NumElements;
        *ResumeHandle = 0;
        Error = ERROR_SUCCESS;

#if 0
        //
        // when we have right RemainingRecords count.
        //

        DhcpAssert( RemainingRecords == LocalEnumInfo->NumElements );
#endif

    }
    else {

        *ClientsTotal = RemainingRecords;
        if( LocalResumeHandle != 0 ) {

            *ResumeHandle = LocalResumeHandle;
        }
        else {

            *ResumeHandle =
                LocalEnumInfo->Clients
                    [LocalEnumInfo->NumElements - 1]->ClientIpAddress;
        }

        Error = ERROR_MORE_DATA;
    }

Cleanup:

    UNLOCK_DATABASE();

    if( (Error != ERROR_SUCCESS) &&
        (Error != ERROR_MORE_DATA) ) {

        //
        // if we aren't succssful return locally allocated buffer.
        //

        if( LocalEnumInfo != NULL ) {
            _fgs__DHCP_MCLIENT_INFO_ARRAY( LocalEnumInfo );
            MIDL_user_free( LocalEnumInfo );
        }

    }

    DhcpEndReadApi( "DhcpEnumMScopeClients", Error );
    return(Error);
}


DWORD
R_DhcpScanMDatabase(
    LPWSTR ServerIpAddress,
    LPWSTR          pMScopeName,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function scans the database entries and registry bit-map for
    specified subnet scope and veryfies to see they match. If they
    don't match, this api will return the list of inconsistent entries.
    Optionally FixFlag can be used to fix the bad entries.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : Address of the subnet scope to verify.

    FixFlag : If this flag is TRUE, this api will fix the bad entries.

    ScanList : List of bad entries returned. The caller should free up
        this memory after it has been used.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;
    PM_SUBNET   pMScope;

    DhcpPrint(( DEBUG_APIS, "DhcpScanMDatabase is called. (%ws)\n",pMScopeName));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }


    DhcpAcquireWriteLock();

    Error = MemServerFindMScope(
                DhcpGetCurrentServer(),
                INVALID_MSCOPE_ID,
                pMScopeName,
                &pMScope);

    if( ERROR_FILE_NOT_FOUND == Error ) {
        Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        goto Cleanup;
    }

    if( ERROR_SUCCESS != Error) goto Cleanup;

    DhcpAssert(NULL != pMScope);

    Error = ScanDatabase(
        pMScope,
        FixFlag,
        ScanList
    );

Cleanup:

    DhcpReleaseWriteLock();
    DhcpScheduleRogueAuthCheck();


    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS, "DhcpScanMDatabase  failed, %ld.\n",
                        Error ));
    }

    return(Error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\mib.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mib.c

Abstract:

    This module contains the implementation of DHCP MIB API.

Author:

    Madan Appiah (madana)  14-Jan-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include    <dhcppch.h>
#include    <rpcapi.h>
#include    <mdhcpsrv.h>

DWORD
DhcpUpdateInUseCount(
    IN      PM_RANGE  InitialRange,	// the initial range
    IN      PM_RANGE  ThisSubRange,	// interval included in the initial range
    IN OUT  PDWORD    pAddrInUse)   // cumulative value for the InUse number of bits
{
    DWORD   Error;

    // parameters should be valid
    DhcpAssert( InitialRange != NULL &&
                ThisSubRange != NULL &&
                pAddrInUse != NULL);

    // ThisSubRange has to be a sub range of InitialRange
    DhcpAssert( InitialRange->Start <= ThisSubRange->Start && ThisSubRange->End <= InitialRange->End);
    // The InitialRange should have a valid BitMask
    DhcpAssert( InitialRange->BitMask != NULL);

    // update the pAddrInUse: this is all what we are working for!
    *pAddrInUse += MemBitGetSetBitsInRange(InitialRange->BitMask,
                                          ThisSubRange->Start - InitialRange->Start,
                                          ThisSubRange->End - InitialRange->Start);
    return ERROR_SUCCESS;
}

DWORD
DhcpGetFreeInRange(
    IN      PM_RANGE    InitialRange,
    IN      PARRAY      Exclusions,
    OUT     PDWORD      AddrFree,
    OUT     PDWORD      AddrInUse
)
{
    DWORD Error;
    DWORD BackupError;

    // variables for the Exclusion list
    ARRAY_LOCATION      LocExcl;
    PM_RANGE            ThisExclusion = NULL;
    DWORD               IpExcluded;
    DWORD               i;

    // variables for the Ranges list
    PM_RANGE            firstRange = NULL;
    ARRAY               Ranges;
    ARRAY_LOCATION      LocRanges;
    PM_RANGE            ThisRange = NULL;
    DWORD               IpRanges;
    DWORD               j;

	// Parameters should be valid
	DhcpAssert(InitialRange != NULL && Exclusions != NULL);

    // init the list of Ranges to scan
    firstRange = MemAlloc(sizeof(M_RANGE));
    if (firstRange == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    // use here MemRangeInit instead
    firstRange->Start = InitialRange->Start;
    firstRange->End = InitialRange->End;
    // insert firstRange element in the list
    Error = MemArrayInit(&Ranges);
    Error = MemArrayInitLoc(&Ranges, &LocRanges);

    Error = MemArrayInsElement(&Ranges, &LocRanges, firstRange);
    if (Error != ERROR_SUCCESS)
    {
        MemFree(firstRange);
        return Error;           // free firstRange here?
    }

    // scan the list of excluded IP addresses
    IpExcluded = MemArraySize(Exclusions);
    Error = MemArrayInitLoc(Exclusions, &LocExcl);
    for (i = 0; i < IpExcluded; i++)
    {
        // {ThisExclusion} = interval of IP addresses to exclude
        Error = MemArrayGetElement(Exclusions, &LocExcl, &ThisExclusion);
        DhcpAssert(ERROR_SUCCESS == Error && ThisExclusion);

        // walk through the list of Ranges to scan and remove exclusion from Ranges.
        IpRanges = MemArraySize(&Ranges);
        Error = MemArrayInitLoc(&Ranges, &LocRanges);
        for (j = 0; j < IpRanges; j++)
        {
            // [ThisRange] = interval of IP addresses to intersect with the exclusion
            Error = MemArrayGetElement(&Ranges, &LocRanges, &ThisRange);
            DhcpAssert(ERROR_SUCCESS == Error && ThisRange);

            // {}[] -> This Exclusion is done, go to the next one. (Ranges list is ordered!)
            if (ThisExclusion->End < ThisRange->Start)
                break;
            // {[}] or {[]}
            if (ThisExclusion->Start <= ThisRange->Start)
            {
                // {[}] -> adjust range and go to the next exclusion
                if (ThisExclusion->End < ThisRange->End)
                {
                    ThisRange->Start = ThisExclusion->End + 1;
                    break;
                }
                // {[]} -> remove this range and go to the next range
                else
                {
                    Error = MemArrayDelElement(&Ranges, &LocRanges, &ThisRange);
                    MemFree(ThisRange);
                    IpRanges--; j--; // reflect new size and rollback index one position
                    continue;        // next iteration on same element
                }
            }
            // [{}] or [{]}
            else if (ThisExclusion->Start <= ThisRange->End)
            {
                // [{]} -> adjust the range and go to the next range
                if (ThisExclusion->End >= ThisRange->End)
                {
                    ThisRange->End = ThisExclusion->Start - 1;
                }
                // [{}] -> break the range in two and go to the next exclusion
                else
                {
                    PM_RANGE newRange;

                    newRange = MemAlloc(sizeof(M_RANGE));
                    if (newRange == NULL)
                    {
                        Error = ERROR_NOT_ENOUGH_MEMORY;     // should the Ranges list be released?
                        goto cleanup;
                    }
                    // use here MemRangeInit instead
                    newRange->Start = ThisRange->Start;
                    newRange->End = ThisExclusion->Start - 1;
                    ThisRange->Start = ThisExclusion->End + 1;
                    // insert newRange element before ThisRange
                    Error = MemArrayInsElement(&Ranges, &LocRanges, newRange);
                    if (Error != ERROR_SUCCESS)
                        goto cleanup;                       // should the Ranges list be released?
                    break;
                }
            }
            // []{} -> nothing special to do, go to the next Range

            Error = MemArrayNextLoc(&Ranges, &LocRanges);
            DhcpAssert(ERROR_SUCCESS == Error || j == IpRanges-1);
        }

        Error = MemArrayNextLoc(Exclusions, &LocExcl);
        DhcpAssert(ERROR_SUCCESS == Error || i == IpExcluded-1);
    }

    // if this point is hit, everything went fine
    Error = ERROR_SUCCESS;

cleanup:
    // sum here all the free addresses from the Ranges list
    IpRanges = MemArraySize(&Ranges);
    MemArrayInitLoc(&Ranges, &LocRanges);

	// I have here the list of all "active" ranges (Ranges)
	// and also the Bitmask of the InitialRange so I have everything
	// to find out which addresses are really in use (outside an exclusion range)
	// I can do this in the same loop below as far as the Ranges list is ordered!

    *AddrFree = 0;
    *AddrInUse = 0;

	// InitialRange should have a valid BitMask at this point
    DhcpAssert(InitialRange->BitMask != NULL);

    for (j = 0; j < IpRanges; j++)
    {
        BackupError = MemArrayGetElement(&Ranges, &LocRanges, &ThisRange);
        DhcpAssert(ERROR_SUCCESS == BackupError && ThisRange);

        *AddrFree += ThisRange->End - ThisRange->Start + 1;
        DhcpUpdateInUseCount(InitialRange, ThisRange, AddrInUse);

        MemFree(ThisRange);

        BackupError = MemArrayNextLoc(&Ranges, &LocRanges);
        DhcpAssert(ERROR_SUCCESS == BackupError|| j == IpRanges-1);
    }
    // cleanup all the memory allocated in this function
    MemArrayCleanup(&Ranges);

    return Error;
}

DWORD
DhcpSubnetGetMibCount(
    IN      PM_SUBNET               Subnet,
    OUT     PDWORD                  AddrInUse,
    OUT     PDWORD                  AddrFree,
    OUT     PDWORD                  AddrPending
)
{
    PARRAY                         Ranges;
    ARRAY_LOCATION                 Loc2;
    PM_RANGE                       ThisRange = NULL;
    PARRAY                         Exclusions;
    PM_EXCL                        ThisExcl = NULL;
    DWORD                          IpRanges;
    DWORD                          Error = ERROR_SUCCESS;
    PLIST_ENTRY                    listEntry;
    LPPENDING_CONTEXT              PendingContext;
    DWORD                          j;

    *AddrInUse = 0;
    *AddrFree = 0;
    *AddrPending = 0;

    if (IS_DISABLED(Subnet->State)) return ERROR_SUCCESS;

    Ranges = &Subnet->Ranges;
    IpRanges = MemArraySize(Ranges);
    Exclusions = &Subnet->Exclusions;

    //
    // add all subnet ranges.
    //

    Error = MemArrayInitLoc(Ranges, &Loc2);

    for( j = 0; j < IpRanges; j++ ) {
        DWORD	FreeInRange;
		DWORD	InUseInRange;

        Error = MemArrayGetElement(Ranges, &Loc2, &ThisRange);
        DhcpAssert(ERROR_SUCCESS == Error && ThisRange);
        Error = MemArrayNextLoc(Ranges, &Loc2);
        DhcpAssert(ERROR_SUCCESS == Error || j == IpRanges-1);

        Error = DhcpGetFreeInRange(ThisRange, Exclusions, &FreeInRange, &InUseInRange);
        if (ERROR_SUCCESS != Error)
            return Error;

        *AddrFree  += FreeInRange;
        *AddrInUse += InUseInRange;
    }

    //
    // finally subtract InUse count.
    //

    *AddrFree -=  *AddrInUse;

    LOCK_INPROGRESS_LIST();
    *AddrPending = Subnet->fSubnet ? DhcpCountIPPendingCtxt(Subnet->Address, Subnet->Mask)
                                   : DhcpCountMCastPendingCtxt( Subnet->MScopeId );
    UNLOCK_INPROGRESS_LIST();

    return Error;
}

DWORD
QueryMibInfo(
    OUT     LPDHCP_MIB_INFO       *MibInfo
)
{
    DWORD                          Error;
    LPDHCP_MIB_INFO                LocalMibInfo = NULL;
    LPSCOPE_MIB_INFO               LocalScopeMibInfo = NULL;
    DHCP_KEY_QUERY_INFO            QueryInfo;
    DWORD                          SubnetCount;

    DWORD                          i;
    DWORD                          NumAddressesInUse;

    PARRAY                         Subnets;
    ARRAY_LOCATION                 Loc;
    PM_SUBNET                      ThisSubnet = NULL;

    DhcpAssert( *MibInfo == NULL );

    //
    // allocate counter buffer.
    //

    LocalMibInfo = MIDL_user_allocate( sizeof(DHCP_MIB_INFO) );

    if( LocalMibInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalMibInfo->Discovers = DhcpGlobalNumDiscovers;
    LocalMibInfo->Offers = DhcpGlobalNumOffers;
    LocalMibInfo->Requests = DhcpGlobalNumRequests;
    LocalMibInfo->Acks = DhcpGlobalNumAcks;
    LocalMibInfo->Naks = DhcpGlobalNumNaks;
    LocalMibInfo->Declines = DhcpGlobalNumDeclines;
    LocalMibInfo->Releases = DhcpGlobalNumReleases;
    LocalMibInfo->ServerStartTime = DhcpGlobalServerStartTime;
    LocalMibInfo->Scopes = 0;
    LocalMibInfo->ScopeInfo = NULL;


    //
    // query number of available subnets on this server.
    //

    SubnetCount = DhcpServerGetSubnetCount(DhcpGetCurrentServer());
    if( 0 == SubnetCount ) {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // allocate memory for the scope information.
    //

    LocalScopeMibInfo = MIDL_user_allocate(sizeof( SCOPE_MIB_INFO )*SubnetCount );

    if( LocalScopeMibInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Subnets = &(DhcpGetCurrentServer()->Subnets);
    Error = MemArrayInitLoc(Subnets, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);

    for ( i = 0; i < SubnetCount; i++) {          // process each subnet

        Error = MemArrayGetElement(Subnets, &Loc, (LPVOID *)&ThisSubnet);
        DhcpAssert(ERROR_SUCCESS == Error);
        Error = MemArrayNextLoc(Subnets, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || i == SubnetCount-1);

        LocalScopeMibInfo[i].Subnet = ThisSubnet->Address;
        Error = DhcpSubnetGetMibCount(
                    ThisSubnet,
                    &LocalScopeMibInfo[i].NumAddressesInuse,
                    &LocalScopeMibInfo[i].NumAddressesFree,
                    &LocalScopeMibInfo[i].NumPendingOffers
                    );

    }

    //
    // Finally set return buffer.
    //

    LocalMibInfo->Scopes = SubnetCount;
    LocalMibInfo->ScopeInfo = LocalScopeMibInfo;

    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // Free up Locally alloted memory.
        //

        if( LocalMibInfo != NULL ) {
            MIDL_user_free( LocalMibInfo );
        }

        if( LocalScopeMibInfo != NULL ) {
            MIDL_user_free( LocalScopeMibInfo );
        }
    } else {
        *MibInfo = LocalMibInfo;
    }

    return( Error );
}

DWORD
R_DhcpGetMibInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_MIB_INFO *MibInfo
    )
/*++

Routine Description:

    This function retrives all counter values of the DHCP server
    service.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    MibInfo : pointer a counter/table buffer. Caller should free up this
        buffer after usage.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;

    UNREFERENCED_PARAMETER( ServerIpAddress );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) return( Error );

    DhcpAcquireReadLock();
    Error = QueryMibInfo( MibInfo );
    DhcpReleaseReadLock();

    return Error;
}

DWORD
QueryMCastMibInfo(
    OUT     LPDHCP_MCAST_MIB_INFO       *MCastMibInfo
)
{
    DWORD                          Error;
    LPDHCP_MCAST_MIB_INFO          LocalMCastMibInfo = NULL;
    LPMSCOPE_MIB_INFO              LocalMScopeMibInfo = NULL;
    DHCP_KEY_QUERY_INFO            QueryInfo;
    DWORD                          IpRanges;
    DWORD                          MScopeCount;

    DWORD                          i, j;
    DWORD                          NumAddressesInUse;

    PARRAY                         MScopes;
    ARRAY_LOCATION                 Loc;
    PM_SUBNET                      ThisMScope = NULL;

    DhcpAssert( *MCastMibInfo == NULL );

    //
    // allocate counter buffer.
    //

    LocalMCastMibInfo = MIDL_user_allocate( sizeof(DHCP_MCAST_MIB_INFO) );

    if( LocalMCastMibInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalMCastMibInfo->Discovers = MadcapGlobalMibCounters.Discovers;
    LocalMCastMibInfo->Offers = MadcapGlobalMibCounters.Offers;
    LocalMCastMibInfo->Requests = MadcapGlobalMibCounters.Requests;
    LocalMCastMibInfo->Renews = MadcapGlobalMibCounters.Renews;
    LocalMCastMibInfo->Acks = MadcapGlobalMibCounters.Acks;
    LocalMCastMibInfo->Naks = MadcapGlobalMibCounters.Naks;
    LocalMCastMibInfo->Releases = MadcapGlobalMibCounters.Releases;
    LocalMCastMibInfo->Informs = MadcapGlobalMibCounters.Informs;
    LocalMCastMibInfo->ServerStartTime = DhcpGlobalServerStartTime;
    LocalMCastMibInfo->Scopes = 0;
    LocalMCastMibInfo->ScopeInfo = NULL;


    //
    // query number of available subnets on this server.
    //

    MScopeCount = DhcpServerGetMScopeCount(DhcpGetCurrentServer());
    if( 0 == MScopeCount ) {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // allocate memory for the scope information.
    //

    LocalMScopeMibInfo = MIDL_user_allocate(sizeof( MSCOPE_MIB_INFO )*MScopeCount );

    if( LocalMScopeMibInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    MScopes = &(DhcpGetCurrentServer()->MScopes);
    Error = MemArrayInitLoc(MScopes, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);

    for ( i = 0; i < MScopeCount; i++) {          // process each subnet

        Error = MemArrayGetElement(MScopes, &Loc, (LPVOID *)&ThisMScope);
        DhcpAssert(ERROR_SUCCESS == Error);
        Error = MemArrayNextLoc(MScopes, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || i == MScopeCount-1);

        LocalMScopeMibInfo[i].MScopeId = ThisMScope->MScopeId;
        LocalMScopeMibInfo[i].MScopeName =  MIDL_user_allocate( WSTRSIZE( ThisMScope->Name ) );
        if (LocalMScopeMibInfo[i].MScopeName) {
            wcscpy(LocalMScopeMibInfo[i].MScopeName,ThisMScope->Name);
        }
        Error = DhcpSubnetGetMibCount(
                    ThisMScope,
                    &LocalMScopeMibInfo[i].NumAddressesInuse,
                    &LocalMScopeMibInfo[i].NumAddressesFree,
                    &LocalMScopeMibInfo[i].NumPendingOffers
                    );

    }

    //
    // Finally set return buffer.
    //

    LocalMCastMibInfo->Scopes = MScopeCount;
    LocalMCastMibInfo->ScopeInfo = LocalMScopeMibInfo;

    Error = ERROR_SUCCESS;
Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // Free up Locally alloted memory.
        //

        if( LocalMCastMibInfo != NULL ) {
            MIDL_user_free( LocalMCastMibInfo );
        }

        if( LocalMScopeMibInfo != NULL ) {
            MIDL_user_free( LocalMScopeMibInfo );
        }
    } else {
        *MCastMibInfo = LocalMCastMibInfo;
    }

    return( Error );
}

DWORD
R_DhcpGetMCastMibInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_MCAST_MIB_INFO *MCastMibInfo
    )
/*++

Routine Description:

    This function retrives all counter values of the DHCP server
    service.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    MCastMibInfo : pointer a counter/table buffer. Caller should free up this
        buffer after usage.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;

    UNREFERENCED_PARAMETER( ServerIpAddress );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) return( Error );

    DhcpAcquireReadLock();
    Error = QueryMCastMibInfo( MCastMibInfo );
    DhcpReleaseReadLock();

    return Error;
}

BOOL
IsStringTroublesome(
    IN LPCWSTR Str
    )
{
    LPBYTE Buf;
    BOOL fResult;
    DWORD Size;
    
    //
    // A string is troublesome if it can't be converted to
    // OEM or ANSI code pages without any errors
    //

    Size = 1 + wcslen(Str)*3;
    Buf = DhcpAllocateMemory(Size);
    if( NULL == Buf ) return TRUE;

    fResult = FALSE;
    do {
        if( 0 == WideCharToMultiByte(
            CP_ACP, WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK |
            WC_DEFAULTCHAR, Str, -1, Buf, Size, NULL, &fResult
            ) ) {
            fResult = TRUE;
            break;
        }

        if( fResult ) break;

        if( 0 == WideCharToMultiByte(
            CP_OEMCP, WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK |
            WC_DEFAULTCHAR, Str, -1, Buf, Size, NULL, &fResult
            ) ) {
            fResult = TRUE;
            break;
        }
        
    } while ( 0 );

    DhcpFreeMemory( Buf );
    return fResult;
}

DWORD
R_DhcpServerSetConfig(
    LPWSTR  ServerIpAddress,
    DWORD   FieldsToSet,
    LPDHCP_SERVER_CONFIG_INFO ConfigInfo
    )
/*++

Routine Description:

    This function sets the DHCP server configuration information.
    Serveral of the configuration information will become effective
    immediately.  This function is provided to emulate the pre-NT4SP2
    RPC interface to allow interoperability with older versions of the
    DHCP Administrator application.

    The following parameters require restart of the service after this
    API is called successfully.

        Set_APIProtocolSupport
        Set_DatabaseName
        Set_DatabasePath
        Set_DatabaseLoggingFlag
        Set_RestoreFlag

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    FieldsToSet : Bit mask of the fields in the ConfigInfo structure to
        be set.

    ConfigInfo: Pointer to the info structure to be set.


Return Value:

    WINDOWS errors.
--*/

{
    DWORD                      dwResult;

    dwResult = R_DhcpServerSetConfigV4(
                        ServerIpAddress,
                        FieldsToSet,
                        (DHCP_SERVER_CONFIG_INFO_V4 *) ConfigInfo );

    return dwResult;
}


DWORD
R_DhcpServerSetConfigV4(
    LPWSTR ServerIpAddress,
    DWORD FieldsToSet,
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo
    )
/*++

Routine Description:

    This function sets the DHCP server configuration information.
    Serveral of the configuration information will become effective
    immediately.

    The following parameters require restart of the service after this
    API is called successfully.

        Set_APIProtocolSupport
        Set_DatabaseName
        Set_DatabasePath
        Set_DatabaseLoggingFlag
        Set_RestoreFlag

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    FieldsToSet : Bit mask of the fields in the ConfigInfo structure to
        be set.

    ConfigInfo: Pointer to the info structure to be set.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error, Tmp;
    BOOL BoolError;

    LPSTR OemDatabaseName = NULL;
    LPSTR OemDatabasePath = NULL;
    LPSTR OemBackupPath = NULL;
    LPSTR OemJetBackupPath = NULL;
    LPWSTR BackupConfigFileName = NULL;

    BOOL RecomputeTimer = FALSE;

    DhcpPrint(( DEBUG_APIS, "DhcpServerSetConfig is called.\n" ));
    DhcpAssert( ConfigInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if( FieldsToSet == 0 ) {
        goto Cleanup;
    }

    //
    // Set API Protocol parameter. Requires service restart.
    //

    if( FieldsToSet & Set_APIProtocolSupport ) {

        //
        // atleast a protocol should be enabled.
        //

        if( ConfigInfo->APIProtocolSupport == 0 ) {
            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_API_PROTOCOL_VALUE,
                    0,
                    DHCP_API_PROTOCOL_VALUE_TYPE,
                    (LPBYTE)&ConfigInfo->APIProtocolSupport,
                    sizeof(ConfigInfo->APIProtocolSupport)
                    );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        DhcpGlobalRpcProtocols = ConfigInfo->APIProtocolSupport;
    }

    if( FieldsToSet & Set_PingRetries ) {
        if ( ConfigInfo->dwPingRetries + 1 >= MIN_DETECT_CONFLICT_RETRIES + 1&&
             ConfigInfo->dwPingRetries <= MAX_DETECT_CONFLICT_RETRIES )
        {
            Error = RegSetValueEx(
                        DhcpGlobalRegParam,
                        DHCP_DETECT_CONFLICT_RETRIES_VALUE,
                        0,
                        DHCP_DETECT_CONFLICT_RETRIES_VALUE_TYPE,
                        (LPBYTE) &ConfigInfo->dwPingRetries,
                        sizeof( ConfigInfo->dwPingRetries ));

            if ( ERROR_SUCCESS != Error )
                goto Cleanup;

            DhcpGlobalDetectConflictRetries = ConfigInfo->dwPingRetries;
        }
        else
        {
            // invalid parameter
            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if ( FieldsToSet & Set_AuditLogState )
    {
        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_AUDIT_LOG_FLAG_VALUE,
                    0,
                    DHCP_AUDIT_LOG_FLAG_VALUE_TYPE,
                    (LPBYTE) &ConfigInfo->fAuditLog,
                    sizeof( ConfigInfo->fAuditLog )
                    );

        if ( ERROR_SUCCESS != Error )
            goto Cleanup;

        DhcpGlobalAuditLogFlag = ConfigInfo->fAuditLog;

    }



    if ( FieldsToSet & Set_BootFileTable )
    {

        if ( ConfigInfo->wszBootTableString )
        {

              Error = RegSetValueEx(
                            DhcpGlobalRegParam,
                            DHCP_BOOT_FILE_TABLE,
                            0,
                            DHCP_BOOT_FILE_TABLE_TYPE,
                            (LPBYTE) ConfigInfo->wszBootTableString,
                            ConfigInfo->cbBootTableString
                            );

              if ( ERROR_SUCCESS != Error )
                  goto Cleanup;
        }
        else
            RegDeleteValue( DhcpGlobalRegGlobalOptions,
                            DHCP_BOOT_FILE_TABLE );
    }

    //
    // Set Database name parameter. Requires service restart.
    //

    if( FieldsToSet & Set_DatabaseName ) {

        //
        // can't be a NULL string.
        //

        if( (ConfigInfo->DatabaseName == NULL) ||
            (wcslen(ConfigInfo->DatabaseName ) == 0) ) {

            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if( IsStringTroublesome( ConfigInfo->DatabaseName ) ) {
            Error = ERROR_INVALID_NAME;
            goto Cleanup;
        }
        
        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_DB_NAME_VALUE,
                    0,
                    DHCP_DB_NAME_VALUE_TYPE,
                    (LPBYTE)ConfigInfo->DatabaseName,
                    (wcslen(ConfigInfo->DatabaseName) + 1) *
                        sizeof(WCHAR) );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // update the global parameter.
        //

        OemDatabaseName = DhcpUnicodeToOem(
                            ConfigInfo->DatabaseName,
                            NULL ); // allocate memory.

        if( OemDatabaseName == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


    }

    //
    // Set Database path parameter. Requires service restart.
    //

    if( FieldsToSet & Set_DatabasePath ) {

        //
        // can't be a NULL string.
        //

        if( (ConfigInfo->DatabasePath == NULL) ||
            (wcslen(ConfigInfo->DatabasePath ) == 0) ) {

            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if( IsStringTroublesome( ConfigInfo->DatabasePath ) ) {
            Error = ERROR_INVALID_NAME;
            goto Cleanup;
        }
        
        //
        // create the backup directory if it is not there.
        //

        BoolError = CreateDirectoryPathW(
            ConfigInfo->DatabasePath,
            DhcpGlobalSecurityDescriptor
            );

        if( !BoolError ) {

            Error = GetLastError();
            if( Error != ERROR_ALREADY_EXISTS ) {
                goto Cleanup;
            }
            Error = ERROR_SUCCESS;
        }

        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_DB_PATH_VALUE,
                    0,
                    DHCP_DB_PATH_VALUE_TYPE,
                    (LPBYTE)ConfigInfo->DatabasePath,
                    (wcslen(ConfigInfo->DatabasePath) + 1) *
                        sizeof(WCHAR) );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // update the global parameter.
        //

        OemDatabasePath = DhcpUnicodeToOem(
                            ConfigInfo->DatabasePath,
                            NULL ); // allocate memory.

        if( OemDatabasePath == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

    }

    //
    // Set Backup path parameter.
    //

    if( FieldsToSet & Set_BackupPath ) {

        //
        // can't be a NULL string.
        //

        if( (ConfigInfo->BackupPath == NULL) ||
            (wcslen(ConfigInfo->BackupPath ) == 0) ) {

            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }


        if( IsStringTroublesome( ConfigInfo->BackupPath ) ) {
            Error = ERROR_INVALID_NAME;
            goto Cleanup;
        }
        //
        // create the backup directory if it is not there.
        //

        BoolError = CreateDirectoryPathW(
            ConfigInfo->BackupPath,
            DhcpGlobalSecurityDescriptor
            );

        if( !BoolError ) {

            Error = GetLastError();
            if( Error != ERROR_ALREADY_EXISTS ) {
                goto Cleanup;
            }
            Error = ERROR_SUCCESS;
        }

        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_BACKUP_PATH_VALUE,
                    0,
                    DHCP_BACKUP_PATH_VALUE_TYPE,
                    (LPBYTE)ConfigInfo->BackupPath,
                    (wcslen(ConfigInfo->BackupPath) + 1) *
                        sizeof(WCHAR) );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // update the global parameter, so that next backup will be done
        // using the new path.
        //

        OemBackupPath = DhcpUnicodeToOem(
                            ConfigInfo->BackupPath,
                            NULL ); // allocate memory.

        if( OemBackupPath == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


        OemJetBackupPath =
            DhcpAllocateMemory(
                (strlen(OemBackupPath) +
                 strlen(DHCP_KEY_CONNECT_ANSI) + 1 ));

        if( OemJetBackupPath == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        strcpy( OemJetBackupPath, OemBackupPath );
        strcat( OemJetBackupPath, DHCP_KEY_CONNECT_ANSI );

        //
        // create the JET backup directory if it is not there.
        //

        BoolError = CreateDirectoryPathOem(
            OemJetBackupPath,
            DhcpGlobalSecurityDescriptor
            );

        if( !BoolError ) {

            Error = GetLastError();
            if( Error != ERROR_ALREADY_EXISTS ) {
                goto Cleanup;
            }
            Error = ERROR_SUCCESS;
        }

        //
        // make backup configuration (full) file name.
        //

        BackupConfigFileName =
            DhcpAllocateMemory(
                (strlen(OemBackupPath) +
                    wcslen(DHCP_KEY_CONNECT) +
                    wcslen(DHCP_BACKUP_CONFIG_FILE_NAME) + 1) *
                        sizeof(WCHAR) );

        if( BackupConfigFileName == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // convert oem path to unicode path.
        //

        BackupConfigFileName =
            DhcpOemToUnicode(
                OemBackupPath,
                BackupConfigFileName );

        DhcpAssert( BackupConfigFileName != NULL );

        //
        // add file name.
        //

        wcscat( BackupConfigFileName, DHCP_KEY_CONNECT );
        wcscat( BackupConfigFileName, DHCP_BACKUP_CONFIG_FILE_NAME );


        //
        // now replace Global values.
        //

        LOCK_DATABASE();

        if( DhcpGlobalOemBackupPath != NULL ) {
            DhcpFreeMemory( DhcpGlobalOemBackupPath );
        }
        DhcpGlobalOemBackupPath = OemBackupPath;

        if( DhcpGlobalOemJetBackupPath != NULL ) {
            DhcpFreeMemory( DhcpGlobalOemJetBackupPath );
        }
        DhcpGlobalOemJetBackupPath = OemJetBackupPath;

        UNLOCK_DATABASE();

        LOCK_REGISTRY();

        if( DhcpGlobalBackupConfigFileName != NULL ) {
            DhcpFreeMemory( DhcpGlobalBackupConfigFileName );
        }
        DhcpGlobalBackupConfigFileName = BackupConfigFileName;

        UNLOCK_REGISTRY();

        OemBackupPath = NULL;
        OemJetBackupPath = NULL;
        BackupConfigFileName = NULL;
    }

    //
    // Set Backup Interval parameter.
    //

    if( FieldsToSet & Set_BackupInterval ) {

        if( ConfigInfo->BackupInterval == 0 ) {
            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        Tmp = ConfigInfo->BackupInterval * 60000;
        if( (Tmp/ 60000) != ConfigInfo->BackupInterval ) {
            Error = ERROR_ARITHMETIC_OVERFLOW;
            goto Cleanup;
        }

        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_BACKUP_INTERVAL_VALUE,
                    0,
                    DHCP_BACKUP_INTERVAL_VALUE_TYPE,
                    (LPBYTE)&ConfigInfo->BackupInterval,
                    sizeof(ConfigInfo->BackupInterval)
                    );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        DhcpGlobalBackupInterval = ConfigInfo->BackupInterval * 60000;
        RecomputeTimer = TRUE;
    }

    //
    // Set Backup Interval parameter. Requires service restart.
    //

    if( FieldsToSet & Set_DatabaseLoggingFlag ) {

        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_DB_LOGGING_FLAG_VALUE,
                    0,
                    DHCP_DB_LOGGING_FLAG_VALUE_TYPE,
                    (LPBYTE)&ConfigInfo->DatabaseLoggingFlag,
                    sizeof(ConfigInfo->DatabaseLoggingFlag)
                    );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpGlobalDatabaseLoggingFlag = ConfigInfo->DatabaseLoggingFlag;
    }

    //
    // Set Restore parameter. Requires service restart.
    //

    if( FieldsToSet & Set_RestoreFlag ) {

        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_RESTORE_FLAG_VALUE,
                    0,
                    DHCP_RESTORE_FLAG_VALUE_TYPE,
                    (LPBYTE)&ConfigInfo->RestoreFlag,
                    sizeof(ConfigInfo->RestoreFlag)
                    );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpGlobalRestoreFlag = ConfigInfo->RestoreFlag;
    }

    //
    // Set Database Cleanup Interval parameter.
    //

    if( FieldsToSet & Set_DatabaseCleanupInterval ) {

        if( ConfigInfo->DatabaseCleanupInterval == 0 ) {
            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        Tmp = ConfigInfo->DatabaseCleanupInterval * 60000;
        if( (Tmp/ 60000) != ConfigInfo->DatabaseCleanupInterval ) {
            Error = ERROR_ARITHMETIC_OVERFLOW;
            goto Cleanup;
        }
            
        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_DB_CLEANUP_INTERVAL_VALUE,
                    0,
                    DHCP_DB_CLEANUP_INTERVAL_VALUE_TYPE,
                    (LPBYTE)&ConfigInfo->DatabaseCleanupInterval,
                    sizeof(ConfigInfo->DatabaseCleanupInterval)
                    );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        DhcpGlobalCleanupInterval =
            ConfigInfo->DatabaseCleanupInterval * 60000;

        RecomputeTimer = TRUE;
    }

    //
    // Set debug flags.
    //

    if( FieldsToSet & Set_DebugFlag ) {

#if DBG
        DhcpGlobalDebugFlag = ConfigInfo->DebugFlag;

        if( DhcpGlobalDebugFlag & 0x40000000 ) {
            DbgBreakPoint();
        }

        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_DEBUG_FLAG_VALUE,
                    0,
                    DHCP_DEBUG_FLAG_VALUE_TYPE,
                    (LPBYTE)&ConfigInfo->DebugFlag,
                    sizeof(ConfigInfo->DebugFlag)
                    );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
#endif
    }

Cleanup:

    if( OemDatabaseName != NULL ) {
        DhcpFreeMemory( OemDatabaseName );
    }

    if( OemDatabasePath != NULL ) {
        DhcpFreeMemory( OemDatabasePath );
    }

    if( OemBackupPath != NULL ) {
        DhcpFreeMemory( OemBackupPath );
    }

    if( OemJetBackupPath != NULL ) {
        DhcpFreeMemory( OemJetBackupPath );
    }

    if( BackupConfigFileName != NULL ) {
        DhcpFreeMemory( BackupConfigFileName );
    }

    if( RecomputeTimer ) {
        BoolError = SetEvent( DhcpGlobalRecomputeTimerEvent );

        if( !BoolError ) {

            DWORD LocalError;

            LocalError = GetLastError();
            DhcpAssert( LocalError == ERROR_SUCCESS );

            if( Error == ERROR_SUCCESS ) {
                Error = LocalError;
            }
        }
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS,
                "DhcpServerSetConfig failed, %ld.\n",
                    Error ));
    }

    return( Error );
}

DWORD
R_DhcpServerGetConfig(
    LPWSTR ServerIpAddress,
    LPDHCP_SERVER_CONFIG_INFO *ConfigInfo
    )
/*++

Routine Description:

    This function retrieves the current configuration information of the
    server.  This function is provided to emulate the pre-NT4SP2
    RPC interface to allow interoperability with older versions of the
    DHCP Administrator application.


Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ConfigInfo: Pointer to a location where the pointer to the dhcp
        server config info structure is returned. Caller should free up
        this structure after use.

Return Value:

    WINDOWS errors.
--*/

{
    LPDHCP_SERVER_CONFIG_INFO_V4  pConfigInfoV4 = NULL;
    DWORD                         dwResult;

    if ( NULL == ConfigInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    dwResult = R_DhcpServerGetConfigV4(
                    ServerIpAddress,
                    &pConfigInfoV4
                    );

    if ( ERROR_SUCCESS == dwResult )
    {

        //
        // free unused fields
        //

        if ( pConfigInfoV4->wszBootTableString )
        {
            MIDL_user_free( pConfigInfoV4->wszBootTableString );
        }

        //
        // since the new fields are at the end of the struct, it
        // is safe to simply return the new struct.
        //

        *ConfigInfo = ( DHCP_SERVER_CONFIG_INFO *) pConfigInfoV4;
    }


    return dwResult;
}


DWORD
R_DhcpServerGetConfigV4(
    LPWSTR ServerIpAddress,
    LPDHCP_SERVER_CONFIG_INFO_V4 *ConfigInfo
    )
/*++

Routine Description:

    This function retrieves the current configuration information of the
    server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ConfigInfo: Pointer to a location where the pointer to the dhcp
        server config info structure is returned. Caller should free up
        this structure after use.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;
    LPDHCP_SERVER_CONFIG_INFO_V4 LocalConfigInfo;
    LPWSTR UnicodeString;
    WCHAR  *pwszBootFileTable;

    DhcpPrint(( DEBUG_APIS, "DhcpServerGetConfig is called.\n" ));
    DhcpAssert( *ConfigInfo == NULL );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    LocalConfigInfo = MIDL_user_allocate( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( LocalConfigInfo == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    LocalConfigInfo->APIProtocolSupport = DhcpGlobalRpcProtocols;

    UnicodeString = MIDL_user_allocate(
                        (strlen(DhcpGlobalOemDatabaseName) + 1)
                            * sizeof(WCHAR) );

    if( UnicodeString == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalConfigInfo->DatabaseName =
        DhcpOemToUnicode(
            DhcpGlobalOemDatabaseName,
            UnicodeString );

    UnicodeString = MIDL_user_allocate(
                        (strlen(DhcpGlobalOemDatabasePath) + 1)
                            * sizeof(WCHAR) );

    if( UnicodeString == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalConfigInfo->DatabasePath =
        DhcpOemToUnicode(
            DhcpGlobalOemDatabasePath,
            UnicodeString );

    UnicodeString = MIDL_user_allocate(
                        (strlen(DhcpGlobalOemBackupPath) + 1)
                            * sizeof(WCHAR) );

    if( UnicodeString == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalConfigInfo->BackupPath =
        DhcpOemToUnicode(
            DhcpGlobalOemBackupPath,
            UnicodeString );




    LocalConfigInfo->BackupInterval = DhcpGlobalBackupInterval / 60000;
    LocalConfigInfo->DatabaseLoggingFlag = DhcpGlobalDatabaseLoggingFlag;
    LocalConfigInfo->RestoreFlag = DhcpGlobalRestoreFlag;
    LocalConfigInfo->DatabaseCleanupInterval =
        DhcpGlobalCleanupInterval / 60000;

#if DBG
    LocalConfigInfo->DebugFlag = DhcpGlobalDebugFlag;
#endif

    LocalConfigInfo->fAuditLog = DhcpGlobalAuditLogFlag;
    LocalConfigInfo->dwPingRetries = DhcpGlobalDetectConflictRetries;

    Error = LoadBootFileTable( &LocalConfigInfo->wszBootTableString,
                               &LocalConfigInfo->cbBootTableString);

    if ( ERROR_SUCCESS != Error )
    {
        if ( ERROR_SERVER_INVALID_BOOT_FILE_TABLE == Error )
        {
            LocalConfigInfo->cbBootTableString  = 0;
            LocalConfigInfo->wszBootTableString = NULL;
        }
        else
            goto Cleanup;
    }

    *ConfigInfo = LocalConfigInfo;
    Error = ERROR_SUCCESS;
Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // freeup the locally allocated memories if we aren't
        // successful.
        //

        if( LocalConfigInfo != NULL ) {

            if( LocalConfigInfo->DatabaseName != NULL ) {
                MIDL_user_free( LocalConfigInfo->DatabaseName);
            }

            if( LocalConfigInfo->DatabasePath != NULL ) {
                MIDL_user_free( LocalConfigInfo->DatabasePath);
            }

            if( LocalConfigInfo->BackupPath != NULL ) {
                MIDL_user_free( LocalConfigInfo->BackupPath);
            }

            if ( LocalConfigInfo->wszBootTableString )
            {
                MIDL_user_free( LocalConfigInfo->wszBootTableString );
            }

            MIDL_user_free( LocalConfigInfo );
        }

        DhcpPrint(( DEBUG_APIS,
                "DhcpServerGetConfig failed, %ld.\n",
                    Error ));
    }

    return( Error );
}

DWORD
R_DhcpAuditLogSetParams(                          // set some auditlogging params
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,         // currently must be zero
    IN      LPWSTR                 AuditLogDir,   // directory to log files in..
    IN      DWORD                  DiskCheckInterval, // how often to check disk space?
    IN      DWORD                  MaxLogFilesSize,   // how big can all logs files be..
    IN      DWORD                  MinSpaceOnDisk     // mininum amt of free disk space
)
{
    DWORD                          Error;

    DhcpPrint(( DEBUG_APIS, "AuditLogSetParams is called.\n" ));

    if( 0 != Flags ) return ERROR_INVALID_PARAMETER;
    if( NULL == AuditLogDir ) return ERROR_INVALID_PARAMETER;

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if ( Error != ERROR_SUCCESS ) {
        return Error ;
    }

    return AuditLogSetParams(
        Flags,
        AuditLogDir,
        DiskCheckInterval,
        MaxLogFilesSize,
        MinSpaceOnDisk
    );
}

DWORD
R_DhcpAuditLogGetParams(                          // get the auditlogging params
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,         // must be zero
    OUT     LPWSTR                *AuditLogDir,   // same meaning as in AuditLogSetParams
    OUT     DWORD                 *DiskCheckInterval, // ditto
    OUT     DWORD                 *MaxLogFilesSize,   // ditto
    OUT     DWORD                 *MinSpaceOnDisk     // ditto
)
{
    DWORD                          Error;

    DhcpPrint(( DEBUG_APIS, "AuditLogSetParams is called.\n" ));

    if( 0 != Flags ) return ERROR_INVALID_PARAMETER;

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );
    if ( Error != ERROR_SUCCESS ) {
        return Error ;
    }

    return AuditLogGetParams(
        Flags,
        AuditLogDir,
        DiskCheckInterval,
        MaxLogFilesSize,
        MinSpaceOnDisk
    );
}


DWORD
R_DhcpGetVersion(
    LPWSTR ServerIpAddress,
    LPDWORD MajorVersion,
    LPDWORD MinorVersion
    )
/*++

Routine Description:

    This function returns the major and minor version numbers of the
    server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    MajorVersion : pointer to a location where the major version of the
        server is returned.

    MinorVersion : pointer to a location where the minor version of the
        server is returned.

Return Value:

    WINDOWS errors.

--*/
{

    *MajorVersion = DHCP_SERVER_MAJOR_VERSION_NUMBER;
    *MinorVersion = DHCP_SERVER_MINOR_VERSION_NUMBER;
    return( ERROR_SUCCESS );
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\network.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    network.c

Abstract:

    This module contains the network interface for the DHCP server.

Author:

    Madan Appiah (madana)  10-Sep-1993
    Manny Weiser (mannyw)  24-Aug-1992

Environment:

    User Mode - Win32

Revision History:

--*/

#include "dhcppch.h"
#include "ipinfo.h"
#include "llinfo.h"
#include "ntddtcp.h"
#include "tdiinfo.h"
#include <ws2tcpip.h>
#include <iptbl.h>
#include <endpoint.h>

DWORD UpdateArpCache(DWORD dwIfAddress, DWORD dwIPAddress,
                     LPBYTE lpbLLAddress, DWORD dwLLAddrlen, BOOL bAdd);
DWORD OpenTcp();
DWORD TCPSetInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                          LPVOID lpvOutBuffer, LPDWORD lpdwOutSize);
DWORD TCPQueryInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                            LPVOID lpvOutBuffer, LPDWORD lpdwOutSize);

DWORD MapAddressToInstance(DWORD dwAddress, LPDWORD lpdwInstance,
                           LPDWORD lpdwIndex);
//
// TCPIP values
//
DWORD                 DhcpGlobalAddrToInstCount;
AddressToInstanceMap *DhcpGlobalAddrToInstTable = NULL;
HANDLE                DhcpGlobalTCPHandle;


BOOL _stdcall
SetBoundSocketInFdSet(
    IN OUT PENDPOINT_ENTRY Entry,
    IN PVOID FdSetp
    )
/*++

Routine Description:
    This routine sets the socket in the FdSet if the current endpoint
    is bound.  It sets both teh dhcp socket as well as the madcap
    socket.

Arguments:
    Entry -- endpoint entry.
    FdSet -- FD Set.

Return Value:
    TRUE always.

--*/
{
    fd_set *FdSet = (fd_set *)FdSetp;
    PENDPOINT Ep = (PENDPOINT)Entry;

    if( IS_ENDPOINT_BOUND( Ep ) ) {
        FD_SET(Ep->Socket, FdSet);
        FD_SET(Ep->MadcapSocket, FdSet);
    }

    return TRUE;
}

typedef struct {
    IN OUT BOOL fFound;
    IN OUT BOOL fMadcap;
    IN fd_set *FdSet;
    OUT SOCKET Sock;
    OUT DHCP_IP_ADDRESS IpAddress;
    OUT DHCP_IP_ADDRESS Mask;
} SOCK_READY_CTXT;

BOOL _stdcall
FindReadyContext(
    IN OUT PENDPOINT_ENTRY Entry,
    IN PVOID ReadyCtxt
    )
{
    PENDPOINT Ep = (PENDPOINT)Entry;
    SOCK_READY_CTXT *Ctxt = (SOCK_READY_CTXT *)ReadyCtxt;

    if( !IS_ENDPOINT_BOUND(Ep) ) return TRUE;

    Ctxt->IpAddress = Entry->IpAddress;
    Ctxt->Mask = Entry->SubnetMask;
    if( FD_ISSET(Ep->Socket, Ctxt->FdSet) ) {
        Ctxt->Sock = Ep->Socket;
        Ctxt->fFound = TRUE;
        return FALSE;
    }

    if( FD_ISSET(Ep->MadcapSocket, Ctxt->FdSet ) ) {
        Ctxt->Sock = Ep->MadcapSocket;
        Ctxt->fFound = TRUE;
        Ctxt->fMadcap = TRUE;
        return FALSE;
    }

    return TRUE;
}

DWORD
DhcpWaitForMessage(
    DHCP_REQUEST_CONTEXT *pRequestContext
    )
/*++

Routine Description:

    This function waits for a request on the DHCP port on any of the
    configured interfaces.

Arguments:

    RequestContext - A pointer to a request context block for
        this request.

Return Value:

    The status of the operation.

--*/
{
    DWORD length;
    DWORD error;
    fd_set readSocketSet;
    DWORD i;
    int readySockets;
    struct timeval timeout = { 0x7FFFFFFF, 0 }; // forever.
    BOOLEAN MsgRcvd;
    SOCKET readySocket;
    SOCK_READY_CTXT ReadyCtxt;

#define ENDPOINT_EVENT       0
#define TERMINATE_EVENT             1

#define EVENT_COUNT                 2

    if ( DhcpGlobalNumberOfNetsActive == 0 ) {
        HANDLE  WaitHandle[ EVENT_COUNT ];
        DWORD   result;

        DhcpPrint((DEBUG_MISC,"No active nets(%lx)..waiting\n", DhcpGlobalNumberOfNetsActive ));
        // no endpoints ready. wait infinitely for one to become available.
        WaitHandle[ ENDPOINT_EVENT ] = DhcpGlobalEndpointReadyEvent;
        WaitHandle[ TERMINATE_EVENT ] = DhcpGlobalProcessTerminationEvent;

        result = WaitForMultipleObjects(
            /* num handles  */ EVENT_COUNT,
            /* handle array */ WaitHandle,
            /* wait for any */ FALSE,
            /* timeout msecs*/INFINITE
            );

        switch ( result ) {
        case TERMINATE_EVENT:
            return( ERROR_SEM_TIMEOUT );
        case ENDPOINT_EVENT:
            break;
        default:
            break;
        }

    }

    //
    // Setup the file descriptor set for select from all bound
    // endpoints.
    //

    FD_ZERO(&readSocketSet);
    WalkthroughEndpoints(
        &readSocketSet,
        SetBoundSocketInFdSet
        );

    readySockets = select( 0, &readSocketSet, NULL, NULL, &timeout );

    //
    // return to caller when the service is shutting down or select()
    // times out.
    //

    if( (readySockets == 0)  ||
        (WaitForSingleObject( DhcpGlobalProcessTerminationEvent, 0 ) == 0) ) {

        return( ERROR_SEM_TIMEOUT );
    }

    //
    // Time to play 20 question with winsock.  Which socket is ready?
    //
    ReadyCtxt.fFound = FALSE;
    ReadyCtxt.fMadcap = FALSE;
    ReadyCtxt.FdSet = &readSocketSet;

    WalkthroughEndpoints(
        &ReadyCtxt,
        FindReadyContext
        );

    if( FALSE == ReadyCtxt.fFound ) {
        //
        // this can happen when a socket becomes readable
        // coz of a close that just happened on it on
        // the pnp thread.
        //
        return ERROR_DEV_NOT_EXIST;
    }

    // Acquire the socket lock for this packet.
    DhcpPrint(( DEBUG_TRACE_CALLS, "Acquiring read lock for %p\n",
                ((( BYTE * ) pRequestContext ) - FIELD_OFFSET( PACKET, ReqContext ))));
    CountRwLockAcquireForRead( &SocketRwLock );
    (( LPPACKET ) pRequestContext->pPacket )->fSocketLocked = TRUE;

    pRequestContext->EndPointIpAddress = ReadyCtxt.IpAddress;
    pRequestContext->EndPointMask = ReadyCtxt.Mask;
    pRequestContext->EndPointSocket = ReadyCtxt.Sock;
    pRequestContext->fMadcap = ReadyCtxt.fMadcap;
    readySocket = ReadyCtxt.Sock;

    //
    // Read data from the net.  If multiple sockets have data, just
    // process the first available socket.
    //

    pRequestContext->SourceNameLength = sizeof( struct sockaddr );

    //
    // clean the receive buffer before receiving data in it.
    //

    RtlZeroMemory( pRequestContext->ReceiveBuffer, pRequestContext->ReceiveBufferSize );
    pRequestContext->ReceiveMessageSize = pRequestContext->ReceiveBufferSize;

    length = recvfrom(
                 readySocket,
                 (char *)pRequestContext->ReceiveBuffer,
                 pRequestContext->ReceiveMessageSize,
                 0,
                 &pRequestContext->SourceName,
                 (int *)&pRequestContext->SourceNameLength
                 );

    if ( length == SOCKET_ERROR ) {
        error = WSAGetLastError();
        DhcpPrint(( DEBUG_ERRORS, "Recv failed, error = %ld\n", error ));
        if( WSAENOTSOCK == error ) {
            // something changed underneath.  The socket just died?  let's hope that
            // the PnP thread will catch this soon.  Until then, we will have to sleep
            // maybe for a few milliseconds. Just yield this thread and see if that helps.
            Sleep(0);
        }
    } else {
        DhcpPrint(( DEBUG_MESSAGE, "Received message\n", 0 ));
        error = ERROR_SUCCESS;
    }

    pRequestContext->ReceiveMessageSize = length;
    return( error );
} // DhcpWaitForMessage()



DWORD
DhcpSendMessage(
    LPDHCP_REQUEST_CONTEXT DhcpRequestContext
    )
/*++

Routine Description:

    This function send a response to a DHCP client.

Arguments:

    RequestContext - A pointer to the DhcpRequestContext block for
        this request.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    struct sockaddr_in *source;
    LPDHCP_MESSAGE dhcpMessage;
    LPDHCP_MESSAGE dhcpReceivedMessage;
    WORD SendPort;
    DWORD MessageLength;
    BOOL  ArpCacheUpdated = FALSE;

    dhcpMessage = (LPDHCP_MESSAGE) DhcpRequestContext->SendBuffer;
    dhcpReceivedMessage = (LPDHCP_MESSAGE) DhcpRequestContext->ReceiveBuffer;

    //
    // if the request arrived from a relay agent, then send the reply
    // on server port otherwise on client port.
    //

    source = (struct sockaddr_in *)&DhcpRequestContext->SourceName;
    DhcpAssert( !DhcpRequestContext->fMadcap );
    if ( dhcpReceivedMessage->RelayAgentIpAddress != 0 ) {
        SendPort = (USHORT)DhcpGlobalServerPort ;
    } else {
        SendPort = (USHORT)DhcpGlobalClientPort;
    }
    source->sin_port = htons( SendPort );

    //
    // if this request arrived from relay agent then send the
    // response to the address the relay agent says.
    //


    if ( DHCP_INFORM_MESSAGE == DhcpRequestContext->MessageType ) {
        //
        // UNICAST inform ACKs to DHCP client unless we don't know the client address
        // or the BROADCAST bit is set..  (and even in those 2 cases, if we are
        // across a relay agent, unicast to relay agent on the SERVER port)
        //

        if( (ntohs(dhcpReceivedMessage->Reserved) & DHCP_BROADCAST ) ||
            0 == dhcpReceivedMessage->ClientIpAddress ) {

            if( 0 != dhcpReceivedMessage->RelayAgentIpAddress ) {
                source->sin_addr.s_addr = dhcpReceivedMessage->RelayAgentIpAddress;
		dhcpMessage->Reserved = 0; // Why this strangeness?
            } else {
                source->sin_addr.s_addr = (DWORD) -1;
                //
                // Values in this case should be set before, don't need to bother.
                //
            }

        } else {

            source->sin_addr.s_addr = dhcpReceivedMessage->ClientIpAddress;
            source->sin_port = htons((USHORT)DhcpGlobalClientPort);
        }

    } // if INFORM
    else if ( dhcpReceivedMessage->RelayAgentIpAddress != 0 ) {
        source->sin_addr.s_addr = dhcpReceivedMessage->RelayAgentIpAddress;
    } 
    else if ( TRUE == DhcpRequestContext->fNak ) {
	source->sin_addr.s_addr = INADDR_BROADCAST;
    }
    else {

        //
        // if the client didnt specify broadcast bit and if
        // we know the ipaddress of the client then send unicast.
        //

        //
        // But if IgnoreBroadcastFlag is set in the registry and
        // if the client requested to broadcast or the server is
        // nacking or If the client doesn't have an address yet,
        // respond via broadcast.
        // Note that IgnoreBroadcastFlag is off by default. But it
        // can be set as a workaround for the clients that are not
        // capable of receiving unicast
        // and they also dont set the broadcast bit.
        //

        if ( DhcpGlobalIgnoreBroadcastFlag ) {
            if( (ntohs(dhcpReceivedMessage->Reserved) & DHCP_BROADCAST) ||
                    (dhcpReceivedMessage->ClientIpAddress == 0) ||
                    (source->sin_addr.s_addr == 0) ) {

                source->sin_addr.s_addr = INADDR_BROADCAST;

                dhcpMessage->Reserved = 0;
                    // this flag should be zero in the local response.
            }

        }  // if global broadcast flag
        else {
	    
            if (( ntohs( dhcpReceivedMessage->Reserved ) & DHCP_BROADCAST ) ||
		( !dhcpMessage->YourIpAddress )) {
		
                source->sin_addr.s_addr = INADDR_BROADCAST;
		
                dhcpMessage->Reserved = 0;
		// this flag should be zero in the local response.
            } 
            else {
                DWORD   LocalError;
                if ( ( LocalError = UpdateArpCache(
						   DhcpRequestContext->EndPointIpAddress,
						   dhcpMessage->YourIpAddress,
						   dhcpReceivedMessage->HardwareAddress,
						   dhcpReceivedMessage->HardwareAddressLength,
						   TRUE)) == STATUS_SUCCESS ) {

                    source->sin_addr.s_addr = dhcpMessage->YourIpAddress;
                    ArpCacheUpdated = TRUE;
                    DhcpPrint((DEBUG_STOC, "Arp entry added on %s interface for %s client \n",
                        inet_ntoa( *(struct in_addr *)&DhcpRequestContext->EndPointIpAddress),
                        inet_ntoa( *(struct in_addr *)&dhcpMessage->YourIpAddress)) );

                } else {
                    DhcpPrint(( DEBUG_ERRORS, "Failed to add Arp entry on %s, for client %s, Error %lx\n",
                        inet_ntoa( *(struct in_addr *)&DhcpRequestContext->EndPointIpAddress),
                        inet_ntoa( *(struct in_addr *)&dhcpMessage->YourIpAddress), LocalError) );

                    source->sin_addr.s_addr = (DWORD)-1;
                }

            } // else

        } // else not global broadcast flag
    } // else 

#if DBG
    // This allows the DHCP Server to be up on the net while we are doing the rest.  So,
    // Whenever this guy is up, we still do not broadcast.. but just send to the test
    // machines address....
    if( (DWORD)(-1) != DhcpRegGetBcastAddress() )
        source->sin_addr.s_addr = DhcpRegGetBcastAddress();
#endif


    DhcpPrint(( DEBUG_STOC, "Sending response to = %s, XID = %lx.\n",
        inet_ntoa(source->sin_addr), dhcpMessage->TransactionID));


    //
    // send minimum DHCP_MIN_SEND_RECV_PK_SIZE (300) bytes, otherwise
    // bootp relay agents don't like the packet.
    //

    MessageLength = ((
        DhcpRequestContext->SendMessageSize >
        DHCP_MIN_SEND_RECV_PK_SIZE)
        ? DhcpRequestContext->SendMessageSize
        : DHCP_MIN_SEND_RECV_PK_SIZE
        )
        ;
    error = sendto(
        DhcpRequestContext->EndPointSocket,
        (char *)DhcpRequestContext->SendBuffer,
        MessageLength,
        0,
        &DhcpRequestContext->SourceName,
        DhcpRequestContext->SourceNameLength
        );

    if ( error == SOCKET_ERROR ) {
        error = WSAGetLastError();
        DhcpPrint(( DEBUG_ERRORS, "Send failed, error = %ld\n", error ));
    } else {
        error = ERROR_SUCCESS;
    }

    if ( ArpCacheUpdated ) {
        DWORD   LocalError;
        LocalError = UpdateArpCache(
            DhcpRequestContext->EndPointIpAddress,
            dhcpMessage->YourIpAddress,
            dhcpReceivedMessage->HardwareAddress,
            dhcpReceivedMessage->HardwareAddressLength,
            FALSE
            );
        if( LocalError != STATUS_SUCCESS ) {

            DhcpPrint((
                DEBUG_ERRORS, "Failed to delete Arp entry on %s"
                ", for client %s, Error %lx\n",
                inet_ntoa( *(struct in_addr *)
                           &DhcpRequestContext->EndPointIpAddress),
                inet_ntoa( *(struct in_addr *)
                           &dhcpMessage->YourIpAddress),
                LocalError
                ) );

        }

    }

    return( error );
}

DWORD
MadcapSendMessage(
    LPDHCP_REQUEST_CONTEXT DhcpRequestContext
    )
/*++

Routine Description:

    This function send a response to a DHCP client.

Arguments:

    RequestContext - A pointer to the DhcpRequestContext block for
        this request.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    struct sockaddr_in *source;
    LPMADCAP_MESSAGE dhcpMessage;
    LPMADCAP_MESSAGE dhcpReceivedMessage;

    dhcpMessage = (LPMADCAP_MESSAGE) DhcpRequestContext->SendBuffer;
    dhcpReceivedMessage = (LPMADCAP_MESSAGE) DhcpRequestContext->ReceiveBuffer;

    //
    // if the request arrived from a relay agent, then send the reply
    // on server port otherwise on client port.
    //

    source = (struct sockaddr_in *)&DhcpRequestContext->SourceName;



    DhcpPrint(( DEBUG_STOC, "Sending response to = %s, XID = %lx.\n",
        inet_ntoa(source->sin_addr), dhcpMessage->TransactionID));


    error = sendto(
        DhcpRequestContext->EndPointSocket,
        (char *)DhcpRequestContext->SendBuffer,
        DhcpRequestContext->SendMessageSize,
        0,
        &DhcpRequestContext->SourceName,
        DhcpRequestContext->SourceNameLength
        );

    if ( error == SOCKET_ERROR ) {
        error = WSAGetLastError();
        DhcpPrint(( DEBUG_ERRORS, "Send failed, error = %ld\n", error ));
    } else {
        error = ERROR_SUCCESS;
    }


    return( error );
}

//---------------------------------------------------------------------------
// Function:    UpdateArpCache
//
// Parameters:
//      DWORD   dwIfAddress     the interface to modify
//      DWORD   dwIPAddress     the IP address to add
//      LPBYTE  lpbLLAddress    the hardware address to add
//      DWORD   dwLLAddrlen     the length of the hardware address
//      BOOL    bAdd            if true, an entry is added. otherwise,
//                              an entry is deleted.
//
// This function adds or deletes an entry to the local ARP cache for
// the network interface whose IP address is dwIfAddress
//---------------------------------------------------------------------------
DWORD APIENTRY UpdateArpCache(DWORD dwIfAddress, DWORD dwIPAddress,
                     LPBYTE lpbLLAddress, DWORD dwLLAddrlen, BOOL bAdd) {
    UCHAR *lpContext;
    TDIObjectID *lpObject;
    IPNetToMediaEntry *lpinmeEntry;
    TCP_REQUEST_SET_INFORMATION_EX *lptrsiBuffer;

    DWORD dwErr, dwInstance, dwIndex, dwInSize, dwOutSize;


    dwErr = MapAddressToInstance(dwIfAddress, &dwInstance, &dwIndex);
    if (dwErr == (DWORD)-1) { return 1; }

    dwInSize = sizeof(TCP_REQUEST_SET_INFORMATION_EX) +
               sizeof(IPNetToMediaEntry) - 1;
    lptrsiBuffer = DhcpAllocateMemory(dwInSize);
    if (lptrsiBuffer == NULL) {
        return GetLastError();
    }

    lptrsiBuffer->BufferSize = sizeof(IPNetToMediaEntry);

    lpObject = &lptrsiBuffer->ID;
    lpObject->toi_id = AT_MIB_ADDRXLAT_ENTRY_ID;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_entity.tei_entity = AT_ENTITY;
    lpObject->toi_entity.tei_instance = dwInstance;

    lpinmeEntry = (IPNetToMediaEntry *)lptrsiBuffer->Buffer;
    lpinmeEntry->inme_index = dwIndex;
    lpinmeEntry->inme_addr = dwIPAddress;
    lpinmeEntry->inme_type = (bAdd ? INME_TYPE_DYNAMIC : INME_TYPE_INVALID);
    lpinmeEntry->inme_physaddrlen = dwLLAddrlen;
    CopyMemory(lpinmeEntry->inme_physaddr, lpbLLAddress, dwLLAddrlen);

    dwOutSize = 0;
    dwErr = TCPSetInformationEx((LPVOID)lptrsiBuffer, &dwInSize,
                                NULL, &dwOutSize);

    return dwErr;
}



//-----------------------------------------------------------------------
// Function:    GetAddressToInstanceTable
//
// Parameters:
//      none
//
// Builds the mappings from IP address to ARP Entity Instance; these
// mappings are needed for adding entries to ARP caches when messages
// are being relayed to clients.
// The algorithm is as follows:

//  get table of all TDI entities.
//  query each address translation entity in the table, and save
//      the instance numbers of all entities which support ARP.
//  query each ARP entity for its address translation info; this
//      info includes a field axi_index.
//  query the IP layer for the table of all IP address entries; these
//      entries include a field iae_index which corresponds to axi_index.
//  for each IP address, make an entry in our global AddressToInstanceMap
//      array, setting the index (by matching iae_index to axi_index),
//      the address (using iae_address), and the instance number
//      by using iae_index (==axi_index) to find the AddrXlatInfo for this
//      IP address, and then using the AddrXlatInfo to find the
//      ARP instance number.
//-----------------------------------------------------------------------
DWORD APIENTRY GetAddressToInstanceTable() {
    UCHAR *lpContext;
    IPSNMPInfo ipsiInfo;
    TDIObjectID *lpObject;

    DWORD dwErr, dwInSize, dwOutSize;
    TCP_REQUEST_QUERY_INFORMATION_EX trqiBuffer;

    DWORD dwAxiCount;
    AddrXlatInfo *lpAXITable, *lpaxi, *lpaxiend;

    DWORD dwAddrCount;
    IPAddrEntry *lpAddrTable, *lpaddr, *lpaddrend;

    DWORD dwEntityCount;
    TDIEntityID *lpEntityTable, *lpent, *lpentend;

    DWORD dwArpInstCount;
    DWORD *lpadwArpInstTable, *lpdwinst, *lpdwinstend;

    AddressToInstanceMap *lpAddrToInstTable, *lpatoi;

    lpadwArpInstTable =
        ( DWORD * ) DhcpAllocateMemory( sizeof( DWORD ) * MAX_TDI_ENTITIES );

    if ( NULL == lpadwArpInstTable ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //-----------------
    // get entity table
    //-----------------
    dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutSize = MAX_TDI_ENTITIES * sizeof(TDIEntityID);

    lpEntityTable = (TDIEntityID *)DhcpAllocateMemory(dwOutSize);
    if (lpEntityTable == NULL) {
        return GetLastError();
    }

    lpContext = (UCHAR *)trqiBuffer.Context;
    ZeroMemory(lpContext, CONTEXT_SIZE);

    lpObject = &trqiBuffer.ID;
    lpObject->toi_id = ENTITY_LIST_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_GENERIC;
    lpObject->toi_entity.tei_instance = 0;
    lpObject->toi_entity.tei_entity = GENERIC_ENTITY;

    dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                  lpEntityTable, &dwOutSize);
    if (dwErr != NO_ERROR || dwOutSize == 0) {
        DhcpFreeMemory(lpEntityTable);
        return dwErr;
    }

    dwEntityCount = dwOutSize / sizeof(TDIEntityID);


    //-------------------------------------------
    // copy instance numbers for all ARP entities
    //-------------------------------------------
    dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    lpContext = (UCHAR *)trqiBuffer.Context;
    lpObject = &trqiBuffer.ID;
    lpObject->toi_id = ENTITY_TYPE_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_GENERIC;
    lpObject->toi_entity.tei_entity = AT_ENTITY;

    lpdwinst = lpadwArpInstTable;
    lpentend = lpEntityTable + dwEntityCount;
    for (lpent = lpEntityTable; lpent < lpentend; lpent++) {
        if (lpent->tei_entity == AT_ENTITY) {
            DWORD dwEntityType;

            lpObject->toi_type = INFO_TYPE_PROVIDER;
            lpObject->toi_class = INFO_CLASS_GENERIC;
            lpObject->toi_entity.tei_entity = AT_ENTITY;
            lpObject->toi_entity.tei_instance = lpent->tei_instance;

            dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
            dwOutSize = sizeof(dwEntityType);
            ZeroMemory(lpContext, CONTEXT_SIZE);

            dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                          &dwEntityType, &dwOutSize);
            if (dwErr != NO_ERROR) {
                continue;
            }

            if (dwEntityType == AT_ARP) {
                *lpdwinst++ = lpent->tei_instance;
            }

        }
    }

    // done with the entity table now
    DhcpFreeMemory(lpEntityTable);

    dwArpInstCount = (DWORD)(lpdwinst - lpadwArpInstTable);
    if (dwArpInstCount == 0) {
        return 0;
    }


    //------------------------------------------------
    // make memory for the AT entities and then
    // query ARP entities for address translation info
    //------------------------------------------------
    lpAXITable = DhcpAllocateMemory(dwArpInstCount * sizeof(AddrXlatInfo));
    if (lpAXITable == NULL) {
        DhcpFreeMemory( lpadwArpInstTable );
        return GetLastError();
    }

    lpContext = (UCHAR *)trqiBuffer.Context;

    lpObject->toi_id = AT_MIB_ADDRXLAT_INFO_ID;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_entity.tei_entity = AT_ENTITY;

    lpaxi = lpAXITable;
    lpaxiend = lpAXITable + dwArpInstCount;
    lpdwinstend = lpadwArpInstTable + dwArpInstCount;
    for (lpdwinst = lpadwArpInstTable; lpdwinst < lpdwinstend; lpdwinst++) {
        lpObject->toi_entity.tei_instance = *lpdwinst;

        dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
        dwOutSize = sizeof(AddrXlatInfo);

        ZeroMemory(lpContext, CONTEXT_SIZE);

        dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                      lpaxi, &dwOutSize);

        // ignore errors, since each AddrXlatInfo must be in
        // a position in the AXI table that is parallel with
        // the postion of its instance number in the instance table
        if (dwErr != 0) {
            lpaxi->axi_index = (DWORD)-1;
        }
        ++lpaxi;
    }

    dwAxiCount = (DWORD)(lpaxi - lpAXITable);
    if (dwAxiCount == 0) {
        DhcpFreeMemory( lpadwArpInstTable );
        DhcpFreeMemory(lpAXITable);
        return 0;
    }


    //------------------------------
    // query IP for IP address table
    //------------------------------

    // first get address count
    dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutSize = sizeof(IPSNMPInfo);

    lpContext = (UCHAR *)trqiBuffer.Context;
    ZeroMemory(lpContext, CONTEXT_SIZE);

    lpObject->toi_id = IP_MIB_STATS_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;

    dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                  &ipsiInfo, &dwOutSize);
    if (dwErr != NO_ERROR || ipsiInfo.ipsi_numaddr == 0) {
        DhcpFreeMemory( lpadwArpInstTable );
        DhcpFreeMemory(lpAXITable);
        return dwErr;
    }

    dwAddrCount = ipsiInfo.ipsi_numaddr;

    // got address count, now get address table

    dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutSize = (dwAddrCount + 5) * sizeof(IPAddrEntry);

    lpAddrTable = DhcpAllocateMemory(dwOutSize);
    if (lpAddrTable == NULL) {
        DhcpFreeMemory( lpadwArpInstTable );
        DhcpFreeMemory(lpAXITable);
        return GetLastError();
    }

    lpContext = (UCHAR *)trqiBuffer.Context;
    ZeroMemory(lpContext, CONTEXT_SIZE);

    lpObject->toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;

    dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                  lpAddrTable, &dwOutSize);
    if (dwErr != NO_ERROR) {
        DhcpFreeMemory( lpadwArpInstTable );
        DhcpFreeMemory(lpAXITable);
        DhcpFreeMemory(lpAddrTable);
        return GetLastError();
    }


    // build table of AddressToInstanceMap structures
    // for each IP address, as follows:
    //      use IPAddrEntry.iae_index to find corresponding
    //          AddrXlatInfo.axi_index
    //      use the AddrXlatInfo found to find corresponding TDIEntityID
    //      use the TDIEntity found to set AddressToInstanceMap.dwInstance
    //--------------------------------------------------------------------
    lpAddrToInstTable = DhcpAllocateMemory(dwAddrCount * sizeof(AddressToInstanceMap));
    if (lpAddrToInstTable == NULL) {
        DhcpFreeMemory( lpadwArpInstTable );
        DhcpFreeMemory(lpAXITable);
        DhcpFreeMemory(lpAddrTable);
        return GetLastError();
    }

    lpatoi = lpAddrToInstTable;
    lpaxiend = lpAXITable + dwAxiCount;
    lpaddrend = lpAddrTable + dwAddrCount;
    for (lpaddr = lpAddrTable; lpaddr < lpaddrend; lpaddr++) {
        lpatoi->dwIndex = lpaddr->iae_index;
        lpatoi->dwIPAddress = lpaddr->iae_addr;

        // find the instance number
        lpdwinst = lpadwArpInstTable;
        for (lpaxi = lpAXITable; lpaxi < lpaxiend; lpaxi++) {
            if (lpaxi->axi_index != (DWORD)-1 &&
                lpaxi->axi_index == lpaddr->iae_index) {
                lpatoi->dwInstance = *lpdwinst;
                ++lpatoi;
                break;
            }
            ++lpdwinst;
        }
    }

    // done with AXI table and IP address table
    DhcpFreeMemory( lpadwArpInstTable );
    DhcpFreeMemory(lpAXITable);
    DhcpFreeMemory(lpAddrTable);

    if (DhcpGlobalAddrToInstTable != NULL) {
        DhcpFreeMemory(DhcpGlobalAddrToInstTable);
    }

    DhcpGlobalAddrToInstCount = (DWORD)(lpatoi - lpAddrToInstTable);
    DhcpGlobalAddrToInstTable = lpAddrToInstTable;

    return 0;
}



//------------------------------------------------------------------
// Function:    MapAddressToInstance
//
// Parameters:
//      DWORD   dwAddress       the address to map
//
//------------------------------------------------------------------
DWORD MapAddressToInstance(DWORD dwAddress, LPDWORD lpdwInstance,
                           LPDWORD lpdwIndex) {
    DWORD dwErr;
    AddressToInstanceMap *lpptr, *lpend;

    dwErr = (DWORD)-1;

    if ( DhcpGlobalAddrToInstTable == NULL ) {
        return dwErr;
    }
    lpend = DhcpGlobalAddrToInstTable + DhcpGlobalAddrToInstCount;
    for (lpptr = DhcpGlobalAddrToInstTable; lpptr < lpend; lpptr++) {
        if (dwAddress == lpptr->dwIPAddress) {
            *lpdwIndex = lpptr->dwIndex;
            *lpdwInstance = lpptr->dwInstance;
            dwErr = 0;
            break;
        }
    }

    return dwErr;
}



//------------------------------------------------------------------
// Function:    OpenTcp
//
// Parameters:
//      none.
//
// Opens the handle to the Tcpip driver.
//------------------------------------------------------------------
DWORD OpenTcp() {
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;

    // Open the ip stack for setting routes and parps later.
    //
    // Open a Handle to the TCP driver.
    //
    RtlInitUnicodeString(&nameString, DD_TCP_DEVICE_NAME);

    InitializeObjectAttributes(&objectAttributes, &nameString,
                                           OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateFile(
        &DhcpGlobalTCPHandle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &objectAttributes, &ioStatusBlock, NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,
        FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0
        );

    return (status == STATUS_SUCCESS ? 0 : ERROR_OPEN_FAILED);

}



//---------------------------------------------------------------------
// Function:        TCPQueryInformationEx
//
// Parameters:
//      TDIObjectID *ID            The TDI Object ID to query
//      void        *Buffer        buffer to contain the query results
//      LPDWORD     *BufferSize    pointer to the size of the buffer
//                                 filled in with the amount of data.
//      UCHAR       *Context       context value for the query. should
//                                 be zeroed for a new query. It will be
//                                 filled with context information for
//                                 linked enumeration queries.
//
// Returns:
//      An NTSTATUS value.
//
//  This routine provides the interface to the TDI QueryInformationEx
//      facility of the TCP/IP stack on NT.
//---------------------------------------------------------------------
DWORD TCPQueryInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                            LPVOID lpvOutBuffer, LPDWORD lpdwOutSize) {
    NTSTATUS status;
    IO_STATUS_BLOCK isbStatusBlock;

    if (DhcpGlobalTCPHandle == NULL) {
        OpenTcp();
    }

    status = NtDeviceIoControlFile(
        DhcpGlobalTCPHandle, // Driver handle
        NULL,                // Event
        NULL,                // APC Routine
        NULL,                // APC context
        &isbStatusBlock,     // Status block
        IOCTL_TCP_QUERY_INFORMATION_EX,  // Control
        lpvInBuffer,         // Input buffer
        *lpdwInSize,         // Input buffer size
        lpvOutBuffer,        // Output buffer
        *lpdwOutSize
        );       // Output buffer size

    if (status == STATUS_PENDING) {
            status = NtWaitForSingleObject(DhcpGlobalTCPHandle, TRUE, NULL);
        status = isbStatusBlock.Status;
    }

    if (status != STATUS_SUCCESS) {
        *lpdwOutSize = 0;
    }
    else {
        *lpdwOutSize = (ULONG)isbStatusBlock.Information;
    }

    return status;
}




//---------------------------------------------------------------------------
// Function:        TCPSetInformationEx
//
// Parameters:
//
//      TDIObjectID *ID         the TDI Object ID to set
//      void      *lpvBuffer    data buffer containing the information
//                              to be set
//      DWORD     dwBufferSize  the size of the data buffer.
//
//  This routine provides the interface to the TDI SetInformationEx
//  facility of the TCP/IP stack on NT.
//---------------------------------------------------------------------------
DWORD TCPSetInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                          LPVOID lpvOutBuffer, LPDWORD lpdwOutSize) {
    NTSTATUS status;
    IO_STATUS_BLOCK isbStatusBlock;

    if (DhcpGlobalTCPHandle == NULL) {
        OpenTcp();
    }

    status = NtDeviceIoControlFile(
        DhcpGlobalTCPHandle, // Driver handle
        NULL,                // Event
        NULL,                // APC Routine
        NULL,                // APC context
        &isbStatusBlock,     // Status block
        IOCTL_TCP_SET_INFORMATION_EX,    // Control
        lpvInBuffer,         // Input buffer
        *lpdwInSize,         // Input buffer size
        lpvOutBuffer,        // Output buffer
        *lpdwOutSize
        );       // Output buffer size
    
    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(DhcpGlobalTCPHandle, TRUE, NULL);
        status = isbStatusBlock.Status;
    }

    if (status != STATUS_SUCCESS) {
        *lpdwOutSize = 0;
    }
    else {
        *lpdwOutSize = (ULONG)isbStatusBlock.Information;
    }

    return status;
}


DHCP_IP_ADDRESS
DhcpResolveName(
    CHAR *szHostName
    )
/*++

Routine Description:
    Resolves the specified host name to an IP address
    .
Arguments:

    szHostName  - host name
    .

Return Value:

    Success - the IP address for szHostName.
    Failure - 0.

    .

--*/

{
    DHCP_IP_ADDRESS IpAddress = 0;

    IpAddress = inet_addr( szHostName );

    if ( INADDR_NONE == IpAddress )
    {
        HOSTENT *ph = gethostbyname( szHostName );
        if ( ph )
        {
            IpAddress = *((DHCP_IP_ADDRESS*) ph->h_addr_list[0]);
        }
    }

    return IpAddress;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\oldstub.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    oldstub.c

Abstract:

    This file is the old RPC stub code.

Author:

    Madan Appiah  (madana)  25-APR-1994

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#include "dhcppch.h"

#define WSTRSIZE( wsz ) (( wcslen( wsz ) + 1 ) * sizeof( WCHAR ))


/* routine that frees graph for struct _DHCP_BINARY_DATA */
void _fgs__DHCP_BINARY_DATA (DHCP_BINARY_DATA  * _source)
  {
  if (_source->Data !=0)
    {
    MIDL_user_free((void  *)(_source->Data));
    }
  }
/* routine that frees graph for struct _DHCP_HOST_INFO */
void _fgs__DHCP_HOST_INFO (DHCP_HOST_INFO  * _source)
  {
  if (_source->NetBiosName !=0)
    {
    MIDL_user_free((void  *)(_source->NetBiosName));
    }
  if (_source->HostName !=0)
    {
    MIDL_user_free((void  *)(_source->HostName));
    }
  }


/* routine that frees graph for struct _DHCP_SUBNET_INFO */
void _fgs__DHCP_SUBNET_INFO (DHCP_SUBNET_INFO  * _source)
  {
  if (_source->SubnetName !=0)
    {
    MIDL_user_free((void  *)(_source->SubnetName));
    }
  if (_source->SubnetComment !=0)
    {
    MIDL_user_free((void  *)(_source->SubnetComment));
    }
  _fgs__DHCP_HOST_INFO ((DHCP_HOST_INFO *)&_source->PrimaryHost);
  }

/* routine that frees graph for struct _DHCP_IP_ARRAY */
void _fgs__DHCP_IP_ARRAY (DHCP_IP_ARRAY  * _source)
  {
  if (_source->Elements !=0)
    {
    MIDL_user_free((void  *)(_source->Elements));
    }
  }

/* routine that frees graph for struct _DHCP_IP_RESERVATION */
void _fgs__DHCP_IP_RESERVATION (DHCP_IP_RESERVATION_V4  * _source)
  {
  if (_source->ReservedForClient !=0)
    {
    _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)_source->ReservedForClient);
    MIDL_user_free((void  *)(_source->ReservedForClient));
    }

  }
/* routine that frees graph for union _DHCP_SUBNET_ELEMENT_UNION */
void _fgu__DHCP_SUBNET_ELEMENT_UNION (union _DHCP_SUBNET_ELEMENT_UNION_V4 * _source, DHCP_SUBNET_ELEMENT_TYPE _branch)
  {
  switch (_branch)
    {
    case DhcpIpRanges :
    case DhcpIpRangesDhcpOnly:
    case DhcpIpRangesBootpOnly:
    case DhcpIpRangesDhcpBootp:
      {
      if (_source->IpRange !=0)
        {
        MIDL_user_free((void  *)(_source->IpRange));
        }
      break;
      }
    case DhcpSecondaryHosts :
      {
      if (_source->SecondaryHost !=0)
        {
        _fgs__DHCP_HOST_INFO ((DHCP_HOST_INFO *)_source->SecondaryHost);
        MIDL_user_free((void  *)(_source->SecondaryHost));
        }
      break;
      }
    case DhcpReservedIps :
      {
      if (_source->ReservedIp !=0)
        {
        _fgs__DHCP_IP_RESERVATION ((DHCP_IP_RESERVATION_V4 *)_source->ReservedIp);
        MIDL_user_free((void  *)(_source->ReservedIp));
        }
      break;
      }
    case DhcpExcludedIpRanges :
      {
      if (_source->ExcludeIpRange !=0)
        {
        MIDL_user_free((void  *)(_source->ExcludeIpRange));
        }
      break;
      }
    case DhcpIpUsedClusters :
      {
      if (_source->IpUsedCluster !=0)
        {
        MIDL_user_free((void  *)(_source->IpUsedCluster));
        }
      break;
      }
    default :
      {
      break;
      }
    }
  }

/* routine that frees graph for struct _DHCP_SUBNET_ELEMENT_DATA */
void _fgs__DHCP_SUBNET_ELEMENT_DATA (DHCP_SUBNET_ELEMENT_DATA_V4  * _source)
  {
  _fgu__DHCP_SUBNET_ELEMENT_UNION ( (union _DHCP_SUBNET_ELEMENT_UNION_V4 *)&_source->Element, _source->ElementType);
  }
/* routine that frees graph for struct _DHCP_SUBNET_ELEMENT_INFO_ARRAY */
void _fgs__DHCP_SUBNET_ELEMENT_INFO_ARRAY (DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4  * _source)
  {
  if (_source->Elements !=0)
    {
      {
      unsigned long _sym23;
      for (_sym23 = 0; _sym23 < (unsigned long )(0 + _source->NumElements); _sym23++)
        {
        _fgs__DHCP_SUBNET_ELEMENT_DATA ((DHCP_SUBNET_ELEMENT_DATA_V4 *)&_source->Elements[_sym23]);
        }
      }
    MIDL_user_free((void  *)(_source->Elements));
    }
  }
/* routine that frees graph for union _DHCP_OPTION_ELEMENT_UNION */
void _fgu__DHCP_OPTION_ELEMENT_UNION (union _DHCP_OPTION_ELEMENT_UNION * _source, DHCP_OPTION_DATA_TYPE _branch)
  {
  switch (_branch)
    {
    case DhcpByteOption :
      {
      break;
      }
    case DhcpWordOption :
      {
      break;
      }
    case DhcpDWordOption :
      {
      break;
      }
    case DhcpDWordDWordOption :
      {
      break;
      }
    case DhcpIpAddressOption :
      {
      break;
      }
    case DhcpStringDataOption :
      {
      if (_source->StringDataOption !=0)
        {
        MIDL_user_free((void  *)(_source->StringDataOption));
        }
      break;
      }
    case DhcpBinaryDataOption :
      {
      _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)&_source->BinaryDataOption);
      break;
      }
    case DhcpEncapsulatedDataOption :
      {
      _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)&_source->EncapsulatedDataOption);
      break;
      }
    default :
      {
      break;
      }
    }
  }
/* routine that frees graph for struct _DHCP_OPTION_DATA_ELEMENT */
void _fgs__DHCP_OPTION_DATA_ELEMENT (DHCP_OPTION_DATA_ELEMENT  * _source)
  {
  _fgu__DHCP_OPTION_ELEMENT_UNION ( (union _DHCP_OPTION_ELEMENT_UNION *)&_source->Element, _source->OptionType);
  }
/* routine that frees graph for struct _DHCP_OPTION_DATA */
void _fgs__DHCP_OPTION_DATA (DHCP_OPTION_DATA  * _source)
  {
  if (_source->Elements !=0)
    {
      {
      unsigned long _sym31;
      for (_sym31 = 0; _sym31 < (unsigned long )(0 + _source->NumElements); _sym31++)
        {
        _fgs__DHCP_OPTION_DATA_ELEMENT ((DHCP_OPTION_DATA_ELEMENT *)&_source->Elements[_sym31]);
        }
      }
    MIDL_user_free((void  *)(_source->Elements));
    }
  }
/* routine that frees graph for struct _DHCP_OPTION */
void _fgs__DHCP_OPTION (DHCP_OPTION  * _source)
  {
  if (_source->OptionName !=0)
    {
    MIDL_user_free((void  *)(_source->OptionName));
    }
  if (_source->OptionComment !=0)
    {
    MIDL_user_free((void  *)(_source->OptionComment));
    }
  _fgs__DHCP_OPTION_DATA ((DHCP_OPTION_DATA *)&_source->DefaultValue);
  }
/* routine that frees graph for struct _DHCP_OPTION_VALUE */
void _fgs__DHCP_OPTION_VALUE (DHCP_OPTION_VALUE  * _source)
  {
  _fgs__DHCP_OPTION_DATA ((DHCP_OPTION_DATA *)&_source->Value);
  }
/* routine that frees graph for struct _DHCP_OPTION_VALUE_ARRAY */
void _fgs__DHCP_OPTION_VALUE_ARRAY (DHCP_OPTION_VALUE_ARRAY  * _source)
  {
  if (_source->Values !=0)
    {
      {
      unsigned long _sym34;
      for (_sym34 = 0; _sym34 < (unsigned long )(0 + _source->NumElements); _sym34++)
        {
        _fgs__DHCP_OPTION_VALUE ((DHCP_OPTION_VALUE *)&_source->Values[_sym34]);
        }
      }
    MIDL_user_free((void  *)(_source->Values));
    }
  }
/* routine that frees graph for struct _DHCP_OPTION_LIST */
void _fgs__DHCP_OPTION_LIST (DHCP_OPTION_LIST  * _source)
  {
  if (_source->Options !=0)
    {
      {
      unsigned long _sym37;
      for (_sym37 = 0; _sym37 < (unsigned long )(0 + _source->NumOptions); _sym37++)
        {
        _fgs__DHCP_OPTION_VALUE ((DHCP_OPTION_VALUE *)&_source->Options[_sym37]);
        }
      }
    MIDL_user_free((void  *)(_source->Options));
    }
  }
/* routine that frees graph for struct _DHCP_CLIENT_INFO */
void _fgs__DHCP_CLIENT_INFO (DHCP_CLIENT_INFO_V4  * _source)
  {
  _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)&_source->ClientHardwareAddress);
  if (_source->ClientName !=0)
    {
    MIDL_user_free((void  *)(_source->ClientName));
    }
  if (_source->ClientComment !=0)
    {
    MIDL_user_free((void  *)(_source->ClientComment));
    }
  _fgs__DHCP_HOST_INFO ((DHCP_HOST_INFO *)&_source->OwnerHost);
  }
/* routine that frees graph for struct _DHCP_CLIENT_INFO_ARRAY */
void _fgs__DHCP_CLIENT_INFO_ARRAY (DHCP_CLIENT_INFO_ARRAY_V4  * _source)
  {
  if (_source->Clients !=0)
    {
      {
      unsigned long _sym40;
      for (_sym40 = 0; _sym40 < (unsigned long )(0 + _source->NumElements); _sym40++)
        {
        if (_source->Clients[_sym40] !=0)
          {
          _fgs__DHCP_CLIENT_INFO ((DHCP_CLIENT_INFO_V4 *)_source->Clients[_sym40]);
          MIDL_user_free((void  *)(_source->Clients[_sym40]));
          }
        }
      }
    MIDL_user_free((void  *)(_source->Clients));
    }
  }
/* routine that frees graph for struct _DHCP_CLIENT_INFO_ARRAY_V5 */
void _fgs__DHCP_CLIENT_INFO_ARRAY_V5 (DHCP_CLIENT_INFO_ARRAY_V5  * _source)
  {
  if (_source->Clients !=0)
    {
      {
      unsigned long _sym40;
      for (_sym40 = 0; _sym40 < (unsigned long )(0 + _source->NumElements); _sym40++)
        {
        if (_source->Clients[_sym40] !=0)
          {
          _fgs__DHCP_CLIENT_INFO_V5 ((DHCP_CLIENT_INFO_V5 *)_source->Clients[_sym40]);
          MIDL_user_free((void  *)(_source->Clients[_sym40]));
          }
        }
      }
    MIDL_user_free((void  *)(_source->Clients));
    }
  }
/* routine that frees graph for struct _DHCP_CLIENT_INFO_V5 */
void _fgs__DHCP_CLIENT_INFO_V5 (DHCP_CLIENT_INFO_V5  * _source)
  {
  _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)&_source->ClientHardwareAddress);
  if (_source->ClientName !=0)
    {
    MIDL_user_free((void  *)(_source->ClientName));
    }
  if (_source->ClientComment !=0)
    {
    MIDL_user_free((void  *)(_source->ClientComment));
    }
  _fgs__DHCP_HOST_INFO ((DHCP_HOST_INFO *)&_source->OwnerHost);
  }

/* routine that frees graph for union _DHCP_CLIENT_SEARCH_UNION */
void _fgu__DHCP_CLIENT_SEARCH_UNION (union _DHCP_CLIENT_SEARCH_UNION * _source, DHCP_SEARCH_INFO_TYPE _branch)
  {
  switch (_branch)
    {
    case DhcpClientIpAddress :
      {
      break;
      }
    case DhcpClientHardwareAddress :
      {
      _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)&_source->ClientHardwareAddress);
      break;
      }
    case DhcpClientName :
      {
      if (_source->ClientName !=0)
        {
        MIDL_user_free((void  *)(_source->ClientName));
        }
      break;
      }
    default :
      {
      break;
      }
    }
  }
/* routine that frees graph for struct _DHCP_CLIENT_SEARCH_INFO */
void _fgs__DHCP_CLIENT_SEARCH_INFO (DHCP_SEARCH_INFO  * _source)
  {
  _fgu__DHCP_CLIENT_SEARCH_UNION ( (union _DHCP_CLIENT_SEARCH_UNION *)&_source->SearchInfo, _source->SearchType);
  }

void _fgs__DHCP_OPTION_ARRAY(DHCP_OPTION_ARRAY * _source )
  {
  if (_source->Options !=0)
    {
      {
      unsigned long _sym23;
      for (_sym23 = 0; _sym23 < (unsigned long )(0 + _source->NumElements); _sym23++)
        {
        _fgs__DHCP_OPTION ((DHCP_OPTION *)&_source->Options[_sym23]);
        }
      }
    MIDL_user_free((void  *)(_source->Options));
    }
  }


DHCP_SUBNET_ELEMENT_DATA_V4 *
CopySubnetElementDataToV4(
    DHCP_SUBNET_ELEMENT_DATA    *pInput
    )
/*++

Routine Description:
    Deep copy a DHCP_SUBNET_ELEMENT_DATA_V4 structure to a
    DHCP_SUBNET_ELEMENT_DATA structure, allocating memory as
    necessary.  Fields that exist in DHCP_SUBNET_ELEMENT_DATA_V4
    that don't exist in DHCP_SUBNET_ELEMENT_DATA are ignored.

    .
Arguments:

    pInput - pointer to a DHCP_SUBNET_ELEMENT_DATA_V4 structure.

Return Value:
    Success - pointer to a DHCP_SUBNET_ELEMENT_DATA structure.
    Failure - NULL

    .

--*/

{
    DHCP_SUBNET_ELEMENT_DATA_V4 *pOutput;
    DWORD                        dwResult;

    if ( NULL == pInput ) {
        return NULL;
    }

    pOutput = MIDL_user_allocate( sizeof( *pOutput ) );
    if ( pOutput )
    {
        if (CopySubnetElementUnionToV4(
                            &pOutput->Element,
                            &pInput->Element,
                            pInput->ElementType
                            ))
        {
            pOutput->ElementType = pInput->ElementType;
        }
        else
        {
            MIDL_user_free( pOutput );
            pOutput = NULL;
        }
    }

    return pOutput;
}


BOOL
CopySubnetElementUnionToV4(
    DHCP_SUBNET_ELEMENT_UNION_V4 *pUnionV4,
    DHCP_SUBNET_ELEMENT_UNION    *pUnion,
    DHCP_SUBNET_ELEMENT_TYPE      Type
    )
/*++

Routine Description:
    Deep copy a DHCP_SUBNET_ELEMENT_UNION_V4 structure to a
    DHCP_SUBNET_ELEMENT_UNION structure, allocating memory as
    necessary.  Fields that exist in DHCP_SUBNET_ELEMENT_UNION_V4
    that don't exist in DHCP_SUBNET_ELEMENT_UNION are ignored.

    .
Arguments:

    pInput - pointer to a DHCP_SUBNET_ELEMENT_UNION_V4 structure.

Return Value:
    Success - pointer to a DHCP_SUBNET_ELEMENT_UNION structure.
    Failure - NULL

    .

--*/

{
    BOOL fResult = FALSE;

    switch ( Type )
    {
    case DhcpIpRanges:
    case DhcpIpRangesDhcpOnly:
    case DhcpIpRangesBootpOnly:
    case DhcpIpRangesDhcpBootp:
        pUnionV4->IpRange = CopyIpRange( pUnion->IpRange );
        fResult = ( pUnionV4->IpRange != NULL );
        break;

    case DhcpSecondaryHosts:
        pUnionV4->SecondaryHost = CopyHostInfo( pUnion->SecondaryHost, NULL );
        fResult = ( pUnionV4->SecondaryHost != NULL );
        break;

    case DhcpReservedIps:
        pUnionV4->ReservedIp = CopyIpReservationToV4( pUnion->ReservedIp );
        fResult = ( pUnionV4->ReservedIp != NULL );
        break;

    case DhcpExcludedIpRanges:
        pUnionV4->ExcludeIpRange = CopyIpRange( pUnion->ExcludeIpRange );
        fResult = ( pUnionV4->ExcludeIpRange != NULL );
        break;

    case DhcpIpUsedClusters:
        pUnionV4->IpUsedCluster = CopyIpCluster( pUnion->IpUsedCluster );
        fResult = ( pUnionV4->IpUsedCluster != NULL );
        break;

    }

    return fResult;
}

DHCP_IP_RANGE *
CopyIpRange(
    DHCP_IP_RANGE *IpRange
    )
/*++

Routine Description:
    Duplicate a DHCP_IP_RANGE structure.  The function allocates
    memory for the new structure.

    .
Arguments:

    IpRange - pointer to an DHCP_IP_RANGE structure.

Return Value:
    Success - pointer to a DHCP_IP_RANGE structure.
    Failure - NULL

    .

--*/

{
    DHCP_IP_RANGE *pOutputRange;

    if( NULL == IpRange ) return NULL;
    
    pOutputRange = MIDL_user_allocate( sizeof( *pOutputRange ) );

    if ( pOutputRange )
    {
        pOutputRange->StartAddress  = IpRange->StartAddress;
        pOutputRange->EndAddress    = IpRange->EndAddress;
    }

    return pOutputRange;
}


DHCP_HOST_INFO *
CopyHostInfo(
    DHCP_HOST_INFO *pHostInfo,
    DHCP_HOST_INFO *pHostInfoDest OPTIONAL
    )
/*++

Routine Description:
    Duplicate a DHCP_HOST_INFO structure.  The function allocates
    memory for the new structure unless a buffer is provided by the
    caller.

    .
Arguments:

    pHostInfo - pointer to an DHCP_HOST_INFO structure.
    pHostInfoDest - optional pointer to a DHCP_HOST_INFO struct


Return Value:
    Success - pointer to a DHCP_HOST_INFO structure.
    Failure - NULL

    .

--*/

{
    DHCP_HOST_INFO *pOutput;

    if ( !pHostInfoDest )
        pOutput = MIDL_user_allocate( sizeof( *pOutput ) );
    else
        pOutput = pHostInfoDest;

    if ( pOutput )
    {
        pOutput->IpAddress = pHostInfo->IpAddress;

        if ( pHostInfo->NetBiosName )
        {
            pOutput->NetBiosName =
                MIDL_user_allocate( WSTRSIZE( pHostInfo->NetBiosName ) );

            if ( !pOutput->NetBiosName )
            {
                goto t_cleanup;
            }

            wcscpy ( pOutput->NetBiosName,
                     pHostInfo->NetBiosName );
        }

        if ( pHostInfo->HostName )
        {
            pOutput->HostName =
                MIDL_user_allocate( WSTRSIZE( pHostInfo->HostName ) );

            if ( !pOutput->HostName )
            {
                goto t_cleanup;
            }

            wcscpy( pOutput->HostName,
                    pHostInfo->HostName
                  );
        }

        return pOutput;
    }
t_cleanup:

    if ( pOutput->HostName )
    {
        MIDL_user_free( pOutput->HostName );
    }

    if ( pOutput->NetBiosName )
    {
        MIDL_user_free( pOutput->NetBiosName );
    }

    if ( !pHostInfoDest )
        MIDL_user_free( pOutput );

    return NULL;
}

DHCP_IP_RESERVATION_V4 *
CopyIpReservationToV4(
    DHCP_IP_RESERVATION *pInput
    )
/*++

Routine Description:
    Deep copy a DHCP_IP_RESERVATION_V4 structure to a
    DHCP_IP_RESERVATION structure, allocating memory as
    necessary.  Fields that exist in DHCP_IP_RESERVATION_V4
    that don't exist in DHCP_IP_RESERVATION are ignored.

    .
Arguments:

    pInput - pointer to a DHCP_IP_RESERVATION_V4 structure.

Return Value:
    Success - pointer to a DHCP_IP_RESERVATION structure.
    Failure - NULL

    .

--*/
{
    DHCP_IP_RESERVATION_V4 *pOutput =
        MIDL_user_allocate( sizeof( *pOutput ) );

    if ( pOutput )
    {
        pOutput->ReservedIpAddress   = pInput->ReservedIpAddress;
        pOutput->ReservedForClient =
            CopyBinaryData( pInput->ReservedForClient, NULL );

        if ( !pOutput->ReservedForClient )
        {
            goto t_cleanup;
        }

        pOutput->bAllowedClientTypes = CLIENT_TYPE_DHCP;
    }

    return pOutput;

t_cleanup:

    if ( pOutput->ReservedForClient )
    {
        _fgs__DHCP_BINARY_DATA( pOutput->ReservedForClient );
    }

    return NULL;
}

DHCP_IP_CLUSTER *
CopyIpCluster(
    DHCP_IP_CLUSTER *pInput
    )
/*++

Routine Description:
    Duplicate a DHCP_IP_CLUSTER structure.  The function allocates
    memory for the new structure.

    .
Arguments:

    IpRange - pointer to an DHCP_IP_CLUSTER structure.

Return Value:
    Success - pointer to a DHCP_IP_CLUSTER structure.
    Failure - NULL

    .

--*/
{
    DHCP_IP_CLUSTER *pOutput =
        MIDL_user_allocate( sizeof( *pOutput ) );

    if ( pOutput )
    {
        pOutput->ClusterAddress = pInput->ClusterAddress;
        pOutput->ClusterMask    = pInput->ClusterMask;
    }
    return pOutput;
}

DHCP_BINARY_DATA *
CopyBinaryData(
    DHCP_BINARY_DATA *pInput,
    DHCP_BINARY_DATA *pOutputArg
    )
/*++

Routine Description:
    Duplicate a DHCP_BINARY_DATA structure.  The function allocates
    memory for the new structure unless a buffer is provided by the
    caller.

    .
Arguments:

    pHostInfo - pointer to an DHCP_BINARY_DATA structure.
    pHostInfoDest - optional pointer to a DHCP_BINARY_DATA struct


Return Value:
    Success - pointer to a DHCP_BINARY_DATA structure.
    Failure - NULL

    .

--*/

{
    DHCP_BINARY_DATA *pOutput;

    // Check for valid Input
    if (( NULL == pInput ) ||
	( NULL == pInput->Data )) {
	return NULL;
    }

    if ( pOutputArg )
        pOutput = pOutputArg;
    else
        pOutput = MIDL_user_allocate( sizeof( *pOutput ) );
    if ( pOutput )
    {
        pOutput->DataLength = pInput->DataLength;

        pOutput->Data = MIDL_user_allocate( pOutput->DataLength );
        if ( !pOutput->Data )
        {
            goto t_cleanup;
        }
	
	if ( IsBadReadPtr( pInput->Data, pInput->DataLength )) {
	    goto t_cleanup;
	}

        RtlCopyMemory( pOutput->Data,
                       pInput->Data,
                       pInput->DataLength );
    }

    return pOutput;

t_cleanup:
    if ( pOutput->Data )
    {
        MIDL_user_free( pOutput->Data );
    }

    if ( !pOutputArg )
    {
        MIDL_user_free( pOutput );
    }


    return NULL;
}

WCHAR *
DupUnicodeString(
    WCHAR *pInput
    )
/*++

Routine Description:
    Duplicate a unicode string.  The function allocates
    memory for the new string.

    .
Arguments:

    IpRange - pointer to unicode string.

Return Value:
    Success - pointer to a copy of pInput.
    Failure - NULL

    .

--*/
{
    WCHAR *pOutput = MIDL_user_allocate( WSTRSIZE( pInput ) );
    if ( pOutput )
    {
        wcscpy( pOutput, pInput );
    }

    return pOutput;
}

DHCP_CLIENT_INFO_V4 *
CopyClientInfoToV4(
    DHCP_CLIENT_INFO *pInput
    )
/*++

Routine Description:
    Deep copy a DHCP_CLIENT_INFO_V4 structure to a
    DHCP_CLIENT_INFO structure, allocating memory as
    necessary.  Fields that exist in DHCP_CLIENT_INFO_V4
    that don't exist in DHCP_CLIENT_INFO are ignored.

    .
Arguments:

    pInput - pointer to a DHCP_CLIENT_INFO_V4 structure.

Return Value:
    Success - pointer to a DHCP_CLIENT_INFO structure.
    Failure - NULL

    .

--*/
{
    DHCP_CLIENT_INFO_V4 *pOutput =
        MIDL_user_allocate( sizeof( *pOutput ) );

    if ( pOutput )
    {

        memset( pOutput, 0, sizeof( *pOutput ));

        pOutput->ClientIpAddress = pInput->ClientIpAddress;
        pOutput->SubnetMask      = pInput->SubnetMask;

        if ( !CopyBinaryData( &pInput->ClientHardwareAddress,
                              &pOutput->ClientHardwareAddress ))
            goto t_cleanup;

        if ( pInput->ClientName )
        {
            pOutput->ClientName = DupUnicodeString( pInput->ClientName );

            if ( !pOutput->ClientName )
                goto t_cleanup;
        }


        if ( pInput->ClientComment )
        {
            pOutput->ClientComment = DupUnicodeString( pInput->ClientComment );

            if ( !pOutput->ClientComment )
                goto t_cleanup;
        }

        pOutput->ClientLeaseExpires = pInput->ClientLeaseExpires;
        if ( !CopyHostInfo( &pInput->OwnerHost, &pOutput->OwnerHost ) )
        {
            goto t_cleanup;
        }

        pOutput -> OwnerHost.NetBiosName = NULL;
        pOutput -> OwnerHost.HostName = NULL;
    }

    return pOutput;

t_cleanup:
    _fgs__DHCP_BINARY_DATA( &pOutput->ClientHardwareAddress );

    if ( pOutput->ClientName )
    {
        MIDL_user_free( pOutput->ClientName );
    }

    if ( pOutput->ClientComment )
    {
        MIDL_user_free( pOutput->ClientComment );
    }

    _fgs__DHCP_HOST_INFO( &pOutput->OwnerHost );

    MIDL_user_free( pOutput );

    return NULL;
}

/* routine that frees graph for struct _DHCP_MCLIENT_INFO */
void _fgs__DHCP_MCLIENT_INFO (DHCP_MCLIENT_INFO  * _source)
  {
  _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)&_source->ClientId);
  if (_source->ClientName !=0)
    {
    MIDL_user_free((void  *)(_source->ClientName));
    }
  _fgs__DHCP_HOST_INFO ((DHCP_HOST_INFO *)&_source->OwnerHost);
  }

/* routine that frees graph for struct _DHCP_MCLIENT_INFO_ARRAY */
void _fgs__DHCP_MCLIENT_INFO_ARRAY (DHCP_MCLIENT_INFO_ARRAY  * _source)
  {
  if (_source->Clients !=0)
    {
      {
      unsigned long _sym40;
      for (_sym40 = 0; _sym40 < (unsigned long )(0 + _source->NumElements); _sym40++)
        {
        if (_source->Clients[_sym40] !=0)
          {
          _fgs__DHCP_MCLIENT_INFO ((DHCP_MCLIENT_INFO *)_source->Clients[_sym40]);
          MIDL_user_free((void  *)(_source->Clients[_sym40]));
          }
        }
      }
    MIDL_user_free((void  *)(_source->Clients));
    }
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\mmapi.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

DWORD
DhcpRegistryInitOld(
    VOID
) ;

DWORD
DhcpReadConfigInfo(
    IN OUT PM_SERVER *Server
    );

DWORD
DhcpOpenConfigTable(
    IN JET_SESID SesId,
    IN JET_DBID DbId
    );

DWORD
DhcpSaveConfigInfo(
    IN OUT PM_SERVER Server,
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DHCP_IP_ADDRESS Subnet OPTIONAL,
    IN DWORD Mscope OPTIONAL,
    IN DHCP_IP_ADDRESS Reservation OPTIONAL
    );

DWORD
DhcpConfigInit(
    VOID
) ;

VOID
DhcpConfigCleanup(
    VOID
) ;


DWORD
DhcpConfigSave(
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DHCP_IP_ADDRESS Subnet OPTIONAL,
    IN DWORD Mscope OPTIONAL,
    IN DHCP_IP_ADDRESS Reservation OPTIONAL
    );

PM_SERVER
DhcpGetCurrentServer(
    VOID
) ;


VOID
DhcpSetCurrentServer(
    IN      PM_SERVER              NewCurrentServer
) ;


DWORD
DhcpFindReservationByAddress(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address,
    OUT     LPBYTE                *ClientUID,
    OUT     ULONG                 *ClientUIDSize
) ;


DWORD
DhcpLoopThruSubnetRanges(
    IN      PM_SUBNET              Subnet,
    IN      LPVOID                 Context1,
    IN      LPVOID                 Context2,
    IN      LPVOID                 Context3,
    IN      DWORD                  (*FillRangesFunc)(
            IN          PM_RANGE        Range,
            IN          LPVOID          Context1,
            IN          LPVOID          Context2,
            IN          LPVOID          Context3,
            IN          LPDHCP_BINARY_DATA InUseData,
            IN          LPDHCP_BINARY_DATA UsedData
    )
) ;


DWORD
DhcpGetParameter(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  Ctxt,
    IN      DWORD                  Option,
    OUT     LPBYTE                *OptData, // allocated by funciton
    OUT     DWORD                 *OptDataSize,
    OUT     DWORD                 *Level    // OPTIONAL
) ;


DWORD
DhcpGetParameterForAddress(
    IN      DHCP_IP_ADDRESS        Address,
    IN      DWORD                  ClassId,
    IN      DWORD                  Option,
    OUT     LPBYTE                *OptData, // allocated by function
    OUT     DWORD                 *OptDataSize,
    OUT     DWORD                 *Level    // OPTIONAL
) ;


DWORD
DhcpGetAndCopyOption(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  Ctxt,
    IN      DWORD                  Option,
    IN  OUT LPBYTE                 OptData, // fill input buffer --max size is given as OptDataSize parameter
    IN  OUT DWORD                 *OptDataSize,
    OUT     DWORD                 *Level,   // OPTIONAL
    IN      BOOL                   fUtf8
) ;


DHCP_IP_ADDRESS
DhcpGetSubnetMaskForAddress(
    IN      DHCP_IP_ADDRESS        AnyIpAddress
) ;


DWORD
DhcpLookupReservationByHardwareAddress(
    IN      DHCP_IP_ADDRESS        ClientSubnetAddress,
    IN      LPBYTE                 RawHwAddr,
    IN      DWORD                  RawHwAddrSize,
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt          // fill in the Subnet and Reservation of the client
) ;


VOID
DhcpReservationGetAddressAndType(
    IN      PM_RESERVATION         Reservation,
    OUT     DHCP_IP_ADDRESS       *Address,
    OUT     BYTE                  *Type
) ;


VOID
DhcpSubnetGetSubnetAddressAndMask(
    IN      PM_SUBNET              Subnet,
    OUT     DHCP_IP_ADDRESS       *Address,
    OUT     DHCP_IP_ADDRESS       *Mask
) ;


BOOL
DhcpSubnetIsDisabled(
    IN      PM_SUBNET              Subnet,
    IN      BOOL                   fBootp
) ;


BOOL
DhcpSubnetIsSwitched(
    IN      PM_SUBNET              Subnet
) ;


DWORD
DhcpGetSubnetForAddress(                               // fill in with the right subnet for given address
    IN      DHCP_IP_ADDRESS        Address,
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt
) ;


DWORD
DhcpGetMScopeForAddress(                               // fill in with the right subnet for given address
    IN      DHCP_IP_ADDRESS        Address,
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt
) ;


DWORD
DhcpLookupDatabaseByHardwareAddress(                   // see if the client has any previous address in the database
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt,         // set this with details if found
    IN      LPBYTE                 RawHwAddr,
    IN      DWORD                  RawHwAddrSize,
    OUT     DHCP_IP_ADDRESS       *desiredIpAddress    // if found, fill this with the ip address found
) ;


DWORD
DhcpRequestSomeAddress(                                // get some address in this context
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    OUT     DHCP_IP_ADDRESS       *desiredIpAddress,
    IN      BOOL                   fBootp
) ;


BOOL
DhcpSubnetInSameSuperScope(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        IpAddress2
) ;


BOOL
DhcpInSameSuperScope(
    IN      DHCP_IP_ADDRESS        Address1,
    IN      DHCP_IP_ADDRESS        Address2
) ;


BOOL
DhcpAddressIsOutOfRange(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    IN      BOOL                   fBootp
) ;


BOOL
DhcpAddressIsExcluded(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt
) ;


BOOL
DhcpRequestSpecificAddress(
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    IN      DHCP_IP_ADDRESS        Address
) ;


DWORD
DhcpReleaseBootpAddress(
    IN      DHCP_IP_ADDRESS        Address
) ;


DWORD
DhcpReleaseAddress(
    IN      DHCP_IP_ADDRESS        Address
) ;


DWORD
DhcpServerGetSubnetCount(
    IN      PM_SERVER              Server
) ;


DWORD
DhcpServerGetMScopeCount(
    IN      PM_SERVER              Server
) ;


DWORD
DhcpServerGetClassId(
    IN      PM_SERVER              Server,
    IN      LPBYTE                 ClassIdBytes,
    IN      DWORD                  nClassIdBytes
) ;


DWORD
DhcpServerGetVendorId(
    IN      PM_SERVER              Server,
    IN      LPBYTE                 VendorIdBytes,
    IN      DWORD                  nVendorIdBytes
) ;


BOOL
DhcpServerIsAddressReserved(
    IN      PM_SERVER              Server,
    IN      DHCP_IP_ADDRESS        Address
) ;


BOOL
DhcpServerIsAddressOutOfRange(
    IN      PM_SERVER              Server,
    IN      DHCP_IP_ADDRESS        Address,
    IN      BOOL                   fBootp
) ;


BOOL
DhcpSubnetIsAddressExcluded(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address
) ;


BOOL
DhcpSubnetIsAddressOutOfRange(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address,
    IN      BOOL                   fBootp
) ;


BOOL
DhcpSubnetIsAddressReserved(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address
) ;


DWORD
DhcpUpdateReservationInfo(
    IN      DHCP_IP_ADDRESS        IpAddress,
    IN      LPBYTE                 SetClientUID,
    IN      DWORD                  SetClientUIDLength
) ;


DWORD
DhcpRegFlushServerIfNeeded(
    VOID
) ;


DWORD
DhcpFlushBitmaps(                                 // do a flush of all bitmaps that have changed
    VOID
) ;


DWORD
DhcpServerFindMScope(
    IN      PM_SERVER              Server,
    IN      DWORD                  ScopeId,
    IN      LPWSTR                 Name,          // Multicast scope name or NULL if this is not the key to search on
    OUT     PM_MSCOPE             *MScope
) ;


BOOL
DhcpServerValidateNewMScopeId(
    IN      PM_SERVER               Server,
    IN      DWORD                   MScopeId
) ;


BOOL
DhcpServerValidateNewMScopeName(
    IN      PM_SERVER               Server,
    IN      LPWSTR                  Name
) ;


DWORD
DhcpMScopeReleaseAddress(
    IN      DWORD                  MScopeId,
    IN      DHCP_IP_ADDRESS        Address
) ;


DWORD
DhcpSubnetRequestSpecificAddress(
	PM_SUBNET            Subnet,
	DHCP_IP_ADDRESS      IpAddress
) ;


DWORD
DhcpSubnetReleaseAddress(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address
) ;


DWORD
MadcapGetMScopeListOption(
    IN      DHCP_IP_ADDRESS         ServerIpAddress,
    OUT     LPBYTE                 *OptVal,
    IN OUT  WORD                   *OptSize
) ;


BOOL
DhcpRequestSpecificMAddress(
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    IN      DHCP_IP_ADDRESS        Address
) ;


BOOL
DhcpMScopeIsAddressReserved(
    IN      DWORD                   MScopeId,
    IN      DHCP_IP_ADDRESS         Address
) ;

BOOL
DhcpIsSubnetStateDisabled(
    IN ULONG SubnetState
) ;


BOOL
DhcpServerIsNotServicingSubnet(
    IN      DWORD                   IpAddressInSubnet
) ;


// This function tries to create a list of all classes (wire-class-id, class name, descr)
// and send this as an option. but since the list can be > 255 it has to be make a continuation...
// and also, we dont want the list truncated somewhere in the middle.. so we try to append
// information for each class separately to see if it succeeds..
LPBYTE
DhcpAppendClassList(
    IN OUT  LPBYTE                  BufStart,
    IN OUT  LPBYTE                  BufEnd
) ;


DWORD
DhcpMemInit(
    VOID
) ;


VOID
DhcpMemCleanup(
    VOID
) ;

//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\oldstub.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    oldstub.h

Abstract:

    This file is the old RPC stub code.

Author:

    Madan Appiah  (madana)  25-APR-1994

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#include <string.h>
#include <limits.h>

#include "dhcp_srv.h"

/* routine that frees graph for struct _DHCP_BINARY_DATA */
void _fgs__DHCP_BINARY_DATA (DHCP_BINARY_DATA  * _source);

/* routine that frees graph for struct _DHCP_HOST_INFO */
void _fgs__DHCP_HOST_INFO (DHCP_HOST_INFO  * _source);

/* routine that frees graph for struct _DHCP_SUBNET_INFO */
void _fgs__DHCP_SUBNET_INFO (DHCP_SUBNET_INFO  * _source);

/* routine that frees graph for struct _DHCP_IP_ARRAY */
void _fgs__DHCP_IP_ARRAY (DHCP_IP_ARRAY  * _source);

/* routine that frees graph for struct _DHCP_IP_RESERVATION */
void _fgs__DHCP_IP_RESERVATION (DHCP_IP_RESERVATION_V4  * _source);

/* routine that frees graph for union _DHCP_SUBNET_ELEMENT_UNION */
void _fgu__DHCP_SUBNET_ELEMENT_UNION (union _DHCP_SUBNET_ELEMENT_UNION_V4 * _source, DHCP_SUBNET_ELEMENT_TYPE _branch);

/* routine that frees graph for struct _DHCP_SUBNET_ELEMENT_DATA */
void _fgs__DHCP_SUBNET_ELEMENT_DATA (DHCP_SUBNET_ELEMENT_DATA_V4  * _source);

/* routine that frees graph for struct _DHCP_SUBNET_ELEMENT_INFO_ARRAY */
void _fgs__DHCP_SUBNET_ELEMENT_INFO_ARRAY (DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4  * _source);


/* routine that frees graph for union _DHCP_OPTION_ELEMENT_UNION */
void _fgu__DHCP_OPTION_ELEMENT_UNION (union _DHCP_OPTION_ELEMENT_UNION * _source, DHCP_OPTION_DATA_TYPE _branch);

/* routine that frees graph for struct _DHCP_OPTION_DATA_ELEMENT */
void _fgs__DHCP_OPTION_DATA_ELEMENT (DHCP_OPTION_DATA_ELEMENT  * _source);

/* routine that frees graph for struct _DHCP_OPTION_DATA */
void _fgs__DHCP_OPTION_DATA (DHCP_OPTION_DATA  * _source);

/* routine that frees graph for struct _DHCP_OPTION */
void _fgs__DHCP_OPTION (DHCP_OPTION  * _source);

/* routine that frees graph for struct _DHCP_OPTION_VALUE */
void _fgs__DHCP_OPTION_VALUE (DHCP_OPTION_VALUE  * _source);

/* routine that frees graph for struct _DHCP_OPTION_VALUE_ARRAY */
void _fgs__DHCP_OPTION_VALUE_ARRAY (DHCP_OPTION_VALUE_ARRAY  * _source);

/* routine that frees graph for struct _DHCP_OPTION_LIST */
void _fgs__DHCP_OPTION_LIST (DHCP_OPTION_LIST  * _source);

/* routine that frees graph for struct _DHCP_CLIENT_INFO */
void _fgs__DHCP_CLIENT_INFO (DHCP_CLIENT_INFO_V4  * _source);

/* routine that frees graph for struct _DHCP_CLIENT_INFO_V5 */
void _fgs__DHCP_CLIENT_INFO_V5 (DHCP_CLIENT_INFO_V5 * _source);

/* routine that frees graph for struct _DHCP_CLIENT_INFO_ARRAY */
void _fgs__DHCP_CLIENT_INFO_ARRAY (DHCP_CLIENT_INFO_ARRAY_V4  * _source);

/* routine that frees graph for struct _DHCP_INFO_ARRAY_V5 */
void _fgs__DHCP_CLIENT_INFO_ARRAY_V5 (DHCP_CLIENT_INFO_ARRAY_V5    *_source);

/* routine that frees graph for union _DHCP_CLIENT_SEARCH_UNION */
void _fgu__DHCP_CLIENT_SEARCH_UNION (union _DHCP_CLIENT_SEARCH_UNION * _source, DHCP_SEARCH_INFO_TYPE _branch);

/* routine that frees graph for struct _DHCP_CLIENT_SEARCH_INFO */
void _fgs__DHCP_CLIENT_SEARCH_INFO (DHCP_SEARCH_INFO  * _source);

/* routine that frees graph for struct _DHCP_OPTION_ARRAY */
void _fgs__DHCP_OPTION_ARRAY(DHCP_OPTION_ARRAY * _source );

/* routine that frees graph for struct _DHCP_MCLIENT_INFO */
void _fgs__DHCP_MCLIENT_INFO (DHCP_MCLIENT_INFO  * _source);

/* routine that frees graph for struct _DHCP_MCLIENT_INFO_ARRAY */
void _fgs__DHCP_MCLIENT_INFO_ARRAY (DHCP_MCLIENT_INFO_ARRAY  * _source);

DHCP_SUBNET_ELEMENT_DATA_V4 *
CopySubnetElementDataToV4(
    DHCP_SUBNET_ELEMENT_DATA    *pInput
    );

BOOL
CopySubnetElementUnionToV4(
    DHCP_SUBNET_ELEMENT_UNION_V4 *pUnionV4,
    DHCP_SUBNET_ELEMENT_UNION    *pUnion,
    DHCP_SUBNET_ELEMENT_TYPE      Type
    );

DHCP_IP_RANGE *
CopyIpRange(
    DHCP_IP_RANGE *IpRange
    );

DHCP_HOST_INFO *
CopyHostInfo( DHCP_HOST_INFO *pHostInfo,
              OPTIONAL DHCP_HOST_INFO *pHostInfoDest
    );

DHCP_IP_RESERVATION_V4 *
CopyIpReservationToV4(
    DHCP_IP_RESERVATION *pInput
    );

DHCP_IP_CLUSTER *
CopyIpCluster(
    DHCP_IP_CLUSTER *pInput
    );

DHCP_BINARY_DATA *
CopyBinaryData(
    DHCP_BINARY_DATA *pInput,
    DHCP_BINARY_DATA *pOutputBuff
    );

DHCP_CLIENT_INFO_V4 *
CopyClientInfoToV4(
    DHCP_CLIENT_INFO *pInput
    );


WCHAR *
DupUnicodeString( WCHAR *pInput
    );







=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\mmapi.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    mmapi.c

Abstract:

    Server interface to the MM module

Environment:

    User mode, Win32

--*/

#include    <dhcppch.h>
#include    <rpcapi.h>
#include    <dsreg.h>

//
// file static variable.
//

//
// Exported routines begin here.
//

//BeginExport(function)
DWORD
DhcpRegistryInitOld(
    VOID
) //EndExport(function)
/*++

    Initializes registry so far as MM is concerned -- just read the objects
    and fill in the internal structures.

--*/
{
    DhcpAssert( NULL == DhcpGlobalThisServer );
    return DhcpRegReadThisServer(&DhcpGlobalThisServer);
}

//BeginExport(function)
DWORD
DhcpConfigInit(
    VOID
) //EndExport(function)
{
    DWORD Error;

    Error = DhcpReadConfigInfo(&DhcpGlobalThisServer);
    if( NO_ERROR != Error ) return Error;

    return ReadServerBitmasks();
}

//BeginExport(function)
VOID
DhcpConfigCleanup(
    VOID
) //EndExport(function)
/*++

    This undoes the effect of DhcpConfigInit, closing all handles and
    freeing all resources.

--*/
{
    if(DhcpGlobalThisServer) {
        MemServerFree(DhcpGlobalThisServer);
        DhcpGlobalThisServer = NULL;
    }
}

//BeginExport(function)
DWORD
DhcpConfigSave(
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DHCP_IP_ADDRESS Subnet OPTIONAL,
    IN DWORD Mscope OPTIONAL,
    IN DHCP_IP_ADDRESS Reservation OPTIONAL
) //EndExport(function)
{
    return DhcpSaveConfigInfo(
        DhcpGlobalThisServer, fClassChanged, fOptionsChanged,
        Subnet, Mscope, Reservation );
}

//BeginExport(function)
PM_SERVER
DhcpGetCurrentServer(
    VOID
) //EndExport(function)
{
    return DhcpGlobalThisServer;
}

//BeginExport(function)
VOID
DhcpSetCurrentServer(
    IN PM_SERVER NewCurrentServer
) //EndExport(function)
{
    DhcpAssert(NewCurrentServer);
    DhcpGlobalThisServer = NewCurrentServer;
}

//BeginExport(function)
DWORD
DhcpFindReservationByAddress(
    IN PM_SUBNET Subnet,
    IN DHCP_IP_ADDRESS Address,
    OUT LPBYTE *ClientUID,
    OUT ULONG *ClientUIDSize
)   //EndExport(function)
/*++

Routine Description:

    This function searches a subnet for a reservation with a given IP
    address, and if found returns the ClientUID and size.  The ClientUID is
    an internally allocated pointer that is valid only so long as the
    "ReadLock" (see lock.c) is taken....  It could get modified after
    that..

Arguments:

    Subnet -- valid subnet object pointer
    Address -- non-zero IP address of the reservation to check for
    ClientUID -- return pointer to memory that is valid only so long as
        readlock is held. (Do not free this memory).
    ClientUIDSize -- size of above pointer in bytes.

Return Value:

    Win32 errors

--*/
{
    ULONG Error;
    PM_RESERVATION Reservation;

    Error = MemReserveFindByAddress(
        &Subnet->Reservations, Address, &Reservation
        );
    if( ERROR_SUCCESS != Error ) return Error;

    *ClientUID = Reservation->ClientUID;
    *ClientUIDSize = Reservation->nBytes;

    return ERROR_SUCCESS;
}


//BeginExport(function)
DWORD
DhcpLoopThruSubnetRanges(
    IN PM_SUBNET Subnet,
    IN LPVOID Context1 OPTIONAL,
    IN LPVOID Context2 OPTIONAL,
    IN LPVOID Context3 OPTIONAL,
    IN DWORD (*FillRangesFunc)(
        IN PM_RANGE Range,
        IN LPVOID Context1,
        IN LPVOID Context2,
        IN LPVOID Context3,
        IN LPDHCP_BINARY_DATA InUseData,
        IN LPDHCP_BINARY_DATA UsedData
    )
)   //EndExport(function)
/*++

Routine Description:
    This routine can be used to loop though the ranges of a subnet to
    process each range.   Three contexts can be supplied which will be
    passed directly to the FillRangesFunc routine as parameter.

Arguments:
    Subnet -- this is the subnet to loop through.
    Context1 -- caller specified context, passed to FillRangesFunc.
    Context2 -- caller specified context, passed to FillRangesFunc.
    Context3 -- caller specified context, passed to FillRangesFunc.
    FillRangesFunc -- caller specified routine that is called on each
        range found for the subnet.   This routine is called with the
        InUseData and UsedData clusters as appropriate for this range.
        (These last two parameters should not be modified in anyway)

Return Value:
   If any invocation of FillRangesFunc returns an error, then that error is
   immediately returned.  If there is any error in retreiving the InUseData
   and the UsedData binary structures for any range, then an error is
   returned.

   Win32 errors.

--*/
{
    ULONG Error;
    ARRAY_LOCATION Loc;
    PM_RANGE ThisRange = NULL;
    DHCP_BINARY_DATA InUseData, UsedData;

    for( Error = MemArrayInitLoc(&Subnet->Ranges, &Loc) ;
         ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc(&Subnet->Ranges, &Loc)
    ) {
        Error = MemArrayGetElement(&Subnet->Ranges, &Loc, &ThisRange);

        Error = MemRangeConvertToClusters(
            ThisRange, &InUseData.Data, &InUseData.DataLength,
            &UsedData.Data, &UsedData.DataLength
            );
        if( ERROR_SUCCESS != Error ) return Error;

        Error = FillRangesFunc(
            ThisRange, Context1, Context2, Context3, &InUseData, &UsedData
            );
        if( UsedData.Data ) MemFree(UsedData.Data);
        if( InUseData.Data ) MemFree(InUseData.Data);

        if( ERROR_SUCCESS != Error ) return Error;
    }

    return ERROR_SUCCESS;
}

DWORD
DhcpOptClassGetMemOptionExact(
    IN LPDHCP_REQUEST_CONTEXT Ctxt,
    IN PM_OPTCLASS Options,
    IN DWORD Option,
    IN DWORD ClassId,
    IN DWORD VendorId,
    OUT PM_OPTION *Opt
)
/*++

Routine Description:
    This routine tries to find an option matching the option ID specified
    in "Option" parameter and belonging to the class specified by ClassId
    and VendorId.  (Note that ClassId and VendorId are used for exact
    matches).

    If an option is found, then the option structure is returned in the
    "Opt" parameter -- this can be used only so long as the global readlock
    on all memory structures are in place. (see lock.c).  It is an internal
    pointer and should not be modified.

    N.B.  If VendorId actually belongs to a microsoft vendor class ID, then
    the MSFT class is also applied..

Arguments:
    Ctxt -- client request context
    Options -- the option-class list to search for the particular option
    Option -- the option ID of the option to search for
    ClassId -- the exact class id of the option needed
    VendorId -- the exact vendor id of the option needed
    Opt -- a variable that will be filled with pointer to the in memory
        option structure.

Return Value:
    Win32 errors.
--*/
{
    DWORD Error;
    PM_OPTLIST OptList;

    //
    // get list of options for classid, vendorid pair.
    //

    do {
        OptList = NULL;
        Error = MemOptClassFindClassOptions(
            Options,
            ClassId,
            VendorId,
            &OptList
            );
        if( ERROR_SUCCESS != Error ) {
            if( VendorId != DhcpGlobalMsftClass
                && Ctxt->fMSFTClient ) {
                //
                // If it belongs to a microsoft client,
                // try the MSFT class also.
                //
                VendorId = DhcpGlobalMsftClass;
                continue;
            }
        }

        if( ERROR_SUCCESS != Error ) break;

        //
        // search for reqd option id
        //

        DhcpAssert(NULL != OptList);
        Error = MemOptListFindOption(
            OptList,
            Option,
            Opt
            );
        if( ERROR_SUCCESS != Error ) {
            if( VendorId != DhcpGlobalMsftClass
                && Ctxt->fMSFTClient ) {
                //
                // If it belongs to a microsoft client,
                // try the MSFT class also.
                //
                VendorId = DhcpGlobalMsftClass;
                continue;
            }
        }

        break;
    } while ( 1 );
    return Error;
} // DhcpoptclassGetMemOptionExact()

DWORD
DhcpOptClassGetMemOption(
    IN LPDHCP_REQUEST_CONTEXT Ctxt,
    IN PM_OPTCLASS Options,
    IN DWORD Option,
    IN DWORD ClassId OPTIONAL,
    IN DWORD VendorId OPTIONAL,
    OUT PM_OPTION *Opt
)
/*++

Routine Description:
    This routine is almost exactly the same as
    DhcpOptClassGetMemOptionExact except that the ClassId and VendorId are
    optional, and the following search logic is used to identify the
    options.

    1. An exact search is made for <Option, ClassId, VendorId>.

    Note that the returned option is valid only so long as the global
    memory read lock is taken... (see lock.c)

Arguments:
    Ctxt -- client request context
    Options -- list of opt-class to search for desired option
    Option -- option id to search for
    ClassId -- reqd class id
    VendorId -- reqd vendor id
    Opt -- variable to store the found option.

Return Value:
    Win32 errors

--*/
{
    DWORD Error;

    //
    // exact match.
    //

    Error = DhcpOptClassGetMemOptionExact(
        Ctxt,
        Options,
        Option,
        ClassId,
        VendorId,
        Opt
    );

    return Error;
} // DhcpOptClassGetMemOption()

DWORD
DhcpOptClassGetOptionSimple(
    IN PDHCP_REQUEST_CONTEXT Ctxt,
    IN PM_OPTCLASS Options,
    IN DWORD Option,
    IN DWORD ClassId,
    IN DWORD VendorId,
    OUT LPBYTE OptData OPTIONAL,
    IN OUT DWORD *OptDataSize,
    IN BOOL fUtf8
)
/*++

Routine Description:
    This routine copies the option data value for the option id specified
    by the "Option" parameter onto the buffer "OptData" and fills the size
    of the buffer filled onto the parameter "OptDataSize".   If the buffer
    is of insufficient size (input size is also specified by the
    "OptDataSize" parameter), then the required size is filled in, and
    ERROR_MORE_DATA is returned.

    No special processing is done for option OPTION_VENDOR_SPEC_INFO --
    i.e. if there are multiple vendor specific option ID's defined, the
    information is not collated. Use DhcpOptClassGetOption for that.

    The buffer "OptData" is filled in with the option as it would need to
    be sent on the wire.

Arguments:
    Ctxt -- client request context
    Options -- the option-class list to search in for reqd option
    Option -- option id to search for
    ClassId -- the user class to seach for
    VendorId -- the vendor class to seach for
    OptData -- the input buffer to fill in with option data information
        This can be NULL if OptDataSize is set to zero on input.
    OptDataSize -- on input this should be the size of the above buffer,
        and on output it would be set to the actual size required or used
        for this option.

Return Value:
    ERROR_MORE_DATA if the input buffer size is insufficient.
    Other Win32 errors

--*/
{
    DWORD Error;
    PM_OPTION Opt;

    //
    // get the option first.
    //

    Opt = NULL;
    Error = DhcpOptClassGetMemOption(
        Ctxt,
        Options,
        Option,
        ClassId,
        VendorId,
        &Opt
    );
    if( ERROR_SUCCESS != Error ) return ERROR_FILE_NOT_FOUND;

    DhcpAssert(NULL != Opt);

    //
    // Convert formats.
    //

    return DhcpParseRegistryOption(
        Opt->Val,
        Opt->Len,
        OptData,
        OptDataSize,
        fUtf8
    );

}

DWORD
DhcpOptClassGetOption(
    IN PDHCP_REQUEST_CONTEXT Ctxt,
    IN PM_OPTCLASS Options,
    IN DWORD Option,
    IN DWORD ClassId,
    IN DWORD VendorId,
    OUT LPBYTE OptData OPTIONAL,
    IN OUT DWORD *OptDataSize,
    IN BOOL fUtf8
)
/*++

Routine Description:
    This routine copies the option data value for the option id specified
    by the "Option" parameter onto the buffer "OptData" and fills the size
    of the buffer filled onto the parameter "OptDataSize".   If the buffer
    is of insufficient size (input size is also specified by the
    "OptDataSize" parameter), then the required size is filled in, and
    ERROR_MORE_DATA is returned.

    If the "Option" parameter is OPTION_VENDOR_SPEC_INFO, then, this
    routine collates the information for ALL vendor id's  (vendor id 1 to
    vendor id 254) that are present for the particular class id and vendor
    id, and pulls them together (constructing the resulting option as
    required by the DHCP draft) and returns that in the OptData buffer.
    Note that if the size of the resultant buffer would end up bigger than
    255 (which is the erstwhile maximum size allowed on wire), only so many
    vendor optiosn are included as is possible to keep the count within
    this size.  Also, if there is already an OPTION_VENDOR_SPEC_INFO option
    defined, then that is used instead of the specific options.

    The buffer "OptData" is filled in with the option as it would need to
    be sent on the wire.

Arguments:
    Ctxt -- client request context
    Options -- the option-class list to search in for reqd option
    Option -- option id to search for
    ClassId -- the user class to seach for
    VendorId -- the vendor class to seach for
    OptData -- the input buffer to fill in with option data information
        This can be NULL if OptDataSize is set to zero on input.
    OptDataSize -- on input this should be the size of the above buffer,
        and on output it would be set to the actual size required or used
        for this option.

Return Value:
    ERROR_MORE_DATA if the input buffer size is insufficient.
    Other Win32 errors

--*/
{
    DWORD Error, Index, InBufferSize;
    DWORD ThisSize, InBufferSizeTmp, OutBufferSize;
    PM_OPTLIST OptList;
    PM_OPTION Opt;
    DWORD     Loc;



    Error = MemOptClassFindClassOptions( Options, ClassId, VendorId, &OptList );
    if ( ERROR_SUCCESS != Error ) {
        return Error;
    }

    for ( Error = MemArrayInitLoc( OptList, &Loc );
          ERROR_FILE_NOT_FOUND != Error;
          Error = MemArrayNextLoc( OptList, &Loc )) {
    
        Require( ERROR_SUCCESS == Error );

        Error = MemArrayGetElement( OptList, &Loc, &Opt );
        Require(( ERROR_SUCCESS == Error ) &&
                ( NULL != Opt ));

        if ( Option == Opt->OptId ) {
            Error = DhcpParseRegistryOption( Opt->Val, Opt->Len,
                                             OptData, OptDataSize, fUtf8 );
            return Error;
        }
    } // for 
    
    if ( OPTION_VENDOR_SPEC_INFO != Option ) {
        //
        // Vendor spec option not requested, or succeeded or unknown error
        //
        return Error;
    }

    //
    // process each vendor spec option and collate 'em
    //


    InBufferSize = InBufferSizeTmp = *OptDataSize;
    OutBufferSize = 0;

    // ConvertOptIdToMemValue just adds 256 to Index
    for ( Error = MemArrayInitLoc( OptList, &Loc );
          ERROR_FILE_NOT_FOUND != Error;
          Error = MemArrayNextLoc( OptList, &Loc )) {

        Require( ERROR_SUCCESS == Error );

        Error = MemArrayGetElement( OptList, &Loc, &Opt );
        Require(( ERROR_SUCCESS == Error ) &&
                ( NULL != Opt ));
    
        if ( Opt->OptId > 256 ) {
            *OptData = ( BYTE ) ( Opt->OptId - 256 );
            ThisSize = InBufferSizeTmp;
            Error = DhcpParseRegistryOption( Opt->Val, Opt->Len,
                                             OptData + 2,  &ThisSize, fUtf8 );
            OutBufferSize += ThisSize + 2;

            // If there is an error, try to find out the space needed.
            if (( ERROR_MORE_DATA == Error ) || 
                ( ERROR_SUCCESS != Error ) ||
                ( ThisSize + 2 > InBufferSizeTmp )) {
                continue;
            }

            // Fill the data in.
            InBufferSizeTmp -= ThisSize + 2;
            OptData[ 1 ] = ( BYTE ) ThisSize;
            OptData += ThisSize + 2;        
        } // if 
    } // for 

    if( OutBufferSize == 0 ) return ERROR_FILE_NOT_FOUND;
    *OptDataSize = OutBufferSize;
    if( OutBufferSize > InBufferSize ) return ERROR_MORE_DATA;
    return ERROR_SUCCESS;
} // DhcpOptClassGetOption()


//
//
// abstract: options priority (1) Reservation, (2) Scope Level and (3) Global
// get the options for the client based on its context.( resv, userid or vendorid )
// this function grovels through the internal ( residing in memory ) options 
// based on the client context. The options at the reservation level has the highest priority, at the scope level
// the next highest priority and the global level the lowest priority.
//
//

DWORD
DhcpGetOptionByContext(
   IN      DHCP_IP_ADDRESS        Address,
   IN      PDHCP_REQUEST_CONTEXT  Ctxt,
   IN      DWORD                  Option,
   IN OUT  LPBYTE                 OptData,
   IN OUT  DWORD                 *OptDataSize,
   OUT     DWORD                 *Level,
   IN      BOOL                   fUtf8 
)
{

  DWORD Error = ERROR_FILE_NOT_FOUND;
  PM_OPTLIST OptList = NULL;

if( !DhcpGlobalThisServer ) return ERROR_FILE_NOT_FOUND;
    if( !Ctxt ) return ERROR_FILE_NOT_FOUND;

    if( Level ) *Level = DHCP_OPTION_LEVEL_RESERVATION;
    if( Ctxt->Reservation )
        Error = DhcpOptClassGetOption(
            Ctxt,
            &(Ctxt->Reservation->Options),
            Option,
            Ctxt->ClassId,
            Ctxt->VendorId,
            OptData,
            OptDataSize,
            fUtf8
        );

    if( ERROR_SUCCESS == Error) return ERROR_SUCCESS;
    if( ERROR_MORE_DATA == Error) return Error;

    if( Level ) *Level = DHCP_OPTION_LEVEL_SCOPE;

    if( Ctxt->Subnet )
        Error = DhcpOptClassGetOption(
            Ctxt,
            &(Ctxt->Subnet->Options),
            Option,
            Ctxt->ClassId,
            Ctxt->VendorId,
            OptData,
            OptDataSize,
            fUtf8
        );

    if( ERROR_SUCCESS == Error) return ERROR_SUCCESS;
    if( ERROR_MORE_DATA == Error) return Error;
    if( Level ) *Level = DHCP_OPTION_LEVEL_GLOBAL;

    if( Ctxt->Server )
        Error = DhcpOptClassGetOption(
            Ctxt,
            &(Ctxt->Server->Options),
            Option,
            Ctxt->ClassId,
            Ctxt->VendorId,
            OptData,
            OptDataSize,
            fUtf8
        );

    return Error;
  
} // DhcpGetOptionByContext()

//
//
// checks the options based on userid/classid. This function follows the following algorithm.
// (a) Check for options with the passed classid/vendorid if both are non NULL. If success return.
// (b) If vendorid is non NULL and userid is NULL, get value for this option. If success return.
// (c) If userid is non NULL and vendor id is NULL, get value for this option. If success return.
// (d) If all else fails, go for the default options with zero value for vendorid and userid.
//
// To figure out the size of the option this function may be called
// with OptData set to NULL. In that case the error code is ERROR_MORE_DATA
// and the function will return.
//
//

DWORD
DhcpGetOption(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  Ctxt,
    IN      DWORD                  Option,
    IN  OUT LPBYTE                 OptData, // copied into buffer
    IN  OUT DWORD                 *OptDataSize, // input buffer size and filled with output buffer size
    OUT     DWORD                 *Level,   // OPTIONAL
    IN      BOOL                   fUtf8
)
{
    DWORD                          Error = ERROR_FILE_NOT_FOUND;
    DWORD                          lClsId;
    DWORD                          lVendId;


    if( !DhcpGlobalThisServer ) return ERROR_FILE_NOT_FOUND;
    if( !Ctxt ) return ERROR_FILE_NOT_FOUND;

    //
    // local variables that will hold the classid/vendorid 
    //

    lClsId  = Ctxt -> ClassId;
    lVendId = Ctxt -> VendorId; 

    //
    // both classid and vendorid are present.
    //

    if (( Ctxt -> ClassId ) && 
    ( Ctxt -> VendorId )) {
    Error = DhcpGetOptionByContext( Address, Ctxt, Option, OptData, OptDataSize,
                    Level, fUtf8 );
    }

    if (( Error == ERROR_SUCCESS ) ||
    ( Error == ERROR_MORE_DATA )) {
    return( Error );
    }

    //
    // only vendor id is present or the above call failed.
    //

    if ( Ctxt -> VendorId ) {
        Ctxt -> ClassId = 0;
        Error = DhcpGetOptionByContext( Address, Ctxt, Option, OptData, OptDataSize,
                    Level, fUtf8 );
    }

    Ctxt -> ClassId = lClsId;

    if (( Error == ERROR_SUCCESS ) ||
    ( Error == ERROR_MORE_DATA )) {
        return( Error );
    }

    //
    // only classid is present or the above call failed
    //

    if ( Ctxt -> ClassId ) {
        Ctxt -> VendorId = 0;
        Error = DhcpGetOptionByContext( Address, Ctxt, Option, OptData, OptDataSize,
                    Level, fUtf8 );
    }

    Ctxt -> VendorId = lVendId;
    if (( Error == ERROR_SUCCESS ) ||
    ( Error == ERROR_MORE_DATA )) {
        return ( Error );
    }
    
    //
    // niether classid nor vendorid is present or all the calls above failed,
    // get default options.
    //
    
    Ctxt -> VendorId = Ctxt -> ClassId = 0;
    Error = DhcpGetOptionByContext( Address, Ctxt, Option, OptData, OptDataSize,
                    Level, fUtf8 );
    Ctxt -> VendorId = lVendId; 
    Ctxt -> ClassId  = lClsId;
    return Error;
} // DhcpGetOption()

//BeginExport(function)
DWORD
DhcpGetParameter(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  Ctxt,
    IN      DWORD                  Option,
    OUT     LPBYTE                *OptData, // allocated by funciton
    OUT     DWORD                 *OptDataSize,
    OUT     DWORD                 *Level    // OPTIONAL
) //EndExport(function)
{
    LPBYTE                         Ptr;
    LPBYTE                         RetVal;
    DWORD                          Size;
    DWORD                          Error;

    *OptData = NULL;
    *OptDataSize = 0;

    // 576 = typical max size of DHCP packet
    Size = 576;
    RetVal = DhcpAllocateMemory(Size);
    if( NULL == RetVal ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = DhcpGetOption(Address, Ctxt, Option, RetVal, &Size,
                          Level, FALSE);
    if ( ERROR_SUCCESS == Error ) {
        *OptData = RetVal;
        *OptDataSize = Size;
        return Error;
    } // if
    if ( ERROR_MORE_DATA == Error ) {
    DhcpFreeMemory( RetVal );
    RetVal = DhcpAllocateMemory( Size );
    if ( NULL == RetVal ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    Error = DhcpGetOption( Address, Ctxt, Option, RetVal,
                   &Size, Level, FALSE );
        DhcpAssert(ERROR_MORE_DATA != Error);
    } // if
    if ( ERROR_SUCCESS == Error ) {
    *OptData = RetVal;
        *OptDataSize = Size;
    }
    else {
        DhcpFreeMemory( RetVal );
    }
    
    return Error;
}

//BeginExport(function)
DWORD
DhcpGetParameterForAddress(
    IN      DHCP_IP_ADDRESS        Address,
    IN      DWORD                  ClassId,
    IN      DWORD                  Option,
    OUT     LPBYTE                *OptData, // allocated by function
    OUT     DWORD                 *OptDataSize,
    OUT     DWORD                 *Level    // OPTIONAL
) //EndExport(function)
{
    DWORD                          Error;
    DHCP_REQUEST_CONTEXT           Ctxt;

    // this routine does not work for multicast address.
    DhcpAssert( !CLASSD_HOST_ADDR(Address) );

    Ctxt.Server = DhcpGetCurrentServer();
    Ctxt.Subnet = NULL;
    Ctxt.Range = NULL;
    Ctxt.Reservation = NULL;
    Ctxt.ClassId = ClassId;
    Ctxt.VendorId = 0;
    Ctxt.fMSFTClient = FALSE;

    Error = DhcpGetSubnetForAddress(Address, &Ctxt);
    if( ERROR_SUCCESS != Error ) return Error;

    return DhcpGetParameter(Address, &Ctxt, Option, OptData, OptDataSize, Level);
}

//BeginExport(function)
DWORD
DhcpGetAndCopyOption(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  Ctxt,
    IN      DWORD                  Option,
    IN  OUT LPBYTE                 OptData, // fill input buffer --max size is given as OptDataSize parameter
    IN  OUT DWORD                 *OptDataSize,
    OUT     DWORD                 *Level,   // OPTIONAL
    IN      BOOL                   fUtf8
    ) //EndExport(function)
{
    return DhcpGetOption(
        Address, Ctxt, Option, OptData, OptDataSize, Level, fUtf8);
}

//BeginExport(function)
DHCP_IP_ADDRESS
DhcpGetSubnetMaskForAddress(
    IN      DHCP_IP_ADDRESS        AnyIpAddress
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    if( !DhcpGlobalThisServer ) return 0;
    Error = MemServerGetAddressInfo(
        DhcpGlobalThisServer,
        AnyIpAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return 0;
    DhcpAssert(Subnet);
    return Subnet->Mask;
}

//BeginExport(function)
DWORD
DhcpLookupReservationByHardwareAddress(
    IN      DHCP_IP_ADDRESS        ClientSubnetAddress,
    IN      LPBYTE                 RawHwAddr,
    IN      DWORD                  RawHwAddrSize,
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt          // fill in the Subnet and Reservation of the client
) //EndExport(function)
{
    PM_SUBNET                      Subnet = NULL;
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    DWORD                          SScopeId;
    DWORD                          UIDSize;
    LPBYTE                         UID;

    Error = MemServerGetAddressInfo(
        ClientCtxt->Server,
        ClientSubnetAddress,
        &(ClientCtxt->Subnet),
        &(ClientCtxt->Range),
        &(ClientCtxt->Excl),
        &(ClientCtxt->Reservation)
    );
    if( ERROR_SUCCESS != Error ) return Error;
    if( NULL == ClientCtxt->Subnet ) return ERROR_FILE_NOT_FOUND;
    SScopeId = ClientCtxt->Subnet->SuperScopeId;

    Error = MemArrayInitLoc(&(ClientCtxt->Server->Subnets), &Loc);
    DhcpAssert(ERROR_SUCCESS == Error );

    while( ERROR_FILE_NOT_FOUND != Error ) {
        DhcpAssert(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(&(ClientCtxt->Server->Subnets), &Loc, (LPVOID *)&Subnet);
        DhcpAssert(ERROR_SUCCESS == Error);

        if( 0 == SScopeId && ClientCtxt->Subnet != Subnet ) {
            Error = MemArrayNextLoc(&(ClientCtxt->Server->Subnets), &Loc);
            continue;
        }
        if( Subnet->SuperScopeId == SScopeId ) {
            UID = NULL;
            Error = DhcpMakeClientUID(
                RawHwAddr,
                RawHwAddrSize,
                0 /* hardware type is hardcoded anyways.. */,
                Subnet->Address,
                &UID,
                &UIDSize
            );
            if( ERROR_SUCCESS != Error ) return Error;

            Error = MemReserveFindByClientUID(
                &(Subnet->Reservations),
                UID,
                UIDSize,
                &(ClientCtxt->Reservation)
            );
            DhcpFreeMemory(UID);
            if( ERROR_SUCCESS == Error && NULL != &(ClientCtxt->Reservation) ) {
                ClientCtxt->Subnet = Subnet;
                return ERROR_SUCCESS;
            }
        }

        Error = MemArrayNextLoc(&(ClientCtxt->Server->Subnets), &Loc);
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
VOID
DhcpReservationGetAddressAndType(
    IN      PM_RESERVATION         Reservation,
    OUT     DHCP_IP_ADDRESS       *Address,
    OUT     BYTE                  *Type
) //EndExport(function)
{
    if( NULL == Reservation ) {
        DhcpAssert(FALSE);
        *Address = 0; *Type = 0;
        return;
    }
    *Address = Reservation->Address;
    *Type = (BYTE)Reservation->Flags;
}


//BeginExport(function)
VOID
DhcpSubnetGetSubnetAddressAndMask(
    IN      PM_SUBNET              Subnet,
    OUT     DHCP_IP_ADDRESS       *Address,
    OUT     DHCP_IP_ADDRESS       *Mask
) //EndExport(function)
{
    if( NULL == Subnet ) {
        DhcpAssert(FALSE);
        *Address = *Mask = 0;
        return;
    }

    *Address = Subnet->Address;
    *Mask = Subnet->Mask;
}

//BeginExport(function)
BOOL
DhcpSubnetIsDisabled(
    IN      PM_SUBNET              Subnet,
    IN      BOOL                   fBootp
) //EndExport(function)
{

    if( Subnet?(IS_DISABLED(Subnet->State)):TRUE )
        return TRUE;

    if( FALSE == Subnet->fSubnet ) {
        //
        // no more checks for MADCAP Scopes
        //
        return FALSE;
    }

    return !MemSubnetCheckBootpDhcp(Subnet, fBootp, TRUE);
}

//BeginExport(function)
BOOL
DhcpSubnetIsSwitched(
    IN      PM_SUBNET              Subnet
) //EndExport(function)
{
    return Subnet?(IS_SWITCHED(Subnet->State)):FALSE;
}

//BeginExport(function)
DWORD
DhcpGetSubnetForAddress(                               // fill in with the right subnet for given address
    IN      DHCP_IP_ADDRESS        Address,
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt
) //EndExport(function)
{
    if( NULL == ClientCtxt->Server ) return ERROR_FILE_NOT_FOUND;
    return MemServerGetAddressInfo(
        ClientCtxt->Server,
        Address,
        &(ClientCtxt->Subnet),
        &(ClientCtxt->Range),
        &(ClientCtxt->Excl),
        &(ClientCtxt->Reservation)
    );
}

//BeginExport(function)
DWORD
DhcpGetMScopeForAddress(                               // fill in with the right subnet for given address
    IN      DHCP_IP_ADDRESS        Address,
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt
) //EndExport(function)
{
    if( NULL == ClientCtxt->Server ) return ERROR_FILE_NOT_FOUND;
    return MemServerGetMAddressInfo(
        ClientCtxt->Server,
        Address,
        &(ClientCtxt->Subnet),
        &(ClientCtxt->Range),
        &(ClientCtxt->Excl),
        NULL
    );
}
//BeginExport(function)
DWORD
DhcpLookupDatabaseByHardwareAddress(                   // see if the client has any previous address in the database
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt,         // set this with details if found
    IN      LPBYTE                 RawHwAddr,
    IN      DWORD                  RawHwAddrSize,
    OUT     DHCP_IP_ADDRESS       *desiredIpAddress    // if found, fill this with the ip address found
) //EndExport(function)
{
    PM_SUBNET                      Subnet = NULL;
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    DWORD                          SScopeId;
    DWORD                          UIDSize;
    DWORD                          Size;
    LPBYTE                         UID;

    DhcpAssert(NULL != ClientCtxt->Subnet);
    if( NULL == ClientCtxt->Subnet ) return ERROR_INVALID_PARAMETER;
    SScopeId = ClientCtxt->Subnet->SuperScopeId;

    Error = MemArrayInitLoc(&(ClientCtxt->Server->Subnets), &Loc);
    DhcpAssert(ERROR_SUCCESS == Error );

    while( ERROR_FILE_NOT_FOUND != Error ) {
        DhcpAssert(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(&(ClientCtxt->Server->Subnets), &Loc, (LPVOID *)&Subnet);
        DhcpAssert(ERROR_SUCCESS == Error);

        if( 0 == SScopeId && ClientCtxt->Subnet != Subnet ) {
            Error = MemArrayNextLoc(&(ClientCtxt->Server->Subnets), &Loc);
            continue;
        }

        if( Subnet->SuperScopeId == SScopeId ) {
            UID = NULL;
            Error = DhcpMakeClientUID(
                RawHwAddr,
                RawHwAddrSize,
                0 /* hardware type is hardcoded anyways.. */,
                Subnet->Address,
                &UID,
                &UIDSize
            );
            if( ERROR_SUCCESS != Error ) return Error;

            LOCK_DATABASE();
            Error = DhcpJetOpenKey(
                DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColName,
                UID,
                UIDSize
            );
            DhcpFreeMemory(UID);
            if( ERROR_SUCCESS == Error ) {
                Size = sizeof(DHCP_IP_ADDRESS);
                Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                    desiredIpAddress,
                    &Size
                );
                if( ERROR_SUCCESS == Error ) {
                    DhcpAssert(((*desiredIpAddress) & Subnet->Mask) == Subnet->Address);
                    UNLOCK_DATABASE();
                    return DhcpGetSubnetForAddress(
                        *desiredIpAddress,
                        ClientCtxt
                    );
                }
            }
            UNLOCK_DATABASE();
        }

        Error = MemArrayNextLoc(&(ClientCtxt->Server->Subnets), &Loc);
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
DhcpRequestSomeAddress(                                // get some address in this context
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    OUT     DHCP_IP_ADDRESS       *desiredIpAddress,
    IN      BOOL                   fBootp
) //EndExport(function)
{
    static BOOL                    DhcpRangeFull = FALSE;
    static BOOL                    BootpRangeFull = FALSE;
    BOOL                           Result;
    PM_SUBNET                      Subnet;
    DWORD                          Error;
    LPWSTR                         ScopeName;

    *desiredIpAddress = 0;

    if( ClientCtxt->Subnet->fSubnet == TRUE &&
        FALSE == MemSubnetCheckBootpDhcp(ClientCtxt->Subnet, fBootp, TRUE ) ) {
        //
        // For DHCP Scopes, check to see if any required type of addreses
        // are present.. If not, return error saying none available.
        // No such checks for MADCAP Scopes.
        //
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }


    LOCK_MEMORY();
    Result = MemSubnetRequestAddress(
        ClientCtxt->Subnet,
        0,
        TRUE, /* also acquire the address */
        fBootp, /* asking for dynamic bootp address? */
        desiredIpAddress,
        &Subnet
    );
    UNLOCK_MEMORY();
    if( Result ) {
        DhcpAssert(*desiredIpAddress && Subnet);
        ClientCtxt->Subnet = Subnet;
        Error = MemSubnetGetAddressInfo(
            Subnet,
            *desiredIpAddress,
            &(ClientCtxt->Range),
            &(ClientCtxt->Excl),
            &(ClientCtxt->Reservation)
        );
        DhcpAssert(ERROR_SUCCESS == Error);
        if( fBootp ) {
            BootpRangeFull = FALSE;
        } else {
            DhcpRangeFull = FALSE;
        }
        return Error;
    }

    if( FALSE == (fBootp? BootpRangeFull : DhcpRangeFull) ) {
        //
        // avoid repeated logging..
        //

        if( fBootp ) {
            BootpRangeFull = TRUE; 
        }
        else {
            DhcpRangeFull = TRUE;
        }

        // Use the superscope name if the subnet is in a superscope
        if (( FALSE == ClientCtxt->Subnet->fSubnet ) ||
            ( 0 == ClientCtxt->Subnet->SuperScopeId )) {
            ScopeName = ClientCtxt->Subnet->Name;
        }
        else {
            PM_SSCOPE SScope = NULL;
          
            Error = MemServerFindSScope( ClientCtxt->Server, 
                                         ClientCtxt->Subnet->SuperScopeId,
                                         NULL, &SScope );
            Require( ERROR_SUCCESS == Error );
            Require( NULL != SScope );
            ScopeName = SScope->Name;

        } // else

        if ( fBootp ) {
            DhcpReportEventW( DHCP_EVENT_SERVER, EVENT_SERVER_BOOTP_FULL,
                              EVENTLOG_WARNING_TYPE,
                              1, 0, &ScopeName, NULL );
        }
        else {
            DhcpReportEventW( DHCP_EVENT_SERVER, EVENT_SERVER_SCOPE_FULL,
                              EVENTLOG_WARNING_TYPE,
                              1, 0, &ScopeName, NULL );
        }
    } // if

    return ERROR_DHCP_RANGE_FULL;
}

//BeginExport(function)
BOOL
DhcpSubnetInSameSuperScope(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        IpAddress2
)   //EndExport(function)
{
    ULONG                          SubnetMask, SubnetAddress, Error;
    PM_SUBNET                      Subnet2;

    DhcpSubnetGetSubnetAddressAndMask(
        Subnet,
        &SubnetAddress,
        &SubnetMask
    );

    if( (IpAddress2 & SubnetMask ) == SubnetAddress ) return TRUE;

    Error = MemServerGetAddressInfo(
        DhcpGlobalThisServer,
        IpAddress2,
        &Subnet2,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return FALSE;

    // --ft: Addresses are in the same superscope if in the same subnet or if there is a
    // superscope and both subnets belong to it. (Subnets out of a superscope have SuperScopeId == 0)

    if (Subnet == Subnet2 ) return TRUE;

    return (Subnet->SuperScopeId == Subnet2->SuperScopeId) && ( 0 != Subnet->SuperScopeId );
}

//BeginExport(function)
BOOL
DhcpInSameSuperScope(
    IN      DHCP_IP_ADDRESS        Address1,
    IN      DHCP_IP_ADDRESS        Address2
) //EndExport(function)
{
    PM_SUBNET                      Subnet;
    DWORD                          Error;

    if( !DhcpGlobalThisServer ) return FALSE;

    Error = MemServerGetAddressInfo(
        DhcpGlobalThisServer,
        Address1,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return FALSE;

    return DhcpSubnetInSameSuperScope(Subnet, Address2);
}

//BeginExport(function)
BOOL
DhcpAddressIsOutOfRange(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    IN      BOOL                   fBootp
) //EndExport(function)
{
    return MemServerIsOutOfRangeAddress(ClientCtxt->Server, Address, fBootp);
}

//BeginExport(function)
BOOL
DhcpAddressIsExcluded(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt
) //EndExport(function)
{
    return MemServerIsExcludedAddress(ClientCtxt->Server, Address);
}

//BeginExport(function)
BOOL
DhcpRequestSpecificAddress(
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;

    Error = MemServerGetAddressInfo(
        ClientCtxt->Server,
        Address,
        &(ClientCtxt->Subnet),
        &(ClientCtxt->Range),
        &(ClientCtxt->Excl),
        &(ClientCtxt->Reservation)
    );

    if( ERROR_SUCCESS != Error || !ClientCtxt->Range || ClientCtxt->Excl )
        return FALSE;

    LOCK_MEMORY();
    Error = MemSubnetRequestAddress(
        ClientCtxt->Subnet,
        Address,
        TRUE,
        FALSE,
        NULL,
        NULL
    );
    UNLOCK_MEMORY();

    if( TRUE != Error )
        return FALSE;
    return TRUE;
}

VOID
LogReleaseAddress(
    IN DHCP_IP_ADDRESS Address
    )
{
    //
    // For DBG builds alone, just print the fact that an
    // IP address got released..
    //
#if DBG
    DhcpUpdateAuditLog(
        DHCP_IP_LOG_DELETED,
        GETSTRING( DHCP_IP_LOG_DELETED_NAME ),
        Address,
        NULL,
        0,
        L"IPAddr Released"
        );
#endif
}

//BeginExport(function)
DWORD
DhcpReleaseBootpAddress(
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;

    LOCK_MEMORY();
    Error = MemServerReleaseAddress(
        DhcpGlobalThisServer,
        Address,
        TRUE
        );
    UNLOCK_MEMORY();

    if( ERROR_SUCCESS == Error ) LogReleaseAddress(Address);
    return Error;
}

//BeginExport(function)
DWORD
DhcpReleaseAddress(
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;

    LOCK_MEMORY();
    Error = MemServerReleaseAddress(
        DhcpGlobalThisServer,
        Address,
        FALSE
    );
    UNLOCK_MEMORY();

    if( ERROR_SUCCESS == Error ) LogReleaseAddress(Address);
    return Error;
}

//BeginExport(function)
DWORD
DhcpServerGetSubnetCount(
    IN      PM_SERVER              Server
) //EndExport(function)
{
    return Server?MemArraySize(&(Server->Subnets)):0;
}

//BeginExport(function)
DWORD
DhcpServerGetMScopeCount(
    IN      PM_SERVER              Server
) //EndExport(function)
{
    return Server?MemArraySize(&(Server->MScopes)):0;
}

//BeginExport(function)
DWORD
DhcpServerGetClassId(
    IN      PM_SERVER              Server,
    IN      LPBYTE                 ClassIdBytes,
    IN      DWORD                  nClassIdBytes
) //EndExport(function)
{
    PM_CLASSDEF                    ClassDef;
    DWORD                          Error;

    if( NULL == ClassIdBytes || 0 == nClassIdBytes )
        return 0;

    Error = MemServerGetClassDef(
        Server,
        0,
        NULL,
        nClassIdBytes,
        ClassIdBytes,
        &ClassDef
    );
    if( ERROR_SUCCESS != Error ) return 0;
    if( TRUE == ClassDef->IsVendor ) return 0;
    return ClassDef->ClassId;
}

//BeginExport(function)
DWORD
DhcpServerGetVendorId(
    IN      PM_SERVER              Server,
    IN      LPBYTE                 VendorIdBytes,
    IN      DWORD                  nVendorIdBytes
) //EndExport(function)
{
    PM_CLASSDEF                    ClassDef;
    DWORD                          Error;

    if( NULL == VendorIdBytes || 0 == nVendorIdBytes )
        return 0;

    Error = MemServerGetClassDef(
        Server,
        0,
        NULL,
        nVendorIdBytes,
        VendorIdBytes,
        &ClassDef
    );
    if( ERROR_SUCCESS != Error ) return 0;
    if( FALSE == ClassDef->IsVendor ) return 0;
    return ClassDef->ClassId;
}

//BeginExport(function)
BOOL
DhcpServerIsAddressReserved(
    IN      PM_SERVER              Server,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    return MemServerIsReservedAddress(Server,Address);
}

//BeginExport(function)
BOOL
DhcpServerIsAddressOutOfRange(
    IN      PM_SERVER              Server,
    IN      DHCP_IP_ADDRESS        Address,
    IN      BOOL                   fBootp
) //EndExport(function)
{
    DWORD                          Error;
    PM_RANGE                       Range;
    PM_EXCL                        Excl;

    Error = MemServerGetAddressInfo(
        Server,
        Address,
        NULL,
        &Range,
        &Excl,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return TRUE;

    if( Excl || NULL == Range ) return TRUE;
    if( 0 == (Range->State & (fBootp? MM_FLAG_ALLOW_BOOTP : MM_FLAG_ALLOW_DHCP) ) ) {
        return TRUE;
    }
    return FALSE;
}

//BeginExport(function)
BOOL
DhcpSubnetIsAddressExcluded(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;
    PM_EXCL                        Excl;

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Address,
        NULL,
        &Excl,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return FALSE;
    return NULL != Excl;
}

//BeginExport(function)
BOOL
DhcpSubnetIsAddressOutOfRange(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address,
    IN      BOOL                   fBootp
) //EndExport(function)
{
    DWORD                          Error;
    PM_RANGE                       Range;
    PM_EXCL                        Excl;
    PM_RESERVATION                 Resv;

    //
    // passing exclusion and resvation info to check if the address is ok.
    //

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Address,
        &Range,
        &Excl,
        &Resv 
    );

    if( ERROR_SUCCESS != Error ) return TRUE;
    if( NULL == Range ) return TRUE;
    if( 0 == (Range->State & (fBootp? MM_FLAG_ALLOW_BOOTP : MM_FLAG_ALLOW_DHCP) ) ) {
        return TRUE;
    }
    return FALSE;
}

//BeginExport(function)
BOOL
DhcpSubnetIsAddressReserved(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;
    PM_RESERVATION                 Reservation;

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Address,
        NULL,
        NULL,
        &Reservation
    );

    if( ERROR_SUCCESS == Error && NULL != Reservation )
        return TRUE;

    return FALSE;
}

static const
DWORD                              TryThreshold = 5;
//BeginExport(function)
DWORD
DhcpRegFlushServerIfNeeded(
    VOID
) //EndExport(function)
{
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpFlushBitmaps(                                 // do a flush of all bitmaps that have changed
    VOID
) //EndExport(function)
{

    return FlushBitmaskToDatabase();
}

//BeginExport(function)
DWORD
DhcpServerFindMScope(
    IN      PM_SERVER              Server,
    IN      DWORD                  ScopeId,
    IN      LPWSTR                 Name,          // Multicast scope name or NULL if this is not the key to search on
    OUT     PM_MSCOPE             *MScope
) //EndExport(function)
{
    return MemServerFindMScope(
        Server,
        ScopeId,
        Name,
        MScope
    );
}


//BeginExport(function)
BOOL
DhcpServerValidateNewMScopeId(
    IN      PM_SERVER               Server,
    IN      DWORD                   MScopeId
) //EndExport(function)
{
    PM_SUBNET   pMScope;
    DWORD       Error;

    Error = MemServerFindMScope(
                Server,
                MScopeId,
                INVALID_MSCOPE_NAME,
                &pMScope
                );

    if ( ERROR_SUCCESS == Error ) {
        return FALSE;
    } else {
        DhcpAssert( ERROR_FILE_NOT_FOUND == Error );
        return TRUE;
    }
}

//BeginExport(function)
BOOL
DhcpServerValidateNewMScopeName(
    IN      PM_SERVER               Server,
    IN      LPWSTR                  Name
) //EndExport(function)
{
    PM_SUBNET   pMScope;
    DWORD       Error;

    Error = MemServerFindMScope(
                Server,
                INVALID_MSCOPE_ID,
                Name,
                &pMScope
                );

    if ( ERROR_SUCCESS == Error ) {
        return FALSE;
    } else {
        DhcpAssert( ERROR_FILE_NOT_FOUND == Error );
        return TRUE;
    }
}


//BeginExport(function)
DWORD
DhcpMScopeReleaseAddress(
    IN      DWORD                  MScopeId,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      pMScope;

    Error = DhcpServerFindMScope(
        DhcpGetCurrentServer(),
        MScopeId,
        NULL, /* scope name */
        &pMScope
        );
    if ( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Could not find MScope object - id %lx, %ld\n", MScopeId, Error));
        return Error;
    }

    LOCK_MEMORY();
    Error = MemSubnetReleaseAddress(
        pMScope,
        Address,
        FALSE
    );
    UNLOCK_MEMORY();

    if( ERROR_SUCCESS == Error ) LogReleaseAddress(Address);
    return Error;
}

//BeginExport(function)
DWORD
DhcpSubnetRequestSpecificAddress(
    PM_SUBNET            Subnet,
    DHCP_IP_ADDRESS      IpAddress
) //EndExport(function)
{
    DWORD   Error;

    LOCK_MEMORY();
    Error = MemSubnetRequestAddress(
           Subnet,
           IpAddress,
           TRUE,
           FALSE,
           NULL,
           NULL
    );
    UNLOCK_MEMORY();
    return Error;
}

//BeginExport(function)
DWORD
DhcpSubnetReleaseAddress(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;

    LOCK_MEMORY();
    Error = MemSubnetReleaseAddress(
        Subnet,
        Address,
        FALSE
    );
    UNLOCK_MEMORY();

    if( ERROR_SUCCESS == Error ) LogReleaseAddress(Address);
    return Error;
}

//BeginExport(function)
DWORD
MadcapGetMScopeListOption(
    IN      DHCP_IP_ADDRESS         ServerIpAddress,
    OUT     LPBYTE                 *OptVal,
    IN OUT  WORD                   *OptSize
) //EndExport(function)
{
    PM_SERVER                       pServer;
    PM_SUBNET                       pScope = NULL;
    ARRAY_LOCATION                  Loc;
    WORD                            TotalScopeDescLen;
    WORD                            ScopeCount;
    DWORD                           Error;
    WORD                            TotalSize;
    PBYTE                           pBuf,pScopeBuf;
    WORD                            DbgScopeCount = 0;

    pServer = DhcpGetCurrentServer();

    Error = MemArrayInitLoc(&(pServer->MScopes), &Loc);
    if ( ERROR_FILE_NOT_FOUND == Error ) {
        return Error;
    }

    // First find out how much memory do we need.
    ScopeCount = TotalScopeDescLen = 0;
    while ( ERROR_FILE_NOT_FOUND != Error ) {

        Error = MemArrayGetElement(&(pServer->MScopes), &Loc, (LPVOID *)&pScope);
        DhcpAssert(ERROR_SUCCESS == Error);

        if (!IS_DISABLED(pScope->State)) {
            if (pScope->Name) {
                TotalScopeDescLen += (WORD) ConvertUnicodeToUTF8(pScope->Name, -1, NULL, 0 );
                // add for the lang tag, flags, name length etc.
                TotalScopeDescLen += (3 + wcslen(pScope->LangTag));

            }
            ScopeCount++;
        }

        Error = MemArrayNextLoc(&(pServer->MScopes), &Loc);
    }

    if (!ScopeCount) {
        return ERROR_FILE_NOT_FOUND;
    }
    // MBUG - assumes IPv4
    TotalSize = 1 // scope count
                + ScopeCount * ( 10 ) // scope id, last addr, TTL, name count
                + TotalScopeDescLen; // all the descriptor.

    pScopeBuf = DhcpAllocateMemory( TotalSize );

    if ( !pScopeBuf ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( pScopeBuf, TotalSize );

    pBuf = pScopeBuf;
    // store the scope count
    *pBuf++ = (BYTE)ScopeCount;

    // now for each scope store the id and the descriptor.
    Error = MemArrayInitLoc(&(pServer->MScopes), &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);

    while ( ERROR_FILE_NOT_FOUND != Error ) {
        LPSTR   pDesc;
        BYTE    DescLen;
        DWORD   LastAddr;

        Error = MemArrayGetElement(&(pServer->MScopes), &Loc, (LPVOID *)&pScope);
        DhcpAssert(ERROR_SUCCESS == Error);


        if (!IS_DISABLED(pScope->State)) {
            PM_RANGE    Range = NULL;
            ARRAY_LOCATION  LastLoc = 0;

            *(DWORD UNALIGNED *)pBuf = htonl(pScope->MScopeId);
            pBuf += 4;
            // store last address
            Error = MemArrayLastLoc(&(pScope->Ranges), &LastLoc);
            if (ERROR_SUCCESS == Error) {
                Error = MemArrayGetElement(&(pScope->Ranges), &LastLoc, &Range);
                DhcpAssert(ERROR_SUCCESS == Error);
                LastAddr = htonl(Range->End);
            } else {
                LastAddr = htonl(pScope->MScopeId);
            }
            *(DWORD UNALIGNED *)pBuf = LastAddr;
            pBuf += 4;
            // store the ttl
            *pBuf++ = pScope->TTL;
            // name count
            *pBuf++ = 1;


            if ( pScope->Name ) {
                char    LangTag[80];
                // Name flags
                *pBuf++ = 128;
                // Language tag
                DhcpAssert(pScope->LangTag);
                if (NULL == DhcpUnicodeToOem(pScope->LangTag, LangTag) ) {
                    DhcpFreeMemory( pScopeBuf );
                    return ERROR_INVALID_DATA;
                }
                *pBuf++ = (BYTE)strlen(LangTag);
                memcpy(pBuf, LangTag, strlen(LangTag));
                pBuf += strlen(LangTag);
                TotalScopeDescLen -= (3 + strlen(LangTag));
                pDesc = pBuf + 1;
                if ( 0 == (DescLen = (BYTE) ConvertUnicodeToUTF8(pScope->Name, -1, pDesc, TotalScopeDescLen) ) ) {
                    DhcpFreeMemory( pScopeBuf );
                    return ERROR_BAD_FORMAT;
                }
                TotalScopeDescLen -= DescLen;
            } else {
                DescLen = 0;
            }
            *pBuf++ = DescLen;
            pBuf += DescLen;
#ifdef DBG
            DbgScopeCount++;
#endif
        }

        Error = MemArrayNextLoc(&(pServer->MScopes), &Loc);
    }

    DhcpAssert( ScopeCount == DbgScopeCount );

    *OptVal = pScopeBuf;
    *OptSize = TotalSize;

    return ERROR_SUCCESS;
}

//BeginExport(function)
BOOL
DhcpRequestSpecificMAddress(
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;

    Error = MemSubnetGetAddressInfo(
        ClientCtxt->Subnet,
        Address,
        &(ClientCtxt->Range),
        &(ClientCtxt->Excl),
        &(ClientCtxt->Reservation)
    );

    if( ERROR_SUCCESS != Error || !ClientCtxt->Range || ClientCtxt->Excl )
        return FALSE;

    LOCK_MEMORY();
    Error = MemSubnetRequestAddress(
        ClientCtxt->Subnet,
        Address,
        TRUE,
        FALSE,
        NULL,
        NULL
    );
    UNLOCK_MEMORY();

    if( ERROR_SUCCESS != Error )
        return FALSE;
    return TRUE;
}

//BeginExport(function)
BOOL
DhcpMScopeIsAddressReserved(
    IN      DWORD                   MScopeId,
    IN      DHCP_IP_ADDRESS         Address
) //EndExport(function)
{
    return FALSE;
}

//BeginExport(function)
BOOL
DhcpIsSubnetStateDisabled(
    IN ULONG SubnetState
)   //EndExport(function)
{
    return IS_DISABLED(SubnetState);
}


// This function returns TRUE if the subnet address in question does not exist in
// the list of subnets for the current server.  This SHOULD NOT BE CALLED with the
// Read/Write lock taken as the lock is taken right here.
//BeginExport(function)
BOOL
DhcpServerIsNotServicingSubnet(
    IN      DWORD                   IpAddressInSubnet
)   //EndExport(function)
{

    DWORD                           Mask;

    DhcpAcquireReadLock();

    Mask = DhcpGetSubnetMaskForAddress(IpAddressInSubnet);

    DhcpReleaseReadLock();

    return Mask == 0;
}

VOID        _inline
ConvertHostToNetworkString(
    IN      LPWSTR                  String,
    IN      ULONG                   NChars
)
{
    while(NChars--) {
        *String = htons(*String);
        String ++;
    }
}

// this function takes a class def and converts it into packs into a buffer as follows
// [size-hi] [size-lo] class-id-bytes [size-hi] [size-lo] name [size-hi] [lo] descr
// where name and descr are LPWSTR (nul terminated) that are just copied over..
VOID
ConvertClassDefToWireFormat(
    IN      PM_CLASSDEF             ClassDef,
    OUT     LPBYTE                 *Buf,          // allocated by this function
    OUT     DWORD                  *BufSize       // size allocated by this function
)
{
    DWORD                           Size;
    LPBYTE                          Mem;

    *Buf = NULL; *BufSize = 0;
    Size = 6+ ((3+ClassDef->nBytes)&~3)           // round off nbytes by "4"
        + sizeof(WCHAR)*(1+wcslen(ClassDef->Name));
    if( NULL == ClassDef->Comment ) Size += sizeof(WCHAR);
    else Size += sizeof(WCHAR)*(1+wcslen(ClassDef->Comment));

    Mem = DhcpAllocateMemory(Size);
    if( NULL == Mem ) return ;

    *Buf = Mem; *BufSize = Size;
    Mem[0] = (BYTE)(ClassDef->nBytes >> 8) ;
    Mem[1] = (BYTE)(ClassDef->nBytes & 0xFF);
    Mem += 2;
    memcpy(Mem, ClassDef->ActualBytes, ClassDef->nBytes);
    Mem += (ClassDef->nBytes+3)&~3;               // round off to multiple of "4"
    Size = sizeof(WCHAR)*(1+wcslen(ClassDef->Name));
    Mem[0] = (BYTE)(Size>>8);
    Mem[1] = (BYTE)(Size&0xFF);
    Mem += 2;
    memcpy(Mem, (LPBYTE)(ClassDef->Name), Size);
    ConvertHostToNetworkString((LPWSTR)Mem, Size/2);
    Mem += Size;
    if( NULL == ClassDef->Comment ) {
        Mem[0] = 0; Mem[1] = sizeof(WCHAR);
        Mem += 2; memset(Mem, 0, sizeof(WCHAR));
        Mem += sizeof(WCHAR);
    } else {
        Size = sizeof(WCHAR)*(1+wcslen(ClassDef->Comment));
        Mem[0] = (BYTE)(Size>>8);
        Mem[1] = (BYTE)(Size&0xFF);
        Mem += 2;
        memcpy(Mem, (LPBYTE)(ClassDef->Comment), Size);
        ConvertHostToNetworkString((LPWSTR)Mem, Size/2);
        Mem += Size;
    }
}

//BeginExport(function)
// This function tries to create a list of all classes (wire-class-id, class name, descr)
// and send this as an option. but since the list can be > 255 it has to be make a continuation...
// and also, we dont want the list truncated somewhere in the middle.. so we try to append
// information for each class separately to see if it succeeds..
LPBYTE
DhcpAppendClassList(
    IN OUT  LPBYTE                  BufStart,
    IN OUT  LPBYTE                  BufEnd
) //EndExport(function)
{
    PARRAY                          ClassDefList;
    ARRAY_LOCATION                  Loc;
    PM_CLASSDEF                     ThisClassDef = NULL;
    DWORD                           Result, Size;
    LPBYTE                          Buf;

    ClassDefList = &(DhcpGetCurrentServer()->ClassDefs.ClassDefArray);
    for( Result = MemArrayInitLoc(ClassDefList, &Loc)
         ;  ERROR_FILE_NOT_FOUND != Result ;
         Result = MemArrayNextLoc(ClassDefList, &Loc)
    ) {                                           // walk thru the array and add classes..
        Result = MemArrayGetElement(ClassDefList, &Loc, (LPVOID)&ThisClassDef);
        DhcpAssert(ERROR_SUCCESS == Result && NULL != ThisClassDef);

        if( ThisClassDef->IsVendor ) continue;    // don't list vendor classes

        Buf = NULL; Size = 0;
        ConvertClassDefToWireFormat(ThisClassDef, &Buf, &Size);
        if( NULL == Buf || 0 == Size ) {          // some error.. could not convert this class.. ignore..
            DhcpAssert(FALSE);
            continue;
        }

        BufStart = (LPBYTE)DhcpAppendOption(
            (LPOPTION)BufStart,
            OPTION_USER_CLASS,
            (PVOID)Buf,
            Size,
            (LPVOID)BufEnd
        );
        DhcpFreeMemory(Buf);
    }

    return BufStart;
}


//BeginExport(function)
DWORD
DhcpMemInit(
    VOID
) //EndExport(function)
{
#if DBG_MEM
    return MemInit();
#else
    return ERROR_SUCCESS;
#endif
}

//BeginExport(function)
VOID
DhcpMemCleanup(
    VOID
) //EndExport(function)
{
#if DBG_MEM
    MemCleanup();
#endif
}

ULONG       DhcpGlobalMemoryAllocated = 0;

#if  DBG_MEM
#undef DhcpAllocateMemory
#undef DhcpFreeMemory
LPVOID
DhcpAllocateMemory(
    IN      DWORD                  nBytes
)
{
    DWORD                          SizeBytes = ROUND_UP_COUNT(sizeof(DWORD),ALIGN_WORST);
    LPDWORD                        RetVal;

    DhcpAssert(nBytes != 0);
    RetVal = MemAlloc(nBytes+SizeBytes);
    if( NULL == RetVal ) return NULL;

    *RetVal = nBytes+SizeBytes;
    InterlockedExchangeAdd(&DhcpGlobalMemoryAllocated, nBytes+SizeBytes);
    return SizeBytes + (LPBYTE)RetVal;
}

VOID
DhcpFreeMemory(
    IN      LPVOID                 Ptr
)
{
    DWORD                          Result;
    LONG                           Size;

    if( NULL == Ptr ) {
        Require(FALSE);
        return;
    }

    Ptr = ((LPBYTE)Ptr) - ROUND_UP_COUNT(sizeof(DWORD), ALIGN_WORST);
    Size = *((LPLONG)Ptr);

    Result = MemFree(Ptr);
    DhcpAssert(ERROR_SUCCESS == Result);
    InterlockedExchangeAdd(&DhcpGlobalMemoryAllocated, -Size);
}
#endif  DBG

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\pendingc.c ===
//================================================================================
// Copyright (c) 1997 Microsoft Corporation
// Author: RameshV
// Description: deals with the pending context list structures used to shortcircuit
// expensive lookups and searches..
//================================================================================
#include <dhcppch.h>
#include <mdhcpsrv.h>
#include <align.h>

//BeginExport(typedef)
#ifndef     PENDING_CTXT_DEFINED
#define     PENDING_CTXT_DEFINED
typedef struct _DHCP_PENDING_CTXT {               // this is what is stored for each pending client
    LIST_ENTRY                     BucketList;    // entry in the bucket (hash list)
    LIST_ENTRY                     GlobalList;    // list of ALL pending contexts in FIFO order
    LPBYTE                         RawHwAddr;     // raw hw address, not UID as created by us
    DWORD                          nBytes;        // size of above in bytes
    DWORD                          Address;       // offered address
    DWORD                          LeaseDuration; // how long did we offer before?
    DWORD                          T1, T2;        // old offered T1 and T2
    DWORD                          MScopeId;      // MScopeId this address was offered from.
    DATE_TIME                      ExpiryTime;    // when should this context be expired?
    BOOL                           Processing;    // is this being processed?
} DHCP_PENDING_CTXT, *PDHCP_PENDING_CTXT, *LPDHCP_PENDING_CTXT;
typedef     LIST_ENTRY             PENDING_CTXT_SEARCH_HANDLE;
typedef     PLIST_ENTRY            PPENDING_CTXT_SEARCH_HANDLE;
typedef     PLIST_ENTRY            LPPENDING_CTXT_SEARCH_HANDLE;
#endif      PENDING_CTXT_DEFINED
//EndExport(typedef)

#define     HASH_SIZE              512            // hash table of size 255 bytes
LIST_ENTRY                         PendingList;
LIST_ENTRY                         Buckets[HASH_SIZE];
DWORD                              nPendingReqs = 0;
const       DWORD                  MaxPendingRequests = 1000;
static      DWORD                  Initialized = 0;
#if DBG
DWORD                              nBytesAllocatedForPendingRequests = 0;
#endif

DWORD       _inline
CalculateHashValue(
    IN      LPBYTE                 RawHwAddr,
    IN      DWORD                  nBytes
) {
    ULONG                          RetVal = 0;
    while( nBytes >= sizeof(DWORD) ) {
        RetVal += *((DWORD UNALIGNED*)RawHwAddr) ++;
        nBytes -= sizeof(DWORD);
    }
    while( nBytes-- ) RetVal += *RawHwAddr++;
    return RetVal % HASH_SIZE;
}

//BeginExport(function)
DWORD
DhcpFindPendingCtxt(                              // find if a pending context exists (srch by ip address or hw addr)
    IN      LPBYTE                 RawHwAddr,     // OPTIONAL the hw addr to use for search
    IN      DWORD                  RawHwAddrSize, // OPTIONAL size of above in bytes
    IN      DWORD                  Address,       // OPTIONAL the address to search for
    OUT     PDHCP_PENDING_CTXT    *Ctxt
) //EndExport(function)
{
    DWORD                          Hash;
    PLIST_ENTRY                    List, ThisEntry;

    DhcpAssert( RawHwAddrSize != 0 && Address == 0 || RawHwAddrSize == 0 && Address != 0 );

    if( 0 == RawHwAddrSize ) {                    // this search is global
        List = &PendingList;
    } else {
        Hash = CalculateHashValue(RawHwAddr, RawHwAddrSize );
        DhcpAssert( Hash < HASH_SIZE);

        List = &Buckets[Hash];
    }

    ThisEntry = List->Flink;
    while( ThisEntry != List ) {
        if( RawHwAddrSize ) {                     // looking in bucket list
            *Ctxt = CONTAINING_RECORD( ThisEntry, DHCP_PENDING_CTXT, BucketList );
            if( (*Ctxt)->nBytes == RawHwAddrSize )
                if( 0 == memcmp(RawHwAddr, (*Ctxt)->RawHwAddr, RawHwAddrSize) )
                    return ERROR_SUCCESS;
        } else {                                  // looking in global list
            *Ctxt = CONTAINING_RECORD( ThisEntry, DHCP_PENDING_CTXT, GlobalList );
            if( Address == (*Ctxt)->Address )
                return ERROR_SUCCESS;
        }

        ThisEntry = ThisEntry->Flink;
    }

    *Ctxt = NULL;
    return ERROR_FILE_NOT_FOUND;
}

DWORD
DhcpRemoveMatchingCtxt(
    IN DWORD                       Mask,
    IN DWORD                       Address
)
{
    PDHCP_PENDING_CTXT             Ctxt;
    PLIST_ENTRY                    ThisEntry;

    ThisEntry = PendingList.Flink;
    while( ThisEntry != &PendingList )
    {
        Ctxt = CONTAINING_RECORD( ThisEntry, DHCP_PENDING_CTXT, GlobalList );
        ThisEntry = ThisEntry->Flink;
        if ((Ctxt->Address & Mask) == Address)
        {
            DhcpRemovePendingCtxt( Ctxt );
            DhcpFreeMemory(Ctxt);
        }
    }
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRemovePendingCtxt(                            // remove a ctxt from the pending ctxt list
    IN OUT  PDHCP_PENDING_CTXT     Ctxt
) //EndExport(function)
{
    DhcpAssert(!IsListEmpty(&Ctxt->BucketList));
    DhcpAssert(!IsListEmpty(&Ctxt->GlobalList));

    RemoveEntryList(&Ctxt->BucketList);           // remove from the bucket
    RemoveEntryList(&Ctxt->GlobalList);           // remove from the global list

    InitializeListHead(&Ctxt->BucketList);
    InitializeListHead(&Ctxt->GlobalList);

    nPendingReqs--;

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpAddPendingCtxt(                               // add a new pending ctxt
    IN      LPBYTE                 RawHwAddr,     // raw bytes that form the hw address
    IN      DWORD                  nBytes,        // size of above in bytes
    IN      DWORD                  Address,       // offered address
    IN      DWORD                  LeaseDuration, // how long did we offer before?
    IN      DWORD                  T1,            // old offered T1
    IN      DWORD                  T2,            // old offered T2
    IN      DWORD                  MScopeId,      // the multicast scope id of offered address.
    IN      DATE_TIME              ExpiryTime,    // how long to keep the pending ctxt?
    IN      BOOL                   Processing     // is this context still being processed?
) //EndExport(function)
{
    PDHCP_PENDING_CTXT             Ctxt;
    DWORD                          Result;
    DWORD                          Size;
    DWORD                          Hash;
    PLIST_ENTRY                    Entry;


    DhcpAssert( !CLASSD_HOST_ADDR( Address ) || MScopeId != 0 );

    if( nPendingReqs < MaxPendingRequests ) {
    } else {                                      // not enough space for a pending context.. make space
        // evict the last non-busy Pending context.
        Entry = PendingList.Blink;
        while ( Entry != &PendingList ) {
            Ctxt = CONTAINING_RECORD(Entry, DHCP_PENDING_CTXT, GlobalList);
            if ( FALSE == Ctxt->Processing ) {
                Result = DhcpRemovePendingCtxt(Ctxt);
                if( ERROR_SUCCESS != Result ) {
                    DhcpAssert(FALSE);
                    return Result;
                }
                if ( CLASSD_HOST_ADDR( Ctxt->Address )) {
                    Result = MadcapDeletePendingCtxt(Ctxt);
                }
                else {
                    Result = DhcpDeletePendingCtxt( Ctxt );
                }
                break;
            } // if free
            else {
                Entry = Entry->Blink;
            }
        } // while
        // Require(ERROR_SUCCESS == Result);
    }

    Size = sizeof(*Ctxt) + nBytes ;
    Ctxt = DhcpAllocateMemory(Size);
    if( NULL == Ctxt ) return ERROR_NOT_ENOUGH_MEMORY;

    nPendingReqs ++;                          // we are adding one more pending context
    Ctxt->RawHwAddr = sizeof(*Ctxt) + (LPBYTE)Ctxt;
    memcpy(Ctxt->RawHwAddr, RawHwAddr, nBytes);
    Ctxt->nBytes = nBytes;
    Ctxt->LeaseDuration = LeaseDuration;
    Ctxt->T1 = T1;
    Ctxt->T2 = T2;
    Ctxt->Address = Address;
    Ctxt->MScopeId = MScopeId;
    Ctxt->Processing = Processing;
    Ctxt->ExpiryTime = ExpiryTime;

    Hash = CalculateHashValue(RawHwAddr, nBytes);
    DhcpAssert( Hash < HASH_SIZE);

    InsertHeadList(&Buckets[Hash], &Ctxt->BucketList);
    InsertHeadList(&PendingList, &Ctxt->GlobalList);
#if DBG
    nBytesAllocatedForPendingRequests += sizeof(*Ctxt) + Ctxt->nBytes;
#endif

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpDeletePendingCtxt(
    IN OUT  PDHCP_PENDING_CTXT     Ctxt
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    BYTE                           State;
    BOOL                           OkToRelease;

    DhcpAssert(IsListEmpty(&Ctxt->BucketList));   // must have been taken off the buckets
    DhcpAssert(IsListEmpty(&Ctxt->GlobalList));   // must have been taken off the buckets

    LOCK_DATABASE();
    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        &(Ctxt->Address),
        sizeof(Ctxt->Address)
    );
    if( ERROR_SUCCESS != Error ) {
        OkToRelease = TRUE;                       // ok to release address with no db entry
    } else {
        Size = sizeof(State);
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[STATE_INDEX].ColHandle,
            &State,
            &Size
        );
        if( ERROR_SUCCESS != Error || IsAddressDeleted(State) || !IS_ADDRESS_STATE_ACTIVE(State) )
            OkToRelease = TRUE;
        else OkToRelease = FALSE;
    }

    if( OkToRelease ) {
        DhcpReleaseAddress(Ctxt->Address);        // release the address -- it must be taken
    } else {
        DhcpPrint((DEBUG_ERRORS, "Address 0x%lx is not deleted from registry!\n", Ctxt->Address));
    }

    UNLOCK_DATABASE();
#if DBG
    nBytesAllocatedForPendingRequests -= sizeof(*Ctxt) + Ctxt->nBytes;
#endif
    DhcpFreeMemory(Ctxt);

    return ERROR_SUCCESS;
}

DWORD
MadcapDeletePendingCtxt(
    IN OUT  PDHCP_PENDING_CTXT     Ctxt
)
{
    DWORD                          Error;
    DWORD                          Size;
    BYTE                           State;
    BOOL                           OkToRelease;
    DB_CTX  DbCtx;


    DhcpAssert(IsListEmpty(&Ctxt->BucketList));   // must have been taken off the buckets
    DhcpAssert(IsListEmpty(&Ctxt->GlobalList));   // must have been taken off the buckets

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    LOCK_DATABASE();
    Error = MadcapJetOpenKey(
        &DbCtx,
        MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
        &(Ctxt->RawHwAddr),
        Ctxt->nBytes
        );

    if( ERROR_SUCCESS != Error ) {
        OkToRelease = TRUE;                       // ok to release address with no db entry
    } else {
        Size = sizeof(State);
        Error = MadcapJetGetValue(
            &DbCtx,
            MCAST_COL_HANDLE(MCAST_TBL_STATE),
            &State,
            &Size
        );
        if( ERROR_SUCCESS != Error || !IS_ADDRESS_STATE_ACTIVE(State) )
            OkToRelease = TRUE;
        else OkToRelease = FALSE;
    }

    if( OkToRelease ) {
        Error = DhcpMScopeReleaseAddress(Ctxt->MScopeId, Ctxt->Address);        // release the address -- it must be taken
    } else {
        DhcpPrint((DEBUG_ERRORS, "Address 0x%lx is not deleted from registry!\n", Ctxt->Address));
    }

    UNLOCK_DATABASE();
#if DBG
    nBytesAllocatedForPendingRequests -= sizeof(*Ctxt) + Ctxt->nBytes;
#endif
    DhcpFreeMemory(Ctxt);

    return ERROR_SUCCESS;
}

#define     DATE_CONV(X)           (*(ULONGLONG UNALIGNED *)(&X))

//BeginExport(function)
DWORD
DhcpDeleteExpiredCtxt(                            // all ctxt with expiration time < this will be deleted
    IN      DATE_TIME              ExpiryTime     // if this is zero, delete EVERY element
) //EndExport(function)
{
    PDHCP_PENDING_CTXT             Ctxt;
    PLIST_ENTRY                    ThisEntry;
    DWORD                          Error;

    if( 0 == Initialized ) return ERROR_SUCCESS;

    ThisEntry = PendingList.Flink;
    while( ThisEntry != &PendingList ) {
        Ctxt = CONTAINING_RECORD(ThisEntry, DHCP_PENDING_CTXT, GlobalList);
        ThisEntry = ThisEntry->Flink;

        if( (ULONGLONG)0 == DATE_CONV(ExpiryTime) ||
            DATE_CONV(Ctxt->ExpiryTime) < DATE_CONV(ExpiryTime) ) {
            DHCP_IP_ADDRESS Addr = htonl(Ctxt->Address);

            DhcpPrint((DEBUG_SCAVENGER, "Deleting pending %s\n",
                       inet_ntoa(*(struct in_addr *)&Addr) ));
            Error = DhcpRemovePendingCtxt(Ctxt);
            DhcpAssert(ERROR_SUCCESS == Error);
            if (CLASSD_HOST_ADDR(Ctxt->Address)) {
                Error = MadcapDeletePendingCtxt(Ctxt);
            } else {
                Error = DhcpDeletePendingCtxt(Ctxt);
            }
            DhcpAssert(ERROR_SUCCESS == Error);
        } else {
            DHCP_IP_ADDRESS Addr = htonl(Ctxt->Address);

            DhcpPrint((DEBUG_SCAVENGER, "Not deleting pending %s\n",
                       inet_ntoa(*(struct in_addr *)&Addr) ));
        }
    }

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpCountIPPendingCtxt(                             // find the # of pending ctxt in given subnet
    IN      DWORD                  SubnetAddress,
    IN      DWORD                  SubnetMask
) //EndExport(function)
{
    DWORD                          Count;
    PDHCP_PENDING_CTXT             Ctxt;
    PLIST_ENTRY                    ThisEntry;

    Count = 0;
    ThisEntry = PendingList.Flink;
    while( ThisEntry != &PendingList ) {
        Ctxt = CONTAINING_RECORD(ThisEntry, DHCP_PENDING_CTXT, GlobalList);
        ThisEntry = ThisEntry->Flink;

        if( !CLASSD_HOST_ADDR(Ctxt->Address) && ((Ctxt->Address & SubnetMask) == SubnetAddress) )
            Count ++;
    }

    //
    // This assert is BOGUS as we can easily have multiple subnet's cache in this list.. so
    // it is not valid to assume total matches this..
    // DhcpAssert(nPendingReqs == Count);
    //
    return Count;
}

//BeginExport(function)
DWORD
DhcpCountMCastPendingCtxt(                             // find the # of pending ctxt in given subnet
    IN      DWORD                  MScopeId
) //EndExport(function)
{
    DWORD                          Count;
    PDHCP_PENDING_CTXT             Ctxt;
    PLIST_ENTRY                    ThisEntry;

    Count = 0;
    ThisEntry = PendingList.Flink;
    while( ThisEntry != &PendingList ) {
        Ctxt = CONTAINING_RECORD(ThisEntry, DHCP_PENDING_CTXT, GlobalList);
        ThisEntry = ThisEntry->Flink;

        if( CLASSD_HOST_ADDR(Ctxt->Address) && Ctxt->MScopeId == MScopeId )
            Count ++;
    }

    //
    // With MCAST stuff, this count isn't accurate so far as nPendingReqs
    // is concerned... So, we'll leave this alone and not ASSERT
    //
    //DhcpAssert(nPendingReqs == Count);
    //
    return Count;
}

//BeginExport(function)
DWORD
DhcpPendingListInit(                              // intialize this module
    VOID
) //EndExport(function)
{
    DWORD                          i;

    DhcpAssert(0 == Initialized);
    InitializeListHead(&PendingList);
    for( i = 0 ; i < HASH_SIZE ; i ++ )
        InitializeListHead(&Buckets[i]);

    Initialized ++;
    return ERROR_SUCCESS;
}

//BeginExport(function)
VOID
DhcpPendingListCleanup(                           // cleanup everything in this module
    VOID
) //EndExport(function)
{
    DWORD                          i;
    DWORD                          Error;
    DATE_TIME                      ZeroTime;

    if( 0 == Initialized ) return ;
    Initialized --;
    DhcpAssert(0 == Initialized);

    memset(&ZeroTime, 0, sizeof(ZeroTime));
    Error = DhcpDeleteExpiredCtxt(ZeroTime);      // delete every pending ctxt
    DhcpAssert(ERROR_SUCCESS == Error);

    nPendingReqs = 0;
#if DBG
    nBytesAllocatedForPendingRequests = 0;
#endif
    return ;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\perf.c ===
/*++

    Copyright (C) 1998 Microsoft Corporation

Module:

    perf.c

Abstract:

    This module creates the shared memory segment needed for running
    perfmon

Author:

    Ramesh V K (RameshV) 08-Aug-1998

Environment:

    User mode (Win32)


--*/

#include <dhcppch.h>
#include <aclapi.h>

#define REF_REG_KEY L"MACHINE\\System\\CurrentControlSet\\Services\\DHCPServer\\Performance"

ULONG
CopyDaclsFromRegistryToSharedMem(
    VOID
)
{
    BOOL Status;
    ULONG Error;
    PACL pDacl = NULL;
    PSID pOwnerSid = NULL;
    WCHAR String[sizeof(REF_REG_KEY)/sizeof(WCHAR)] = REF_REG_KEY;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    
    Error = GetNamedSecurityInfo(
        String,
        SE_REGISTRY_KEY,
        DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION ,
        &pOwnerSid,
        NULL,
        &pDacl,
        NULL,
        &pSecurityDescriptor
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "GetNamedSecurityInfo failed %ld\n", Error));
        return Error;
    }

    Error = SetNamedSecurityInfo(
        DHCPCTR_SHARED_MEM_NAME,
        SE_KERNEL_OBJECT,
        DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION ,
        pOwnerSid,
        NULL,
        pDacl,
        NULL
    );

    if( pSecurityDescriptor ) LocalFree (pSecurityDescriptor);

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "SetNamedSecurityInfoEx failed %ld\n", Error));
    }

    return Error;
}

BOOL fPerfInitialized = FALSE;
HANDLE PerfHandle = NULL;

ULONG
PerfInit(
    VOID
)
{
    ULONG Error;

    DhcpAssert( FALSE == fPerfInitialized );

    if( TRUE == fPerfInitialized ) return ERROR_SUCCESS;

    do {
        PerfStats = NULL;
        PerfHandle = CreateFileMapping(
            INVALID_HANDLE_VALUE,
            NULL,
            PAGE_READWRITE,
            0,
            sizeof(DHCP_PERF_STATS),
            DHCPCTR_SHARED_MEM_NAME
        );
        if( NULL == PerfHandle ) break;

        PerfStats = (LPVOID) MapViewOfFile(
            PerfHandle,
            FILE_MAP_WRITE,
            0,
            0,
            sizeof(DHCP_PERF_STATS)
        );
        if( NULL == PerfStats ) break;

        fPerfInitialized = TRUE;

        RtlZeroMemory( PerfStats, sizeof(*PerfStats));
        CopyDaclsFromRegistryToSharedMem();
        return ERROR_SUCCESS;
    } while (FALSE);

    Error = GetLastError();

    if( NULL != PerfHandle ) {
        CloseHandle(PerfHandle);
        PerfHandle = NULL;
        PerfStats = NULL;
    }

    return Error;
}

VOID
PerfCleanup(
    VOID
)
{
    if( FALSE == fPerfInitialized ) return;

    if( NULL != PerfStats ) UnmapViewOfFile( PerfStats );
    if( NULL != PerfHandle ) CloseHandle( PerfHandle );

    PerfStats = NULL;
    PerfHandle  = NULL;
    fPerfInitialized = FALSE;
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\pendingc.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

#ifndef     PENDING_CTXT_DEFINED
#define     PENDING_CTXT_DEFINED
typedef struct _DHCP_PENDING_CTXT {               // this is what is stored for each pending client
    LIST_ENTRY                     BucketList;    // entry in the bucket (hash list)
    LIST_ENTRY                     GlobalList;    // list of ALL pending contexts in FIFO order
    LPBYTE                         RawHwAddr;     // raw hw address, not UID as created by us
    DWORD                          nBytes;        // size of above in bytes
    DWORD                          Address;       // offered address
    DWORD                          LeaseDuration; // how long did we offer before?
    DWORD                          T1, T2;        // old offered T1 and T2
    DWORD                          MScopeId;      // MScopeId this address was offered from.
    DATE_TIME                      ExpiryTime;    // when should this context be expired?
    BOOL                           Processing;    // is this being processed?
} DHCP_PENDING_CTXT, *PDHCP_PENDING_CTXT, *LPDHCP_PENDING_CTXT;
typedef     LIST_ENTRY             PENDING_CTXT_SEARCH_HANDLE;
typedef     PLIST_ENTRY            PPENDING_CTXT_SEARCH_HANDLE;
typedef     PLIST_ENTRY            LPPENDING_CTXT_SEARCH_HANDLE;
#endif      PENDING_CTXT_DEFINED


DWORD
DhcpFindPendingCtxt(                              // find if a pending context exists (srch by ip address or hw addr)
    IN      LPBYTE                 RawHwAddr,     // OPTIONAL the hw addr to use for search
    IN      DWORD                  RawHwAddrSize, // OPTIONAL size of above in bytes
    IN      DWORD                  Address,       // OPTIONAL the address to search for
    OUT     PDHCP_PENDING_CTXT    *Ctxt
) ;


DWORD
DhcpRemoveMatchingCtxt(
    IN DWORD                       Mask,
    IN DWORD                       Address
) ;

DWORD
DhcpRemovePendingCtxt(                            // remove a ctxt from the pending ctxt list
    IN OUT  PDHCP_PENDING_CTXT     Ctxt
) ;


DWORD
DhcpAddPendingCtxt(                               // add a new pending ctxt
    IN      LPBYTE                 RawHwAddr,     // raw bytes that form the hw address
    IN      DWORD                  nBytes,        // size of above in bytes
    IN      DWORD                  Address,       // offered address
    IN      DWORD                  LeaseDuration, // how long did we offer before?
    IN      DWORD                  T1,            // old offered T1
    IN      DWORD                  T2,            // old offered T2
    IN      DWORD                  MScopeId,      // multicast scope id
    IN      DATE_TIME              ExpiryTime,    // how long to keep the pending ctxt?
    IN      BOOL                   Processing     // is this context still being processed?
) ;


DWORD
DhcpDeletePendingCtxt(
    IN OUT  PDHCP_PENDING_CTXT     Ctxt
) ;

DWORD
MadcapDeletePendingCtxt(
    IN OUT  PDHCP_PENDING_CTXT     Ctxt
) ;


DWORD
DhcpDeleteExpiredCtxt(                            // all ctxt with expiration time < this will be deleted
    IN      DATE_TIME              ExpiryTime     // if this is zero, delete EVERY element
) ;


DWORD
DhcpCountIPPendingCtxt(                             // find the # of pending ctxt in given subnet
    IN      DWORD                  SubnetAddress,
    IN      DWORD                  SubnetMask
);

DWORD
DhcpCountMCastPendingCtxt(                             // find the # of pending ctxt in given subnet
    IN      DWORD                  MScopeId
);

DWORD
DhcpPendingListInit(                              // intialize this module
    VOID
) ;


VOID
DhcpPendingListCleanup(                           // cleanup everything in this module
    VOID
) ;

//========================================================================
//  end of file
//========================================================================

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\ping.c ===
//================================================================================
//  Microsoft Confidential
//  Copyright (C) Microsoft Corporation 1997
//
//  Author: RameshV
//================================================================================

//================================================================================
//  Required headers
//================================================================================
#include <dhcppch.h>
#include <ping.h>
#include <thread.h>

#include <ipexport.h>
#include <icmpif.h>
#include <icmpapi.h>

//================================================================================
//  Data structures  NOT EXPORTED
//================================================================================

//  The follwing is the structure that is passed back to the callback function
typedef struct st_apcContext {          // struct passed to APC routine
    LIST_ENTRY       IcmpRepliesList;   // the chain of replies got is stored here
    LIST_ENTRY       IcmpRequestsList;  // The list that holds the icmp response
    PICMP_ECHO_REPLY Reply;             // Icmp reply packet
    DWORD            ReplySize;         // The size of above buffer.
    IPAddr           DestinationAddress;// Who are we try to ping?
    LONG             Status;            // Did we succeed? Also retry count.
    LPVOID           Context;           // Dont know what this is goint to be
} APC_CONTEXT, *PAPC_CONTEXT;

// All file-scope globals are here.
LIST_ENTRY               IcmpRepliesList;      // Here is where the IcmpReplies are spooled
LIST_ENTRY               IcmpRequestsList;     // Here is where the
CRITICAL_SECTION         IcmpRepliesCritSect;  // To access the replies list
CRITICAL_SECTION         IcmpRequestsCritSect; // To access the requests list
HANDLE                   IcmpRepliesEvent;     // Signaled each time a reply is received
HANDLE                   IcmpRequestsEvent;    // Singaled whenever a request is received

HANDLE                   TerminateEvent;       // Quit everything being done.
CRITICAL_SECTION         OutputCritSect;       // To co-ordinate access to console output

HANDLE                   RequestsThreadHandle; // The handle of the thread that takes requests
HANDLE                   RepliesThreadHandle;  // The handle of the thread that takes replies

HANDLE                   IcmpHandle;           // Handle to do IcmpSendEcho2 etc.

BOOL                     Terminating = FALSE;  // Are we terminating?
DWORD                    nPendingRequests = 0; // # of pending ICMP requests..

#define LOCK_REPLIES_LIST()    EnterCriticalSection(&IcmpRepliesCritSect)
#define LOCK_REQUESTS_LIST()   EnterCriticalSection(&IcmpRequestsCritSect)
#define LOCK_OUTPUT()          EnterCriticalSection(&OutputCritSect)

#define UNLOCK_REPLIES_LIST()  LeaveCriticalSection(&IcmpRepliesCritSect)
#define UNLOCK_REQUESTS_LIST() LeaveCriticalSection(&IcmpRequestsCritSect)
#define UNLOCK_OUTPUT()        LeaveCriticalSection(&OutputCritSect)

//================================================================================
//  Routines
//================================================================================

//--------------------------------------------------------------------------------
//  The following functions are on the replies side.  They handle the icmp reply
//  packet and take the necessary action depending on the status, etc.
//--------------------------------------------------------------------------------

VOID NTAPI
ApcRoutine(                             //  This is called when ping completes
    IN PVOID            Context,        //  The above structure
    IN PIO_STATUS_BLOCK Ignored1,       //  Unused param
    IN ULONG            Ignored2        //  Unused param
) {
    BOOL   Status;
    PAPC_CONTEXT ApcContext = (PAPC_CONTEXT)Context;

    LOCK_REPLIES_LIST();                //  Add this to replies list
    InsertTailList(&IcmpRepliesList, &ApcContext->IcmpRepliesList);
    UNLOCK_REPLIES_LIST();
    nPendingRequests --;

    if( CFLAG_USE_PING_REPLY_THREAD ) { // if using a separate thread, notify!
        Status = SetEvent(IcmpRepliesEvent);
        DhcpAssert( FALSE != Status );
    }
}

BOOL
DestReachable(                          //  Is destination reachable?
    IN PAPC_CONTEXT      ApcContext     //  this has the info of sender etc..
) {
    DWORD nReplies, i;

    nReplies = IcmpParseReplies(
        ApcContext->Reply,
        ApcContext->ReplySize
    );

    if( 0 == nReplies ) {               //  No reply, so dest unreachable
        // If there was no reply, there is no way for us to reach this
        // So, we assume that the Dest is NOT reachable.
        // Reasons could be IP_REQ_TIMED_OUT or IP_BAD_DESTINATION etc..
        return FALSE;
    }

    // Now we check each reply to see if there is anything from the same dest
    // address we are looking for. And if the status is success. If the status
    // is not success, we actually do not check anything there. Potentially, it
    // could be IP_DEST_PORT_UNREACHABLE, in which case, the dest machine is up,
    // but for some reason we tried the wrong port..

    for( i = 0; i < nReplies; i ++ ) {
        if( ApcContext->DestinationAddress == ApcContext->Reply[i].Address ) {
            // hit the destination!

            DhcpAssert( IP_SUCCESS == ApcContext->Reply[i].Status );
            return TRUE;
        }

        DhcpAssert( IP_SUCCESS != ApcContext->Reply[i].Status);
    }

    return FALSE;
}

VOID
HandleRepliesEvent(                     //  Process all replies received
    VOID
) {
    PAPC_CONTEXT   ApcContext;
    PLIST_ENTRY    listEntry;
    BOOL           Status;

    LOCK_REPLIES_LIST();                //  Pickup replies and process them
    while( !IsListEmpty( &IcmpRepliesList ) ) {

        ApcContext = CONTAINING_RECORD(IcmpRepliesList.Flink, APC_CONTEXT, IcmpRepliesList);
        RemoveEntryList(&ApcContext->IcmpRepliesList);

        UNLOCK_REPLIES_LIST();

        Status = DestReachable(ApcContext);

        if( Status || NUM_RETRIES <= ApcContext->Status ) {
            HandleIcmpResult(
                ApcContext->DestinationAddress,
                Status,
                ApcContext->Context
            );

            DhcpFreeMemory(ApcContext);
        } else {                        //  Dest unreachable, but retry

            LOCK_REQUESTS_LIST();       //  Put it on the request list and notify
            InsertTailList(&IcmpRequestsList, &ApcContext->IcmpRequestsList);
            UNLOCK_REQUESTS_LIST();

            Status = SetEvent(IcmpRequestsEvent);
            DhcpAssert( TRUE == Status );
        }

        LOCK_REPLIES_LIST();
    }
    UNLOCK_REPLIES_LIST();
}


//  This routine sleeps on a loop, and is woken up by the call back function when an ICMP
//  reply comes through.  On waking up, this routine processes ALL ICMP replies.
DWORD                                   //  THREAD ENTRY
LoopOnIcmpReplies(                      //  Loop on all the ICMP replies.
    LPVOID      Unused
) {
    DWORD  Status;
    HANDLE WaitHandles[2];

    WaitHandles[0] = TerminateEvent;    //  Wait for global terminate event
    WaitHandles[1] = IcmpRepliesEvent;  //  Or for ICMP replies to be queued

    while( TRUE ) {
        Status = WaitForMultipleObjects(
            sizeof(WaitHandles)/sizeof(WaitHandles[0]),
            WaitHandles,
            FALSE,
            INFINITE
        );


        if( WAIT_OBJECT_0 == Status )   //  Termination
            break;

        if( 1+WAIT_OBJECT_0 == Status ) {
            HandleRepliesEvent();       //  Some ICMP reply got queued, process this q
            continue;
        }

        DhcpPrint((DEBUG_ERRORS, "WaitForMult: %ld\n", Status));
        DhcpAssert( FALSE );            //  Should not happen
    }

    return ERROR_SUCCESS;
}

#define AlignSizeof(X)     ROUND_UP_COUNT(sizeof(X),ALIGN_WORST)

//================================================================================
//  Note that this is async only when the # of pending reqs is < MAX_PENDING_REQUESTS
//  Beyond that it just blocks for some request to be satisfied before queueing this
//  one
//================================================================================
DWORD                                   //  Win32 errors
DoIcmpRequestEx(                        //  Try to send an ICMP request (ASYNC)
    IPAddr        DestAddr,             //  The address to try to ping
    LPVOID        Context,              //  The parameter to HandleIcmpResult
    LONG          InitCount             //  Initial count (negative ==> # of attempts)
)
{
    PAPC_CONTEXT  pCtxt;
    LPBYTE        startAddress;
    DWORD         Status;
    BOOL          BoolStatus;

    pCtxt = DhcpAllocateMemory(AlignSizeof(APC_CONTEXT) + RCV_BUF_SIZE);
    startAddress = (LPBYTE)pCtxt;
    if( NULL == pCtxt )                 //  If could not allocate context?
        return ERROR_NOT_ENOUGH_MEMORY;

    // Now fill the context with all that we know.
    pCtxt->Reply = (PICMP_ECHO_REPLY)(startAddress + AlignSizeof(APC_CONTEXT));
    pCtxt->ReplySize = RCV_BUF_SIZE;
    pCtxt->DestinationAddress = DestAddr;
    pCtxt->Status = (InitCount? ( NUM_RETRIES - InitCount ) : 0 );
    pCtxt->Context = Context;

    LOCK_REQUESTS_LIST();
    InsertTailList(&IcmpRequestsList, &pCtxt->IcmpRequestsList);
    UNLOCK_REQUESTS_LIST();

    // Signal the Requests loop.
    BoolStatus = SetEvent(IcmpRequestsEvent);
    DhcpAssert( TRUE == BoolStatus );

    return ERROR_SUCCESS;
}

DWORD                                   //  Win32 errors
DoIcmpRequest(                          //  Try to send an ICMP request (ASYNC)
    IPAddr        DestAddr,             //  The address to try to ping
    LPVOID        Context               //  The parameter to HandleIcmpResult
)
{
    return DoIcmpRequestEx(DestAddr, Context, 0);
}

//--------------------------------------------------------------------------------
//  The following functions handle the the end that sends ICMP echoes.
//--------------------------------------------------------------------------------
VOID
HandleRequestsEvent(                    //   Process every request for ICMP echo.
    VOID
) {
    PAPC_CONTEXT   ApcContext;
    PLIST_ENTRY    listEntry;
    DWORD          Status;


    LOCK_REQUESTS_LIST();

    while( !IsListEmpty( &IcmpRequestsList ) ) {
        // retrive the first element in the list
        ApcContext = CONTAINING_RECORD(IcmpRequestsList.Flink, APC_CONTEXT, IcmpRequestsList);
        RemoveEntryList(&ApcContext->IcmpRequestsList);
        UNLOCK_REQUESTS_LIST();

        if( nPendingRequests >= MAX_PENDING_REQUESTS ) {
            //
            // Need to sleep for more than WAIT_TIME as IcmpSendEcho2 is
            // not accurate so far as timing is concerned..
            //
            SleepEx( WAIT_TIME + (WAIT_TIME/2), TRUE );
            DhcpAssert(nPendingRequests < MAX_PENDING_REQUESTS );
        }

        nPendingRequests ++;
        // Send an Icmp echo and return immediately..
        ApcContext->Status ++;
        Status = IcmpSendEcho2(
            IcmpHandle,                 // The handle to register APC and send echo
            NULL,                       // No event
            ApcRoutine,                 // The call back routine
            (LPVOID)ApcContext,         // The first parameter to the callback routine
            ApcContext->DestinationAddress, // The address being PING'ed
            SEND_MESSAGE,
            (WORD)strlen(SEND_MESSAGE),
            NULL,
            (LPVOID)ApcContext->Reply,
            ApcContext->ReplySize,
            WAIT_TIME
        );

        if( FALSE == Status ) Status = GetLastError();
        else {
            DhcpAssert(FALSE);          //  We can not get anything else!
            Status = ERROR_SUCCESS;
        }

        // Since we queued an APC, we expect an STATUS_PENDING.
        if( ERROR_SUCCESS != Status && ERROR_IO_PENDING != Status ) {
            // Got something that is incorrect.  Free ApcContext?
            // Maybe call ApcRoutine on this?
            DhcpPrint((DEBUG_ERRORS, "IcmpSendEcho2:GetLastError: %ld\n", Status));
            DhcpAssert(FALSE);
            nPendingRequests --;        //  Lets do our best to continue..
            DhcpFreeMemory(ApcContext); //  No point wasting this memory..
        }
        LOCK_REQUESTS_LIST();
    }
    UNLOCK_REQUESTS_LIST();
}


// This function handles the Requests.. For each one, it just sends an IcmpEcho
// asynchronously and returns back immediately.  When the APC routine is called,
// it would queue it up on the Replies list and then it would get processed...
DWORD                                   //  THREAD ENTRY
LoopOnIcmpRequests(                     //  Process pending requests for echo
    LPVOID           Unused
) {
    DWORD  Status;
    HANDLE WaitHandles[2];

    WaitHandles[0] = TerminateEvent;    //  Quit only when terminate is signalled
    WaitHandles[1] = IcmpRequestsEvent; //  Otherwise just wait til some request

    while( TRUE ) {
        Status = WaitForMultipleObjectsEx(
            sizeof(WaitHandles)/sizeof(WaitHandles[0]),
            WaitHandles,                //  array of handles
            FALSE,                      //  any one of them set
            INFINITE,                   //  wait forever
            TRUE                        //  allow APC's
        );

        if( WAIT_OBJECT_0 == Status )   //  Asked to terminate
            break;
        if( WAIT_IO_COMPLETION == Status) {
            if( ! CFLAG_USE_PING_REPLY_THREAD ) {
                HandleRepliesEvent();   //  APC -- some ICMP reply got queued, process the Q
            }
            continue;
        }
        if( 1+WAIT_OBJECT_0 == Status ) {
            HandleRequestsEvent();      //  Satisfy all pending requests for echo
            if( ! CFLAG_USE_PING_REPLY_THREAD ) {
                HandleRepliesEvent();   //  APC could have occurred in above call.
            }
            continue;
        }

        DhcpPrint((DEBUG_ERRORS, "WaitForM (IcmpReq) : %ld\n", Status));
        DhcpAssert(FALSE);              //  Unexpected error
    }

    return ERROR_SUCCESS;
}

//--------------------------------------------------------------------------------
//  Initialization, Cleanup routines.
//--------------------------------------------------------------------------------
DWORD PingInitLevel = 0;
DWORD // exported
PingInit(
    VOID
)
{
    DWORD ThreadId, Status;

    // Initialize all data vars.
    IcmpRepliesEvent = IcmpRequestsEvent = TerminateEvent = NULL;
    RepliesThreadHandle = RequestsThreadHandle = NULL;
    IcmpHandle = NULL;


    // Initialize Lists.
    InitializeListHead(&IcmpRepliesList);
    InitializeListHead(&IcmpRequestsList);

    // Initialize Critical Sections.
    try {
        InitializeCriticalSection(&IcmpRepliesCritSect);
        InitializeCriticalSection(&IcmpRequestsCritSect);
        InitializeCriticalSection(&OutputCritSect);
    }except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // hit an exception while initializing critical section
        // shouldnt happen
        //

        Status = GetLastError( );
        return( Status );
    }

    PingInitLevel ++;        // Indicate that PingInit was started
    // Open IcmpHandle..
    IcmpHandle = IcmpCreateFile();
    if( INVALID_HANDLE_VALUE == IcmpHandle ) return GetLastError();

    // Create Events,
    IcmpRepliesEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if( NULL == IcmpRepliesEvent ) return GetLastError();
    IcmpRequestsEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if( NULL == IcmpRequestsEvent ) return GetLastError();
    TerminateEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if( NULL == TerminateEvent ) return GetLastError();

    // Create Threads

    if( CFLAG_USE_PING_REPLY_THREAD ) {
        RepliesThreadHandle = CreateThread(
            (LPSECURITY_ATTRIBUTES)
            NULL,            // No security information
            0,               // Stack size = same as default primary thread
            LoopOnIcmpReplies,// The function to call
            NULL,            // No paramter needs to be passed to this function
            0,               // Flags: just start this thread right away
            &ThreadId        // The return ThreadId value.
        );
        if( NULL == RepliesThreadHandle ) return GetLastError();
    }

    RequestsThreadHandle = CreateThread(
        NULL,                // No security information
        0,                   // Stack size = same as default primary thread
        LoopOnIcmpRequests,  // The function to call
        NULL,                // No paramter needs to be passed to this function
        0,                   // Flags: just start this thread right away
        &ThreadId            // The return ThreadId value.
    );
    if( NULL == RequestsThreadHandle ) return GetLastError();

    return ERROR_SUCCESS;
}

VOID // exported
PingCleanup(
    VOID
)
{
    DWORD               Status;
    BOOL                BoolStatus;
    PAPC_CONTEXT        ApcContext;
    PLIST_ENTRY         listEntry;

    if( 0 == PingInitLevel ) return;
    PingInitLevel -- ;
    
    // Kill the replies and reqeusts threads after waiting for a while.
    // Kill the Replies and Requests ThreadHandle 's.
    if( NULL != RepliesThreadHandle || NULL != RequestsThreadHandle ) {
        // DhcpAssert ( NULL != TerminateEvent )
        Terminating = TRUE;
        SetEvent(TerminateEvent);

        if( CFLAG_USE_PING_REPLY_THREAD && NULL != RepliesThreadHandle ) {
            Status = WaitForSingleObject(
                RepliesThreadHandle,
                THREAD_KILL_TIME
            );
            if( WAIT_OBJECT_0 != Status ) {
                //  did not succeed in stopping the thread..
                DhcpPrint( (DEBUG_ERRORS, "Error: PingCleanup ( threadwait to die): %ld \n", Status ) );
            }
            CloseHandle(RepliesThreadHandle);
        }

        if( NULL != RequestsThreadHandle ) {
            Status = WaitForSingleObject(
                RequestsThreadHandle,
                THREAD_KILL_TIME
            );
            if( WAIT_OBJECT_0 != Status ) {
                //  did not succeed in stopping the thread..
                DhcpPrint( (DEBUG_ERRORS, "Error: PingCleanup ( threadwait to die): %ld \n", Status ) );
            }
            CloseHandle(RequestsThreadHandle);
        }
    }

    // Close Event handles.
    CloseHandle(IcmpRepliesEvent);
    CloseHandle(IcmpRequestsEvent);
    CloseHandle(TerminateEvent);

    LOCK_REPLIES_LIST();
    // Freeup all elements of lists..
    while( !IsListEmpty( &IcmpRepliesList ) ) {
        // retrive the first element in the list
        ApcContext = CONTAINING_RECORD(IcmpRepliesList.Flink, APC_CONTEXT, IcmpRepliesList);
        RemoveEntryList(&ApcContext->IcmpRepliesList);

        DhcpFreeMemory(ApcContext);
    }
    UNLOCK_REPLIES_LIST();

    LOCK_REQUESTS_LIST();
    while( !IsListEmpty( &IcmpRequestsList ) ) {
        // retrive the first element in the list
        ApcContext = CONTAINING_RECORD(IcmpRequestsList.Flink, APC_CONTEXT, IcmpRequestsList);
        RemoveEntryList(&ApcContext->IcmpRequestsList);

        DhcpFreeMemory(ApcContext);
    }
    UNLOCK_REQUESTS_LIST();

    // Close Icmp handle
    IcmpCloseHandle(IcmpHandle);

    // Destroy critical sections
    DeleteCriticalSection(&IcmpRepliesCritSect);
    DeleteCriticalSection(&IcmpRequestsCritSect);
    DeleteCriticalSection(&OutputCritSect);

    DhcpAssert( 0 == PingInitLevel );
} // PingCleanup()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\proto.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    This file contain function prototypes for the DHCP server service.

Author:

    Manny Weiser  (mannyw)  11-Aug-1992

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/
#ifndef PROTO_H_INCLUDED
#define PROTO_H_INCLUDED

//
//  util.c
//

VOID
DhcpServerEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode
    );

VOID
DhcpServerJetEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode,
    LPSTR CallerInfo
    );

VOID
DhcpServerEventLogSTOC(
    DWORD EventID,
    DWORD EventType,
    DHCP_IP_ADDRESS IPAddress,
    LPBYTE HardwareAddress,
    DWORD HardwareAddressLength
    );

DWORD
DisplayUserMessage(
    DWORD MessageId,
    ...
    );

BOOL
CreateDirectoryPathOem(
    IN LPCSTR OemPath,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

BOOL
CreateDirectoryPathW(
    IN LPWSTR Path,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

ULONG
GetUserAndDomainName(
    IN WCHAR Buf[]
    );

    
DWORD
RevertFromSecretUser(
    IN VOID
    );

DWORD
ImpersonateSecretUser(
    VOID
    );

BOOL
IsRunningOnDc(
    VOID
    );

DWORD
DhcpBeginWriteApi(
    IN LPSTR ApiName
    );

DWORD
DhcpEndWriteApi(
    IN LPSTR ApiName,
    IN ULONG Error
    );

DWORD
DhcpEndWriteApiEx(
    IN LPSTR ApiName,
    IN ULONG Error,
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DHCP_IP_ADDRESS Subnet OPTIONAL,
    IN DWORD Mscope OPTIONAL,
    IN DHCP_IP_ADDRESS Reservation OPTIONAL
    );

DWORD
DhcpBeginReadApi(
    IN LPSTR ApiName
    );

VOID
DhcpEndReadApi(
    IN LPSTR ApiName,
    IN ULONG Error
    );


DWORD
DynamicDnsInit(
    VOID
);

//
// cltapi.c
//

DWORD
DhcpCreateClientEntry(
    DHCP_IP_ADDRESS ClientIpAddress,
    LPBYTE ClientHardwareAddress OPTIONAL,
    DWORD HardwareAddressLength,
    DATE_TIME LeaseDuration,
    LPWSTR MachineName OPTIONAL,
    LPWSTR ClientInformation OPTIONAL,
    BYTE   bClientType,
    DHCP_IP_ADDRESS ServerIpAddress,
    BYTE AddressState,
    BOOL OpenExisting
);

DWORD
DhcpGetBootpReservationInfo(
    BYTE            *pbAllowedClientType,
    CHAR            *szBootFileServer,
    CHAR            *szBootFileName
);

DWORD
DhcpRemoveClientEntry(
    DHCP_IP_ADDRESS ClientIpAddress,
    LPBYTE HardwareAddress,
    DWORD HardwareAddressLength,
    BOOL ReleaseAddress,
    BOOL DeletePendingRecord
    );

BOOL
DhcpIsClientValid(
    IN      DHCP_IP_ADDRESS        Address,
    IN      LPBYTE                 RawHwAddress,
    IN      DWORD                  RawHwAddressLength,
    OUT     BOOL                  *fReconciled
);

BOOL
DhcpValidateClient(
    DHCP_IP_ADDRESS ClientIpAddress,
    PVOID HardwareAddress,
    DWORD HardwareAddressLength
);

DWORD
DhcpDeleteSubnetClients(
    DHCP_IP_ADDRESS SubnetAddress
);

//
// stoc.c
//

DWORD
DhcpInitializeClientToServer(
    VOID
);

VOID
DhcpCleanupClientToServer(
    VOID
    );


DWORD
ProcessMessage(
    LPDHCP_REQUEST_CONTEXT RequestContext,
    LPPACKET               AdditionalContext,
    LPDWORD                AdditionalStatus
);

DWORD
ProcessMadcapMessage(
    LPDHCP_REQUEST_CONTEXT RequestContext,
    LPPACKET               AdditionalContext,
    LPDWORD                AdditionalStatus
);


DWORD
DhcpMakeClientUID(
    LPBYTE ClientHardwareAddress,
    DWORD  ClientHardwareAddressLength,
    BYTE ClientHardwareAddressType,
    DHCP_IP_ADDRESS ClientSubnetAddress,
    LPBYTE *ClientUID,
    DWORD  *ClientUIDLength
);

//
// network.c
//

DWORD
InitializeSocket(
    OUT     SOCKET                *Sockp,
    IN      DWORD                  IpAddress,
    IN      DWORD                  Port,
    IN      DWORD                  McastAddress  OPTIONAL
);

DWORD
DhcpWaitForMessage(
    DHCP_REQUEST_CONTEXT *pRequestContext
);

DWORD
DhcpSendMessage(
    LPDHCP_REQUEST_CONTEXT DhcpRequestContext
);

DWORD
MadcapSendMessage(
    LPDHCP_REQUEST_CONTEXT DhcpRequestContext
);

DWORD
GetAddressToInstanceTable(
    VOID
);

DHCP_IP_ADDRESS
DhcpResolveName(
    CHAR *szHostName
);


//
// subntapi.c
//

// only RPC calls?

//
// optapi.c
//

DWORD
DhcpLookupBootpInfo(
    LPBYTE ReceivedBootFileName,
    LPBYTE BootFileName,
    LPBYTE BootFileServer
);

VOID
DhcpGetBootpInfo(
    IN LPDHCP_REQUEST_CONTEXT Ctxt,
    IN DHCP_IP_ADDRESS IpAddress,
    IN DHCP_IP_ADDRESS Mask,
    IN CHAR *szRequest,
    OUT CHAR *szBootFileName,
    OUT DHCP_IP_ADDRESS *pBootpServerAddress
    );


DWORD
LoadBootFileTable(
    WCHAR **ppszTable,
    DWORD *pcb
);

DWORD
DhcpParseBootFileString(
    WCHAR *wszBootFileString,
    char  *szGenericName,
    char  *szBootFileName,
    char  *szServerName
);


//
// database.c
//

DWORD
DhcpLoadDatabaseDll(
    VOID
);

DWORD
DhcpMapJetError(
    JET_ERR JetError,
    LPSTR CallerInfo OPTIONAL
);

DWORD
DhcpJetOpenKey(
    char *ColumnName,
    PVOID Key,
    DWORD KeySize
);

DWORD
DhcpJetBeginTransaction(
    VOID
);

DWORD
DhcpJetRollBack(
    VOID
);

DWORD
DhcpJetCommitTransaction(
    VOID
);

DWORD
DhcpJetPrepareUpdate(
    char *ColumnName,
    PVOID Key,
    DWORD KeySize,
    BOOL NewRecord
);

DWORD
DhcpJetCommitUpdate(
    VOID
);

DWORD
DhcpJetSetValue(
    JET_COLUMNID KeyColumnId,
    PVOID Data,
    DWORD DataSize
);

DWORD
DhcpJetGetValue(
    JET_COLUMNID ColumnId,
    PVOID Data,
    PDWORD DataSize
);

DWORD
DhcpJetPrepareSearch(
    char *ColumnName,
    BOOL SearchFromStart,
    PVOID Key,
    DWORD KeySize
);

DWORD
DhcpJetNextRecord(
    VOID
);

DWORD
DhcpJetDeleteCurrentRecord(
    VOID
);

BOOL
DhcpGetIpAddressFromHwAddress(
    PBYTE HardwareAddress,
    BYTE HardwareAddressLength,
    LPDHCP_IP_ADDRESS IpAddress
);

DWORD
DhcpSearchSuperScopeForHWAddress(
    BYTE *pbHardwareAddress,
    BYTE  cbHardwareAddress,
    BYTE  bHardwareAddressType,
    DHCP_IP_ADDRESS *pSubnetIPAddress,
    DHCP_IP_ADDRESS *pClientIPAddress
);


BOOL
DhcpGetHwAddressFromIpAddress(
    DHCP_IP_ADDRESS IpAddress,
    PBYTE HardwareAddress,
    DWORD HardwareAddressLength
);

DWORD
DhcpCreateAndInitDatabase(
    CHAR *Connect,
    JET_DBID *DatabaseHandle,
    JET_GRBIT JetBits
);

DWORD
DhcpInitializeDatabase(
    VOID
);

VOID
DhcpCleanupDatabase(
    DWORD ErrorCode
);

DWORD
DhcpBackupDatabase(
    LPSTR BackupPath
);

DWORD
DhcpRestoreDatabase(
    LPSTR BackupPath
);

DWORD
DhcpStartJet500Conversion(
    VOID
);

DWORD
DhcpStartJet97Conversion(
    VOID
);

DWORD
FlushBitmaskToDatabase( VOID );

DWORD
ReadServerBitmasks( void );

//
// Auditlog.c
//

DWORD
DhcpAuditLogInit(                                 // intialize audit log
    VOID                                          // must be called after initializing registry..
);

VOID
DhcpAuditLogCleanup(                              // undo the effects of the init..
    VOID
);

DWORD
DhcpUpdateAuditLog(
    DWORD Task,
    WCHAR *TaskName,
    DHCP_IP_ADDRESS IpAddress,
    LPBYTE HardwareAddress,
    DWORD HardwareAddressLength,
    LPWSTR MachineName
);

DWORD
DhcpUpdateAuditLogEx(
    DWORD Task,
    WCHAR *TaskName,
    DHCP_IP_ADDRESS IpAddress,
    LPBYTE HardwareAddress,
    DWORD HardwareAddressLength,
    LPWSTR MachineName,
    ULONG ErrorCode OPTIONAL
);

DWORD
AuditLogSetParams(                                // set some auditlogging params
    IN      DWORD                  Flags,         // currently must be zero
    IN      LPWSTR                 AuditLogDir,   // directory to log files in..
    IN      DWORD                  DiskCheckInterval, // how often to check disk space?
    IN      DWORD                  MaxLogFilesSize,   // how big can all logs files be..
    IN      DWORD                  MinSpaceOnDisk     // mininum amt of free disk space
);

DWORD
AuditLogGetParams(                                // get the auditlogging params
    IN      DWORD                  Flags,         // must be zero
    OUT     LPWSTR                *AuditLogDir,   // same meaning as in AuditLogSetParams
    OUT     DWORD                 *DiskCheckInterval, // ditto
    OUT     DWORD                 *MaxLogFilesSize,   // ditto
    OUT     DWORD                 *MinSpaceOnDisk     // ditto
);

VOID
DhcpChangeAuditLogs(                              // shift for new log
    VOID
);

//
// scavenger.c
//

DWORD
Scavenger(
    VOID
);

DWORD
CleanupClientRequests(
    DATE_TIME *TimeNow,
    BOOL CleanupAll
);


//
// main.c
//

DWORD
UpdateStatus(
    VOID
);

//
// rogue.c
//

VOID
DhcpScheduleRogueAuthCheck(
    VOID
);

BOOLEAN
DhcpRogueAcceptEnterprise(
    PCHAR   pClientDomain,
    DWORD   dwClientDomLen
);


VOID
DhcpRogueDetect(
    VOID
);


DWORD
DhcpRogueSockInit(
    VOID
);


DWORD
DhcpRogueWithDS(
    VOID
);


DWORD
DhcpRogueGetNeighborInfo(
    OUT PCHAR    *pInfo,
    OUT DWORD    *pNumResponses,
    OUT BOOLEAN  *pfSomeDSExists
);


DWORD
DhcpRogueSendDhcpInform(
    DWORD   *pXid
);


DWORD
DhcpRogueRecvDhcpInformResp(
    OUT PCHAR    pszDomainName,
    OUT DWORD   *pIpAddress,
    OUT BOOLEAN *fGotResponse,
    IN  DWORD    Xid
);

DWORD
DhcpRogueReceiveResponse(
    struct sockaddr *pSockAddr,
    DWORD           TimeOut,
    CHAR            *rcvBuf,
    DWORD           *pdwMsgLen,
    BOOL            *pfSelectTimedOut
);


DWORD
DhcpRogueOnSAM(
    VOID
    );

DWORD
DhcpRogueSendDiscover(
    VOID
);


DWORD
DhcpRogueListenForOffers(
    IN DWORD  TimeOut
);


BOOL
AmIRunningOnSAMSrv(
    VOID
);
//
// binl.c
//

BOOL
BinlRunning(
    VOID
    );

VOID
InformBinl(
    int NewState
    );

VOID
BinlProcessDiscover(
    LPDHCP_REQUEST_CONTEXT  RequestContext,
    LPDHCP_SERVER_OPTIONS   DhcpOptions
    );

LPOPTION
BinlProcessRequest(
    LPDHCP_REQUEST_CONTEXT  RequestContext,
    LPDHCP_SERVER_OPTIONS   DhcpOptions,
    LPOPTION Option,
    PBYTE OptionEnd
    );

BOOL
CheckForBinlOnlyRequest(
    LPDHCP_REQUEST_CONTEXT  RequestContext,
    LPDHCP_SERVER_OPTIONS   DhcpOptions
    );

//
// stuff for .mc messages
// you may have to change hese definitions if you add messages
//

#ifdef DBG
WCHAR * GetString( DWORD dwID );
#endif

// Get the real broadcast address to use instead of 255.255.255.255.
DHCP_IP_ADDRESS
DhcpRegGetBcastAddress(
    VOID
);

//
// dnsdb.c
//

// here are some functions that do work for Dynamic Dns stuff.

// The following function is called after JetBeginTransaction() by DhcpMakeclientEntry()
VOID
DhcpDoDynDnsCreateEntryWork(
    LPDHCP_IP_ADDRESS   ClientIpAddress,  // Ip address of new client
    BYTE                ClientType,       // The type of the client
    LPWSTR              MachineName,      // Name of the machine.
    LPBYTE              AddressState,     // The required address state
    LPBOOL              OpenExisiting,    // expected existence of record
    BOOL                BadAddress        // Is this a bad address?
);

// This function is called by DhcpRemoveClientEntry for Reservation case alone
VOID
DhcpDoDynDnsReservationWork(
    DHCP_IP_ADDRESS     ClientIpAddress,  // The ip address of the dying client
    LPWSTR              ClientName,       // The name of the client
    BYTE                State             // The state of the client in DB.
);

// This function is called in the scavenger and the main file cltapi.c (delete x..)
BOOL
DhcpDoDynDnsCheckDelete(
    DHCP_IP_ADDRESS IpAddress
);


VOID
DhcpDoDynDnsRefresh(
    DHCP_IP_ADDRESS IpAddress
);

VOID
DhcpCleanupDnsMemory(
    VOID
);

VOID
DhcpInitDnsMemory(
    VOID
);

VOID
DhcpDnsHandleCallbacks(
    VOID
    );

//
// thread.c -- see thread.h
//

//
// ping.c -- see ping.h
//

//
// dhcpreg.c
//

BOOL
QuickBound(
    DHCP_IP_ADDRESS ipAddress,
    DHCP_IP_ADDRESS *subnetMask,
    DHCP_IP_ADDRESS *subnetAddress,
    BOOL *fBind
);

DWORD
DhcpGetBindingList(
    LPWSTR  *bindingList
);

DWORD
DhcpOpenAdapterConfigKey(
    LPWSTR  AdapterStr,
    HKEY *AdapterKeyHandle
);

BOOL
IsAdapterStaticIP(
    HKEY AdapterKeyHandle
);

#if 0
BOOL
IsAdapterBoundToDHCPServer(
    HKEY AdapterKeyHandle
);

DWORD
SetBindingToDHCPServer(
    HKEY Key,
    BOOL fBind
);
#endif

DWORD
DhcpGetAdapterIPAddr(
    HKEY AdapterKeyHandle,
    DHCP_IP_ADDRESS *IpAddress,
    DHCP_IP_ADDRESS *SubnetMask,
    DHCP_IP_ADDRESS *SubnetAddress
);

DWORD
DhcpGetAdapterIPAddrQuickBind(
    HKEY             AdapterKeyHandle,
    DHCP_IP_ADDRESS *IpAddress,
    DHCP_IP_ADDRESS *SubnetMask,
    DHCP_IP_ADDRESS *SubnetAddress
);

BOOL
DhcpCheckIfDatabaseUpgraded(
    BOOL fRegUpgrade
    );

DWORD
DhcpSetRegistryUpgradedToDatabaseStatus(
    VOID
    );


//
// mm interface (in memory strucutures)
//

#include    <mmapi.h>

//
// secretk.h
//

DWORD
DhcpInitSecrets(
    VOID
);

VOID
DhcpCleanupSecrets(
    VOID
);


BOOL
DhcpGetAuthStatus(
    IN LPWSTR DomainName,
    OUT BOOL *fUpgraded,
    OUT BOOL *fAuthorized
);

DWORD
DhcpSetAuthStatus(
    IN LPWSTR DomainName OPTIONAL,
    IN BOOL fUpgraded,
    IN BOOL fAuthorized
);

VOID
DhcpSetAuthStatusUpgradedFlag(
    IN BOOL fUpgraded
);


DWORD
DhcpQuerySecretUname(
    IN OUT LPWSTR Uname,
    IN ULONG UnameSize,  // size in BYTES not WCHARS
    IN OUT LPWSTR Domain,
    IN ULONG DomainSize, // size in BYTES
    IN OUT LPWSTR Passwd,
    IN ULONG PasswdSize  // size in BYTES
    );

DWORD
DhcpSetSecretUnamePasswd(
    IN LPWSTR Uname,
    IN LPWSTR Domain,
    IN LPWSTR Passwd
    );

//
// Rogue.C
//

DWORD
APIENTRY
DhcpRogueInit(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL,
    IN      HANDLE                 WaitEvent,
    IN      HANDLE                 TerminateEvent
);

VOID
APIENTRY
DhcpRogueCleanup(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL
);

ULONG
APIENTRY
RogueDetectStateMachine(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL
);

VOID
DhcpScheduleRogueAuthCheck(
    VOID
);

ULONG
DhcpInitGlobalData (
    BOOLEAN ServiceStartup
);

VOID
DhcpCleanUpGlobalData (
    ULONG   Error,
    BOOLEAN ServiceEnd
);

//
// Perf.c
//

ULONG
PerfInit(
    VOID
);

VOID
PerfCleanup(
    VOID
);

//
// mib.c
//

BOOL
IsStringTroublesome(
    IN LPCWSTR Str
    );

//
// scan.c
//
DWORD
CreateClientDBEntry(
    DHCP_IP_ADDRESS ClientIpAddress,
    DHCP_IP_ADDRESS SubnetMask,
    LPBYTE ClientHardwareAddress,
    DWORD HardwareAddressLength,
    DATE_TIME LeaseTerminates,
    LPWSTR MachineName,
    LPWSTR ClientInformation,
    DHCP_IP_ADDRESS ServerIpAddress,
    BYTE AddressState,
    BYTE ClientType
    );

//--------------------------------------------------------------------------------
// End of file
//--------------------------------------------------------------------------------
#endif PROTO_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\rogue.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rogue.c

Abstract:

    This file contains all the routines used in Rogue DHCP Server detection

Author:

    Shirish Koti (koti)    16-May-1997

    Ramesh VK (RameshV)    07-Mar-1998
       *PnP changes

    Ramesh VK (RameshV)    01-Aug-1998
       * Code changes to include asynchronous design
       * better logging (event + auditlog)
       * Two sockets only (needed for async recv + sync send? )
       * NT5 server in NT4 domain
       * Better reliability in case of multiple DS DC's + one goes down etc

    Ramesh VK (RameshV)    28-Sep-1998
       * Updated with review suggestions as well as ->NT5 upgrade scenarios
       * Updated -- removed neg caching, changed timeouts, changed loops..

    Ramesh VK (RameshV)    16-Dec-1998
       * Updated bindings model change.

Environment:

    User Mode - Win32

Revision History:


--*/

#include <dhcppch.h>
#include <dhcpds.h>
#include <iptbl.h>
#include <endpoint.h>
#include <ws2tcpip.h>
#include <mswsock.h>
#include <iphlpapi.h>

typedef enum {

    ROGUE_STATE_INIT = 0,
    ROGUE_STATE_WAIT_FOR_NETWORK,
    ROGUE_STATE_START,
    ROGUE_STATE_PREPARE_SEND_PACKET,
    ROGUE_STATE_SEND_PACKET,
    ROGUE_STATE_WAIT_FOR_RESP,
    ROGUE_STATE_PROCESS_RESP,
    ROGUE_STATE_TERMINATED

} DHCP_ROGUE_STATE;

#define  DHCP_ROGUE_AUTHORIZED                      0
#define  DHCP_ROGUE_UNAUTHORIZED                    1
#define  DHCP_ROGUE_DSERROR                         2


enum {
    ROGUE_AUTHORIZED = 0,
    ROGUE_UNAUTHORIZED,
    ROGUE_AUTH_NOT_CHECKED
};


// All times in seconds
#define DHCP_GET_DS_ROOT_RETRIES                 3
#define DHCP_GET_DS_ROOT_TIME                    5
#define DHCP_ROGUE_RUNTIME_RESTART               (60)
#define DHCP_ROGUE_RUNTIME_RESTART_LONG          (5*60)
#define DHCP_ROGUE_WAIT_FOR_RESP_TIME            2

#undef  DHCP_ROGUE_RUNTIME_DELTA
#undef  DHCP_ROGUE_RUNTIME_DELTA_LONG

#define DHCP_ROGUE_RESTART_NET_ERROR             5
#define DHCP_ROGUE_RUNTIME_DIFF                  (5*60)
#define DHCP_ROGUE_RUNTIME_DIFF_LONG             (7*60)
#define DHCP_ROGUE_RUNTIME_DELTA                 (5*60)
#define DHCP_ROGUE_RUNTIME_DELTA_LONG            (15*60)
#define DHCP_MAX_ACKS_PER_INFORM                 (30)
#define DHCP_ROGUE_MAX_INFORMS_TO_SEND           (4)
#define DHCP_RECHECK_DSDC_RETRIES                100
#define ROUND_DELTA_TIME                         (60*60)

#define IPCACHE_TIME                             (5*60)

#define DHCP_ROGUE_FIRST_NONET_TIME              (1*60)

//
// The rogue authorization recheck time is now configurable.
// The minimum time is 5 minutes, default = 60 minutes
//
#define ROGUE_MIN_AUTH_RECHECK_TIME              (5 * 60)
#define ROGUE_DEFAULT_AUTH_RECHECK_TIME          (60 * 60)
DWORD RogueAuthRecheckTime = ROGUE_DEFAULT_AUTH_RECHECK_TIME;


DHCP_ROGUE_STATE_INFO DhcpGlobalRogueInfo;
HMODULE Self;

//
// Pointer to WSARecvMsg
//
LPFN_WSARECVMSG WSARecvMsgFuncPtr = NULL;

//
//           A U D I T   L O G   C A L L S
//

VOID
RogueAuditLog(
    IN ULONG EventId,
    IN ULONG IpAddress,
    IN LPWSTR Domain,
    IN ULONG ErrorCode
)
{
    DhcpPrint((DEBUG_ROGUE, "%ws, %x, %ws (%ld)\n", 
               GETSTRING(EventId), IpAddress, Domain, ErrorCode));
    DhcpUpdateAuditLogEx(
        (EventId + DHCP_IP_LOG_ROGUE_BASE - DHCP_IP_LOG_ROGUE_FIRST ),
        GETSTRING(EventId),
        IpAddress,
        NULL,
        0,
        Domain,
        ErrorCode
    );
}

ULONG
MapEventIdToEventLogType(
    IN ULONG EventId
)
{
    switch(EventId) {
    case DHCP_ROGUE_EVENT_STARTED: 
    case DHCP_ROGUE_EVENT_STARTED_DOMAIN:
    case DHCP_ROGUE_EVENT_JUST_UPGRADED:
    case DHCP_ROGUE_EVENT_JUST_UPGRADED_DOMAIN:
        return EVENTLOG_INFORMATION_TYPE;
    }
    return EVENTLOG_ERROR_TYPE;
}

VOID
RogueEventLog(
    IN ULONG EventId,
    IN ULONG IpAddress,
    IN LPWSTR Domain,
    IN ULONG ErrorCode
)
{
    LPWSTR IpAddrString;
    LPWSTR Strings[3];
    WCHAR ErrorCodeString[sizeof(ErrorCode)*2 + 5];
    
    if( 0 == IpAddress ) IpAddrString = NULL;
    else {
        IpAddress = htonl(IpAddress);
        IpAddrString = DhcpOemToUnicode( 
            inet_ntoa(*(struct in_addr *)&IpAddress), 
            NULL
            );
    }

    Strings[0] = (NULL == IpAddrString)? L"" : IpAddrString;
    Strings[1] = (NULL == Domain)? L"" : Domain;
    if( 0 == ErrorCode ) {
        Strings[2] = L"0";
    } else {
        swprintf(ErrorCodeString, L"0x%8lx", ErrorCode);
        Strings[2] = ErrorCodeString;
    }

    DhcpReportEventW(
        DHCP_EVENT_SERVER,
        EventId,
        MapEventIdToEventLogType(EventId),
        3,
        sizeof(ULONG),
        Strings,
        (LPVOID)&ErrorCode
    );
}

#define ROGUEAUDITLOG(Evt,Ip,Dom,Err) if(pInfo->fLogEvents) RogueAuditLog(Evt,Ip,Dom,Err)
#define ROGUEEVENTLOG(Evt,Ip,Dom,Err) if ( pInfo->fLogEvents ) RogueEventLog(Evt,Ip,Dom,Err)

LPWSTR
FormatRogueServerInfo(
    IN ULONG IpAddress,
    IN LPWSTR Domain,
    IN ULONG Authorization
)
{
    LPWSTR String = NULL;
    LPWSTR IpString, Strings[2] ;
    ULONG Error;

    switch(Authorization) {
    case ROGUE_UNAUTHORIZED :
        Authorization = DHCP_ROGUE_STRING_FMT_UNAUTHORIZED; break;
    case ROGUE_AUTHORIZED :
        Authorization = DHCP_ROGUE_STRING_FMT_AUTHORIZED; break;
    case ROGUE_AUTH_NOT_CHECKED :
        Authorization = DHCP_ROGUE_STRING_FMT_NOT_CHECKED; break;
    default: return NULL;
    }

    IpAddress = htonl(IpAddress);
    IpString = DhcpOemToUnicode(
        inet_ntoa( *(struct in_addr *)&IpAddress), NULL
        );
    if( NULL == IpString ) return NULL;

    Strings[0] = IpString;
    Strings[1] = Domain;
    Error = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER 
        | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        Self,
        Authorization,
        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
        (PVOID)&String,
        0,
        (PVOID)Strings
    );

    DhcpFreeMemory(IpString);
    return String;
}

BOOL
AmIRunningOnSBSSrv(
    VOID
)
/*++

Routine Description:

    This function determines if this is a SAM Server

Arguments:

    None.

Return Value:

    TRUE if this is an SBS server that still has the NT 
         Restriction Key  "Small Business(Restricted)" in ProductSuite
    FALSE - otherwise

--*/
{
    OSVERSIONINFOEX OsInfo;
    DWORDLONG dwlCondition = 0;

    OsInfo.dwOSVersionInfoSize = sizeof(OsInfo);
    OsInfo.wSuiteMask = VER_SUITE_SMALLBUSINESS_RESTRICTED;

    VER_SET_CONDITION(
        dwlCondition, VER_SUITENAME, VER_AND
        );

    return VerifyVersionInfo(
        &OsInfo,
        VER_SUITENAME,
        dwlCondition
        );
}

DWORD _inline
GetDomainName(
    IN OUT PDHCP_ROGUE_STATE_INFO Info
)
{
    DWORD Error;
    LPWSTR pNetbiosName = NULL, pDomainName = NULL;
    BOOLEAN fIsWorkGroup;

    Error = NetpGetDomainNameExEx(
        &pNetbiosName,
        &pDomainName,
        &fIsWorkGroup
    );

    if( ERROR_SUCCESS != Error ) return Error;

    if ( fIsWorkGroup ) {
        Info->eRole = ROLE_WORKGROUP;
    }
    else if ( pNetbiosName && NULL == pDomainName ) {
        //
        // Only NetbiosName available?  Then this is NOT a NT5 domain!
        //
        Info->eRole = ROLE_NT4_DOMAIN;
    }
    else {
        Info->eRole = ROLE_DOMAIN;
    }

    if( pNetbiosName ) NetApiBufferFree(pNetbiosName);

    if( NULL != pDomainName ) {
        wcscpy(Info->DomainDnsName, pDomainName);

        // Copy the domain name for replying to other work group servers
        if ( NULL == DhcpGlobalDSDomainAnsi ) {
            // Allocate and zero-init
            DhcpGlobalDSDomainAnsi = LocalAlloc( LPTR, MAX_DNS_NAME_LEN );
        }
        if ( NULL != DhcpGlobalDSDomainAnsi ) {
            DhcpUnicodeToOem( Info->DomainDnsName, DhcpGlobalDSDomainAnsi );
        }
    } //if pDomainName

    if( pDomainName ) NetApiBufferFree(pDomainName);

    return ERROR_SUCCESS;
} // GetDomainName()

VOID
RogueNetworkStop(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo
)
{

    DWORD i;
    INT   ret;

    // Make sure the info is valid
    DhcpAssert((( NULL == pInfo->pBoundEP ) && ( 0 == pInfo->nBoundEndpoints )) ||
               (( NULL != pInfo->pBoundEP ) && ( 0 < pInfo->nBoundEndpoints )));

    if ( NULL == pInfo->pBoundEP ) {
        return;
    }

    // Close all the open sockets
    for ( i = 0; i < pInfo->nBoundEndpoints; ++i ) {
        DhcpAssert( INVALID_SOCKET != pInfo->pBoundEP[ i ].socket );
        ret = closesocket( pInfo->pBoundEP[ i ].socket );
        DhcpAssert( SOCKET_ERROR != ret );
    } // for all endpoints

    DhcpFreeMemory( pInfo->pBoundEP );
    pInfo->pBoundEP = NULL;
    pInfo->nBoundEndpoints = 0;

} // RogueNetworkStop()

DWORD _inline
RogueNetworkInit(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo
)
{
    ULONG Error;
    LPDHCP_BIND_ELEMENT_ARRAY pBindInfo = NULL;
    DWORD i, j;

    if ( FALSE == pInfo->fDhcp ) {
        //
        // Initialize Receive sockets
        //
        if( 0 != pInfo->nBoundEndpoints ) {
            return ERROR_SUCCESS;
        }

        //
        // Open socket and initialize it as needed, binding to 0.0.0.0
        //
        Error = InitializeSocket( &pInfo->RecvSocket, INADDR_ANY,
                                  DhcpGlobalClientPort, 0 );
        if( ERROR_SUCCESS != Error ) {
            return Error;
        }

    } // if pInfo->fDhcp

    //
    // Initialize Send sockets
    //

    //
    // Create an array of sockets bound to each bounded IP addr
    //

    Error = DhcpGetBindingInfo( &pBindInfo );
    if (( ERROR_SUCCESS != Error ) ||
        ( NULL == pBindInfo )) {
        if ( NULL != pBindInfo ) {
            MIDL_user_free( pBindInfo );
        }
        return Error;
    } // if

    // Get a count of bound adapters
    pInfo->nBoundEndpoints = 0;
    for ( i = 0; i < pBindInfo->NumElements; i++ ) {
        if ( pBindInfo->Elements[ i ].fBoundToDHCPServer ) {
            pInfo->nBoundEndpoints++;
        }
    } // for

    pInfo->pBoundEP =
        ( PROGUE_ENDPOINT ) DhcpAllocateMemory( pInfo->nBoundEndpoints *
                                                sizeof( ROGUE_ENDPOINT ));
    if ( NULL == pInfo->pBoundEP ) {
        MIDL_user_free( pBindInfo );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for ( i = 0, j = 0; i < pBindInfo->NumElements, j < pInfo->nBoundEndpoints; i++ ) {
        if ( pBindInfo->Elements[ i ].fBoundToDHCPServer ) {
            pInfo->pBoundEP[ j ].IpAddr = pBindInfo->Elements[ i ].AdapterPrimaryAddress;
            pInfo->pBoundEP[ j ].SubnetAddr = pBindInfo->Elements[ i ].AdapterSubnetAddress;
            Error = InitializeSocket( &pInfo->pBoundEP[ j ].socket,
                                      pBindInfo->Elements[ i ].AdapterPrimaryAddress,
                                      DhcpGlobalClientPort, 0 );

            if ( ERROR_SUCCESS != Error ) {
                break;
            }
            j++;
        } // if boun
    } // for

    // free allcated memory
    MIDL_user_free( pBindInfo );


    return Error;
} // RogueNetworkInit()

VOID
LogUnAuthorizedInfo(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo
)
/*++

Routine Description

    This routine walks through the Info->CachedServersList and
    creates a string out of them formatted as below (one per entry)

    Server <Entry->IpAddress> (domain Entry->Domain) : [Authorized, NotAuthorized, Not Cheecked]

    For workgroup or Sam server, it just looks at LastSeenDomain and LastSeenIpAddress

Arguments

    Info -- pointer to state info to gather information to print.

Return Value

    none
--*/
{
    LPWSTR String, Strings[1];
    static ULONG LastCount = 0;
    ULONG Count;

    if (( ROLE_WORKGROUP == pInfo->eRole ) ||
        ( ROLE_SBS == pInfo->eRole )) {

        //
        // Ignore if no other server present or while in wrkgrp and saw
        // no domain.
        //

        if( pInfo->LastSeenIpAddress == 0 ) {
            return ;
        }

        if (( ROLE_WORKGROUP == pInfo->eRole ) &&
            ( pInfo->LastSeenDomain[0] == L'\0' )) {
            return ;
        }

        String = FormatRogueServerInfo(
            pInfo->LastSeenIpAddress, pInfo->LastSeenDomain, DHCP_ROGUE_UNAUTHORIZED
            );
    } // if workgroup or SBS
    else {
        String = FormatRogueServerInfo( 0, pInfo->DomainDnsName, DHCP_ROGUE_UNAUTHORIZED );
    }

    if( NULL == String ) return ;

    DhcpPrint((DEBUG_ROGUE,"LOG -- %ws\n", String));

    Strings[0] = String;
    DhcpReportEventW(
        DHCP_EVENT_SERVER,
        DHCP_ROGUE_EVENT_UNAUTHORIZED_INFO,
        EVENTLOG_WARNING_TYPE,
        1,
        0,
        Strings,
        NULL
    );

    if(String ) LocalFree( String );
} // LogUnAuthorizedInfo()

ULONG _fastcall
ValidateServer(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo
)
{
    DWORD Error;
    BOOL fFound, fIsStandAlone;

    //
    // Validate ourselves against the local DS.
    //

    DhcpPrint(( DEBUG_ROGUE,
        "Validating : %ws %x\n",
        pInfo->DomainDnsName,
        pInfo->LastSeenIpAddress
        ));
    Error = DhcpDsValidateService(
        pInfo->DomainDnsName,
        NULL,
        0,
        NULL,
        0,
        ADS_SECURE_AUTHENTICATION,
        &fFound,
        &fIsStandAlone
    );
    if( ERROR_SUCCESS != Error ) {

        ROGUEAUDITLOG( DHCP_ROGUE_LOG_COULDNT_SEE_DS, 0, pInfo->DomainDnsName, Error );
        ROGUEEVENTLOG( EVENT_SERVER_COULDNT_SEE_DS, 0, pInfo->DomainDnsName, Error );

    }

    pInfo->fAuthorized = fFound;

    return Error;

} // ValidateServer()

VOID
EnableOrDisableService(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo,
    IN BOOL fEnable,
    IN BOOL fLogOnly
)
/*++

Routine Description

    This routine enables or disables the service depending on what the
    value of fEnable is.  It doesnt do either but just logs some
    information if fLogOnly is TRUE.

Arguments

    Info  -- pointer to the global information and state
    fEnable -- ENABLE or DISABLE the service (TRUE or FALSE)
    fLogOnly -- log some information but do not enable or disable service

Return Values

    None

--*/
{
    LPWSTR DomainName;
    ULONG EventId;

    if( FALSE == fLogOnly ) {
        //
        // If state is changed, then inform binl.
        //
        InformBinl( fEnable ? DHCP_AUTHORIZED : DHCP_NOT_AUTHORIZED );

        // Log event only if state changes
        if (( DhcpGlobalOkToService != fEnable ) ||
            ( pInfo->fLogEvents == 2 )) {

            ROGUEAUDITLOG( fEnable ? DHCP_ROGUE_LOG_STARTED: DHCP_ROGUE_LOG_STOPPED, 0,
                           pInfo->DomainDnsName, 0);

            if( ROLE_DOMAIN == pInfo->eRole ) {
                DomainName = pInfo->DomainDnsName;
                if( fEnable && pInfo->fJustUpgraded ) {
                    if( ROGUE_AUTHORIZED != pInfo->CachedAuthStatus ) {
                        EventId = DHCP_ROGUE_EVENT_JUST_UPGRADED_DOMAIN;
                    }
                    else {
                        EventId = DHCP_ROGUE_EVENT_STARTED_DOMAIN ;
                    }
                }
                else {
                    EventId = ( fEnable ? DHCP_ROGUE_EVENT_STARTED_DOMAIN :
                                DHCP_ROGUE_EVENT_STOPPED_DOMAIN );
                }
            } // if domain
            else {
                DomainName = NULL;
                if( fEnable && pInfo->fJustUpgraded ) {
                    EventId = DHCP_ROGUE_EVENT_JUST_UPGRADED ;
                } 
                else {
                    EventId = ( fEnable ? DHCP_ROGUE_EVENT_STARTED
                                :  DHCP_ROGUE_EVENT_STOPPED );
                }
            } // else

            ROGUEEVENTLOG( EventId, 0, DomainName, 0 );
        } // if state changed

        DhcpGlobalOkToService = fEnable;
    } // if not log only

    if ( 2 == pInfo->fLogEvents ) {
        pInfo->fLogEvents = 1;
    }
} // EnableOrDisableService()

BOOL
IsThisNICBounded(
    IN UINT IfIndex
)
{
    DWORD Error;
    LPDHCP_BIND_ELEMENT_ARRAY pBindInfo = NULL;
    DWORD i, j;
    BOOL fFound = FALSE;
    PMIB_IPADDRTABLE pIpAddrTable = NULL;
    ULONG             TableLen = 0;


    Error = GetIpAddrTable( NULL, &TableLen, FALSE );
    DhcpAssert( NO_ERROR != Error );
    pIpAddrTable = ( PMIB_IPADDRTABLE ) DhcpAllocateMemory( TableLen );
    if ( NULL == pIpAddrTable ) {
        return FALSE;
    }

    Error = GetIpAddrTable( pIpAddrTable, &TableLen, FALSE );
    DhcpAssert( NO_ERROR == Error );
    if ( NO_ERROR != Error ) {
        DhcpFreeMemory( pIpAddrTable );
        return FALSE;
    }

    Error = DhcpGetBindingInfo( &pBindInfo );
    if (( ERROR_SUCCESS != Error ) ||
        ( NULL == pBindInfo )) {
        if ( NULL != pBindInfo ) {
            MIDL_user_free( pBindInfo );
        }
        DhcpFreeMemory( pIpAddrTable );
        return FALSE;
    } // if

    for ( j = 0; fFound == FALSE && j < pIpAddrTable->dwNumEntries; j++ ) {
        if ( pIpAddrTable->table[ j ].dwIndex != IfIndex ) {
            continue;
        }

        // Found the interface, check if bound
        for ( i = 0; i < pBindInfo->NumElements; i++ ) {
            if (( pBindInfo->Elements[ i ].fBoundToDHCPServer ) &&
                ( pBindInfo->Elements[ i ].AdapterPrimaryAddress
                  == pIpAddrTable->table[ j ].dwAddr )) {
                fFound = TRUE;
                break;
            } // if
        } // for i 
    } // for j

    MIDL_user_free( pBindInfo );
    DhcpFreeMemory( pIpAddrTable );
    return fFound;
} // IsThisNICBounded()

DWORD
GetWSARecvFunc( SOCKET sock )
{

    DWORD cbReturned = 0;
    DWORD Error;
    GUID WSARecvGuid = WSAID_WSARECVMSG;


    Error = WSAIoctl( sock, SIO_GET_EXTENSION_FUNCTION_POINTER,
                      ( void * ) &WSARecvGuid, sizeof( GUID ),
                      ( void * ) &WSARecvMsgFuncPtr,
                      sizeof( LPFN_WSARECVMSG ),
                      &cbReturned, NULL, NULL );

    if ( ERROR_SUCCESS != Error ) {
        Error = WSAGetLastError();
        DhcpPrint(( DEBUG_ERRORS, "Obtain WSARecvMsg pointer failed %d\n", Error ));
    } // if

    return Error;

} // GetWSARecvFunc()

BOOL _stdcall
DoWSAEventSelectForRead(
    IN OUT PENDPOINT_ENTRY Entry,
    IN OUT PVOID RogueInfo
    )
/*++

Routine Description:
    This routine sets all the rogue sockets to signal the
    WaitHandle on availablity to read.

    N.B This is done only on the bound sockets.
Arguments:
    Entry -- endpoint binding.
    RogueInfo -- rogue state info.

Return Values:
    always TRUE as all the endpoints need to be scanned.

--*/
{
    PDHCP_ROGUE_STATE_INFO Info = (PDHCP_ROGUE_STATE_INFO) RogueInfo;
    PENDPOINT Ep = (PENDPOINT)Entry;
    ULONG Error;
    int  fRecv = 1;
    //
    // Ignore unbound interfaces right away.
    //
    if( !IS_ENDPOINT_BOUND( Ep ) ) return TRUE;

    //
    // Now do WSAEventSelect and print error code.
    //
    Error = WSAEventSelect(
        Ep->RogueDetectSocket,
        Info->WaitHandle,
        FD_READ
        );
    if( SOCKET_ERROR == Error ) {
        Error = WSAGetLastError();
        DhcpPrint((DEBUG_ROGUE, "LOG WSAEventSelect: %ld\n", Error));
    }

    //
    // Set socket option to return the interface the UDP packet came from
    //

    Error = setsockopt( Ep->RogueDetectSocket, IPPROTO_IP,
                        IP_PKTINFO, ( const char * ) &fRecv, sizeof( fRecv ));
    if ( ERROR_SUCCESS != Error ) {
        Error = WSAGetLastError();
        DhcpPrint(( DEBUG_ROGUE,
                    "setsockopt( IPPROTO_IP, IP_PKTINFO ) failed : %x\n",
                    Error ));
        closesocket( Ep->RogueDetectSocket );
        return FALSE;
    } // if

    //
    // Get a pointer to the WSARecvMsg for this socket
    //

    if ( NULL == WSARecvMsgFuncPtr ) {
        Error = GetWSARecvFunc( Ep->RogueDetectSocket );
        if ( ERROR_SUCCESS != Error ) {
            closesocket( Ep->RogueDetectSocket );
            return FALSE;
        }
    } // if 

    return TRUE;
} // DoWSAEventSelectForRead()

VOID
EnableForReceive(
    IN PDHCP_ROGUE_STATE_INFO Info
)
/*++

Routine Description:
    Sets the ASYNC SELECT events on the required sockets.

--*/
{
    ULONG Error, i;

    if( FALSE == Info->fDhcp ) {
        //
        // BINL -- only one socket: Info->RecvSocket
        //
        if( SOCKET_ERROR == WSAEventSelect(
            Info->RecvSocket, Info->WaitHandle, FD_READ) ) {
            Error = WSAGetLastError();

            DhcpPrint((DEBUG_ROGUE, "LOG WSAEventSelect failed %ld\n",
                       Error));
        }
        return;
    }

    //
    // For DHCP -- each endpoint that is bound has a rogue detect socket.
    // Enable receiving on each of those.
    //

    WalkthroughEndpoints(
        (PVOID)Info,
        DoWSAEventSelectForRead
        );
}

ULONG _inline
RogueSendDhcpInform(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo,
    IN BOOL fNewXid
)
{
    DWORD Error, i;
    PDHCP_MESSAGE SendMessage;
    POPTION Option;
    LPBYTE OptionEnd;
    BYTE Value;
    CHAR Buf[2];
    SOCKADDR_IN BcastAddr;
    ULONG Async;

    //
    // Format the inform packet if we haven't done it already.
    //

    SendMessage = (PDHCP_MESSAGE) pInfo->SendMessage;
    RtlZeroMemory( pInfo->SendMessage, sizeof(pInfo->SendMessage) );
    SendMessage ->Operation = BOOT_REQUEST;
    SendMessage ->HardwareAddressType = HARDWARE_TYPE_10MB_EITHERNET;
    SendMessage ->HardwareAddressLength = 6;
    SendMessage ->SecondsSinceBoot = 10;
    SendMessage ->Reserved = htons(DHCP_BROADCAST);

    Option = &SendMessage->Option;
    OptionEnd = DHCP_MESSAGE_SIZE + (LPBYTE)SendMessage;

    Option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) Option, OptionEnd );
    Value = ( ROLE_SBS == pInfo->eRole )
        ? DHCP_DISCOVER_MESSAGE
        : DHCP_INFORM_MESSAGE;
    Option = DhcpAppendOption(
        Option,
        OPTION_MESSAGE_TYPE,
        &Value,
        sizeof(Value),
        OptionEnd
        );

    if( ROLE_WORKGROUP == pInfo->eRole ) {
        Buf[0] = OPTION_MSFT_DSDOMAINNAME_REQ;
        Buf[1] = 0;
        Option = DhcpAppendOption(
            Option,
            OPTION_VENDOR_SPEC_INFO,
            Buf,
            sizeof(Buf),
            OptionEnd
            );
    }

    Option = DhcpAppendOption (Option, OPTION_END, NULL, 0, OptionEnd);

    pInfo->SendMessageSize = (DWORD) ((PBYTE)Option - (PBYTE)SendMessage);

    if( fNewXid ) {
        pInfo->TransactionID = GetTickCount() + (rand() << 16);
    }

    SendMessage ->TransactionID = pInfo->TransactionID;

    //
    // Send the packet out broadcast
    //

    BcastAddr.sin_family = AF_INET;
    BcastAddr.sin_port = htons(DHCP_SERVR_PORT);
    BcastAddr.sin_addr.s_addr = INADDR_BROADCAST;

    for ( i = 0; i < pInfo->nBoundEndpoints; i++ ) {
        // use the address of the bound adapter for ci_addr
        SendMessage->ClientIpAddress = pInfo->pBoundEP[ i ].IpAddr;
        if( SOCKET_ERROR == sendto( pInfo->pBoundEP[ i ].socket,
                                    (PCHAR) pInfo->SendMessage,
                                    pInfo->SendMessageSize,
                                    0,
                                    (LPSOCKADDR) &BcastAddr,
                                    sizeof( SOCKADDR_IN ))) {
            Error = WSAGetLastError();

            //
            // LOG error
            //
            ROGUEAUDITLOG( DHCP_ROGUE_LOG_NETWORK_FAILURE,0, NULL, Error);
            return Error;
        } // if
    } // for

    //
    // Set the socket to be asynchronous binding to WaitHandle event
    //

    EnableForReceive(pInfo);

    return ERROR_SUCCESS;
} // RogueSendDhcpInform()

typedef struct {
    PDHCP_ROGUE_STATE_INFO Info;
    SOCKET *Sock;
    ULONG LastError;
} GET_SOCK_CTXT;

BOOL _stdcall
GetReadableSocket(
    IN OUT PENDPOINT_ENTRY Entry,
    IN OUT PVOID SockCtxt
    )
/*++

Routine Description:
    This routine takes a network endpoint and tells if the endpoint
    has a rogue det. socket available for reading.
    If so, it returns FALSE.  Otherwise, it returns TRUE.

    If the routine returns TRUE, then the socket that is ready for
    read is returned in the SockCtxt->Sock variable.
    
Arguments:
    Entry -- endpoint entry
    SockCtxt -- pointer to a GET_SOCK_CTXT structure.

Return Values:
    TRUE -- the socket does not have a read event ready.
    FALSE -- the socket has a read event ready.
    
--*/
{
    GET_SOCK_CTXT *Ctxt = (GET_SOCK_CTXT*)SockCtxt;
    PENDPOINT Ep = (PENDPOINT)Entry;
    WSANETWORKEVENTS NetEvents;
    ULONG Error;
    
    if(!IS_ENDPOINT_BOUND(Ep) ) return TRUE;

    Error = WSAEnumNetworkEvents(
        Ep->RogueDetectSocket,
        Ctxt->Info->WaitHandle,
        &NetEvents
        );
    if( SOCKET_ERROR == Error ) {
        Ctxt->LastError = WSAGetLastError();
        DhcpPrint((DEBUG_ROGUE,"LOG WSAEnumNet: %ld\n", Error));
        return TRUE;
    }

    if( 0 == (NetEvents.lNetworkEvents & FD_READ) ) {
        //
        // Nothing to read for this socket.
        //
        return TRUE;
    }
    *(Ctxt->Sock) = Ep->RogueDetectSocket;
    Ctxt->LastError = NO_ERROR;

    //
    // return FALSE - don't proceed with enumeration anymore.
    // 
    return FALSE;
}

DWORD
GetReceivableSocket(
    IN PDHCP_ROGUE_STATE_INFO Info,
    OUT SOCKET *Socket
)
/*++

Routine Description:
   This routine returns a socket that has a packet receivable on it.

Argument:
   Info -- state info
   Socket -- socket that recvfrom won't block on

Return Value:
   ERROR_SEM_TIMEOUT if no socket is avaliable for receive
   Winsock errors

--*/
{
    ULONG Error;
    WSANETWORKEVENTS NetEvents;
    GET_SOCK_CTXT Ctxt;
    
    if( FALSE == Info->fDhcp ) {
        //
        // BINL -- need to check only the RecvSocket to see if readable.
        //
        Error = WSAEnumNetworkEvents( 
            Info->RecvSocket,
            Info->WaitHandle,
            &NetEvents
            );
        if( SOCKET_ERROR == Error ) {
            Error = WSAGetLastError();
#if DBG
            DbgPrint("WSAEnumNetworkEvents: %ld (0x%lx)\n", Error);
            DebugBreak();
#endif
            return Error;
        }
        
        if( 0 == (NetEvents.lNetworkEvents & FD_READ ) ) {
            //
            // OK - nothing to read? 
            //
            return ERROR_SEM_TIMEOUT;
        }

        *Socket = Info->RecvSocket;
        return ERROR_SUCCESS;
    }

    //
    // For DHCP -- we need to traverse the list of bound endpoints..
    // and check to see if any of them are available for read.
    //

    *Socket = INVALID_SOCKET;

    Ctxt.Info = Info;
    Ctxt.Sock = Socket;
    Ctxt.LastError = ERROR_SEM_TIMEOUT;

    WalkthroughEndpoints(
        (PVOID)&Ctxt,
        GetReadableSocket
        );

    return Ctxt.LastError;
}

DWORD _inline
RogueReceiveAck(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo
)
{
    ULONG SockAddrLen, MsgLen, Error, IpAddress, Flags;
    PDHCP_MESSAGE RecvMessage, SendMessage;
    DHCP_SERVER_OPTIONS DhcpOptions;
    LPSTR DomainName;
    WCHAR DomBuf[MAX_DNS_NAME_LEN];
    LPWSTR DomainNameW;
    WSABUF WsaBuf;
    BOOL fFirstTime = TRUE;
    SOCKET Socket;

    WSAMSG      WsaMsg;
    SOCKADDR_IN SourceIp;
    BYTE        ControlMsg[ sizeof( WSACMSGHDR ) + sizeof( struct in_pktinfo )];
    PWSACMSGHDR   pCtrlMsgHdr;

    struct in_pktinfo *pPktInfo;

    //
    // First try to do a recvfrom -- since socket is asynchronous it will
    // tell if there is a packet waiting or it will fail coz there is none
    // If it fails, just return success
    //

    while ( TRUE ) {

        Error = GetReceivableSocket( pInfo, &Socket );
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint(( DEBUG_ROGUE,
                        "GetReceivableSocket() failed: Error = %ld, firsttime = %ld\n",
                        Error, fFirstTime ));
            if( ERROR_SEM_TIMEOUT == Error && !fFirstTime ) {
                return ERROR_RETRY;
            }
            return Error;
        }

        fFirstTime = FALSE;

        SockAddrLen = sizeof( struct sockaddr );
        Flags = 0;

        memset( pInfo->RecvMessage, 0, sizeof( pInfo->RecvMessage ));
        memset( ControlMsg, 0, sizeof( ControlMsg ));

        WsaBuf.len = sizeof( pInfo->RecvMessage );
        WsaBuf.buf = ( char * ) pInfo->RecvMessage;

        WsaMsg.name = ( LPSOCKADDR ) &SourceIp;
        WsaMsg.namelen = sizeof( SourceIp );
        WsaMsg.lpBuffers = &WsaBuf;
        WsaMsg.dwBufferCount = 1;

        WsaMsg.Control.len = sizeof( ControlMsg );
        WsaMsg.Control.buf = ( char * ) ControlMsg;
        WsaMsg.dwFlags = 0;

        Error = WSARecvMsgFuncPtr( Socket, &WsaMsg, &MsgLen, NULL, NULL );

        if( SOCKET_ERROR == Error ) {
            Error = WSAGetLastError();

            if( WSAEWOULDBLOCK == Error ) {
                //
                // UNEXPECTED!!!!!!!!!!
                //
                return ERROR_RETRY;
            }

            if( WSAECONNRESET == Error ) {
                //
                // Someone is sending ICMP port unreachable.
                //
                DhcpPrint((DEBUG_ROGUE, "LOG WSARecvFrom returned WSAECONNRESET\n"));
                continue;
            }

            if( WSAENOTSOCK == Error ) {
                //
                // PnP Event blew away the socket? Ignore it
                //
                DhcpPrint((DEBUG_ROGUE, "PnP Event Blewaway the Socket\n"));
                continue;
            }

            if ( MSG_BCAST & Error ) {
                DhcpPrint(( DEBUG_ROGUE,"Broadcast message is received\n" ));
            }


            if ( MSG_CTRUNC & Error ) {
                DhcpPrint(( DEBUG_ROGUE, "Control header is insufficient. Need %d bytes\n",
                            (( WSACMSGHDR * ) ControlMsg )->cmsg_len ));
            }

            //
            // Some weird error. LOG and return error..
            //
            DhcpPrint((DEBUG_ROGUE, "LOG: recvfrom failed %ld\n", Error));
            return Error;
        } // if socket error

        DhcpPrint(( DEBUG_ROGUE, "Packet received at %d.%d.%d.%d\n",
                    SourceIp.sin_addr.S_un.S_un_b.s_b1,
                    SourceIp.sin_addr.S_un.S_un_b.s_b2,
                    SourceIp.sin_addr.S_un.S_un_b.s_b3,
                    SourceIp.sin_addr.S_un.S_un_b.s_b4 ));

        RecvMessage = (PDHCP_MESSAGE) pInfo->RecvMessage;
        SendMessage = (PDHCP_MESSAGE) pInfo->SendMessage;
        if( SendMessage->TransactionID != RecvMessage->TransactionID ) {
            //
            // some general response got picked up
            //
            continue;
        }

        //
        // Did we reply to ourselves? This is possible when the
        // authorization is being rechecked after a successful
        // authorization (done every hour or through manual
        // invocation).
        //

        if ( IsIpAddrBound( RecvMessage->BootstrapServerAddress )) {
            DhcpPrint(( DEBUG_ROGUE, "Ignoring responses from ourselves\n" ));
            continue;
        }

        Error = ExtractOptions(
            RecvMessage,&DhcpOptions, MsgLen
        );
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ROGUE, "LOG received message could't parse\n"));
            continue;
        }

        // Check if the packet we got is from any of the bound interfaces
        pPktInfo = ( struct in_pktinfo * ) ( ControlMsg + sizeof( WSACMSGHDR ));
        if ( !IsThisNICBounded( pPktInfo->ipi_ifindex )) {
            DhcpPrint((DEBUG_ROGUE, "LOG ignoring packet from unbound subnets\n"));
            continue;
        }

        // Ignore responses for informs we didn't send
        if ( RecvMessage->TransactionID != pInfo->TransactionID ) {
            DhcpPrint(( DEBUG_ROGUE, "Ignoring ACKs for other informs\n" ));
            continue;
        }

        break;
    } // while

    pInfo->nResponses ++;
    pInfo->LastSeenIpAddress = htonl( SourceIp.sin_addr.S_un.S_addr );
    pInfo->LastSeenDomain[0] = L'\0';

    if( DhcpOptions.DSDomainName ) {
        DomainName = DhcpOptions.DSDomainName;
        DomainNameW = NULL;
        DomainName[DhcpOptions.DSDomainNameLen] = '\0';
        MsgLen = mbstowcs(DomBuf, DomainName, sizeof(DomBuf)/sizeof(DomBuf[0]) );
        if( -1 != MsgLen ) {
            DomainNameW = DomBuf;
            DomBuf[MsgLen] = L'\0';
        }
        wcscpy(pInfo->LastSeenDomain, DomBuf);
    }

    if( NULL == DhcpOptions.DSDomainName ||
        ( ROLE_SBS == pInfo->eRole )) {
        //
        // If this is a SAM serve, we got to quit.
        // Else if there is no domain, it is not  a problem.
        //

        DhcpPrint(( DEBUG_ROGUE, "LOG: SBS saw a response\n" ));
        return ERROR_SUCCESS;
    }


    if( ROLE_WORKGROUP == pInfo->eRole ) {
        //
        // LOG this IP and domain name
        //
        DhcpPrint((DEBUG_ROGUE, "LOG Workgroup saw a domain\n"));
        return ERROR_SUCCESS;
    }

    return ERROR_SUCCESS;
} // RogueReceiveAck()

BOOL _stdcall
StopReceiveForEndpoint(
    IN OUT PENDPOINT_ENTRY Entry,
    IN PVOID Unused
    )
/*++

Routine Description:
    This routine turns of asnyc event notificaiton for the rogue
    detection socket on the given endpoint (assuming that the endpoint
    is bound).

Arguments:
    Entry -- endpoint entry.
    Unused -- unused variable.

Return Values:
    TRUE always.

--*/
{
    PENDPOINT Ep = (PENDPOINT) Entry;
    ULONG Error;

    //
    // Ignore unbound sockets.
    //
    if( !IS_ENDPOINT_BOUND(Ep) ) return TRUE;

    Error = WSAEventSelect( Ep->RogueDetectSocket, NULL, 0 );
    if( SOCKET_ERROR == Error ) {
        Error = WSAGetLastError();
        DhcpPrint((
            DEBUG_ROGUE, "LOG WSAEventSelect(NULL):%ld\n",Error
            ));
    }

    return TRUE;
} // StopReceiveForEndpoint()

VOID _inline
RogueStopReceives(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info
)
{
    ULONG Error,i;

    //
    // Set the socket to be synchronous removing the
    // binding to the wait hdl 
    //

    if( FALSE == Info->fDhcp ) {
        //
        // BINL has only one socket in use -- the RecvSocket.  
        //
        if( SOCKET_ERROR == WSAEventSelect(
            Info->RecvSocket, NULL, 0 ) ) {

            Error = WSAGetLastError();
            //
            // LOG error
            //
            DhcpPrint((
                DEBUG_ROGUE, " LOG WSAEventSelect(NULL,0)"
                " failed %ld\n", Error
                ));
        }
    } else {
        //
        // DHCP has the list of endpoints  to be taken care of
        //

        WalkthroughEndpoints(
            NULL,
            StopReceiveForEndpoint
            );
    }
    ResetEvent(Info->WaitHandle);
} // RogueStopReceives()

VOID _inline
CleanupRogueStruct(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo
)
{
    DWORD i;
    if ( INVALID_SOCKET != pInfo->RecvSocket ) {
        closesocket( pInfo->RecvSocket );
    }
    RogueNetworkStop( pInfo );
    RtlZeroMemory( pInfo, sizeof( *pInfo ));
    pInfo->RecvSocket = INVALID_SOCKET;
} // CleanupRogueStruct()

VOID
CheckAndWipeOutUpgradeInfo(
    IN PDHCP_ROGUE_STATE_INFO Info
)
/*++

Routine Description:
    This routine checks to see if a DS is currently available 
    and if so, it wipes out the "UPGRADED" information in the
    registry..

--*/
{
    DhcpSetAuthStatusUpgradedFlag( FALSE );
}

BOOL _inline
CatchRedoAndNetReadyEvents(
    IN OUT PDHCP_ROGUE_STATE_INFO Info,
    IN ULONG TimeNow,
    OUT PULONG RetVal
)
/*++

Routine Description:
    Handle all kinds of redo-authorization requests as well as network
    ready events..  In case the state machine has been processed for this
    state, this routine returns TRUE indicating no more processing needs to
    be done -- just the return value provided in the second parameter
    should be returned.

    If DhcpGlobalRedoRogueStuff is set, then the value of the variabe
    DhcpGlobalRogueRedoScheduledTime is checked to see if we have to redo
    rogue detection right away or at a later time.. (depending on whether
    this value is in the past or current..)  If rogue detection had been
    scheduled explicitly, then we wipe out any upgrade information that we
    have (if we can see a DS enabled DC that is).  If the auth-check is
    scheduled for a time in future, the routine returns TRUE and sets the
    retval to the time diff to the scheduled time of auth-check.

Arguments:
    Info -- state info
    TimeNow -- current time
    RetVal -- Value to return from state machine if routine returns TRUE.

Return Value:
    FALSE -- indicating processing has to continue..
    TRUE -- processing has to stop, and RetVal has to be returned.
--*/
{
    if( DhcpGlobalRedoRogueStuff ) {

        //
        // Asked to restart Rogue detection?
        //

        Info->RogueState = ROGUE_STATE_START;
        RogueStopReceives( Info );
        RogueNetworkStop( Info );
        ResetEvent(Info->WaitHandle);

        if( TimeNow < DhcpGlobalRogueRedoScheduledTime ) {
            //
            // Scheduled re-start time is in future.. wait until then..
            //
            *RetVal = ( DhcpGlobalRogueRedoScheduledTime - TimeNow );
            return TRUE;
        } else {
            if( 0 != DhcpGlobalRogueRedoScheduledTime ) {
                //
                // Specifically scheduled redo? Then we must
                // remove upgrade information if DS-enabled DC
                // is found
                //
                CheckAndWipeOutUpgradeInfo(Info);
            }
        }
        DhcpGlobalRedoRogueStuff = FALSE;
    }

    if( Info->fDhcp && Info->RogueState != ROGUE_STATE_INIT
        && 0 == DhcpGlobalNumberOfNetsActive ) {
        //
        // No sockets that the server is bound to.
        // No point doing any rogue detection.  Doesn't matter if we 
        // are authorized in the DS or not.  Lets go back to start and
        // wait till this situation is remedied.
        //

        Info->RogueState = ROGUE_STATE_START;
        RogueStopReceives( Info );
        RogueNetworkStop( Info );

        *RetVal = INFINITE;
        return TRUE;
    }

    return FALSE;
} // CatchRedoAndNetReadyEvents()

DWORD
FindServerRole(
   IN PDHCP_ROGUE_STATE_INFO pInfo
)
{
    DhcpAssert( NULL != pInfo );

    // Is this an SBS server? 
    if ( AmIRunningOnSBSSrv()) {
        pInfo->eRole = ROLE_SBS;
        return ERROR_SUCCESS;
    } // if

    // This will update pInfo->eRole 
    return GetDomainName( pInfo );
} // FindServerRole()

DWORD
ValidateWithDomain(
    IN PDHCP_ROGUE_STATE_INFO pInfo
)
{
    DWORD Error;
    BOOL  fUpgraded = FALSE;
    BOOL  Status;

    pInfo->fAuthorized = FALSE;

    Error = ValidateServer( pInfo );

    if (( ERROR_SUCCESS == Error ) ||
        ( ERROR_DS_OBJ_NOT_FOUND == Error )) {

        // Update the result in the registry cache
        Error = DhcpSetAuthStatus( pInfo->DomainDnsName,
                                   FALSE, pInfo->fAuthorized );
#ifdef DBG
        pInfo->fAuthorized = FALSE;
        Error = DhcpGetAuthStatus( pInfo->DomainDnsName,
                                   &fUpgraded, &pInfo->fAuthorized );
#endif
    } // if
    else {
        // There was a DS error. Use the cached entry
        Status = DhcpGetAuthStatus( pInfo->DomainDnsName,
                                    &fUpgraded, &pInfo->fAuthorized );
        // If the cached entry was not found, then it is
        // not authorized.
        if ( FALSE == Status ) {
            pInfo->fAuthorized = FALSE;
        }
        Error = ERROR_SUCCESS;
    } // if

    EnableOrDisableService( pInfo, pInfo->fAuthorized, FALSE );

    return Error;
} // Validatewithdomain()

DWORD
HandleRogueInit(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo,
    IN     DWORD *pRetTime
)
{
    DWORD  Error = ERROR_SUCCESS;

    DhcpAssert( NULL != pInfo );

    DhcpPrint(( DEBUG_ROGUE, "Inside HandleRogueInit()\n" ));

    *pRetTime = 0;

    pInfo->RogueState = ROGUE_STATE_START;
    return Error;

} // HandleRogueInit()

DWORD
HandleRogueStart(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo,
    IN     DWORD *pRetTime
)
{
    DWORD Error;

    DhcpAssert( NULL != pInfo );

    DhcpPrint(( DEBUG_ROGUE, "Inside HandleRogueStart()\n" ));

    // Check if there are any interfaces available at this time
    if (( pInfo->fDhcp ) &&
        ( 0 == DhcpGlobalNumberOfNetsActive )) {
        ULONG RetVal;

        //
        // If there are no nets available at this time, then wait till
        // network becomes available again.
        //
        *pRetTime = INFINITE;

        ROGUEAUDITLOG( DHCP_ROGUE_LOG_NO_NETWORK, 0, NULL, 0 );
        ROGUEEVENTLOG( DHCP_ROGUE_EVENT_NO_NETWORK, 0, NULL, 0 );

        // no state change
        return ERROR_SUCCESS;
    } // if

    // Find the dhcp server's role

    Error = FindServerRole( pInfo );
    if ( ERROR_SUCCESS != Error ) {
        // GetDomainName() failed. Terminate the server

        pInfo->RogueState = ROGUE_STATE_TERMINATED;
        *pRetTime = 0;
        return ERROR_SUCCESS;
    }

    // NT4 Domain members are okay to service
    switch ( pInfo->eRole ) {
    case ROLE_NT4_DOMAIN: {
        *pRetTime = INFINITE;

        EnableOrDisableService( pInfo, TRUE, FALSE );
        DhcpPrint(( DEBUG_ROGUE, "NT4 domain member: ok to service" ));

        // stay in the same state
        Error =  ERROR_SUCCESS;
        break;
    } // NT4 domain member

    case ROLE_DOMAIN: {
        ULONG Retval;

        // Query DS and validate the server
        Retval = ValidateWithDomain( pInfo );

        // Is there a DS error?
        if ( DHCP_ROGUE_DSERROR == Retval ) {
            // schedule another rogue check after a few minutes
            *pRetTime = DHCP_ROGUE_RUNTIME_DELTA;
        }
        else {
            *pRetTime = RogueAuthRecheckTime;
        }

        // stay in the same state.
        Error = ERROR_SUCCESS;
        break;
    } // domain member

        // We need to send informs/discovers
    case ROLE_WORKGROUP:
    case ROLE_SBS: {
        // Initialize network to receive informs
        Error = RogueNetworkInit( pInfo );
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ROGUE, "FATAL Couldn't initialize network: %ld\n",
                       Error));
            ROGUEAUDITLOG( DHCP_ROGUE_LOG_NETWORK_FAILURE,
                           0, NULL, Error );
            ROGUEEVENTLOG( DHCP_ROGUE_EVENT_NETWORK_FAILURE,
                           0, NULL, Error );
            // terminate the server since network couldn't be initialized
            pInfo->RogueState = ROGUE_STATE_TERMINATED;
            Error = ERROR_SUCCESS;
        } // if

        *pRetTime = 0;

        pInfo->RogueState = ROGUE_STATE_PREPARE_SEND_PACKET;
        pInfo->LastSeenDomain[ 0 ] = L'\0';
        pInfo->InformsSentCount = 0;
        pInfo->ProcessAckRetries = 0;

        Error = ERROR_SUCCESS;
        break;
    }

    default: {
        DhcpAssert( FALSE );
    }
    } // switch

    return Error;
} // HandleRogueStart()

DWORD
HandleRoguePrepareSendPacket(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo,
    IN     DWORD *pRetTime
)
{
    DhcpAssert( NULL != pInfo );

    DhcpPrint(( DEBUG_ROGUE, "Inside HandleRoguePrepareSendPacket()\n" ));

    pInfo->nResponses = 0;

    pInfo->RogueState = ROGUE_STATE_SEND_PACKET;

    return ERROR_SUCCESS;
} // HandleRoguePrepareSendPacket()


DWORD
HandleRogueSendPacket(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo,
    IN     DWORD *pRetTime
)
{
    DWORD Error;

    DhcpAssert( NULL != pInfo );

    DhcpPrint(( DEBUG_ROGUE, "Inside HandleRogueSendPacket()\n" ));

    Error = RogueSendDhcpInform( pInfo, ( 0 == pInfo->InformsSentCount ));
    if ( ERROR_SUCCESS != Error ) {
        //
        // Unable to send inform, go back to start state
        //
        pInfo->RogueState = ROGUE_STATE_START;
        *pRetTime = DHCP_ROGUE_RESTART_NET_ERROR;
        return ERROR_SUCCESS;
    } // if

    DhcpPrint((DEBUG_ROGUE, "LOG -- Sent an INFORM\n"));
    pInfo->InformsSentCount ++;
    pInfo->WaitForAckRetries = 0;

    // wait for a response to inform/discover
    pInfo->RogueState = ROGUE_STATE_WAIT_FOR_RESP;
    pInfo->ReceiveTimeLimit = (ULONG)(time(NULL) + DHCP_ROGUE_WAIT_FOR_RESP_TIME);
    *pRetTime = DHCP_ROGUE_WAIT_FOR_RESP_TIME;

    return ERROR_SUCCESS;
} // HandleRogueSendPacket()

DWORD
HandleRogueWaitForResponse(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo,
    IN     DWORD *pRetTime
)
{
    DWORD Error;
    ULONG TimeNow;

    DhcpAssert( NULL != pInfo );

    DhcpPrint(( DEBUG_ROGUE, "Inside HandleRogueWaitForResponse()\n" ));

    Error = RogueReceiveAck( pInfo );
    pInfo->WaitForAckRetries++;

    if ( ERROR_SUCCESS == Error ) {

        // Got a packet, process it

        pInfo->RogueState = ROGUE_STATE_PROCESS_RESP;
        *pRetTime = 0;

        return ERROR_SUCCESS;
    } // if got a response


    TimeNow = ( ULONG ) time( NULL );
    if (( ERROR_SEM_TIMEOUT != Error ) &&
        ( pInfo->WaitForAckRetries <= DHCP_MAX_ACKS_PER_INFORM ) &&
        ( TimeNow < pInfo->ReceiveTimeLimit )) {
        // Continue to receive acks.

        *pRetTime = pInfo->ReceiveTimeLimit - TimeNow;
    } // if

    // Didn't get a packet, send another inform/discover

    if ( pInfo->InformsSentCount < DHCP_ROGUE_MAX_INFORMS_TO_SEND ) {
        pInfo->RogueState = ROGUE_STATE_SEND_PACKET;
        *pRetTime = 0;

        return ERROR_SUCCESS;
    } // if

    // Already sent enough informs, stop listening
    // and process packets if any.
    RogueStopReceives( pInfo );
    pInfo->RogueState = ROGUE_STATE_PROCESS_RESP;
    *pRetTime = 0;

    return ERROR_SUCCESS;

} // HandleRogueWaitForResponse()

DWORD
HandleRogueProcessResponse(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo,
    IN     DWORD *pRetTime
)
{
    DWORD Error;

    DhcpAssert( NULL != pInfo );

    DhcpPrint(( DEBUG_ROGUE, "Inside HandleRogueProcessResponse()\n" ));

    if (( ROLE_SBS == pInfo->eRole )  &&
        ( 0 != pInfo->nResponses )) {
        // shutdown the service
        pInfo->RogueState = ROGUE_STATE_TERMINATED;
        *pRetTime = INFINITE;

        ROGUEAUDITLOG( ROLE_WORKGROUP == pInfo->eRole
                       ? DHCP_ROGUE_LOG_OTHER_SERVER
                       : DHCP_ROGUE_LOG_SAM_OTHER_SERVER,
                       pInfo->LastSeenIpAddress,
                       pInfo->LastSeenDomain,
                       0 );
        ROGUEEVENTLOG( ROLE_WORKGROUP == pInfo->eRole
                       ? DHCP_ROGUE_EVENT_OTHER_SERVER
                       : DHCP_ROGUE_EVENT_SAM_OTHER_SERVER,
                       pInfo->LastSeenIpAddress,
                       pInfo->LastSeenDomain,
                       0 );

        // Cleanup
        RogueNetworkStop( pInfo );

        return ERROR_SUCCESS;
    } // if SBS

    // Workgroup

    // Did we wee a domain? Disable service.
    if ( L'\0' != pInfo->LastSeenDomain[ 0 ]) {
        // disable the service
        EnableOrDisableService( pInfo, FALSE, FALSE );

        // Restart rogue after a while
        *pRetTime = RogueAuthRecheckTime;
        pInfo->RogueState = ROGUE_STATE_START;


        ROGUEAUDITLOG( ROLE_WORKGROUP == pInfo->eRole
                       ? DHCP_ROGUE_LOG_OTHER_SERVER
                       : DHCP_ROGUE_LOG_SAM_OTHER_SERVER,
                       pInfo->LastSeenIpAddress,
                       pInfo->LastSeenDomain,
                       0 );
        ROGUEEVENTLOG( ROLE_WORKGROUP == pInfo->eRole
                       ? DHCP_ROGUE_EVENT_OTHER_SERVER
                       : DHCP_ROGUE_EVENT_SAM_OTHER_SERVER,
                       pInfo->LastSeenIpAddress,
                       pInfo->LastSeenDomain,
                       0 );

        // Stop receiving acks
        RogueStopReceives( pInfo );
        RogueNetworkStop( pInfo );

        return ERROR_SUCCESS;
    } // if saw a domain

    // Are we done with sending all the informs/discovers?
    if ( DHCP_ROGUE_MAX_INFORMS_TO_SEND == pInfo->InformsSentCount ) {
        // No DHCP server or domain enabled server, so we are authorized
        // to service.

        EnableOrDisableService( pInfo, TRUE, FALSE );
        pInfo->RogueState = ROGUE_STATE_START;
        *pRetTime = RogueAuthRecheckTime;

        // Cleanup
        RogueStopReceives( pInfo );
        RogueNetworkStop( pInfo );

        return ERROR_SUCCESS;
    } // if

    // Still more informs/discovers to go.
    pInfo->RogueState = ROGUE_STATE_SEND_PACKET;
    *pRetTime = 0;
    return ERROR_SUCCESS;
} // HandleRogueProcessResponse()

DWORD
HandleRogueTerminated(
    IN OUT PDHCP_ROGUE_STATE_INFO pInfo,
    IN     DWORD *pRetTime
)
{
    DWORD Error;

    DhcpAssert( NULL != pInfo );

    DhcpPrint(( DEBUG_ROGUE, "Inside HandleRogueTerminated()\n" ));

    ROGUEEVENTLOG( DHCP_ROGUE_EVENT_SHUTDOWN, 0, NULL, 0 );

    SetEvent( pInfo->TerminateEvent );
    *pRetTime = INFINITE;

    return ERROR_SUCCESS;
} // HandleRogueTerminated()

ULONG
APIENTRY
RogueDetectStateMachine(
    IN OUT PDHCP_ROGUE_STATE_INFO Info OPTIONAL
)
/*++

Routine Description

    This routine is the Finite State Machine for the Rogue Detection
    portion of the DHCP server.  State is maintained in the Info struct
    especially the RogueState field.

    The various states are defined by the enum DHCP_ROGUE_STATE.

    This function returns the timeout that has to elapse before a
    state change can happen.  The second field <WaitHandle> is
    used for non-fixed state changes and it would be signalled if
    a state change happened asynchronously.  (This is useful to
    handle new packet arrival)  This field MUST be filled by caller.

    This handle should initially be RESET by the caller but after that
    the caller should not reset it, that is handled within by this
    function. (It must be a manual-reset function)

    The terminate event handle is used to signal termination and to
    initiate shutdown of the service.  This field MUST also be filled
    by caller.

Arguments

    Info -- Ptr to struct that holds all the state information

Return value

    This function returns the amount of time the caller is expected
    to wait before calling again.  This is in seconds.

    INFINITE -- this value is returned if the network is not ready yet.
       In this case, the caller is expected to call again soon after the
       network becomes available.

       This value is also returned upon termination...
--*/
{

    ULONG Error, TimeNow, RetVal;
    BOOL  fEnable;
    DWORD RetTime = 0;

    DWORD DisableRogueDetection = 0;

    Error = DhcpRegGetValue( DhcpGlobalRegParam,
                 DHCP_DISABLE_ROGUE_DETECTION,
                 DHCP_DISABLE_ROGUE_DETECTION_TYPE,
                 ( LPBYTE ) &DisableRogueDetection 
                 );
    if (( ERROR_SUCCESS == Error ) &&
        ( 0 != DisableRogueDetection )) {
        DhcpGlobalOkToService = TRUE;
        DhcpPrint(( DEBUG_ROGUE,
                    "Rogue Detection Disabled\n"
                    ));
        return INFINITE;
    } // if

    //
    // DHCP code passes NULL, BINL passes valid context
    //
    if( NULL == Info ) Info = &DhcpGlobalRogueInfo;
    TimeNow = (ULONG) time(NULL);

    //
    // Preprocess and check if we have to restart rogue detection..
    // or if the network just became available etc...
    // This "CatchRedoAndNetReadyEvents" would affect the state..
    //

    if( CatchRedoAndNetReadyEvents( Info, TimeNow, &RetVal ) ) {
        //
        // Redo or NetReady event filter did all the work
        // in this state... So, we should just return RetVal..
        //
        return RetVal;
    }

    RetTime = 0;
    do {

        //
        // All the HandleRogue* routines should return
        // ERROR_SUCCESS with the return timer value in
        // RetTime. All these routines should handle error
        // cases and always return success.
        //

        switch ( Info->RogueState ) {
        case ROGUE_STATE_INIT : {
            Error = HandleRogueInit( Info, &RetTime );
            break;
        } // Init

        case ROGUE_STATE_START : {
            Error = HandleRogueStart( Info, &RetTime );
            break;
        } // start

        case ROGUE_STATE_PREPARE_SEND_PACKET: {
            Error = HandleRoguePrepareSendPacket( Info, &RetTime );
            break;
        } // Prepare send packet

        case ROGUE_STATE_SEND_PACKET : {
            Error = HandleRogueSendPacket( Info, &RetTime );
            break;
        } // send packet

        case ROGUE_STATE_WAIT_FOR_RESP : {
            Error = HandleRogueWaitForResponse( Info, &RetTime );
            break;
        } // Wait for response

        case ROGUE_STATE_PROCESS_RESP : {
            Error = HandleRogueProcessResponse( Info, &RetTime );
            break;
        } // Process response

        case ROGUE_STATE_TERMINATED: {
            Error = HandleRogueTerminated( Info, &RetTime );
            break;
        }

        default: {
            DhcpAssert( FALSE );
        }
        } // switch

        DhcpAssert( ERROR_SUCCESS == Error );

    } while ( 0 == RetTime );

    return RetTime;
} // RogueDetectStateMachine()

DWORD
APIENTRY
DhcpRogueInit(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info  OPTIONAL,
    IN      HANDLE                 WaitEvent,
    IN      HANDLE                 TerminateEvent
)
/*++

Routine Description

    This routine initializes the rogue information state.  It does
    not really allocate much resources and can be called over multiple
    times.

Arguments

    Info -- this is a pointer to a struct to initialize. If NULL, a global
    struct is used.

    WaitEvent -- this is the event that caller should wait on for async changes.

    TerminateEvent -- this is the event that caller should wait on to know when
    to terminate.

    Return Values

    Win32 errors

Environment

    Any.  Thread safe.

--*/
{
    DWORD Error;

    if ( NULL == Info ) {
        Info = &DhcpGlobalRogueInfo;
    } else {

        Error = DhcpInitGlobalData( FALSE );
        if (Error != ERROR_SUCCESS) {
            return Error;
        }
    }

    if( INVALID_HANDLE_VALUE == WaitEvent || NULL == WaitEvent )
        return ERROR_INVALID_PARAMETER;
    if( INVALID_HANDLE_VALUE == TerminateEvent || NULL == TerminateEvent )
        return ERROR_INVALID_PARAMETER;

    if( Info->fInitialized ) return ERROR_SUCCESS;

    RtlZeroMemory(Info, sizeof(*Info));
    Info->WaitHandle = WaitEvent;
    Info->TerminateEvent = TerminateEvent;
    Info->nBoundEndpoints = 0;
    Info->pBoundEP = NULL;
    Info->RecvSocket = INVALID_SOCKET;
    Info->fInitialized = TRUE;
    Info->fLogEvents = (
        (Info == &DhcpGlobalRogueInfo)
        && (0 != DhcpGlobalRogueLogEventsLevel)
        ) ? 2 : 0;
    DhcpGlobalRedoRogueStuff = FALSE;
    Info->fDhcp = (Info == &DhcpGlobalRogueInfo );

    // Get the Auth recheck time from the registry
    Error = DhcpRegGetValue( DhcpGlobalRegParam,
                 DHCP_ROGUE_AUTH_RECHECK_TIME,
                 DHCP_ROGUE_AUTH_RECHECK_TIME_TYPE,
                 ( LPBYTE ) &RogueAuthRecheckTime
                 );
    if ( ERROR_SUCCESS != Error ) {
        // The key is not present, use the default value
        RogueAuthRecheckTime = ROGUE_DEFAULT_AUTH_RECHECK_TIME;
    } // if
    else {
        // RogueAuthRecheckTime is in minutes, convert it to seconds
        RogueAuthRecheckTime *= 60;
        if ( RogueAuthRecheckTime < ROGUE_MIN_AUTH_RECHECK_TIME ) {
            RogueAuthRecheckTime = ROGUE_MIN_AUTH_RECHECK_TIME;
            // should we update the registry with the default value?
        } // if
    } // else

    // Initial state is INIT
    Info->RogueState = ROGUE_STATE_INIT;

    return ERROR_SUCCESS;
} // DhcpRogueInit()

VOID
APIENTRY
DhcpRogueCleanup(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL
)
/*++

Routine Description

    This routine de-initializes any allocated memory for the Info structure
    passed in.

Arguments

    Info -- this is the same value that was passed to the DhcpRogueInit function.
            If the original pointer passed was NULL, this must be NULL too.

--*/
{
    BOOLEAN cleanup;

    if ( NULL == Info ) {

        Info = &DhcpGlobalRogueInfo;
        cleanup = FALSE;

    } else {

        cleanup = TRUE;
    }

    if( FALSE == Info->fInitialized ) return ;
    CleanupRogueStruct(Info);
    Info->fInitialized = FALSE;
    DhcpGlobalRedoRogueStuff = FALSE;

    if (cleanup) {
        DhcpCleanUpGlobalData( ERROR_SUCCESS, FALSE );
    }
} // DhcpRogueCleanup

VOID
DhcpScheduleRogueAuthCheck(
    VOID
)
/*++

Routine Description:
    Thsi routine schedules an authorization check
    for three minutes from the current time.

--*/
{
    if( FALSE == DhcpGlobalRogueInfo.fJustUpgraded ) {
        //
        // Don't need one here..
        //
        return;
    }

    DhcpGlobalRogueRedoScheduledTime = (ULONG)(time(NULL) + 3 * 60);
    DhcpGlobalRedoRogueStuff = TRUE;

    SetEvent( DhcpGlobalRogueWaitEvent );
} // DhcpScheduleRogueAuthCheck()

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\ping.h ===
//================================================================================
//  Copyright (C) Microsoft Corporation 1997
//  Date: July 27 1997
//  Author: RameshV
//  Description:  Handles the asynchronous pinging part
//================================================================================

//================================================================================
//  Functions EXPORTED
//================================================================================
DWORD                                    // Win32 errors
DoIcmpRequest(                           // send icmp req. and process asynchro..
    DHCP_IP_ADDRESS    DestAddr,         // Address to send ping to
    LPVOID             Context           // the parameter to above function..
);

DWORD                                    // Win32 errors
DoIcmpRequestEx(                         // send icmp req. and process asynchro..
    DHCP_IP_ADDRESS    DestAddr,         // Address to send ping to
    LPVOID             Context,          // the parameter to above function..
    LONG               nAttempts         // # of attempts to ping
);

DWORD                                    // Win32 errors
PingInit(                                // Initialize all globals..
    VOID
);

VOID
PingCleanup(                             // Free memory and close handles..
    VOID
);

//================================================================================
//  Some defines
//================================================================================
#define WAIT_TIME              1000     //  Wait for 1 seconds
#define RCV_BUF_SIZE           0x500    //  This big a buffer
#define SEND_MESSAGE           "DhcpIcmpChk"
#define THREAD_KILL_TIME       INFINITE //  No need to kill anything, it will work

#define MAX_PENDING_REQUESTS   200      //  Any more requests are handled synchro.
#define NUM_RETRIES            ((LONG)DhcpGlobalDetectConflictRetries)


//================================================================================
//  End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\rpcapi2.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: all non-option/class related stuff are here. mostly subnet related.
// some also deal with the database.  RPC and their helper functions
//  -- For options related RPC implementation, pl look at rpcapi1.c.
//================================================================================

//================================================================================
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  GENERAL WARNING: Most of the routines in this file allocate memory using
//  MIDL functions because they are used in the RPC code path (??? Really, it
//  because that is how they were written before by Madan Appiah and co? )
//  So, BEWARE.   If you read this after getting burnt, there! I tried to tell ya.
//  -- RameshV
//================================================================================

#include    <dhcppch.h>
#include    <rpcapi.h>
#define     CONFIG_CHANGE_CHECK()  do{if( ERROR_SUCCESS == Error) DhcpRegUpdateTime(); } while(0)

#include "Uniqid.h"

//BeginExport(function)
DWORD
DhcpUpdateReservationInfo(                        // this is used in cltapi.c to update a reservation info
    IN      DWORD                  Address,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDLength
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Flags;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        Address,
        &Subnet,
        NULL,
        NULL,
        &Reservation
    );

    if( ERROR_SUCCESS != Error ) {
        DhcpAssert(FALSE);
        return Error;
    }

    DhcpAssert(Reservation && Subnet);
    Error = MemReserveReplace(
        &(Subnet->Reservations),
        Address,
        Flags = Reservation->Flags,
        ClientUID,
        ClientUIDLength
    );

    return Error;
}

DWORD
DhcpSetSuperScopeV4(
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPWSTR                 SScopeName,
    IN      BOOL                   ChangeExisting
)
{
    DWORD                          Error;
    DWORD                          SScopeId;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_SSCOPE                      SScope;

    Server = DhcpGetCurrentServer();

    Error = MemServerGetAddressInfo(
        Server,
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;

    if( NULL == SScopeName ) {                    // remove this subnet from whatever sscope it is in
        SScopeId = Subnet->SuperScopeId;
        Subnet->SuperScopeId = 0;                 // removed it

        return NO_ERROR;
    }

    if( FALSE == ChangeExisting && 0 != Subnet->SuperScopeId ) {
        // Found this element in some other super scope .. return error
        return ERROR_DHCP_SUBNET_EXITS;
    }

    Error = MemServerFindSScope(
        Server,
        0,
        SScopeName,
        &SScope
    );
    if( ERROR_SUCCESS != Error ) { // no supserscope exists by this name... create one
        Error = MemSScopeInit(
            &SScope,
            0,
            SScopeName
        );
        if( ERROR_SUCCESS != Error ) return Error;
        Error = MemServerAddSScope( Server,SScope );
        DhcpAssert( ERROR_SUCCESS == Error );
    } // if

    // Delete the subnet record
    Error = DeleteRecord( Subnet->UniqId );
    if ( ERROR_SUCCESS != Error ) {
	return Error;
    }

    Subnet->SuperScopeId = SScope->SScopeId;
    Subnet->UniqId = INVALID_UNIQ_ID;

    return Error;
} // DhcpSetSuperScopeV4()

DWORD
DhcpDeleteSuperScope(
    IN      LPWSTR                 SScopeName
)
{
    DWORD                          Error;
    DWORD                          SScopeId;
    PM_SSCOPE                      SScope;
    ARRAY_LOCATION                 Loc;
    PARRAY                         pArray;
    PM_SUBNET                      Subnet;

    if( NULL == SScopeName ) return ERROR_INVALID_PARAMETER;

    Error = MemServerFindSScope(
        DhcpGetCurrentServer(),
        0,
        SScopeName,
        &SScope
    );
    if( ERROR_FILE_NOT_FOUND == Error ) {
        return ERROR_DHCP_SUBNET_NOT_PRESENT;
    }
    if( ERROR_SUCCESS != Error) return Error;

    DhcpAssert(SScope);
    Error = MemServerDelSScope(
        DhcpGetCurrentServer(),
        SScopeId = SScope->SScopeId,
        &SScope
    );
    DhcpAssert(ERROR_SUCCESS == Error && NULL != SScope );
    Error = MemSScopeCleanup(SScope);
    DhcpAssert( NO_ERROR == Error );

    //
    // Now find subnets that have this as the superscope and
    // change all of them to have no superscopes
    //

    pArray = &DhcpGetCurrentServer()->Subnets;
    Error = MemArrayInitLoc(pArray, &Loc);

    while( NO_ERROR == Error ) {

        Error = MemArrayGetElement(pArray, &Loc, (LPVOID *)&Subnet);
        DhcpAssert(ERROR_SUCCESS == Error && Subnet);

        if( Subnet->SuperScopeId == SScopeId ) {
	    // Delete the subnet record
	    Error = DeleteRecord( Subnet->UniqId );
	    if ( ERROR_SUCCESS != Error ) {
		return Error;
	    }

	    Subnet->UniqId = INVALID_UNIQ_ID;
            Subnet->SuperScopeId = 0;
        } // if

        Error = MemArrayNextLoc(pArray, &Loc);
    } // while

    DhcpAssert( ERROR_FILE_NOT_FOUND == Error );
    return NO_ERROR;
} // DhcpDeleteSuperScope()

DWORD
DhcpGetSuperScopeInfo(
    IN OUT  LPDHCP_SUPER_SCOPE_TABLE  SScopeTbl
)
{
    DWORD                          Error;
    DWORD                          nSubnets;
    DWORD                          Index;
    DWORD                          i;
    DWORD                          First;
    PM_SERVER                      Server;
    PARRAY                         Subnets;
    PARRAY                         SuperScopes;
    PM_SUBNET                      Subnet;
    PM_SSCOPE                      SScope;
    ARRAY_LOCATION                 Loc;
    LPDHCP_SUPER_SCOPE_TABLE_ENTRY LocalTable;

    Server = DhcpGetCurrentServer();
    Subnets = &Server->Subnets;
    SuperScopes = &Server->SuperScopes;
    nSubnets = MemArraySize(Subnets);

    SScopeTbl->cEntries = 0;
    SScopeTbl->pEntries = NULL;

    if( 0 == nSubnets ) return ERROR_SUCCESS;
    LocalTable = MIDL_user_allocate(sizeof(DHCP_SUPER_SCOPE_TABLE_ENTRY)*nSubnets);
    if( NULL == LocalTable ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = MemArrayInitLoc(Subnets, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error );
    for(Index = 0; Index < nSubnets ; Index ++ ) {
        Error = MemArrayGetElement(Subnets, &Loc, (LPVOID *)&Subnet);
        DhcpAssert(ERROR_SUCCESS == Error && Subnet);

        LocalTable[Index].SubnetAddress = Subnet->Address;
        LocalTable[Index].SuperScopeNumber = 0;
        LocalTable[Index].SuperScopeName = NULL;
        LocalTable[Index].NextInSuperScope = Index;

        if( Subnet->SuperScopeId ) {
            Error = MemServerFindSScope(
                Server,
                Subnet->SuperScopeId,
                NULL,
                &SScope
            );
            if( ERROR_SUCCESS == Error ) {
                LocalTable[Index].SuperScopeNumber = Subnet->SuperScopeId;
                LocalTable[Index].SuperScopeName = SScope->Name;
            }
        }

        Error = MemArrayNextLoc(Subnets, &Loc);
    }

    for( Index = 0; Index < nSubnets ; Index ++ ) {
        for( i = 0; i < Index ; i ++ ) {
            if( LocalTable[Index].SuperScopeNumber == LocalTable[i].SuperScopeNumber ) {
                LocalTable[Index].NextInSuperScope = i;
            }
        }
        for( i = Index + 1; i < nSubnets; i ++ ) {
            if( LocalTable[Index].SuperScopeNumber == LocalTable[i].SuperScopeNumber ) {
                LocalTable[Index].NextInSuperScope = i;
                break;
            }
        }
    }

    for( Index = 0; Index < nSubnets ; Index ++ ) {
        if( NULL == LocalTable[Index].SuperScopeName) continue;
        LocalTable[Index].SuperScopeName = CloneLPWSTR(LocalTable[Index].SuperScopeName);
        if( NULL == LocalTable[Index].SuperScopeName ) {
            for( i = 0; i < Index ; i ++ )
                if( NULL != LocalTable[Index].SuperScopeName ) MIDL_user_free(LocalTable[Index].SuperScopeName);
            MIDL_user_free(LocalTable);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    SScopeTbl->cEntries = nSubnets;
    SScopeTbl->pEntries = LocalTable;

    return ERROR_SUCCESS;
} // DhcpGetSuperScopeInfo()

DWORD
DhcpCreateSubnet(
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
)
{
    DWORD                          Error, Error2;
    PM_SUBNET                      Subnet;

    if (( SubnetAddress != SubnetInfo->SubnetAddress ) ||
        ( 0 == SubnetAddress ) ||
        (( SubnetAddress & SubnetInfo->SubnetMask ) != SubnetAddress )) {
        return ERROR_INVALID_PARAMETER;
    }

    // Name, Comment, State; PrimaryHost is ignored for now...

    Error = MemSubnetInit(
        &Subnet,
        SubnetInfo->SubnetAddress,
        SubnetInfo->SubnetMask,
        SubnetInfo->SubnetState,
        0,                              // BUBBUG: SuperScopeId needs to be read from registry!
        SubnetInfo->SubnetName,
        SubnetInfo->SubnetComment
    );
    if( ERROR_SUCCESS != Error ) return Error;
    DhcpAssert(Subnet);

    Error = MemServerAddSubnet( DhcpGetCurrentServer(), Subnet, INVALID_UNIQ_ID );
    if( ERROR_SUCCESS != Error ) {
        Error2 = MemSubnetCleanup( Subnet );
        DhcpAssert(ERROR_SUCCESS == Error2);

        if( ERROR_OBJECT_ALREADY_EXISTS == Error ) {
            return ERROR_DHCP_SUBNET_EXISTS;
        }
        
        return Error;
    }

    return NO_ERROR;
} // DhcpCreateSubnet()

DWORD
DhcpSubnetSetInfo(
    IN OUT  PM_SUBNET              Subnet,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
)
{
    DWORD                          Error;
    PM_SUBNET                      AlternateSubnet;

    Error = MemSubnetModify(
        Subnet,
        SubnetInfo->SubnetAddress,
        SubnetInfo->SubnetMask,
        SubnetInfo->SubnetState,
        Subnet->SuperScopeId,                     // use same old super scope
        SubnetInfo->SubnetName,
        SubnetInfo->SubnetComment
    );
    return Error;

} // DhcpSubnetSetInfo()

DWORD
DhcpSetSubnetInfo(
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    if( SubnetAddress != SubnetInfo->SubnetAddress ||
        (SubnetAddress & SubnetInfo->SubnetMask) != SubnetAddress)
        return ERROR_INVALID_PARAMETER;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;
    if( ERROR_SUCCESS != Error ) return Error;

    DhcpAssert(Subnet);

    return DhcpSubnetSetInfo(Subnet, SubnetInfo);
}

DWORD
DhcpGetSubnetInfo(
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;
    if( ERROR_SUCCESS != Error) return Error;

    DhcpAssert(NULL != Subnet);

    SubnetInfo->SubnetAddress = Subnet->Address;
    SubnetInfo->SubnetMask = Subnet->Mask;
    SubnetInfo->SubnetName = CloneLPWSTR(Subnet->Name);
    SubnetInfo->SubnetComment = CloneLPWSTR(Subnet->Description);
    SubnetInfo->SubnetState = Subnet->State;
    SubnetInfo->PrimaryHost.IpAddress = inet_addr("127.0.0.1");
    SubnetInfo->PrimaryHost.NetBiosName = CloneLPWSTR(L"");
    SubnetInfo->PrimaryHost.HostName = CloneLPWSTR(L"");

    return ERROR_SUCCESS;
}

BOOL
SubnetIsBootpOnly(
    IN      PM_SUBNET              Subnet
)
{
    PM_RANGE                       ThisRange;
    ARRAY_LOCATION                 Loc;
    ULONG                          Error;
    
    Error = MemArrayInitLoc(&Subnet->Ranges, &Loc);
    while( ERROR_SUCCESS == Error ) {
        MemArrayGetElement(&Subnet->Ranges, &Loc, &ThisRange);
        if( ThisRange->State & MM_FLAG_ALLOW_DHCP ) return FALSE;

        Error = MemArrayNextLoc(&Subnet->Ranges, &Loc);
    }

    return TRUE;
}

DWORD
DhcpEnumSubnets(
    IN      BOOL                   fSubnet,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN OUT  LPDHCP_IP_ARRAY        EnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error, Error2;
    DWORD                          Index;
    DWORD                          Count;
    DWORD                          FilledSize;
    DWORD                          nSubnets;
    DWORD                          nToRead;
    PARRAY                         Subnets;
    PM_SUBNET                      Subnet;
    ARRAY_LOCATION                 Loc;
    DHCP_IP_ADDRESS               *IpArray;

    EnumInfo->NumElements = 0;
    EnumInfo->Elements = NULL;

    if( fSubnet ) Subnets = & (DhcpGetCurrentServer()->Subnets);
    else Subnets = &(DhcpGetCurrentServer()->MScopes);

    nSubnets = MemArraySize(Subnets);
    if( 0 == nSubnets || nSubnets <= *ResumeHandle)
        return ERROR_NO_MORE_ITEMS;

    if( nSubnets - *ResumeHandle > PreferredMaximum )
        nToRead = PreferredMaximum;
    else nToRead = nSubnets - *ResumeHandle;

    if ( 0 == nToRead ) {
        return ERROR_NO_MORE_ITEMS;
    }

    IpArray = MIDL_user_allocate(sizeof(DHCP_IP_ADDRESS)*nToRead);
    if( NULL == IpArray ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = MemArrayInitLoc(Subnets, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);
    
    for(Index = 0; Index < *ResumeHandle; Index ++ ) {
        Error = MemArrayNextLoc(Subnets, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    Count = Index;
    for( Index = 0; Index < nToRead; ) {
        Error = MemArrayGetElement(Subnets, &Loc, &Subnet);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != Subnet );

        IpArray[Index++] = Subnet->Address;

        Error = MemArrayNextLoc(Subnets, &Loc);
        if( ERROR_SUCCESS != Error ) break;
    }

    *nRead = Index;
    *nTotal = nSubnets - Count;
    *ResumeHandle += *nRead;

    EnumInfo->NumElements = Index;
    EnumInfo->Elements = IpArray;

    return ERROR_SUCCESS;
}

DWORD
DhcpDeleteSubnet(
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DWORD                  ForceFlag
)
{
    DWORD                          Error;
    DWORD                          SScopeId;
    PM_SUBNET                      Subnet;
    PM_SSCOPE                      SScope;

    // If force on, it should remove every record in the database for this subnet..
    if( ForceFlag != DhcpFullForce ) {
        Error = SubnetInUse( NULL /* dont bother abt regkey */, SubnetAddress);
        if( ERROR_SUCCESS != Error ) return Error;
    }

    Error = DhcpDeleteSubnetClients(SubnetAddress);
    // ignore the above error? 

    Error = MemServerDelSubnet(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;
    if( ERROR_SUCCESS != Error ) return Error;

    SScopeId = Subnet->SuperScopeId;

    // we have the M_SUBNET structure to remove
    // remove all the pending offers we've done on behalf of this subnet.
    // the requests for those ones (if any) will be NACK'ed.
    Error = DhcpRemoveMatchingCtxt(Subnet->Mask, Subnet->Address);
    // ignore this error, offers are anyway retracted on timeout.

    MemSubnetFree(Subnet);                        // evaporate this subnet all all related stuff
    return NO_ERROR;
}

DWORD
DhcpJetIterateOnAddresses(
    IN ULONG Start,
    IN ULONG End,
    IN BOOL (*IteratorFn)( ULONG IpAddress, PVOID Ctxt ),
    IN PVOID Ctxt
)
/*++

Iterate over every address in given range..

--*/
{
    ULONG Error, Size;

    //
    // Unfortunately we can't start from "Start" itself as the
    // prepareSearch routine starts from NEXT value..
    //
    Start --;
    LOCK_DATABASE();
    do {
        Error = DhcpJetPrepareSearch(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
            (Start == -1)? TRUE: FALSE,
            &Start,
            sizeof(Start)
            );
        if( ERROR_SUCCESS != Error ) break;

        while( 1 ) {
            Size = sizeof(Start);
            Error = DhcpJetGetValue(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                &Start,
                &Size
                );
            if( ERROR_SUCCESS  != Error ) break;
            if( Start > End ) break;

            if( IteratorFn( Start, Ctxt ) ) {
                Error = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            Error = DhcpJetNextRecord();
            if( ERROR_NO_MORE_ITEMS == Error ) {
                Error = ERROR_SUCCESS;
                break;
            }
        }
    } while ( 0 );

    UNLOCK_DATABASE();
    return Error;
}

typedef struct {
    BOOL fHuntForDhcpOrBootp;
    BOOL fFoundAny;
} DHCP_BOOTP_CHECK_CTXT;

BOOL
CheckForDhcpBootpLeases(
    IN ULONG IpAddress,
    IN OUT DHCP_BOOTP_CHECK_CTXT *Ctxt
)
/*++

Return Value:
    TRUE --> error
    FALSE === ev'rything appear ok

--*/
{
    ULONG Error, Size; 
    BYTE ClientType, AddressState;
    BOOL fReserved;
    
    Size = sizeof(AddressState);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        &Size
        );
    if( ERROR_SUCCESS == Error ) {
        //
        // If address deleted or not in active state, don't bother..
        //
        if( IsAddressDeleted(AddressState) 
            || !IS_ADDRESS_STATE_ACTIVE( AddressState ) ) {
            return FALSE;
        }
    }

    fReserved = DhcpServerIsAddressReserved(
        DhcpGetCurrentServer(),
        IpAddress
        );
    if( fReserved ) {
        //
        // Do not count reserved IP addresses..
        //
        return FALSE;
    }
    
    Size = sizeof(ClientType);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[CLIENT_TYPE_INDEX].ColHandle,
        &ClientType,
        &Size
        );
    
    if( ERROR_SUCCESS != Error ) return FALSE;
    
    if( Ctxt->fHuntForDhcpOrBootp ) {
        if( CLIENT_TYPE_DHCP == ClientType ) {
            Ctxt->fFoundAny = TRUE;
            return TRUE;
        }
    }

    if( FALSE == Ctxt->fHuntForDhcpOrBootp ) {
        if( CLIENT_TYPE_BOOTP == ClientType ) {
            Ctxt->fFoundAny = TRUE;
            return TRUE;
        }
    }
            
    return FALSE;
}

DWORD
CheckRangeStateChangeAllowed(
    IN ULONG RangeStart,
    IN ULONG RangeEnd,
    IN ULONG OldState,
    IN ULONG NewState OPTIONAL
)
/*++

Routine Description:
    This routine checks to see if there are any DHCP clients
    in the specified range when the conversion would require no
    DHCP Clients and similarly for BOOTP Clients.

    A conversion to BootpOnly would be something that requires
    no DHCP Clients at the end.  Conversely, a conversion to
    DHCP Only requires absence of BOOTP clients at the end.

--*/
{
    BOOL fDhcpDisallowed = FALSE;
    DHCP_BOOTP_CHECK_CTXT Ctxt;

    if( 0 == NewState ) NewState = MM_FLAG_ALLOW_DHCP;

    if( OldState == NewState ) return ERROR_SUCCESS;
    if( NewState == (MM_FLAG_ALLOW_DHCP | MM_FLAG_ALLOW_BOOTP ) ) {
        return ERROR_SUCCESS;
    }

    if( NewState == MM_FLAG_ALLOW_DHCP ) {
        fDhcpDisallowed = FALSE;
    } else if( NewState == MM_FLAG_ALLOW_BOOTP ) {
        fDhcpDisallowed = TRUE;
    } else {
        return ERROR_INVALID_PARAMETER;
    }

    Ctxt.fHuntForDhcpOrBootp = fDhcpDisallowed;
    Ctxt.fFoundAny = FALSE;

    DhcpJetIterateOnAddresses(
        RangeStart,
        RangeEnd,
        CheckForDhcpBootpLeases,
        &Ctxt
        );

    if( Ctxt.fFoundAny ) return ERROR_DHCP_IPRANGE_CONV_ILLEGAL;
    return ERROR_SUCCESS;
}

DWORD
DhcpSubnetAddRange(
    IN      PM_SUBNET              Subnet,
    IN      ULONG                  State OPTIONAL,
    IN      DHCP_IP_RANGE          Range,
    IN      ULONG                  MaxBootpAllowed OPTIONAL
)
/*++

Routine Description:

    This routine adds a range to a subnet, or modifies the range if it already
    exists.  State tells the new state, and Range is the new Range.  If the
    range is an extension of a previous range, then an attempt is made to extend
    the Range as required.  Note that if State is zero, then the old state is
    left as is.

Arguments:

    Subnet -- pointer to the subnet object to be modified.
    State -- ZERO indicates same state as before.
             MM_FLAG_ALLOW_DHCP and MM_FLAG_ALLOW_BOOTP can be used as bit flags
             here.
    Range -- the value of the new range.. this can be an extension of an
             existing range..
    MaxBootpAllowed -- maximum number of bootp clietns allowed.  Not used if
             State is zero.

Return Values:

Win32 or DHCP errors.

--*/
{
    DWORD                          Error;
    ULONG                          BootpAllocated, OldMaxBootpAllowed, OldState;
    DWORD                          RangeStartOld, RangeStartNew;
    DWORD                          OldStartAddress;
    DWORD                          OldEndAddress;
    DWORD                          InUseClustersSize;
    DWORD                          UsedClustersSize;
    LPBYTE                         InUseClusters;
    LPBYTE                         UsedClusters;
    PM_RANGE                       OverlappingRange;


    //
    // Bug # 415758 requries that we do not allow multiple
    // ranges.  So, if Subnet->Ranges is not empty then don't
    // allow this range.  
    //
    
    if( MemArraySize(&Subnet->Ranges) ) {
        if( NO_ERROR != MemSubnetFindCollision(
            Subnet, Range.StartAddress, Range.EndAddress,
            &OverlappingRange, NULL ) ) {
            return ERROR_DHCP_INVALID_RANGE;
        }
    }
        
    
    OverlappingRange = NULL;
    Error = MemSubnetAddRange(
        Subnet,
        Range.StartAddress,
        Range.EndAddress,
        (ARGUMENT_PRESENT(ULongToPtr(State)))? State : MM_FLAG_ALLOW_DHCP,
        0,
        MaxBootpAllowed,
        &OverlappingRange,
	INVALID_UNIQ_ID
    );
    if( ERROR_OBJECT_ALREADY_EXISTS == Error 
        && OverlappingRange->Start == Range.StartAddress 
        && OverlappingRange->End == Range.EndAddress ) {

        //
        // Special case -- changing attributes only..
        // 
        if( !( ARGUMENT_PRESENT( ULongToPtr(State) ) ) ) {
            //
            // If nothing needs to be change.. why call?
            //
            return ERROR_DHCP_IPRANGE_EXITS;
        }
        Error = CheckRangeStateChangeAllowed(
            OverlappingRange->Start,
            OverlappingRange->End,
            OverlappingRange->State,
            State
            );
        if( ERROR_SUCCESS != Error ) return Error;

        // Delete the corresponding record in the database
        Error = DeleteRecord( OverlappingRange->UniqId );
        if ( ERROR_SUCCESS != Error ) {
            return Error;
        }

        OverlappingRange->State = State;
        OverlappingRange->MaxBootpAllowed = MaxBootpAllowed;
        OverlappingRange->UniqId = INVALID_UNIQ_ID;
        Error = ERROR_SUCCESS;
    } // if changing state only

    if( ERROR_SUCCESS == Error ) {
        return NO_ERROR;
    }

    if( ERROR_OBJECT_ALREADY_EXISTS != Error ) return Error;
    DhcpAssert(NULL != OverlappingRange);

    Error = CheckRangeStateChangeAllowed(
        OverlappingRange->Start,
        OverlappingRange->End,
        OverlappingRange->State,
        State
        );
    if( ERROR_SUCCESS != Error ) return Error;

    OldState = OverlappingRange->State;
    OldMaxBootpAllowed = OverlappingRange->MaxBootpAllowed;

    if( ARGUMENT_PRESENT( ULongToPtr(State) ) ) {
        OverlappingRange->State = State;
        OverlappingRange->MaxBootpAllowed = MaxBootpAllowed;
    } else {
        State = OldState;
        MaxBootpAllowed = OldMaxBootpAllowed;
    }

    BootpAllocated = OverlappingRange->BootpAllocated;

    Error = MemSubnetAddRangeExpandOrContract(
        Subnet,
        Range.StartAddress,
        Range.EndAddress,
        &OldStartAddress,
        &OldEndAddress
    );
    if( ERROR_SUCCESS != Error ) {
        //
        // If we couldn't expand, then restore old values..
        //
        OverlappingRange->State = OldState;
        OverlappingRange->MaxBootpAllowed = OldMaxBootpAllowed;
        return ERROR_DHCP_INVALID_RANGE;
    }

    return Error;
} // DhcpSubnetAddRange()

DWORD
DhcpSubnetAddExcl(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_RANGE          Excl
)
{
    DWORD                          Error;
    DWORD                          nElements;
    DWORD                          Index;
    PM_EXCL                        CollidingExcl;
    DHCP_IP_ADDRESS               *ExclRegFormat;
    PARRAY                         Exclusions;
    ARRAY_LOCATION                 Loc;

    Error = MemSubnetAddExcl(
        Subnet,
        Excl.StartAddress,
        Excl.EndAddress,
        &CollidingExcl,
	INVALID_UNIQ_ID
    );

    if( ERROR_SUCCESS != Error ) return ERROR_DHCP_INVALID_RANGE;

    return NO_ERROR;
}

DWORD
DhcpSubnetAddReservation(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        ReservedAddress,
    IN      LPBYTE                 RawHwAddr,
    IN      DWORD                  RawHwAddrLen,
    IN      DWORD                  Type
)
{
    DWORD                          Error;
    DWORD                          IpAddress;
    PM_RANGE                       Range;
    PM_RESERVATION                 Reservation;
    LPBYTE                         ClientUID = NULL;
    DWORD                          ClientUIDSize;
    DATE_TIME                      ZeroDateTime = { 0, 0 };
    BOOL                           ExistingClient;

    if( CFLAG_RESERVED_IN_RANGE_ONLY ) {
        //
        // Compiled with option to disallow reservations out of range
        //
        Error = MemSubnetGetAddressInfo(
            Subnet,
            ReservedAddress,
            &Range,
            NULL,
            &Reservation
            );
        if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_NOT_RESERVED_CLIENT;
        if( ERROR_SUCCESS != Error ) return Error;
    } else {
        //
        // Compiled with no restrictions on where a reservation can fit in..
        //
        if( (ReservedAddress & Subnet->Mask) != Subnet->Address ) {
            return ERROR_DHCP_NOT_RESERVED_CLIENT;
        }
    }

    ClientUID = NULL;
    Error = DhcpMakeClientUID(
        RawHwAddr,
        RawHwAddrLen,
        HARDWARE_TYPE_10MB_EITHERNET,
        Subnet->Address,
        &ClientUID,
        &ClientUIDSize
    );
    if( ERROR_SUCCESS != Error ) return Error;

    ExistingClient = FALSE;
    if( DhcpGetIpAddressFromHwAddress(ClientUID, (BYTE)ClientUIDSize, &IpAddress ) ) {
        if( IpAddress != ReservedAddress ) {      // we got some other address, release it!
            Error = DhcpRemoveClientEntry(
                IpAddress,
                ClientUID,
                ClientUIDSize,
                TRUE,
                FALSE
            );
            if( ERROR_DHCP_RESERVED_CLIENT == Error ) {
                return ERROR_DHCP_RESERVEDIP_EXITS;
            }
        } else ExistingClient = TRUE;             // only instance where we carry on with existing record
    } else {
        Error = DhcpJetOpenKey(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
            &ReservedAddress,
            sizeof(ReservedAddress)
        );
        if( ERROR_SUCCESS == Error ) {
            Error = DhcpRemoveClientEntry(
                ReservedAddress, NULL, 0, TRUE, FALSE);
            if( ERROR_DHCP_RESERVED_CLIENT == Error ) {
                return ERROR_DHCP_RESERVEDIP_EXITS;
            }
            if( NO_ERROR != Error ) return Error;
        }
            
    }

    Error = DhcpCreateClientEntry(
        ReservedAddress,
        ClientUID,
        ClientUIDSize,
        ZeroDateTime,
        NULL,
        NULL,
        CLIENT_TYPE_UNSPECIFIED,
        (DWORD)(-1),
        ADDRESS_STATE_ACTIVE,
        ExistingClient
    );
    if( ERROR_SUCCESS == Error ) {
        Error = MemReserveAdd(
            &Subnet->Reservations,
            ReservedAddress,
            Type,
            ClientUID,
            ClientUIDSize,
	    INVALID_UNIQ_ID
        );
        if( ERROR_SUCCESS != Error ) {
            if( ExistingClient ) {
                Error = ERROR_DHCP_RESERVEDIP_EXITS;
            } else {
                Error = ERROR_DHCP_ADDRESS_NOT_AVAILABLE;
            }
        } 
    }

    DhcpFreeMemory(ClientUID);

    if( ERROR_SUCCESS == Error ) {
        //
        // If everything went fine take over this
        // address.. don't know if DHCP-type is allowed
        // If not, mark it as BOOTP.
        //

	/// Test: check added for the first call.
        if (!MemSubnetRequestAddress(
				     Subnet, ReservedAddress, TRUE,
				     FALSE, NULL, NULL
				     ) ) {
	    MemSubnetRequestAddress(
				    Subnet, ReservedAddress, TRUE,
				    TRUE, NULL, NULL
				    );
	} 
    }
    
    return Error;
}

BOOL
AdminScopedMcastRange(
    IN DHCP_IP_RANGE Range
    )
{
    if( Range.EndAddress >= ntohl(inet_addr("239.0.0.0"))
        && Range.EndAddress <= ntohl(inet_addr("239.255.255.255"))) {
        return TRUE;
    }
    
    return FALSE;
}

DWORD
EndWriteApiForSubnetElement(
    IN LPSTR ApiName,
    IN DWORD Error,
    IN DWORD Subnet,
    IN PVOID Elt
    )
{
    LPDHCP_SUBNET_ELEMENT_DATA_V4 Info = Elt;
    DWORD Reservation;
    
    if( NO_ERROR != Error ) {
        return DhcpEndWriteApi( ApiName, Error );
    }

    Reservation = 0;
    if( DhcpReservedIps == Info->ElementType ) {
        Reservation = (
            Info->Element.ReservedIp->ReservedIpAddress );
    }
    
    return DhcpEndWriteApiEx(
        ApiName, Error, FALSE, FALSE, Subnet, 0, Reservation );
}

DWORD
DhcpAddSubnetElement(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 ElementInfo,
    IN      BOOL                   fIsV5Call
)
{
    DWORD                          Error;
    ULONG                          Flag;
    DHCP_IP_RANGE                  Range;
    DHCP_BOOTP_IP_RANGE           *DhcpBootpRange;
    ULONG                          MaxBootpAllowed;

    if( DhcpSecondaryHosts == ElementInfo->ElementType ) {
        DhcpAssert(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }
    
    Flag = 0;
    
    switch( ElementInfo->ElementType ) {
    case DhcpIpRangesDhcpOnly :
    case DhcpIpRanges :
        Flag = MM_FLAG_ALLOW_DHCP; break;
    case DhcpIpRangesBootpOnly:
        Flag = MM_FLAG_ALLOW_BOOTP; break;
    case DhcpIpRangesDhcpBootp:
        Flag = MM_FLAG_ALLOW_DHCP | MM_FLAG_ALLOW_BOOTP;
        break;
    }

    if( 0 != Flag ) {
        //
        // It is an IpRange that we're trying to add..
        //

        if( NULL == ElementInfo->Element.IpRange ) {
            return ERROR_INVALID_PARAMETER;
        }
        
        if( fIsV5Call ) {
            DhcpBootpRange = (LPVOID) ElementInfo->Element.IpRange;
            Range.StartAddress = DhcpBootpRange->StartAddress;
            Range.EndAddress = DhcpBootpRange->EndAddress;
            if( Flag == (MM_FLAG_ALLOW_DHCP | MM_FLAG_ALLOW_BOOTP ) ) {
                MaxBootpAllowed = DhcpBootpRange->MaxBootpAllowed;
            } else {
                MaxBootpAllowed = ~0;
            }
        } else {
            Range = *ElementInfo->Element.IpRange;
            MaxBootpAllowed = ~0;
            Flag = 0;
        }

        if( Subnet->fSubnet || !AdminScopedMcastRange(Range) ) {
            return DhcpSubnetAddRange(
                Subnet,
                Flag,
                Range,
                MaxBootpAllowed
                );
        }

        //
        // Before adding mscope range, first check if the range
        // is in the administratively scoped region.  If so, then
        // we have to make sure that the range is atleast 256 elements
        // and also automatically insert an exclusion for the last 256.
        //

        if( Range.EndAddress < Range.StartAddress + 255 ) {
            return ERROR_MSCOPE_RANGE_TOO_SMALL;
        }

        //
        // Now add the range, and if successful, try to add the exclusion
        //
        
        Error = DhcpSubnetAddRange( Subnet, Flag, Range, MaxBootpAllowed );
        if( NO_ERROR != Error ) return Error;

        Range.StartAddress = Range.EndAddress - 255;
        return DhcpSubnetAddExcl( Subnet, Range );
        
    }

    if( DhcpExcludedIpRanges == ElementInfo->ElementType ) {

        return DhcpSubnetAddExcl(
            Subnet,
            *ElementInfo->Element.ExcludeIpRange
        );
    }

    if( DhcpReservedIps == ElementInfo->ElementType ) {
        return DhcpSubnetAddReservation(
            Subnet,
            ElementInfo->Element.ReservedIp->ReservedIpAddress,
            ElementInfo->Element.ReservedIp->ReservedForClient->Data,
            ElementInfo->Element.ReservedIp->ReservedForClient->DataLength,
            ElementInfo->Element.ReservedIp->bAllowedClientTypes
        );
    }
    return ERROR_INVALID_PARAMETER;
}

DWORD
DhcpEnumRanges(
    IN      PM_SUBNET              Subnet,
    IN      BOOL                   fOldStyle,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN OUT  LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalEnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error;
    DWORD                          FilledSize;
    DWORD                          Count;
    LONG                           Index;
    ULONG                          Type;
    DWORD                          nElements;
    LPDHCP_SUBNET_ELEMENT_DATA_V4  ElementArray;
    DHCP_SUBNET_ELEMENT_UNION_V4   ElementData;
    PARRAY                         Ranges;
    ARRAY_LOCATION                 Loc;
    PM_RANGE                       ThisRange;
    ULONG                          RangeSize = fOldStyle ? sizeof(DHCP_IP_RANGE):sizeof(DHCP_BOOTP_IP_RANGE);
    
    *nRead = *nTotal =0;
    LocalEnumInfo->NumElements =0;
    LocalEnumInfo->Elements = NULL;

    Ranges = &Subnet->Ranges;
    nElements = MemArraySize(Ranges);

    if( 0 == nElements || nElements <= *ResumeHandle )
        return ERROR_NO_MORE_ITEMS;

    Error = MemArrayInitLoc(Ranges, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error );

    for(Count = 0; Count < *ResumeHandle; Count ++ ) {
        Error = MemArrayNextLoc(Ranges, &Loc);
        if( ERROR_SUCCESS != Error ) {
            return ERROR_NO_MORE_ITEMS;
        }
    }

    ElementArray = MIDL_user_allocate(
        (nElements - Count)*sizeof(DHCP_SUBNET_ELEMENT_DATA_V4)
        );
    if( NULL == ElementArray ) return ERROR_NOT_ENOUGH_MEMORY;

    FilledSize = 0; Error = ERROR_SUCCESS;
    for(Index = 0; Count < nElements; Count ++ ) {
        Error = MemArrayGetElement(Ranges, &Loc, &ThisRange);
        DhcpAssert(ERROR_SUCCESS == Error && ThisRange);

        ElementData.IpRange = MIDL_user_allocate(RangeSize);
        if( NULL == ElementData.IpRange ) {
            while( -- Index >= 0 ) {
                MIDL_user_free(ElementArray[Index].Element.IpRange);
            }
            MIDL_user_free(ElementArray);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        if( fOldStyle ) {
            ElementData.IpRange->StartAddress = ThisRange->Start;
            ElementData.IpRange->EndAddress = ThisRange->End;
        } else {
            ((LPDHCP_BOOT_IP_RANGE)(ElementData.IpRange))->StartAddress = ThisRange->Start;
            ((LPDHCP_BOOT_IP_RANGE)(ElementData.IpRange))->EndAddress = ThisRange->End;
            ((LPDHCP_BOOT_IP_RANGE)(ElementData.IpRange))->BootpAllocated = ThisRange->BootpAllocated;
            ((LPDHCP_BOOT_IP_RANGE)(ElementData.IpRange))->MaxBootpAllowed = ThisRange->MaxBootpAllowed;
        }
        ElementArray[Index].Element = ElementData;

        if( fOldStyle ) {
            //
            // Old admin tool can understand only DhcpIpRanges -- nothin else
            //
            ElementArray[Index++].ElementType = DhcpIpRanges;
        } else {
            //
            // New admin tool can understand DhcpIpRangesDhcpOnly, BootpOnly or DhcpBootp
            //
            switch( ThisRange->State & (MM_FLAG_ALLOW_DHCP | MM_FLAG_ALLOW_BOOTP ) ) {
            case MM_FLAG_ALLOW_DHCP: Type = DhcpIpRangesDhcpOnly; break;
            case MM_FLAG_ALLOW_BOOTP: Type = DhcpIpRangesBootpOnly; break;
            default: Type = DhcpIpRangesDhcpBootp; break;
            }

            ElementArray[Index++].ElementType = Type;
        }

        FilledSize += RangeSize + sizeof(DHCP_SUBNET_ELEMENT_DATA_V4);
        if( FilledSize > PreferredMaximum ) {
            FilledSize -= RangeSize - sizeof(DHCP_SUBNET_ELEMENT_DATA_V4);
            Index --;
            MIDL_user_free(ElementData.IpRange);
            Error = ERROR_MORE_DATA;
            break;
        }
        Error = MemArrayNextLoc(Ranges, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || Count == nElements-1);
    }

    if( 0 == Index ) {
        *nRead = *nTotal = 0;
        LocalEnumInfo->NumElements = 0;
        MIDL_user_free(LocalEnumInfo->Elements);
        LocalEnumInfo->Elements = NULL;
        MIDL_user_free( ElementArray );
        return ERROR_NO_MORE_ITEMS;
    }

    if( nElements == Count ) Error = ERROR_SUCCESS;
    *nRead = Index;
    *nTotal = nElements - *ResumeHandle;
    *ResumeHandle = Count;
    LocalEnumInfo->NumElements = Index;
    LocalEnumInfo->Elements = ElementArray;
            
    return Error;
}

DWORD
DhcpEnumExclusions(
    IN      PM_SUBNET              Subnet,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN OUT  LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalEnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error;
    DWORD                          FilledSize;
    DWORD                          Count;
    LONG                           Index;
    DWORD                          nElements;
    LPDHCP_SUBNET_ELEMENT_DATA_V4  ElementArray;
    DHCP_SUBNET_ELEMENT_UNION_V4   ElementData;
    PARRAY                         Exclusions;
    ARRAY_LOCATION                 Loc;
    PM_EXCL                        ThisExcl;

    *nRead = *nTotal =0;
    LocalEnumInfo->NumElements =0;
    LocalEnumInfo->Elements = NULL;

    Exclusions = &Subnet->Exclusions;
    nElements = MemArraySize(Exclusions);

    if( 0 == nElements || nElements <= *ResumeHandle )
        return ERROR_NO_MORE_ITEMS;

    Error = MemArrayInitLoc(Exclusions, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error );

    for(Count = 0; Count < *ResumeHandle; Count ++ ) {
        Error = MemArrayNextLoc(Exclusions, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    ElementArray = MIDL_user_allocate((nElements - Count)*sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    if( NULL == ElementArray ) return ERROR_NOT_ENOUGH_MEMORY;

    FilledSize = 0; Error = ERROR_SUCCESS;
    for(Index = 0; Count < nElements; Count ++ ) {
        Error = MemArrayGetElement(Exclusions, &Loc, &ThisExcl);
        DhcpAssert(ERROR_SUCCESS == Error && ThisExcl);

        ElementData.ExcludeIpRange = MIDL_user_allocate(sizeof(DHCP_IP_RANGE));
        if( NULL == ElementData.ExcludeIpRange ) {
            while( -- Index >= 0 ) {
                MIDL_user_free(ElementArray[Index].Element.ExcludeIpRange);
            }
            MIDL_user_free(ElementArray);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        ElementData.ExcludeIpRange->StartAddress = ThisExcl->Start;
        ElementData.ExcludeIpRange->EndAddress = ThisExcl->End;
        ElementArray[Index].Element = ElementData;
        ElementArray[Index++].ElementType = DhcpExcludedIpRanges;

        FilledSize += sizeof(DHCP_IP_RANGE) + sizeof(DHCP_SUBNET_ELEMENT_DATA_V4);
        if( FilledSize > PreferredMaximum ) {
            FilledSize -= (DWORD)(sizeof(DHCP_IP_RANGE) - sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
            Index --;
            MIDL_user_free(ElementData.ExcludeIpRange);
            Error = ERROR_MORE_DATA;
            break;
        }
        Error = MemArrayNextLoc(Exclusions, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || Count == nElements-1);
    }

    if( nElements == Count ) Error = ERROR_SUCCESS;
    *nRead = Index;
    *nTotal = nElements - *ResumeHandle;
    *ResumeHandle = Count;
    LocalEnumInfo->NumElements = Index;
    LocalEnumInfo->Elements = ElementArray;

    return Error;
}

DWORD
DhcpEnumReservations(
    IN      PM_SUBNET              Subnet,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN OUT  LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalEnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error;
    DWORD                          FilledSize;
    DWORD                          Count;
    LONG                           Index;
    DWORD                          nElements;
    LPDHCP_SUBNET_ELEMENT_DATA_V4  ElementArray;
    DHCP_SUBNET_ELEMENT_UNION_V4   ElementData;
    PARRAY                         Reservations;
    ARRAY_LOCATION                 Loc;
    PM_RESERVATION                 ThisReservation;
    LPVOID                         Ptr1, Ptr2, Ptr3;

    *nRead = *nTotal =0;
    LocalEnumInfo->NumElements =0;
    LocalEnumInfo->Elements = NULL;

    Reservations = &Subnet->Reservations;
    nElements = MemArraySize(Reservations);

    if( 0 == nElements || nElements <= *ResumeHandle )
        return ERROR_NO_MORE_ITEMS;

    Error = MemArrayInitLoc(Reservations, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error );

    for(Count = 0; Count < *ResumeHandle; Count ++ ) {
        Error = MemArrayNextLoc(Reservations, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    ElementArray = MIDL_user_allocate((nElements - Count)*sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    if( NULL == ElementArray ) return ERROR_NOT_ENOUGH_MEMORY;

    FilledSize = 0; Error = ERROR_SUCCESS;
    for(Index = 0; Count < nElements; Count ++ ) {
        Error = MemArrayGetElement(Reservations, &Loc, &ThisReservation);
        DhcpAssert(ERROR_SUCCESS == Error && ThisReservation);

        if( FilledSize + sizeof(DHCP_IP_RESERVATION_V4) + ThisReservation->nBytes > PreferredMaximum ) {
            Error = ERROR_MORE_DATA;
            break;
        }

        ElementData.ReservedIp = Ptr1 = MIDL_user_allocate(sizeof(DHCP_IP_RESERVATION_V4));
        if( NULL != Ptr1 ) {
            Ptr2 = MIDL_user_allocate(sizeof(*(ElementData.ReservedIp->ReservedForClient)));
            ElementData.ReservedIp->ReservedForClient = Ptr2;
        } else Ptr2 = NULL;
        if( NULL != Ptr2 ) {
            Ptr3 = MIDL_user_allocate(ThisReservation->nBytes);
            ElementData.ReservedIp->ReservedForClient->Data = Ptr3;
        } else Ptr3 = NULL;
        if( NULL == Ptr1 || NULL == Ptr2 || NULL == Ptr3 ) {
            if( NULL != Ptr1 ) MIDL_user_free(Ptr1);
            if( NULL != Ptr2 ) MIDL_user_free(Ptr2);
            if( NULL != Ptr3 ) MIDL_user_free(Ptr3);
            while( -- Index >= 0 ) {
                MIDL_user_free(ElementArray[Index].Element.ReservedIp->ReservedForClient->Data);
                MIDL_user_free(ElementArray[Index].Element.ReservedIp->ReservedForClient);
                MIDL_user_free(ElementArray[Index].Element.ReservedIp);
            }
            MIDL_user_free(ElementArray);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        memcpy(Ptr3, ThisReservation->ClientUID, ThisReservation->nBytes);
        ElementData.ReservedIp->ReservedForClient->DataLength = ThisReservation->nBytes;

        ElementData.ReservedIp->bAllowedClientTypes = (BYTE)ThisReservation->Flags;
        ElementData.ReservedIp->ReservedIpAddress = ThisReservation->Address;
        ElementArray[Index].Element = ElementData;
        ElementArray[Index++].ElementType = DhcpReservedIps;

        FilledSize += sizeof(DHCP_IP_RESERVATION_V4) + ThisReservation->nBytes;
        DhcpAssert(FilledSize <= PreferredMaximum);

        Error = MemArrayNextLoc(Reservations, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || Count == nElements-1);
    }

    if( Count == nElements ) Error = ERROR_SUCCESS;
    *nRead = Index;
    *nTotal = nElements - *ResumeHandle;
    *ResumeHandle = Count;
    LocalEnumInfo->NumElements = Index;
    LocalEnumInfo->Elements = ElementArray;

    return Error;
}


DWORD
DhcpEnumSubnetElements(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN      BOOL                   fIsV5Call,
    IN OUT  LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalEnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    switch(EnumElementType) {
    case DhcpIpRanges:
        return DhcpEnumRanges(
            Subnet, TRUE, ResumeHandle, PreferredMaximum,
            LocalEnumInfo, nRead, nTotal
            );
    case DhcpIpRangesDhcpBootp :
        if( !fIsV5Call ) return ERROR_INVALID_PARAMETER;
        return DhcpEnumRanges(
            Subnet, FALSE, ResumeHandle, PreferredMaximum,
            LocalEnumInfo, nRead, nTotal
            );
    case DhcpSecondaryHosts:
        return ERROR_NOT_SUPPORTED;
    case DhcpReservedIps:
        return DhcpEnumReservations(
            Subnet, ResumeHandle, PreferredMaximum,
            LocalEnumInfo, nRead, nTotal
        );
    case DhcpExcludedIpRanges:
        return DhcpEnumExclusions(
            Subnet, ResumeHandle, PreferredMaximum,
            LocalEnumInfo, nRead, nTotal
        );
    default: return ERROR_INVALID_PARAMETER;
    }
}

DWORD
DhcpRemoveRange(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_IP_RANGE        Range,
    IN      DHCP_FORCE_FLAG        ForceFlag
)
{
    DWORD                          Error;
    DWORD                          Start;
    PM_RANGE                       ThisRange;

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Range->StartAddress,
        &ThisRange,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return ERROR_DHCP_INVALID_RANGE;

    if( ThisRange->Start != Range->StartAddress ||
        ThisRange->End  != Range->EndAddress )
        return ERROR_DHCP_INVALID_RANGE;

    if( DhcpFullForce != ForceFlag ) {
        if( MemBitGetSetBitsSize(ThisRange->BitMask) != 0 )
            return ERROR_DHCP_ELEMENT_CANT_REMOVE;
    }

    Error = MemSubnetDelRange(
        Subnet,
        Start = ThisRange->Start
    );
    return Error;
}

DWORD
DhcpRemoveReservation(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_IP_RESERVATION_V4 Reservation
)
{
    DWORD                          Error;
    DWORD                          ReservedAddress;
    PM_RESERVATION                 ThisReservation;
    DHCP_CLIENT_UID                dupReservation;

    ReservedAddress = Reservation->ReservedIpAddress;

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Reservation->ReservedIpAddress,
        NULL,
        NULL,
        &ThisReservation
    );

    if( ERROR_FILE_NOT_FOUND == Error )
    {
        DHCP_SEARCH_INFO    ClientInfo;

        // this might be because a bogus reservation from the db. Handle it as a regular lease:
        // the first parameter, DHCP_SRV_HANDLE ServerIpAddress is not used at all in DhcpDeleteClientInfo

        ClientInfo.SearchType = DhcpClientIpAddress;
        ClientInfo.SearchInfo.ClientIpAddress = Reservation->ReservedIpAddress;

        // instead of ERROR_DHCP_NOT_RESERVED_CLIENT, just return the result of deleting the regular lease.
        return R_DhcpDeleteClientInfo(NULL, &ClientInfo);
    }
    if( ERROR_SUCCESS != Error ) return Error;

    DhcpAssert(ThisReservation);

#if 0 // this check does not seem to be done before .. 
    if( ThisReservation->nBytes != Reservation->ReservedForClient->DataLength )
        return ERROR_DHCP_NOT_RESERVED_CLIENT;
    if( 0 != memcmp(ThisReservation->ClientUID, Reservation->ReservedForClient->Data, ThisReservation->nBytes))
        return ERROR_DHCP_NOT_RESERVED_CLIENT;
#endif

    dupReservation.DataLength = ThisReservation->nBytes;
    dupReservation.Data = DhcpAllocateMemory(dupReservation.DataLength);
    if (dupReservation.Data==NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlCopyMemory(dupReservation.Data, ThisReservation->ClientUID, dupReservation.DataLength);

    Error = MemReserveDel(
        &Subnet->Reservations,
        ReservedAddress
    );
    DhcpAssert(ERROR_SUCCESS == Error);

    Error = DhcpRemoveClientEntry(
        ReservedAddress,
        dupReservation.Data,
        dupReservation.DataLength,
        TRUE,
        FALSE
    );
    DhcpAssert(ERROR_SUCCESS == Error);

    DhcpFreeMemory(dupReservation.Data);
    return ERROR_SUCCESS;
}

DWORD
DhcpRemoveExclusion(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_IP_RANGE        ExcludedRange
)
{
    DWORD                          Error;
    DWORD                          nElements;
    DWORD                          Index;
    PM_EXCL                        ThisExclusion, CollidingExcl;
    PARRAY                         Exclusions;
    ARRAY_LOCATION                 Loc;
    DHCP_IP_ADDRESS               *ExclRegFormat;

    Error = MemSubnetGetAddressInfo(
        Subnet,
        ExcludedRange->StartAddress,
        NULL,
        &ThisExclusion,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return ERROR_DHCP_ELEMENT_CANT_REMOVE;

    DhcpAssert(ThisExclusion);

    if( ThisExclusion->Start != ExcludedRange->StartAddress ||
        ThisExclusion->End != ExcludedRange->EndAddress )
        return ERROR_INVALID_PARAMETER;

    Error = MemSubnetDelExcl(Subnet, ExcludedRange->StartAddress);
    if( ERROR_SUCCESS != Error ) return ERROR_DHCP_ELEMENT_CANT_REMOVE;
    return NO_ERROR;
}

DWORD
DhcpRemoveSubnetElement(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    IN      BOOL                   fIsV5Call,
    IN      DHCP_FORCE_FLAG        ForceFlag
)
{
    DHCP_IP_RANGE                  Range, *Rangep;
    DHCP_BOOTP_IP_RANGE           *DhcpBootpRange;
    DhcpAssert(Subnet);

    switch(RemoveElementInfo->ElementType ) {
    case DhcpIpRangesDhcpOnly:
    case DhcpIpRangesDhcpBootp:
    case DhcpIpRangesBootpOnly:
    case DhcpIpRanges: 
        if ( NULL == RemoveElementInfo->Element.IpRange ) {
            return ERROR_INVALID_PARAMETER;
        }
        if( fIsV5Call ) {
            DhcpBootpRange = (PVOID)RemoveElementInfo->Element.IpRange;
            Range.StartAddress = DhcpBootpRange->StartAddress;
            Range.EndAddress = DhcpBootpRange->EndAddress;
            Rangep = &Range;
        } else {
            Rangep = RemoveElementInfo->Element.IpRange;
        }
        return  DhcpRemoveRange(Subnet,Rangep,ForceFlag);
    case DhcpSecondaryHosts: return ERROR_CALL_NOT_IMPLEMENTED;
    case DhcpReservedIps: return DhcpRemoveReservation(Subnet, RemoveElementInfo->Element.ReservedIp);
    case DhcpExcludedIpRanges: {
        if ( NULL == RemoveElementInfo->Element.ExcludeIpRange ) {
            return ERROR_INVALID_PARAMETER;
        }
        return DhcpRemoveExclusion(Subnet,
                                   RemoveElementInfo->Element.ExcludeIpRange);
    }
    default: return ERROR_INVALID_PARAMETER;
    }
}

//================================================================================
//  the actual RPC code is here.. (all the subntapi routines)
//================================================================================

//BeginExport(function)
DWORD
R_DhcpSetSuperScopeV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPWSTR                 SuperScopeName,
    IN      BOOL                   ChangeExisting
) //EndExport(function)
{
    DWORD                          Error;

    Error = DhcpBeginWriteApi( "DhcpSetSuperScopeV4" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpSetSuperScopeV4(
        SubnetAddress,
        SuperScopeName,
        ChangeExisting
    );

    return DhcpEndWriteApiEx(
        "DhcpSetSuperScopeV4", Error, FALSE, FALSE,
        SubnetAddress, 0,0 );
}

//BeginExport(function)
DWORD
R_DhcpDeleteSuperScopeV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      LPWSTR                 SuperScopeName
) //EndExport(function)
{
    DWORD                          Error;

    Error = DhcpBeginWriteApi( "DhcpDeleteSuperScopeV4" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpDeleteSuperScope(SuperScopeName);

    return DhcpEndWriteApi("DhcpDeleteSuperScopeV4", Error );
}

//BeginExport(function)
DWORD
R_DhcpGetSuperScopeInfoV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    OUT     LPDHCP_SUPER_SCOPE_TABLE *SuperScopeTable
) //EndExport(function)
{
    DWORD                          Error;
    LPDHCP_SUPER_SCOPE_TABLE       LocalSuperScopeTable;

    Error = DhcpBeginReadApi( "DhcpGetSuperScopeInfoV4" );
    if( ERROR_SUCCESS != Error ) return Error;

    *SuperScopeTable = NULL;
    LocalSuperScopeTable = MIDL_user_allocate(sizeof(DHCP_SUPER_SCOPE_TABLE));
    if( NULL == LocalSuperScopeTable ) {
        DhcpEndReadApi( "DhcpGetSuperScopeInfoV4", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpGetSuperScopeInfo(LocalSuperScopeTable);
    if( ERROR_SUCCESS != Error ) {
        
        MIDL_user_free(LocalSuperScopeTable);
        LocalSuperScopeTable = NULL;
    } 

    *SuperScopeTable = LocalSuperScopeTable;

    DhcpEndReadApi( "DhcpGetSuperScopeInfoV4", Error );
    return Error;
}


//BeginExport(function)
DWORD
R_DhcpCreateSubnet(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) //EndExport(function)
{
    DWORD                          Error;

    Error = DhcpBeginWriteApi( "DhcpCreateSubnet" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpCreateSubnet(SubnetAddress, SubnetInfo);

    return DhcpEndWriteApiEx(
        "DhcpCreateSubnet", Error, FALSE, FALSE, SubnetAddress, 0,0  );
}

//BeginExport(function)
DWORD
R_DhcpSetSubnetInfo(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) //EndExport(function)
{
    DWORD                          Error;

    Error = DhcpBeginWriteApi( "DhcpSetSubnetInfo" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpSetSubnetInfo(SubnetAddress, SubnetInfo);

    return DhcpEndWriteApiEx(
        "DhcpSetSubnetInfo", Error, FALSE, FALSE, SubnetAddress, 0,0 );
}

//BeginExport(function)
DWORD
R_DhcpGetSubnetInfo(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    OUT     LPDHCP_SUBNET_INFO    *SubnetInfo
) //EndExport(function)
{
    DWORD                          Error;
    LPDHCP_SUBNET_INFO             LocalSubnetInfo;


    *SubnetInfo = NULL;

    Error = DhcpBeginReadApi( "DhcpGetSubnetInfo" );
    if( ERROR_SUCCESS != Error ) return Error;

    LocalSubnetInfo = MIDL_user_allocate(sizeof(DHCP_SUBNET_INFO));
    if( NULL == LocalSubnetInfo ) {
        DhcpEndReadApi( "DhcpGetSubnetInfo", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpGetSubnetInfo(SubnetAddress, LocalSubnetInfo);
    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalSubnetInfo);
        LocalSubnetInfo = NULL;
    } 

    *SubnetInfo = LocalSubnetInfo;

    DhcpEndReadApi( "DhcpGetSubnetInfo", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpEnumSubnets(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN      LPDHCP_IP_ARRAY       *EnumInfo,
    IN      DWORD                 *ElementsRead,
    IN      DWORD                 *ElementsTotal
) //EndExport(function)
{
    DWORD                          Error;
    LPDHCP_IP_ARRAY                LocalEnumInfo;

    *EnumInfo = NULL;

    Error = DhcpBeginReadApi( "DhcpEnumSubnets" );
    if( ERROR_SUCCESS != Error ) return Error;

    LocalEnumInfo = MIDL_user_allocate(sizeof(DHCP_IP_ARRAY));
    if( NULL == LocalEnumInfo ) {
        DhcpEndReadApi( "DhcpEnumSubnets", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpEnumSubnets(
        TRUE, ResumeHandle, 
        PreferredMaximum, LocalEnumInfo, ElementsRead, ElementsTotal
        );

    if( ERROR_SUCCESS != Error && ERROR_MORE_DATA != Error ) {
        MIDL_user_free(LocalEnumInfo);
    } else {
        *EnumInfo = LocalEnumInfo;
    }

    DhcpEndReadApi( "DhcpEnumSubnets", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpDeleteSubnet(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_FORCE_FLAG        ForceFlag      // if TRUE delete all turds from memory/registry/database
) //EndExport(function)
{
    DWORD                          Error;

    Error = DhcpBeginWriteApi( "DhcpDeleteSubnet" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpDeleteSubnet(SubnetAddress, ForceFlag);

    return DhcpEndWriteApiEx(
        "DhcpDeleteSubnet", Error, FALSE, FALSE, SubnetAddress, 0,0 );
}

//BeginExport(function)
DWORD
R_DhcpAddSubnetElementV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4  AddElementInfo
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error = DhcpBeginWriteApi( "DhcpAddSubnetElementV4" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );

    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpAddSubnetElement(Subnet, AddElementInfo, FALSE);
    }

    return EndWriteApiForSubnetElement(
        "DhcpAddSubnetElementV4", Error, SubnetAddress,
        AddElementInfo );
}
//BeginExport(function)
DWORD
R_DhcpAddSubnetElementV5(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V5  AddElementInfo
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error = DhcpBeginWriteApi( "DhcpAddSubnetElementV5" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );

    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpAddSubnetElement(Subnet, (PVOID)AddElementInfo, TRUE);
    }

    return EndWriteApiForSubnetElement(
        "DhcpAddSubnetElementV5", Error, SubnetAddress,
        AddElementInfo );
}

//BeginExport(function)
DWORD
R_DhcpEnumSubnetElementsV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalElementEnumInfo;

    *EnumElementInfo = NULL;
    *ElementsRead = 0;
    *ElementsTotal = 0;

    Error = DhcpBeginReadApi( "DhcpEnumSubnetElementsV4" );
    if( ERROR_SUCCESS != Error ) return Error;

    LocalElementEnumInfo = MIDL_user_allocate(sizeof(DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4));
    if( NULL == LocalElementEnumInfo ) {
        DhcpEndReadApi( "DhcpEnumSubnetElementsV4", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpEnumSubnetElements(
            Subnet,
            EnumElementType,
            ResumeHandle,
            PreferredMaximum,
            FALSE,
            LocalElementEnumInfo,
            ElementsRead,
            ElementsTotal
        );
    }

    if( ERROR_SUCCESS != Error 
        && ERROR_MORE_DATA != Error ) {
        MIDL_user_free(LocalElementEnumInfo);
    } else {
        *EnumElementInfo = LocalElementEnumInfo;
    }

    DhcpEndReadApi( "DhcpEnumSubnetElementsV4", Error );
    return Error;
}
//BeginExport(function)
DWORD
R_DhcpEnumSubnetElementsV5(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalElementEnumInfo;

    *EnumElementInfo = NULL;
    *ElementsRead = 0;
    *ElementsTotal = 0;

    Error = DhcpBeginReadApi( "DhcpEnumSubnetElementsV5" );
    if( ERROR_SUCCESS != Error ) return Error;

    LocalElementEnumInfo = MIDL_user_allocate(sizeof(DHCP_SUBNET_ELEMENT_INFO_ARRAY_V5));
    if( NULL == LocalElementEnumInfo ) {
        DhcpEndReadApi( "DhcpEnumSubnetElementsV4", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpApiAccessCheck(DHCP_VIEW_ACCESS);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpEnumSubnetElements(
            Subnet,
            EnumElementType,
            ResumeHandle,
            PreferredMaximum,
            TRUE,
            (PVOID)LocalElementEnumInfo,
            ElementsRead,
            ElementsTotal
        );
    }

    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalElementEnumInfo);
    } else {
        *EnumElementInfo = (PVOID)LocalElementEnumInfo;
    }

    DhcpEndReadApi( "DhcpEnumSubnetElementsV4", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpRemoveSubnetElementV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error = DhcpBeginWriteApi( "DhcpRemoveSubnetElementV4" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpRemoveSubnetElement(Subnet, RemoveElementInfo, FALSE, ForceFlag);
    }

    return EndWriteApiForSubnetElement(
        "DhcpRemoveSubnetElementV4", Error, SubnetAddress,
        RemoveElementInfo );
}

//BeginExport(function)
DWORD
R_DhcpRemoveSubnetElementV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V5 RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error = DhcpBeginWriteApi( "DhcpRemoveSubnetElementV4" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpRemoveSubnetElement(Subnet, (PVOID)RemoveElementInfo, TRUE, ForceFlag);
    }

    return EndWriteApiForSubnetElement(
        "DhcpRemoveSubnetElementV4", Error, SubnetAddress,
        RemoveElementInfo );
}

DWORD
R_DhcpScanDatabase(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function scans the database entries and registry bit-map for
    specified subnet scope and veryfies to see they match. If they
    don't match, this api will return the list of inconsistent entries.
    Optionally FixFlag can be used to fix the bad entries.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : Address of the subnet scope to verify.

    FixFlag : If this flag is TRUE, this api will fix the bad entries.

    ScanList : List of bad entries returned. The caller should free up
        this memory after it has been used.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;
    PM_SUBNET   Subnet;

    DhcpPrint(( DEBUG_APIS, "DhcpScanDatabase is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }


    DhcpAcquireWriteLock();

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) {
        DhcpReleaseWriteLock();
        return ERROR_DHCP_SUBNET_NOT_PRESENT;
    }
    
    if( ERROR_SUCCESS != Error) {
        DhcpReleaseWriteLock();
        return Error;
    }

    DhcpAssert(NULL != Subnet);

    Error = ScanDatabase(
        Subnet,
        FixFlag,
        ScanList
    );

    DhcpReleaseWriteLock();
    DhcpScheduleRogueAuthCheck();

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS, "DhcpScanDatabase  failed, %ld.\n",
                        Error ));
    }

    return(Error);
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\rpcapi1.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: most of the rpc apis are here and some miscellaneous functions too
//================================================================================

//================================================================================
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  GENERAL WARNING: Most of the routines in this file allocate memory using
//  MIDL functions because they are used in the RPC code path (??? Really, it
//  because that is how they were written before by Madan Appiah and co? )
//  So, BEWARE.   If you read this after getting burnt, there! I tried to tell ya.
//  -- RameshV
//================================================================================

#include    <dhcppch.h>

#include "uniqid.h"

#define   MAX_CLASS_DATA_LENGTH 255

#define     CONFIG_CHANGE_CHECK()  do{if( ERROR_SUCCESS == Error) DhcpRegUpdateTime(); } while(0)


typedef  struct _OPTION_BIN {
    DWORD                          DataSize;
    DHCP_OPTION_DATA_TYPE          OptionType;
    DWORD                          NumElements;
    BYTE                           Data[0];
} OPTION_BIN, *LPOPTION_BIN;

#define IS_SPACE_AVAILABLE(FilledSize, AvailableSize, RequiredSpace )   ((FilledSize) + (RequiredSpace) <= (AvailableSize) )

BOOL        _inline
CheckForVendor(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendor
)
{
    if( IsVendor ) return (256 <= OptId);
    return 256 > OptId;
}

DWORD       _inline
ConvertOptIdToRPCValue(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendorUnused
)
{
    return OptId % 256;
}

//BeginExport(inline)
DWORD       _inline
ConvertOptIdToMemValue(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendor
)
{
    if( IsVendor ) return OptId + 256;
    return OptId;
}
//EndExport(inline)

DWORD
DhcpUnicodeToUtf8Size(
    IN LPWSTR Str
    )
{
    return WideCharToMultiByte(
        CP_UTF8, 0, Str, -1, NULL, 0, NULL, NULL );
}

DWORD
DhcpUnicodeToUtf8(
    IN LPWSTR Str,
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    return WideCharToMultiByte(
        CP_UTF8, 0, Str, -1, Buffer, BufSize, NULL, NULL );
}
    
//BeginExport(function)
DWORD                                             // ERROR_MORE_DATA with DataSize as reqd size if buffer insufficient
DhcpParseRegistryOption(                          // parse the options to fill into this buffer
    IN      LPBYTE                 Value,         // input option buffer
    IN      DWORD                  Length,        // size of input buffer
    OUT     LPBYTE                 DataBuffer,    // output buffer
    OUT     DWORD                 *DataSize,      // given buffer space on input, filled buffer space on output
    IN      BOOL                   fUtf8
) //EndExport(function)
{
    LPOPTION_BIN                   OptBin;
    LPBYTE                         OptData;
    DWORD                          OptSize;
    DWORD                          OptType;
    DWORD                          nElements;
    DWORD                          i;
    DWORD                          NetworkULong;
    DWORD                          DataLength;
    DWORD                          FilledSize;
    DWORD                          AvailableSize;
    WORD                           NetworkUShort;

    FilledSize = 0;
    AvailableSize = *DataSize;
    *DataSize = 0;

    OptBin = (LPOPTION_BIN)Value;

    if(OptBin->DataSize != Length) {              // internal error!
        DhcpPrint((DEBUG_ERRORS, "Internal error while parsing options\n"));
        DhcpAssert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    OptType = OptBin->OptionType;
    nElements = OptBin->NumElements;
    OptData = OptBin->Data;
    OptData = ROUND_UP_COUNT(sizeof(OPTION_BIN), ALIGN_WORST) + (LPBYTE)OptBin;

    for(i = 0; i < nElements ; i ++ ) {           // marshal the elements in the data buffer
        switch( OptType ) {
        case DhcpByteOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(BYTE)) ) {
                *DataBuffer = (BYTE)(*(DWORD UNALIGNED*)OptData);
                DataBuffer += sizeof(BYTE);
            }
            OptData += sizeof(DWORD);
            FilledSize += sizeof(BYTE);
            break;

        case DhcpWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(WORD)) ) {
                NetworkUShort = htons((WORD)(*(DWORD UNALIGNED*)OptData));
                SmbPutUshort( (LPWORD)DataBuffer, NetworkUShort );
                DataBuffer += sizeof(WORD);
            }
            OptData += sizeof(DWORD);
            FilledSize += sizeof(WORD);
            break;

        case DhcpDWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD)) ) {
                NetworkULong = htonl(*(DWORD UNALIGNED *)OptData);
                SmbPutUlong( (LPDWORD)DataBuffer, NetworkULong );
                DataBuffer += sizeof(DWORD);
            }
            OptData += sizeof(DWORD);
            FilledSize += sizeof(DWORD);
            break;

        case DhcpDWordDWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD)*2) ) {
                NetworkULong = htonl(((DWORD_DWORD UNALIGNED*)OptData)->DWord1);
                SmbPutUlong( (LPDWORD)DataBuffer, NetworkULong );
                DataBuffer += sizeof(DWORD);
                NetworkULong = htonl(((DWORD_DWORD UNALIGNED*)OptData)->DWord2);
                SmbPutUlong( (LPDWORD)DataBuffer, NetworkULong );
                DataBuffer += sizeof(DWORD);
            }
            OptData += sizeof(DWORD_DWORD);
            FilledSize += sizeof(DWORD_DWORD);
            break;

        case DhcpIpAddressOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD) ) ) {
                NetworkULong = htonl(*(DHCP_IP_ADDRESS UNALIGNED *)OptData);
                SmbPutUlong( (LPDWORD)DataBuffer, NetworkULong );
                DataBuffer += sizeof(DWORD);
            }
            OptData += sizeof(DHCP_IP_ADDRESS);
            FilledSize += sizeof(DWORD);
            break;

        case DhcpStringDataOption:
            DataLength = *((WORD UNALIGNED*)OptData);
            OptData += sizeof(DWORD);

            DhcpAssert((wcslen((LPWSTR)OptData)+1)*sizeof(WCHAR) <= DataLength);
            if( fUtf8 ) {
                DataLength = DhcpUnicodeToUtf8Size((LPWSTR)OptData);
            } else {
                DataLength = DhcpUnicodeToOemSize((LPWSTR)OptData);
            }
            
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength ) ) {
                if( fUtf8 ) {
                    DhcpUnicodeToUtf8( (LPWSTR)OptData,(LPSTR)DataBuffer, DataLength );
                } else {
                    DhcpUnicodeToOem( (LPWSTR)OptData, (LPSTR)DataBuffer );
                }
                DataBuffer += DataLength;
            }

            FilledSize += DataLength ;
            OptData += ROUND_UP_COUNT(DataLength, ALIGN_DWORD);
            break;

        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption:
            DataLength = *((WORD UNALIGNED *)OptData);
            OptData += sizeof(DWORD);

            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength) ) {
                RtlCopyMemory( DataBuffer, OptData, DataLength );
                DataBuffer += DataLength;
            }
            OptData += ROUND_UP_COUNT(DataLength, ALIGN_DWORD);
            FilledSize += DataLength;

            DhcpAssert( i == 0 );                 // should not be more than one binary element specified
            if( i > 0 ) {
                DhcpPrint(( DEBUG_OPTIONS, "Multiple Binary option packed\n"));
            }
            break;

        default:
            DhcpPrint(( DEBUG_OPTIONS, "Unknown option found\n"));
            break;
        }
    }

    *DataSize = FilledSize;
    if( FilledSize > AvailableSize ) return ERROR_MORE_DATA;

    return ERROR_SUCCESS;
}

DWORD
DhcpConvertOptionRPCToRegFormat(
    IN      LPDHCP_OPTION_DATA     Option,
    IN OUT  LPBYTE                 RegBuffer,     // OPTIONAL
    IN OUT  DWORD                 *BufferSize     // input: buffer size, output: filled buffer size
)
{
    OPTION_BIN                     Dummy;
    DWORD                          AvailableSize;
    DWORD                          FilledSize;
    DWORD                          nElements;
    DWORD                          i;
    DWORD                          DataLength;
    DWORD                          Length;
    DHCP_OPTION_DATA_TYPE          OptType;
    LPBYTE                         BufStart;

    AvailableSize = *BufferSize;
    FilledSize = 0;
    BufStart = RegBuffer;

    Dummy.DataSize = sizeof(Dummy);
    Dummy.OptionType = DhcpByteOption;
    Dummy.NumElements = 0;
    FilledSize = ROUND_UP_COUNT(sizeof(Dummy), ALIGN_WORST);

    RegBuffer += FilledSize;                      // will do this actual filling at the very end

    if (( NULL == Option ) ||
        ( NULL == Option->Elements )) {
        return ERROR_INVALID_PARAMETER;
    }

    OptType = Option->Elements[0].OptionType;
    nElements = Option->NumElements;

    for( i = 0; i < nElements ; i ++ ) {          // marshal each argument in
        if ( OptType != Option->Elements[i].OptionType ) {
            return ERROR_INVALID_PARAMETER;       // do not allow random option types, all got to be same
        }

        switch(OptType) {
        case DhcpByteOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD)) ) {
                *((LPDWORD)RegBuffer) = Option->Elements[i].Element.ByteOption;
                RegBuffer += sizeof(DWORD);
            }
            FilledSize += sizeof(DWORD);
            break;
        case DhcpWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD)) ) {
                *((LPDWORD)RegBuffer) = Option->Elements[i].Element.WordOption;
                RegBuffer += sizeof(DWORD);
            }
            FilledSize += sizeof(DWORD);
            break;
        case DhcpDWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD) )) {
                *((LPDWORD)RegBuffer) = Option->Elements[i].Element.DWordOption;
                RegBuffer += sizeof(DWORD);
            }
            FilledSize += sizeof(DWORD);
            break;
        case DhcpDWordDWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD_DWORD)) ) {
                *((LPDWORD_DWORD)RegBuffer) = Option->Elements[i].Element.DWordDWordOption;
                RegBuffer += sizeof(DWORD_DWORD);
            }
            FilledSize += sizeof(DWORD_DWORD);
            break;
        case DhcpIpAddressOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DHCP_IP_ADDRESS)) ) {
                *((LPDHCP_IP_ADDRESS)RegBuffer) = Option->Elements[i].Element.IpAddressOption;
                RegBuffer += sizeof(DHCP_IP_ADDRESS);
            }
            FilledSize += sizeof(DHCP_IP_ADDRESS);
            break;
        case DhcpStringDataOption:
            if( NULL == Option->Elements[i].Element.StringDataOption ) {
                DataLength = ROUND_UP_COUNT((FilledSize + sizeof(DWORD) + sizeof(WCHAR)), ALIGN_DWORD);
                DataLength -= FilledSize;
                if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength ) ) {
                    *(LPDWORD)RegBuffer = (DWORD) sizeof(WCHAR);
                    RegBuffer += sizeof(DWORD);
                    *(LPWSTR)RegBuffer = L'\0';
                    RegBuffer += ROUND_UP_COUNT(sizeof(WCHAR), ALIGN_DWORD);
                    DhcpAssert(sizeof(DWORD) + ROUND_UP_COUNT(sizeof(WCHAR),ALIGN_DWORD) == DataLength);
                }
                FilledSize += DataLength;
                break;
            }

            Length = (1+wcslen(Option->Elements[i].Element.StringDataOption))*sizeof(WCHAR);
            DataLength = ROUND_UP_COUNT((Length + FilledSize + sizeof(DWORD)), ALIGN_DWORD);
            DataLength -= FilledSize;

            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength) ) {
                *((LPDWORD)RegBuffer) = Length;
                RegBuffer += sizeof(DWORD);
                memcpy(RegBuffer, Option->Elements[i].Element.StringDataOption, Length );
                RegBuffer += ROUND_UP_COUNT(Length, ALIGN_DWORD);
                DhcpAssert(ROUND_UP_COUNT(Length,ALIGN_DWORD) + sizeof(DWORD) == DataLength);
            }
            FilledSize += DataLength;
            break;
        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption:
            Length = Option->Elements[i].Element.BinaryDataOption.DataLength;
            DataLength = ROUND_UP_COUNT((FilledSize+Length+sizeof(DWORD)), ALIGN_DWORD);
            DataLength -= FilledSize;
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength) ) {
                *((LPDWORD)RegBuffer) = Length;
                RegBuffer += sizeof(DWORD);
                memcpy(RegBuffer, Option->Elements[i].Element.BinaryDataOption.Data, Length);
                Length = ROUND_UP_COUNT(Length, ALIGN_DWORD);
                DhcpAssert(Length + sizeof(DWORD) == DataLength);
                RegBuffer += Length;
            }
            FilledSize += DataLength;
            break;
        default:
            return ERROR_INVALID_PARAMETER;       // Dont support any other kind of options
        }
    }
    // Length = ROUND_UP_COUNT(FilledSize, ALIGN_WORST);
    *BufferSize = FilledSize;
    if( AvailableSize < FilledSize ) return ERROR_MORE_DATA;

    Dummy.NumElements = nElements;
    Dummy.DataSize = *BufferSize;
    Dummy.OptionType = OptType;
    memcpy(BufStart, (LPBYTE)&Dummy, sizeof(Dummy));
    return ERROR_SUCCESS;
}

DWORD
DhcpConvertOptionRegToRPCFormat(
    IN      LPBYTE                 Buffer,
    IN      DWORD                  BufferSize,
    OUT     LPDHCP_OPTION_DATA     Option,        // struct pre-allocated, all sub fields will be allocated..
    OUT     DWORD                 *AllocatedSize  // OPTIONAL, total # of bytes allocated..
)
{
    LPOPTION_BIN                   OptBin;
    LPBYTE                         OptData;
    LPBYTE                         DataBuffer;
    DWORD                          OptSize;
    DWORD                          OptType;
    DWORD                          nElements;
    DWORD                          i;
    DWORD                          NetworkULong;
    DWORD                          DataLength;
    DWORD                          FilledSize;
    DWORD                          AvailableSize;
    WORD                           NetworkUShort;
    LPDHCP_OPTION_DATA_ELEMENT     Elements;

    FilledSize = 0;
    if( AllocatedSize ) *AllocatedSize = 0;

    OptBin = (LPOPTION_BIN)Buffer;

    if(OptBin->DataSize != BufferSize) {              // internal error!
        DhcpPrint((DEBUG_ERRORS, "Internal error while parsing options\n"));
        DhcpAssert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    OptType = OptBin->OptionType;
    nElements = OptBin->NumElements;
    OptData = OptBin->Data;
    OptData = ROUND_UP_COUNT(sizeof(OPTION_BIN), ALIGN_WORST) + (LPBYTE)OptBin;

    Option->NumElements = 0;
    Option->Elements = NULL;

    if( 0 == nElements ) {
        return ERROR_SUCCESS;
    }

    Elements = (LPDHCP_OPTION_DATA_ELEMENT)MIDL_user_allocate(nElements*sizeof(DHCP_OPTION_DATA_ELEMENT));
    if( NULL == Elements ) return ERROR_NOT_ENOUGH_MEMORY;

    for(i = 0; i < nElements ; i ++ ) {           // marshal the elements in the data buffer
        Elements[i].OptionType = OptType;

        switch( OptType ) {
        case DhcpByteOption:
            Elements[i].Element.ByteOption = *((LPBYTE)OptData);
            OptData += sizeof(DWORD);
            break;

        case DhcpWordOption:
            Elements[i].Element.WordOption = (WORD)(*((LPDWORD)OptData));
            OptData += sizeof(DWORD);
            break;

        case DhcpDWordOption:
            Elements[i].Element.DWordOption = *((LPDWORD)OptData);
            OptData += sizeof(DWORD);
            break;

        case DhcpDWordDWordOption:
            Elements[i].Element.DWordDWordOption = *((LPDWORD_DWORD)OptData);
            OptData += sizeof(DWORD_DWORD);
            break;

        case DhcpIpAddressOption:
            Elements[i].Element.IpAddressOption = *((LPDHCP_IP_ADDRESS)OptData);
            OptData += sizeof(DHCP_IP_ADDRESS);
            break;

        case DhcpStringDataOption:
        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption:
            DataLength = *((LPWORD)OptData);
            OptData += sizeof(DWORD);

        if ( 0 != DataLength) {
        DataBuffer = MIDL_user_allocate(DataLength);
        if( DataBuffer == NULL ) {
            while( i -- >= 1 ) {                   // free all local strucutures..
            _fgs__DHCP_OPTION_DATA_ELEMENT(&Elements[i]);
            }
            MIDL_user_free(Elements);
            return ERROR_NOT_ENOUGH_MEMORY;   // cleaned everything, so return silently
        }
        
        RtlCopyMemory( DataBuffer, OptData, DataLength );
        OptData += ROUND_UP_COUNT(DataLength, ALIGN_DWORD);
        FilledSize += DataLength;
        } // if
        else {
        DataBuffer = NULL;
        }
        if( OptType == DhcpStringDataOption ) {
        Elements[i].Element.StringDataOption = (LPWSTR)DataBuffer;
        } else {
        Elements[i].Element.BinaryDataOption.DataLength = DataLength;
        Elements[i].Element.BinaryDataOption.Data = DataBuffer;
        }
        if ( DhcpStringDataOption != OptType ) {
        // should not be more than one binary or encapsulated option 
        DhcpAssert( i == 0 ); 
        }
            if( i > 0 ) {
                DhcpPrint(( DEBUG_OPTIONS, "Multiple Binary option packed\n"));
            }
            break;

        default:
            DhcpPrint(( DEBUG_OPTIONS, "Unknown option found\n"));
            break;
        }
    }

    Option->NumElements = i;                      // this handles the case of a wrong option being ignored..
    Option->Elements = Elements;

    if(AllocatedSize ) {                          // if asked for allocated size, fill that in
        *AllocatedSize = nElements * sizeof(DHCP_OPTION_DATA_ELEMENT) + FilledSize;
    }
    return ERROR_SUCCESS;
}

DWORD
ConvertOptionInfoRPCToMemFormat(
    IN      LPDHCP_OPTION          OptionInfo,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *OptId,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
)
{
    DWORD                          Error;

    if( Name ) *Name = OptionInfo->OptionName;
    if( Comment ) *Comment = OptionInfo->OptionComment;
    if( OptId ) *OptId = (DWORD)(OptionInfo->OptionID);
    if( Value ) {
        *Value = NULL;
        if( !ValueSize ) return ERROR_INVALID_PARAMETER;
        *ValueSize = 0;
        Error = DhcpConvertOptionRPCToRegFormat(
            &OptionInfo->DefaultValue,
            NULL,
            ValueSize
        );

        if( ERROR_MORE_DATA != Error ) return Error;
        DhcpAssert(0 != *ValueSize);

        *Value = DhcpAllocateMemory(*ValueSize);
        if( NULL == *Value ) {
            *ValueSize = 0;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        Error = DhcpConvertOptionRPCToRegFormat(
            &OptionInfo->DefaultValue,
            *Value,
            ValueSize
        );

        DhcpAssert(ERROR_MORE_DATA != Error);
        DhcpAssert(ERROR_SUCCESS == Error);

        if( ERROR_SUCCESS != Error ) {
            DhcpFreeMemory(*Value);
            *Value = NULL;
            *ValueSize = 0;
            return Error;
        }
    }

    return ERROR_SUCCESS;
}

DWORD       _inline
DhcpGetClassIdFromName(
    IN      LPWSTR                 Name,
    OUT     DWORD                 *ClassId
)
{
    DWORD                          Error;
    PM_CLASSDEF                    ClassDef;

    Error = ERROR_SUCCESS;
    if( NULL == Name ) *ClassId = 0;
    else {
        Error = MemServerGetClassDef(
            DhcpGetCurrentServer(),
            0,
            Name,
            0,
            NULL,
            &ClassDef
        );
        if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_CLASS_NOT_FOUND;
        else if( ERROR_SUCCESS == Error ) {
            DhcpAssert(ClassDef);
            if( ClassDef->IsVendor == TRUE ) {
                Error = ERROR_DHCP_CLASS_NOT_FOUND;
            } else {
                *ClassId = ClassDef->ClassId;
            }
        }
    }
    return Error;
}

DWORD       _inline
DhcpGetVendorIdFromName(
    IN      LPWSTR                 Name,
    OUT     DWORD                 *VendorId
)
{
    DWORD                          Error;
    PM_CLASSDEF                    ClassDef;

    Error = ERROR_SUCCESS;
    if( NULL == Name ) *VendorId = 0;
    else {
        Error = MemServerGetClassDef(
            DhcpGetCurrentServer(),
            0,
            Name,
            0,
            NULL,
            &ClassDef
        );
        if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_CLASS_NOT_FOUND;
        else if( ERROR_SUCCESS == Error ) {
            DhcpAssert(ClassDef);
            if( ClassDef->IsVendor == FALSE ) {
                Error = ERROR_DHCP_CLASS_NOT_FOUND;
            } else {
                *VendorId = ClassDef->ClassId;
            }
        }
    }
    return Error;
}

DWORD                                             // fail if class absent or exists in memory (registry obj may exist tho)
DhcpCreateOptionDef(                              // Create, fill the memory and write it to registry
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptId,
    IN      DWORD                  OptType,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptLen         // these should be ConvertOptionInfoRPCToMemFormat'ed
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_OPTDEF                      OptDef;

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetOptDef(
        DhcpGetCurrentServer(),
        ClassId,
        VendorId,
        OptId,
        Name,
        &OptDef
    );
    if( ERROR_FILE_NOT_FOUND != Error ) {
        if( ERROR_SUCCESS == Error ) Error = ERROR_DHCP_OPTION_EXITS;
        return Error;
    }

    Error = MemServerAddOptDef(
        DhcpGetCurrentServer(),
        ClassId,
        VendorId,
        OptId,
        Name,
        Comment,
        OptType,
        OptVal,
        OptLen,
    INVALID_UNIQ_ID
    );
    return Error;
} // DhcpCreateOptionDef()

DWORD
DhcpModifyOptionDef(                              // fill the memory and write it to registry (must exist)
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptId,
    IN      DWORD                  OptType,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptLen         // these should be ConvertOptionInfoRPCToMemFormat'ed
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerDelOptDef(                   // now try to delete it from memory..
        DhcpGetCurrentServer(),
        ClassId,
        VendorId,
        OptId
    );
    if( ERROR_FILE_NOT_FOUND == Error ) {         // oops could not? then this option is not present..
        return ERROR_DHCP_OPTION_NOT_PRESENT;
    }

    Error =  DhcpCreateOptionDef(                 // cleared registry and memory, so safely create the option..
        Name,
        Comment,
        ClassName,
        VendorName,
        OptId,
        OptType,
        OptVal,
        OptLen
    );

    DhcpAssert(ERROR_DHCP_OPTION_EXITS != Error); // dont expect this to be a problem, as we just deleted it

    return Error;
}

LPWSTR
CloneLPWSTR(                                      // allocate and copy a LPWSTR type
    IN      LPWSTR                 Str
)
{
    LPWSTR                         S;

    if( NULL == Str ) return NULL;
    S = MIDL_user_allocate(sizeof(WCHAR)*(1+wcslen(Str)));
    if( NULL == S ) return NULL;                  // what else to do here? 
    wcscpy(S, Str);
    return S;
}

LPBYTE
CloneLPBYTE(
    IN      LPBYTE                 Bytes,
    IN      DWORD                  nBytes
)
{
    LPBYTE                         Ptr;

    DhcpAssert(Bytes && nBytes > 0);
    Ptr = MIDL_user_allocate(nBytes);
    if( NULL == Ptr ) return Ptr;
    memcpy(Ptr,Bytes,nBytes);

    return Ptr;
}

DWORD
DhcpGetOptionDefInternal(                         // search by classid and (optionid or option name) and fill RPC struct
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      PM_OPTDEF              OptDef,
    OUT     LPDHCP_OPTION          OptionInfo,    // MIDL_user_allocate fields in the structure
    OUT     DWORD                 *AllocatedSize  // OPTIONAL # of bytes allocated
)
{
    DWORD                          Error;
    DWORD                          FilledSize;
    DWORD                          OptId = OptDef->OptId;

    FilledSize = 0;

    OptionInfo->OptionID = ConvertOptIdToRPCValue(OptId, TRUE);
    OptionInfo->OptionName = CloneLPWSTR(OptDef->OptName);
    if( OptDef->OptName ) FilledSize += sizeof(WCHAR)*(1+wcslen(OptDef->OptName));
    OptionInfo->OptionComment = CloneLPWSTR(OptDef->OptComment);
    if( OptDef->OptComment ) FilledSize += sizeof(WCHAR)*(1+wcslen(OptDef->OptComment));
    OptionInfo->OptionType = OptDef->Type;
    Error = DhcpConvertOptionRegToRPCFormat(
        OptDef->OptVal,
        OptDef->OptValLen,
        &OptionInfo->DefaultValue,
        AllocatedSize
    );
    if( AllocatedSize ) (*AllocatedSize) += FilledSize;

    if( ERROR_SUCCESS != Error ) {                // cleanup everything..
        _fgs__DHCP_OPTION(OptionInfo);            // lookup oldstub.c for this mystery
        if( AllocatedSize ) *AllocatedSize = 0;

        DhcpPrint((DEBUG_APIS, "DhcpGetOptionDefInternal(%ld):%ld [0x%lx]\n", OptId, Error, Error));
    }

    return Error;
}

DWORD
DhcpGetOptionDef(                                 // search by classid and (optionid or option name) and fill RPC struct
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptId,
    IN      LPWSTR                 OptName,
    OUT     LPDHCP_OPTION          OptionInfo,    // MIDL_user_allocate fields in the structure
    OUT     DWORD                 *AllocatedSize  // OPTIONAL # of bytes allocated
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_OPTDEF                      OptDef;

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetOptDef(
        DhcpGetCurrentServer(),
        ClassId,
        VendorId,
        OptId,
        OptName,
        &OptDef
    );
    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_OPTION_NOT_PRESENT;
    if( ERROR_SUCCESS != Error ) return Error;

    return DhcpGetOptionDefInternal(
        ClassId,
        VendorId,
        OptDef,
        OptionInfo,
        AllocatedSize
    );
}

DWORD
DhcpEnumRPCOptionDefs(                            // enumerate for the RPC call
    IN      DWORD                  Flags,         // DHCP_FLAGS_OPTION_IS_VENDOR ==> this opt is vendor spec..
    IN OUT  DWORD                 *ResumeHandle,  // integer position in the registry..
    IN      LPWSTR                 ClassName,     // which class is being referred here?
    IN      LPWSTR                 VendorName,    // if opt is vendor specific, who is vendor?
    IN      DWORD                  PreferredMax,  // preferred max # of bytes..
    OUT     LPDHCP_OPTION_ARRAY   *OptArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error, Error2;
    DWORD                          nElements;
    DWORD                          Index;
    DWORD                          Count;
    DWORD                          AllocatedSize;
    DWORD                          FilledSize;
    DWORD                          ClassId;
    DWORD                          VendorId;
    BOOL                           IsVendor;
    PARRAY                         pArray;
    ARRAY_LOCATION                 Loc;
    LPDHCP_OPTION_ARRAY            LocalOptArray;
    PM_OPTCLASSDEFLIST             OptClassDefList;
    PM_OPTDEFLIST                  OptDefList;
    PM_OPTDEF                      OptDef;

    *OptArray = NULL;
    *nRead = 0;
    *nTotal = 0;
    FilledSize = 0;

    IsVendor = ((Flags & DHCP_FLAGS_OPTION_IS_VENDOR) != 0);
    if( FALSE == IsVendor && 0 != Flags ) return ERROR_INVALID_PARAMETER;

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    *OptArray = NULL;
    *nRead = *nTotal = 0;

    OptClassDefList = &(DhcpGetCurrentServer()->OptDefs);
    Error = MemOptClassDefListFindOptDefList(
        OptClassDefList,
        ClassId,
        VendorId,
        &OptDefList
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_NO_MORE_ITEMS;
    if( ERROR_SUCCESS != Error ) return Error;

    nElements = MemArraySize(pArray = &OptDefList->OptDefArray);
    if( 0 == nElements || nElements <= *ResumeHandle ) {
        return ERROR_NO_MORE_ITEMS;
    }

    Count = 0;
    Error = MemArrayInitLoc(pArray, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);
    while(Count < *ResumeHandle ) {
        Count ++;
        Error = MemArrayGetElement(pArray, &Loc, (LPVOID*)&OptDef);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != OptDef);
        DhcpPrint((DEBUG_APIS, "Discarding option <%ws>\n", OptDef->OptName));
        Error = MemArrayNextLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    LocalOptArray = MIDL_user_allocate(sizeof(DHCP_OPTION_ARRAY));
    if( NULL == LocalOptArray ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LocalOptArray->NumElements = 0;
    LocalOptArray->Options = MIDL_user_allocate(sizeof(DHCP_OPTION)*(nElements- (*ResumeHandle)));
    if( NULL == LocalOptArray->Options ) {
        MIDL_user_free(LocalOptArray);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Index = 0;
    Error = ERROR_SUCCESS;
    while(Count < nElements ) {
        Count ++;

        Error = MemArrayGetElement(pArray, &Loc, (LPVOID*)&OptDef);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != OptDef);
        Error = MemArrayNextLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || Count == nElements);

        Error = ERROR_SUCCESS;
        if( !CheckForVendor(OptDef->OptId,IsVendor) ) continue;
        Error = DhcpGetOptionDef(
            ClassName,
            VendorName,
            OptDef->OptId,
            NULL,
            &(LocalOptArray->Options[Index]),
            &AllocatedSize
        );
        if( ERROR_SUCCESS != Error ) {
            LocalOptArray->NumElements = Index;
            _fgs__DHCP_OPTION_ARRAY( LocalOptArray );
            MIDL_user_free( LocalOptArray );
            return Error;
        }
        if( FilledSize + AllocatedSize + sizeof(DHCP_OPTION) < PreferredMax ) {
            FilledSize += AllocatedSize + sizeof(DHCP_OPTION);
            Index ++;
        } else {
            Error = ERROR_MORE_DATA;
            _fgs__DHCP_OPTION(&(LocalOptArray->Options[Index]));
            break;
        }
    }

    LocalOptArray->NumElements = Index;
    if( 0 == Index ) {
        MIDL_user_free(LocalOptArray->Options);
        MIDL_user_free(LocalOptArray);
        if( ERROR_SUCCESS == Error ) return ERROR_NO_MORE_ITEMS;
        return Error;
    }

    *OptArray = LocalOptArray;
    *nRead = Index;
    *nTotal = nElements - Count + Index;
    *ResumeHandle = Count;

    return Error;
}

DWORD
DhcpDeleteOptionDef(
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptionId
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerDelOptDef(
        DhcpGetCurrentServer(),
        ClassId,
        VendorId,
        OptionId
    );

    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_OPTION_NOT_PRESENT;
    return Error;
}

DWORD
EndWriteApiForScopeInfo(
    IN LPSTR ApiName,
    IN DWORD Error,
    IN LPDHCP_OPTION_SCOPE_INFO ScopeInfo
    )
{
    DWORD                          Scope, Mscope, Res;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;

    if( NO_ERROR != Error ) {
        return DhcpEndWriteApi( ApiName, Error );
    }

    Scope = Mscope = Res = 0;

    Subnet = NULL; Reservation = NULL;
    switch( ScopeInfo->ScopeType ) {
    case DhcpSubnetOptions:
        Error = MemServerGetAddressInfo(
            DhcpGetCurrentServer(),
            ScopeInfo->ScopeInfo.SubnetScopeInfo,
            &Subnet, NULL, NULL, NULL );
        if( ERROR_SUCCESS != Error ) {            // got the subnet in question
            Subnet = NULL;
        }
        break;
    case DhcpMScopeOptions :
        Error = DhcpServerFindMScope(
            DhcpGetCurrentServer(),
            INVALID_MSCOPE_ID,
            ScopeInfo->ScopeInfo.MScopeInfo,
            &Subnet
            );

        if( ERROR_SUCCESS != Error ) {            // got the subnet in question
            Subnet = NULL;
        }
    case DhcpReservedOptions :
        Error = MemServerGetAddressInfo(
            DhcpGetCurrentServer(),
            ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress,
            &Subnet, NULL, NULL, &Reservation
        );
        if( ERROR_SUCCESS != Error ) {            // found the reservation in question
            Subnet = NULL; Reservation = NULL;
        }
        break;
    }

    if( Reservation != NULL ) {
        Res = Reservation->Address;
    } else if( Subnet ) {
        if( Subnet->fSubnet ) {
            Scope = Subnet->Address;
        } else {
            Mscope = Subnet->MScopeId;
            if( 0 == Mscope ) Mscope = INVALID_MSCOPE_ID;
        }
    }

    return DhcpEndWriteApiEx(
        ApiName, NO_ERROR, FALSE, TRUE, Scope, Mscope, Res );
}                    
        
DWORD
DhcpSetOptionValue(                               // add/replace this option value to inmemory store and registry
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptId,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptData
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_OPTDEF                      OptDef;
    PM_OPTDEFLIST                  OptDefList;
    PM_OPTCLASS                    OptClass;
    PM_OPTION                      Option;
    PM_OPTION                      DeletedOption;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;
    LPBYTE                         Value;
    DWORD                          ValueSize;

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        Error = MemServerGetOptDef(               // dont allow option values without defs only for default values..
            DhcpGetCurrentServer(),
            0, // ClassId,                        // dont bother about the class id -- get this option anyways
            VendorId,
            OptId,
            NULL,
            &OptDef
        );
        if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_OPTION_NOT_PRESENT;
        if( ERROR_SUCCESS != Error ) return Error;
    }

    ValueSize = 0;
    Error = DhcpConvertOptionRPCToRegFormat(OptData, NULL, &ValueSize);
    if( ERROR_MORE_DATA != Error ) {
        DhcpAssert(ERROR_SUCCESS != Error);
        return Error;
    }

    Value = DhcpAllocateMemory(ValueSize);
    if( NULL == Value ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = DhcpConvertOptionRPCToRegFormat(OptData, Value, &ValueSize);
    DhcpAssert(ERROR_MORE_DATA != Error);

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        Error = MemServerAddOptDef(
            DhcpGetCurrentServer(),
            ClassId,
            VendorId,
            OptId,
            OptDef->OptName,
            OptDef->OptComment,
            OptDef->Type,
            Value,
            ValueSize,
        INVALID_UNIQ_ID
            );
        if(Value ) DhcpFreeMemory(Value);
        return Error;
    }

    Error = MemOptInit(
        &Option,
        OptId,
        ValueSize,
        Value
    );
    DhcpFreeMemory(Value);
    if( ERROR_SUCCESS != Error ) return Error;
    DeletedOption = NULL;

    if(DhcpGlobalOptions == ScopeInfo->ScopeType ) {
        OptClass = &(DhcpGetCurrentServer()->Options);
    } else if( DhcpSubnetOptions == ScopeInfo->ScopeType ) {
        Error = MemServerGetAddressInfo(
            DhcpGetCurrentServer(),
            ScopeInfo->ScopeInfo.SubnetScopeInfo,
            &Subnet,
            NULL,
            NULL,
            NULL
        );
        if( ERROR_SUCCESS == Error ) {            // got the subnet in question
            DhcpAssert(Subnet);
            OptClass = &(Subnet->Options);
            DhcpAssert(Subnet->Address == ScopeInfo->ScopeInfo.SubnetScopeInfo);
            OptClass = &Subnet->Options;
        }
    } else if( DhcpMScopeOptions == ScopeInfo->ScopeType ) {
        Error = DhcpServerFindMScope(
            DhcpGetCurrentServer(),
            INVALID_MSCOPE_ID,
            ScopeInfo->ScopeInfo.MScopeInfo,
            &Subnet
            );

        if( ERROR_SUCCESS == Error ) {            // got the subnet in question
            DhcpAssert(Subnet);
            OptClass = &(Subnet->Options);
        }
    } else if( DhcpReservedOptions == ScopeInfo->ScopeType ) {
        Error = MemServerGetAddressInfo(
            DhcpGetCurrentServer(),
            ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress,
            &Subnet,
            NULL,
            NULL,
            &Reservation
        );
        if( ERROR_SUCCESS == Error ) {            // found the reservation in question
            if( NULL == Reservation ) {
                Error = ERROR_DHCP_NOT_RESERVED_CLIENT;
            }
        }

        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet && Reservation);
            OptClass = &(Reservation->Options);
            if( Subnet->Address != ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress ) {
                DhcpAssert(FALSE);                // found it in a different subnet?
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
            } else {
                OptClass = &Reservation->Options;
            }
        }
    } else {
        DhcpAssert(FALSE);                        // expect one of the above as params..
        Error = ERROR_INVALID_PARAMETER;          // dont know anything better to return
    }

    if( ERROR_SUCCESS == Error ) {                // managed to save in registry
        DhcpAssert(OptClass);                     // we must have found the right option location to add to
        Error = MemOptClassAddOption(
            OptClass,
            Option,
            ClassId,
            VendorId,
            &DeletedOption,                        // check to see if we replaced an existing option
        INVALID_UNIQ_ID
        );
        if( ERROR_SUCCESS == Error && DeletedOption ) {
            MemFree(DeletedOption);               // if we did replace, free the old option
        }
    }

    if( ERROR_SUCCESS != Error ) {                // something went wrong, clean up
        ULONG LocalError = MemOptCleanup(Option);
        DhcpAssert(ERROR_SUCCESS == LocalError);
    }

    return Error;
} // DhcpSetOptionValue()

DWORD
DhcpGetOptionValue(                               // fetch a specific option..
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory and fill in with data
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;
    LPDHCP_OPTION_VALUE            LocalOptionValue;
    PM_OPTDEF                      OptDef;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;
    PM_OPTCLASS                    OptClass;
    PM_OPTLIST                     OptList;
    PM_OPTION                      Opt;

    *OptionValue = NULL;

    Server = DhcpGetCurrentServer();

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        Error = MemServerGetOptDef(               // check for optdef only for default options ...
            Server,
            0, // ClassId,                        // dont bother about class for getting option def's
            VendorId,
            OptId,
            NULL,
            &OptDef
        );
        if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_OPTION_NOT_PRESENT;
        if( ERROR_SUCCESS != Error ) return Error;
    }

    LocalOptionValue = MIDL_user_allocate(sizeof(DHCP_OPTION_VALUE));
    if( NULL == LocalOptionValue ) return ERROR_NOT_ENOUGH_MEMORY;
    LocalOptionValue->OptionID = ConvertOptIdToRPCValue(OptId, TRUE);

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        Error = DhcpConvertOptionRegToRPCFormat(
            OptDef->OptVal,
            OptDef->OptValLen,
            &LocalOptionValue->Value,
            NULL
        );
        if( ERROR_SUCCESS != Error ) {
            MIDL_user_free(LocalOptionValue);
        }
        return Error;
    }

    switch(ScopeInfo->ScopeType) {
    case DhcpGlobalOptions : OptClass = &Server->Options; Error = ERROR_SUCCESS; break;
    case DhcpSubnetOptions:
        Error = MemServerGetAddressInfo(
            Server,
            ScopeInfo->ScopeInfo.SubnetScopeInfo,
            &Subnet,
            NULL,
            NULL,
            NULL
        );
        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            OptClass = &Subnet->Options;
        } else {
            if( ERROR_FILE_NOT_FOUND == Error )
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        }
        break;
    case DhcpMScopeOptions:
        Error = DhcpServerFindMScope(
            DhcpGetCurrentServer(),
            INVALID_MSCOPE_ID,
            ScopeInfo->ScopeInfo.MScopeInfo,
            &Subnet
            );
        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            OptClass = &Subnet->Options;
        } else {
            if( ERROR_FILE_NOT_FOUND == Error )
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        }
        break;
    case DhcpReservedOptions:
        Error = MemServerGetAddressInfo(
            Server,
            ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress,
            &Subnet,
            NULL,
            NULL,
            &Reservation
        );
        if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = ERROR_DHCP_NOT_RESERVED_CLIENT;
        } else if( ERROR_SUCCESS == Error ) {
            if( NULL == Subnet ) {
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT ;
            } else if( NULL == Reservation ) {
                Error = ERROR_DHCP_NOT_RESERVED_CLIENT;
            } else if( Subnet->Address != ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress ) {
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
            } else {
                OptClass = &Reservation->Options;
            }
        }
        break;
    default:
        Error = ERROR_INVALID_PARAMETER;
    }

    if( ERROR_SUCCESS == Error ) {
        Error = MemOptClassFindClassOptions(
            OptClass,
            ClassId,
            VendorId,
            &OptList
        );
        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(NULL != OptList);

            Error = MemOptListFindOption(
                OptList,
                OptId,
                &Opt
            );
        }
    }

    if( ERROR_SUCCESS == Error ) {
        DhcpAssert(Opt);
        DhcpAssert(Opt->OptId == OptId);
        Error = DhcpConvertOptionRegToRPCFormat(
            Opt->Val,
            Opt->Len,
            &LocalOptionValue->Value,
            NULL
        );
    }

    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalOptionValue);
    } else {
        *OptionValue = LocalOptionValue;
    }

    return Error;
}

DWORD
FindOptClassForScope(                             // find the optclass array corresponding to scope...
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     PM_OPTCLASS           *OptClass       // fill in this ptr..
)
{
    DWORD                          Error;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;

    Server = DhcpGetCurrentServer();

    switch(ScopeInfo->ScopeType) {
    case DhcpGlobalOptions:
        *OptClass = &Server->Options; Error = ERROR_SUCCESS; break;
    case DhcpSubnetOptions:
        Error = MemServerGetAddressInfo(
            Server,
            ScopeInfo->ScopeInfo.SubnetScopeInfo,
            &Subnet,
            NULL,
            NULL,
            NULL
        );
        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            *OptClass = &Subnet->Options;
        } else if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        }
        break;
    case DhcpMScopeOptions:
        Error = DhcpServerFindMScope(
            DhcpGetCurrentServer(),
            INVALID_MSCOPE_ID,
            ScopeInfo->ScopeInfo.MScopeInfo,
            &Subnet
        );
        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            *OptClass = &Subnet->Options;
        } else if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        }
        break;
    case DhcpReservedOptions:
        Error = MemServerGetAddressInfo(
            Server,
            ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress,
            &Subnet,
            NULL,
            NULL,
            &Reservation
        );
        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            if( NULL == Reservation ) {
                Error = ERROR_DHCP_NOT_RESERVED_CLIENT;
            } else if( Subnet->Address != ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress ) {
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
            } else {
                *OptClass = &Reservation->Options;
            }
        } else if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = ERROR_DHCP_NOT_RESERVED_CLIENT;
        }
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    return Error;
}

DWORD
DhcpEnumOptionValuesInternal(                     // scopeinfo can be anything but DhcpDefaultOptions
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      BOOL                   IsVendor,      // do we want to enumerate only vendor or only non-vendor?
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error;
    DWORD                          Index;
    DWORD                          Count;
    DWORD                          nElements;
    DWORD                          FilledSize;
    DWORD                          UsedSize;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;
    PM_OPTCLASS                    OptClass;
    PM_OPTLIST                     OptList;
    PM_OPTION                      Opt;
    PM_OPTDEF                      OptDef;
    PARRAY                         pArray;
    ARRAY_LOCATION                 Loc;
    LPDHCP_OPTION_VALUE_ARRAY      LocalOptValueArray;
    LPDHCP_OPTION_VALUE            LocalOptValues;

    Server = DhcpGetCurrentServer();

    *OptionValues = NULL;
    *nRead = *nTotal = 0;

    Error = FindOptClassForScope(ScopeInfo, &OptClass);
    if( ERROR_SUCCESS != Error ) return Error;
    DhcpAssert(OptClass);

    Error = MemOptClassFindClassOptions(
        OptClass,
        ClassId,
        VendorId,
        &OptList
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_NO_MORE_ITEMS;

    nElements = MemArraySize(OptList);
    if( 0 == nElements || nElements <= *ResumeHandle ) return ERROR_NO_MORE_ITEMS;

    LocalOptValueArray = MIDL_user_allocate(sizeof(DHCP_OPTION_VALUE_ARRAY));
    if( NULL == LocalOptValueArray ) return ERROR_NOT_ENOUGH_MEMORY;

    LocalOptValues = MIDL_user_allocate(sizeof(DHCP_OPTION_VALUE)*(nElements - *ResumeHandle));
    if( NULL == LocalOptValues ) {
        MIDL_user_free(LocalOptValueArray);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LocalOptValueArray->NumElements = 0;
    LocalOptValueArray->Values = LocalOptValues;

    pArray = OptList;
    Error = MemArrayInitLoc(pArray, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);

    for( Count = 0; Count < *ResumeHandle ; Count ++ ) {
        Error = MemArrayNextLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    Index = 0; Error = ERROR_SUCCESS; FilledSize =0;
    while( Count < nElements ) {
        Count ++;

        Error = MemArrayGetElement(pArray, &Loc, &Opt);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != Opt);
        Error = MemArrayNextLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || Count == nElements);

        Error = ERROR_SUCCESS;
        if( !CheckForVendor(Opt->OptId, IsVendor) ) continue;

        Error = DhcpConvertOptionRegToRPCFormat(
            Opt->Val,
            Opt->Len,
            &LocalOptValues[Index].Value,
            &UsedSize
        );
        if( ERROR_SUCCESS != Error ) {
            LocalOptValueArray->NumElements = Index;
            _fgs__DHCP_OPTION_VALUE_ARRAY( LocalOptValueArray );
            MIDL_user_free(LocalOptValueArray);
            return Error;
        }

        if( FilledSize + UsedSize + sizeof(DHCP_OPTION_VALUE) > PreferredMaximum ) {
            _fgs__DHCP_OPTION_DATA( &LocalOptValues[Index].Value );
            Error = ERROR_MORE_DATA;
            break;
        } else {
            LocalOptValues[Index].OptionID = ConvertOptIdToRPCValue(Opt->OptId, TRUE);
            FilledSize += UsedSize + sizeof(DHCP_OPTION_VALUE);
            Index ++;
        }
    }

    if( 0 == Index ) {
        MIDL_user_free(LocalOptValues);
        MIDL_user_free(LocalOptValueArray);
        if( ERROR_SUCCESS == Error ) return ERROR_NO_MORE_ITEMS;
        else return Error;
    }

    LocalOptValueArray->NumElements = Index;
    *nRead = Index ;
    *nTotal = nElements - Count + Index;
    *ResumeHandle = Count;
    *OptionValues = LocalOptValueArray;
    return Error;
}

DWORD
DhcpEnumOptionValues(
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      BOOL                   IsVendor,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;
    DWORD                          Index;
    DWORD                          Count;
    DWORD                          nElements;
    DWORD                          FilledSize;
    DWORD                          UsedSize;
    PM_SERVER                      Server;
    PM_OPTLIST                     OptList;
    PM_OPTION                      Opt;
    PM_OPTDEF                      OptDef;
    PM_OPTDEFLIST                  OptDefList;
    PARRAY                         pArray;
    ARRAY_LOCATION                 Loc;
    LPDHCP_OPTION_VALUE_ARRAY      LocalOptValueArray;
    LPDHCP_OPTION_VALUE            LocalOptValues;

    Server = DhcpGetCurrentServer();

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    *nRead = *nTotal = 0;
    *OptionValues = NULL;

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        Error = MemOptClassDefListFindOptDefList(
            &(Server->OptDefs),
            ClassId,
            VendorId,
            &OptDefList
        );
        if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_NO_MORE_ITEMS;
        if( ERROR_SUCCESS != Error) return Error;
        DhcpAssert(OptDefList);
        nElements = MemArraySize(&OptDefList->OptDefArray);
        if( 0 == nElements || *ResumeHandle <= nElements) {
            return ERROR_NO_MORE_ITEMS;
        }

        if ( nElements < *ResumeHandle ) {
            return ERROR_INVALID_PARAMETER;
        }

        LocalOptValueArray = MIDL_user_allocate(sizeof(DHCP_OPTION_VALUE_ARRAY));
        if( NULL == LocalOptValueArray ) return ERROR_NOT_ENOUGH_MEMORY;
        LocalOptValues = MIDL_user_allocate( sizeof( DHCP_OPTION_VALUE_ARRAY ) * ( nElements - *ResumeHandle ));
        if( NULL == LocalOptValues ) {
            MIDL_user_free(LocalOptValueArray);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        LocalOptValueArray->NumElements = 0;
        LocalOptValueArray->Values = LocalOptValues;

        pArray = &(OptDefList->OptDefArray);
        Error = MemArrayInitLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);

        for( Count = 0; Count < *ResumeHandle; Count ++ ) {
            Error = MemArrayNextLoc(pArray, &Loc);
            DhcpAssert(ERROR_SUCCESS == Error);
        }

        Error = ERROR_SUCCESS; Index = 0; FilledSize = 0;
        while( Count < nElements ) {
            Count ++;

            Error = MemArrayGetElement(pArray, &Loc, &OptDef);
            DhcpAssert(ERROR_SUCCESS == Error && NULL != OptDef);
            Error = MemArrayNextLoc(pArray, &Loc);
            DhcpAssert(ERROR_SUCCESS == Error || Count == nElements);
            Error = ERROR_SUCCESS;

            if( !CheckForVendor(OptDef->OptId, IsVendor) ) continue;

            Error = DhcpConvertOptionRegToRPCFormat(
                OptDef->OptVal,
                OptDef->OptValLen,
                &LocalOptValues[Index].Value,
                &UsedSize
            );
            if( ERROR_SUCCESS != Error ) {
                LocalOptValueArray->NumElements = Index;
                _fgs__DHCP_OPTION_VALUE_ARRAY( LocalOptValueArray );
                MIDL_user_free( LocalOptValueArray );
                return Error;
            }

            if( FilledSize + UsedSize + sizeof(DHCP_OPTION_VALUE) > PreferredMaximum ) {
                _fgs__DHCP_OPTION_DATA( &LocalOptValues[Index].Value );
                Error = ERROR_MORE_DATA;
                break;
            } else {
                LocalOptValues[Index].OptionID = ConvertOptIdToRPCValue(OptDef->OptId, TRUE);
                FilledSize += UsedSize + sizeof(DHCP_OPTION_VALUE);
                Index ++;
            }
        }
        LocalOptValueArray->NumElements = Index;
        *nRead = Index ;
        *nTotal = nElements - Count + Index;
        *ResumeHandle = Count;
        return Error;
    }

    return DhcpEnumOptionValuesInternal(
        ScopeInfo,
        ClassId,
        VendorId,
        IsVendor,
        ResumeHandle,
        PreferredMaximum,
        OptionValues,
        nRead,
        nTotal
    );
}

DWORD
DhcpRemoveOptionValue(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
)
{
    DWORD                          Error;
    DWORD                          RegError;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;
    PM_OPTCLASS                    OptClass;
    PM_OPTLIST                     OptList;
    PM_OPTION                      Opt;
    PM_OPTDEF                      OptDef;
    PM_OPTDEFLIST                  OptDefList;

    Server = DhcpGetCurrentServer();

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    if( DhcpDefaultOptions == ScopeInfo->ScopeType )
        return ERROR_INVALID_PARAMETER;           // use DhcpRemoveOption in this case??

    switch(ScopeInfo->ScopeType) {
    case DhcpGlobalOptions:
        OptClass = &Server->Options; Error = ERROR_SUCCESS;
        break;
    case DhcpSubnetOptions:
        Error = MemServerGetAddressInfo(
            Server,
            ScopeInfo->ScopeInfo.SubnetScopeInfo,
            &Subnet,
            NULL,
            NULL,
            NULL
        );
        if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        } else if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            OptClass = &Subnet->Options;
        }
        break;
    case DhcpMScopeOptions:
        Error = DhcpServerFindMScope(
            DhcpGetCurrentServer(),
            INVALID_MSCOPE_ID,
            ScopeInfo->ScopeInfo.MScopeInfo,
            &Subnet
            );

        if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        } else if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            OptClass = &Subnet->Options;
        }
        break;
    case DhcpReservedOptions:
        Error = MemServerGetAddressInfo(
            Server,
            ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress,
            &Subnet,
            NULL,
            NULL,
            &Reservation
        );
        if( ERROR_FILE_NOT_FOUND == Error || NULL == Reservation) {
            Error = ERROR_DHCP_NOT_RESERVED_CLIENT;
        } else {
            DhcpAssert(NULL != Subnet);
            if( Subnet->Address != ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress ) {
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
            } else {
                OptClass = &Reservation->Options;
            }
        }
        break;
    default:
        Error = ERROR_INVALID_PARAMETER;
    }

    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemOptClassFindClassOptions(
        OptClass,
        ClassId,
        VendorId,
        &OptList
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_CLASS_NOT_FOUND;
    if( ERROR_SUCCESS != Error ) return Error;

    DhcpAssert(OptList);
    Error = MemOptListDelOption(
        OptList,
        OptId
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_OPTION_NOT_PRESENT;

    return Error;
}


//================================================================================
//  classid only stuff implemented here
//================================================================================
DWORD
DhcpCreateClass(
    IN      LPWSTR                 ClassName,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassComment,
    IN      LPBYTE                 ClassData,
    IN      DWORD                  ClassDataLength
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    BOOL                           IsVendor;
    PM_CLASSDEF                    ClassDef = NULL;

    if( NULL == ClassName || 
        NULL == ClassData ||
        0 == ClassDataLength ||
        ClassDataLength > MAX_CLASS_DATA_LENGTH ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 != Flags && DHCP_FLAGS_OPTION_IS_VENDOR != Flags ) {
        return ERROR_INVALID_PARAMETER;
    }

    IsVendor = (0 != ( Flags & DHCP_FLAGS_OPTION_IS_VENDOR ));

    if( !IsVendor ) {
        Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    } else {
        Error = DhcpGetVendorIdFromName(ClassName, &ClassId);
    }
    
    if( ERROR_DHCP_CLASS_NOT_FOUND != Error ) {
        if( ERROR_SUCCESS != Error ) return Error;
        return ERROR_DHCP_CLASS_ALREADY_EXISTS;
    }
    
    Error = MemServerGetClassDef(
        DhcpGetCurrentServer(),
        0,
        NULL,
        ClassDataLength,
        ClassData,
        &ClassDef
        );
    if( ERROR_SUCCESS == Error ) {
        return ERROR_DHCP_CLASS_ALREADY_EXISTS;
    }
        
    ClassId = MemNewClassId();

    Error = MemServerAddClassDef(
        DhcpGetCurrentServer(),
        ClassId,
        IsVendor,
        ClassName,
        ClassComment,
        ClassDataLength,
        ClassData,
    INVALID_UNIQ_ID
    );

    return Error;
}

// Delete the global option definitison for the given vendorid..
DWORD       _inline
DhcpDeleteGlobalClassOptDefs(
    IN      LPWSTR                 ClassName,
    IN      ULONG                  ClassId,
    IN      BOOL                   IsVendor
)
{
    DWORD                          Error;
    PARRAY                         Opts;
    ARRAY_LOCATION                 Loc;
    PM_OPTCLASSDEFL_ONE            OptDefList1;
    PM_OPTDEFLIST                  OptDefList;
    PM_OPTDEF                      OptDef;
    PM_OPTION                      Option;
    PM_SERVER                      Server;

    Server = DhcpGetCurrentServer();

    //
    // First clear all relevant option definitions
    //

    for( Error = MemArrayInitLoc( &Server->OptDefs.Array, &Loc)
         ; ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc( &Server->OptDefs.Array, &Loc)
    ) {
        Error = MemArrayGetElement(&Server->OptDefs.Array, &Loc, &OptDefList1);
        DhcpAssert(ERROR_SUCCESS == Error);

        if( OptDefList1->VendorId != ClassId ) continue;

        // if( OptDefList1->IsVendor != IsVendor ) continue;
        // For now, we ignore IsVendor and assume it is always TRUE
        // meaning the option is defined to be deleted for that vendor CLASS.

        // DhcpAssert( TRUE == OptDefList1->IsVendor );

        // remove this optdeflist OFF of the main list..
        MemArrayDelElement(&Server->OptDefs.Array, &Loc, &OptDefList1);

        break;
    }

    if( ERROR_FILE_NOT_FOUND == Error ) {
        return ERROR_SUCCESS;
    }

    if( ERROR_SUCCESS != Error ) return Error;

    // we found the OptDefList1 we were looking for. Delete each optdef in it.
    // But simultaneously delete the registry optdefs for these options too.
    //

    for( Error = MemArrayInitLoc( &OptDefList1->OptDefList.OptDefArray, &Loc)
         ; ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc( &OptDefList1->OptDefList.OptDefArray, &Loc)
    ) {
        Error = MemArrayGetElement(&OptDefList1->OptDefList.OptDefArray, &Loc, &OptDef);
        DhcpAssert(ERROR_SUCCESS == Error);

        // clean the registry off the option OptDef...

        // Again, we are assuming that this is a VENDOR CLASS and so we're
        // deleting all relevant stuff.  If it is not a VENDOR CLASS then we'd
        // not have reached this loop at all? (as USER CLASSes cannot have options
        // definitions for them)

        // -- We should not be free'ing memory so casually.. this memory actually
        // should be free'd via a Mem API.  But good lord, please forgive this lapse.

        MemFree(OptDef);
    }

    // Free the list itself...
    Error = MemOptDefListCleanup(&OptDefList1->OptDefList);

    // Get rid of the OptDefList1 also... -- shouldn't free this badly..
    MemFree(OptDefList1);

    return Error;
}


DWORD       _inline
DhcpDeleteOptListOptionValues(
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      PM_OPTLIST             OptList,
    IN      PM_RESERVATION         Reservation,
    IN      PM_SUBNET              Subnet,
    IN      PM_SERVER              Server
)
{
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    PM_OPTION                      Option;

    for( Error = MemArrayInitLoc( OptList, &Loc)
         ; ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc( OptList, &Loc)
    ) {
        Error = MemArrayGetElement( OptList, &Loc, &Option);
        DhcpAssert(ERROR_SUCCESS == Error);

        //
        // now cleanup the option
        //

        MemOptCleanup(Option);
    }

    // Now cleanup the option list..

    return MemOptListCleanup(OptList);
}

DWORD
DhcpDeleteOptClassOptionValues(
    IN      LPWSTR                 ClassNameIn,
    IN      ULONG                  ClassId,
    IN      BOOL                   IsVendor,
    IN      PM_OPTCLASS            OptClass,
    IN      PM_RESERVATION         Reservation,
    IN      PM_SUBNET              Subnet,
    IN      PM_SERVER              Server
)
{
    DWORD                          Error;
    ULONG                          IdToCheck;
    LPWSTR                         VendorName, ClassName;
    ARRAY_LOCATION                 Loc, Loc2;
    PM_ONECLASS_OPTLIST            OptOneList;
    PM_CLASSDEF                    ClassDef;
    PM_OPTION                      Option;

    //
    // Get Optlist for options defined for (ClassId/IsVendor)..
    //

    for( Error = MemArrayInitLoc( &OptClass->Array, &Loc)
         ; ERROR_SUCCESS == Error ;
    ) {
        Error = MemArrayGetElement(&OptClass->Array, &Loc, &OptOneList );
        DhcpAssert(ERROR_SUCCESS == Error);

        if( ClassId != (IsVendor? OptOneList->VendorId : OptOneList->ClassId ) ) {
            //
            // not what we are looking for
            //

            Error = MemArrayNextLoc( &OptClass->Array, &Loc);

        } else {

            //
            // matched -- got to remove all of the options defined..
            //

            if( IsVendor ) {
                VendorName = ClassNameIn;
                ClassName = NULL;
                IdToCheck = OptOneList->ClassId;
            } else {
                VendorName = NULL;
                ClassName = ClassNameIn;
                IdToCheck = OptOneList->VendorId;
            }

            if( 0 != IdToCheck ) {
                Error = MemServerGetClassDef(
                    Server,
                    IdToCheck,
                    NULL,
                    0,
                    NULL,
                    &ClassDef
                );
                DhcpAssert(ERROR_SUCCESS == Error);
                if( ERROR_SUCCESS == Error) {
                    if( IsVendor ) ClassName = ClassDef->Name;
                    else VendorName = ClassDef->Name;
                }
            }

            //
            // Now clear off the options(& OptList) from mem & registry
            //

            Error = DhcpDeleteOptListOptionValues(
                ClassName,
                VendorName,
                &OptOneList->OptList,
                Reservation,
                Subnet,
                Server
            );
            DhcpAssert(ERROR_SUCCESS == Error);

            //
            // Now clear off the OptOneList from off of OptClass also..
            //

            MemFree(OptOneList);

            MemArrayDelElement(&OptClass->Array, &Loc, &OptOneList);
            Error = MemArrayAdjustLocation(&OptClass->Array, &Loc);
        }
    }

    if( ERROR_FILE_NOT_FOUND != Error ) return Error;
    return ERROR_SUCCESS;
}

// Delete all the global options defined for the given vendor/classid
DWORD       _inline
DhcpDeleteGlobalClassOptValues(
    IN      LPWSTR                 ClassName,
    IN      ULONG                  ClassId,
    IN      BOOL                   IsVendor
)
{
    DWORD                          Error;
    PM_SERVER                      Server;

    Server = DhcpGetCurrentServer();

    return DhcpDeleteOptClassOptionValues(
        ClassName,
        ClassId,
        IsVendor,
        &Server->Options,
        NULL,  /* reservation */
        NULL,  /* subnet */
        Server /* server */
    );
}

// This function deletes all optiosn and optiondefs defined for a particular class
DWORD       _inline
DhcpDeleteGlobalClassOptions(
    IN      LPWSTR                 ClassName,
    IN      ULONG                  ClassId,
    IN      BOOL                   IsVendor
)
{
    DWORD                          Error;

    if( IsVendor ) {
        Error = DhcpDeleteGlobalClassOptDefs(ClassName, ClassId, IsVendor);
        if( ERROR_SUCCESS != Error ) return Error;
    }

    return DhcpDeleteGlobalClassOptValues(ClassName, ClassId, IsVendor);
}

DWORD
DhcpDeleteSubnetOptClassOptionValues(
    IN      LPWSTR                 ClassName,
    IN      ULONG                  ClassId,
    IN      BOOL                   IsVendor,
    IN      PM_SUBNET              Subnet,
    IN      PM_SERVER              Server
)
{
    ULONG                          Error;
    ARRAY_LOCATION                 Loc;
    PM_RESERVATION                 Reservation;

    Error = DhcpDeleteOptClassOptionValues(
        ClassName,
        ClassId,
        IsVendor,
        &Subnet->Options,
        NULL,
        Subnet,
        Server
    );
    DhcpAssert(ERROR_SUCCESS == Error);


    for( Error = MemArrayInitLoc(&Subnet->Reservations, &Loc)
         ; ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc(&Subnet->Reservations, &Loc)
    ) {
        Error = MemArrayGetElement(&Subnet->Reservations, &Loc, &Reservation);
        DhcpAssert(ERROR_SUCCESS == Error);

        Error = DhcpDeleteOptClassOptionValues(
            ClassName,
            ClassId,
            IsVendor,
            &Reservation->Options,
            Reservation,
            Subnet,
            Server
        );
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    return ERROR_SUCCESS;
}

DWORD       _inline
DhcpDeleteSubnetReservationOptions(
    IN      LPWSTR                 ClassName,
    IN      ULONG                  ClassId,
    IN      BOOL                   IsVendor
)
{
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;

    Server = DhcpGetCurrentServer();

    for( Error = MemArrayInitLoc(&Server->Subnets, &Loc)
         ; ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc(&Server->Subnets, &Loc)
    ) {
        Error = MemArrayGetElement(&Server->Subnets, &Loc, &Subnet);
        DhcpAssert(ERROR_SUCCESS == Error );

        Error = DhcpDeleteSubnetOptClassOptionValues(
            ClassName,
            ClassId,
            IsVendor,
            Subnet,
            Server
        );
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    for( Error = MemArrayInitLoc(&Server->MScopes, &Loc)
         ; ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc(&Server->MScopes, &Loc)
    ) {
        Error = MemArrayGetElement(&Server->MScopes, &Loc, &Subnet);
        DhcpAssert(ERROR_SUCCESS == Error );

        Error = DhcpDeleteSubnetOptClassOptionValues(
            ClassName,
            ClassId,
            IsVendor,
            Subnet,
            Server
        );
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    if( ERROR_FILE_NOT_FOUND != Error ) return Error;
    return ERROR_SUCCESS;
}


DWORD
DhcpDeleteClass(
    IN      LPWSTR                 ClassName
)
{
    DWORD                          Error;
    PM_CLASSDEF                    ClassDef;
    ULONG                          ClassId;
    BOOL                           IsVendor;

    Error = MemServerGetClassDef(
        DhcpGetCurrentServer(),
        0,
        ClassName,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_CLASS_NOT_FOUND;

    //
    // found the class, remember class id to delete options..
    //

    IsVendor = ClassDef->IsVendor;
    ClassId = ClassDef->ClassId;

    Error = MemServerDelClassDef(
        DhcpGetCurrentServer(),
        0,
        ClassName,
        0,
        NULL
    );

    if( ERROR_SUCCESS != Error ) {
        return Error;
    }


    //
    // Now delete the options & optdefs defined for this class globally
    //

    Error = DhcpDeleteGlobalClassOptions(
        ClassName,
        ClassId,
        IsVendor
    );

    if( ERROR_SUCCESS != Error ) {
        return Error;
    }

    //
    // Now delete the options defined for this class for every subnet & reservation
    //

    Error = DhcpDeleteSubnetReservationOptions(
        ClassName,
        ClassId,
        IsVendor
    );

    return Error;
}

DWORD
DhcpModifyClass(
    IN      LPWSTR                 ClassName,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassComment,
    IN      LPBYTE                 ClassData,
    IN      DWORD                  ClassDataLength
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    BOOL                           IsVendor;
    PM_CLASSDEF                    ClassDef = NULL;
    
    if( 0 != Flags && DHCP_FLAGS_OPTION_IS_VENDOR != Flags ) {
        return ERROR_INVALID_PARAMETER;
    }

    IsVendor = (0 != ( Flags & DHCP_FLAGS_OPTION_IS_VENDOR ));

    if( FALSE == IsVendor ) {
        Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    } else {
        Error = DhcpGetVendorIdFromName(ClassName, &ClassId);
    }
    if( ERROR_SUCCESS != Error ) {
        return Error;
    }

    Error = MemServerGetClassDef(
        DhcpGetCurrentServer(),
        0,
        NULL,
        ClassDataLength,
        ClassData,
        &ClassDef
        );
    if( ERROR_SUCCESS == Error ) {
        if( ClassDef->ClassId != ClassId ) {
            return ERROR_DHCP_CLASS_ALREADY_EXISTS;
        }
    }
    
    Error = MemServerAddClassDef(
        DhcpGetCurrentServer(),
        ClassId,
        IsVendor,
        ClassName,
        ClassComment,
        ClassDataLength,
        ClassData,
    INVALID_UNIQ_ID
    );

    return Error;
} // DhcpModifyClass()

DWORD
ConvertClassDefToRPCFormat(
    IN      PM_CLASSDEF            ClassDef,
    IN OUT  LPDHCP_CLASS_INFO      ClassInfo,
    OUT     DWORD                 *AllocatedSize
)
{
    DWORD                          Error;

    ClassInfo->ClassName = CloneLPWSTR(ClassDef->Name);
    ClassInfo->ClassComment = CloneLPWSTR(ClassDef->Comment);
    ClassInfo->ClassData = CloneLPBYTE(ClassDef->ActualBytes, ClassDef->nBytes);
    ClassInfo->ClassDataLength = ClassDef->nBytes;
    ClassInfo->Flags = 0;
    ClassInfo->IsVendor = ClassDef->IsVendor;

    if( NULL == ClassInfo->ClassName || NULL == ClassInfo->ClassData ) {
        if( ClassInfo->ClassName ) MIDL_user_free(ClassInfo->ClassName);
        if( ClassInfo->ClassComment ) MIDL_user_free(ClassInfo->ClassComment);
        if( ClassInfo->ClassData ) MIDL_user_free(ClassInfo->ClassData);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if(AllocatedSize ) *AllocatedSize = (
        sizeof(WCHAR)*(1 + wcslen(ClassDef->Name)) +
        ((NULL == ClassDef->Comment)?0:(sizeof(WCHAR)*(1 + wcslen(ClassDef->Comment)))) +
        ClassDef->nBytes
    );

    return ERROR_SUCCESS;
}

DWORD
DhcpGetClassInfo(
    IN      LPWSTR                 ClassName,
    IN      LPBYTE                 ClassData,
    IN      DWORD                  ClassDataLength,
    OUT     LPDHCP_CLASS_INFO     *ClassInfo
)
{
    DWORD                          Error;
    LPDHCP_CLASS_INFO              LocalClassInfo;
    PM_CLASSDEF                    ClassDef;

    *ClassInfo = 0;
    Error = MemServerGetClassDef(
        DhcpGetCurrentServer(),
        0,
        ClassName,
        ClassDataLength,
        ClassData,
        &ClassDef
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_CLASS_NOT_FOUND;
    if( ERROR_SUCCESS != Error ) return Error;

    DhcpAssert(ClassDef);

    LocalClassInfo = MIDL_user_allocate(sizeof(DHCP_CLASS_INFO));
    if( NULL == LocalClassInfo ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = ConvertClassDefToRPCFormat(ClassDef, LocalClassInfo, NULL);
    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalClassInfo);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *ClassInfo = LocalClassInfo;
    return ERROR_SUCCESS;
}

DhcpEnumClasses(
    IN      DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error;
    LONG                           Index;
    DWORD                          nElements;
    DWORD                          Count;
    DWORD                          FilledSize;
    DWORD                          UsedSize;
    LPDHCP_CLASS_INFO              LocalClassInfo;
    LPDHCP_CLASS_INFO_ARRAY        LocalClassInfoArray;
    PM_CLASSDEF                    ClassDef;
    PARRAY                         pArray;
    ARRAY_LOCATION                 Loc;

    pArray = &(DhcpGetCurrentServer()->ClassDefs.ClassDefArray);
    nElements = MemArraySize(pArray);

    *nRead = *nTotal = 0;
    *ClassInfoArray = NULL;

    if( 0 == nElements || nElements <= *ResumeHandle )
        return ERROR_NO_MORE_ITEMS;

    Error = MemArrayInitLoc(pArray, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);
    for(Count = 0; Count < *ResumeHandle ; Count ++ ) {
        Error = MemArrayNextLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    LocalClassInfoArray = MIDL_user_allocate(sizeof(DHCP_CLASS_INFO_ARRAY));
    if( NULL == LocalClassInfoArray ) return ERROR_NOT_ENOUGH_MEMORY;
    LocalClassInfo = MIDL_user_allocate(sizeof(DHCP_CLASS_INFO)*(nElements - *ResumeHandle ));
    if( NULL == LocalClassInfo ) {
        MIDL_user_free(LocalClassInfoArray);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Index = 0; Error = ERROR_SUCCESS; FilledSize = 0;
    while( Count < nElements ) {
        Count ++;

        Error = MemArrayGetElement(pArray, &Loc, &ClassDef);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != ClassDef);
        Error = MemArrayNextLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || nElements == Count);

        Error = ConvertClassDefToRPCFormat(
            ClassDef,
            &LocalClassInfo[Index],
            &UsedSize
        );
        if( ERROR_SUCCESS != Error ) {
            while(Index -- >= 1) {
                if(LocalClassInfo[Index].ClassName ) MIDL_user_free(LocalClassInfo[Index].ClassName);
                if(LocalClassInfo[Index].ClassComment ) MIDL_user_free(LocalClassInfo[Index].ClassComment);
                if(LocalClassInfo[Index].ClassData ) MIDL_user_free(LocalClassInfo[Index].ClassData);
            }
            MIDL_user_free(LocalClassInfo);
            MIDL_user_free(LocalClassInfoArray);
            return Error;
        }

        if( FilledSize + UsedSize + sizeof(DHCP_CLASS_INFO) > PreferredMaximum ) {
            if(LocalClassInfo[Index].ClassName ) MIDL_user_free(LocalClassInfo[Index].ClassName);
            if(LocalClassInfo[Index].ClassComment ) MIDL_user_free(LocalClassInfo[Index].ClassComment);
            if(LocalClassInfo[Index].ClassData ) MIDL_user_free(LocalClassInfo[Index].ClassData);
            Error = ERROR_MORE_DATA;
            break;
        }
        Index ++;
        FilledSize += UsedSize + sizeof(DHCP_CLASS_INFO);
        Error = ERROR_SUCCESS;
    }

    *nRead = Index;
    *nTotal = nElements - Count + Index;
    *ResumeHandle = Count;
    LocalClassInfoArray->NumElements = Index;
    LocalClassInfoArray->Classes = LocalClassInfo;

    *ClassInfoArray = LocalClassInfoArray;
    return Error;
}

//================================================================================
//  extended enum api's and helpers needed for that..
//================================================================================

typedef
VOID        (*OPTDEFFUNC) (PM_OPTDEF, DWORD, DWORD, LPVOID, LPVOID, LPVOID, LPVOID);

VOID
TraverseOptDefListAndDoFunc(                      // apply function each optdef in otpdeflist
    IN      PM_OPTDEFLIST          OptDefList,    // input list
    IN      DWORD                  ClassId,       // class id
    IN      DWORD                  VendorId,      // vendor id
    IN      OPTDEFFUNC             OptDefFunc,    // function to apply
    IN OUT  LPVOID                 Ctxt1,         // some parameter to OptDefFunc
    IN OUT  LPVOID                 Ctxt2,         // some parameter to OptDefFunc
    IN OUT  LPVOID                 Ctxt3,         // some parameter to OptDefFunc
    IN OUT  LPVOID                 Ctxt4          // some parameter to OptDefFunc
)
{
    DWORD                          Error;
    ARRAY                          Array;
    ARRAY_LOCATION                 Loc;
    PM_OPTDEF                      OptDef;

    for( Error = MemArrayInitLoc(&OptDefList->OptDefArray, &Loc)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(&OptDefList->OptDefArray, &Loc)
    ) {                                           // traverse the optdef list
        DhcpAssert(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&OptDefList->OptDefArray, &Loc, &OptDef);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != OptDef );

        OptDefFunc(OptDef, ClassId, VendorId, Ctxt1, Ctxt2, Ctxt3, Ctxt4);
    }
}

VOID
TraverseAllOptDefsAndDoFunc(                      // for all opt defs defined in this server call func
    IN      OPTDEFFUNC             OptDefFunc,    // function to apply
    IN OUT  LPVOID                 Ctxt1,         // some parameter to OptDefFunc
    IN OUT  LPVOID                 Ctxt2,         // some parameter to OptDefFunc
    IN OUT  LPVOID                 Ctxt3,         // some parameter to OptDefFunc
    IN OUT  LPVOID                 Ctxt4          // some parameter to OptDefFunc
)
{
    DWORD                          Error;
    PM_OPTCLASSDEFLIST             OptClassDefList;
    PM_OPTCLASSDEFL_ONE            OptClassDefList1;
    ARRAY                          Array;
    ARRAY_LOCATION                 Loc;

    OptClassDefList = &(DhcpGetCurrentServer()->OptDefs);
    for( Error = MemArrayInitLoc(&OptClassDefList->Array, &Loc)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(&OptClassDefList->Array, &Loc)
    ) {                                           // traverse the list of <list of opt defs>
        DhcpAssert(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&OptClassDefList->Array, &Loc, &OptClassDefList1);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != OptClassDefList1);

        TraverseOptDefListAndDoFunc(
            &OptClassDefList1->OptDefList,
            OptClassDefList1->ClassId,
            OptClassDefList1->VendorId,
            OptDefFunc,
            Ctxt1,
            Ctxt2,
            Ctxt3,
            Ctxt4
        );
    }
}

VOID
CountVendorOptDefsFunc(                           // function that just keeps count of venodr optdefs..
    IN      PM_OPTDEF              OptDef,
    IN      DWORD                  ClassIdunused,
    IN      DWORD                  VendorIdunused,
    IN OUT  LPVOID                 Ctxt1,         // this is actually a pointer to DWORD to keep count..
    IN OUT  LPVOID                 Ctxt2unused,
    IN OUT  LPVOID                 Ctxt3unused,
    IN OUT  LPVOID                 Ctxt4unused
)
{
    if( CheckForVendor(OptDef->OptId, TRUE ) ) {  // if this is a vendor option..
        (*((LPDWORD)Ctxt1))++;                    // treat Ctxt as a DWORD ptr and incr. count
    }
}

VOID
AddVendorOptDefsFunc(                             // add each vendor opt def found to arrays..
    IN      PM_OPTDEF              OptDef,        // this is the opt def in question
    IN      DWORD                  ClassId,       // class id if any
    IN      DWORD                  VendorId,      // vendor id if any..
    IN OUT  LPDWORD                MaxSize,       // this is the max size of the arrays..
    IN OUT  LPDWORD                nFilled,       // this is the # we actually filled in..
    IN      LPDHCP_ALL_OPTIONS     AllOptions,    // the struct to fill in venodr options..
    IN      LPVOID                 Unused         // not used
)
{
    DWORD                          Error;
    PM_CLASSDEF                    ClassDef;
    LPWSTR                         Tmp = NULL;

    if( 0 == *MaxSize ) {                         // some error occurred before and this was set to zero
        return;                                   // to signify no more processing should be done..
    }

    if( !CheckForVendor(OptDef->OptId, TRUE) ) {  // not a vendor specific option, ignore this
        return;
    }

    if( *nFilled >= *MaxSize ) {                  // internal error!
        DhcpAssert(FALSE);
        return;
    }

    if( 0 != VendorId ) {                         // try to get the vendor name, if any
        Error = MemServerGetClassDef(
            DhcpGetCurrentServer(),
            VendorId,
            NULL,
            0,
            NULL,
            &ClassDef
        );
        if( ERROR_SUCCESS != Error ) {            // internal error?!!
            *MaxSize = 0;                         // set this to zero, so we dont do anything anymore
            return;
        }

        if( FALSE == ClassDef->IsVendor ) {       // what we thought of as vendor-id is not actuall that?
            DhcpAssert(FALSE);
        }

        Tmp = CloneLPWSTR(ClassDef->Name);
        AllOptions->VendorOptions[*nFilled].VendorName = Tmp;
        if( NULL == Tmp ) {                       // could not clone the name for some reason?
            *MaxSize = 0;                         // set this, so that we dont do anything in next calls..
            return;
        }
    }

    Error = DhcpGetOptionDefInternal(
        ClassId,
        VendorId,
        OptDef,
        &AllOptions->VendorOptions[*nFilled].Option,
        NULL
    );
    if( ERROR_SUCCESS != Error ) {                // could not fix the options stuff...
        *MaxSize = 0;                             // dont bother doing any more of this...
        if( Tmp ) {
            MIDL_user_free(Tmp);
        }
    }

    (*nFilled) ++;                                // since we successfully got one more option, mark it..
}
DWORD
DhcpCountAllVendorOptions(                        // count the # of vendor options defined..
    VOID
)
{
    DWORD                          Count;

    Count = 0;
    TraverseAllOptDefsAndDoFunc(                  // execute fn for each optdef found..
        (OPTDEFFUNC)CountVendorOptDefsFunc,       // counting function
        (LPVOID)&Count,                           // just increment this ctxt value for each vendor opt
        NULL,
        NULL,
        NULL
    );

    return Count;                                 // at the end of this Count would have been set correcly..
}

DWORD
DhcpFillAllVendorOptions(                         // now fill in all the required vendor options..
    IN      DWORD                  NumElements,   // # we expect for total # of elements,
    IN OUT  LPDWORD                nFilled,       // # of elements filled in? initially zero
    IN      LPDHCP_ALL_OPTIONS     AllOptions     // structure to fill in (fills AllOptions->VendorOptions[i])
)
{
    DWORD                          AttemptedNum;

    AttemptedNum = NumElements;                   // we should expect to fill in these many

    TraverseAllOptDefsAndDoFunc(                  // execute fn for each optdef found
        (OPTDEFFUNC)AddVendorOptDefsFunc,         // add each vendor opt def found in the way..
        (LPVOID)&NumElements,                     // first ctxt parameter
        (LPVOID)nFilled,                          // second ctxt parameter
        (LPVOID)AllOptions,                       // third parameter
        (LPVOID)NULL                              // fourth..
    );

    if( *nFilled < AttemptedNum ) {               // could not fill in the requested #...
        return ERROR_NOT_ENOUGH_MEMORY;           // duh! need to be more intelligent... what is exact error?
    }
    return ERROR_SUCCESS;
}

DWORD
DhcpGetAllVendorOptions(                          // get all vendor spec stuff only
    IN      DWORD                  Flags,         // unused..
    IN OUT  LPDHCP_ALL_OPTIONS     OptionStruct   // filled in the NamedVendorOptions field..
)
{
    DWORD                          Error;
    DWORD                          nVendorOptions;
    DWORD                          MemReqd;
    LPVOID                         Mem, Mem2;

    nVendorOptions = DhcpCountAllVendorOptions(); // first count this so that we can allocate space..
    if( 0 == nVendorOptions ) {                   // if no vendor options, nothing more to do..
        return ERROR_SUCCESS;
    }

    MemReqd = sizeof(*(OptionStruct->VendorOptions))*nVendorOptions;
    Mem = MIDL_user_allocate(MemReqd);
    if( NULL == Mem ) return ERROR_NOT_ENOUGH_MEMORY;
    memset(Mem, 0, MemReqd);

    OptionStruct->VendorOptions = Mem;

    Error = DhcpFillAllVendorOptions(             // now fill in the vendor options..
        nVendorOptions,                           // expected size is this..
        &OptionStruct->NumVendorOptions,
        OptionStruct
    );

    return Error;
}

DWORD
DhcpGetAllOptions(
    IN      DWORD                  Flags,         // unused?
    IN OUT  LPDHCP_ALL_OPTIONS     OptionStruct   // fill the fields of this structure
)
{
    DWORD                          Error;
    DWORD                          nRead;
    DWORD                          nTotal, n;
    LPWSTR                         UseClassName;
    DHCP_RESUME_HANDLE             ResumeHandle;

    if( 0 != Flags ) {                            // dont understand any flags ..
        return ERROR_INVALID_PARAMETER;
    }

    OptionStruct->Flags = 0;
    OptionStruct->VendorOptions = NULL;
    OptionStruct->NumVendorOptions = 0;
    OptionStruct->NonVendorOptions = NULL;

    ResumeHandle = 0;
    Error = DhcpEnumRPCOptionDefs(                // first read non-vendor options
        0,
        &ResumeHandle,
        NULL,
        NULL,
        0xFFFFFFF,                                // really huge max would cause all options to be read..
        &OptionStruct->NonVendorOptions,
        &nRead,
        &nTotal
    );
    DhcpAssert( ERROR_MORE_DATA != Error );
    if( ERROR_NO_MORE_ITEMS == Error ) Error = ERROR_SUCCESS;
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    Error = DhcpGetAllVendorOptions(Flags, OptionStruct);
    if( ERROR_SUCCESS == Error ) {                // if everything went fine, nothing more to do..
        return ERROR_SUCCESS;
    }

  Cleanup:
    if( OptionStruct->NonVendorOptions ) {
        _fgs__DHCP_OPTION_ARRAY(OptionStruct->NonVendorOptions);
        MIDL_user_free(OptionStruct->NonVendorOptions);
        OptionStruct->NonVendorOptions = NULL;
    }
    if( OptionStruct->NumVendorOptions ) {
        for( n = 0; n < OptionStruct->NumVendorOptions; n ++ ) {
            if( OptionStruct->VendorOptions[n].VendorName ) {
                MIDL_user_free(OptionStruct->VendorOptions[n].VendorName);
            }
            _fgs__DHCP_OPTION(&(OptionStruct->VendorOptions[n].Option));
        }
        MIDL_user_free(OptionStruct->VendorOptions);
        OptionStruct->NumVendorOptions = 0;
        OptionStruct->VendorOptions = NULL;
    }
    return Error;
}

LPWSTR
CloneClassNameForClassId(                         // get class name for class id and clone it..
    IN      DWORD                  ClassId
)
{
    DWORD                          Error;
    PM_CLASSDEF                    ClassDef;

    Error = MemServerGetClassDef(                 // search current server
        DhcpGetCurrentServer(),
        ClassId,
        NULL,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_SUCCESS != Error ) {                // could not get the class info requested
        DhcpAssert(FALSE);
        return NULL;
    }

    if( FALSE != ClassDef->IsVendor ) {           // this is actually a vendor class?
        DhcpAssert(FALSE);
        return NULL;
    }

    return CloneLPWSTR(ClassDef->Name);
}

LPWSTR
CloneVendorNameForVendorId(                       // get Vendor name for vendor id and clone it..
    IN      DWORD                  VendorId
)
{
    DWORD                          Error;
    PM_CLASSDEF                    ClassDef;

    Error = MemServerGetClassDef(                 // search current server
        DhcpGetCurrentServer(),
        VendorId,
        NULL,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_SUCCESS != Error ) {                // could not get the class info requested
        DhcpAssert(FALSE);
        return NULL;
    }

    if( TRUE != ClassDef->IsVendor ) {            // this is actually just a user class?
        DhcpAssert(FALSE);
        return NULL;
    }

    return CloneLPWSTR(ClassDef->Name);
}

DWORD
GetOptionValuesInternal(                          // get all option values for a given scope
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,   // specify scope
    IN      DWORD                  ClassId,       // for this exact class
    IN      DWORD                  VendorId,      // for this exact vendor
    IN      BOOL                   IsVendor,      // TRUE ==> get vendor opts only, false ==> get non=vendor ..
    IN      LPDHCP_ALL_OPTION_VALUES OptionValues // fill in this struct at index given by NumElements
)
{
    DWORD                          Error;
    DWORD                          i;
    DWORD                          nRead, nTotal;
    DHCP_RESUME_HANDLE             ResumeHandle;

    i = OptionValues->NumElements;
    OptionValues->Options[i].ClassName = NULL;    // initialize, no cleanup will be done in this func..
    OptionValues->Options[i].VendorName = NULL;   // caller should cleanup last element in case of error returns..
    OptionValues->Options[i].OptionsArray = NULL;

    if( 0 == ClassId ) {
        OptionValues->Options[i].ClassName = NULL;
    } else {
        OptionValues->Options[i].ClassName = CloneClassNameForClassId(ClassId);
        if( NULL == OptionValues->Options[i].ClassName ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if( 0 == VendorId ) {
        OptionValues->Options[i].VendorName = NULL;
        OptionValues->Options[i].IsVendor = FALSE;
    } else {
        OptionValues->Options[i].VendorName = CloneVendorNameForVendorId(VendorId);
        OptionValues->Options[i].IsVendor = TRUE;
        if( NULL == OptionValues->Options[i].VendorName ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    ResumeHandle = 0;
    nRead = nTotal = 0;
    Error = DhcpEnumOptionValuesInternal(
        ScopeInfo,
        ClassId,
        VendorId,
        IsVendor,
        &ResumeHandle,
        0xFFFFFFFF,
        &(OptionValues->Options[i].OptionsArray),
        &nRead,
        &nTotal
    );
    if( ERROR_NO_MORE_ITEMS == Error ) Error = ERROR_SUCCESS;

    if( ERROR_SUCCESS == Error ) {
        OptionValues->NumElements ++;
    }
    return Error;
}
DWORD
GetOptionValuesForSpecificClassVendorId(
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DWORD                    ClassId,
    IN      DWORD                    VendorId,
    IN      LPDHCP_ALL_OPTION_VALUES OptionValues
) {
    DWORD                            Error;
    DWORD                            i;

    i = OptionValues->NumElements ;
    Error = GetOptionValuesInternal(
        ScopeInfo,
        ClassId,
        VendorId,
        /* IsVendor */ FALSE,
        OptionValues
    );
    if( ERROR_SUCCESS != Error ) {
        if( OptionValues->Options[i].ClassName )
            MIDL_user_free(OptionValues->Options[i].ClassName);
        if( OptionValues->Options[i].VendorName )
            MIDL_user_free(OptionValues->Options[i].VendorName);
        if( OptionValues->Options[i].OptionsArray ) {
            _fgs__DHCP_OPTION_VALUE_ARRAY(OptionValues->Options[i].OptionsArray);
        }

        return Error;
    }
    i = OptionValues->NumElements ;
    Error = GetOptionValuesInternal(
        ScopeInfo,
        ClassId,
        VendorId,
        /* IsVendor */ TRUE,
        OptionValues
    );
    if( ERROR_SUCCESS != Error ) {
        if( OptionValues->Options[i].ClassName )
            MIDL_user_free(OptionValues->Options[i].ClassName);
        if( OptionValues->Options[i].VendorName )
            MIDL_user_free(OptionValues->Options[i].VendorName);
        if( OptionValues->Options[i].OptionsArray ) {
            _fgs__DHCP_OPTION_VALUE_ARRAY(OptionValues->Options[i].OptionsArray);
        }

        return Error;
    }

    return ERROR_SUCCESS;
}

DWORD
DhcpGetAllOptionValues(
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN OUT  LPDHCP_ALL_OPTION_VALUES OptionValues
)
{
    DWORD                          Error;
    DWORD                          NumElements;
    DWORD                          i;
    ARRAY_LOCATION                 Loc;
    LPARRAY                        Array;
    PM_OPTCLASS                    OptClass;
    PM_ONECLASS_OPTLIST            OptClass1;
    DHCP_RESUME_HANDLE             ResumeHandle;

    OptionValues->Flags = 0;
    OptionValues->NumElements = 0;
    OptionValues->Options = NULL;

    Error =  FindOptClassForScope(ScopeInfo, &OptClass);
    if( ERROR_SUCCESS != Error ) {                // did not find this scope's optclass..
        return Error;
    }

    NumElements = 0;
    Array = &OptClass->Array;
    for( Error = MemArrayInitLoc(Array, &Loc)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(Array, &Loc)
    ) {                                           // traverse the options list..
        DhcpAssert( ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Array, &Loc, &OptClass1);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != OptClass1 );

        NumElements ++;
    }


    if( 0 != NumElements ) {
        NumElements *= 2;                         // one for vendor specific, one for otherwise..
        OptionValues->Options = MIDL_user_allocate(NumElements*sizeof(*(OptionValues->Options)));
        if( NULL == OptionValues->Options ) {     // could not allocate space..
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    for( Error = MemArrayInitLoc(Array, &Loc)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(Array, &Loc)
    ) {                                           // traverse the options list..
        DhcpAssert( ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Array, &Loc, &OptClass1);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != OptClass1 );

        Error = GetOptionValuesForSpecificClassVendorId(
            ScopeInfo,
            OptClass1->ClassId,
            OptClass1->VendorId,
            OptionValues
        );
        if( ERROR_SUCCESS != Error ) {            // something went wrong..
            goto Cleanup;
        }
    }

    return ERROR_SUCCESS;

Cleanup:

    // Now we have to undo and free all the concerned memory..
    for( i = 0; i < OptionValues->NumElements ; i ++ ) {
        if( OptionValues->Options[i].ClassName )
            MIDL_user_free(OptionValues->Options[i].ClassName);
        if( OptionValues->Options[i].VendorName )
            MIDL_user_free(OptionValues->Options[i].VendorName);
        if( OptionValues->Options[i].OptionsArray ) {
            _fgs__DHCP_OPTION_VALUE_ARRAY(OptionValues->Options[i].OptionsArray);
        }
    }
    OptionValues->NumElements = 0;
    OptionValues->Options = NULL;

    return Error;
}

//================================================================================
//  the real rpc stubs are here
//================================================================================

//
// RPC stubs for OPTIONS and CLASSES -- old rpc stubs are at the bottom..
//

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
R_DhcpCreateOptionV5(                             // create a new option (must not exist)
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) //EndExport(function)
{
    DWORD                          Error;
    LPWSTR                         Name;
    LPWSTR                         Comment;
    LPBYTE                         Value;
    DWORD                          ValueSize;
    DWORD                          OptId;
    BOOL                           IsVendor;

    DhcpAssert( OptionInfo != NULL );

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpCreateOptionV5" );
    if ( Error != ERROR_SUCCESS ) return Error;

    OptId = ConvertOptIdToMemValue(OptionId, IsVendor);

    Error =  ConvertOptionInfoRPCToMemFormat(
        OptionInfo,
        &Name,
        &Comment,
        NULL,
        &Value,
        &ValueSize
    );
    if( ERROR_SUCCESS == Error ) {

        Error = DhcpCreateOptionDef(
            Name,
            Comment,
            ClassName,
            VendorName,
            OptId,
            OptionInfo->OptionType,
            Value,
            ValueSize
            );
    }

    if( Value ) DhcpFreeMemory(Value);

    return DhcpEndWriteApiEx(
        "DhcpCreateOptionV5", Error, FALSE, TRUE, 0,0,0 );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpSetOptionInfoV5(                            // Modify existing option's fields
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) //EndExport(function)
{
    DWORD                          Error;
    LPWSTR                         Name;
    LPWSTR                         Comment;
    LPBYTE                         Value;
    DWORD                          ValueSize;
    DWORD                          OptId;
    BOOL                           IsVendor;

    DhcpAssert( OptionInfo != NULL );

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpSetOptionInfoV5" );
    if ( Error != ERROR_SUCCESS ) return Error;

    OptId = ConvertOptIdToMemValue(OptionID, IsVendor);

    Error =  ConvertOptionInfoRPCToMemFormat(
        OptionInfo,
        &Name,
        &Comment,
        NULL,
        &Value,
        &ValueSize
    );
    if( ERROR_SUCCESS == Error ) {

        Error = DhcpModifyOptionDef(
            Name,
            Comment,
            ClassName,
            VendorName,
            OptId,
            OptionInfo->OptionType,
            Value,
            ValueSize
            );
    }
    
    if( Value ) DhcpFreeMemory(Value);

    return DhcpEndWriteApiEx(
        "DhcpSetOptionInfoV5", Error, FALSE, TRUE, 0,0,0 );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
R_DhcpGetOptionInfoV5(                            // retrieve the information from off the mem structures
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    DhcpAssert( OptionInfo != NULL );

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginReadApi( "DhcpGetOptionInfoV5" );
    if ( Error != ERROR_SUCCESS ) return Error;

    *OptionInfo = MIDL_user_allocate(sizeof(DHCP_OPTION));
    if( NULL == *OptionInfo ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DhcpEndReadApi( "DhcpGetOptionInfoV5", Error );
        return Error;
    }
    
    OptionID = ConvertOptIdToMemValue(OptionID, IsVendor);
    Error = DhcpGetOptionDef(
        ClassName,
        VendorName,
        OptionID,
        NULL,
        *OptionInfo,
        NULL
    );

    if( ERROR_FILE_NOT_FOUND == Error ) {
        Error = ERROR_DHCP_OPTION_NOT_PRESENT;
    }

    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(*OptionInfo);
        *OptionInfo = NULL;
    }

    DhcpEndReadApi( "DhcpGetOptionInfoV5", Error );
    return Error;
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpEnumOptionsV5(                              // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginReadApi( "DhcpEnumOptionV5" );
    if ( Error != ERROR_SUCCESS ) return Error;

    Error = DhcpEnumRPCOptionDefs(
        Flags,
        ResumeHandle,
        ClassName,
        VendorName,
        PreferredMaximum,
        Options,
        OptionsRead,
        OptionsTotal
    );

    DhcpEndReadApi( "DhcpEnumOptionV5", Error );
    return Error;
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
R_DhcpRemoveOptionV5(                             // remove the option definition from the registry
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpRemoveOptionV5" );
    if ( Error != ERROR_SUCCESS ) return( Error );

    OptionID = ConvertOptIdToMemValue(OptionID, IsVendor);
    Error = DhcpDeleteOptionDef(
        ClassName,
        VendorName,
        OptionID
    );

    return DhcpEndWriteApiEx(
        "DhcpRemoveOptionV5", Error, FALSE, TRUE, 0,0,0 );
}

//BeginExport(function)
DWORD                                             // OPTION_NOT_PRESENT if option is not defined
R_DhcpSetOptionValueV5(                           // replace or add a new option value
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    DhcpAssert( OptionValue != NULL );

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpSetOptionValueV5" );
    if ( Error != ERROR_SUCCESS ) return( Error );

    OptionId = ConvertOptIdToMemValue(OptionId, IsVendor);

    Error = DhcpSetOptionValue(
        ClassName,                                // no class
        VendorName,
        OptionId,
        ScopeInfo,
        OptionValue
    );

    return EndWriteApiForScopeInfo(
        "DhcpSetOptionValueV5", Error, ScopeInfo );
}

//BeginExport(function)
DWORD                                             // not atomic!!!!
R_DhcpSetOptionValuesV5(                          // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) //EndExport(function)
{
    DWORD                          NumElements;
    DWORD                          Error;
    DWORD                          Index;
    BOOL                           IsVendor;

    DhcpAssert( OptionValues != NULL );

    if (( NULL == OptionValues ) ||
        ( NULL == ScopeInfo )) {
        return ERROR_INVALID_PARAMETER;
    }
    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if (( FALSE == IsVendor ) && ( 0 != Flags )) {
        // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    NumElements = OptionValues->NumElements;
    if( 0 == NumElements ) return ERROR_SUCCESS;

    if (( NumElements > 0  ) &&
        ( NULL == OptionValues->Values )) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpSetOptionValueV5" );
    if ( Error != ERROR_SUCCESS ) return( Error );

    for( Index = 0; Index < NumElements ; Index ++ ) {
        Error = DhcpSetOptionValue(               // call the subroutine to do the real get operation
            ClassName,
            VendorName,
            ConvertOptIdToMemValue(OptionValues->Values[Index].OptionID,IsVendor),
            ScopeInfo,
            &OptionValues->Values[Index].Value
        );
        if( ERROR_SUCCESS != Error ) break;
    }

    return EndWriteApiForScopeInfo(
        "DhcpSetOptionValueV5", Error, ScopeInfo );
}

//BeginExport(function)
DWORD
R_DhcpGetOptionValueV5(                           // fetch the required option at required level
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    DhcpAssert( *OptionValue == NULL );

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginReadApi( "DhcpGetOptionValueV5" );
    if ( Error != ERROR_SUCCESS )  return Error ;

    Error = DhcpGetOptionValue(
        ConvertOptIdToMemValue(OptionID,IsVendor),
        ClassName,
        VendorName,
        ScopeInfo,
        OptionValue
    );

    DhcpEndReadApi( "DhcpGetOptionValueV5", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpEnumOptionValuesV5(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    DhcpPrint(( DEBUG_APIS, "R_DhcpEnumOptionValues is called.\n"));
    DhcpAssert( OptionValues != NULL );

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginReadApi( "DhcpEnumOptionValuesV5" );
    if ( Error != ERROR_SUCCESS )  return Error ;

    Error = DhcpEnumOptionValues(
        ScopeInfo,
        ClassName,
        VendorName,
        IsVendor,
        ResumeHandle,
        PreferredMaximum,
        OptionValues,
        OptionsRead,
        OptionsTotal
    );

    DhcpEndReadApi( "DhcpEnumOptionValuesV5", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpRemoveOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpRemoveOptionValueV5" );
    if ( Error != ERROR_SUCCESS )  return Error ;

    Error = DhcpRemoveOptionValue(
        ConvertOptIdToMemValue(OptionID,IsVendor),
        ClassName,
        VendorName,
        ScopeInfo
    );

    return EndWriteApiForScopeInfo(
        "DhcpRemoveOptionValueV5", Error, ScopeInfo );
}

//================================================================================
//  ClassID only APIs (only NT 5 Beta2 and after)
//================================================================================

//BeginExport(function)
DWORD
R_DhcpCreateClass(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) //EndExport(function)
{
    DWORD                          Error;

    if( NULL == ClassInfo || NULL == ClassInfo->ClassName ||
        0 == ClassInfo->ClassDataLength || NULL == ClassInfo->ClassData ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpCreateClass" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpCreateClass(
        ClassInfo->ClassName,
        ClassInfo->IsVendor?DHCP_FLAGS_OPTION_IS_VENDOR:0,
        ClassInfo->ClassComment,
        ClassInfo->ClassData,
        ClassInfo->ClassDataLength
    );

    return DhcpEndWriteApiEx(
        "DhcpCreateClass", Error, TRUE, FALSE, 0,0,0 );
}

//BeginExport(function)
DWORD
R_DhcpModifyClass(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) //EndExport(function)
{
    DWORD                          Error;

    if( NULL == ClassInfo || NULL == ClassInfo->ClassName ||
        0 == ClassInfo->ClassDataLength || NULL == ClassInfo->ClassData ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpModifyClass" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpModifyClass(
        ClassInfo->ClassName,
        ClassInfo->IsVendor?DHCP_FLAGS_OPTION_IS_VENDOR:0,
        ClassInfo->ClassComment,
        ClassInfo->ClassData,
        ClassInfo->ClassDataLength
    );

    return DhcpEndWriteApiEx(
        "DhcpModifyClass", Error, TRUE, FALSE, 0,0,0 );
}

//BeginExport(function)
DWORD
R_DhcpDeleteClass(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPWSTR                 ClassName
) //EndExport(function)
{
    DWORD                          Error;

    if( NULL == ClassName ) return ERROR_INVALID_PARAMETER;

    Error = DhcpBeginWriteApi( "DhcpDeleteClass" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpDeleteClass(ClassName);
    
    return DhcpEndWriteApiEx(
        "DhcpDeleteClass", Error, TRUE, FALSE, 0,0,0 );
}

//BeginExport(function)
DWORD
R_DhcpGetClassInfo(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      PartialClassInfo,
    OUT     LPDHCP_CLASS_INFO     *FilledClassInfo
) //EndExport(function)
{
    DWORD                          Error;

    if( NULL == PartialClassInfo || NULL == FilledClassInfo ) return ERROR_INVALID_PARAMETER;
    if( NULL == PartialClassInfo->ClassName && NULL == PartialClassInfo->ClassData )
        return ERROR_INVALID_PARAMETER;
    if( NULL == PartialClassInfo->ClassName && 0 == PartialClassInfo->ClassDataLength )
        return ERROR_INVALID_PARAMETER;

    Error = DhcpBeginReadApi( "DhcpGetClassInfo" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpGetClassInfo(
        PartialClassInfo->ClassName,
        PartialClassInfo->ClassData,
        PartialClassInfo->ClassDataLength,
        FilledClassInfo
    );

    DhcpEndReadApi( "DhcpGetClassInfo", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpEnumClasses(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
) //EndExport(function)
{
    DWORD                          Error;

    if( NULL == ClassInfoArray || NULL == nRead || NULL == nTotal )
        return ERROR_INVALID_PARAMETER;

    Error = DhcpBeginReadApi( "DhcpEnumClasses" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpEnumClasses(
        ResumeHandle,
        PreferredMaximum,
        ClassInfoArray,
        nRead,
        nTotal
    );

    DhcpEndReadApi( "DhcpEnumClasses", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpGetAllOptionValues(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_ALL_OPTION_VALUES *Values
) //EndExport(function)
{
    DWORD                          Error;
    LPDHCP_ALL_OPTION_VALUES       LocalValues;

    Error = DhcpBeginReadApi( "DhcpGetAllOptionValues" );
    if( NO_ERROR != Error ) return Error;
    
    LocalValues = MIDL_user_allocate(sizeof(*LocalValues));
    if( NULL == LocalValues ) {
        DhcpEndReadApi( "DhcpGetAllOptionValues", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpGetAllOptionValues(
        Flags,
        ScopeInfo,
        LocalValues
    );
    
    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalValues);
        LocalValues = NULL;
    }
    
    *Values = LocalValues;
    DhcpEndReadApi( "DhcpGetAllOptionValues", Error );

    return Error;
}

//BeginExport(function)
DWORD
R_DhcpGetAllOptions(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    OUT     LPDHCP_ALL_OPTIONS    *Options
) //EndExport(function)
{
    DWORD                          Error;
    LPDHCP_ALL_OPTIONS             LocalOptions;


    Error = DhcpBeginReadApi( "DhcpGetAllOptions" );
    if ( Error != ERROR_SUCCESS ) return Error;

    LocalOptions = MIDL_user_allocate(sizeof(*LocalOptions));
    if( NULL == LocalOptions ) {
        DhcpEndReadApi( "DhcpGetAllOptions", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpGetAllOptions(
        Flags,
        LocalOptions
    );

    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalOptions);
        LocalOptions = NULL;
    }
    *Options = LocalOptions;

    DhcpEndReadApi( "DhcpGetAllOptions", Error );
    return Error;
}


//================================================================================
//  NT 5 beta1 and before -- the stubs for those are here...
//================================================================================
//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
R_DhcpCreateOption(                               // create a new option (must not exist)
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPDHCP_OPTION          OptionInfo
) //EndExport(function)
{
    return R_DhcpCreateOptionV5(
        ServerIpAddress,
        0,
        OptionId,
        NULL,
        NULL,
        OptionInfo
    );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpSetOptionInfo(                              // Modify existing option's fields
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION          OptionInfo
) //EndExport(function)
{
    return R_DhcpSetOptionInfoV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        OptionInfo
    );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
R_DhcpGetOptionInfo(                              // retrieve the information from off the mem structures
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) //EndExport(function)
{
    return R_DhcpGetOptionInfoV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        OptionInfo
    );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpEnumOptions(                                // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) //EndExport(function)
{
    return R_DhcpEnumOptionsV5(
        ServerIpAddress,
        0,
        NULL,
        NULL,
        ResumeHandle,
        PreferredMaximum,
        Options,
        OptionsRead,
        OptionsTotal
    );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
R_DhcpRemoveOption(                               // remove the option definition from the registry
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID
) //EndExport(function)
{
    return R_DhcpRemoveOptionV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL
    );
}

//BeginExport(function)
DWORD                                             // OPTION_NOT_PRESENT if option is not defined
R_DhcpSetOptionValue(                             // replace or add a new option value
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) //EndExport(function)
{
    return R_DhcpSetOptionValueV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        ScopeInfo,
        OptionValue
    );
}

//BeginExport(function)
DWORD                                             // not atomic!!!!
R_DhcpSetOptionValues(                            // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) //EndExport(function)
{
    return R_DhcpSetOptionValuesV5(
        ServerIpAddress,
        0,
        NULL,
        NULL,
        ScopeInfo,
        OptionValues
    );
}

//BeginExport(function)
DWORD
R_DhcpGetOptionValue(                             // fetch the required option at required level
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) //EndExport(function)
{
    return R_DhcpGetOptionValueV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        ScopeInfo,
        OptionValue
    );
}

//BeginExport(function)
DWORD
R_DhcpEnumOptionValues(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) //EndExport(function)
{
    return R_DhcpEnumOptionValuesV5(
        ServerIpAddress,
        0,
        NULL,
        NULL,
        ScopeInfo,
        ResumeHandle,
        PreferredMaximum,
        OptionValues,
        OptionsRead,
        OptionsTotal
    );
}

//BeginExport(function)
DWORD
R_DhcpRemoveOptionValue(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) //EndExport(function)
{
    return R_DhcpRemoveOptionValueV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        ScopeInfo
    );
}

//================================================================================
//  plumbing some default stuff.
//================================================================================

DWORD
SetDefaultConfigInfo(
    VOID
)
{
    ULONG Error;
    DWORD ZeroDword = 0;
    DHCP_OPTION_DATA_ELEMENT OptDataElt = {
        DhcpDWordOption
    };
    DHCP_OPTION_DATA OptData = {
        1,
        &OptDataElt
    };

#define OPTION_VALUE_BUFFER_SIZE 50

    BYTE OptValueBuffer[ OPTION_VALUE_BUFFER_SIZE ];
    BYTE NetbiosOptValueBuffer[ OPTION_VALUE_BUFFER_SIZE ];
    BYTE CsrOptValueBuffer[ OPTION_VALUE_BUFFER_SIZE ];
    BYTE ReleaseOptValueBuffer[ OPTION_VALUE_BUFFER_SIZE ];

    ULONG OptValueBufferSize = 0;
    ULONG NetbiosOptValueBufferSize = 0;
    ULONG CsrOptValueBufferSize = 0;
    ULONG ReleaseOptValueBufferSize = 0;

    BOOL ClassChanged = FALSE;
    BOOL OptionsChanged = FALSE;
    //
    // Fill option value struct..
    //
    OptDataElt.Element.DWordOption = 1;
    ReleaseOptValueBufferSize = sizeof(ReleaseOptValueBuffer);
    Error = DhcpConvertOptionRPCToRegFormat(
        &OptData,
        ReleaseOptValueBuffer,
        &ReleaseOptValueBufferSize
        );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "DhcpConvertOptionRPCToRegFormat: %ld\n", Error));
        return Error;
    }

    //
    // Fill option value struct..
    //
    OptDataElt.Element.DWordOption = 0;
    OptValueBufferSize = sizeof(OptValueBuffer);
    Error = DhcpConvertOptionRPCToRegFormat(
        &OptData,
        OptValueBuffer,
        &OptValueBufferSize
        );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "DhcpConvertOptionRPCToRegFormat: %ld\n", Error));
        return Error;
    }

    //
    // Fill option value struct..
    //
    OptDataElt.Element.DWordOption = 1;
    NetbiosOptValueBufferSize = sizeof(OptValueBuffer);
    Error = DhcpConvertOptionRPCToRegFormat(
        &OptData,
        NetbiosOptValueBuffer,
        &NetbiosOptValueBufferSize
        );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "DhcpConvertOptionRPCToRegFormat: %ld\n", Error));
        return Error;
    }

    //
    // Fill option value struct..
    //
    OptDataElt.OptionType = DhcpBinaryDataOption;
    OptDataElt.Element.BinaryDataOption.DataLength = 0;
    OptDataElt.Element.BinaryDataOption.Data = NULL;
    CsrOptValueBufferSize = sizeof(OptValueBuffer);
    
    Error = DhcpConvertOptionRPCToRegFormat(
        &OptData,
        CsrOptValueBuffer,
        &CsrOptValueBufferSize
        );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "DhcpConvertOptionRPCToRegFormat: %ld\n", Error));
        return Error;
    }

    //
    // Create user classes -- ignore errors
    //

    Error = DhcpCreateClass(
        GETSTRING( DHCP_MSFT_RRAS_CLASS_NAME ),
        0, 
        GETSTRING( DHCP_MSFT_RRAS_CLASS_DESCR_NAME),
        DHCP_RAS_CLASS_TXT,
        sizeof(DHCP_RAS_CLASS_TXT)-1
        );

    ClassChanged = Error == NO_ERROR;

    if( NO_ERROR != Error && ERROR_DHCP_CLASS_ALREADY_EXISTS != Error ) {
        //
        // Ignore error
        //
        DhcpPrint((DEBUG_INIT, "DhcpCreateClass RRAS failed: %lx\n", Error));
    }

    Error = DhcpCreateClass(
        GETSTRING( DHCP_MSFT_DYNBOOTP_CLASS_NAME),
        0,
        GETSTRING( DHCP_MSFT_DYNBOOTP_CLASS_DESCR_NAME),
        DHCP_BOOTP_CLASS_TXT,
        sizeof(DHCP_BOOTP_CLASS_TXT)-1
        );
    ClassChanged = Error == NO_ERROR;
    if( NO_ERROR != Error && ERROR_DHCP_CLASS_ALREADY_EXISTS != Error ) {
        //
        // Ignore error
        //
        DhcpPrint((DEBUG_INIT, "DhcpCreateClass BOOTP failed: %lx\n", Error));
    }
    
    //
    // First create MICROSFT vendor classes..
    //

    Error = DhcpCreateClass(
        GETSTRING( DHCP_MSFT50_CLASS_NAME ),
        DHCP_FLAGS_OPTION_IS_VENDOR,
        GETSTRING( DHCP_MSFT50_CLASS_DESCR_NAME ),
        DHCP_MSFT50_CLASS_TXT,
        sizeof(DHCP_MSFT50_CLASS_TXT)-1
        );
    ClassChanged = Error == NO_ERROR;
    if( ERROR_SUCCESS != Error && ERROR_DHCP_CLASS_ALREADY_EXISTS != Error ) {
        //
        // Dont ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "DhcpCreateClass msft50 failed:%lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    Error = DhcpCreateClass(
        GETSTRING( DHCP_MSFT98_CLASS_NAME ),
        DHCP_FLAGS_OPTION_IS_VENDOR,
        GETSTRING( DHCP_MSFT98_CLASS_DESCR_NAME ),
        DHCP_MSFT98_CLASS_TXT,
        sizeof(DHCP_MSFT98_CLASS_TXT)-1
        );
    ClassChanged = Error == NO_ERROR;
    if( ERROR_SUCCESS != Error && ERROR_DHCP_CLASS_ALREADY_EXISTS != Error ) {
        //
        // Dont ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "DhcpCreateClass msft98 failed:%lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    Error = DhcpCreateClass(
        GETSTRING( DHCP_MSFT_CLASS_NAME ),
        DHCP_FLAGS_OPTION_IS_VENDOR,
        GETSTRING( DHCP_MSFT_CLASS_DESCR_NAME ),
        DHCP_MSFT_CLASS_TXT,
        sizeof(DHCP_MSFT_CLASS_TXT)-1
        );
    ClassChanged = Error == NO_ERROR;
    if( ERROR_SUCCESS != Error && ERROR_DHCP_CLASS_ALREADY_EXISTS != Error ) {
        //
        // Cant ignore this error..
        //
        DhcpPrint((DEBUG_INIT, "DhcpCreateClass msft failed:%lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    Error = ERROR_INTERNAL_ERROR;
    
    DhcpGlobalMsft2000Class = DhcpServerGetVendorId(
        DhcpGetCurrentServer(),
        DHCP_MSFT50_CLASS_TXT,
        sizeof(DHCP_MSFT50_CLASS_TXT)-1
        );
    if( 0 == DhcpGlobalMsft2000Class ) {
        DhcpPrint((DEBUG_INIT, "MSFT50 Class isn't present..\n"));

        goto Cleanup;
    }

    DhcpGlobalMsft98Class = DhcpServerGetVendorId(
        DhcpGetCurrentServer(),
        DHCP_MSFT98_CLASS_TXT,
        sizeof(DHCP_MSFT98_CLASS_TXT)-1
        );
    if( 0 == DhcpGlobalMsft98Class ) {
        DhcpPrint((DEBUG_INIT, "MSFT98 Class isn't present..\n"));

        goto Cleanup;
    }
    
    DhcpGlobalMsftClass = DhcpServerGetVendorId(
        DhcpGetCurrentServer(),
        DHCP_MSFT_CLASS_TXT,
        sizeof(DHCP_MSFT_CLASS_TXT)-1
        );
    if( 0 == DhcpGlobalMsftClass ) {
        DhcpPrint((DEBUG_INIT, "MSFT Class isn't present..\n"));

        goto Cleanup;
    }

    //
    // Create the default user classes ??
    //
    
    //
    // Create Default option definitions..
    //

    //
    // Netbiosless option
    //
    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_NETBIOS_VENDOR_OPTION_NAME ),
        GETSTRING( DHCP_NETBIOS_VENDOR_DESCR_NAME ),
        NULL,
        GETSTRING( DHCP_MSFT_CLASS_NAME ),
        ConvertOptIdToMemValue(OPTION_MSFT_VENDOR_NETBIOSLESS, TRUE),
        DhcpUnaryElementTypeOption,
        NetbiosOptValueBuffer,
        NetbiosOptValueBufferSize
        );
    OptionsChanged = Error == NO_ERROR;
    if( ERROR_SUCCESS != Error && ERROR_DHCP_OPTION_EXITS != Error ) {
        //
        // Don't ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "Create Netbiosless option failed: %lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    //
    // Create Release on shutdown and other options
    //
    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_RELEASE_SHUTDOWN_VENDOR_OPTION_NAME ),
        GETSTRING( DHCP_RELEASE_SHUTDOWN_VENDOR_DESCR_NAME ),
        NULL,
        GETSTRING( DHCP_MSFT_CLASS_NAME ),
        ConvertOptIdToMemValue(OPTION_MSFT_VENDOR_FEATURELIST, TRUE),
        DhcpUnaryElementTypeOption,
        ReleaseOptValueBuffer,
    ReleaseOptValueBufferSize
        );
    OptionsChanged = Error == NO_ERROR;
    if( ERROR_SUCCESS != Error && ERROR_DHCP_OPTION_EXITS != Error ) {
        //
        // Don't ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "Create ReleaseOnShutdown option failed: %lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    //
    // Create metric-base option
    //
    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_METRICBASE_VENDOR_OPTION_NAME ),
        GETSTRING( DHCP_METRICBASE_VENDOR_DESCR_NAME ),
        NULL,
        GETSTRING( DHCP_MSFT_CLASS_NAME ),
        ConvertOptIdToMemValue(OPTION_MSFT_VENDOR_METRIC_BASE, TRUE),
        DhcpUnaryElementTypeOption,
        ReleaseOptValueBuffer,
        ReleaseOptValueBufferSize
        );
    OptionsChanged = Error == NO_ERROR;
    if( ERROR_SUCCESS != Error && ERROR_DHCP_OPTION_EXITS != Error ) {
        //
        // Don't ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "Create metricbase option failed: %lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    //
    // Create same set of options as before for MSFT50 class..
    //
    
    //
    // Netbiosless option
    //
    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_NETBIOS_VENDOR_OPTION_NAME ),
        GETSTRING( DHCP_NETBIOS_VENDOR_DESCR_NAME ),
        NULL,
        GETSTRING( DHCP_MSFT50_CLASS_NAME ),
        ConvertOptIdToMemValue(OPTION_MSFT_VENDOR_NETBIOSLESS, TRUE),
        DhcpUnaryElementTypeOption,
        NetbiosOptValueBuffer,
        NetbiosOptValueBufferSize
        );
    OptionsChanged = Error == NO_ERROR;
    if( ERROR_SUCCESS != Error && ERROR_DHCP_OPTION_EXITS != Error ) {
        //
        // Don't ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "Create Netbiosless50 option failed: %lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    //
    // Create Release on shutdown and other options
    //
    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_RELEASE_SHUTDOWN_VENDOR_OPTION_NAME ),
        GETSTRING( DHCP_RELEASE_SHUTDOWN_VENDOR_DESCR_NAME ),
        NULL,
        GETSTRING( DHCP_MSFT50_CLASS_NAME ),
        ConvertOptIdToMemValue(OPTION_MSFT_VENDOR_FEATURELIST, TRUE),
        DhcpUnaryElementTypeOption,
        ReleaseOptValueBuffer,
        ReleaseOptValueBufferSize
        );
    OptionsChanged = Error == NO_ERROR;
    if( ERROR_SUCCESS != Error && ERROR_DHCP_OPTION_EXITS != Error ) {
        //
        // Don't ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "Create ReleaseOnShutdown50 option failed: %lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    //
    // Create metric base option
    //
    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_METRICBASE_VENDOR_OPTION_NAME ),
        GETSTRING( DHCP_METRICBASE_VENDOR_DESCR_NAME ),
        NULL,
        GETSTRING( DHCP_MSFT50_CLASS_NAME ),
        ConvertOptIdToMemValue(OPTION_MSFT_VENDOR_METRIC_BASE, TRUE),
        DhcpUnaryElementTypeOption,
        OptValueBuffer,
        OptValueBufferSize
        );
    OptionsChanged = Error == NO_ERROR;
    if( ERROR_SUCCESS != Error && ERROR_DHCP_OPTION_EXITS != Error ) {
        //
        // Don't ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "Create metricbase50 option failed: %lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_MSFT_CSR_OPTION_NAME ),
        GETSTRING( DHCP_MSFT_CSR_DESCR_NAME ),
        NULL,
        NULL,
        OPTION_CLASSLESS_ROUTES,
        DhcpUnaryElementTypeOption,
        CsrOptValueBuffer,
        CsrOptValueBufferSize
        );

    OptionsChanged = Error == NO_ERROR;
    
    return DhcpConfigSave(
        ClassChanged, OptionsChanged, 0,0,0);

 Cleanup:

    ASSERT( NO_ERROR != Error );

    return Error;
} // SetDefaultConfigInfo()

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\rpcapi3.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:
    rpcapi3.c

Abstract:
    Miscellanious RPC APIs (essentially querying server status 
       and rogue detection stuff as well as starting/setting some stuff)

Environment:
    Usermode Win32 DHCP Server

--*/

#include    <dhcpreg.h>
#include    <dhcppch.h>
#include    <lmapibuf.h>
#include    <dsgetdc.h>
#include    <iptbl.h>
#include    <endpoint.h>

#define CONFIG_BACKUP_MAX_PATH  500

DWORD
R_DhcpServerQueryAttribute(
    IN LPWSTR ServerIpAddress,
    IN ULONG dwReserved,
    IN DHCP_ATTRIB_ID DhcpAttribId,
    OUT LPDHCP_ATTRIB *pDhcpAttrib
)
/*++

Routine Description:
    This routine queries the DHCP Server for the property identified by the
    parameter DhcpAttribId.   The return value can currently be one of the
    following types: DHCP_ATTRIB_TYPE_BOOL or DHCP_ATTRIB_TYPE_ULONG.

Arguments:
    ServerIpAddress -- string representation of server IP address, not used
    dwReserved -- must be zero, reserved for future use
    DhcpAttribId -- Attrib ID that is being queried
    pDhcpAttrib -- This pointer is filled with attrib ID (memory is
        allocated by routine and must be freed with DhcpRpcFreeMemory).

Return Value:
    ERROR_ACCESS_DENIED -- do not have viewing privilege on the server.
    ERROR_INVALID_PARAMETER -- invalid parameters passed
    ERROR_NOT_ENOUGH_MEMORY -- not enough memory to process
    ERROR_NOT_SUPPORTED -- requested attrib is not available
    ERROR_SUCCESS

--*/
{
    DWORD Error;

    DhcpPrint(( DEBUG_APIS, "R_DhcpServerQueryAttribute is called.\n")); 

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    if( NULL == pDhcpAttrib || 0 != dwReserved ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( DHCP_ATTRIB_BOOL_IS_ROGUE != DhcpAttribId &&
        DHCP_ATTRIB_BOOL_IS_DYNBOOTP != DhcpAttribId &&
        DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC != DhcpAttribId &&
        DHCP_ATTRIB_BOOL_IS_ADMIN != DhcpAttribId &&
        DHCP_ATTRIB_BOOL_IS_BINDING_AWARE != DhcpAttribId &&
        DHCP_ATTRIB_ULONG_RESTORE_STATUS != DhcpAttribId ) {
        return ERROR_NOT_SUPPORTED;
    }

    (*pDhcpAttrib) = MIDL_user_allocate(sizeof(DHCP_ATTRIB));
    if( NULL == (*pDhcpAttrib) ) return ERROR_NOT_ENOUGH_MEMORY;

    (*pDhcpAttrib)->DhcpAttribId = DhcpAttribId;
    (*pDhcpAttrib)->DhcpAttribType = DHCP_ATTRIB_TYPE_BOOL;
    if( DHCP_ATTRIB_BOOL_IS_ROGUE == DhcpAttribId ) {
        if( DhcpGlobalNumberOfNetsActive == 0 ) {
            (*pDhcpAttrib)->DhcpAttribBool = FALSE;
        } else {
            (*pDhcpAttrib)->DhcpAttribBool = !DhcpGlobalOkToService;
        }
    } else if( DHCP_ATTRIB_BOOL_IS_DYNBOOTP == DhcpAttribId ) {
        (*pDhcpAttrib)->DhcpAttribBool = DhcpGlobalDynamicBOOTPEnabled;
    } else if( DHCP_ATTRIB_BOOL_IS_BINDING_AWARE == DhcpAttribId ) {
        (*pDhcpAttrib)->DhcpAttribBool = DhcpGlobalBindingsAware;
    } else if( DHCP_ATTRIB_BOOL_IS_ADMIN == DhcpAttribId ) {
        ULONG Err = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
        (*pDhcpAttrib)->DhcpAttribBool = (ERROR_SUCCESS == Err);
    } else if( DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC == DhcpAttribId ) {
        LPWSTR  pDomainName = NULL;
        BOOL IsWorkGroupName = FALSE;

        Error = NetpGetDomainNameEx( &pDomainName,
                                     ( PBOOLEAN ) &IsWorkGroupName );
        (*pDhcpAttrib)->DhcpAttribBool =
            ( NULL != pDomainName ) && 
            ( !IsWorkGroupName );
        if ( NULL != pDomainName ) {
            NetApiBufferFree( pDomainName );
        }
    } else if( DHCP_ATTRIB_ULONG_RESTORE_STATUS == DhcpAttribId ) {
        (*pDhcpAttrib)->DhcpAttribUlong = DhcpGlobalRestoreStatus;
        (*pDhcpAttrib)->DhcpAttribType = DHCP_ATTRIB_TYPE_ULONG;
    }
    
    return ERROR_SUCCESS;
} // R_DhcpServerQueryAttribute()

DWORD
R_DhcpServerQueryAttributes(
    IN LPWSTR ServerIpAddress,
    IN ULONG dwReserved,
    IN ULONG dwAttribCount,
    IN LPDHCP_ATTRIB_ID pDhcpAttribs,
    OUT LPDHCP_ATTRIB_ARRAY *pDhcpAttribArr
)
/*++

Routine Description:
    This routine queries a bunch of properties from the DHCP Server.  In
    case some of the requested attributes aren't known to the server, it
    would still return the supported attributes (so you have to check the
    value in the pDhcpAttribArr parameter to see what attributes are
    available) -- and in this case an error ERROR_NOT_SUPPORTED is
    returned. 

Arguments:
    ServerIpAddress -- string representation of server IP address, not used
    dwReserved -- must be zero, reserved for future use
    dwAttribCount -- the number of attribs being queried
    pDhcpAttribs -- array of attributes being queried
    pDhcpAttribArr -- array of attributes being returned.  This could be
        NULL if there was an error, or it could be a set of attributes that
        the server supports.  (So, if the return value is
        ERROR_NOT_SUPPORTED, this parameter may still contain some value). 
        This should be freed via DhcpRpcFreeMemory.

Return Values:
    ERROR_ACCESS_DENIED -- do not have viewing privilege on the server.
    ERROR_INVALID_PARAMETER -- invalid parameters passed
    ERROR_NOT_ENOUGH_MEMORY -- not enough memory to process
    ERROR_NOT_SUPPORTED -- some requested attrib is not available
    ERROR_SUCCESS

--*/
{
    DWORD Error;
    ULONG i, nAttribs;
    LPDHCP_ATTRIB_ARRAY RetArr;

    DhcpPrint(( DEBUG_APIS, "R_DhcpServerQueryAttributes is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    if( NULL == pDhcpAttribs || 0 == dwAttribCount ||
        0 != dwReserved || NULL == pDhcpAttribArr ) {
        return ERROR_INVALID_PARAMETER;
    }

    *pDhcpAttribArr = NULL;

    nAttribs = 0;
    for( i = 0; i < dwAttribCount; i ++ ) {
        if( DHCP_ATTRIB_BOOL_IS_ROGUE == pDhcpAttribs[i] 
            || DHCP_ATTRIB_BOOL_IS_DYNBOOTP == pDhcpAttribs[i] 
            || DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC == pDhcpAttribs[i]
            || DHCP_ATTRIB_BOOL_IS_ADMIN == pDhcpAttribs[i]
            || DHCP_ATTRIB_BOOL_IS_BINDING_AWARE == pDhcpAttribs[i]
            || DHCP_ATTRIB_ULONG_RESTORE_STATUS == pDhcpAttribs[i]  ) {
            nAttribs ++;
        }
    }

    if( nAttribs == 0 ) {
        //
        // No attrib is supported?
        // 
        return ERROR_NOT_SUPPORTED;
    }

    RetArr = MIDL_user_allocate(sizeof(*RetArr));
    if( NULL == RetArr ) return ERROR_NOT_ENOUGH_MEMORY;

    RetArr->NumElements = nAttribs;
    RetArr->DhcpAttribs = MIDL_user_allocate(sizeof(DHCP_ATTRIB)*nAttribs);
    if( NULL == RetArr->DhcpAttribs ) {
        MIDL_user_free(RetArr);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    nAttribs = 0;
    for( i = 0; i < dwAttribCount ; i ++) {
        if( DHCP_ATTRIB_BOOL_IS_ROGUE == pDhcpAttribs[i] ) {

            RetArr->DhcpAttribs[nAttribs].DhcpAttribId = pDhcpAttribs[i];
            RetArr->DhcpAttribs[nAttribs].DhcpAttribType = (
                DHCP_ATTRIB_TYPE_BOOL
                );
            if( DhcpGlobalNumberOfNetsActive == 0 ) {
                RetArr->DhcpAttribs[nAttribs++].DhcpAttribBool = FALSE;
            } else {
                RetArr->DhcpAttribs[nAttribs++].DhcpAttribBool = (
                    !DhcpGlobalOkToService
                    );
            }
        } else if ( DHCP_ATTRIB_BOOL_IS_DYNBOOTP == pDhcpAttribs[i] ) {
            
            RetArr->DhcpAttribs[nAttribs].DhcpAttribId = pDhcpAttribs[i];
            RetArr->DhcpAttribs[nAttribs].DhcpAttribType = (
                DHCP_ATTRIB_TYPE_BOOL
                );
            RetArr->DhcpAttribs[nAttribs++].DhcpAttribBool = (
                DhcpGlobalDynamicBOOTPEnabled
                );
        } else if ( DHCP_ATTRIB_BOOL_IS_ADMIN == pDhcpAttribs[i] ) {
            RetArr->DhcpAttribs[nAttribs].DhcpAttribId = pDhcpAttribs[i];
            RetArr->DhcpAttribs[nAttribs].DhcpAttribType = (
                DHCP_ATTRIB_TYPE_BOOL
                );
            RetArr->DhcpAttribs[nAttribs++].DhcpAttribBool = (
                ERROR_SUCCESS == DhcpApiAccessCheck( DHCP_ADMIN_ACCESS )
                );
        } else if (DHCP_ATTRIB_BOOL_IS_BINDING_AWARE == pDhcpAttribs[i] ) {
            RetArr->DhcpAttribs[nAttribs].DhcpAttribId = pDhcpAttribs[i];
            RetArr->DhcpAttribs[nAttribs].DhcpAttribType = (
                DHCP_ATTRIB_TYPE_BOOL
                );
            RetArr->DhcpAttribs[nAttribs++].DhcpAttribBool = DhcpGlobalBindingsAware; 

        } else if( DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC == pDhcpAttribs[i] ) {
            PDOMAIN_CONTROLLER_INFO Info;
            
            Info = NULL;
            Error = DsGetDcNameW(
                NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED,
                &Info
                );
            RetArr->DhcpAttribs[nAttribs].DhcpAttribId = pDhcpAttribs[i];
            RetArr->DhcpAttribs[nAttribs].DhcpAttribType = (
                DHCP_ATTRIB_TYPE_BOOL
                );
            RetArr->DhcpAttribs[nAttribs++].DhcpAttribBool = (
                ERROR_SUCCESS == Error
                );
            if( NULL != Info ) NetApiBufferFree(Info);
        } else if( DHCP_ATTRIB_ULONG_RESTORE_STATUS ==  pDhcpAttribs[i] ) {
            RetArr->DhcpAttribs[nAttribs].DhcpAttribId = pDhcpAttribs[i];
            RetArr->DhcpAttribs[nAttribs].DhcpAttribType = (
                DHCP_ATTRIB_TYPE_ULONG
                );
            RetArr->DhcpAttribs[nAttribs++].DhcpAttribUlong = (
                DhcpGlobalRestoreStatus
                );
        }
    }

    *pDhcpAttribArr = RetArr;

    if( dwAttribCount == nAttribs ) return ERROR_SUCCESS;
    return ERROR_NOT_SUPPORTED;
}

DWORD
R_DhcpServerRedoAuthorization(
    IN LPWSTR ServerIpAddress,
    IN ULONG dwReserved
)
/*++

Routine Description:
    This routine restarts the rogue detection attempt right away so that if
    the server isn't authorized or is authorized, it can take appropriate
    action.  This API can be called only by administrators...

Parameters:
    ServerIpAddress -- Ip address of server in dotted string format
    dwReserved -- must be zero, unused

Return Value:
    ERROR_ACCESS_DENIED -- do not have admin priviledges on the dhcp server
    ERROR_SUCCESS

--*/
{
    ULONG Error;

    DhcpPrint(( DEBUG_APIS, "R_DhcpServerRedoAuthorization is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    DhcpGlobalRogueRedoScheduledTime = 0;
    DhcpGlobalRedoRogueStuff = TRUE;    
    SetEvent(DhcpGlobalRogueWaitEvent);
    
    return ERROR_SUCCESS;
}

DWORD
R_DhcpGetServerBindingInfo(
    IN LPWSTR ServerIpAddress, // ignored
    IN ULONG dwReserved,
    OUT LPDHCP_BIND_ELEMENT_ARRAY *BindInfo
)
/*++

Routine Description:
    This routine gets the DHCP Server binding information.

Arguments:
    ServerIpAddress -- Ip address of server in dotted string format
    dwReserved -- must be zero, unused
    BindInfo -- On success the server returns the binding info through this.


Return Values:
    Win32 errors
 
--*/
{
    ULONG Error;

    DhcpPrint(( DEBUG_APIS, "R_DhcpGetServerBindingInfo is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    if( 0 != dwReserved ) return ERROR_INVALID_PARAMETER;

    return DhcpGetBindingInfo( BindInfo );
}

DWORD
R_DhcpSetServerBindingInfo(
    IN LPWSTR ServerIpAddress,
    IN ULONG dwReserved,
    IN LPDHCP_BIND_ELEMENT_ARRAY BindInfo
)
/*++

Routine Description:
    This routine sets the DHCP Server binding information.

Arguments:
    ServerIpAddress -- Ip address of server in dotted string format
    dwReserved -- must be zero, unused
    BindInfo -- Binding information to set.

Return Values:
    Win32 errors

--*/
{
    ULONG Error, i, LastError;
    HKEY Key;

    DhcpPrint(( DEBUG_APIS, "R_DhcpGetServerBindingInfo is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    if( 0 != dwReserved ) return ERROR_INVALID_PARAMETER;
    if (( NULL == BindInfo ) ||
        ( NULL == BindInfo->Elements )) {
        return ERROR_INVALID_PARAMETER;
    }

    return DhcpSetBindingInfo(BindInfo);
    
}    


DWORD
R_DhcpQueryDnsRegCredentials(
    IN LPWSTR ServerIpAddress,
    IN ULONG UnameSize,
    IN OUT LPWSTR Uname,
    IN ULONG DomainSize,
    IN OUT LPWSTR Domain
    )
{
    DWORD Error;
    WCHAR Passwd[ 256 ];
    DWORD PasswdSize = 0;
    
    
    DhcpPrint(( DEBUG_APIS, "R_DhcpQueryDnsRegCredentials is called.\n"));
    
    //
    // password size passed in bytes
    //

    PasswdSize = sizeof( Passwd ) / sizeof( WCHAR );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    if ( NULL == ServerIpAddress ) {
        return ERROR_INVALID_PARAMETER;
    }
    return DhcpQuerySecretUname(
        Uname, UnameSize / sizeof(WCHAR),
        Domain, DomainSize / sizeof(WCHAR),
        Passwd, PasswdSize );
}

DWORD
R_DhcpSetDnsRegCredentials(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Uname,
    IN LPWSTR Domain,
    IN LPWSTR Passwd
    )
{
    DWORD Error;
    DWORD Retval;

    DhcpPrint(( DEBUG_APIS, "R_DhcpSetDnsRegCredentials is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    Retval = DhcpSetSecretUnamePasswd( Uname, Domain, Passwd );
    Error = DynamicDnsInit(); // always returns ERROR_SUCCESS

    return Retval;
} // R_DhcpSetDnsRegCredentials()

DWORD
R_DhcpBackupDatabase(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Path
    )
{
    DWORD Error;
    LPSTR BackupPath;       // path for the database
    LPWSTR CfgBackupPath;    // path for configuration in registry
    
    DhcpPrint(( DEBUG_APIS, "R_DhcpBackupDatabase is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    if( NULL == Path ) return ERROR_INVALID_PARAMETER;

    if( IsStringTroublesome( Path ) ) {
        return ERROR_INVALID_NAME;
    }
    
    BackupPath = DhcpUnicodeToOem( Path, NULL );
    if( NULL == BackupPath ) {
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    if ( !CreateDirectoryPathW( Path, &DhcpGlobalSecurityDescriptor )) {

        DhcpPrint((DEBUG_ERRORS, "R_DhcpBackupDatabase() : DhcpCreateDirectoryPathW(%ws): %ld\n", 
                   Path, Error ));
        DhcpFreeMemory( BackupPath );
        return Error;
    }
    

    DhcpPrint(( DEBUG_APIS, "R_DhcpBackupDatabase() : backing up to %s\n",
                BackupPath ));

    Error = DhcpBackupDatabase( BackupPath );

    if ( ERROR_SUCCESS != Error ) {
        return Error;
    }

    // Save the configuration
    CfgBackupPath = (LPWSTR) DhcpAllocateMemory( CONFIG_BACKUP_MAX_PATH *
                                                 sizeof(WCHAR) );
    if (NULL != CfgBackupPath) {
        wcscpy( CfgBackupPath, Path );
        wcscat( CfgBackupPath, DHCP_KEY_CONNECT ); // append '\\'
        wcscat( CfgBackupPath, DHCP_BACKUP_CONFIG_FILE_NAME );
        
        DhcpPrint(( DEBUG_APIS, "Saving Backup configuration\n" ));

        Error = DhcpBackupConfiguration( CfgBackupPath );
        if ( ERROR_SUCCESS != Error) {
            DhcpServerEventLog(
                               EVENT_SERVER_CONFIG_BACKUP, // TODO: Change this
                               EVENTLOG_ERROR_TYPE,
                               Error );
            DhcpPrint(( DEBUG_ERRORS,
                        "DhcpBackupConfiguration failed, %ld\n", Error ));
        } // if 

        DhcpFreeMemory( CfgBackupPath );
    } // if mem allocated

    DhcpFreeMemory( BackupPath );
    return Error;
} // R_DhcpBackupDatabase()

DWORD
R_DhcpRestoreDatabase(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Path
    )
{
    DWORD Error;
    LPWSTR JetBackupPath;
    LPWSTR CfgBackupPath;
    
    DhcpPrint(( DEBUG_APIS, "R_DhcpRestoreDatabase is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    if( NULL == Path ) return ERROR_INVALID_PARAMETER;

    //
    // If the restore is from the standard backup path, then the
    // current database need not be saved. Otherwise, we need
    // to save the current database so that this can be restored
    // if the other restore fails.
    //

    JetBackupPath = DhcpOemToUnicode( DhcpGlobalOemJetBackupPath, NULL);
    if( NULL == JetBackupPath ) {
        return ERROR_INTERNAL_ERROR;
    }

    if( 0 == _wcsicmp(Path, JetBackupPath) ) {
        DhcpFreeMemory( JetBackupPath ); JetBackupPath = NULL;
        Error = DhcpBackupDatabase( DhcpGlobalOemJetBackupPath );
        if( NO_ERROR != Error ) return Error;
    }

    if( NULL != JetBackupPath ) DhcpFreeMemory( JetBackupPath );

    // Set RestoreDatabasePath key in the registry. Upon next startup,
    // database and the configuration will be updated from this location.
    Error = RegSetValueEx( DhcpGlobalRegParam,
                           DHCP_RESTORE_PATH_VALUE,
                           0, DHCP_RESTORE_PATH_VALUE_TYPE,
                           ( LPBYTE ) Path,
                           sizeof( WCHAR ) * ( wcslen( Path ) +1 ));

    return Error;
} // R_DhcpRestoreDatabase()

//
// EOF
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\rpcapi.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

LPWSTR
CloneLPWSTR(                                      // allocate and copy a LPWSTR type
    IN      LPWSTR                 Str
);

LPBYTE                                            // defined in rpcapi1.c
CloneLPBYTE(
    IN      LPBYTE                 Bytes,
    IN      DWORD                  nBytes
);

DWORD
DhcpAddSubnetElement(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 ElementInfo,
    IN      BOOL                   fIsV5Call
);

DWORD
DhcpEnumSubnetElements(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN      BOOL                   fIsV5Call,
    IN OUT  LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalEnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
);

DWORD
DhcpRemoveSubnetElement(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    IN      BOOL                   fIsV5Call,
    IN      DHCP_FORCE_FLAG        ForceFlag
);

DWORD
ScanDatabase(
    PM_SUBNET Subnet,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
);

DWORD
SubnetInUse(
    IN      HKEY                   SubnetKeyHandle,
    IN      DHCP_IP_ADDRESS        SubnetAddress
);

DWORD       _inline
ConvertOptIdToMemValue(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendor
)
{
    if( IsVendor ) return OptId + 256;
    return OptId;
}


DWORD                                             // ERROR_MORE_DATA with DataSize as reqd size if buffer insufficient
DhcpParseRegistryOption(                          // parse the options to fill into this buffer
    IN      LPBYTE                 Value,         // input option buffer
    IN      DWORD                  Length,        // size of input buffer
    OUT     LPBYTE                 DataBuffer,    // output buffer
    OUT     DWORD                 *DataSize,      // given buffer space on input, filled buffer space on output
    IN      BOOL                   fUtf8
) ;


DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
R_DhcpCreateOptionV5(                             // create a new option (must not exist)
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpSetOptionInfoV5(                            // Modify existing option's fields
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
R_DhcpGetOptionInfoV5(                            // retrieve the information from off the mem structures
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpEnumOptionsV5(                              // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
R_DhcpRemoveOptionV5(                             // remove the option definition from the registry
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


DWORD                                             // OPTION_NOT_PRESENT if option is not defined
R_DhcpSetOptionValueV5(                           // replace or add a new option value
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


DWORD                                             // not atomic!!!!
R_DhcpSetOptionValuesV5(                          // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


DWORD
R_DhcpGetOptionValueV5(                           // fetch the required option at required level
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) ;


DWORD
R_DhcpEnumOptionValuesV5(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


DWORD
R_DhcpRemoveOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;


DWORD
R_DhcpCreateClass(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


DWORD
R_DhcpModifyClass(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


DWORD
R_DhcpDeleteClass(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPWSTR                 ClassName
) ;


DWORD
R_DhcpGetClassInfo(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      PartialClassInfo,
    OUT     LPDHCP_CLASS_INFO     *FilledClassInfo
) ;


DWORD
R_DhcpEnumClasses(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
) ;


DWORD
R_DhcpGetAllOptionValues(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_ALL_OPTION_VALUES *Values
) ;


DWORD
R_DhcpGetAllOptions(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    OUT     LPDHCP_ALL_OPTIONS    *Options
) ;


DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
R_DhcpCreateOption(                               // create a new option (must not exist)
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpSetOptionInfo(                              // Modify existing option's fields
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
R_DhcpGetOptionInfo(                              // retrieve the information from off the mem structures
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpEnumOptions(                                // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
R_DhcpRemoveOption(                               // remove the option definition from the registry
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID
) ;


DWORD                                             // OPTION_NOT_PRESENT if option is not defined
R_DhcpSetOptionValue(                             // replace or add a new option value
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


DWORD                                             // not atomic!!!!
R_DhcpSetOptionValues(                            // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


DWORD
R_DhcpGetOptionValue(                             // fetch the required option at required level
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) ;


DWORD
R_DhcpEnumOptionValues(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


DWORD
R_DhcpRemoveOptionValue(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;

//========================================================================
//  end of file 
//========================================================================
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

DWORD
DhcpUpdateReservationInfo(                        // this is used in cltapi.c to update a reservation info
    IN      DWORD                  Address,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDLength
) ;


DWORD
R_DhcpSetSuperScopeV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPWSTR                 SuperScopeName,
    IN      BOOL                   ChangeExisting
) ;


DWORD
R_DhcpDeleteSuperScopeV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      LPWSTR                 SuperScopeName
) ;


DWORD
R_DhcpGetSuperScopeInfoV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    OUT     LPDHCP_SUPER_SCOPE_TABLE *SuperScopeTable
) ;


DWORD
R_DhcpCreateSubnet(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) ;


DWORD
R_DhcpSetSubnetInfo(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) ;


DWORD
R_DhcpGetSubnetInfo(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    OUT     LPDHCP_SUBNET_INFO    *SubnetInfo
) ;


DWORD
R_DhcpEnumSubnets(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN      LPDHCP_IP_ARRAY       *EnumInfo,
    IN      DWORD                 *ElementsRead,
    IN      DWORD                 *ElementsTotal
) ;


DWORD
R_DhcpDeleteSubnet(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_FORCE_FLAG        ForceFlag      // if TRUE delete all turds from memory/registry/database
) ;


DWORD
R_DhcpAddSubnetElementV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4  AddElementInfo
) ;


DWORD
R_DhcpEnumSubnetElementsV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) ;


DWORD
R_DhcpRemoveSubnetElementV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\scavengr.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scavengr.c

Abstract:

    This is the scavenger thread for the DHCP server.

Author:

    Madan Appiah (madana)  10-Sep-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "dhcppch.h"
#include "mdhcpsrv.h"

//
// For every few records, release and take the lock.
//
DWORD DhcpGlobalLockedRecordsCount = 50;
//
// Stop scavenging if it takes over limit.
//
DWORD DhcpGlobalMaxScavengeTime = 3*60*1000;

DWORD DhcpGlobalScavengeStartAddress = 0;

DWORD
QueryMibInfo(
    LPDHCP_MIB_INFO *MibInfo
);

DWORD
QueryMCastMibInfo(
    LPDHCP_MCAST_MIB_INFO *MibInfo
);

DWORD
NextEventTime(
    LPDHCP_TIMER Timers,
    DWORD NumTimers,
    LPDWORD TimeOut
    )
/*++

Routine Description:

    This function walks through the timer array and returns the next
    timer to fire and the time in msecs to go.

Arguments:

    Timers - Timer Array.

    NumTimers - number of timer blocks in the above array.

    TimeOut - timeout in secs, returned.

Return Value:

    Next Timer ID to fire.

--*/
{
    DATE_TIME LocalTimeOut;
    DATE_TIME TimeNow;
    ULONGLONG NextFire = ~0;
    DWORD EventID, i;

    for ( i = EventID = 0 ; i < NumTimers ; i++ ) {
        ULONGLONG CurrentNextFire;

        //
        // findout time when need to fire this timer.
        //

        CurrentNextFire = ( *(ULONGLONG UNALIGNED *)&Timers[i].LastFiredTime
                            + *Timers[i].Period * (ULONGLONG)10000 );

        //
        // Find least value
        //

        if( CurrentNextFire < NextFire ) {
            NextFire = CurrentNextFire;
            EventID = i;
        }
    }


    TimeNow = DhcpGetDateTime();
    LocalTimeOut.dwLowDateTime = 0;
    LocalTimeOut.dwHighDateTime = 0;


    //
    // if the timer has already fired then we don't have to sleep
    // any further, so return timeout zero.
    //


    *TimeOut = 0 ;

    if ( CompareFileTime(
        (FILETIME *)&NextFire,
        (FILETIME *)&TimeNow ) > 0 ) {

        //
        // findout time in msecs to go still.
        //

        *(ULONGLONG UNALIGNED *)&LocalTimeOut = (
            ( *(ULONGLONG UNALIGNED *)&NextFire - *(ULONGLONG UNALIGNED *)&TimeNow ) / 10000
        ) ;

        DhcpAssert( LocalTimeOut.dwHighDateTime == 0 );
        *TimeOut = LocalTimeOut.dwLowDateTime;
    }

    DhcpPrint(( DEBUG_SCAVENGER,"Next Timer Event: %ld, Time: %ld (msecs)\n",
                EventID, *TimeOut ));

    return EventID;
}

DWORD
CleanupClientRequests(                                 // removes all pending client requests
    IN      DATE_TIME*             TimeNow,            // remove iff client's expiration time < TimeNow
    IN      BOOL                   CleanupAll
)
{
    DWORD                          Error;
    DATE_TIME                      ZeroTime = {0, 0};

    //
    // Acquire a write RW lock so all worker threads are blocked.
    // This is needed to avoid a deadlock between worker threads
    // and the scavenger.
    //

    DhcpAcquireWriteLock();
    LOCK_INPROGRESS_LIST();
    Error = DhcpDeleteExpiredCtxt( CleanupAll ? ZeroTime : *TimeNow );
    UNLOCK_INPROGRESS_LIST();
    DhcpReleaseWriteLock();

    return Error;
}

VOID
DynBootpCallback(
    IN      ULONG                  IpAddress,
    IN      LPBYTE                 HwAddr,
    IN      ULONG                  HwLen,
    IN      BOOL                   Reachable
)
{
    ULONG                          Error;
    ULONG                          HwLen1 = 0, SubnetAddr;
    LPBYTE                         HwAddr1 = NULL;
    ULONG                          HwType;
    
    if( Reachable ) {
        //
        // This machine is still around, do not delete it
        //
        DhcpPrint((DEBUG_PING, "DynBootpCallback for 0x%08lx -- machine is reachable\n", IpAddress));
        return;
    }

    LOCK_DATABASE();
    do {
        Error = DhcpJetOpenKey(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
            (PVOID)&IpAddress,
            sizeof(IpAddress)
            );
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "DynBootpCallback for 0x%08lx erred 0x%lx\n", IpAddress, Error ));
            break;
        }

        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
            &HwAddr1,
            &HwLen1
            );
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "DynBootpCallback for 0x%08lx erred in hw check 0x%lx\n", IpAddress, Error ));
            break;
        }

        if( HwLen1 != HwLen && 0 != memcmp( HwAddr1, HwAddr, HwLen1) ) {
            DhcpPrint((DEBUG_ERRORS, "DynBootpCallback for 0x%08lx mismatched hw addr\n", IpAddress));
            break;
        }

        Error = DhcpReleaseBootpAddress(IpAddress);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS,"DynBootpCallback for 0x%08lx failed releasebootaddress: %lx\n",
                       IpAddress, Error));
            break;
        }

        Error = DhcpJetBeginTransaction();
        if( ERROR_SUCCESS != Error ) {
            DhcpAssert(FALSE);
            break;
        }

        //
        // Give DynDNS a chance but ignore any possible errors
        //

        Error = DhcpDoDynDnsCheckDelete(IpAddress);
        Error = ERROR_SUCCESS;

        Error = DhcpJetDeleteCurrentRecord();

        if( ERROR_SUCCESS != Error ) {
            Error = DhcpJetRollBack();
            DhcpAssert(ERROR_SUCCESS == Error);
            break;
        } else {
            Error = DhcpJetCommitTransaction();
        }
        DhcpAssert(ERROR_SUCCESS == Error);

        DhcpUpdateAuditLog(
            DHCP_IP_BOOTP_LOG_DELETED,
            GETSTRING(DHCP_IP_BOOTP_LOG_DELETED_NAME),
            IpAddress,
            HwAddr,
            HwLen,
            NULL
            );
        SubnetAddr = (
            DhcpGetSubnetMaskForAddress(IpAddress) & IpAddress
            );
        if( HwLen > sizeof(SubnetAddr) &&
            0 == memcmp((PVOID)&SubnetAddr, HwAddr, sizeof(SubnetAddr) ) ) {
            //
            // Hardware address has a prefix of subnet-address.. remove it..
            //
            HwAddr += sizeof(SubnetAddr);
            HwLen -= sizeof(SubnetAddr);
        }
        
        if( HwLen ) {
            HwLen --;
            HwType = *HwAddr ++;
        } else {
            HwAddr = NULL;
            HwLen = 0;
            HwType = 0;
        }

        CALLOUT_DELETED(IpAddress, HwAddr, HwLen, HwType);

    } while ( 0 );

    UNLOCK_DATABASE();
    if( HwAddr1 ) MIDL_user_free(HwAddr1);
}

DWORD
DoIcmpRequestForDynBootp(
    IN      ULONG                  IpAddress,
    IN      LPBYTE                 HwAddr,
    IN      ULONG                  HwLen,
    IN      VOID                   (*Callback) ( ULONG IpAddress, LPBYTE HwAddr, ULONG HwLen, BOOL Reachable)
);

DWORD
CheckDynamicBootpClient(
    IN      DHCP_IP_ADDRESS        IpAddress
)
{
    DWORD                          Error;
    LPBYTE                         HwAddr = NULL;
    ULONG                          HwLen = 0;

    //
    // First read the hw-address for later use
    //

    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
        &HwAddr,
        &HwLen
        );
    if( ERROR_SUCCESS != Error ) return Error;

    //
    // Now make the Asycn Ping call and wait till ping succeeds..
    //
    Error = DoIcmpRequestForDynBootp(
        IpAddress,
        HwAddr,
        HwLen,
        DynBootpCallback
        );

    if( HwAddr ) MIDL_user_free( HwAddr );
    return Error;
}

DWORD
CleanupIpDatabase(
    IN      DATE_TIME*             TimeNow,            // current time standard
    IN      DATE_TIME*             DoomTime,           // Time when the records become 'doom'
    IN      BOOL                   DeleteExpiredLeases,// expired leases be deleted right away? or just set state="doomed"
    OUT     ULONG*                 nExpiredLeases,
    OUT     ULONG*                 nDeletedLeases
)
{
    JET_ERR                        JetError;
    DWORD                          Error;
    FILETIME                       leaseExpires;
    DWORD                          dataSize;
    LPBYTE                         HwAddr = NULL, HwAddr2;
    ULONG                          HwLen = 0;
    DHCP_IP_ADDRESS                ipAddress, SubnetAddr;
    DHCP_IP_ADDRESS                NextIpAddress;
    BYTE                           AddressState;
    BOOL                           DatabaseLocked = FALSE;
    BOOL                           RegistryLocked = FALSE;
    DWORD                          i;
    BYTE                            bAllowedClientTypes;
    DWORD                          ReturnError = ERROR_SUCCESS;
    ULONG                          LockedCount = 0;
    ULONG_PTR                      ScavengeEndTime = 0;

    DhcpPrint(( DEBUG_MISC, "Cleaning up IP database table.\n"));
    //
    // Get the first user record's IpAddress.
    //

    (*nDeletedLeases) = (*nExpiredLeases) = 0;

    LockedCount = DhcpGlobalLockedRecordsCount;
    ScavengeEndTime = time(NULL) + DhcpGlobalMaxScavengeTime;
   
    LOCK_DATABASE();
    DatabaseLocked = TRUE;
    Error = DhcpJetPrepareSearch(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        TRUE,   // Search from start
        NULL,
        0
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    dataSize = sizeof( NextIpAddress );
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
        &NextIpAddress,
        &dataSize
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;
    DhcpAssert( dataSize == sizeof( NextIpAddress )) ;


    //
    // Start from where we left off ..
    //
    if( DeleteExpiredLeases ) {
        DhcpGlobalScavengeStartAddress = 0;
    } else if( 0 != DhcpGlobalScavengeStartAddress ) {
        NextIpAddress = DhcpGlobalScavengeStartAddress;
        DhcpGlobalScavengeStartAddress ++;
    }
        
    //
    // Walk through the entire database looking for expired leases to
    // free up.
    //
    //

    for ( ;; ) {

        //
        // return to caller when the service is shutting down.
        //

        if ( DhcpGlobalServiceStopping ) {
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }

        //
        // lock both registry and database locks here to avoid dead lock.
        //

        if( !DatabaseLocked ) {
            LOCK_DATABASE();
            DatabaseLocked = TRUE;
        }

        //
        // Seek to the next record.
        //

        JetError = JetSetCurrentIndex(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColName
        );

        Error = DhcpMapJetError( JetError, "Cleanup:SetCurrentIndex" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        JetError = JetMakeKey(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            &NextIpAddress,
            sizeof( NextIpAddress ),
            JET_bitNewKey
        );

        Error = DhcpMapJetError( JetError, "Cleanup:MakeKey" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        // Seek to the next record or greater to process. When we
        // processed last record we noted down the next record to
        // process, however the next record may have been deleted when
        // we unlocked the database lock. So moving to the next or
        // greater record will make us to move forward.

        JetError = JetSeek(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            JET_bitSeekGE
        );

        // #if0 when JET_errNoCurrentRecord removed (see scavengr.c@v25);
        // that code tried to go back to start of file when scanned everything.

        Error = DhcpMapJetError( JetError, "Cleanup:Seek" );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // read the IP address of current record.
        //

        dataSize = sizeof( ipAddress );
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
            &ipAddress,
            &dataSize
        );
        if( Error != ERROR_SUCCESS ) {
            goto ContinueError;
        }

        if( FALSE == DeleteExpiredLeases ) {
            DhcpGlobalScavengeStartAddress = ipAddress;
        }
        
        DhcpAssert( dataSize == sizeof( ipAddress )) ;

        //
        // if this is reserved entry don't delete.
        //

        if( DhcpServerIsAddressReserved(DhcpGetCurrentServer(), ipAddress) ) {
            Error = ERROR_SUCCESS;
            goto ContinueError;
        }

        dataSize = sizeof( leaseExpires );
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
            &leaseExpires,
            &dataSize
        );

        if( Error != ERROR_SUCCESS ) {
            goto ContinueError;
        }

        DhcpAssert(dataSize == sizeof( leaseExpires ) );

        // Now get the address state, and if we need to do a DhcpDnsAsync call,
        // do it now.
        if( !USE_NO_DNS ) {
            dataSize = sizeof(AddressState);
            Error = DhcpJetGetValue(
                DhcpGlobalClientTable[STATE_INDEX].ColHandle,
                &AddressState,
                &dataSize
            );
            if(ERROR_SUCCESS != Error) {
                DhcpPrint((DEBUG_ERRORS, "Could not get address state!: Jet:%ld\n",Error));
                DhcpAssert(FALSE);
            } else {
		BOOL Deleted;
                Error = DhcpJetBeginTransaction();

                if( ERROR_SUCCESS == Error ) {
                    if(IsAddressDeleted(AddressState)) {
			Deleted = DhcpDoDynDnsCheckDelete( ipAddress );
                        if( Deleted ) {
                            Error = DhcpJetDeleteCurrentRecord();
			    
			    if ( ERROR_SUCCESS == Error ) {
				Error = DhcpJetCommitTransaction();
				(*nDeletedLeases)++;
			    }
			    else {
				Error = DhcpJetRollBack();
			    }

        		    if ( Deleted ) {
				DhcpUpdateAuditLog( DHCP_IP_LOG_DELETED,
						    GETSTRING( DHCP_IP_LOG_DELETED_NAME ),
						    ipAddress, NULL, 0, NULL );
			    }
			    else {
				DhcpUpdateAuditLog( DHCP_IP_LOG_DNS_NOT_DELETED,
						    GETSTRING( DHCP_IP_LOG_DNS_NOT_DELETED_NAME ),
						    ipAddress, NULL, 0, NULL );
			    }
			    
	                    goto ContinueError;
                        }
                    } else if(IsAddressUnRegistered(AddressState)) {
                        DhcpDoDynDnsRefresh(ipAddress);
                    }

                    Error = DhcpJetCommitTransaction();

                    if( ERROR_SUCCESS != Error ) {
                        DhcpPrint((DEBUG_ERRORS, "JetCommit: %ld\n", Error));
                    }
                } // if begin transaction
            } // else
        } // if !USE_NO_DNS

        // if the LeaseExpired value is not zero and the lease has
        // expired then delete the entry.

        if( CompareFileTime( &leaseExpires, (FILETIME *)TimeNow ) < 0 ) {
            BOOL Deleted;

            //
            // This lease has expired.  Clear the record.
            //

            //
            // Delete this lease if
            //
            //  1. we are asked to delete all expired leases. or
            //
            //  2. the record passed doom time.
            //

            if( DeleteExpiredLeases ||
                    CompareFileTime(
                        &leaseExpires, (FILETIME *)DoomTime ) < 0 ) {
                BYTE ClientType;

                DhcpPrint(( DEBUG_SCAVENGER, "Deleting Client Record %s.\n",
                    DhcpIpAddressToDottedString(ipAddress) ));

                dataSize = sizeof(ClientType);
                Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[CLIENT_TYPE_INDEX].ColHandle,
                    &ClientType,
                    &dataSize
                    );
                if( ERROR_SUCCESS != Error ) {
                    //
                    //
                    //
                    DhcpAssert(FALSE);
                    ClientType = CLIENT_TYPE_DHCP;
                }

                if( CLIENT_TYPE_BOOTP == ClientType ) {
                    //
                    // This is a dynamic BOOTP record... Do not delete it yet!
                    //
                    Error = CheckDynamicBootpClient(ipAddress);
                    goto ContinueError;
                }

                Error = DhcpReleaseAddress( ipAddress );

                if( Error != ERROR_SUCCESS ) {
                    //
                    // Release address can fail if we have already released
                    // address, but dyndns is pending, for instance..
                    // But give one shot by trying to release it as a
                    // BOOTP address..
                    // goto ContinueError;
                    (void)DhcpReleaseBootpAddress( ipAddress );
                    Error = ERROR_SUCCESS;
                }

                HwLen = 0; HwAddr = NULL;
                JetError = DhcpJetGetValue(
                    DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
                    &HwAddr,
                    &HwLen
                );
                if( ERROR_SUCCESS != JetError ) goto ContinueError;

                Error = DhcpJetBeginTransaction();

                if( Error != ERROR_SUCCESS ) {
                    goto Cleanup;
                }
                
                // see if it is okay to delete from DynDns point of view..
                
                Deleted = DhcpDoDynDnsCheckDelete(ipAddress);
		
		Error = DhcpJetDeleteCurrentRecord();
		if ( ERROR_SUCCESS == Error ) {
		    Error = DhcpJetCommitTransaction();
		    (*nDeletedLeases)++;
		}
		else {
		    Error = DhcpJetRollBack();
		    goto ContinueError;
		}

		if ( Deleted ) {
		    DhcpUpdateAuditLog( DHCP_IP_LOG_DELETED,
					GETSTRING( DHCP_IP_LOG_DELETED_NAME ),
					ipAddress, NULL, 0, NULL );
		}
		else {
		    DhcpUpdateAuditLog( DHCP_IP_LOG_DNS_NOT_DELETED,
					GETSTRING( DHCP_IP_LOG_DNS_NOT_DELETED_NAME ),
					ipAddress, NULL, 0, NULL );
		}

                SubnetAddr = (
                    DhcpGetSubnetMaskForAddress(ipAddress) & ipAddress
                    );
                if( HwLen > sizeof(SubnetAddr) &&
                    0 == memcmp((PVOID)&SubnetAddr, HwAddr, sizeof(SubnetAddr) )) {
                    HwAddr2 = HwAddr + sizeof(SubnetAddr);
                    HwLen -= sizeof(SubnetAddr);
                } else {
                    HwAddr2 = HwAddr;
                }
                
                CALLOUT_DELETED(ipAddress, HwAddr2, HwLen, 0);
                if( HwAddr ) DhcpFreeMemory(HwAddr);
                HwAddr = NULL;
                HwLen = 0;
            } // if delete expired leases || ...
            else {

                //
                // read address State.
                //

                dataSize = sizeof( AddressState );
                Error = DhcpJetGetValue(
                            DhcpGlobalClientTable[STATE_INDEX].ColHandle,
                            &AddressState,
                            &dataSize );

                if( Error != ERROR_SUCCESS ) {
                    goto ContinueError;
                }

                DhcpAssert( dataSize == sizeof( AddressState )) ;

                if( ! IS_ADDRESS_STATE_DOOMED(AddressState) ) {
                    //
                    // set state to DOOM.
                    //

                    Error = DhcpJetBeginTransaction();

                    if( Error != ERROR_SUCCESS ) {
                        goto Cleanup;
                    }

                    JetError = JetPrepareUpdate(
                                    DhcpGlobalJetServerSession,
                                    DhcpGlobalClientTableHandle,
                                    JET_prepReplace );

                    Error = DhcpMapJetError( JetError, "Cleanup:PrepareUpdate" );

                    if( Error == ERROR_SUCCESS ) {

                        SetAddressStateDoomed(AddressState);
                        Error = DhcpJetSetValue(
                                    DhcpGlobalClientTable[STATE_INDEX].ColHandle,
                                    &AddressState,
                                    sizeof(AddressState) );

                        if( Error == ERROR_SUCCESS ) {
                            Error = DhcpJetCommitUpdate();
                        }
                    }

                    if( Error != ERROR_SUCCESS ) {

                        Error = DhcpJetRollBack();
                        if( Error != ERROR_SUCCESS ) {
                            goto Cleanup;
                        }

                        goto ContinueError;
                    }

                    Error = DhcpJetCommitTransaction();

                    if( Error != ERROR_SUCCESS ) {
                        goto Cleanup;
                    }

                    DhcpUpdateAuditLog(
                        DHCP_IP_LOG_EXPIRED,
                        GETSTRING( DHCP_IP_LOG_EXPIRED_NAME),
                        ipAddress,
                        NULL,
                        0,
                        NULL
                    );
                } // if not address state doomed
            } // else 
        } // if comparefiletime ....

ContinueError:

        if( NULL != HwAddr ) {
            DhcpFreeMemory(HwAddr);
            HwAddr = NULL; HwLen = 0;
        }

        if( Error != ERROR_SUCCESS ) {

            DhcpPrint(( DEBUG_ERRORS,
                "Cleanup current database record failed, %ld.\n",
                    Error ));

            ReturnError = Error;
        }

        Error = DhcpJetNextRecord();

        if( Error == ERROR_NO_MORE_ITEMS ) {
            if( FALSE == DeleteExpiredLeases ) {
                DhcpGlobalScavengeStartAddress = 0;
            }
            Error = ERROR_SUCCESS;
            break;
        }

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // get next record Ip Address.
        //

        dataSize = sizeof( NextIpAddress );
        Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                    &NextIpAddress,
                    &dataSize );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        } 

        if( FALSE == DeleteExpiredLeases ) {
            DhcpGlobalScavengeStartAddress = NextIpAddress;
        }

        DhcpAssert( dataSize == sizeof( NextIpAddress )) ;

        //
        // unlock the registry and database locks after each user record
        // processed, so that other threads will get chance to look into
        // the registry and/or database.
        //
        // Since we have noted down the next user record to process,
        // when we resume to process again we know where to start.
        //

        //
        // Unlocking/locking for every record is expensive.  Do this once
        // in a while.  Also, make sure we don't spend too much time scavenging.
        //
        
        if( DatabaseLocked ) {
            LockedCount --;
            if( 0 == LockedCount ) {
                UNLOCK_DATABASE();
                DatabaseLocked = FALSE;
                LockedCount = DhcpGlobalLockedRecordsCount;
            }
            if( FALSE == DeleteExpiredLeases ) {
                if( (ULONG_PTR)time(NULL) >= ScavengeEndTime ) {
                    //
                    // No more scavenging..
                    //
                    goto Cleanup;
                }
            }
        } // if database locked
    } // for ;;

    DhcpAssert( Error == ERROR_SUCCESS );

Cleanup:

    if( NULL != HwAddr ) {
        DhcpFreeMemory(HwAddr);
        HwAddr = NULL; HwLen = 0;
    }

    if( DatabaseLocked ) {
        UNLOCK_DATABASE();
    }

    return ReturnError;
}

DWORD
AuditIPAddressUsage()
{
    DWORD                           Error;
    LPDHCP_MIB_INFO                 MibInfo;
    LPSCOPE_MIB_INFO                ScopeInfo;
    DWORD                           i;

    MibInfo = NULL;

    Error = QueryMibInfo( &MibInfo );
    if ( Error != ERROR_SUCCESS ) {
        return Error;
    }

    for ( i = 0, ScopeInfo = MibInfo->ScopeInfo;
          i < MibInfo->Scopes;
          i++, ScopeInfo++ ) {

        IN_ADDR addr;
        DWORD percentage;

        //
        // be careful about divide-by-zero errors.
        //

        if ( ScopeInfo->NumAddressesInuse == 0 &&
                 ScopeInfo->NumAddressesFree == 0 ) {
            continue;
        }

        addr.s_addr = htonl(ScopeInfo->Subnet);

        percentage =
            ( 100 * ScopeInfo->NumAddressesInuse ) /
                (ScopeInfo->NumAddressesInuse + ScopeInfo->NumAddressesFree);

        if ( percentage > DhcpGlobalAlertPercentage &&
                ScopeInfo->NumAddressesFree < DhcpGlobalAlertCount ) {

            LPSTR Strings[3];
            BYTE percentageString[8];
            BYTE remainingString[8];

            _ltoa( percentage, percentageString, 10 );
            _ltoa( ScopeInfo->NumAddressesFree, remainingString, 10 );

            Strings[0] = inet_ntoa( addr );
            Strings[1] = percentageString;
            Strings[2] = remainingString;

            DhcpReportEventA(
                DHCP_EVENT_SERVER,
                EVENT_SERVER_LOW_ADDRESS_WARNING,
                EVENTLOG_WARNING_TYPE,
                3,
                0,
                Strings,
                NULL
                );
        }
    }

    if( MibInfo->ScopeInfo ) MIDL_user_free( MibInfo->ScopeInfo );
    MIDL_user_free( MibInfo );

    return Error;
}

DWORD
AuditMCastAddressUsage()
{
    DWORD                               Error;
    LPDHCP_MCAST_MIB_INFO                MCastMibInfo;
    LPMSCOPE_MIB_INFO                   ScopeInfo;
    DWORD                           i;

    MCastMibInfo = NULL;

    Error = QueryMCastMibInfo( &MCastMibInfo );
    if ( Error != ERROR_SUCCESS ) {
        return Error;
    }

    for ( i = 0, ScopeInfo = MCastMibInfo->ScopeInfo;
          i < MCastMibInfo->Scopes;
          i++, ScopeInfo++ ) {

        IN_ADDR addr;
        DWORD percentage;

        //
        // be careful about divide-by-zero errors.
        //

        if ( ScopeInfo->NumAddressesInuse == 0 &&
                 ScopeInfo->NumAddressesFree == 0 ) {
            continue;
        }

        percentage =
            ( 100 * ScopeInfo->NumAddressesInuse ) /
                (ScopeInfo->NumAddressesInuse + ScopeInfo->NumAddressesFree);

        if ( percentage > DhcpGlobalAlertPercentage &&
                ScopeInfo->NumAddressesFree < DhcpGlobalAlertCount ) {

            LPSTR Strings[3];
            BYTE percentageString[8];
            BYTE remainingString[8];
            CHAR MScopeNameOem[256];

            _ltoa( percentage, percentageString, 10 );
            _ltoa( ScopeInfo->NumAddressesFree, remainingString, 10 );
            Strings[0] = DhcpUnicodeToOem( ScopeInfo->MScopeName, MScopeNameOem  );
            Strings[1] = percentageString;
            Strings[2] = remainingString;

            DhcpReportEventA(
                DHCP_EVENT_SERVER,
                EVENT_SERVER_LOW_ADDRESS_WARNING,
                EVENTLOG_WARNING_TYPE,
                3,
                0,
                Strings,
                NULL
                );
        }
    }

    if(MCastMibInfo->ScopeInfo) MIDL_user_free( MCastMibInfo->ScopeInfo );
    MIDL_user_free( MCastMibInfo );

    return ERROR_SUCCESS;
}

VOID
LogScavengeStats(
    IN ULONG EventId,
    IN ULONG nExpiredLeases,
    IN ULONG nDeletedLeases
    )
{
    DWORD Error;
    LPWSTR Msg;
    DWORD  Len;

    Len = wcslen( GETSTRING( DHCP_IP_LOG_SCAVENGER_STATS_NAME ));
    Len += 12 + 12; // 12 bytes each for integers
    Len *= sizeof( WCHAR );

    Msg = DhcpAllocateMemory( Len );
    if ( NULL == Msg ) {
	return;
    }

    _snwprintf( Msg, ( Len - 1 ) / 2, GETSTRING( DHCP_IP_LOG_SCAVENGER_STATS_NAME ),
		nExpiredLeases, nDeletedLeases );
    DhcpUpdateAuditLog( DHCP_IP_LOG_SCAVENGER_STATS,
			Msg, 0, NULL, 0, NULL );

    DhcpFreeMemory( Msg );

    return;    
} // LogScavengeStats()

DWORD
CleanupDatabase(                                       // tidies up the database by removing expired leases
    IN      DATE_TIME*             TimeNow,            // current time standard
    IN      BOOL                   DeleteExpiredLeases // expired leases be deleted right away? or just set state="doomed"
)
{
    DWORD                          Error;
    HANDLE                         ThreadHandle;
    BOOL                           BoolError;
    DWORD                          ReturnError = ERROR_SUCCESS;
    DATE_TIME                      DoomTime;
    ULONG                          ExpiredLeases, DeletedLeases;
    
    DhcpPrint(( DEBUG_MISC, "Database Cleanup started.\n"));

    //
    // reduce the priority of this thread when we perform the database
    // cleanup. So that we wouldn't hog the CPU when we do the cleanup
    // of big database. Also let the message processing thread work
    // faster.
    //

    ThreadHandle = GetCurrentThread();
    BoolError = SetThreadPriority(
        ThreadHandle,
        THREAD_PRIORITY_BELOW_NORMAL
    );
    DhcpAssert( BoolError );

    *(ULONGLONG UNALIGNED *)&DoomTime =
            *(ULONGLONG UNALIGNED *)TimeNow -
                DhcpLeaseExtension * (ULONGLONG)10000000;
    
    // replace this with auditlog message

    DhcpUpdateAuditLog( DHCP_IP_LOG_SCAVENGER_BEGIN_CLEANUP,
			GETSTRING( DHCP_IP_LOG_SCAVENGER_BEGIN_CLEANUP_NAME ),
			0, NULL, 0, NULL );
    
    Error = CleanupIpDatabase(
        TimeNow,&DoomTime,DeleteExpiredLeases,
        &ExpiredLeases, &DeletedLeases
        );

    LogScavengeStats(
        EVENT_SERVER_IPCLEANUP_FINISHED,
        ExpiredLeases, DeletedLeases
        );

    if( Error != ERROR_SUCCESS ) ReturnError = Error;

    Error = CleanupMCastDatabase(
        TimeNow,&DoomTime,DeleteExpiredLeases,
        &ExpiredLeases, &DeletedLeases
        );
    if( Error != ERROR_SUCCESS ) ReturnError = Error;

    LogScavengeStats(
        EVENT_SERVER_MCASTCLEANUP_FINISHED,
        ExpiredLeases, DeletedLeases
        );
    
    // database is successfully cleanup, backup the database and the
    // registry now.
    // backup the registry now.
    Error = DhcpBackupConfiguration( DhcpGlobalBackupConfigFileName );

    if( Error != ERROR_SUCCESS ) {
        DhcpServerEventLog(
            EVENT_SERVER_CONFIG_BACKUP,
            EVENTLOG_ERROR_TYPE,
            Error );
        DhcpPrint(( DEBUG_ERRORS,"DhcpBackupConfiguration failed, %ld.\n", Error ));
        ReturnError = Error;
    }

    //
    // perform full database backup now.
    //

    Error = DhcpBackupDatabase( DhcpGlobalOemJetBackupPath );
    if( Error != ERROR_SUCCESS ) {

        DhcpServerEventLog(
            EVENT_SERVER_DATABASE_BACKUP,
            EVENTLOG_ERROR_TYPE,
            Error );

        DhcpPrint(( DEBUG_ERRORS,
            "DhcpBackupDatabase failed, %ld.\n", Error ));

        ReturnError = Error;
    }

    // now perform the ipaddress usage and warn the admin if neccessary.
    AuditIPAddressUsage();
    AuditMCastAddressUsage();


Cleanup:


    //
    // Reset the thread priority.
    //

    BoolError = SetThreadPriority(
                    ThreadHandle,
                    THREAD_PRIORITY_NORMAL );

    DhcpAssert( BoolError );

    if( Error == ERROR_SUCCESS ) {
        Error = ReturnError;
    }

    if( (Error != ERROR_SUCCESS) && (Error != ERROR_NO_MORE_ITEMS) ) {

        DhcpServerEventLog(
            EVENT_SERVER_DATABASE_CLEANUP,
            EVENTLOG_ERROR_TYPE,
            Error );

        DhcpPrint(( DEBUG_ERRORS, "Database Cleanup failed, %ld.\n", Error ));

    }
    else  {
        DhcpPrint(( DEBUG_MISC,
            "Database Cleanup finished successfully.\n" ));
    }

    return( ReturnError );
}

DWORD
Scavenger(
    VOID
    )
/*++

Routine Description:

    This function runs as an independant thread.  It periodically wakes
    up to free expired leases.

Arguments:

    None.

Return Value:

    None.

--*/
{

#define CORE_SCAVENGER      0
#define DATABASE_BACKUP     1
#define DATABASE_CLEANUP    2
#define SCAVENGE_IP_ADDRESS 3

#define TIMERS_COUNT        4

    DWORD Error;
    DWORD result;
    DATE_TIME TimeNow;
    BOOL MidNightCleanup = TRUE;
    BOOL ScavengedOutOfTurn = FALSE;
    DHCP_TIMER Timers[TIMERS_COUNT];
    ULONG NextFireForRogue, Now;

    SYSTEMTIME LocalTime;

    DWORD DisableRogueDetection = 0;

#define TERMINATE_EVENT             0
#define ROGUE_DETECT_EVENT          1
#define TIMER_RECOMPUTE_EVENT       2

#define EVENT_COUNT                 3

    HANDLE WaitHandle[EVENT_COUNT];

    //
    // Initialize timers.
    //

    TimeNow = DhcpGetDateTime();
    Timers[CORE_SCAVENGER].Period = &DhcpGlobalScavengerTimeout;
    Timers[CORE_SCAVENGER].LastFiredTime = TimeNow;

    Timers[DATABASE_BACKUP].Period = &DhcpGlobalBackupInterval;
    Timers[DATABASE_BACKUP].LastFiredTime = TimeNow;

    Timers[DATABASE_CLEANUP].Period = &DhcpGlobalCleanupInterval;
    Timers[DATABASE_CLEANUP].LastFiredTime = TimeNow;

    Timers[SCAVENGE_IP_ADDRESS].Period = &DhcpGlobalScavengeIpAddressInterval;
    Timers[SCAVENGE_IP_ADDRESS].LastFiredTime = TimeNow;

    DhcpAssert( DhcpGlobalRecomputeTimerEvent != NULL );
    WaitHandle[TIMER_RECOMPUTE_EVENT] = DhcpGlobalRecomputeTimerEvent;
    WaitHandle[TERMINATE_EVENT] = DhcpGlobalProcessTerminationEvent;
    WaitHandle[ROGUE_DETECT_EVENT] = DhcpGlobalRogueWaitEvent;

    // Check to see if rogue detection is needed    
    Error = DhcpRegGetValue( DhcpGlobalRegParam,
			     DHCP_DISABLE_ROGUE_DETECTION,
			     DHCP_DISABLE_ROGUE_DETECTION_TYPE,
			     ( LPBYTE ) &DisableRogueDetection
			     );
    if (( ERROR_SUCCESS == Error ) &&
	( 0 != DisableRogueDetection )) {
	DisableRogueDetection = 1;
    } // if 


    NextFireForRogue = RogueDetectStateMachine(NULL);
    if( INFINITE != NextFireForRogue ) NextFireForRogue += (ULONG) time(NULL);

    while (1) {

        DWORD TimeOut;
        DWORD EventID;

        EventID = NextEventTime( Timers, TIMERS_COUNT, &TimeOut );


	do {

	    //
	    // If wait forever for rogue stuff, don't alter timeout
	    //

	    if( INFINITE == NextFireForRogue ) break;

	    //
	    // If the rogue state should have changed already, re-schedule
	    //

	    if( (Now = (ULONG)time(NULL)) >= NextFireForRogue ) {
		NextFireForRogue = RogueDetectStateMachine(NULL);
		if( INFINITE != NextFireForRogue ) {
		    NextFireForRogue += (Now = (ULONG)time(NULL));
		} else {
		    //
		    // INFINITE sleep?  timeout won't change
		    //
		    break;
		} // else
	    } // if

	    //
	    // Wakeup at the earliest of rogue-state-change or normal timeout
	    //

	    if( (NextFireForRogue - Now)*1000 < TimeOut ) {
		TimeOut = (NextFireForRogue - Now)*1000;
	    }

	} while ( 0 );

	DhcpPrint( ( DEBUG_SCAVENGER,
		     "Waiting for %d seconds.\n",
		     TimeOut / 1000 )
		   );

	if( INFINITE == NextFireForRogue ) {
	    //
	    // INFINITE wait is used to indicate network is not ready.
	    // Wait on NetworkReady event rather than RogueWait event.
	    //
	    WaitHandle[ROGUE_DETECT_EVENT] = DhcpGlobalEndpointReadyEvent;
	} else {
	    WaitHandle[ROGUE_DETECT_EVENT] = DhcpGlobalRogueWaitEvent;
	}

	if ( DisableRogueDetection ) {
	    WaitHandle[ ROGUE_DETECT_EVENT ] = DhcpGlobalRogueWaitEvent;
	}

        DhcpDnsHandleCallbacks();

        result = WaitForMultipleObjectsEx(
                    EVENT_COUNT,            // num. of handles.
                    WaitHandle,             // handle array.
                    FALSE,                  // wait for any.
                    TimeOut,                // timeout in msecs.
                    TRUE );                 // alertable

        switch( result ) {
        case WAIT_IO_COMPLETION:
            // IoCompletion routine is called ( for the winsock pnp notifications )
            break;

        case TERMINATE_EVENT:
            //
            // the service is asked to stop, return to main.
            //

            return( ERROR_SUCCESS );

        case TIMER_RECOMPUTE_EVENT:

            break;

        case ROGUE_DETECT_EVENT:
	    //
	    // Fire another step in state machine.
	    //
	    NextFireForRogue = RogueDetectStateMachine(NULL);
	    if( INFINITE != NextFireForRogue ) {
		NextFireForRogue += (ULONG) time(NULL);
	    }

            //
            // Rogue event could be either RogueWaitEvent or
            // EndpointReadyEvent. Reset accordingly.
            ResetEvent( WaitHandle[ ROGUE_DETECT_EVENT ]);
            break;

        case WAIT_TIMEOUT:


	    if( INFINITE != NextFireForRogue && (ULONG)time(NULL) >= NextFireForRogue ) {
		//
		// GO To top of WHILE loop -- need to fire another step in state machine.
		//
		continue;
	    }


            TimeNow = DhcpGetDateTime();
            switch (EventID ) {

            case CORE_SCAVENGER :

                //
                // Cleanup client requests that are never committed.
                //

                Error = CleanupClientRequests( &TimeNow, FALSE );

                //
                // Expire multicast scopes
                //

                DeleteExpiredMcastScopes(&TimeNow);


                //
                // is it time to do mid-night database cleanup ?
                //

                GetLocalTime( &LocalTime );
                if ( LocalTime.wHour == 0 ) {

                    //
                    // change audit logs if required...
                    //

                    DhcpChangeAuditLogs();

                    //
                    // did we do this cleanup before ?
                    //

                    if( MidNightCleanup == TRUE ) {

                        Error = CleanupDatabase( &TimeNow, FALSE );
                        MidNightCleanup = FALSE;
                    }
                }
                else {

                    //
                    // set the mid-night flag again.
                    //

                    MidNightCleanup = TRUE;
                }

                if( ! DhcpGlobalScavengeIpAddress ) {
                    //
                    // don't need to scavenge Ip address away..
                    //
                    break;
                }

                if( ScavengedOutOfTurn ) {
                    // already done once out of turn.. don't do anymore..
                    break;
                }

                ScavengedOutOfTurn = TRUE;

                // FALL THROUGH AND SCAVENGE IF NEEDED

            case SCAVENGE_IP_ADDRESS:

                if( DhcpGlobalScavengeIpAddress ) {

                    //
                    // cleanup all expired leases too.
                    //

                    Error = CleanupDatabase( &TimeNow, TRUE );
                    DhcpGlobalScavengeIpAddress = FALSE;
                }

                if( SCAVENGE_IP_ADDRESS == EventID ) {
                    ScavengedOutOfTurn = FALSE;
                }

                break;

            case DATABASE_CLEANUP:

                Error = CleanupDatabase( &TimeNow, FALSE );
                break;

            case DATABASE_BACKUP : {

                Error = DhcpBackupConfiguration( DhcpGlobalBackupConfigFileName );

                if( Error != ERROR_SUCCESS ) {

                    DhcpServerEventLog(
                        EVENT_SERVER_CONFIG_BACKUP,
                        EVENTLOG_ERROR_TYPE,
                        Error );

                    DhcpPrint(( DEBUG_ERRORS,
                        "DhcpBackupConfiguration failed, %ld.\n", Error ));
                }

		Error = DhcpBackupDatabase( DhcpGlobalOemJetBackupPath );
                if( Error != ERROR_SUCCESS ) {

                    DhcpServerEventLog(
                        EVENT_SERVER_DATABASE_BACKUP,
                        EVENTLOG_ERROR_TYPE,
                        Error );

                    DhcpPrint(( DEBUG_ERRORS,
                        "DhcpBackupDatabase failed, %ld.\n", Error ));
                }


                break;
            } // DATABASE_BACKUP

            default:
                DhcpAssert(FALSE);
                break;
            } // switch (EventID)

            Timers[EventID].LastFiredTime = DhcpGetDateTime();
            break;

        default :

            DhcpPrint(( DEBUG_ERRORS,
                "WaitForMultipleObjects returned invalid result, %ld.\n",
                    result ));
            break;

        } // switch()
    } // while (1) 

    return( ERROR_SUCCESS );
} // Scavenger()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\scan.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scan.c

Abstract:

    This module contains the implementation for the APIs that update
    the list of IP addresses that the server can distribute.

Author:

    Madan Appiah (madana)  13-Oct-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include "dhcppch.h"
#include <mmapi.h>

#include <mdhcpsrv.h>
typedef struct _BITMAP_ENTRY {
    DHCP_IP_ADDRESS ClusterAddress;
    DWORD ClusterBitMap;
    DHCP_IP_ADDRESS RangeStartAddress;
    DHCP_IP_ADDRESS RangeEndAddress;
} BITMAP_ENTRY, *LPBITMAP_ENTRY;

DWORD
MemReserveFindByAddress(
    IN      PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    OUT     PM_RESERVATION        *Res
);


INT __cdecl
CmpReservedAddress(
    const void *Entry1,
    const void *Entry2
    )
{
    DHCP_IP_ADDRESS Ip1 = *(DHCP_IP_ADDRESS *)Entry1;
    DHCP_IP_ADDRESS Ip2 = *(DHCP_IP_ADDRESS *)Entry2;

    if( Ip1 == Ip2 ) return 0;
    if( Ip1 > Ip2 ) return 1;
    return -1;
}

INT __cdecl
CmpBitmapEntry(
    const void *Entry1,
    const void *Entry2
    )
{
    if( ((LPBITMAP_ENTRY)Entry1)->ClusterAddress ==
            ((LPBITMAP_ENTRY)Entry2)->ClusterAddress ) {
        return(0);
    }
    else if( ((LPBITMAP_ENTRY)Entry1)->ClusterAddress >
                ((LPBITMAP_ENTRY)Entry2)->ClusterAddress ) {
        return(1);
    }
    return(-1);
}

BOOL
FoundInBitMap(
    LPBITMAP_ENTRY BitMapList,
    LPBITMAP_ENTRY EndBitMapList,
    DHCP_IP_ADDRESS IpAddress,
    LPBITMAP_ENTRY *LastPointer
    )
/*++

Routine Description:

    This function checks to see that a given IP address is in the
    BITMAP. if it is, returns TRUE otherwise FALSE.

Arguments:

    BitMapList - BITMAP list.

    EndBitMapList - end of bitmap list.

    IpAddress - address to look at.

    LastPointer - location where last search was found.

Return Value:

    TRUE or FALSE.
--*/
{
    //
    // begin search from last found entry.
    //

    LPBITMAP_ENTRY NextEntry = *LastPointer;
    DHCP_IP_ADDRESS Address;

    DhcpAssert( NextEntry < EndBitMapList );
    for ( ; ; ) {

        Address = NextEntry->ClusterAddress;

        //
        // check address is in the current cluster.
        //

        if( (IpAddress >= Address) &&
                (IpAddress < (Address + CLUSTER_SIZE)) ) {

            DWORD Bit = 0x1 << (IpAddress - Address);

            //
            // return current cluster for next search.
            //

            *LastPointer = NextEntry;

            if( NextEntry->ClusterBitMap & Bit ) {

                //
                // address is marked in the bitmap.
                //

                return( TRUE );
            }

            return( FALSE );
        }

        NextEntry++;
        if ( NextEntry >= EndBitMapList ) {

            //
            // move back to the begining of the cluster array.
            //

            NextEntry = BitMapList;
        }

        if( NextEntry ==  *LastPointer ) {

            //
            // we are done searching the entire cluster array.
            //

            return(FALSE);
        }
    }

    DhcpAssert( FALSE );
}

BOOL
FoundInDatabase(
    LPDHCP_IP_ADDRESS DatabaseList,
    LPDHCP_IP_ADDRESS EndDatabaseList,
    DHCP_IP_ADDRESS NextAddress,
    LPDHCP_IP_ADDRESS *LastEntry
    )
/*++

Routine Description:

    This function scans for a database entry from the database list. It
    it is found in the list it returns TRUE otherwise it returns FALSE.

Arguments:

    DatabaseList - list of database entries.

    EndDatabaseListCount - end of database entries list.

    NextAddress - lookup entry.

    LastEntry - pointer to last found entry.

Return Value:

    TRUE or FALSE.
--*/
{

    //
    // start search from next to last found entry.
    //

    LPDHCP_IP_ADDRESS NextEntry = *LastEntry;

    do {

        NextEntry++;

        if( NextEntry >= EndDatabaseList ) {

            //
            // move back to the begining of the list.
            //

            NextEntry = DatabaseList;

        }

        if( *NextEntry == NextAddress ) {

            *LastEntry = NextEntry;
            return(TRUE);
        }

    } while ( NextEntry != *LastEntry );


    return(FALSE);
}

BOOL
FindNextAddress(
    LPBITMAP_ENTRY *NextCluster,
    DHCP_IP_ADDRESS *NextAddress,
    LPBITMAP_ENTRY EndBitMapList
    )
/*++

Routine Description:

    This function returns next used address from the bit map.

Arguments:

    NextCluster - pointer to next cluster entry pointer.

    NextAddress - pointer to an address location. on entry it contains
        the last returned address and on exit it will have next address.
        It is set to zero if this is begining of the serach.

    EndBitMapList - end of BitMap list.

Return Value:

    TRUE or FALSE.

--*/
{
    DHCP_IP_ADDRESS Address;
    LPBITMAP_ENTRY Cluster = *NextCluster;

    //
    // if this is start of the address search, set the address to
    // the first cluster address.
    //

    if( *NextAddress == 0 ) {
        Address = Cluster->ClusterAddress;
    }
    else {

        //
        // otherwise search from next to last found address.
        //

        Address = *NextAddress + 1;
    }

    for ( ; ; ) {

        //
        // is this address in the current cluster ?
        //

        if( Address < Cluster->ClusterAddress + CLUSTER_SIZE ) {

            //
            // check this address is used.
            //

            if( Cluster->ClusterBitMap &
                    (0x1 << (Address - Cluster->ClusterAddress)) ) {

                if( Address <= Cluster->RangeEndAddress ) {

                    *NextAddress = Address;
                    *NextCluster = Cluster;
                    return( TRUE );
                }

            }

            Address++;
        }
        else {

            //
            // move to next cluster;
            //

            Cluster++;

            if( Cluster >= EndBitMapList ) {
                //
                // end of search.
                //

                return( FALSE );
            }

            //
            // next possible used address.
            //

            Address = Cluster->ClusterAddress;
        }
    }

    DhcpAssert( FALSE );
}


DWORD
InitBadList(
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function initialize scan list.

Arguments:

    ScanList - pointer to scan list.

Return Value:

    WINDOWS errors.
--*/
{

    DhcpAssert( *ScanList == NULL );

    //
    // make new scan list.
    //
    // Note : DhcpAllocateMemory zeros the returned memory block, so
    // (*ScanList)->NumScanItems should be set to 0 and
    // (*ScanList)->NumScanItems should be set to NULL.
    //

    *ScanList = DhcpAllocateMemory( sizeof(DHCP_SCAN_LIST) );

    if( *ScanList == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    return( ERROR_SUCCESS );
}

DWORD
AddToBadList(
    LPDHCP_SCAN_LIST *ScanList,
    DHCP_IP_ADDRESS Address,
    DHCP_SCAN_FLAG Fix
    )
/*++

Routine Description:

    This function adds another bad entry to scan list.

Arguments:

    ScanList - pointer to scan list.

    Address - bad address.

    Fix - type of fix required.

Return Value:

    WINDOWS errors.
--*/
{
    LPDHCP_SCAN_LIST List = *ScanList;
    LPDHCP_SCAN_ITEM NextItem;
    ULONG i;

#define ENTRIES_TO_ALLOCATE_ATTIME     100

    DhcpAssert( List != NULL );

    //
    // First check to see if the bad list already has this
    // address..
    //
    for( i = 0; i < List->NumScanItems ; i ++ ) {
        if( List->ScanItems[i].IpAddress == Address ) {
            //
            // Already there?  A database fix takes
            // precedence over a registr fix..
            //
            if( DhcpDatabaseFix == Fix ) {
                List->ScanItems[i].ScanFlag = DhcpDatabaseFix;
            }
            return ERROR_SUCCESS;
        }
    }

    if( (List->NumScanItems % ENTRIES_TO_ALLOCATE_ATTIME) == 0) {

        LPDHCP_SCAN_ITEM NewScanItems;

        //
        // expand items memory.
        //

        NewScanItems = DhcpAllocateMemory(
                        sizeof(DHCP_SCAN_ITEM) *
                            (List->NumScanItems +
                                ENTRIES_TO_ALLOCATE_ATTIME) );

        if( NewScanItems == NULL  ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        if( List->NumScanItems != 0 ) {

			//
			// copy old items.
			//

            memcpy(
                NewScanItems,
                List->ScanItems,
                sizeof(DHCP_SCAN_ITEM) *
                    List->NumScanItems );

            DhcpFreeMemory( List->ScanItems );
        }

        List->ScanItems = NewScanItems;
    }

    NextItem = &List->ScanItems[List->NumScanItems];

    NextItem->IpAddress = Address;
    NextItem->ScanFlag = Fix;
    List->NumScanItems++;

    *ScanList = List;

    return( ERROR_SUCCESS );
}


DWORD
VerifyLists(
    PM_SUBNET Subnet,
    LPDHCP_IP_ADDRESS DatabaseList,
    DWORD DatabaseListCount,
    LPBITMAP_ENTRY BitMapList,
    DWORD BitMapListCount,
    DHCP_IP_ADDRESS *ReservedList,
    ULONG ReserveListCount,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function goes throught the database list and registry list and
    match each other and determines all mismatch entries to for a
    scanlist.

Arguments:

    DatabaseList : List of database entries, ip addresses.

    DatabaseListCount : count of ip addresses.

    BitMapList : list of clusters.

    BitMapListCount : count of clusters.

    ScanList : list of bad entries returned.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error = ERROR_SUCCESS;
    LPDHCP_IP_ADDRESS DatabaseEntry;
    LPBITMAP_ENTRY NextCluster;
    DHCP_IP_ADDRESS NextAddress;
    LPBITMAP_ENTRY LastCluster;
    LPDHCP_IP_ADDRESS LastDBEntry;
    LPBITMAP_ENTRY EndBitMapList = BitMapList + BitMapListCount;
    LPDHCP_IP_ADDRESS EndDatabaseList = DatabaseList + DatabaseListCount;
    ULONG i;

    DhcpAssert( *ScanList == NULL );

    //
    // init scan list.
    //

    Error = InitBadList( ScanList );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // sort bitmap array.
    //

    if( BitMapListCount != 0 ) {

        qsort(
            (PVOID)BitMapList,
            (size_t)BitMapListCount,
            (size_t)sizeof(BITMAP_ENTRY),
            CmpBitmapEntry );

    }

    if( ReserveListCount != 0 ) {
        qsort(
            (PVOID)ReservedList,
            (size_t)ReserveListCount,
            sizeof(DHCP_IP_ADDRESS),
            CmpReservedAddress
            );
    }

    //
    // scan database entries and check each entry against the bitmap.
    //

    if( DatabaseListCount ) {

        LastCluster = BitMapList;
        for( DatabaseEntry = DatabaseList;
                DatabaseEntry < EndDatabaseList;
                    DatabaseEntry++ ) {


            //
            // find it in bitmap.
            //

            if( (BitMapListCount == 0) ||
                !FoundInBitMap(
                    BitMapList,
                    EndBitMapList,
                    *DatabaseEntry,
                    &LastCluster ) ) {

                if( !DhcpServerIsAddressReserved(
                    DhcpGetCurrentServer(), *DatabaseEntry )  ) {

                    Error = AddToBadList(
                        ScanList,
                        *DatabaseEntry,
                        DhcpRegistryFix
                    );

                    if( Error != ERROR_SUCCESS ){
                        goto Cleanup;
                    }
                }
            }
        }
    }

    if ( BitMapListCount ) {

        //
        // init search.
        //

        NextCluster = BitMapList;
        NextAddress = 0;
        LastDBEntry =
            (DatabaseListCount == 0) ? DatabaseList : (EndDatabaseList - 1);

        while( FindNextAddress( &NextCluster, &NextAddress, EndBitMapList ) ) {

            if( (DatabaseListCount == 0) ||
                !FoundInDatabase(
                    DatabaseList,
                    EndDatabaseList,
                    NextAddress,
                    &LastDBEntry ) ) {

                if( !DhcpSubnetIsAddressExcluded(
                    Subnet, NextAddress) ) {

                    Error = AddToBadList(
                                ScanList,
                                NextAddress,
                                DhcpDatabaseFix );

                    if( Error != ERROR_SUCCESS ){
                        goto Cleanup;
                    }
                }
            }
        }
    }

    if( ReserveListCount ) {

        LastDBEntry =
            (DatabaseListCount == 0) ? DatabaseList : (EndDatabaseList - 1);

        for( i = 0; i < ReserveListCount ; i ++ ) {
            if( (DatabaseListCount == 0 ) ||
                !FoundInDatabase(
                    DatabaseList, EndDatabaseList,
                    ReservedList[i], &LastDBEntry
                    )
                ) {
                Error = AddToBadList(
                    ScanList, ReservedList[i], DhcpDatabaseFix
                    );
                if( ERROR_SUCCESS != Error ) goto Cleanup;
            }
        }
    }

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // freeup the scan list.
        //

        if( *ScanList != NULL ) {
            if( (*ScanList)->ScanItems != NULL ) {
                DhcpFreeMemory( (*ScanList)->ScanItems );
            }

            DhcpFreeMemory( *ScanList );
            *ScanList = NULL;
        }
    }

    return( Error );
}


DWORD
AppendClustersToList(
    LPBITMAP_ENTRY *BitMapList,
    DWORD *BitMapListCount,
    DWORD *MaxCount,
    DHCP_IP_ADDRESS RangeStartAddress,
    DHCP_IP_ADDRESS RangeEndAddress,
    LPDHCP_BINARY_DATA InUseBinaryData,
    LPDHCP_BINARY_DATA UsedBinaryData
    )
/*++

Routine Description:

    Append list of new cluster entries to BitMapList. If necessary this
    function allocates memory for BitMapList or expands the old buffer.

Arguments:

    BitMapList : Pointer to list bit map cluster. Caller should free up
        the memory after use.

    BitMapListCount : Count of entries in the above list.

    MaxCount :  Count entries that fit in the current BitMapList Buffer.

    RangeStartAddress : start of this range.

    RangeEndAddress : end of this range.

    InUseBinaryData : Current range InUseCluster list.

    UsedBinaryData : Current subnet range UsedCluster list.

Return Value:

    WINDOWS errors.
--*/
{
    LPBITMAP_ENTRY List = *BitMapList;
    DWORD Count = *BitMapListCount;
    DWORD MaximumCount = *MaxCount;

    LPIN_USE_CLUSTERS InUseClusters = (LPIN_USE_CLUSTERS)InUseBinaryData->Data;
    LPUSED_CLUSTERS UsedClusters = (LPUSED_CLUSTERS)UsedBinaryData->Data;

    DWORD TempCount;
    LPBITMAP_ENTRY Entry;
    DWORD i;

#define ALLOC_NUM_ENTRIES_AT_TIME   128

    if( List == NULL ) {

        DhcpAssert( MaximumCount == 0 );
        DhcpAssert( Count == 0 );

        //
        // allocate first chunk of memory.
        //

        List = DhcpAllocateMemory(
                    sizeof(BITMAP_ENTRY) *
                        ALLOC_NUM_ENTRIES_AT_TIME );

        if( List == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        MaximumCount = ALLOC_NUM_ENTRIES_AT_TIME;
    }

    //
    // check to see we have enough space in the buffer for new entries
    // to append.
    //

    TempCount = InUseClusters->NumInUseClusters +
                    UsedClusters->NumUsedClusters;

    //
    // special case: add at least an entry for this range,
    // so that the fix routine will get to know
    // abou this range.
    //

    if( TempCount == 0 ) {
        TempCount = 1;
    }

    if( (Count + TempCount) > MaximumCount ) {

        LPBITMAP_ENTRY NewBitMapList;

        //
        // enlarge the buffer.
        //

        MaximumCount += (((TempCount / ALLOC_NUM_ENTRIES_AT_TIME) + 1) *
                            ALLOC_NUM_ENTRIES_AT_TIME );


        NewBitMapList = DhcpAllocateMemory(
                            sizeof(BITMAP_ENTRY) *
                               MaximumCount );


        if( NewBitMapList == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        //
        // Copy old data to new buffer.
        //

        memcpy(
            NewBitMapList,
            List,
            Count * sizeof(BITMAP_ENTRY) );

        //
        // freeup old memory.
        //

        DhcpFreeMemory( List );

        List = NewBitMapList;
    }

    DhcpAssert( (TempCount + Count) < MaximumCount );

    //
    // new copy in use entries.
    //

    Entry = &List[Count];

    if( (InUseClusters->NumInUseClusters != 0) ||
            (UsedClusters->NumUsedClusters != 0 ) ) {

        for( i = 0; i < InUseClusters->NumInUseClusters; i++ ) {

            Entry->ClusterAddress = InUseClusters->Clusters[i].ClusterAddress;
            Entry->ClusterBitMap = InUseClusters->Clusters[i].ClusterBitMap;
            Entry->RangeStartAddress = RangeStartAddress;
            Entry->RangeEndAddress = RangeEndAddress;
            Entry++;
        }

        for( i = 0; i < UsedClusters->NumUsedClusters; i++ ) {

            Entry->ClusterAddress = UsedClusters->Clusters[i];
            Entry->ClusterBitMap = (DWORD)(-1);
            Entry->RangeStartAddress = RangeStartAddress;
            Entry->RangeEndAddress = RangeEndAddress;
            Entry++;
        }
    }
    else {

        //
        // special case: add at least an entry for this range,
        // so that the fix routine will get to know
        // abou this range.
        //

        Entry->ClusterAddress = RangeStartAddress;
        Entry->ClusterBitMap = (DWORD)(0);
        Entry->RangeStartAddress = RangeStartAddress;
        Entry->RangeEndAddress = RangeEndAddress;
        Entry++;
    }

    Count += (DWORD)(Entry - &List[Count]); // check ??

    *BitMapList = List;
    *BitMapListCount = Count;
    *MaxCount = MaximumCount;

    return( ERROR_SUCCESS );
}

DWORD
FillRangesClusterFunc(
    IN      PM_RANGE               Range,
    IN      LPBITMAP_ENTRY        *BitMapList,
    IN      LPDWORD                BitMapListCount,
    IN      LPDWORD                MaxBitMapListCount,
    IN      LPDHCP_BINARY_DATA     InUseBinaryData,
    IN      LPDHCP_BINARY_DATA     UsedBinaryData
)
{
    return AppendClustersToList(
        BitMapList,
        BitMapListCount,
        MaxBitMapListCount,
        Range->Start,
        Range->End,
        InUseBinaryData,
        UsedBinaryData
    );
}

DWORD
GetRegistryBitMap(
    PM_SUBNET Subnet,
    LPBITMAP_ENTRY *BitMapList,
    DWORD *BitMapListCount
    )
/*++

Routine Description:

Arguments:

    SubnetMask : Pointer to a location where the subnet mask of the
        above subnet is returned.

    BitMapList : Pointer to list bit map cluster. Caller should free up
        the memory after use.

    BitMapListCount : Count of entries in the above list.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;

    DWORD MaxBitMapListCount = 0;

    DhcpAssert( *BitMapList == NULL );

    Error = DhcpLoopThruSubnetRanges(
        Subnet,
        BitMapList,
        BitMapListCount,
        &MaxBitMapListCount,
        FillRangesClusterFunc
    );

Cleanup:

    if (Error != ERROR_SUCCESS ) {

        //
        // if aren't successful free up return buffers.
        //

        if( *BitMapList != NULL ) {
            DhcpFreeMemory( *BitMapList );
        }

        *BitMapListCount = 0;
    }

    return( Error );
}


DWORD
GetDatabaseList(
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_IP_ADDRESS *DatabaseList,
    DWORD *DatabaseListCount
    )
/*++

Routine Description:

    Read ipaddresses of the database entries that belong to the given
    subnet.

Arguments:

    SubnetAddress : Address of the subnet scope to verify.

    DatabaseList : pointer to list of ip address. caller should free up
        the memory after use.

    DatabaseListCount : count of ip addresses in the above list.

Return Value:

    WINDOWS errors.
--*/
{

    DWORD Error;
    JET_ERR JetError;
    JET_RECPOS JetRecordPosition;
    DWORD TotalExpRecCount = 1;
    DWORD RecordCount = 0;
    LPDHCP_IP_ADDRESS IpList = NULL;
    DWORD i;

    //
    // move the database pointer to the begining.
    //

    Error = DhcpJetPrepareSearch(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                TRUE,   // Search from start
                NULL,
                0
                );


    if( Error != ERROR_SUCCESS ) {
        if( Error == ERROR_NO_MORE_ITEMS ) {

            *DatabaseList = NULL;
            *DatabaseListCount = 0;
            Error = ERROR_SUCCESS;
        }
        goto Cleanup;
    }

    //
    // determine total number of records in the database.
    //
    // There is no way to determine the total number of records, other
    // than  walk through the db. do it.
    //


    while ( (Error = DhcpJetNextRecord() ) == ERROR_SUCCESS )  {
         TotalExpRecCount++;
    }

    if ( Error != ERROR_NO_MORE_ITEMS ) {
        goto Cleanup;
    }

    //
    // move back the database pointer to the begining.
    //

    Error = DhcpJetPrepareSearch(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                TRUE,   // Search from start
                NULL,
                0
                );


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // allocate memory for return list.
    //

    IpList = DhcpAllocateMemory( sizeof(DHCP_IP_ADDRESS) * TotalExpRecCount );

    if( IpList == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // read database entries.
    //

    for( i = 0; i < TotalExpRecCount; i++ ) {

        DHCP_IP_ADDRESS IpAddress;
        DHCP_IP_ADDRESS SubnetMask;
        DHCP_IP_ADDRESS realSubnetMask;
        DWORD Size;

        //
        // read ip address of the current record.
        //

        Size = sizeof(IpAddress);
        Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                    &IpAddress,
                    &Size );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpAssert( Size == sizeof(IpAddress) );

        Size = sizeof(SubnetMask);
        Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
                    &SubnetMask,
                    &Size );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpAssert( Size == sizeof(SubnetMask) );

        realSubnetMask = DhcpGetSubnetMaskForAddress(IpAddress);
        if( realSubnetMask != SubnetMask ) {
            DhcpPrint((DEBUG_ERRORS, "Ip Address <%s> ",inet_ntoa(*(struct in_addr *)&IpAddress)));
            DhcpPrint((DEBUG_ERRORS, "has subnet mask <%s> in db, must be ",inet_ntoa(*(struct in_addr *)&SubnetMask)));
            DhcpPrint((DEBUG_ERRORS, " <%s>\n",inet_ntoa(*(struct in_addr *)&realSubnetMask)));
            DhcpAssert( realSubnetMask == SubnetMask && "GetDatabaseList (scan.c)");
        }

        if( (IpAddress & realSubnetMask) == SubnetAddress ) {

            //
            // append this address to list.
            //

            IpList[RecordCount++] = IpAddress;
        }

        //
        // move to next record.
        //

        Error = DhcpJetNextRecord();

        if( Error != ERROR_SUCCESS ) {

            if( Error == ERROR_NO_MORE_ITEMS ) {
                Error = ERROR_SUCCESS;
                break;
            }

            goto Cleanup;
        }
    }

#if DBG

    //
    // we should be pointing to end of database.

    Error = DhcpJetNextRecord();
    DhcpAssert( Error == ERROR_NO_MORE_ITEMS );
    Error = ERROR_SUCCESS;

#endif // DBG

    *DatabaseList = IpList;
    IpList = NULL;
    *DatabaseListCount = RecordCount;

Cleanup:

    if( IpList != NULL ) {
        DhcpFreeMemory( IpList );
    }

    return( Error );
}


DWORD
CreateClientDBEntry(
    DHCP_IP_ADDRESS ClientIpAddress,
    DHCP_IP_ADDRESS SubnetMask,
    LPBYTE ClientHardwareAddress,
    DWORD HardwareAddressLength,
    DATE_TIME LeaseTerminates,
    LPWSTR MachineName,
    LPWSTR ClientInformation,
    DHCP_IP_ADDRESS ServerIpAddress,
    BYTE AddressState,
    BYTE ClientType
    )
/*++

Routine Description:

    This function creates a client entry in the client database.

Arguments:

    ClientIpAddress - IP address of the client.

    SubnetAddress - Subnet address of the client.

    ClientHardareAddress - The hardware address of this client.

    HardwareAddressLength - The length, in bytes, of the hardware address.

    LeaseDuration - The duration of the lease, in seconds.

    MachineName - The hostname of the client machine.  If NULL, the
        client information is unknown.

    ClientInformation - A client information string.  If NULL, the
        client information is unknown.

    ServerIpAddress - IpAddress of the server which supplied the lease
        to the client.

    AddressState - The new state of the address.

Return Value:

    The status of the operation.

--*/
{
    DWORD Error;
    BOOL TransactBegin = FALSE;
    JET_ERR JetError = JET_errSuccess;

    //
    // start transaction before a create/update database record.
    //

    Error = DhcpJetBeginTransaction();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    TransactBegin = TRUE;

    Error = DhcpJetPrepareUpdate(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                &ClientIpAddress,
                sizeof( ClientIpAddress ),
                TRUE );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                &ClientIpAddress,
                sizeof( ClientIpAddress ) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
                &SubnetMask,
                sizeof(SubnetMask) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[STATE_INDEX].ColHandle,
                &AddressState,
                sizeof(AddressState) );

    if( ERROR_SUCCESS != Error ) {
        goto Cleanup;
    }
    
    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[CLIENT_TYPE_INDEX].ColHandle,
                &ClientType,
                sizeof(ClientType) );

    if( ERROR_SUCCESS != Error ) {
        goto Cleanup;
    }
    
    //
    // Write the information for this client.
    //

    //
    // ClientHarwardAddress can't be NULL.
    //

    DhcpAssert( (ClientHardwareAddress != NULL) &&
                    (HardwareAddressLength > 0) );

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
                ClientHardwareAddress,
                HardwareAddressLength
                );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
                MachineName,
                (MachineName == NULL) ? 0 :
                    (wcslen(MachineName) + 1) * sizeof(WCHAR) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[MACHINE_INFO_INDEX].ColHandle,
                ClientInformation,
                (ClientInformation == NULL) ? 0 :
                    (wcslen(ClientInformation) + 1) * sizeof(WCHAR) );

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
                &LeaseTerminates,
                sizeof(LeaseTerminates));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[SERVER_NAME_INDEX].ColHandle,
                DhcpGlobalServerName,
                DhcpGlobalServerNameLen );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[SERVER_IP_ADDRESS_INDEX].ColHandle,
                &ServerIpAddress,
                sizeof(ServerIpAddress) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // commit changes.
    //

    JetError = JetUpdate(
                    DhcpGlobalJetServerSession,
                    DhcpGlobalClientTableHandle,
                    NULL,
                    0,
                    NULL );

    Error = DhcpMapJetError( JetError, "M:Scan:Create:Update" );

Cleanup:

    if ( Error != ERROR_SUCCESS ) {

        //
        // if the transaction has been started, then roll back to the
        // start point, so that we will not leave the database
        // inconsistence.
        //

        if( TransactBegin == TRUE ) {
            DWORD LocalError;

            LocalError = DhcpJetRollBack();
            DhcpAssert( LocalError == ERROR_SUCCESS );
        }

        DhcpPrint(( DEBUG_ERRORS, "Can't create client entry in the "
                    "database, %ld.\n", Error));

    }
    else {

        //
        // commit the transaction before we return.
        //

        DhcpAssert( TransactBegin == TRUE );

        if( TransactBegin == TRUE ) {

            DWORD LocalError;

            LocalError = DhcpJetCommitTransaction();
            DhcpAssert( LocalError == ERROR_SUCCESS );
        }
    }

    return( Error );
}


DWORD
FixBadEntries(
    PM_SUBNET Subnet,
    LPBITMAP_ENTRY BitMapList,
    DWORD BitMapListCount,
    LPDHCP_SCAN_LIST ScanList
    )
/*++

Routine Description:

    This functions goes through the bad entries list and fixes either
    the database or registry appropriately.

Arguments:

    SubnetAddress : Subnet address.

    BitMapList : list of clusters.

    BitMapListCount : count of clusters.

    ScanList : list of bad entries returned.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;
    DWORD ReturnError = ERROR_SUCCESS;
    LPDHCP_SCAN_ITEM BadEntry;
    LPDHCP_SCAN_ITEM EndBadEntry;
    BOOL RegistryModified = FALSE;
    LPBITMAP_ENTRY NextBitMapCluster;
    LPBITMAP_ENTRY NewBitMapList = NULL;
    DWORD dwUnused;
    CHAR                *HardwareAddressBuffer = NULL;
    DWORD               nHardwareAddressBuffer = 0;


    DhcpAssert( BitMapList != NULL );
    DhcpAssert( ScanList != NULL );

    EndBadEntry =  ScanList->ScanItems + ScanList->NumScanItems;

    for( BadEntry = ScanList->ScanItems;
            BadEntry < EndBadEntry;
                BadEntry++ ) {

        //
        // For each registry fix mark the corresponding bit in the bit
        // map.
        //

        if( BadEntry->ScanFlag == DhcpRegistryFix ) {

            DHCP_IP_ADDRESS BadAddress;
            BOOL BitFound;

            //
            // scan bitmap and fix appropriate bitmap cluster.
            //

            BadAddress = BadEntry->IpAddress;
            BitFound = FALSE;

            // set the BadAddress bit into the memory bitmask (reconcile with the memory).
            // normally, Error should be ERROR_SUCCESS.
		    Error = DhcpSubnetRequestSpecificAddress(
                Subnet,
                BadAddress
            );

            // shouldn't happen..
            if (Error != ERROR_SUCCESS)
                continue;

            for( NextBitMapCluster = BitMapList;
                    NextBitMapCluster  < BitMapList + BitMapListCount;
                        NextBitMapCluster++ ) {

                DHCP_IP_ADDRESS ClusterAddress;

                ClusterAddress = NextBitMapCluster->ClusterAddress;

                //
                // is the bad address in this cluster.
                //

                if( (BadAddress >= ClusterAddress) &&
                        (BadAddress < (ClusterAddress + CLUSTER_SIZE)) ) {

                    DWORD Bit = 0x1 << (BadAddress - ClusterAddress);

                    DhcpAssert( (NextBitMapCluster->ClusterBitMap & Bit) == 0 );

                    NextBitMapCluster->ClusterBitMap |= Bit;
                    BitFound = TRUE;
                    break;
                }
            }

            if( !BitFound ) {

                //
                // if the bad address is not found in the existing
                // clusters, check to see this address is within any
                // one of the existing ranges, if so this bit must be
                // from one of the unused clusters. Create a new
                // cluster and add to list.
                //

                for( NextBitMapCluster = BitMapList;
                        NextBitMapCluster  < BitMapList + BitMapListCount;
                            NextBitMapCluster++ ) {

                    DHCP_IP_ADDRESS RangeStartAddress;
                    DHCP_IP_ADDRESS RangeEndAddress;

                    RangeStartAddress = NextBitMapCluster->RangeStartAddress;
                    RangeEndAddress = NextBitMapCluster->RangeEndAddress;

                    if( (BadAddress  >= RangeStartAddress) &&
                            (BadAddress <=RangeEndAddress ) ) {

                        DHCP_IP_ADDRESS ClusterAddress;
                        DWORD BitMap;
                        BITMAP_ENTRY BitMapCluster;

                        //
                        // Found a range that fits this address.
                        //

                        ClusterAddress = RangeStartAddress +
                            (BadAddress - RangeStartAddress) -
                                ((BadAddress - RangeStartAddress) %
                                    CLUSTER_SIZE);

                        BitMap =  0x1 << (BadAddress - ClusterAddress);

                        BitMapCluster.ClusterAddress = ClusterAddress;
                        BitMapCluster.ClusterBitMap = BitMap;
                        BitMapCluster.RangeStartAddress = RangeStartAddress;
                        BitMapCluster.RangeEndAddress = RangeEndAddress;

                        if( (BitMapListCount %
                                ALLOC_NUM_ENTRIES_AT_TIME) != 0 ) {

                            //
                            // we still have room left in the buffer, use it.
                            //

                            BitMapList[BitMapListCount] = BitMapCluster;
                            BitMapListCount++;
                        }
                        else {

                            //
                            // allocate new memory to fit
                            // ALLOC_NUM_ENTRIES_AT_TIME additional
                            // entries.
                            //

                            NewBitMapList =
                                DhcpAllocateMemory(
                                    sizeof(BITMAP_ENTRY) *
                                        (BitMapListCount +
                                         ALLOC_NUM_ENTRIES_AT_TIME) );

                            DhcpAssert( NewBitMapList != NULL );

                            if( NewBitMapList != NULL ) {

                                //
                                // copy old data.
                                //

                                memcpy( NewBitMapList,
                                        BitMapList,
                                        sizeof(BITMAP_ENTRY) *
                                            BitMapListCount );

                                //
                                // copy new pointer to old pointer.
                                // the caller will free up the old
                                // pointer, this function should
                                // freeup the new pointer at the end.
                                //

                                BitMapList = NewBitMapList;

                                //
                                // now copy new entry.
                                //

                                BitMapList[BitMapListCount] = BitMapCluster;
                                BitMapListCount++;
                            }
                        } // allocate more memory.

                        break; // we are done with this bad address.

                    } // range found.
                } // search ranges.
            } // !BitFound

            //
            // bit map should be written back in the registry.
            //

            RegistryModified = TRUE;
        }
        else if( BadEntry->ScanFlag == DhcpDatabaseFix ) {

            DHCP_IP_ADDRESS     IpAddress;
            WCHAR               MachineNameBuffer[DHCP_IP_KEY_LEN];
            LPWSTR              MachineName;
            DWORD               nClientHardwareAddress;
            ULONG               ClientUIDSize;
            LPBYTE              ClientUID;
            DATE_TIME           Lease;

            // get the IpAddress of this BadEntry
            IpAddress = BadEntry->IpAddress;

            // we don't know the machine's name, so we fake it to
            // the string representation of the IpAddress
            MachineName = DhcpRegIpAddressToKey(
                            IpAddress,
                            MachineNameBuffer );

            // find out if this is a reserved address, which case we will have the real hardware address
            Error = DhcpFindReservationByAddress(Subnet, IpAddress, &ClientUID, &ClientUIDSize);

            // find out the maximal size of the client's hardware address,
            // regardless it will be faked or not.

            nClientHardwareAddress = (Error == ERROR_SUCCESS) ? ClientUIDSize : DHCP_IP_KEY_LEN;

            // make sure there is enough space in HardwareAddressBuffer
            // for holding nClientHardwareAddress bytes

            if (nClientHardwareAddress > nHardwareAddressBuffer)
            {
                // need to grow the HardwareAddressBuffer
                if (HardwareAddressBuffer != NULL)
                    DhcpFreeMemory(HardwareAddressBuffer);

                // in order to avoid initial frequent reallocations, do not alloc less than DHCP_IP_KEY_LEN bytes
                nHardwareAddressBuffer = (nClientHardwareAddress > DHCP_IP_KEY_LEN) ?
                                          nClientHardwareAddress : DHCP_IP_KEY_LEN;

                HardwareAddressBuffer = DhcpAllocateMemory(nHardwareAddressBuffer);

                //*** handle here the allocation failure ***
                if (HardwareAddressBuffer == NULL)
                {
                    // as above, when buffer allocation fails, don't give up,
                    // skip to the next 'BadEntry'
                    nHardwareAddressBuffer = 0;
                    continue;
                }
            }

            // next, get the values for HardwareAddressBuffer, nClientHardwareAddress
            // and Lease variables
            if (Error == ERROR_SUCCESS)
            {
                // if the IpAddress is a reservation, then the lease = 0 Reserved(inactive)
                // and the HardwareAddress is copied from the registry
                Lease.dwLowDateTime = DHCP_DATE_TIME_ZERO_LOW;
                Lease.dwHighDateTime = DHCP_DATE_TIME_ZERO_HIGH;

                memcpy(HardwareAddressBuffer, ClientUID, nClientHardwareAddress);
            }
            else
            {
                // this is a regular IpAddress, so the lease is copied from the subnet options
                // and the Hardware address is faked to the binary encoding of the
                // IpAddress string representation
                DHCP_IP_ADDRESS         NetworkIpAddress;
                DHCP_REQUEST_CONTEXT    Ctxt;
                LPBYTE                  OptionData = NULL;
                DWORD                   OptionDataLength = 0;
                DWORD                   LeaseDuration;

                //
                // get lease duration.
                //
                Ctxt.Server = DhcpGetCurrentServer();
                Ctxt.Range = NULL;
                Ctxt.Reservation = NULL;
                Ctxt.Subnet = Subnet;
                Ctxt.ClassId = 0;

                Error =  DhcpGetParameter(
                            IpAddress,
                            &Ctxt,
                            OPTION_LEASE_TIME,
                            &OptionData,
                            &OptionDataLength,
                            &dwUnused);

                if ( Error != ERROR_SUCCESS ) {
                    LeaseDuration = INFINIT_LEASE;
                } else {
                    DhcpAssert( OptionDataLength == sizeof(LeaseDuration) );
                    LeaseDuration = *(DWORD *)OptionData;
                    // DhcpGetParameter returns values in Network Byte Order.
                    LeaseDuration = ntohl( LeaseDuration );
                    DhcpFreeMemory( OptionData );
                }

                Lease = DhcpCalculateTime(LeaseDuration);
                NetworkIpAddress = htonl(IpAddress);

                // we don't know what's the Hardware address, so we fake it to the binary encoding
                // of the string representation of the IpAddress
                strcpy(HardwareAddressBuffer, inet_ntoa(*(struct in_addr *)&NetworkIpAddress));
                nClientHardwareAddress = strlen(HardwareAddressBuffer) + sizeof(CHAR);
            }

            // next, write down the database record based on the info obtained above
            if (Subnet->fSubnet) {
                //
                // create a dummy entry with subnet/global lease time, so
                // that this bad entry will be recovered after the lease
                // expires.
                //
                Error = CreateClientDBEntry(
                    IpAddress,
                    Subnet->Mask,
                    HardwareAddressBuffer,
                    nClientHardwareAddress,
                    Lease,
                    MachineName,
                    NULL,
                    INADDR_LOOPBACK,
                    ADDRESS_STATE_ACTIVE,
                    CLIENT_TYPE_BOTH );
            } else {
                Error = MadcapCreateClientEntry(
                    (LPBYTE)&IpAddress,
                    sizeof(IpAddress),
                    Subnet->MScopeId,
                    HardwareAddressBuffer,
                    nClientHardwareAddress,
                    NULL,
                    DhcpGetDateTime(),
                    Lease,
                    INADDR_LOOPBACK,
                    ADDRESS_STATE_ACTIVE,
                    0,
                    FALSE
                );
            }

            DhcpAssert( Error == ERROR_SUCCESS );

            if( Error != ERROR_SUCCESS ) {
                ReturnError = Error;
            }
        }
        else {

            //
            // neither the registry nor the database fix.
            //

            DhcpAssert( FALSE );
        }
    }

//    if (RegistryModified) {
//          old code updated here the registry as well
//    }

//Cleanup:

    if( NewBitMapList != NULL ) {
        DhcpFreeMemory( NewBitMapList );
    }

    if( HardwareAddressBuffer != NULL) {
        DhcpFreeMemory( HardwareAddressBuffer );
    }

    return( ReturnError );
}

DWORD
GetReservedList(
    IN PM_SUBNET Subnet,
    OUT DHCP_IP_ADDRESS **ReservedList,
    OUT ULONG* ReserveListCount
    )
{
    ULONG Error, Count;
    ARRAY_LOCATION Loc;
    DHCP_IP_ADDRESS *List;

    (*ReservedList) = NULL;
    (*ReserveListCount) = MemArraySize(&Subnet->Reservations);
    if( 0 == (*ReserveListCount) ) {
        return ERROR_SUCCESS;
    }

    (*ReservedList) = DhcpAllocateMemory(
        sizeof(DHCP_IP_ADDRESS)*(*ReserveListCount)
        );
    if( NULL == (*ReservedList) ) {
        (*ReserveListCount) = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    List = *ReservedList;
    for(
        Error = MemArrayInitLoc(&Subnet->Reservations, &Loc);
        ERROR_SUCCESS == Error;
        Error = MemArrayNextLoc(&Subnet->Reservations, &Loc)
        ) {
        PM_RESERVATION ThisElt;

        MemArrayGetElement(&Subnet->Reservations, &Loc, &ThisElt);
        *List ++ = ThisElt->Address;
    }

    return ERROR_SUCCESS;
}

DWORD
ScanDatabase(
    PM_SUBNET Subnet,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    Worker function for R_DhcpScanDatabase.

Arguments:

    SubnetAddress : Address of the subnet scope to verify.

    FixFlag : If this flag is TRUE, this api will fix the bad entries.

    ScanList : List of bad entries returned. The caller should free up
        this memory after it has been used.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;
    LPDHCP_IP_ADDRESS DatabaseList = NULL;
    DWORD DatabaseListCount = 0;
    LPBITMAP_ENTRY BitMapList = NULL;
    DWORD BitMapListCount = 0;
    DHCP_IP_ADDRESS *ReservedList;
    ULONG ReserveListCount;

    DhcpAssert( *ScanList == NULL );

    //
    // lock both registry and database locks here to avoid dead lock.
    //

    LOCK_DATABASE();

    //
    // read registry bit-map.
    //

    Error = GetRegistryBitMap(
        Subnet,
        &BitMapList,
        &BitMapListCount
    );


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    // now make list of database records of the specified subnet.
    if (Subnet->fSubnet) {
        Error = GetDatabaseList(
            Subnet->Address,
            &DatabaseList,
            &DatabaseListCount
        );
    } else {
        Error = GetMCastDatabaseList(
            Subnet->MScopeId,
            &DatabaseList,
            &DatabaseListCount
        );
    }

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    GetReservedList(
        Subnet,
        &ReservedList,
        &ReserveListCount
        );

    //
    // now time to check both lists.
    //

    Error = VerifyLists(
        Subnet,
        DatabaseList,
        DatabaseListCount,
        BitMapList,
        BitMapListCount,
        ReservedList,
        ReserveListCount,
        ScanList
    );

    if( ReservedList ) DhcpFreeMemory(ReservedList);

    if( Error != ERROR_SUCCESS ) {
        DhcpAssert( *ScanList == NULL );
        goto Cleanup;
    }

    DhcpAssert( *ScanList != NULL );

    if( FixFlag ) {

        //
        // fix bad entries.
        //

        Error = FixBadEntries(
            Subnet,
            BitMapList,
            BitMapListCount,
            *ScanList
        );
    }

Cleanup:

    if( DatabaseList != NULL ) {
        DhcpFreeMemory( DatabaseList );
    }

    if( BitMapList != NULL) {
        DhcpFreeMemory( BitMapList );
    }

    UNLOCK_DATABASE();

    return(Error);
}

DWORD
R_DhcpScanDatabase2(
    LPWSTR ServerIpAddress,
    LPWSTR  pMScopeName,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function scans the database entries and registry bit-map for
    specified subnet scope and veryfies to see they match. If they
    don't match, this api will return the list of inconsistent entries.
    Optionally FixFlag can be used to fix the bad entries.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : Address of the subnet scope to verify.

    FixFlag : If this flag is TRUE, this api will fix the bad entries.

    ScanList : List of bad entries returned. The caller should free up
        this memory after it has been used.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;
    PM_SUBNET   Subnet;

    DhcpPrint(( DEBUG_APIS, "DhcpScanDatabase is called.\n"));

    if (!pMScopeName ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }


    DhcpAcquireWriteLock();

    Error = DhcpFlushBitmaps();
    DhcpAssert(ERROR_SUCCESS == Error);

    Error = DhcpServerFindMScope(
        DhcpGetCurrentServer(),
        0,
        pMScopeName,
        &Subnet
    );

    if( ERROR_SUCCESS == Error ) {
        Error = ScanDatabase(
            Subnet,
            FixFlag,
            ScanList
        );
    }

    DhcpReleaseWriteLock();
    DhcpScheduleRogueAuthCheck();

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS, "DhcpScanDatabase  failed, %ld.\n",
                        Error ));
    }

    return(Error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\uniqid.h ===
#ifndef UNIQID_H
#define UNIQID_H

#define INVALID_UNIQ_ID 0xffffffff

DWORD
DeleteRecord(
    IN ULONG UniqId
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\subntapi.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpapi.c

Abstract:

    This module contains the implementation for the APIs that update
    the list of IP addresses that the server can distribute.

Author:

    Madan Appiah (madana)  13-Sep-1993

Environment:

    User Mode - Win32

Revision History:

    Cheng Yang (t-cheny)  30-May-1996  superscope
    Cheng Yang (t-cheny)  27-Jun-1996  audit log

--*/

#include "dhcppch.h"

DWORD
SubnetInUse(
    HKEY SubnetKeyHandle,
    DHCP_IP_ADDRESS SubnetAddress
    )
/*++

Routine Description:

    This function determains whether a subnet is under use or not.
    Currently it returns error if any of the subnet address is still
    distributed to client.

Arguments:

    SubnetKeyHandle : handle to the subnet key.

    SubnetAddress : address of the subnet to test.

Return Value:

    DHCP_SUBNET_CANT_REMOVE - if the subnet is in use.

    Other registry errors.

--*/
{
    DWORD Error;
    DWORD Resumehandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY_V4 ClientInfo = NULL;
    DWORD ClientsRead;
    DWORD ClientsTotal;

    //
    // enumurate clients that belong to the given subnet.
    //
    // We can specify big enough buffer to hold one or two clients
    // info, all we want to know is, is there atleast a client belong
    // to this subnet.
    //

    Error = R_DhcpEnumSubnetClientsV4(
                NULL,
                SubnetAddress,
                &Resumehandle,
                1024,  // 1K buffer.
                &ClientInfo,
                &ClientsRead,
                &ClientsTotal );

    if( Error == ERROR_NO_MORE_ITEMS ) {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( (Error == ERROR_SUCCESS) || (Error == ERROR_MORE_DATA) ) {

        if( ClientsRead != 0 ) {
            Error = ERROR_DHCP_ELEMENT_CANT_REMOVE;
        }
        else {
            Error = ERROR_SUCCESS;
        }
    }

Cleanup:

    if( ClientInfo != NULL ) {
        _fgs__DHCP_CLIENT_INFO_ARRAY( ClientInfo );
        MIDL_user_free( ClientInfo );
    }

    return( Error );
}


//
// Subnet APIs
//


DWORD
R_DhcpAddSubnetElement(
    DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_ELEMENT_DATA AddElementInfo
    )
/*++

Routine Description:

    This function adds an enumerable type of subnet elements to the
    specified subnet. The new elements that are added to the subnet will
    come into effect immediately.

    This function emulates the RPC interface used by NT 4.0 DHCP Server.
    It is provided for backward compatibilty with older version of the
    DHCP Administrator application.

    NOTE: It is not clear now how do we handle the new secondary hosts.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    AddElementInfo : Pointer to an element information structure
        containing new element that is added to the subnet.
        DhcpIPClusters element type is invalid to specify.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    Other WINDOWS errors.
--*/


{
    DHCP_SUBNET_ELEMENT_DATA_V4 *pAddElementInfoV4;
    DWORD                        dwResult;

    if( NULL == AddElementInfo ||
        (DhcpIpRanges == AddElementInfo->ElementType &&
         NULL == AddElementInfo->Element.IpRange ) ) {

        //
        // Bug# 158321
        //
        
        return ERROR_INVALID_PARAMETER;
    }
    
    pAddElementInfoV4 = CopySubnetElementDataToV4( AddElementInfo );
    if ( pAddElementInfoV4 )
    {

        if ( DhcpReservedIps == pAddElementInfoV4->ElementType )
        {
            pAddElementInfoV4->Element.ReservedIp->bAllowedClientTypes =
                CLIENT_TYPE_BOTH;
        }

        dwResult = R_DhcpAddSubnetElementV4(
                        ServerIpAddress,
                        SubnetAddress,
                        pAddElementInfoV4 );

        _fgs__DHCP_SUBNET_ELEMENT_DATA( pAddElementInfoV4 );

        MIDL_user_free( pAddElementInfoV4 );
    }
    else
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

    return dwResult;
}


DWORD
R_DhcpEnumSubnetElements(
    DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
{
    DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *pEnumElementInfoV4 = NULL;
    DWORD                              dwResult;

    dwResult = R_DhcpEnumSubnetElementsV4(
                        ServerIpAddress,
                        SubnetAddress,
                        EnumElementType,
                        ResumeHandle,
                        PreferredMaximum,
                        &pEnumElementInfoV4,
                        ElementsRead,
                        ElementsTotal
                        );
    if ( ERROR_SUCCESS == dwResult || ERROR_MORE_DATA == dwResult )
    {
        DWORD dw;


        // since the only difference between DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 and
        // DHCP_SUBNET_ELEMENT_INFO_ARRAY are a couple of fields at the end of the
        // embedded DHCP_IP_RESERVATION_V4 struct, it is safe to simply return the
        // V4 struct.

        *EnumElementInfo = ( DHCP_SUBNET_ELEMENT_INFO_ARRAY *) pEnumElementInfoV4;
    }
    else
    {
        DhcpAssert( !pEnumElementInfoV4 );
    }

    return dwResult;
}



DWORD
R_DhcpRemoveSubnetElement(
    LPWSTR  ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_ELEMENT_DATA RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet element from managing. If the subnet
    element is in use (for example, if the IpRange is in use) then it
    returns error according to the ForceFlag specified.

    This function emulates the RPC interface used by NT 4.0 DHCP Server.
    It is provided for backward compatibilty with older version of the
    DHCP Administrator application.


Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    RemoveElementInfo : Pointer to an element information structure
        containing element that should be removed from the subnet.
        DhcpIPClusters element type is invalid to specify.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    ERROR_DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.
--*/


{
    DWORD dwResult;
    DHCP_SUBNET_ELEMENT_DATA_V4 *pRemoveElementInfoV4;

    pRemoveElementInfoV4 = CopySubnetElementDataToV4( RemoveElementInfo );
    if ( pRemoveElementInfoV4 )
    {
        if ( DhcpReservedIps == pRemoveElementInfoV4->ElementType )
        {
            pRemoveElementInfoV4->Element.ReservedIp->bAllowedClientTypes = CLIENT_TYPE_DHCP;
        }

        dwResult = R_DhcpRemoveSubnetElementV4(
                        ServerIpAddress,
                        SubnetAddress,
                        pRemoveElementInfoV4,
                        ForceFlag );

        _fgs__DHCP_SUBNET_ELEMENT_DATA( pRemoveElementInfoV4 );
        MIDL_user_free( pRemoveElementInfoV4 );
    }
    else
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

    return dwResult;
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\thread.h ===
//================================================================================
//  Copyright (C) Microsoft Corporation 1997
//  Author: RameshV
//  Title: Threading Model
//  Description: the new, neat threading model
//  Date: 24-Jul-97 09:22
//--------------------------------------------------------------------------------

#ifndef THREAD_H_INCLUDED
#define THREAD_H_INCLUDED
//================================================================================
//  EXPOSED strucures and types
//================================================================================

typedef struct st_PACKET {              //  Packet information for quick lookups
    LIST_ENTRY           List;          //  This is one of Active/PingRetry/PingRetried
    LIST_ENTRY           HashList;      //  This is the list for each bucket in the hash
    DWORD                HashValue;     //  The hash value for this packet
    // Do not separate the following three fields: Check HashPacket for reason.
    DWORD                Xid;           //  The transaction id of the process
    BYTE                 HWAddrType;    //  The hardware address type
    BYTE                 Chaddr[16];    //  Client hw address
    LPBYTE               ClientId;      //  Client Identifier
    BYTE                 ClientIdSize;  //  The length of above ptr
    BYTE                 PacketType;    //  What is the type of the packet?
    DHCP_IP_ADDRESS      PingAddress;   //  Address attempted ping for
    BOOL                 DestReachable; //  Is the destination reachable?
    DHCP_REQUEST_CONTEXT ReqContext;    //  The actual request context
    union {
        LPVOID           CalloutContext;//  used to pass context to dhcp server callouts
        VOID             (*Callback)(ULONG IpAddress, LPBYTE HwAddr, ULONG HwLen, BOOL Reachable);
    };
    BOOL                 fSocketLocked; //  Did we acquire a socket lock for this packet?
} PACKET, *LPPACKET, *PPACKET;


#define PACKET_ACTIVE    0x01           //  A new packet just came in
#define PACKET_PING      0x02           //  This packet is waiting for trying out ping
#define PACKET_PINGED    0x03           //  A ping has happened
#define PACKET_DYNBOOT   0x04           //  Packet for dynamic bootp

#define PACKET_OFFSET(X) ((DWORD)(ULONG_PTR)&(((LPPACKET)0)->X))
#define HASH_PREFIX      (PACKET_OFFSET(ClientId) - PACKET_OFFSET(Xid))

//================================================================================
//  EXPOSED functions
//================================================================================
DWORD                                   //  Win32 errors
ThreadsDataInit(                        //  Initialize everything in this file
    IN      DWORD        nMaxThreads,   //  Max # of processing threads to start
    IN      DWORD        nActiveThreads //  Of this how many can run at a time
);

VOID
ThreadsDataCleanup(                     //  Cleanup everything done in this file
    VOID
);

DWORD                                   //  Win32 errors
ThreadsStartup(                         //  Start the requisite # of threads
    VOID
);

VOID
ThreadsStop(                            //  Stop all the threads
    VOID
);

VOID                                    //  No return values
HandleIcmpResult(                       //  After a ping is finished, it comes here
    IN      DWORD        PingAddressIn, //  The Address that was pinged
    IN      BOOL         DestReachable, //  Was the Destination reachable?
    IN      LPPACKET     P              //  This is the packet that we were dealing with
);

DWORD                                   //  Win32 errors
DhcpNotifyWorkerThreadsQuit(            //  Post io comp request asking threads to quit
    VOID
);

VOID
WaitForMessageThreadToQuit( 
    VOID 
);

//================================================================================
//  End of file
//================================================================================
#endif THREAD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\thread.c ===
//--------------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation 1997
//  Author: RameshV
//  Title: Threading Model
//  Description: the new, neat threading model
//  Date: 24-Jul-97 09:22
//--------------------------------------------------------------------------------
#include <dhcppch.h>                    //  global header file
#include <thread.h>                     //  types and exposed functions
#include <ping.h>                       //  handling the ping calls

typedef PLIST_ENTRY      PACKET_Q;      //  PACKET_Q is just a list

#define Q_INIT_SIZE      50             //  Initial amount of allocated buffers
#define Q_MAX_SIZE       100            //  Maximum size of the queue
#define MAX_MSG_IN_Q_TIME 30            //  30 seconds

#define ThreadTrace(str)                DhcpPrint((DEBUG_THREAD, "%s", str ))
#define ThreadTrace2(X,Y)               DhcpPrint((DEBUG_THREAD, X, Y ))
#define ThreadTrace3(X,Y,Z)             DhcpPrint((DEBUG_THREAD, X, Y, Z));
#define ThreadAlert(X)                  DhcpPrint((DEBUG_ERRORS, "ALERT: %s", X))

//================================================================================
//  IMPORTED functions  (non Win32 API stuff only)
//================================================================================
// DhcpPrint
// ASSERT
// DhcpAssert
// DhcpAllocateMemory
// DhcpFreeMemory
//
// DhcpWaitForMessage
//
// DhcpCreateClientEntry
//
//
// DoIcmpRequest
//
//
//================================================================================
//  IMPORTED global variables
//================================================================================
// No global variable is used directly in this file
//

//================================================================================
//  Function prototypes: forward declarations
//================================================================================
DWORD
NotifyProcessingLoop(
    VOID
);

DWORD
DhcpNotifiedAboutMessage(
    OUT     BOOL        *Terminate
);

BOOL
DhcpTerminated(
    VOID
);

DWORD
DhcpMessageWait(
    IN      LPPACKET     Packet
);

BOOL
ExactMatch(
    IN      LPPACKET     Packet1,
    IN      LPPACKET     Packet2
);

VOID
ProcessPacket(
    IN      LPPACKET     Packet
);

VOID
HandlePingAbort(
    IN      DWORD        IpAddress,
    IN      BOOL         DestReachable
);

//================================================================================
//  Here is the hash queue..
//================================================================================
#define     HASH_Q_SIZE  1024           //  Size of the hash queue
LIST_ENTRY  HashQ[HASH_Q_SIZE];         //  Each list is one bucket

//================================================================================
//  Hash q functions
//================================================================================
DWORD                                   //  Hash value == 0 .. HASH_Q_SIZE
HashPacket(                             //  Hash the packet into the reqd queue
    IN      PPACKET      P              //  The input packet to hash.
) {
    DWORD   PrefixLen, HashVal, Tmp;
    LPBYTE  HashBytes;                  //  The start of the hashing bytes

    PrefixLen = HASH_PREFIX;            //  packet prefix is this big.
    HashBytes = (LPBYTE)&P->Xid;        //  Start the hashing from Xid
    HashVal = 0;

    while( PrefixLen > sizeof(DWORD) ) {
        memcpy((LPBYTE)&Tmp, HashBytes, sizeof(DWORD));
        HashBytes += sizeof(DWORD);
        PrefixLen -= sizeof(DWORD);
        HashVal += Tmp;
    }

    if( PrefixLen ) {                   //  If prefixlen is not a multiple of DWORD size
        Tmp = 0;                        //  Then, copy as much as is left
        memcpy((LPBYTE)&Tmp, HashBytes, PrefixLen);
        HashVal += Tmp;
    }

    DhcpAssert( 4 == sizeof(DWORD) );   //  We need to get down to 2 bytes, so assert this

    HashVal = (HashVal >> 16 ) + (HashVal & 0xFFFF);
    return HashVal % HASH_Q_SIZE;       //  add hashval higher word to lower word and mod size
}

DWORD                                   //  Win32 errors
InitHashQ(                              //  Initialize the hash q
    VOID                                //  No parameters
) {
    DWORD   i;

    for( i = 0; i < HASH_Q_SIZE ; i ++ )
        InitializeListHead(&HashQ[i]);

    return ERROR_SUCCESS;
}

VOID
CleanupHashQ(                           //  Cleanup all memory associated with hash q
) {
    DWORD   i;

    for( i = 0; i < HASH_Q_SIZE ; i ++ )
        InitializeListHead(&HashQ[i]);
}

DWORD                                   //  Win32 errors
InsertHashQ(                            //  Insert the given packet into the HashQ
    IN      PPACKET      P              //  input packet to insert
) {
    DWORD   HashVal;

    DhcpAssert(P && P->HashValue < HASH_Q_SIZE );

    DhcpAssert(P->HashList.Flink == &(P->HashList) );
    InsertHeadList(&HashQ[P->HashValue], &P->HashList);
    return  ERROR_SUCCESS;
}

DWORD                                   //  Win32 errors
DeleteHashQ(                            //  Delete this from the hash q
    IN      PPACKET      P              //  The packet to delete
) {
    DhcpAssert(P->HashList.Flink != &(P->HashList) );
    RemoveEntryList(&P->HashList);
    InitializeListHead(&P->HashList);   //  Further removes wont hurt
    return  ERROR_SUCCESS;
}

DWORD                                   //  Win32 errors
SearchHashQ(                            //  Search the hash Q
    IN      PPACKET      P,             //  Input packet to search for
    OUT     PPACKET     *OutP           //  Output packet if found
) {
    PLIST_ENTRY          List,NextEntry;
    PPACKET              RetVal;

    DhcpAssert(OutP && P && P->HashValue < HASH_Q_SIZE );

    *OutP = NULL;
    List = &HashQ[P->HashValue];
    NextEntry = List->Flink;
    while( List != NextEntry ) {        //  While not end of list
        RetVal = CONTAINING_RECORD(NextEntry, PACKET, HashList);

        if(ExactMatch(P, RetVal) ) {    //  It is in the same bucket, but is it same?
            *OutP = RetVal;
            break;
        }

        NextEntry = NextEntry->Flink;
    }

    if( *OutP ) return ERROR_SUCCESS;
    return ERROR_FILE_NOT_FOUND;
}


//================================================================================
//  Functions, helpers, real, initialization,cleanup etc.
//================================================================================

LPPACKET  STATIC                        //  Return a deleted elt or NULL if empty
DeleteOldestElement(                    //  Delete the first inserted elt from the Q
    IN      PACKET_Q     Pq             //  The Q to delete from
) {
    PLIST_ENTRY          Head;

    if( IsListEmpty(Pq) ) return NULL;  //  No element here

    Head = RemoveTailList(Pq);
    return CONTAINING_RECORD(Head, PACKET, List);
}

BOOL  STATIC                            //  TRUE on success, FALSE if no memory
InsertElement(                          //  Insert an element into the array
    IN      PACKET_Q     Pq,            //  Insert into this Q
    IN      LPPACKET     packet         //  This is the packet to insert
) {
    InsertHeadList(Pq, &packet->List);  //  Just insert this guy
    return TRUE;
}

//================================================================================
//  Local Data
//================================================================================
CRITICAL_SECTION         PacketCritSection;
#define QLOCK()          EnterCriticalSection(&PacketCritSection)
#define QUNLOCK()        LeaveCriticalSection(&PacketCritSection)

LIST_ENTRY               FreeQ;
PACKET_Q                 ActiveQ, PingRetryQ, PingRetriedQ;

struct /* anonymous */ { //  holds the statistics for this file
    DWORD     NServiced;
    DWORD     NActiveDropped;
    DWORD     NRetryDropped;
    DWORD     NRetriedDropped;
    DWORD     NActiveMatched;
    DWORD     NRetryMatched;
    DWORD     NRetriedMatched;
    DWORD     NPacketsAllocated;
    DWORD     NPacketsInFreePool;
} Stats;

//================================================================================
//  Module functions
//================================================================================

LPPACKET  STATIC                        //  Packet* or NULL if no mem
AllocateFreePacket(                     //  Allocate a packet
    VOID
) {
    DWORD   HeaderSize, PacketSize, MessageSize;
    LPBYTE  Memory;
    PPACKET RetVal;

    HeaderSize = sizeof(LIST_ENTRY);
    HeaderSize = ROUND_UP_COUNT(HeaderSize, ALIGN_WORST);
    PacketSize = sizeof(PACKET);
    PacketSize = ROUND_UP_COUNT(PacketSize, ALIGN_WORST);
    MessageSize = DHCP_RECV_MESSAGE_SIZE;

    Memory = DhcpAllocateMemory(HeaderSize+PacketSize+MessageSize);
    if( NULL == Memory ) return NULL;   //  Cannot do anything if no mem.
    RetVal = (LPPACKET)(Memory+HeaderSize);

    RetVal->fSocketLocked = FALSE;

    Stats.NPacketsAllocated ++;
    return RetVal;
}

VOID  STATIC
FreeFreePacket(                         //  Free the packet and associated strucs
    IN      LPPACKET     Packet         //  The packet to free
) {
    DWORD   HeaderSize;
    LPBYTE  Memory;

    HeaderSize = sizeof(LIST_ENTRY);
    HeaderSize = ROUND_UP_COUNT(HeaderSize, ALIGN_WORST);

    Memory = (LPBYTE)Packet ;
    DhcpFreeMemory( Memory - HeaderSize );
    Stats.NPacketsAllocated --;
}

VOID  STATIC
InsertFreePacket(                       //  Insert a free packet into pool
    IN      PLIST_ENTRY  List,          //  The list to insert into
    IN      LPPACKET     Packet         //  The packet to insert
) {
    DWORD                HeaderSize;
    LPBYTE               Memory;

    if( Stats.NPacketsInFreePool > Q_INIT_SIZE ) {
        FreeFreePacket(Packet);
        return;
    }

    Stats.NPacketsInFreePool ++;
    HeaderSize = sizeof(LIST_ENTRY);
    HeaderSize = ROUND_UP_COUNT(HeaderSize, ALIGN_WORST);
    //  Note that the packet has a "hidden" header the used start address.
    //  Things will work correctly only IF THE PACKET WAS ALLOCATED by the
    //  AllocatePacket function

    Memory = (LPBYTE)Packet;
    InsertHeadList( List, ((PLIST_ENTRY)(Memory - HeaderSize)));
}

LPPACKET   STATIC _inline               //  Return NULL or a packet
DeleteFreePacketEx(                     //  Try to see if a free packet exists
    IN     PLIST_ENTRY   List,          //  Input list
    IN     BOOL          Alloc          //  Allocate if list empty?
) {
    PLIST_ENTRY          Head;
    LPBYTE               Memory;
    DWORD                HeaderSize;

    HeaderSize = sizeof(LIST_ENTRY);
    HeaderSize = ROUND_UP_COUNT(HeaderSize, ALIGN_WORST);

    if( IsListEmpty(List) ) {
        if( Alloc && Stats.NPacketsAllocated < Q_MAX_SIZE ) {
            return AllocateFreePacket();
        }
        return NULL;
    }

    DhcpAssert(Stats.NPacketsInFreePool);
    Stats.NPacketsInFreePool --;
    Head = RemoveHeadList(List);        //  Remove the first elt in the list
    Memory = (LPBYTE)Head;
    return (LPPACKET) (Memory + HeaderSize );
}

LPPACKET  STATIC                        //  A packet* if one exists, NULL else
DeleteFreePacket(                       //  Delete a free packet
    IN      PLIST_ENTRY  List           //  The list to delete from
) {
    LPPACKET             RetVal;
    DWORD                PacketSize;

    RetVal = DeleteFreePacketEx(List, TRUE );
    if( RetVal ) {
        InitializeListHead(&RetVal->List);
        InitializeListHead(&RetVal->HashList);

        // Reset the buffer in request context
        PacketSize = sizeof( PACKET );
        PacketSize = ROUND_UP_COUNT( PacketSize, ALIGN_WORST );
        RetVal->ReqContext.ReceiveBuffer = ( LPBYTE ) ( RetVal ) + PacketSize;
        RetVal->ReqContext.ReceiveBufferSize = DHCP_RECV_MESSAGE_SIZE;
        RetVal->ReqContext.pPacket = RetVal;

        DhcpAssert( FALSE == RetVal->fSocketLocked );
    }
    return RetVal;
} // DeleteFreePacket()

static                                  //  The space for these three pointers..
LIST_ENTRY ActiveQSpace, PingRetryQSpace, PingRetriedQSpace;

DWORD  STATIC                           //  Win32 errors
InitQData(                              //  Initialize DataStrucs for this file
    VOID
) {
    int   i;
    DWORD Error = ERROR_SUCCESS;

    ActiveQ = &ActiveQSpace;            //  should we do alloc or use
    PingRetryQ = &PingRetryQSpace;      //  static variables like this?
    PingRetriedQ = &PingRetriedQSpace;

    InitializeListHead( &FreeQ );
    InitializeListHead( ActiveQ);
    InitializeListHead( PingRetryQ );
    InitializeListHead( PingRetriedQ );
    InitHashQ();
    try {
        InitializeCriticalSection(&PacketCritSection);
    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // shouldnt happen, but one never knows..
        //

        Error = GetLastError( );
        return Error;
    }

    for( i = 0; i < Q_INIT_SIZE ; i ++ ) {
        LPPACKET     Packet;

        Packet = AllocateFreePacket();
        if( NULL == Packet )
            return ERROR_NOT_ENOUGH_MEMORY;

        InsertFreePacket( &FreeQ, Packet );
    }

    return ERROR_SUCCESS;
} // InitQData()

VOID  STATIC
CleanupQData(                           //  Cleanup the memory used in this file
    VOID
) {
    LPPACKET   Packet;

    QLOCK();                            //  Must be able to lock -- Else problem!
    while( Packet = DeleteFreePacketEx( &FreeQ, FALSE )) {
        DhcpAssert( FALSE == Packet->fSocketLocked );
        FreeFreePacket( Packet );       //  Free memory..
    }
    DhcpPrint(( DEBUG_TRACE_CALLS, "Deleting ActiveQ elements ... \n" ));
    while( Packet = DeleteOldestElement( ActiveQ ) ) {
        if ( Packet->fSocketLocked ) {
            CountRwLockRelease( &SocketRwLock );
        }
        FreeFreePacket( Packet );
    }
    DhcpPrint(( DEBUG_TRACE_CALLS, "Deleting PingRetryQ elements ... \n" ));
    while( Packet = DeleteOldestElement( PingRetryQ ) ) {
        HandlePingAbort(Packet->PingAddress, Packet->DestReachable);
        if ( Packet->fSocketLocked ) {
            CountRwLockRelease( &SocketRwLock );
        }
        FreeFreePacket( Packet );
    }
    DhcpPrint(( DEBUG_TRACE_CALLS, "Deleting PingRetriedQ elements ... \n" ));
    while( Packet = DeleteOldestElement( PingRetriedQ ) ) {
        HandlePingAbort(Packet->PingAddress, Packet->DestReachable);
        if ( Packet->fSocketLocked ) {
            CountRwLockRelease( &SocketRwLock );
        }
        FreeFreePacket( Packet );
    }

    DeleteCriticalSection(&PacketCritSection);
    CleanupHashQ();
} // CleanupQData()

VOID
UnlockAndFreePacket(
    LPPACKET pPacket,
    BOOL fLockQueue
)
{
    DhcpAssert( NULL != pPacket );

    DhcpPrint(( DEBUG_TRACE_CALLS, "Freeing packet : %p\n", pPacket ));

    if ( pPacket->fSocketLocked ) {
        CountRwLockRelease( &SocketRwLock );
    }
    pPacket->fSocketLocked = FALSE;
    if (( fLockQueue ) && ( pPacket->fSocketLocked )) {
        QLOCK();
        InsertFreePacket( &FreeQ, pPacket );
        QUNLOCK();
    }
    else {
        InsertFreePacket( &FreeQ, pPacket );
    }
} // UnlockAndFreePacket()


VOID
ProcessReceivedPacket(
    LPPACKET pPacket
)
{

    DWORD      Error;
    LPPACKET   pMatchedPkt = NULL;

    QLOCK();
    do {

        // Check if this is a duplicate packet
        if ( ERROR_SUCCESS == SearchHashQ (pPacket, &pMatchedPkt) ) {
            //  Found this packet in the hash queue.. drop incoming packet
            InterlockedIncrement( &DhcpGlobalNumPacketsDuplicate );
            DhcpAssert( NULL != pMatchedPkt );
            Stats.NActiveDropped++;

            QUNLOCK();
            CALLOUT_DROPPED( pPacket, DHCP_DROP_DUPLICATE);
            CALLOUT_DROPPED( pPacket, DHCP_DROP_PROCESSED);

            DhcpPrint(( DEBUG_TRACE_CALLS, "Dropping duplicate packet : %p\n", pPacket ));
            UnlockAndFreePacket( pPacket, TRUE );
            break;
        } // if duplicate


        Error = InsertHashQ( pPacket );
        DhcpAssert( ERROR_SUCCESS == Error );

        Stats.NServiced++;
        pPacket->PacketType = PACKET_ACTIVE;

        // Add to the work queue.
        if ( !InsertElement( ActiveQ, pPacket )) {

            // not expected
            DhcpAssert( FALSE );

            Error = DeleteHashQ( pPacket );
            if ( pPacket->fSocketLocked ) {
                DhcpPrint(( DEBUG_TRACE_CALLS, "Releasing read lock since couldn't add to ActiveQ : %d\n",
                            SocketRwLock.LockCount ));
            }

            DhcpAssert( ERROR_SUCCESS == Error );
            ThreadTrace( "Dropped active packet as activeQ too long\n" );

            CALLOUT_DROPPED( pPacket, DHCP_DROP_INTERNAL_ERROR );
            // also notify that this packet was processed
            CALLOUT_DROPPED( pPacket, DHCP_DROP_PROCESSED);

            UnlockAndFreePacket( pPacket, FALSE );

            QUNLOCK();
            break;
        } // if adding to work queue

        // Finish book keeping tasks...

        InterlockedIncrement( &DhcpGlobalNumPacketsInActiveQueue );
        NotifyProcessingLoop();
        QUNLOCK();
    } while ( FALSE );

} // ProcessReceivedPacket()

VOID STATIC
MessageLoop(
   VOID
)
{

    LPPACKET pPacket;
    DWORD Error;
    BOOL ProcessIt;


    ThreadTrace( "Starting message Loop\n" );

    while ( TRUE ) {

        // Get a packet to receive the message
        QLOCK();
        pPacket = DeleteFreePacket( &FreeQ );
        QUNLOCK();

        // Low mem conditions can return NULL, so wait till we get some memory
        if ( NULL == pPacket ) {
            ( void ) SwitchToThread();
            continue;
        }

        // Prepare the packet
        pPacket->fSocketLocked = FALSE;
        pPacket->PingAddress = 0;
        pPacket->DestReachable = 0;
        pPacket->ReqContext.ReceiveBuffer =
            ROUND_UP_COUNT( sizeof( PACKET ), ALIGN_WORST ) + ( LPBYTE ) pPacket;

        // Receive the packet
        Error = DhcpMessageWait( pPacket );

        pPacket->ReqContext.TimeArrived = GetCurrentTime();

        DhcpPrint(( DEBUG_TRACE_CALLS, "DhcpMessageWait( %p ) returned : %d\n",
                    pPacket, Error ));

        // Are we quitting?
        if ( DhcpTerminated()) {

            if ( ERROR_SUCCESS == Error ) {
                CALLOUT_DROPPED( pPacket, DHCP_DROP_PROCESSED );
            } // if
            pPacket->PacketType = PACKET_ACTIVE;

            DhcpPrint(( DEBUG_TRACE_CALLS, "Freeing %p since quitting \n", pPacket ));
            // Put this back in to the free Q
            UnlockAndFreePacket( pPacket, TRUE );

            break;
        } // if quitting


        // Did we successfully receive a packet?
        if ( ERROR_SUCCESS == Error ) {
            InterlockedIncrement( &DhcpGlobalNumPacketsReceived );
            ProcessIt = TRUE;
            pPacket->CalloutContext = NULL;

            CALLOUT_NEWPKT( pPacket, &ProcessIt );
            if ( FALSE == ProcessIt ) {
                CALLOUT_DROPPED( pPacket, DHCP_DROP_PROCESSED );
                ThreadTrace( "Callout dropped a packet\n" );

                DhcpAssert( TRUE == pPacket->fSocketLocked );
                UnlockAndFreePacket( pPacket, TRUE );

                continue;
            } // if callout dll rejected this
        } // if received a packet
        else {
            if ( ERROR_SEM_TIMEOUT == Error ) {
                ThreadTrace( "Sockets timeout -- No messages\n" );
            }

            if ( ERROR_DEV_NOT_EXIST == Error ) {
                ThreadTrace( "Socket vanished underneath (PnP). Ignored\n" );
            }


            if ( ERROR_SUCCESS != Error ) {
                ThreadTrace2( "Waiting for message, Error: %ld\n", Error );
            }

            UnlockAndFreePacket( pPacket, TRUE );

            continue;
        } // else

        // Add this to the active Q
        DhcpPrint(( DEBUG_TRACE_CALLS, "Processing packet : %p\n", pPacket ));
        ProcessReceivedPacket( pPacket );

    } // while

    ThreadTrace( "Message loop is quitting\n" );

} // MessageLoop()

VOID  STATIC                            //  Multithreaded main loop for handling messages
ProcessingLoop(                         //  Pickout requests and dispatch them
    VOID                                //  No parameters
) {
    LPBYTE              SendBuffer;     //  Need a buffer to send messages
    DWORD               SendBufferSize; //  The size of above buffer in bytes
    LPPACKET            P;              //  The current packet being looked at
    BOOL                Terminate;
    DWORD               Error;

    SendBufferSize = DHCP_SEND_MESSAGE_SIZE;
    SendBuffer = DhcpAllocateMemory( SendBufferSize );

    if( NULL == SendBuffer ) {          //  Need this buffer to be able to send stuff out
        ThreadAlert("Could not allocate send buffer\n");
        return ;                        //  ERROR_NOT_ENOUGH_MEMORY
    }

    ThreadTrace("Starting processing loop\n");
    while( TRUE ) {                     //  Main loop
        Terminate = FALSE;
        Error = DhcpNotifiedAboutMessage(&Terminate);

        if( ERROR_SUCCESS != Error ) {  //  Nothing much to do if this fails
            ThreadTrace2("Notification failed : %ld\n", Error );
            continue;
        }
        if( Terminate ) {               //  If asked to quit, make sure we put packet back in
            DhcpFreeMemory(SendBuffer); //  Free our local buffers..
            break;
        }


        while( TRUE ) {
            QLOCK();                    //  Q's are del'ed in rev order compared to MsgLoop
            P = DeleteOldestElement( PingRetriedQ);
            if( NULL != P ) {
                InterlockedDecrement( &DhcpGlobalNumPacketsInPingQueue );
            } else {
                P = DeleteOldestElement( ActiveQ);
                if( NULL != P ) InterlockedDecrement( &DhcpGlobalNumPacketsInActiveQueue);
            }

            QUNLOCK();

            if( NULL == P ) break;      //  We finished all elements

            P->ReqContext.SendBuffer = SendBuffer;
            P->ReqContext.SendMessageSize = SendBufferSize;
	    P->ReqContext.fNak = FALSE;

            if( PACKET_ACTIVE == P->PacketType ) {
                ThreadTrace2("Processing active packet : %p\n", P );
            }
            else {
                ThreadTrace2( "Processing ping packet : %p\n", P );
            }
            ProcessPacket(P);           //  This automatically re-inserts the packet into Q's
            ThreadTrace2( "Processed packet : %p\n", P );
        }
    }

    ThreadTrace("ProcessingLoop quitting\n");
}

VOID
HandlePingAbort(                        //  Aborted address... Release address or mark bad
    IN      DWORD        IpAddress,     //  We did a ping against this address
    IN      BOOL         DestReachable  //  And this tells if this address was reachable
) {
    DWORD   Error, Status;
    PACKET  pkt, *P = &pkt;

    if( 0 == IpAddress ) return;        //  Nope we did not really do a ping

    ThreadTrace3(
        "Ping abort: %s, %s\n",
        inet_ntoa(*(struct in_addr *)&IpAddress),
        DestReachable? "TRUE" : "FALSE"
    );
    if( !DestReachable ) {              //  A sensible address
        Error = DhcpReleaseAddress(IpAddress);
        if( ERROR_SUCCESS != Error ) {
            //
            // Don't know if we are checking for BOOP or DHCP..
            //
            Error = DhcpReleaseBootpAddress( IpAddress );
        }
        DhcpAssert(ERROR_SUCCESS == Error);
        return;
    }

    P->PingAddress = IpAddress;         //  Mark this addresss bad by creating a dummy packet
    P->DestReachable = DestReachable;   //  structure and calling CreateClientEntry
    Error = DhcpCreateClientEntry(
        IpAddress,                      //  Ip address to mark bad
        (LPBYTE)&IpAddress,             //  Munged hw address, No hw address
        sizeof(IpAddress),              //  size is size of ip address
        DhcpCalculateTime(INFINIT_LEASE),//  Does not really matter
        GETSTRING(DHCP_BAD_ADDRESS_NAME),//  Machine name & info dont matter
        GETSTRING(DHCP_BAD_ADDRESS_INFO),//  ditto
        CLIENT_TYPE_DHCP,               //  Dont care about client type
        (-1),                           //  Server address?
        ADDRESS_STATE_DECLINED,         //  Address state?
        TRUE                            //  Open existing? D
    );

    DhcpAssert( ERROR_SUCCESS == Error);
}

DWORD
DoIcmpRequestForDynBootp(
    IN      ULONG                  IpAddress,
    IN      LPBYTE                 HwAddr,
    IN      ULONG                  HwLen,
    IN      VOID                   (*Callback)(ULONG IpAddres, LPBYTE HwAddr, ULONG HwLen, BOOL Reachable)
)
{
    ULONG                          Error;
    LPPACKET                       P;

    QLOCK();
    P = DeleteFreePacket( &FreeQ );
    QUNLOCK();
    if( NULL == P ) return ERROR_NOT_ENOUGH_MEMORY;

    P->PingAddress = htonl(IpAddress);
    P->PacketType = PACKET_DYNBOOT;
    // Use the receive buffer in the request context to hold the
    //  variable length client id.
    P->ClientId = P->ReqContext.ReceiveBuffer;

    memcpy( P->ClientId, HwAddr, HwLen);
    P->ClientIdSize = (BYTE)HwLen;
    P->Callback = Callback;

    Error = DoIcmpRequestEx(P->PingAddress, P, 3);
    if( ERROR_SUCCESS != Error ) {
        QLOCK();
        InsertFreePacket( &FreeQ, P );
        QUNLOCK();
    }
    return Error;
}

VOID                                    //  No return values
HandleIcmpResult(                       //  After a ping is finished, it comes here
    IN      DWORD        PingAddressIn, //  The Address that was pinged
    IN      BOOL         DestReachable, //  Was the Destination reachable?
    IN      LPPACKET     P              //  This is the packet that we were dealing with
)
{
    LPPACKET             P2;
    DWORD                PingAddress, Error;

    if( P->PacketType == PACKET_DYNBOOT ) {
        //
        // Handle dynamic bootp result..
        //
        P->Callback(
            ntohl(P->PingAddress), P->ClientId, P->ClientIdSize, DestReachable
            );
        UnlockAndFreePacket( P, TRUE );
        return ;
    }

    PingAddress = htonl(PingAddressIn);

    ThreadTrace("StartIcmpResult\n");
    QLOCK();
    if( P->PingAddress != PingAddress || P->PacketType != PACKET_PING ) {
        ThreadTrace("Ping reply too late\n");
        InterlockedDecrement(&DhcpGlobalNumPacketsInPingQueue);
        HandlePingAbort(PingAddress, DestReachable);
        goto EndFunc;                   //  We already killed this packet
    }

    Error = SearchHashQ(P, &P2);
    if( ERROR_SUCCESS != Error ) {      //  This packet was dropped and re-used
        DhcpAssert(FALSE);              //  Cannot happen.
        ThreadTrace("Ping reply too late!\n");
        InterlockedDecrement( &DhcpGlobalNumPacketsInPingQueue );
        HandlePingAbort(PingAddress, DestReachable);
        goto EndFunc;
    }
    DhcpAssert( P2 == P );              //  Must get this exact packet!

    RemoveEntryList(&P->List);          //  Remove this element from the PingRetryQ
    InitializeListHead(&P->List);       //  Fit in this list correctly

    P->PacketType = PACKET_PINGED;      //  Completed ping request
    P->DestReachable = DestReachable;   //  Was the destination actually reachable?

    ThreadTrace3("%s %s reachable\n",
                 inet_ntoa(*(struct in_addr *)&PingAddressIn),
                 DestReachable? "is" : "is not"
                 );
    if(!InsertElement(PingRetriedQ, P)){//  Will be handled by the ProcessingLoop
        DhcpAssert(FALSE);
        HandlePingAbort(PingAddress, DestReachable);
        Error = DeleteHashQ(P);
        if ( P->fSocketLocked ) {
            DhcpPrint(( DEBUG_TRACE_CALLS, "Releasing read lock since adding to PingRetriedQ failed : p = %p, %d\n",
                        P, SocketRwLock.LockCount ));
        }
        UnlockAndFreePacket( P, FALSE );
        DhcpAssert(ERROR_SUCCESS == Error);
        ThreadTrace("Dropped ping retried packet as Q too long\n");
    }

EndFunc:

    QUNLOCK();
    ThreadTrace("EndIcmpResult\n");
    NotifyProcessingLoop();             //  Notify the ProcessingLoop of new arrival
}

//================================================================================
//  Functions needed for IO Completion ports
//================================================================================
static
HANDLE      IoPort       = NULL;        //  The IO Completion Port that threads queue
static
LONG        nPendingReq  = 0;           //  The # of Pending IO Compl Port Requests
static
DWORD       nMaxWorkerThreads;          //  The maximum # of worker threads to run
static
DWORD       nActiveWorkerThreads;       //  Of these the # of threads that are active

// TEST 
static
LONG        postQueued = 0;
static      
LONG        getQueued  = 0;
// TEST


DWORD  STATIC                           //  Win32 errors
InitCompletionPort(                     //  Initialize completion ports
    IN      DWORD        nMaxThreads,   //  max # of threads
    IN      DWORD        nActiveThreads,//  max # of active threads
    IN      DWORD        QueueSize      //  The size of the message queue -- UNUSED
) {
    DWORD        i, Error, nProcessors;
    SYSTEM_INFO  SysInfo;

    GetSystemInfo(&SysInfo);            //  Get the # of processors on this machine
    nProcessors = SysInfo.dwNumberOfProcessors;
    DhcpAssert(nProcessors);

    if( 0xFFFFFFFF == nMaxThreads )     //  Unspecified # of total threads
        nMaxThreads = 1;                //  Assume it is 1 more than # processors
    if( 0xFFFFFFFF == nActiveThreads )  //  Unspecified # of active threads
        nActiveThreads = 0;             //  Assume as many as there are processors

    nMaxThreads += nProcessors;         //  Increment by # of processors
    nActiveThreads += nProcessors;

    if( nActiveThreads > nMaxThreads )
        return ERROR_NOT_ENOUGH_MEMORY;

    nMaxWorkerThreads = nMaxThreads;    //  Copy stuff into local variables
    nActiveWorkerThreads = nActiveThreads;

    ThreadTrace2("Created %ld completion ports\n", nActiveWorkerThreads);

    IoPort = CreateIoCompletionPort(    //  Create the completion ports
        INVALID_HANDLE_VALUE,           //  Overlap file handle
        NULL,                           //  Existing completion port
        0,                              //  Key
        nActiveWorkerThreads            //  # of concurrent active threads
    );

    if( NULL == IoPort ) {
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "Could not create io port: %ld\n", Error));
        return Error;
    }

    return ERROR_SUCCESS;
}

VOID  STATIC
CleanupCompletionPort(                  //  Cleanup last function
    VOID
) {
    if( NULL != IoPort) {
        CloseHandle(IoPort);
        IoPort = NULL;
    }
}


DWORD  STATIC                           //  Win32 errors
NotifyProcessingLoop(                   //  Post an IO Completion request about msg
    VOID
) {
    DhcpAssert(IoPort);                 //  Must have initialized IoPort

    if( InterlockedIncrement(&nPendingReq) > (LONG)nMaxWorkerThreads+1 ) {
        //
        // Too many requests done already.  Don't POST anything now..
        //

        InterlockedDecrement(&nPendingReq);

	DhcpPrint((DEBUG_ERRORS, "Too many pending requests : %ld\n", nPendingReq));
	// This return value is not used by anyone
	return 0;
    }

    // TEST
    // Update the postQueued count
    InterlockedIncrement(&postQueued);

    //TEST

    if(!PostQueuedCompletionStatus(IoPort, 0, 0, NULL)) {
        DWORD  Error = GetLastError();  //  This should not happen
        DhcpPrint((DEBUG_ERRORS, "Could not post to io port: %ld\n", Error));
        return Error;
    }
    return ERROR_SUCCESS;
}

DWORD                                   //  Win32 errors
DhcpNotifyWorkerThreadsQuit(            //  Post io comp request asking threads to quit
    VOID
) {
    if( !IoPort ) return ERROR_INVALID_PARAMETER;

    if(!PostQueuedCompletionStatus(IoPort, 0, 1, NULL)) {
        DWORD  Error = GetLastError();  //  Should not really happen
        DhcpPrint((DEBUG_ERRORS, "Could not post to io port: %ld\n", Error));
        return Error;
    }
    return ERROR_SUCCESS;
}

DWORD  STATIC                           //  Win32 errors
DhcpNotifiedAboutMessage(               //  Check if there is a message waiting
    OUT     BOOL        *Terminate      //  Has a terminate been issued?
) {
    DWORD Error, n;
    ULONG_PTR key;
    LPOVERLAPPED olap;

    DhcpAssert(IoPort);                 //  Expect to have initialized port
    if( !IoPort ) {                     //  If for some reason, something went wrong
        *Terminate = TRUE;              //  got to terminate!
        return ERROR_INVALID_PARAMETER;
    }

    (*Terminate) = FALSE;

    if( DhcpTerminated() ) {            //  Quit, when the terminate signal is up
        (*Terminate) = TRUE;            //  This is one way to signal termination
        DhcpNotifyWorkerThreadsQuit();  //  Pass this notificatioin to all other threads
        return ERROR_SUCCESS;
    }

    // TEST
    // update getQueued count

    InterlockedIncrement(&getQueued);
    // TEST

    if(!GetQueuedCompletionStatus(IoPort, &n, &key, &olap, INFINITE)) {
        Error = GetLastError();         //  Could not get notification?
        DhcpPrint((DEBUG_ERRORS, "GetQueuedStatus = %ld\n", Error));
        return Error;
    }

    InterlockedDecrement(&nPendingReq);
    DhcpAssert(key == 0 || key == 1);   //  key:0 => normal message, 1 => Termination
    if(key == 1) {                      //  Asked to terminate
        (*Terminate) = TRUE;
        (void)DhcpNotifyWorkerThreadsQuit();
    }

    return ERROR_SUCCESS;
} // DhcpNotifiedAboutMessage()

//================================================================================
//  Some helper functions
//================================================================================
BOOL  STATIC                            //  TRUE==>Terminated
DhcpTerminated(                         //  Has termination been signaled?
    VOID
) {                                     //  no error cases handled ?
    //
    // We can look at the terminate event here.. but then, this var is also equally
    // good .. so lets opt for the faster solution.
    //

    return DhcpGlobalServiceStopping;
}

DWORD  STATIC                           //  Win32 errors
DhcpMessageWait(                        //  Wait until something happens on some socket
    IN      LPPACKET     Packet         //  This is where the incoming packet will be stored
) {                                     //  For more info on this fn, see ExtractOptions
    DWORD                Error, RecvMessageSize, Hwlen;
    LPBYTE               Start,EndOfMessage,MagicCookie;

    Error = DhcpWaitForMessage( &Packet->ReqContext);

    if( ERROR_SUCCESS != Error ) {
        // release the socket lock since we no longer need this.
        DhcpPrint(( DEBUG_THREAD, "DhcpWaitFormessage() returned error : %d\n", Error ));
        return Error;
    }

    if (FALSE == Packet->ReqContext.fMadcap) {

        LPDHCP_MESSAGE       RecvMessage;   //  DataBuffer to the message received
        LPBYTE               currentOption, nextOption;
        RecvMessage = (LPDHCP_MESSAGE)Packet->ReqContext.ReceiveBuffer;
        RecvMessageSize = Packet->ReqContext.ReceiveMessageSize;

        Packet->Xid = RecvMessage->TransactionID;
        Packet->HWAddrType = RecvMessage->HardwareAddressType;
        Hwlen = RecvMessage->HardwareAddressLength;
        if( Hwlen > sizeof(Packet->Chaddr) ) {
            //
            // Insufficient space for hardware address...
            // HWLEN is invalid!
            //
            return ERROR_DHCP_INVALID_DHCP_MESSAGE;
        }

        memcpy(Packet->Chaddr, RecvMessage->HardwareAddress, Hwlen);
        memset(Packet->Chaddr+ Hwlen, 0, sizeof(Packet->Chaddr) - Hwlen);
        Packet->ClientId = "" ;             //  dont use NULL, because we cant do strncmp
        Packet->ClientIdSize = 0;           //  but this empty string, we can do strncmp

        // Now do a minimal parse to get the ClientId of this client
        Start = (LPBYTE) RecvMessage;
        EndOfMessage = Start + RecvMessageSize -1;
        currentOption = (LPBYTE)&RecvMessage->Option;

        if( Start + RecvMessageSize <= currentOption ) {
            return ERROR_DHCP_INVALID_DHCP_MESSAGE ;
        }

        if ( Start + RecvMessageSize == currentOption ) {
            // this is to take care of the bootp clients which can send
            // requests without vendor field filled in.

            return ERROR_SUCCESS;
        }

        MagicCookie = currentOption;

        if( (*MagicCookie != (BYTE)DHCP_MAGIC_COOKIE_BYTE1) ||
            (*(MagicCookie+1) != (BYTE)DHCP_MAGIC_COOKIE_BYTE2) ||
            (*(MagicCookie+2) != (BYTE)DHCP_MAGIC_COOKIE_BYTE3) ||
            (*(MagicCookie+3) != (BYTE)DHCP_MAGIC_COOKIE_BYTE4))
        {
            // this is a vendor specific magic cookie.

            return ERROR_SUCCESS;
        }

        currentOption = MagicCookie + 4;
        while ( (currentOption <= EndOfMessage) &&
                currentOption[0] != OPTION_END &&
                (currentOption+1 <= EndOfMessage) ) {

            if ( OPTION_PAD == currentOption[0] )
                nextOption = currentOption +1;
            else  nextOption = currentOption + currentOption[1] + 2;

            if ( nextOption  > EndOfMessage+1 ) {
                return ERROR_SUCCESS;
            }

            if( OPTION_CLIENT_ID == currentOption[0] ) {
                DWORD   len;
                if ( currentOption[1] > 1 ) {
                    Packet->HWAddrType = currentOption[2];
                }

                if ( currentOption[1] > 2 ) {
                    Packet->ClientIdSize = currentOption[1] - sizeof(BYTE);
                    Packet->ClientId = currentOption + 2 + sizeof(BYTE);
                }

                if( Packet->ClientIdSize < sizeof(Packet->Chaddr))
                    len = Packet->ClientIdSize;
                else len = sizeof(Packet->Chaddr);

                // if we find a client-id, copy it to hw addr (erase what was there)
                memcpy(Packet->Chaddr, Packet->ClientId, len);
                memset(&Packet->Chaddr[len], 0, sizeof(Packet->Chaddr)-len);

                break;
            }
            currentOption = nextOption;
        }

    } else {
        WIDE_OPTION UNALIGNED*         NextOpt;
        BYTE        UNALIGNED*         EndOpt;
        DWORD                          Size;
        DWORD                          OptionType;
        LPMADCAP_MESSAGE               RecvMessage;   //  DataBuffer to the message received


        RecvMessage = (LPMADCAP_MESSAGE)Packet->ReqContext.ReceiveBuffer;
        RecvMessageSize = Packet->ReqContext.ReceiveMessageSize;

        // MBUG : Duplicating option parsing code is really ugly here
        Packet->Xid = RecvMessage->TransactionID;
        Packet->HWAddrType = 0;


        EndOpt = (LPBYTE) RecvMessage + RecvMessageSize;              // all options should be < EndOpt;
        NextOpt = (WIDE_OPTION UNALIGNED*)&RecvMessage->Option;
        //
        // Check sizes to see if the fixed size header part exists or not.

        if( RecvMessageSize < MADCAP_MESSAGE_FIXED_PART_SIZE ) {
            return( ERROR_DHCP_INVALID_DHCP_MESSAGE );
        }

        while( NextOpt->OptionValue <= EndOpt &&
               MADCAP_OPTION_END != (OptionType = ntohs(NextOpt->OptionType)) ) {

            Size = ntohs(NextOpt->OptionLength);
            if ((NextOpt->OptionValue + Size) > EndOpt) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }

            // Now do a minimal parse to get the ClientId of this client
            if( MADCAP_OPTION_LEASE_ID == OptionType ) {
                DWORD   len;

                Packet->ClientIdSize = (BYTE)Size;
                Packet->ClientId = (LPBYTE)NextOpt->OptionValue;

                if( Packet->ClientIdSize < sizeof(Packet->Chaddr))
                    len = Packet->ClientIdSize;
                else len = sizeof(Packet->Chaddr);

                // if we find a client-id, copy it to hw addr (erase what was there)
                memcpy(Packet->Chaddr, Packet->ClientId, len);
                memset(&Packet->Chaddr[len], 0, sizeof(Packet->Chaddr)-len);

                break;
            }
            NextOpt = (WIDE_OPTION UNALIGNED*)(NextOpt->OptionValue + Size);
        }

    }

    return ERROR_SUCCESS;
}

BOOL  STATIC                            //  TRUE==>Same src both packets
ExactMatch(                             //  Are these two pckts from same source?
    IN      LPPACKET     Packet1,       //  First packet
    IN      LPPACKET     Packet2        //  second packet
)
{
    LPBYTE  B1, B2;
    BOOL Check;
    PDHCP_MESSAGE M1, M2;
    PDHCP_REQUEST_CONTEXT Req1, Req2;

    // First make sure we are not mixing MADCAP  and DHCP
    if (Packet1->ReqContext.fMadcap != Packet2->ReqContext.fMadcap ) {
        return FALSE;
    }
    B1 = (LPBYTE) &Packet1->Xid;
    B2 = (LPBYTE) &Packet2->Xid;

    if( 0 != memcmp(B1, B2, HASH_PREFIX ) )
        return FALSE;                   //  Mismatch in basic check

    Check = ( Packet1->ClientIdSize == Packet2->ClientIdSize &&
             0 == memcmp(Packet1->ClientId, Packet2->ClientId, Packet1->ClientIdSize)
    );
    if( FALSE == Check ) return FALSE;
    // If this is MADCAP Packet that is all we need to compare.
    else if (Packet1->ReqContext.fMadcap ) return TRUE;
    //
    // Now check subnets of origin as well as GIADDRs.
    //
    M1 = (PDHCP_MESSAGE) Packet1->ReqContext.ReceiveBuffer;
    M2 = (PDHCP_MESSAGE) Packet2->ReqContext.ReceiveBuffer;

    if( M1->RelayAgentIpAddress != M2->RelayAgentIpAddress ) {
        return FALSE;
    }

    Req1 = &Packet1->ReqContext;
    Req2 = &Packet2->ReqContext;

    return ( ( Req1->EndPointMask & Req1->EndPointIpAddress )
             ==
             ( Req2->EndPointMask & Req1->EndPointIpAddress )
             );
}

VOID  STATIC
ProcessPacket(                          //  Handle a packet, and call the right function
    IN      LPPACKET     Packet         //  The input packet to process
) {
    DWORD   Error, Status;
    BOOL    TimedOuT;
    ULONG ProcessingTime;

    Error = Status = ERROR_SUCCESS;
    if( 0 == Packet->PingAddress &&     //  Fresh packet, can be thrown depending on timeout
        GetCurrentTime() >= Packet->ReqContext.TimeArrived + 1000* MAX_MSG_IN_Q_TIME) {
        // If a Ping had been done, then the address would have been marked.  So,
        // handle this case.
        HandlePingAbort(Packet->PingAddress, Packet->DestReachable);
        CALLOUT_DROPPED(Packet, DHCP_DROP_TIMEOUT);
        InterlockedIncrement( &DhcpGlobalNumPacketsExpired );
        DhcpPrint((DEBUG_ERRORS, "A packet has been dropped (timed out)\n"));
    } else if( !DhcpGlobalOkToService ) {
        DhcpPrint((DEBUG_ERRORS, "Dropping packets as not authorized to process\n"));
        CALLOUT_DROPPED(Packet, DHCP_DROP_UNAUTH);
        HandlePingAbort(Packet->PingAddress, Packet->DestReachable);
    } else {
        DhcpAcquireReadLock();
        Packet->ReqContext.Server = DhcpGetCurrentServer();
        Packet->ReqContext.Subnet = NULL;
        Packet->ReqContext.Range = NULL;
        Packet->ReqContext.Excl = NULL;
        Packet->ReqContext.Reservation = NULL;
        if (Packet->ReqContext.fMadcap) {
            Error = ProcessMadcapMessage( &Packet->ReqContext, Packet, &Status);
        } else {
            Error = ProcessMessage( &Packet->ReqContext, Packet, &Status);
        }
        (void)DhcpRegFlushServerIfNeeded();
        DhcpReleaseReadLock();
    }

    ProcessingTime = GetCurrentTime() - Packet->ReqContext.TimeArrived;
    QLOCK();
    switch(Status) {
    case ERROR_SUCCESS:                 //  Everything went well, plug it back into freeQ
        CALLOUT_DROPPED(Packet, DHCP_DROP_PROCESSED);
        DeleteHashQ(Packet);
        if ( Packet->fSocketLocked ) {
            DhcpPrint(( DEBUG_TRACE_CALLS, "Releasing Read lock for packet %p: back to FreeQ : %d\n",
                        Packet, SocketRwLock.LockCount ));
        }
        UnlockAndFreePacket( Packet, FALSE );
        break;
    case ERROR_IO_PENDING:              //  Need to ping something!
        Packet->PacketType = PACKET_PING;
        if(!InsertElement( PingRetryQ, Packet)) {
            CALLOUT_DROPPED(Packet, DHCP_DROP_PROCESSED);
            DhcpAssert(FALSE);
            DeleteHashQ(Packet);
            if ( Packet->fSocketLocked ) {
                DhcpPrint(( DEBUG_TRACE_CALLS, "Releasing Read lock for packet %p: adding to PingRetryQ : %d\n",
                            Packet, SocketRwLock.LockCount ));
            }
            UnlockAndFreePacket( Packet, FALSE );
            ThreadTrace("Could not process ping retry packet as Q too long\n");
        }
        InterlockedIncrement( &DhcpGlobalNumPacketsInPingQueue );
        break;
    default:
        ASSERT(FALSE);                  //  Should not happen
    }
    QUNLOCK();

    if( ERROR_IO_PENDING == Status ) {  //  Ok do the ping out side the lock as this can block
        DoIcmpRequest(ntohl(Packet->PingAddress), Packet);
    } else {
        InterlockedExchangeAdd( &DhcpGlobalNumMilliSecondsProcessed, ProcessingTime );
        InterlockedIncrement( &DhcpGlobalNumPacketsProcessed );
    }

    return;
} // ProcessPacket()

//================================================================================
//  Module Initialization and cleanup
//================================================================================
static
DWORD       InitLevel = 0;              //  How much of init. has been completed

DWORD                                   //  Win32 errors
ThreadsDataInit(                        //  Initialize everything in this file
    IN      DWORD        nMaxThreads,   //  Max # of processing threads to start
    IN      DWORD        nActiveThreads //  Of this how many can run at a time
) {
    DWORD   Error;

    Error = InitCompletionPort(         //  First Initialize completion ports
        nMaxThreads,
        nActiveThreads,
        0                               //  This parameter is no longer in use
    );
    InitLevel++;

    if( ERROR_SUCCESS != Error )
        return Error;

    Error = InitQData();                //  Now initialize the lists and arrays
    InitLevel++;

    return Error;
}

VOID
ThreadsDataCleanup(                     //  Cleanup everything done in this file
    VOID
) {
    if( !InitLevel ) return;            //  Did not initialize anything beyond this
    InitLevel--;

    CleanupCompletionPort();            //  Cleanup completion ports
    if( !InitLevel ) return;            //  Did not initialize anything beyond this
    InitLevel--;

    CleanupQData();                     //  Cleanup Q structures

    DhcpAssert(0 == InitLevel);         //  Since there is no known cleanup
}

static
HANDLE      ThreadHandles[MAX_THREADS]; //  The handles of the threads created
static
DWORD       nThreadsCreated = 0;        //  # of threads created

//================================================================================
//  This call must be preceded by ThreadsDataInit, PingStartup, and by
//  Database Initialization -- preferably in that order.
//================================================================================
DWORD                                   //  Win32 errors
ThreadsStartup(                         //  Start the requisite # of threads
    VOID
) {
    DWORD   i, count, ThreadId, Error;
    HANDLE  ThreadHandle;

    if( nMaxWorkerThreads >= MAX_THREADS )
        nMaxWorkerThreads = MAX_THREADS -1;

    for( i = 0 ; i < nMaxWorkerThreads; i ++ ) {
        ThreadHandle = CreateThread(    //  Create Each of the threads
            NULL,                       //  No security attributes
            0,                          //  Same size as primary thread of process
            (LPTHREAD_START_ROUTINE)ProcessingLoop,
            NULL,                       //  No parameters to this function
            0,                          //  Run immediately
            &ThreadId                   //  We dont really care about this
        );

        if( NULL == ThreadHandle ) {    //  Function Failed
            Error = GetLastError();     //  Print the error and return it
            DhcpPrint((DEBUG_ERRORS, "CreateThread(processingloop): %ld\n", Error));
            return Error;
        }
        ThreadHandles[nThreadsCreated++] = ThreadHandle;
    }

    ThreadHandle = CreateThread(        //  Create thread for message loop
        NULL,                           //  No security
        0,                              //  same stack size as primary thread
        (LPTHREAD_START_ROUTINE) MessageLoop,
        NULL,                           //  No parameter
        0,                              //  Run rightaway
        &ThreadId                       //  We dont really care about this
    );

    if( NULL == ThreadHandle ) {        //  Could not create thread
        Error = GetLastError();         //  Print the error and return it
        DhcpPrint((DEBUG_ERRORS, "CreateThread(MessageLoop): %ld\n", Error));
        return Error;
    }

    ThreadHandles[nThreadsCreated++] = ThreadHandle;

    return ERROR_SUCCESS;               //  Everything went fine
}

//================================================================================
//  This function must be called before calling PingStop and ThreadsDataCleanup.
//================================================================================
VOID
ThreadsStop(                            //  Stop all the threads
    VOID
) {
    DWORD   i, Error;
    DhcpNotifyWorkerThreadsQuit();      //  Ask all worker threads to quit

    ThreadTrace("Notified worker threads.. should quit soon\n");
    for( i = 0; i < nMaxWorkerThreads; i ++ ) {
        if (ThreadHandles[i] != NULL) {
            ThreadTrace2("Waiting for thread %ld to be done\n", i);
            if( WAIT_OBJECT_0 != WaitForSingleObject(ThreadHandles[i], INFINITE )) {
                Error = GetLastError();
                DhcpPrint((DEBUG_ERRORS, "Error (threadwait to die): %ld\n", Error));

                //
                // error occurred.
                // removed reference to terminate thread, BINL may be 
                // affected. Exit anyway.
                //

            }
            CloseHandle(ThreadHandles[i]);
            ThreadHandles[i] = NULL;
        }
    }
    nThreadsCreated = 0;
    nPendingReq  = 0;
    ThreadTrace("ThreadStop done\n");
} // ThreadStop()

//
// CleanupEndPoints() must be called prior to calling this function
//
VOID
WaitForMessageThreadToQuit(
   VOID
)
{
    DWORD Error;

    if ( NULL != ThreadHandles[ nMaxWorkerThreads ]) {
        ThreadTrace( "Waiting for message Thread to quit ..." );

        if ( WAIT_OBJECT_0 != WaitForSingleObject( ThreadHandles[ nMaxWorkerThreads ],
                                                   INFINITE )) {
            Error = GetLastError();

            DhcpPrint(( DEBUG_ERRORS,
                        "Error %ld while waiting for message thread to quit\n",
                        Error ));

        }

        CloseHandle( ThreadHandles[ nMaxWorkerThreads ]);
        ThreadHandles[ nMaxWorkerThreads ] = NULL;
    } // if

    ThreadTrace( " Done.\n" );

} // WaitForMessageThreadToQuit()
//================================================================================
//  End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\secretk.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:

   SecretK.C

Abstract:

   This module implements reading and writing secret keys using
   LSA secrets API.  Two APIs are provided to retrieve the values
   and set the values respectively.

   This is preliminary version for use by the DHCP server to store
   persistent information on whether Rogue detection ever succeeded
   and if so, when.

Author:

   Ramesh V (RameshV) 29-July-1998

--*/

#include <dhcppch.h>
#include <ntlsa.h>

#define  DHCP_SECRET_KEY            L"DhcpServer Secret Key For Rogue Detection"
#define  DHCP_SECRET_UNAME_KEY      L"DhcpServer Uname Key"
#define  DHCP_SECRET_DOMAIN_KEY     L"DhcpServer Domain Key"
#define  DHCP_SECRET_DNS_PASSWD_KEY L"DhcpServer Passwd Key"

#define  FTIME_TO_SEC_FACTOR       10000000
#define  DHCP_SERVER_AUTHORIZATION_VALIDITY_PERIOD (2*24*60*60)
#define  MAX_STRING_SIZE           260
#define  AUTH_FLAG_JUST_UPGRADED   0x01
#define  AUTH_FLAG_UNAUTHORIZED    0x02
#ifndef  DHCP_ENCODE_SEED
#define  DHCP_ENCODE_SEED          ((UCHAR)0xA5)
#endif

typedef struct {
    ULONG Flags;
    FILETIME TimeStamp;
    //
    // This is followed directly by WCHAR string
    // for the domain that the server was authorized/unauthorized
    // in the last time.
} AUTH_CACHE_INFO, *PAUTH_CACHE_INFO;

static
LSA_HANDLE GlobalPolicyHandle;

static
BOOL LsaInitialized = FALSE;

DWORD _inline
OpenPolicy(
    OUT LSA_HANDLE *PolicyHandle
)
{
    LSA_HANDLE hPolicy;
    DWORD status;
    OBJECT_ATTRIBUTES objectAttributes;

    (*PolicyHandle) = NULL;

    InitializeObjectAttributes(
        &objectAttributes,
        NULL,
        0L,
        NULL,
        NULL
    );

    status = LsaOpenPolicy(
        NULL,
        &objectAttributes,
        POLICY_WRITE | POLICY_READ |
        POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
        &hPolicy
    );

    if (status != STATUS_SUCCESS) {
        return LsaNtStatusToWinError(status);
    }

    (*PolicyHandle) = hPolicy;

    return ERROR_SUCCESS;
}

DWORD _fastcall
SetSecretValue(
    IN LPCWSTR KeyName,
    IN PVOID Buffer,
    IN LONG BufSize
)
/*++

Routine Description

    Set the secret value associated with the keyname using local
    system security policy.

Arguments

    KeyName - key name to use to set secret value

    Buffer - the secret value to set ..

    BufSize - the size of the buffer in bytes.  If this is zero
        the value would be deleted.

Return Value

    Win32 errors

--*/
{
    UNICODE_STRING LKey, Value;
    DWORD status;

    RtlInitUnicodeString(&LKey, KeyName);
    Value.Length = Value.MaximumLength = (USHORT)BufSize;
    Value.Buffer = Buffer;

    if ( FALSE == LsaInitialized ) {
        status = DhcpInitSecrets();
        if ( ERROR_SUCCESS != status ) {
            return status;
        }
    }

    DhcpAssert( NULL != GlobalPolicyHandle );

    status = LsaStorePrivateData( GlobalPolicyHandle, &LKey, &Value);

    return LsaNtStatusToWinError(status);

}

DWORD _inline
GetSecretValue(
    IN LPCWSTR KeyName,
    OUT PVOID Buffer,
    IN OUT PLONG BufSize
)
/*++

Routine Description

    Retrive the secret value with keyname as provided using local
    system security policy.

    If the return value requires more space than the buffer provided
    (BufSize initially has the space provided via Buffer) then return
    the space required in bytes in the BufSize parameter and return
    ERROR_INSUFFICIENT_BUFFER.

Arguments

    KeyName - provide the name of the key of interest.

    Buffer - provide the buffer that needs to be filled in with secret value.

    BufSize - on input this will the size of Buffer in bytes provided.
        In case of successful return, this will hold the actual number of
        bytes used.  If the routine returns ERROR_INSUFFICIENT_BUFFER then
        this will hold the size required.

Return Value

    ERROR_SUCCESS -- successfully copied the value.  If no value exists,
        (*BufSize) would be zero on return and function would return success.

    ERROR_INSUFFICIENT_BUFFER -- The size as provided by BufSize is not
        sufficient to do the full copy of the value.  On return BufSize will
        hold the actual size required.

    Other Win32 errors.

--*/
{
    UNICODE_STRING LKey, *pValue = NULL;
    DWORD status;

    RtlInitUnicodeString(&LKey, KeyName);

    if ( FALSE == LsaInitialized ) {
        status = DhcpInitSecrets();
        if ( ERROR_SUCCESS != status ) {
            return status;
        }
    }

    DhcpAssert( NULL != GlobalPolicyHandle );

    status = LsaRetrievePrivateData( GlobalPolicyHandle, &LKey, &pValue);

    if( STATUS_SUCCESS != status ) {
        return LsaNtStatusToWinError(status);
    }

    if( *BufSize >= pValue->Length ) {
        RtlCopyMemory( Buffer, pValue->Buffer, pValue->Length );
    } else {
        status = ERROR_INSUFFICIENT_BUFFER;
    }

    *BufSize = pValue->Length;
    LsaFreeMemory(pValue);

    return status;
}

BOOL
DhcpGetAuthStatus(
    IN LPWSTR DomainName,
    OUT BOOL *fUpgraded,
    OUT BOOL *fAuthorized
)
/*++

Routine Description:
    This routine checks to see if there is a registry cache entry for the
    given domain name.  If there isn't one for the given domain name, it
    returns FALSE. (In this case, the value for *fAuthorized is FALSE).

    If there is a registry cache entry for the given domain name, then the
    fAuthorized flag contains information on whether it is authorized or
    unauthorized.

    If the machine was just upgraded, then fAuthorized is fUpgraded is set
    to TRUE (This is independent of the return value of the function).

Arguments:
    DomainName -- name of domain to check authorization information
    fUpgraded -- was the machine just upgraded to NT5 ?
    fAuthorized -- is it authorized or unauthorized ?

Return Value:
    TRUE indicates a cache entry for the given domain was found (and the
    flag fAuthorized can be checked to see authorization status). 

--*/
{
    ULONG Error, AuthInfoSize;
    PAUTH_CACHE_INFO AuthInfo;
    BOOL fResult;
    LPWSTR CachedDomainName;
    FILETIME Diff, CurrentTime;

    (*fUpgraded) = (*fAuthorized) = FALSE;

    AuthInfo = NULL; AuthInfoSize = 0;
    Error = GetSecretValue(
        DHCP_SECRET_KEY,
        AuthInfo,
        &AuthInfoSize
        );
    if( ERROR_INSUFFICIENT_BUFFER != Error ) return FALSE;
    if( AuthInfoSize < sizeof(*AuthInfo)) return FALSE;

    AuthInfo = LocalAlloc( LPTR, AuthInfoSize );
    if( NULL == AuthInfo ) return FALSE;

    fResult = FALSE;
    do {
        Error = GetSecretValue(
            DHCP_SECRET_KEY,
            AuthInfo,
            &AuthInfoSize
            );
        if( ERROR_SUCCESS != Error ) break;
        if( AuthInfoSize < sizeof(*AuthInfo) ) break;

        (*fUpgraded) = ( AuthInfo->Flags & AUTH_FLAG_JUST_UPGRADED );
        CachedDomainName = (LPWSTR)(sizeof(*AuthInfo) + (LPBYTE)AuthInfo);

        if( NULL == DomainName ) break;

        if( (1 + wcslen(DomainName)) *sizeof(WCHAR) 
            != AuthInfoSize - sizeof(*AuthInfo) ) {
            break;
        }

        if( 0 != _wcsicmp( 
            DomainName, 
            CachedDomainName
            ) ) {
            break;
        }

        *(ULONGLONG *)&Diff = DHCP_SERVER_AUTHORIZATION_VALIDITY_PERIOD;
        *(ULONGLONG *)&Diff *= FTIME_TO_SEC_FACTOR;

        GetSystemTimeAsFileTime(&CurrentTime);
        (*(ULONGLONG *)&CurrentTime) -= *(ULONGLONG *)&Diff;

        if( CompareFileTime( &AuthInfo->TimeStamp, &CurrentTime ) < 0 ) {
            //
            // We've gone past the cache life
            //
            break;
        }

        (*fAuthorized) = (0 == ( AuthInfo->Flags & AUTH_FLAG_UNAUTHORIZED ));
        fResult = TRUE;

    } while ( 0 );
    LocalFree( AuthInfo );
    return fResult ;
}


DWORD
DhcpSetAuthStatus(
    IN LPWSTR DomainName OPTIONAL,
    IN BOOL fUpgraded,
    IN BOOL fAuthorized
)
/*++

Routine Description:
    This routine sets the registry cache information for authorization.  

Arguments:
    DomainName -- name of domain to set in the authorization info
    fUpgraded -- was this just upgraded to NT5?
    fAuthorized -- was this authorized or unauthorized ?

Return Value:
    Status

--*/
{
    AUTH_CACHE_INFO AuthInfoTmp;
    PAUTH_CACHE_INFO AuthInfo;
    ULONG Error;
    ULONG StringSize;

    StringSize = DomainName? (sizeof(WCHAR)*(1+wcslen(DomainName))):0;
    if( 0 == StringSize ) {
        AuthInfo = &AuthInfoTmp;
    } else {
        AuthInfo = LocalAlloc( LPTR, sizeof(*AuthInfo) + StringSize );
    }
    if( NULL == AuthInfo ) return ERROR_NOT_ENOUGH_MEMORY;

    AuthInfo->Flags = 0;
    if( fUpgraded ) AuthInfo -> Flags |= AUTH_FLAG_JUST_UPGRADED;
    if( !fAuthorized ) AuthInfo ->Flags |= AUTH_FLAG_UNAUTHORIZED;

    GetSystemTimeAsFileTime( &AuthInfo->TimeStamp );

    RtlCopyMemory(
        ( LPBYTE ) AuthInfo + sizeof( *AuthInfo ),
        DomainName,
        StringSize
        );

    Error = SetSecretValue(
        DHCP_SECRET_KEY,
        AuthInfo,
        StringSize + sizeof(*AuthInfo)
        );
    if( AuthInfo != &AuthInfoTmp ) {
        LocalFree(AuthInfo);
    }
    return Error;
}

VOID
DhcpSetAuthStatusUpgradedFlag(
    IN BOOL fUpgraded
)
/*++

Routine Description:
   This routine does not alter any cache information other
   than the just upgraded flag.

--*/
{
    ULONG Error, AuthInfoSize;
    PAUTH_CACHE_INFO AuthInfo;
    BOOL fResult;

    AuthInfo = NULL; AuthInfoSize = 0;
    Error = GetSecretValue(
        DHCP_SECRET_KEY,
        AuthInfo,
        &AuthInfoSize
        );
    if( ERROR_INSUFFICIENT_BUFFER != Error ||
        AuthInfoSize < sizeof( *AuthInfo ) ) {
        DhcpSetAuthStatus( NULL, fUpgraded, FALSE );
        return;
    }
    AuthInfo = LocalAlloc( LPTR, AuthInfoSize );
    if( NULL == AuthInfo ) {
        DhcpSetAuthStatus( NULL, fUpgraded, FALSE );
        return;
    }

    fResult = FALSE;
    do{
        Error = GetSecretValue(
            DHCP_SECRET_KEY,
            AuthInfo,
            &AuthInfoSize
            );
        if( ERROR_SUCCESS != Error ) break;
        if( AuthInfoSize < sizeof(*AuthInfo) ) break;
        if( fUpgraded ) {
            AuthInfo->Flags |= AUTH_FLAG_JUST_UPGRADED;
        } else {
            AuthInfo->Flags &= ~AUTH_FLAG_JUST_UPGRADED;
        }

        SetSecretValue(
            DHCP_SECRET_KEY,
            AuthInfo,
            AuthInfoSize
            );
        fResult = TRUE;
    } while ( 0 );

    if( FALSE == fResult ) {
        DhcpSetAuthStatus( NULL, fUpgraded, FALSE );
    }
    LocalFree( AuthInfo );
}

VOID
WINAPI
DhcpMarkUpgrade(
    VOID
)
/*++

Routine Description:
   This routine is to be called by the UPGRADE setup path when the machine
   has been upgraded to NT5 (and dhcp server is installed etc).
   It MUST NOT BE CALLED within DHCP.
   It automatically initializes this module and cleans up.

--*/
{
    ULONG Error;

    Error = DhcpInitSecrets();
    if( ERROR_SUCCESS == Error ) {
        Error = DhcpSetAuthStatus( NULL, TRUE, TRUE );
        ASSERT( ERROR_SUCCESS == Error );
        DhcpCleanupSecrets();
    }
}


DWORD
DhcpQuerySecretUname(
    IN OUT LPWSTR Uname,
    IN ULONG UnameLen,
    IN OUT LPWSTR DomainName,
    IN ULONG DomainNameLen,
    IN OUT LPWSTR Passwd,
    IN ULONG PasswdLen
    )
{
    DWORD Error;

    DWORD Len;

    ZeroMemory( Uname, sizeof( WCHAR ) * UnameLen );
    ZeroMemory( DomainName, sizeof( WCHAR ) * DomainNameLen );
    ZeroMemory( Passwd, sizeof( WCHAR ) * PasswdLen );

    if( UnameLen <= 0 ) return ERROR_INSUFFICIENT_BUFFER;
    if( DomainNameLen <= 0 ) return ERROR_INSUFFICIENT_BUFFER;

    Len = sizeof( WCHAR ) * UnameLen;
    Error = GetSecretValue(
        DHCP_SECRET_UNAME_KEY, Uname, &Len );
    if( ERROR_FILE_NOT_FOUND == Error ) {
        Uname[0] = L'\0';
        DomainName[0] = L'\0';
        return NO_ERROR;
    }

    if(NO_ERROR != Error ) return Error;

    Len = sizeof( WCHAR ) * DomainNameLen;
    Error = GetSecretValue(
        DHCP_SECRET_DOMAIN_KEY, DomainName, &Len );
    if( ERROR_FILE_NOT_FOUND == Error ) {
        DomainName[0] = L'\0';
        return NO_ERROR;
    }

    if ( NO_ERROR != Error ) return Error;

    Len = sizeof( WCHAR ) * PasswdLen;
    Error = GetSecretValue( 
        DHCP_SECRET_DNS_PASSWD_KEY, Passwd, &Len );
    if ( ERROR_FILE_NOT_FOUND == Error ) {
        Passwd[ 0 ] = L'\0';
        return NO_ERROR;
    }

    return Error;    
}

DWORD
GetAccountSid(
    IN LPWSTR AccountName,
    IN OUT PSID *pSid
    )
{
    BOOL fSuccess;
    DWORD Error, Size, DomSize;
    SID_NAME_USE unused;
    WCHAR DomainName[512];
    
    Size = 0;
    DomSize = sizeof(DomainName)/sizeof(DomainName[0]);
    fSuccess = LookupAccountName(
        NULL, AccountName, (*pSid), &Size, DomainName, &DomSize,
        &unused );
    
    Error = NO_ERROR;
    if( FALSE == fSuccess ) Error = GetLastError();

    if( ERROR_INSUFFICIENT_BUFFER != Error ) return Error;

    (*pSid ) = LocalAlloc( LPTR, Size );
    if( NULL == (*pSid )) return GetLastError();

    fSuccess = LookupAccountName(
        NULL, AccountName, (*pSid), &Size, DomainName, &DomSize,
        &unused );

    Error = NO_ERROR;
    if( FALSE == fSuccess ) Error = GetLastError();
    if( NO_ERROR != Error ) {
        LocalFree(*pSid);
        (*pSid) = NULL;
    }

    return Error;
}

DWORD
SetPrivilegeOnAccount(
    IN PSID pSid,
    IN LPWSTR Privilege
    )
{
    BOOL fEnable = TRUE;
    DWORD Error;
    LSA_UNICODE_STRING Str;

    Str.Buffer = Privilege;
    Str.Length = (USHORT)(lstrlenW(Privilege)*sizeof(WCHAR));
    Str.MaximumLength = Str.Length + sizeof(WCHAR);

    Error = LsaAddAccountRights(
        GlobalPolicyHandle, pSid, &Str, 1 );

    return LsaNtStatusToWinError( Error );
}

DWORD
VerifyAccount(
    IN LPWSTR Uname,
    IN LPWSTR DomainName,
    IN LPWSTR Passwd
    )
{
    DWORD Error;
#define ACCOUNT_NAME_SIZE 512
    WCHAR AccountName[ ACCOUNT_NAME_SIZE ];
    DWORD Rem, Len;
    PSID pSid = NULL;
    HANDLE hToken;

    //
    // Check if DomainName and Passwd fits ( 2 == '\\' + '\0' )
    //

    if ( ACCOUNT_NAME_SIZE < ( wcslen( Uname ) + wcslen( DomainName ) + 2 )) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Len = wcslen( DomainName );
    memcpy( AccountName, DomainName, Len * sizeof( WCHAR ));
    AccountName[ Len++ ] = '\\';
    memcpy( &AccountName[ Len ], Uname, ( 1 + wcslen( Uname )) * sizeof( WCHAR ));

    //
    // Check if lookup succeeds
    //

    Error = GetAccountSid( AccountName, &pSid );
    if( NO_ERROR != Error ) return Error;

    Error = SetPrivilegeOnAccount(pSid, L"SeServiceLogonRight"); 
    if( NO_ERROR != Error ) {
        if( NULL != pSid ) LocalFree( pSid );
        return Error;
    }

    Error = LogonUser(
        Uname, DomainName, Passwd, LOGON32_LOGON_SERVICE,
        LOGON32_PROVIDER_WINNT50, &hToken );
    if( FALSE == Error ) {
        Error = GetLastError();
    } else {
        Error = NO_ERROR;
    }

    if( NULL != pSid ) LocalFree( pSid );
    CloseHandle( hToken );
    return Error;
}

DWORD
DhcpSetSecretUnamePasswd(
    IN LPWSTR Uname,
    IN LPWSTR DomainName,
    IN LPWSTR Passwd
    )
{
    DWORD Error, Size;
    UNICODE_STRING Str;
    WCHAR LocalDomainName[300];
    
    if( NULL == Uname || Uname[0] == L'\0' ) {
        Error = SetSecretValue(
            DHCP_SECRET_UNAME_KEY, NULL, 0 );
        if( NO_ERROR != Error ) return Error;

        Error = SetSecretValue(
            DHCP_SECRET_DOMAIN_KEY, NULL, 0 );
        if( NO_ERROR != Error ) return Error;

        Error = SetSecretValue(
            DHCP_SECRET_DNS_PASSWD_KEY, NULL, 0 );
        return Error;
    }

    if( NULL == Passwd ) Passwd = L"";

    if( NULL == DomainName || DomainName[0] == L'\0' ) {
        //
        // Empty domain is local domain.
        //

        Size = sizeof(LocalDomainName)/sizeof(WCHAR);
        Error = GetComputerNameEx(
            ComputerNameDnsHostname, LocalDomainName, &Size );
        if( FALSE == Error ) return GetLastError();

        DomainName = (LPWSTR)LocalDomainName;
    }
        
    Str.Length = (USHORT)(wcslen(Passwd)*sizeof(WCHAR));
    Str.MaximumLength = Str.Length;
    Str.Buffer = (PVOID)Passwd;
    
    RtlRunDecodeUnicodeString( DHCP_ENCODE_SEED, &Str );

    Error =  VerifyAccount(Uname, DomainName, Passwd );
    if( NO_ERROR != Error ) {
	Error = ERROR_LOGON_FAILURE;
	goto Cleanup;
    }
        
    Size = sizeof(WCHAR)*(1+wcslen(Uname));

    Error = SetSecretValue(
        DHCP_SECRET_UNAME_KEY, Uname, Size );
    if( NO_ERROR != Error ) goto Cleanup;

    Size = sizeof(WCHAR)*(1+wcslen(DomainName));

    Error = SetSecretValue(
        DHCP_SECRET_DOMAIN_KEY, DomainName, Size );
    if( NO_ERROR != Error ) goto Cleanup;

    Size = sizeof(WCHAR)*(wcslen(Passwd));

    Error = SetSecretValue(
        DHCP_SECRET_DNS_PASSWD_KEY, Passwd, Size );

 Cleanup:

    SecureZeroMemory( Passwd, wcslen( Passwd ) * sizeof( WCHAR ));
    
    return Error;
}


DWORD
DhcpInitSecrets(
    VOID
)
/*++

Routine description

    Initialize this module, take care of multiple initializations..
    NOT Thread safe (if multiple people intialize won't work well).

Return Value

    Win32 error codes

--*/
{
    DWORD                          Error;

    if( LsaInitialized ) return ERROR_SUCCESS;

    Error = OpenPolicy(&GlobalPolicyHandle);

    if( ERROR_SUCCESS == Error ) {
        LsaInitialized = TRUE;
    }
    return Error;
}

VOID
DhcpCleanupSecrets(
    VOID
)
/*++


Routine description

    Undo the effect of DhcpInitSecrets -- keep track of # of calls to init & cleanup.
    NOT Thread safe

Return Value

    Win32 error code

--*/
{
    if( FALSE == LsaInitialized )  {
        return;
    }

    LsaInitialized = FALSE;
    if( FALSE == LsaInitialized ) {
        LsaClose(GlobalPolicyHandle);
        GlobalPolicyHandle = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\stoc.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    stoc.c

Abstract:

    This module contains the code to deal with most of the protocol parts
    of the DHCP server (like processing for each type of packet -- discover,
    request, inform, bootp etc).

    THIS FILE IS BEST VIEWED IN 100 COLUMNS

Author:

    Madan Appiah (madana)  10-Sep-1993
    Manny Weiser (mannyw)  24-Aug-1992

Environment:

    User Mode - Win32

Revision History:

    Cheng Yang (t-cheny)  30-May-1996  superscope
    Cheng Yang (t-cheny)  27-Jun-1996  audit log
    Ramesh V K (rameshv)  06-Jun-1998  severe reformat + accumulated changes

--*/

#include "dhcppch.h"
#include <thread.h>
#include <ping.h>
#include <mdhcpsrv.h>
#include <iptbl.h>
#include <endpoint.h>

//
// Default Bootp Options
//

BYTE  pbOptionList[] = {
    3,   // router list
    6,   // dns
    2,   // time offset
    12,  // host name
    15,  // domain name
    44,  // nbt config
    45,  // ""
    46,  // ""
    47,  // ""
    48,  // X term server
    49,  // X term server
    69,  // smtp server
    70,  // pop3 server
    9,   // lpr server
    17,  // root path
    42,  // ntp
    4,   // time server
    144, //HP Jet Direct
    7,   // Log Servers
    18   // Extensions Path
};


VOID
PrintHWAddress(
    IN      LPBYTE                 HWAddress,
    IN      LONG                   HWAddressLength
)
{
    LONG                           i;

    DhcpPrint(( DEBUG_STOC, "Client UID = " ));

    if( (HWAddress == NULL) || (HWAddressLength == 0) ) {
        DhcpPrint(( DEBUG_STOC, "(NULL).\n" ));
        return;
    }

    for( i = 0; i < (HWAddressLength-1); i++ ) {
        DhcpPrint(( DEBUG_STOC, "%.2lx-", (DWORD)HWAddress[i] ));
    }

    DhcpPrint(( DEBUG_STOC, "%.2lx.\n", (DWORD)HWAddress[i] ));
    return;
}

#ifndef     DBG
#define     PrintHWAddress(X,Y)    // dont print anything on retail builds
#endif      DBG

DWORD
DhcpMakeClientUID(
    IN      LPBYTE                 ClientHardwareAddress,
    IN      ULONG                  ClientHardwareAddressLength,
    IN      BYTE                   ClientHardwareAddressType,
    IN      DHCP_IP_ADDRESS        ClientSubnetAddress,
    OUT     LPBYTE                *ClientUID,
    OUT     DWORD                 *ClientUIDLength
    )

/*++

Routine Description:

    This function computes the unique identifier for a client by concatenating
    4-byte subnet address of the client, the client hardware address type and
    the actual hardware address.  But we hardcode the client hardware type as
    HARDWARE_TYPE_10MB_ETHERNET currently  (as there is no way to specify the
    hardware type in the UI for reservations).

    Also this format is used in DhcpValidateClient (cltapi.c?) -- careful about
    changing this code!

    THIS FUNCTION IS DUPLICATED IN RPCAPI2.C IN DHCPDS\ DIRECTORY!  DO NOT
    MODIFY THIS WITHOUT MAKING CORRESPONDING CHANGES THERE!

Arguments:

    ClientHardwareAddress - The actual hardware address (MAC) of the client.

    ClientHardwareAddressLength - The actual number of bytes of hardware address.

    ClientHardwareAddressType - The hardware type of the client. Currently ignored.

    ClientSubnetAddress - The subnet address that the client belongs to. This
        must be in network order, I think (RameshV).

    ClientUID - On return this will hold a buffer allocated via DhcpAllocateMemory,
        that will be filled with the newly formed Client UID.

    ClientUIDLength - This will be filled in to hold the # of bytes of the buffer
        that the ClientUID variable contains.

Return Value:

    ERROR_SUCCESS is returned if everything went fine.
    ERROR_NOT_ENOUGH_MEMORY is returned if not enough memory could be allocated.
    ERROR_DHCP_INVALID_DHCP_CLIENT is returned if the MAC address specified is
        not valid.

--*/

{
    LPBYTE                         Buffer;
    LPBYTE                         ClientUIDBuffer;
    DWORD                          ClientUIDBufferLength;

    DhcpAssert( *ClientUID == NULL );

    if( ClientHardwareAddressLength == 0 ) {
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    ClientHardwareAddressType = HARDWARE_TYPE_10MB_EITHERNET;

    ClientUIDBufferLength  =  sizeof(ClientSubnetAddress);
    ClientUIDBufferLength +=  sizeof(ClientHardwareAddressType);
    ClientUIDBufferLength +=  (BYTE)ClientHardwareAddressLength;

    ClientUIDBuffer = DhcpAllocateMemory( ClientUIDBufferLength );

    if( ClientUIDBuffer == NULL ) {
        *ClientUIDLength = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Buffer = ClientUIDBuffer;
    RtlCopyMemory(Buffer,&ClientSubnetAddress,sizeof(ClientSubnetAddress));

    Buffer += sizeof(ClientSubnetAddress);
    RtlCopyMemory(Buffer,&ClientHardwareAddressType,sizeof(ClientHardwareAddressType) );

    Buffer += sizeof(ClientHardwareAddressType);
    RtlCopyMemory(Buffer,ClientHardwareAddress,ClientHardwareAddressLength );

    *ClientUID = ClientUIDBuffer;
    *ClientUIDLength = ClientUIDBufferLength;

    return ERROR_SUCCESS;
}


VOID
GetLeaseInfo(
    IN      DHCP_IP_ADDRESS        IpAddress,
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    OUT     LPDWORD                LeaseDurationPtr,
    OUT     LPDWORD                T1Ptr               OPTIONAL,
    OUT     LPDWORD                T2Ptr               OPTIONAL,
    IN      DWORD UNALIGNED       *RequestLeaseTime    OPTIONAL
)
/*++

Routine Description:

    This routine gets the specified lease information for the DHCP client
    identified by the IP Address "IpAddress".   This is done by walking the
    configuration for the IP address (first reservations, then scopes, then global)
    via the function DhcpGetParameter.  (Note that any class specific information
    would still be used -- this is passed via the ClientCtxt structure pointer.

Arguments:

    IpAddress - This is the IP address of the client for which lease info is needed.

    ClientCtxt - The client ctxt structure for the client to be used to figure out
        the client class and other information.

    LeaseDurationPtr - This DWORD will be filled with the # of seconds the lease is
        to be given out to the client.

    T1Ptr, T2Ptr - These two DWORDs (OPTIONAL) will be filled with the # of seconds
        until T1 and T2 time respectively.

    RequestedLeaseTime -- If specified, and if this lease duration is lesser than
        the duration as specified in the configuration, then, this is the duration
        that the client would be returned in LeaseDurationPtr.

Return Value:

    None.

--*/
{
    LPBYTE                         OptionData = NULL;
    DWORD                          Error;
    DWORD                          LocalLeaseDuration;
    DWORD                          LocalT1;
    DWORD                          LocalT2;
    DWORD                          OptionDataLength = 0;
    DWORD                          dwUnused;
    DWORD                          LocalRequestedLeaseTime;

    Error = DhcpGetParameter(
        IpAddress,
        ClientCtxt,
        OPTION_LEASE_TIME,
        &OptionData,
        &OptionDataLength,
        NULL /* dont care if this is reservation option, subnet option etc */
    );

    if ( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_ERRORS, "Unable to read lease value from registry, %ld.\n", Error));
        LocalLeaseDuration = DHCP_MINIMUM_LEASE_DURATION;
    } else {
        DhcpAssert( OptionDataLength == sizeof(LocalLeaseDuration) );
        LocalLeaseDuration = *(DWORD *)OptionData;
        LocalLeaseDuration = ntohl( LocalLeaseDuration );

        DhcpFreeMemory( OptionData );
        OptionData = NULL;
        OptionDataLength = 0;
    }

    //
    // If client requests a shorter lease than what we usually give, shorten it!
    //

    if ( CFLAG_GIVE_REQUESTED_LEASE && ARGUMENT_PRESENT(RequestLeaseTime) ) {
        LocalRequestedLeaseTime =  ntohl( *RequestLeaseTime );
        if ( LocalLeaseDuration > LocalRequestedLeaseTime ) {
            LocalLeaseDuration = LocalRequestedLeaseTime;
        }
    }

    *LeaseDurationPtr = LocalLeaseDuration;

    //
    // If T1 and T2 are requested, then do as before for T1 & T2.  If we don't
    // find any information about T1 or T2 in registry, calculate T1 as half LeaseTime
    // and T2 as 87.5 seconds.
    //

    if ( ARGUMENT_PRESENT(T1Ptr) || ARGUMENT_PRESENT(T2Ptr) ) {
        Error = DhcpGetParameter(
            IpAddress,
            ClientCtxt,
            OPTION_RENEWAL_TIME,
            &OptionData,
            &OptionDataLength,
            NULL
        );

        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS,"Unable to read T1 value from registry, %ld.\n", Error));
            LocalT1 = (LocalLeaseDuration) / 2 ;
        } else {
            DhcpAssert( OptionDataLength == sizeof(LocalT1) );
            LocalT1 = *(DWORD *)OptionData;
            LocalT1 = ntohl( LocalT1 );

            DhcpFreeMemory( OptionData );
            OptionData = NULL;
            OptionDataLength = 0;
        }

        Error = DhcpGetParameter(
            IpAddress,
            ClientCtxt,
            OPTION_REBIND_TIME,
            &OptionData,
            &OptionDataLength,
            NULL
        );

        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "Unable to read T2 value from registry, %ld.\n", Error));
            LocalT2 = (LocalLeaseDuration) * 7 / 8 ;
        } else {
            DhcpAssert( OptionDataLength == sizeof(LocalT2) );
            LocalT2 = *(DWORD *)OptionData;

            LocalT2 = ntohl( LocalT2 );

            DhcpFreeMemory( OptionData );
            OptionData = NULL;
            OptionDataLength = 0;
        }

        if( (LocalT2 == 0) || (LocalT2 > LocalLeaseDuration) ) {
            LocalT2 = LocalLeaseDuration * 7 / 8;
        }

        if( (LocalT1 == 0) || (LocalT1 > LocalT2) ) {
            LocalT1 = LocalLeaseDuration / 2;
            if( LocalT1 > LocalT2 ) {
                LocalT1 = LocalT2 - 1; // 1 sec less.
            }
        }

        if( ARGUMENT_PRESENT(T1Ptr) ) *T1Ptr = LocalT1;
        if( ARGUMENT_PRESENT(T2Ptr) ) *T2Ptr = LocalT2;
    }

    return;
}

DWORD
ExtractOptions(
    IN      LPDHCP_MESSAGE         DhcpReceiveMessage,
    OUT     LPDHCP_SERVER_OPTIONS  DhcpOptions,
    IN      ULONG                  ReceiveMessageSize
)

/*++

Routine Description:

    This routine parses the options (non-fixed) part of the DHCP message, making
    sure the packet is correctly formatted and fills in the DhcpOptions structure
    pointer with all the correct pointers.

    A couple of points here -- the input message is kept intact and unmodified.
    If any of the standard options have unacceptable size or value,  an  error
    (ERROR_DHCP_INVALID_DHCP_MESSAGE) is returned.

    Even if there is no OPTION_DYNDNS_BOTH present in the wire, the value of
    DhcpOptions->DNSFlags is non-zero (DYNDNS_DOWNLEVEL_CLIENT which happens
    to be 3).  This is because a value of ZERO means the option with value ZERO
    was sent by the DHCP client.

Arguments:

    DhcpReceiveMessage - This is the actual message sent by the DHCP client.

    DhcpOptions - A pointer to the structure that holds all the important optiosn
        needed by the dhcp server.  This structure must be zeroed -- if an option
        is not received, then the fields won't be modified (except for the
        DNS* fields and DSDomain* fields)

    ReceiveMessageSize - The size of the buffer DhcpReceiveMessage in bytes.

Return Value:

    ERROR_SUCCESS is returned if everything is OK with the message and all optiosn
    were parsed fine.

    ERROR_DHCP_INVALID_DHCP_MESSAGE is returned otherwise.

--*/

{
    LPOPTION                       Option;
    LPOPTION                       MsftOption;
    LPBYTE                         start;
    LPBYTE                         EndOfMessage;
    POPTION                        nextOption;
    LPBYTE                         MagicCookie;

    //
    // Note the HACK with DhcpOptions->DnsFlags below. See routine description.
    // N.B DYNDNS_DOWNLEVEL_CLIENT != ZERO !!
    //

    DhcpOptions->DNSFlags = DYNDNS_DOWNLEVEL_CLIENT;
    DhcpOptions->DNSName = NULL;
    DhcpOptions->DNSNameLength = 0;

    DhcpOptions->DSDomainName = NULL;
    DhcpOptions->DSDomainNameLen = 0;
    DhcpOptions->DSDomainNameRequested = FALSE;

    start = (LPBYTE) DhcpReceiveMessage;
    EndOfMessage = start + ReceiveMessageSize -1;
    Option = &DhcpReceiveMessage->Option;

    //
    // Check sizes to see if the fixed size header part exists or not.
    // If there are no options, it may be just a BOOTP client.
    //

    if( (LONG)ReceiveMessageSize <= ((LPBYTE)Option - start) ) {
        return( ERROR_DHCP_INVALID_DHCP_MESSAGE );
    } else if ( (LONG)ReceiveMessageSize == ((LPBYTE)Option - start) ){
        return ERROR_SUCCESS;
    }

    //
    // If the MAGIC cookie doesn't match, don't parse options!
    // Shouldn't we just drop the packet in this case?
    //

    MagicCookie = (LPBYTE) Option;
    if( (*MagicCookie != (BYTE)DHCP_MAGIC_COOKIE_BYTE1) ||
        (*(MagicCookie+1) != (BYTE)DHCP_MAGIC_COOKIE_BYTE2) ||
        (*(MagicCookie+2) != (BYTE)DHCP_MAGIC_COOKIE_BYTE3) ||
        (*(MagicCookie+3) != (BYTE)DHCP_MAGIC_COOKIE_BYTE4)) {
        return ERROR_SUCCESS;
    }


    //
    // Carefully, walk the options - [BYTE opcode BYTE len BYTES value]*
    // Make sure we don't look outside of packet size in case of bugs Len values
    // or missing OPTION_END option.  Also note that OPTION_PAD and OPTION_END
    // are just one byte each with no len/value parts to them.
    //

    Option = (LPOPTION) (MagicCookie + 4);
    while ( ((LPBYTE)Option <= EndOfMessage) && Option->OptionType != OPTION_END
            && ((LPBYTE)Option+1 <= EndOfMessage)) {

        if ( Option->OptionType == OPTION_PAD ){
            nextOption = (LPOPTION)( (LPBYTE)(Option) + 1);
        } else {
            nextOption = (LPOPTION)( (LPBYTE)(Option) + Option->OptionLength + 2);
        }

        if ((LPBYTE)nextOption  > EndOfMessage+1 ) {
            if ( !DhcpOptions->MessageType ) {

                //
                // We ignore these errors for BOOTP clients as some seem have such problems.
                // This is LEGACY code.
                //

                return ERROR_SUCCESS;
            } else  {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
        }

        //
        // giant UGLY switch for each option of interest.  Wish we could do better.
        //

        switch ( Option->OptionType ) {

        case OPTION_PAD:
            break;

        case OPTION_SERVER_IDENTIFIER:
            DhcpOptions->Server = (LPDHCP_IP_ADDRESS)&Option->OptionValue;
            if( sizeof(DWORD) != Option->OptionLength ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
            break;

        case OPTION_SUBNET_MASK:
            DhcpOptions->SubnetMask = (LPDHCP_IP_ADDRESS)&Option->OptionValue;
            if( sizeof(DWORD) != Option->OptionLength ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
            break;

        case OPTION_ROUTER_ADDRESS:
            DhcpOptions->RouterAddress = (LPDHCP_IP_ADDRESS)&Option->OptionValue;
            if( sizeof(DWORD) != Option->OptionLength ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
            break;

        case OPTION_REQUESTED_ADDRESS:
            DhcpOptions->RequestedAddress = (LPDHCP_IP_ADDRESS)&Option->OptionValue;
            if( sizeof(DWORD) != Option->OptionLength ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
            break;

        case OPTION_LEASE_TIME:
            DhcpOptions->RequestLeaseTime = (LPDWORD)&Option->OptionValue;
            if( sizeof(DWORD) != Option->OptionLength ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
            break;

        case OPTION_OK_TO_OVERLAY:
            DhcpOptions->OverlayFields = (LPBYTE)&Option->OptionValue;
            break;

        case OPTION_PARAMETER_REQUEST_LIST:
            DhcpOptions->ParameterRequestList = (LPBYTE)&Option->OptionValue;
            DhcpOptions->ParameterRequestListLength =
                (DWORD)Option->OptionLength;
            break;

        case OPTION_MESSAGE_TYPE:
            DhcpOptions->MessageType = (LPBYTE)&Option->OptionValue;
            break;

        case OPTION_HOST_NAME:
            DhcpOptions->MachineNameLength = Option->OptionLength;
            DhcpOptions->MachineName = Option->OptionValue;

            break;

        case OPTION_CLIENT_CLASS_INFO:
            DhcpOptions->VendorClassLength = Option->OptionLength;
            DhcpOptions->VendorClass = Option->OptionValue;

            break;

        case OPTION_USER_CLASS:
            DhcpOptions->ClassIdentifierLength = Option->OptionLength;
            DhcpOptions->ClassIdentifier = Option->OptionValue;

            break;

        case OPTION_CLIENT_ID:

            if ( Option->OptionLength >= 1 ) {
                DhcpOptions->ClientHardwareAddressType =
                    (BYTE)Option->OptionValue[0];
            }

            if ( Option->OptionLength >= 2 ) {
                DhcpOptions->ClientHardwareAddressLength =
                    Option->OptionLength - sizeof(BYTE);
                DhcpOptions->ClientHardwareAddress =
                    (LPBYTE)Option->OptionValue + sizeof(BYTE);
            }

            break;

        case OPTION_DYNDNS_BOTH:

            //
            // DHCP_DNS Draft says length >= 4! but subtract 1 byte for len
            // 3 bytes = flags+rcode1+rcode2
            // Get the Flags and domain name if it exists.. else mark null.
            //

            if( Option->OptionLength < 3) break;

            DhcpOptions->DNSFlags = *(LPBYTE)( Option->OptionValue);
            DhcpOptions->DNSNameLength = Option->OptionLength - 3 ;
            DhcpOptions->DNSName = ((LPBYTE)Option->OptionValue)+3;

            break;

        case OPTION_VENDOR_SPEC_INFO:

            if( Option->OptionLength < 2 ) {
                //
                // Don;t have interested option ignore it.
                //
                break;
            }

            MsftOption = (LPOPTION)&Option->OptionValue[0];

            //
            // has the client requested our domain name?
            //

            if (MsftOption->OptionType == OPTION_MSFT_DSDOMAINNAME_REQ) {
                DhcpOptions->DSDomainNameRequested = TRUE;

                MsftOption = (LPOPTION) (
                    (&MsftOption->OptionValue[0] + MsftOption->OptionLength)
                    );
            }


            //
            // have we reached the end of the MsftOption list?
            //

            if (((LPBYTE)MsftOption)+1 >= (LPBYTE)nextOption) {
                break;
            }

            //
            // has the client supplied its domain name?
            //

            if (MsftOption->OptionType == OPTION_MSFT_DSDOMAINNAME_RESP) {

                DhcpOptions->DSDomainNameLen = (DWORD)(MsftOption->OptionLength);

                DhcpOptions->DSDomainName = &MsftOption->OptionValue[0];

                MsftOption = (LPOPTION) (
                    (&MsftOption->OptionValue[0] + MsftOption->OptionLength)
                    );
            }

            if( MsftOption > nextOption ) {
                //
                // Went out of bounds.  Ignore DSDomainName etc..
                //
                DhcpOptions->DSDomainNameLen = 0;
                DhcpOptions->DSDomainName = NULL;
            }

            break;

        //
        //  these next three are for BINL
        //

        case OPTION_SYSTEM_ARCHITECTURE:
            if (Option->OptionLength == 2) {
                DhcpOptions->SystemArchitectureLength = Option->OptionLength;
		// use unaligned dereference. Otherwise, it may cause exceptions in ia64.
		DhcpOptions->SystemArchitecture = ntohs(*(USHORT UNALIGNED *)Option->OptionValue);
            } else {
                return (ERROR_DHCP_INVALID_DHCP_MESSAGE);
            }
            break;

        case OPTION_NETWORK_INTERFACE_TYPE:
            DhcpOptions->NetworkInterfaceTypeLength = Option->OptionLength;
            DhcpOptions->NetworkInterfaceType = Option->OptionValue;
            break;

        case OPTION_CLIENT_GUID:
            DhcpOptions->GuidLength = Option->OptionLength;
            DhcpOptions->Guid = Option->OptionValue;
            break;

        default: {
#if DBG
                DWORD i;

            DhcpPrint(( DEBUG_STOC,
                        "Received an unknown option, ID =%ld, Len = %ld, Data = ",
                        (DWORD)Option->OptionType,
                        (DWORD)Option->OptionLength ));

            for( i = 0; i < Option->OptionLength; i++ ) {
                DhcpPrint(( DEBUG_STOC, "%ld ",
                            (DWORD)Option->OptionValue[i] ));

            }
#endif

            break;
            }

        }

        Option = nextOption;
    }

    return( ERROR_SUCCESS) ;

}

DWORD
ExtractMadcapOptions(
    IN      LPMADCAP_MESSAGE         MadcapReceiveMessage,
    OUT     LPMADCAP_SERVER_OPTIONS  MadcapOptions,
    IN      ULONG                  ReceiveMessageSize
)

/*++

Routine Description:

    This routine parses the options (non-fixed) part of the DHCP message, making
    sure the packet is correctly formatted and fills in the MadcapOptions structure
    pointer with all the correct pointers.

    A couple of points here -- the input message is kept intact and unmodified.
    If any of the standard options have unacceptable size or value,  an  error
    (ERROR_DHCP_INVALID_DHCP_MESSAGE) is returned.

    Even if there is no OPTION_DYNDNS_BOTH present in the wire, the value of
    MadcapOptions->DNSFlags is non-zero (DYNDNS_DOWNLEVEL_CLIENT which happens
    to be 3).  This is because a value of ZERO means the option with value ZERO
    was sent by the DHCP client.

Arguments:

    DhcpReceiveMessage - This is the actual message sent by the DHCP client.

    MadcapOptions - A pointer to the structure that holds all the important optiosn
        needed by the dhcp server.  This structure must be zeroed -- if an option
        is not received, then the fields won't be modified (except for the
        DNS* fields and DSDomain* fields)

    ReceiveMessageSize - The size of the buffer DhcpReceiveMessage in bytes.

Return Value:

    ERROR_SUCCESS is returned if everything is OK with the message and all optiosn
    were parsed fine.

    ERROR_DHCP_INVALID_DHCP_MESSAGE is returned otherwise.

--*/

{
    WIDE_OPTION UNALIGNED*         NextOpt;
    BYTE        UNALIGNED*         EndOpt;
    WORD                           Size;          // Option Size
    WORD                           ExpSize;       // Expected option size
    DWORD                          OptionType;
    WORD                           AddrFamily;

    // all options should be < EndOpt;
    EndOpt = (LPBYTE) MadcapReceiveMessage + ReceiveMessageSize;

    NextOpt = (WIDE_OPTION UNALIGNED*)&MadcapReceiveMessage->Option;

    //
    // Check sizes to see if the fixed size header part exists or not.
    //
    if( ReceiveMessageSize < MADCAP_MESSAGE_FIXED_PART_SIZE ) {
        return( ERROR_DHCP_INVALID_DHCP_MESSAGE );
    }

    while( NextOpt->OptionValue <= EndOpt) {

        OptionType = ntohs(NextOpt->OptionType);

	// Check for duplicate options in the known range. Others are ignored
	if (OptionType < MADCAP_OPTION_TOTAL) {

	    // cannot include same option twice
	    if (MadcapOptions->OptPresent[OptionType]) {
		return( ERROR_DHCP_INVALID_DHCP_MESSAGE );
	    }
	    
	    MadcapOptions->OptPresent[OptionType] = TRUE;
	    if ( MADCAP_OPTION_END == OptionType){
		break;
	    }

	} // if 

	// Check for boundary condition
        Size = ntohs(NextOpt->OptionLength);
        if ((NextOpt->OptionValue + Size) > EndOpt) {
            return ERROR_DHCP_INVALID_DHCP_MESSAGE;
        }

	ExpSize = Size;

        switch ( OptionType ) {
        case MADCAP_OPTION_LEASE_TIME:
	    ExpSize = 4;
            MadcapOptions->RequestLeaseTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_SERVER_ID:
	    ExpSize = 6;
            AddrFamily = ntohs(*(WORD UNALIGNED *)NextOpt->OptionValue);
            if ( MADCAP_ADDR_FAMILY_V4 != AddrFamily ) return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            MadcapOptions->Server = (DHCP_IP_ADDRESS UNALIGNED *)(NextOpt->OptionValue+2);
            break;
        case MADCAP_OPTION_LEASE_ID:
            MadcapOptions->GuidLength = Size;
            MadcapOptions->Guid = (LPBYTE)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_MCAST_SCOPE:
            ExpSize = 4;
            MadcapOptions->ScopeId = (DHCP_IP_ADDRESS UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_REQUEST_LIST:
            MadcapOptions->RequestList = (LPBYTE)NextOpt->OptionValue;
            MadcapOptions->RequestListLength = Size;
            break;
        case MADCAP_OPTION_START_TIME:
	    ExpSize = 4;
            MadcapOptions->LeaseStartTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_ADDR_COUNT:
	    ExpSize = 4;
            MadcapOptions->MinAddrCount = (WORD UNALIGNED *)NextOpt->OptionValue;
            MadcapOptions->AddrCount = (WORD UNALIGNED *)(NextOpt->OptionValue+2);
            break;
        case MADCAP_OPTION_REQUESTED_LANG:
            MadcapOptions->RequestLang = (LPBYTE)NextOpt->OptionValue;
            MadcapOptions->RequestLangLength = Size;
            break;
        case MADCAP_OPTION_MCAST_SCOPE_LIST:
	    ExpSize = 0;
	    // Nothing here?
            break;
        case MADCAP_OPTION_ADDR_LIST:
            ExpSize = Size - (Size % 6);
            MadcapOptions->AddrRangeList = NextOpt->OptionValue;
            MadcapOptions->AddrRangeListSize = Size;
            break;
        case MADCAP_OPTION_TIME:
	    ExpSize = 4;
            MadcapOptions->Time = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;

	    /*
	     * Feature list option lists the optional MADCAP features supported, requested or
	     * required by the sender.
	     *
	     *    The code for this option is 12 and the minimum length is 6.
	     *
	     *            Code        Len      Supported   Requested   Required
	     *    +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
	     *    |    12     |     n     |    FL1    |    FL2    |    FL3    |
	     *    +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
	     *
	     *    where each of the Feature Lists is of the following format:
	     *
	     *           Feature     Feature           Feature
	     *            Count      Code 1            Code m
	     *        +-----+-----+-----+-----+-...-+-----+-----+
	     *        |     m     | FC1       |     |    FCm    |
	     *        +-----+-----+-----+-----+-...-+-----+-----+
	     *
	     */
        case MADCAP_OPTION_FEATURE_LIST:

	    // 9/27/00 : (rterala)
	    // The following code is written incorrectly and does not make
	    // any sense to me. It needs a complete rewrite. Do it when a
	    // customer requests this option.

            if ((Size < 6) || (Size % 2)) {
                ExpSize = 6;
            } else {
                WORD        TempSize;
                WORD        Count,i;
                PBYTE       NextValue;

                TempSize = Size;
                Count = 0;
                NextValue = NextOpt->OptionValue;
                for (i = 0; i < 3; i ++) {
                    if (NextValue <= EndOpt &&
                        (Count = ntohs(*(WORD UNALIGNED *)NextValue)) &&
                        TempSize >= (Count*2 + 2)) {
                        TempSize -= (Count*2 + 2);
                        NextValue += 2;
                        MadcapOptions->Features[i] = (WORD UNALIGNED *)NextValue;
                        MadcapOptions->FeatureCount[i] = Count;
                    } else {
                        ExpSize = Size+1;   // just to fail it
                    }
                }
                if (i < 3 ) {
                    ExpSize = Size+1;   // just to fail it
                } else {
//                      DhcpAssert (0 == TempSize);
                }
            }
            break;
        case MADCAP_OPTION_RETRY_TIME:
	    ExpSize = 4;
	    MadcapOptions->RetryTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_MIN_LEASE_TIME:
	    ExpSize = 4;
            MadcapOptions->MinLeaseTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_MAX_START_TIME:
	    ExpSize = 4;
            MadcapOptions->MaxStartTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_ERROR:
	    ExpSize = 0;
            break;
        default: {
            DWORD i;
            DhcpPrint(( DEBUG_STOC,"Received an unknown option, ID =%ld, Len = %ld, Data = ",
                        (DWORD)OptionType,(DWORD)Size ));
            for( i = 0; i < Size; i++ ) {
                DhcpPrint(( DEBUG_STOC, "%2.2x", NextOpt->OptionValue[i] ));
            }
            break;
            }

        }
        if( ExpSize != Size ) {
            return ERROR_DHCP_INVALID_DHCP_MESSAGE;
        }
        NextOpt = (WIDE_OPTION UNALIGNED*)(NextOpt->OptionValue + Size);
    }

    return( ERROR_SUCCESS) ;

}


LPOPTION
ConsiderAppendingOption(                               // conditionally append option to message (if the option is valid)
    IN      DHCP_IP_ADDRESS        IpAddress,          // client ip address
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,         // ctxt of the client
    OUT     LPOPTION               Option,             // where to start adding the options
    IN      ULONG                  OptionType,         // what option is this?
    IN      LPBYTE                 OptionEnd,          // cutoff upto which we can fill options
    IN      BOOL                   fSwitchedSubnet     // is this client in a switched subnet environment?
    )
/*++

Routine Description:

   This routine tries to verify if it is OK to append the option requested and
   if it is not one of the options manually added by the DHCP server, then it is
   appended at the point given by "Option" (assuming it would fit in without outrunning
   "OptionEnd" ).   The format in which it is appended is as per the wire protocol.

   When an option has been decided to be appended, first the value is obtained from
   the registry (using the ClientCtxt for class-specific options) in case of
   most options.  (Some are obtained through other means).

   If OPTION_CLIENT_CLASS_INFO is the option requested and this is a NetPC requesting
   the option (via BOOTPROM -- the vendor class is set to a specific string) -- then
   the returned value for this option is just the same as one sent in by the client.
   This is a special case for NetPC's..

Arguments:

   IpAddress - The IP Address of the client for which the options are being added.

   ClientCtxt - This is the bunch of parameters like client class, vendor class etc.

   Option - The location where to start appending the option

   OptionType - The actual OPTION ID to retrieve the value of and append.

   OptionEnd - The end marker for this buffer (the option is not appended if we
       would have to overrun this marker while trying to append)

   fSwitchedSubnet - Is the subnet switched? If so, the router address is given
       out as the IP address instead of trying to retrieve it from the config.
       If this variable is true, then OptionType of ROUTER_ADDRESS is NOT appended
       (as in this case, this would have been done elsewhere).

Return Value:

   The location in memory AFTER the option has been appended (in case the option was
   not appended, this would be the same as "Option" ).

--*/

{
    LPBYTE                         optionValue = NULL;
    DWORD                          optionSize;
    DWORD                          status;
    DWORD                          dwUnused;
    BOOL                           doDefault;

    doDefault = FALSE;

    switch ( OptionType ) {
    case OPTION_USER_CLASS:
        Option = (LPOPTION) DhcpAppendClassList(
            (LPBYTE)Option,
            (LPBYTE)OptionEnd
        );
        break;

    //
    //  NetPC Option
    //

    case OPTION_CLIENT_CLASS_INFO:

        if( BinlRunning() ) {
            if( ClientCtxt->BinlClassIdentifierLength ) {
                Option = DhcpAppendOption(
                    Option,
                    OPTION_CLIENT_CLASS_INFO,
                    (PVOID)ClientCtxt->BinlClassIdentifier,
                    (BYTE)ClientCtxt->BinlClassIdentifierLength,
                    OptionEnd
                    );
            }
        } else {
            doDefault = TRUE;
        }

        break;
    //
    // Options already handled.
    //

    case OPTION_SUBNET_MASK:
    case OPTION_REQUESTED_ADDRESS:
    case OPTION_LEASE_TIME:
    case OPTION_OK_TO_OVERLAY:
    case OPTION_MESSAGE_TYPE:
    case OPTION_RENEWAL_TIME:
    case OPTION_REBIND_TIME:
    case OPTION_DYNDNS_BOTH:
        break;


    //
    // Options it is illegal to ask for.
    //

    case OPTION_PAD:
    case OPTION_PARAMETER_REQUEST_LIST:
    case OPTION_END:

        DhcpPrint((DEBUG_ERRORS,"Request for invalid option %d\n", OptionType));
        break;

    case OPTION_ROUTER_ADDRESS:

        if( !fSwitchedSubnet ) {
            doDefault = TRUE;
        }
        break;

    default:

        doDefault = TRUE;
        break;

    }

    if( doDefault ) {
        status = DhcpGetParameter(
            IpAddress,
            ClientCtxt,
            OptionType,
            &optionValue,
            &optionSize,
            NULL
        );

        if ( status == ERROR_SUCCESS ) {
            Option = DhcpAppendOption(
                Option,
                (BYTE)OptionType,
                (PVOID)optionValue,
		optionSize,
                OptionEnd
            );

            DhcpFreeMemory( optionValue );

        } else {
            DhcpPrint((
                DEBUG_ERRORS,"Requested option is "
                "unavilable in registry, %d\n",OptionType
                ));
        }
    }

    return Option;
}


LPOPTION
AppendClientRequestedParameters(                       // if the client requested parameters, add those to the message
    IN      DHCP_IP_ADDRESS        IpAddress,          // client ip address
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,         // clients context
    IN      LPBYTE                 RequestedList,      // list of options requested by client
    IN      DWORD                  ListLength,         // how long is the list
    OUT     LPOPTION               Option,             // this is where to start adding the options
    IN      LPBYTE                 OptionEnd,          // cutoff pt in the buffer up to which options can be filled
    IN      BOOL                   fSwitchedSubnet,    // is this client in a switched subnet environment?
    IN      BOOL                   fAppendVendorSpec   // append vendor spec info?
)
{
    while ( ListLength > 0) {

        if( FALSE == fAppendVendorSpec
            && OPTION_VENDOR_SPEC_INFO == *RequestedList ) {
            ListLength -- ; RequestedList ++;
            continue;
        }

        Option = ConsiderAppendingOption(
            IpAddress,
            ClientCtxt,
            Option,
            *RequestedList,
            OptionEnd,
            fSwitchedSubnet
        );
        ListLength--;
        RequestedList++;
    }

    return Option;
}

LPOPTION
FormatDhcpAck(
    IN      LPDHCP_REQUEST_CONTEXT Ctxt,
    IN      LPDHCP_MESSAGE         Request,
    OUT     LPDHCP_MESSAGE         Response,
    IN      DHCP_IP_ADDRESS        IpAddress,
    IN      DWORD                  LeaseDuration,
    IN      DWORD                  T1,
    IN      DWORD                  T2,
    IN      DHCP_IP_ADDRESS        ServerAddress
)
/*++

Routine Description:

    This function formats a DHCP Ack response packet.  The END option
    is not appended to the message and must be appended by the caller.

Arguments:

    Ctxt - DHCP client request context.

    Response - A pointer to the Received message data buffer.

    Response - A pointer to a preallocated Response buffer.  The buffer
        currently contains the initial request.

    IpAddress - IpAddress offered (in network order).

    LeaseDuration - The lease duration (in network order).

    T1 - renewal time.

    T2 - rebind time.

    ServerAddress - Server IP address (in network order).

Return Value:

    pointer to the next option in the send buffer.

--*/
{
    LPOPTION                       Option;
    LPBYTE                         OptionEnd;
    BYTE                           messageType;
    BYTE                           szBootFileName[BOOT_FILE_SIZE];
    DWORD                          BootpServerIpAddress;

    RtlZeroMemory( Response, DHCP_SEND_MESSAGE_SIZE );

    Response->Operation = BOOT_REPLY;
    Response->TransactionID = Request->TransactionID;
    Response->YourIpAddress = IpAddress;
    Response->Reserved = Request->Reserved;

    Response->HardwareAddressType = Request->HardwareAddressType;
    Response->HardwareAddressLength = Request->HardwareAddressLength;
    RtlCopyMemory(Response->HardwareAddress,
                    Request->HardwareAddress,
                    Request->HardwareAddressLength );

    Response->BootstrapServerAddress = Request->BootstrapServerAddress;
    Response->RelayAgentIpAddress = Request->RelayAgentIpAddress;

    if (IpAddress != 0 && !CLASSD_NET_ADDR(IpAddress) ) {

        memset( szBootFileName, 0, sizeof( szBootFileName ));
        DhcpGetBootpInfo(
            Ctxt,
            ntohl(IpAddress),
            DhcpGetSubnetMaskForAddress(ntohl(IpAddress)),
            Request->BootFileName,
            szBootFileName,
            &BootpServerIpAddress
        );

        Response->BootstrapServerAddress = BootpServerIpAddress;
        memcpy( Response->BootFileName, szBootFileName,
                sizeof( Response->BootFileName ) - 1 );
        Response->BootFileName[ sizeof( Response->BootFileName ) - 1 ] = '\0';;
    }

    Option = &Response->Option;
    OptionEnd = (LPBYTE)Response + DHCP_SEND_MESSAGE_SIZE;

    Option = (LPOPTION) DhcpAppendMagicCookie(
        (LPBYTE) Option,
        OptionEnd );

    messageType = DHCP_ACK_MESSAGE;
    Option = DhcpAppendOption(
        Option,
        OPTION_MESSAGE_TYPE,
        &messageType,
        sizeof( messageType ),
        OptionEnd );

    if (T1) {
        Option = DhcpAppendOption(
            Option,
            OPTION_RENEWAL_TIME,
            &T1,
            sizeof(T1),
            OptionEnd );
    }

    if (T2) {
        Option = DhcpAppendOption(
            Option,
            OPTION_REBIND_TIME,
            &T2,
            sizeof(T2),
            OptionEnd );
    }

    Option = DhcpAppendOption(
        Option,
        OPTION_LEASE_TIME,
        &LeaseDuration,
        sizeof( LeaseDuration ),
        OptionEnd );

    Option = DhcpAppendOption(
        Option,
        OPTION_SERVER_IDENTIFIER,
        &ServerAddress,
        sizeof(ServerAddress),
        OptionEnd );

    DhcpAssert( (char *)Option - (char *)Response <= DHCP_SEND_MESSAGE_SIZE );

    InterlockedIncrement(&DhcpGlobalNumAcks);     // increment ack counter.

    return( Option );
}

LPOPTION
FormatDhcpInformAck(
    IN      LPDHCP_MESSAGE         Request,
    OUT     LPDHCP_MESSAGE         Response,
    IN      DHCP_IP_ADDRESS        IpAddress,
    IN      DHCP_IP_ADDRESS        ServerAddress
)
/*++

Routine Description:

This function formats a DHCP Ack response packet.  The END option
is not appended to the message and must be appended by the caller.

This is to be used only for Inform Packets!
Arguments:

    Response - A pointer to the Received message data buffer.

    Response - A pointer to a preallocated Response buffer.  The buffer
        currently contains the initial request.

    IpAddress - IpAddress offered (in network order).
    -- This is actually the ip address of the client to send this message to!

    ServerAddress - Server IP address (in network order).

Return Value:

    pointer to the next option in the send buffer.

--*/
{
    LPOPTION                       Option;
    LPBYTE                         OptionEnd;
    BYTE                           messageType;

    RtlZeroMemory( Response, DHCP_SEND_MESSAGE_SIZE );

    Response->Operation = BOOT_REPLY;
    Response->TransactionID = Request->TransactionID;
    // Response->YourIpAddress = IpAddress;
    Response->YourIpAddress = 0; // According to the Draft, we should zero this.
    Response->Reserved = Request->Reserved;
    Response->ClientIpAddress = IpAddress;


    Response->HardwareAddressType = Request->HardwareAddressType;
    Response->HardwareAddressLength = Request->HardwareAddressLength;
    RtlCopyMemory(Response->HardwareAddress,
                    Request->HardwareAddress,
                    Request->HardwareAddressLength );

    Response->BootstrapServerAddress = Request->BootstrapServerAddress;
    Response->RelayAgentIpAddress = Request->RelayAgentIpAddress;

    Option = &Response->Option;
    OptionEnd = (LPBYTE)Response + DHCP_SEND_MESSAGE_SIZE;

    Option = (LPOPTION) DhcpAppendMagicCookie(
                            (LPBYTE) Option,
                            OptionEnd );

    messageType = DHCP_ACK_MESSAGE;
    Option = DhcpAppendOption(
        Option,
        OPTION_MESSAGE_TYPE,
        &messageType,
        sizeof( messageType ),
        OptionEnd );

    // Some code here in FormatDhcpAck has been removed..

    Option = DhcpAppendOption(
        Option,
        OPTION_SERVER_IDENTIFIER,
        &ServerAddress,
        sizeof(ServerAddress),
        OptionEnd );

    DhcpAssert( (char *)Option - (char *)Response <= DHCP_SEND_MESSAGE_SIZE );

    if (IpAddress) {
        //
        //  binl calls into us with an IP address of 0, only update the counter
        //  iff we're called from within dhcpssvc.  Within dhcp server, this
        //  routine isn't called with a zero IP address, but if it is, it's
        //  certainly not fatal if we don't increment the counter.
        //
        InterlockedIncrement(&DhcpGlobalNumAcks);     // increment ack counter.
    }

    return( Option );
}


DWORD
FormatDhcpNak(
    IN      LPDHCP_MESSAGE         Request,
    IN      LPDHCP_MESSAGE         Response,
    IN      DHCP_IP_ADDRESS        ServerAddress
)
/*++

Routine Description:

    This function formats a DHCP Nak response packet.

Arguments:

    Response - A pointer to the Received message data buffer.

    Response - A pointer to a preallocated Response buffer.  The buffer
        currently contains the initial request.

    ServerAddress - The address of this server.

Return Value:

    Message size in bytes.

--*/
{
    LPOPTION Option;
    LPBYTE OptionEnd;

    BYTE messageType;
    DWORD messageSize;

    RtlZeroMemory( Response, DHCP_SEND_MESSAGE_SIZE );

    Response->Operation = BOOT_REPLY;
    Response->TransactionID = Request->TransactionID;


    Response->Reserved = Request->Reserved;
    // set the broadcast bit always here. Because the client may be
    // using invalid Unicast address.
    Response->Reserved |= htons(DHCP_BROADCAST);

    Response->HardwareAddressType = Request->HardwareAddressType;
    Response->HardwareAddressLength = Request->HardwareAddressLength;
    RtlCopyMemory(Response->HardwareAddress,
                    Request->HardwareAddress,
                    Request->HardwareAddressLength );

    Response->BootstrapServerAddress = Request->BootstrapServerAddress;
    Response->RelayAgentIpAddress = Request->RelayAgentIpAddress;

    Option = &Response->Option;
    OptionEnd = (LPBYTE)Response + DHCP_SEND_MESSAGE_SIZE;

    Option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) Option, OptionEnd );

    messageType = DHCP_NACK_MESSAGE;
    Option = DhcpAppendOption(
        Option,
        OPTION_MESSAGE_TYPE,
        &messageType,
        sizeof( messageType ),
        OptionEnd
    );

    Option = DhcpAppendOption(
        Option,
        OPTION_SERVER_IDENTIFIER,
        &ServerAddress,
        sizeof(ServerAddress),
        OptionEnd );

    Option = DhcpAppendOption(
        Option,
        OPTION_END,
        NULL,
        0,
        OptionEnd
    );

    messageSize = (DWORD)((char *)Option - (char *)Response);
    DhcpAssert( messageSize <= DHCP_SEND_MESSAGE_SIZE );

    InterlockedIncrement(&DhcpGlobalNumNaks);     // increment nak counter.
    return( messageSize );

}

//--------------------------------------------------------------------------------
// This function decides the additional flags to the state for this client.
// The following are possible flags:
//     ADDRESS_BIT_CLEANUP     : This implies when this record is deleted,
//                               it must be de-registered.
//     ADDRESS_BIT_DOTH_REC    : Treat this client as a down level client
//     ADDRESS_BIT_UNREGISTERED: Do DNS registration for this client
// If the flags value is zero, then no DNS stuff has to be done for this client.
//--------------------------------------------------------------------------------
VOID _inline
DhcpDnsDecideOptionsForClient(
    IN      DHCP_IP_ADDRESS        IpAddress,
    IN      PDHCP_REQUEST_CONTEXT  RequestContext,
    IN      DHCP_SERVER_OPTIONS   *DhcpOptions,
    OUT     LPDWORD                pFlags
)
{
    DWORD                          status;
    DWORD                          DnsFlag;
    DWORD                          OptionSize = 0;
    LPBYTE                         OptionValue = NULL;

    (*pFlags)  = 0;
    if( USE_NO_DNS ) return;

    if( DhcpOptions->ClientHardwareAddressLength >= strlen(DHCP_RAS_PREPEND) &&
        0 == memcmp(
            DhcpOptions->ClientHardwareAddress,
            DHCP_RAS_PREPEND,
            strlen(DHCP_RAS_PREPEND)
        )
    ) {
        //
        // This is actually a RAS server getting the address from us.
        // Don't do anything for this case..
        //
        return;
    }

    if( DhcpOptions->DNSNameLength == 1 &&
        L'\0' == *(DhcpOptions->DNSName) ) {
        //
        // Do not register anything for bad DNS option..
        //
        return;
    }

    status = DhcpGetParameter(
        IpAddress,
        RequestContext,
        OPTION_DYNDNS_BOTH,
        &OptionValue,
        &OptionSize,
        NULL
    );

    if( ERROR_SUCCESS == status && OptionSize == sizeof(DWORD)) {
        memcpy(&DnsFlag, OptionValue, sizeof(DWORD));

        DnsFlag = ntohl(DnsFlag);
    } else {
        DnsFlag = DNS_FLAG_ENABLED | DNS_FLAG_CLEANUP_EXPIRED ;
    }

    if( OptionValue ) DhcpFreeMemory(OptionValue);

    if( !(DNS_FLAG_ENABLED & DnsFlag ) ) {
        DnsFlag = 0;
    } else if( !(DNS_FLAG_UPDATE_BOTH_ALWAYS & DnsFlag ) ) {
        // Do as requested by client.

        if( IS_CLIENT_DOING_A_AND_PTR(DhcpOptions->DNSFlags) ) {
            // Client wants to handle both A and Ptr records.. Let it do it.
            DnsFlag &= ~DNS_FLAG_UPDATE_DOWNLEVEL;
        } else if( DYNDNS_DOWNLEVEL_CLIENT ==
                   DhcpOptions->DNSFlags ) {

            // DOWN level client... Check if it is enabled ?
            if( !( DNS_FLAG_UPDATE_DOWNLEVEL & DnsFlag ) )
                DnsFlag = 0;
        }
	else {
	    DnsFlag |= DNS_FLAG_UPDATE_DOWNLEVEL;
	}
    } else {
        if( DYNDNS_DOWNLEVEL_CLIENT == DhcpOptions->DNSFlags ) {
            // DOWN level client... Check if it is enabled ?
            if( !( DNS_FLAG_UPDATE_DOWNLEVEL & DnsFlag ) )
                DnsFlag = 0;
        } else {
            // We are going to update BOTH always
            DnsFlag |= DNS_FLAG_UPDATE_DOWNLEVEL;
        }
    }

    if( DNS_FLAG_ENABLED & DnsFlag ) {
        (*pFlags) = AddressUnRegistered(*pFlags);    // Do DNS for this client

        if( DNS_FLAG_UPDATE_DOWNLEVEL & DnsFlag )
            (*pFlags) = AddressUpdateAPTR(*pFlags);  // update both records for client

        if( DNS_FLAG_CLEANUP_EXPIRED & DnsFlag )
            (*pFlags) = AddressCleanupRequired(*pFlags); // cleanup on expiry
    } else {                                    // No DNS stuff enabled here
        (*pFlags ) = 0;
    }

    DhcpPrint((DEBUG_DNS, "DNS State for <%s> is: %s, %s (%02x)\n",
               (*pFlags)? "DNS Enabled " : "DnsDisabled ",
               ((*pFlags) & ADDRESS_BIT_BOTH_REC)? "DownLevel " : "Not DownLevel ",
               ((*pFlags) & ADDRESS_BIT_CLEANUP) ? "CleanupOnExpiry" : "No CleanupOnExpiry",
               (*pFlags)
    ));

    return;
}

//--------------------------------------------------------------------------------
//  $DhcpAppendDnsRelatedOptions will append the OPTION_DYNDNS_BOTH with flags
//  either 3 or 0 depending on whether the client was down level or not respectively.
//  It fills in the other two RCODE's with 255.
//--------------------------------------------------------------------------------
POPTION _inline
DhcpAppendDnsRelatedOptions(
    OUT     PVOID                  Option,             // Option to append at the end of.
    IN      DHCP_SERVER_OPTIONS   *DhcpOptions,        // reqd for client name etc. info
    IN      PVOID                  OptionEnd,          // make sure opt doesnt go beyond this.
    IN      BOOL                   DownLevelClient     // client requires dns fwd/rev updates?
) {
    DWORD memSize;

    struct /* anonymous */ {
        BYTE flags;
        BYTE rcode1;
        BYTE rcode2;
    } value;

    if( USE_NO_DNS ) return Option;
    if( NULL == DhcpOptions->DNSName ) {               // if the client never event sent a DNS option..
        DhcpAssert(DownLevelClient == TRUE);           // this had better be a down level client
        return Option;
    }

    ASSERT(sizeof(value) == 3);

    // these flags of 0xff imply we are unaware of DynDNS return values.
    value.rcode1 = value.rcode2 = 0xff;

    // if we did DNS fwd&rev then flags=0x03, not 0x00
    if ( DownLevelClient ) {
        value.flags = DYNDNS_S_BIT;     
        if ( IS_CLIENT_DOING_A_AND_PTR( DhcpOptions->DNSFlags )) {
            value.flags |= DYNDNS_O_BIT;
        }
    }
    else {
        value.flags = 0;
    }

    value.flags |= (DhcpOptions->DNSFlags & DYNDNS_E_BIT );
    
    // if we are not doing both fwd/rev dns, dont give return code for 2.
    if( DownLevelClient ) {
        value.rcode2 = 0;
    }

    // Now just append this stuff.
    Option = DhcpAppendOption(
        Option,
        OPTION_DYNDNS_BOTH,
        (PVOID)&value,
        (BYTE)sizeof(value),
        OptionEnd
    );

    return Option;
}

DWORD
DhcpDetermineInfoFromMessage(                          // find standard info from message
    IN      LPDHCP_REQUEST_CONTEXT RequestContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    OUT     LPBYTE                *OptionHardwareAddress,
    OUT     DWORD                 *OptionHardwareAddressLength,
    OUT     DHCP_IP_ADDRESS       *ClientSubnetAddress
) {
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    DHCP_IP_ADDRESS                RelayAgentAddress;
    DHCP_IP_ADDRESS                RelayAgentSubnetMask;


    dhcpReceiveMessage = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;

    if( DhcpOptions->ClientHardwareAddress != NULL ) { // if specified in options use that
        *OptionHardwareAddress = DhcpOptions->ClientHardwareAddress;
        *OptionHardwareAddressLength = DhcpOptions->ClientHardwareAddressLength;
    } else {                                           // else use the one in the static field
        *OptionHardwareAddress = dhcpReceiveMessage->HardwareAddress;
        *OptionHardwareAddressLength = dhcpReceiveMessage->HardwareAddressLength;
        if( 0 == dhcpReceiveMessage->HardwareAddressLength ) {
            return ERROR_DHCP_INVALID_DHCP_MESSAGE;
        }
    }

    //
    // This function is relied on by ProcessDhcpRelease where it will pass
    // a NULL. In case of ProcessDhcpDiscover, it will pass a NON NULL
    // parameter.
    // NULL checking added for whistler bug 291164
    //

    if ( ClientSubnetAddress == NULL )
    {
        return ERROR_SUCCESS;
    }

    if( 0 == dhcpReceiveMessage->RelayAgentIpAddress ) {
        *ClientSubnetAddress = ntohl( RequestContext->EndPointIpAddress );
        (*ClientSubnetAddress) &= DhcpGetSubnetMaskForAddress(*ClientSubnetAddress);
        if( 0 == (*ClientSubnetAddress) ) {
            return ERROR_FILE_NOT_FOUND;
        }

    } else {
        RelayAgentAddress = ntohl( dhcpReceiveMessage->RelayAgentIpAddress );
        RelayAgentSubnetMask = DhcpGetSubnetMaskForAddress( RelayAgentAddress );

        if( RelayAgentSubnetMask == 0 ) {              // dont know about this subnet
            return ERROR_FILE_NOT_FOUND;               // avoid a NAK..
        }

        *ClientSubnetAddress = (RelayAgentAddress & RelayAgentSubnetMask);
    }

    return ERROR_SUCCESS;
}

BOOL
ConvertOemToUtf8(
    IN LPSTR OemName,
    IN OUT LPSTR Utf8Name,
    IN ULONG BufSize
    )
{
    WCHAR Buf[300];
    DWORD Count;
    
    if( BufSize < sizeof(Buf)/sizeof(Buf[0]) ) {
        ASSERT(FALSE);
        return FALSE;
    }

    Count = MultiByteToWideChar(
        CP_OEMCP, MB_ERR_INVALID_CHARS, OemName, -1,
        (LPWSTR)Buf, sizeof(Buf)/sizeof(Buf[0]));
    if( 0 == Count ) return FALSE;

    Count = WideCharToMultiByte(
        CP_UTF8, 0, Buf, -1, Utf8Name, BufSize, NULL, NULL );

    //
    // N.B. Looks like there is no such thing as a default
    // character for UTF8 - so we have to assume this
    // succeeded.. 
    // if any default characters were used, then it can't be
    // converted actually.. so don't allow this
    //
    
    return (Count != 0);
}

VOID
DhcpDetermineHostName(                                 // find and null terminate the host name
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,         // client context (for reservation info)
    IN      DHCP_IP_ADDRESS        IpAddress,          // ip address being offered to client
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,        // to get the MachineName etc.
    OUT     LPWSTR                *HostName,           // fill this with the required pointer
    IN      LPWSTR                 Buffer,             // use this as buffer
    IN      DWORD                  BufSize             // how many WCHARs can the Buffer take?
) {
    WCHAR                          Tmp[2*OPTION_END+2];
    BYTE                           Buf[2*OPTION_END+2];// host name cannot be bigger than this
    BYTE                           Buf2[2*OPTION_END+2];// host name cannot be bigger than this
    LPBYTE                         AsciiName;
    LPBYTE                         FirstChoiceName;
    LPBYTE                         SecondChoiceName;
    DWORD                          FirstChoiceSize;
    DWORD                          SecondChoiceSize;
    DWORD                          Error;
    DWORD                          Size;
    DWORD                          HostNameSize;
    BOOL                           fUtf8;
    
    *HostName = NULL;
    AsciiName = NULL;
    fUtf8 = ((DhcpOptions->DNSFlags & DYNDNS_E_BIT) != 0 );
    
    if( CFLAG_FOLLOW_DNSDRAFT_EXACTLY ) {              // follow everything per DRAFT exactly
        FirstChoiceName = DhcpOptions->DNSName;
        FirstChoiceSize = DhcpOptions->DNSNameLength;
        SecondChoiceName = DhcpOptions->MachineName;
        SecondChoiceSize = DhcpOptions->MachineNameLength;
    } else {                                           // better solution -- use MachineName..
        FirstChoiceName = DhcpOptions->MachineName;
        FirstChoiceSize = DhcpOptions->MachineNameLength;
        SecondChoiceName = DhcpOptions->DNSName;
        SecondChoiceSize = DhcpOptions->DNSNameLength;
    }

    if( NULL != FirstChoiceName && 0 != FirstChoiceSize 
        && '\0' != *FirstChoiceName ) {
        if( '\0' == FirstChoiceName[FirstChoiceSize-1] )
            AsciiName = FirstChoiceName;               // cool already nul terminated!
        else {                                         // nope, have to nul terminate it
            AsciiName = Buf;
            memcpy(AsciiName, FirstChoiceName, FirstChoiceSize);
            AsciiName[FirstChoiceSize] = '\0';
        }
        if( FirstChoiceName != DhcpOptions->DNSName ) {
            fUtf8 = FALSE;
        }
    } else if( NULL != SecondChoiceName && 0 != SecondChoiceSize ) {
        if( '\0' == SecondChoiceName[SecondChoiceSize-1] )
            AsciiName = SecondChoiceName;              // already null terminated
        else {                                         // nope, we have to null terminate this
            AsciiName = Buf;
            memcpy(AsciiName, SecondChoiceName, SecondChoiceSize);
            AsciiName[SecondChoiceSize] = '\0';
        }
        if( SecondChoiceName != DhcpOptions->DNSName ) {
            fUtf8 = FALSE;
        }
    } else if( NULL != ClientCtxt->Reservation ) {     // nah! got to get this from configured options now
        Size = sizeof(Buf)-1;
        Error = DhcpGetAndCopyOption(              // get the option for host name
            0,                                         // zero address -- no client would have this, but dont matter
            ClientCtxt,
            OPTION_HOST_NAME,
            Buf,
            &Size,
            NULL,                                      // dont care about which level this option is obtained
            TRUE /* use UTF8 */
            );
        if( ERROR_SUCCESS != Error || 0 == Size ) return;
        Buf[Size] = '\0';
        AsciiName = Buf;
        fUtf8 = TRUE;
    }

    if( !AsciiName || !*AsciiName ) return ;           // no name or empty name?

    //
    // Data is not in UTF8 format. Convert it to UTF8 format..
    //
    
    if( !fUtf8 ) {
        if(!ConvertOemToUtf8(AsciiName, Buf2, sizeof(Buf2))) return;
        AsciiName = Buf2;
    }
    
    if( NULL == strchr(AsciiName, '.') ) {             // does not already have a domain name? (not FQDN)
        HostNameSize = strlen(AsciiName);
        if( HostNameSize <= OPTION_END -1 ) {          // enough space for a '.' and domain name..
            if( Buf != AsciiName ) {                   // make sure we have the data in buf so that ..
                strcpy(Buf, AsciiName);                // .. we can pad it in with the domain name..
                AsciiName = Buf;
            }
            Buf[HostNameSize] = '.' ;                  // connector '.'
            Size = sizeof(Buf)-1-HostNameSize-1;       // remove space occupied by '.' ..
            Error = DhcpGetAndCopyOption(              // get the option for domain name...
                IpAddress,                             // client ip address
                ClientCtxt,
                OPTION_DOMAIN_NAME,
                &Buf[HostNameSize+1],
                &Size,
                NULL,                                  // dont care abt level..
                TRUE /* use utf8 */
                );
            if( ERROR_SUCCESS != Error || 0 == Size ) {// couldnt copy domain name..
                Buf[HostNameSize] = '\0';              // forget this domain name business..
            } else {                                   // did copy domain name.. nul terminate it..
                Buf[HostNameSize+Size+1] = '\0';
            }
        }
    }

    if( BufSize <= strlen(AsciiName) ) {               // not enough space!
        return ;
    }

    if( 0 != ConvertUTF8ToUnicode(
        AsciiName, -1, (LPWSTR)Tmp, sizeof(Tmp)/sizeof(WCHAR))) {
        *HostName = DhcpAllocateMemory(
            sizeof(WCHAR)*(1+wcslen(Tmp)));
        if( NULL != *HostName ) {
            wcscpy(*HostName, Tmp);
        }
    }
}

DWORD
ProcessBootpRequest(                                   // process a bootp request
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,     // info on this particular client, including message
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,        // parsed options
    IN OUT  LPPACKET               AdditionalContext,  // asynchronous ping information
    IN OUT  LPDWORD                AdditionalStatus    // is it asynchronous? if so this is set to ERROR_IO_PENDING
) {
    WCHAR                          ServerName[MAX_COMPUTERNAME_LENGTH + 10];
    DWORD                          Length;
    DWORD                          Error;
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_MESSAGE                 dhcpSendMessage;
    CHAR                           szBootFileName[ BOOT_FILE_SIZE];
    CHAR                           szBootServerName[ BOOT_SERVER_SIZE ];
    LPOPTION                       Option;
    LPBYTE                         OptionEnd;

    DHCP_IP_ADDRESS                desiredIpAddress = NO_DHCP_IP_ADDRESS;
    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                ClientSubnetMask = 0;
    DHCP_IP_ADDRESS                networkOrderSubnetMask;
    DHCP_IP_ADDRESS                networkOrderIpAddress;
    DHCP_IP_ADDRESS                BootpServerIpAddress = 0;
    DHCP_IP_ADDRESS                desiredSubnetMask;

    DWORD                          StateFlags = 0;

    BYTE                          *HardwareAddress = NULL;
    DWORD                          HardwareAddressLength;
    BYTE                           bAllowedClientType;

    BYTE                          *OptionHardwareAddress;
    DWORD                          OptionHardwareAddressLength;
    BOOL                           DatabaseLocked = FALSE;
    BOOL                           fSwitchedSubnet;

    WCHAR                          LocalBufferForMachineNameUnicodeString[OPTION_END+2];
    LPWSTR                         NewMachineName;
    LPBYTE                         OptionMachineName;  // Did we send out the mc name as option?

    Length = MAX_COMPUTERNAME_LENGTH + 10;         // get the server name
    if( !GetComputerName( ServerName, &Length ) ) {
        Error = GetLastError();
        DhcpPrint(( DEBUG_ERRORS, "Can't get computer name, %ld.\n", Error ));

        return Error ;
    }

    DhcpAssert( Length <= MAX_COMPUTERNAME_LENGTH );
    ServerName[Length] = L'\0';

    NewMachineName = NULL;
    OptionMachineName = NULL;

    DhcpPrint((DEBUG_STOC, "Bootp Request arrived.\n"));

    dhcpReceiveMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;

    if( AdditionalStatus ) *AdditionalStatus = ERROR_SUCCESS;

    if( DhcpOptions->Server || DhcpOptions->RequestedAddress ) {
        return ERROR_DHCP_INVALID_DHCP_MESSAGE;        // BOOTP clients cannot use Server Id option..
    }

    // make sure the host name and server name fields are null-terminated

    dhcpReceiveMessage->HostName[ BOOT_SERVER_SIZE - 1] = '\0';
    dhcpReceiveMessage->BootFileName[ BOOT_FILE_SIZE - 1 ] = '\0';

    if ( dhcpReceiveMessage->HostName[0] ) {           // if a server-name is mentioned, it should be us
        WCHAR szHostName[ BOOT_SERVER_SIZE ];

        if ( !DhcpOemToUnicode( dhcpReceiveMessage->HostName, szHostName ) ) {
            return ERROR_DHCP_INVALID_DHCP_MESSAGE;    // can this be handled any better?
        }

        if ( _wcsicmp( szHostName, ServerName ) ) {
            return ERROR_DHCP_INVALID_DHCP_MESSAGE;    // maybe destined for some other bootp/dhcp server
        }
    }

    Error = DhcpDetermineInfoFromMessage(              // find h/w address and subnet address of client
        RequestContext,
        DhcpOptions,
        &OptionHardwareAddress,
        &OptionHardwareAddressLength,
        &ClientSubnetAddress
    );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpLookupReservationByHardwareAddress(    // search for a reservation with this hardware address
        ClientSubnetAddress,                           // filter off to include only subnets in superscope with this
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        RequestContext                                 // fill in the reservation details into the context
    );
    if( ERROR_SUCCESS != Error ) {                     // did not find this hardware address?
        DhcpAssert( ERROR_FILE_NOT_FOUND == Error);    // there should be no other problem, really

        return ERROR_DHCP_INVALID_DHCP_CLIENT;         // no reservation for this client
    }

    DhcpReservationGetAddressAndType(
        RequestContext->Reservation,
        &desiredIpAddress,
        &bAllowedClientType
    );
    DhcpSubnetGetSubnetAddressAndMask(
        RequestContext->Subnet,
        &ClientSubnetAddress,
        &desiredSubnetMask
    );
    ClientSubnetMask = desiredSubnetMask;

    if( dhcpReceiveMessage->ClientIpAddress ) {        // client is requesting specific address
        if( desiredIpAddress != ntohl(dhcpReceiveMessage->ClientIpAddress) )
            return ERROR_DHCP_INVALID_DHCP_CLIENT;     // reservation exists for some other address
    }

    if( !(bAllowedClientType & CLIENT_TYPE_BOOTP )) {  // does this reservation allow bootp clients?
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    if( DhcpSubnetIsDisabled(RequestContext->Subnet, TRUE)) {
        return ERROR_DHCP_INVALID_DHCP_CLIENT;         // sorry, this subnet is currently in disabled mode
    }

    DhcpGetBootpInfo(                                  // get boot file name and tftp server
        RequestContext,
        desiredIpAddress,
        desiredSubnetMask,
        dhcpReceiveMessage->BootFileName,
        szBootFileName,
        &BootpServerIpAddress
    );

    if( INADDR_NONE == BootpServerIpAddress ) {        // admin specified wrong Boopt server for phase 2
        return ERROR_DHCP_INVALID_DHCP_CLIENT;         // dont respond.
    }

    DhcpDetermineHostName(                             // calculate the client host name
        RequestContext,
        desiredIpAddress,
        DhcpOptions,
        &NewMachineName,
        LocalBufferForMachineNameUnicodeString,        // give a buffer to return the name, and limit the max size also
        sizeof(LocalBufferForMachineNameUnicodeString)/sizeof(WCHAR)
    );

    HardwareAddress = NULL;
    Error = DhcpMakeClientUID(                         // ok, make extended UID for the database
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        dhcpReceiveMessage->HardwareAddressType,
        ClientSubnetAddress,
        &HardwareAddress,                              // allocate hardware address bits
        &HardwareAddressLength
    );
    if ( ERROR_SUCCESS != Error ) {
        if ( NULL != NewMachineName ) {
            DhcpFreeMemory( NewMachineName );
        }
        return Error;
    }
    DhcpAssert(HardwareAddress);

    PrintHWAddress( HardwareAddress, (BYTE)HardwareAddressLength );

    LOCK_DATABASE();
    DhcpDnsDecideOptionsForClient(                     // check out and see if the client needs DNS (de)registrations..
        desiredIpAddress,
        RequestContext,
        DhcpOptions,                                   // need to look at the client specified options
        &StateFlags                                    // OUT tell if the client is a down level client or not.
    );

    Error = DhcpCreateClientEntry(                     // now actually try to create a Database record
        desiredIpAddress,
        HardwareAddress,
        HardwareAddressLength,
        DhcpCalculateTime(INFINIT_LEASE),
        NewMachineName,
        NULL,
        CLIENT_TYPE_BOOTP,
        ntohl(RequestContext->EndPointIpAddress),
        (CHAR)(StateFlags | ADDRESS_STATE_ACTIVE),
        TRUE                                           // Existing
    );
    UNLOCK_DATABASE();
    DhcpFreeMemory(HardwareAddress);
    HardwareAddress = NULL;
    HardwareAddressLength = 0;

    if( Error != ERROR_SUCCESS ) {                     // could not create the entry?
        DhcpAssert( Error != ERROR_DHCP_RANGE_FULL );  // BOOTP clients cannot have this problem?
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_NOADDRESS);

        if ( NULL != NewMachineName ) {
            DhcpFreeMemory( NewMachineName );
        }
        return Error;
    }

    CALLOUT_RENEW_BOOTP(AdditionalContext, desiredIpAddress, INFINIT_LEASE);

    DhcpUpdateAuditLog(                                // log this event onto the audit logging facility
        DHCP_IP_LOG_BOOTP,
        GETSTRING( DHCP_IP_LOG_BOOTP_NAME ),
        desiredIpAddress,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        NewMachineName
    );

    if ( NULL != NewMachineName ) {
        DhcpFreeMemory( NewMachineName );
    }

    DhcpAssert( desiredIpAddress != NO_DHCP_IP_ADDRESS );
    DhcpAssert( desiredIpAddress != 0 );
    DhcpAssert( desiredIpAddress != ClientSubnetAddress );
    DhcpAssert( ClientSubnetMask != 0 );

    //
    // Now generate and send a reply.
    //

    dhcpReceiveMessage->Reserved |= DHCP_BROADCAST;    // force server to broadcast response

    dhcpSendMessage = (LPDHCP_MESSAGE) RequestContext->SendBuffer;
    RtlZeroMemory( RequestContext->SendBuffer, BOOTP_MESSAGE_SIZE );

    dhcpSendMessage->Operation = BOOT_REPLY;
    dhcpSendMessage->TransactionID = dhcpReceiveMessage->TransactionID;
    dhcpSendMessage->YourIpAddress = htonl( desiredIpAddress );

    if ( BootpServerIpAddress )
        dhcpSendMessage->BootstrapServerAddress = BootpServerIpAddress;
    else
        dhcpSendMessage->BootstrapServerAddress = RequestContext->EndPointIpAddress;

    dhcpSendMessage->Reserved = dhcpReceiveMessage->Reserved;

    dhcpSendMessage->HardwareAddressType =
        dhcpReceiveMessage->HardwareAddressType;
    dhcpSendMessage->HardwareAddressLength =
        dhcpReceiveMessage->HardwareAddressLength;
    RtlCopyMemory(
        dhcpSendMessage->HardwareAddress,
        dhcpReceiveMessage->HardwareAddress,
        dhcpReceiveMessage->HardwareAddressLength
    );

    dhcpSendMessage->RelayAgentIpAddress = dhcpReceiveMessage->RelayAgentIpAddress;

    strncpy( dhcpSendMessage->BootFileName, szBootFileName, BOOT_FILE_SIZE);
    RtlZeroMemory( dhcpSendMessage->HostName, BOOT_SERVER_SIZE );

    Option = &dhcpSendMessage->Option;
    OptionEnd = (LPBYTE)dhcpSendMessage + BOOTP_MESSAGE_SIZE;

    Option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) Option, OptionEnd );

    fSwitchedSubnet = DhcpSubnetIsSwitched( RequestContext->Subnet );

    if ( fSwitchedSubnet ) {                           // see dhcpsrv.doc on switched subnets..
        networkOrderIpAddress =  htonl( desiredIpAddress );
        Option = DhcpAppendOption(                     // set router address as self ==> all subnets are on the same wire
            Option,
            OPTION_ROUTER_ADDRESS,
            &networkOrderIpAddress,
            sizeof( networkOrderIpAddress ),
            OptionEnd
        );
    }

    networkOrderSubnetMask = htonl( ClientSubnetMask );

    Option = DhcpAppendOption(
        Option,
        OPTION_SUBNET_MASK,
        &networkOrderSubnetMask,
        sizeof(networkOrderSubnetMask),
        OptionEnd
    );

    if( 0 != StateFlags ) {                            // Append DYNDNS related options
        Option = DhcpAppendDnsRelatedOptions(
            Option,
            DhcpOptions,
            OptionEnd,
            IS_DOWN_LEVEL(StateFlags)
        );
    }

    if ( !DhcpOptions->ParameterRequestList ) {        // add any parameters requested by the client
        // fake a default set of requests..
        DhcpOptions->ParameterRequestList       = pbOptionList;
        DhcpOptions->ParameterRequestListLength = sizeof( pbOptionList ) / sizeof( *pbOptionList );
    }

    Option = AppendClientRequestedParameters(
        desiredIpAddress,
        RequestContext,
        DhcpOptions->ParameterRequestList,
        DhcpOptions->ParameterRequestListLength,
        Option,
        OptionEnd,
        fSwitchedSubnet,
        TRUE
    );

    Option = DhcpAppendOption(
        Option,
        OPTION_END,
        NULL,
        0,
        OptionEnd
    );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    DhcpAssert( RequestContext->SendMessageSize <= BOOTP_MESSAGE_SIZE );

    DhcpPrint((DEBUG_STOC, "Bootp Request leased, %s.\n", DhcpIpAddressToDottedString(desiredIpAddress)));

    return ERROR_SUCCESS;
}

DWORD                                                  // must be called with pending list lock taken
DhcpDiscoverValidateRequestedAddress(                  // check if everything is ok with the address being requested by client
    IN      PDHCP_REQUEST_CONTEXT  RequestContext,     // input request context
    IN      DHCP_IP_ADDRESS UNALIGNED *RequestedAddress, // client may be requesting something
    IN      LPBYTE                 HardwareAddress,
    IN      DWORD                  HardwareAddressLength,
    IN      BOOL                   fBootp,
    OUT     DHCP_IP_ADDRESS       *IpAddress           // this is the ip address chosen
)
{
    DHCP_IP_ADDRESS                desiredIpAddress;
    DHCP_IP_ADDRESS                SubnetAddress;
    DWORD                          Mask;
    DWORD                          Error;
    LPDHCP_PENDING_CTXT            PendingCtxt;

    DhcpSubnetGetSubnetAddressAndMask(
        RequestContext->Subnet,
        &SubnetAddress,
        &Mask
    );

    if( NULL == RequestedAddress ) {                   // no requests from the client
        *IpAddress = SubnetAddress;                    // choose some address from a subnet later
        return ERROR_SUCCESS;
    }

    desiredIpAddress = ntohl(*RequestedAddress);

    if( ! DhcpInSameSuperScope(desiredIpAddress, SubnetAddress) ) {
        *IpAddress = SubnetAddress;
        return ERROR_SUCCESS;
    }

    Error = DhcpFindPendingCtxt(
        NULL,
        0,
        desiredIpAddress,
        &PendingCtxt
    );
    if( ERROR_SUCCESS == Error ) {                     // found someone else waiting on this address...
        *IpAddress = SubnetAddress;
        return ERROR_SUCCESS;
    }

    Error = DhcpGetSubnetForAddress(
        desiredIpAddress,
        RequestContext
    );
    if( ERROR_SUCCESS != Error ) {
        Error = DhcpGetSubnetForAddress(
            SubnetAddress,
            RequestContext
        );
        DhcpAssert(ERROR_SUCCESS == Error);
        *IpAddress = SubnetAddress;
        return ERROR_SUCCESS;
    }

    if( DhcpSubnetIsDisabled(RequestContext->Subnet, fBootp ) ) {
        DhcpPrint((DEBUG_ERRORS, "Client request is on a disabled subnet..\n"));
        Error = ERROR_FILE_NOT_FOUND;
    } else if( DhcpAddressIsOutOfRange(desiredIpAddress, RequestContext, fBootp ) ||
               DhcpAddressIsExcluded(desiredIpAddress, RequestContext ) ) {
        DhcpPrint((DEBUG_ERRORS, "Client requested out of range or exlcluded address\n"));
        Error = ERROR_FILE_NOT_FOUND;
    } else {
        if( DhcpRequestSpecificAddress(RequestContext, desiredIpAddress) ) {
            Error = ERROR_IO_PENDING;                  // we just retrieved this addres.. we need to do conflict detection
            *IpAddress = desiredIpAddress;
        } else {
            BOOL fUnused;
            if( DhcpIsClientValid(
                desiredIpAddress, "ImpossibleHwAddress",
                sizeof("ImpossibleHwAddress"), &fUnused) ) {
                Error = ERROR_IO_PENDING;              // client is requesting an address that we is not available in registry
                *IpAddress = desiredIpAddress;         // but looks like database is ok with it... so give it to him..
            } else {
                Error = ERROR_FILE_NOT_FOUND;
            }
        }
    }

    if( ERROR_SUCCESS != Error && ERROR_IO_PENDING != Error ) {
        *IpAddress = SubnetAddress;
        Error = DhcpGetSubnetForAddress(
            SubnetAddress,
            RequestContext
        );
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_SUCCESS;
    return Error;
}

DWORD
DhcpRespondToDiscover(                                 // respond to the DISCOVER message
    IN      LPDHCP_REQUEST_CONTEXT RequestContext,
    IN      LPPACKET               AdditionalContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    IN      LPBYTE                 OptionHardwareAddress,
    IN      DWORD                  OptionHardwareAddressLength,
    IN      DHCP_IP_ADDRESS        desiredIpAddress,
    IN      DWORD                  leaseDuration,
    IN      DWORD                  T1,
    IN      DWORD                  T2
    )
//
//  If desiredIpAddress is 0, then this client already has an IP address and
//  we're just passing back BINL's response.
//
{
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_MESSAGE                 dhcpSendMessage;
    DHCP_IP_ADDRESS                desiredSubnetMask;
    DHCP_IP_ADDRESS                ClientSubnetAddress;
    DHCP_IP_ADDRESS                ClientSubnetMask;
    DHCP_IP_ADDRESS                networkOrderIpAddress;
    DHCP_IP_ADDRESS                networkOrderSubnetMask;
    DWORD                          Error;
    BYTE                           messageType;
    CHAR                           szBootFileName[ BOOT_FILE_SIZE ];
    CHAR                           szBootServerName[ BOOT_SERVER_SIZE ];
    LPOPTION                       Option;
    LPBYTE                         OptionEnd;
    BOOL                           fSwitchedSubnet, fBootp;
    DWORD                          BootpServerIpAddress;
    LPWSTR                         NewMachineName;
    WCHAR                          LocalBufferForMachineNameUnicodeString[256];
    ULONG                          StateFlags =0;

    fBootp = (NULL == DhcpOptions->MessageType );
    dhcpReceiveMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;

    DhcpAssert( desiredIpAddress != NO_DHCP_IP_ADDRESS );

    if ( desiredIpAddress != 0 ) {

        DhcpSubnetGetSubnetAddressAndMask(
            RequestContext->Subnet,
            &ClientSubnetAddress,
            &desiredSubnetMask
        );
        ClientSubnetMask = desiredSubnetMask;

        DhcpGetBootpInfo(
            RequestContext,
            desiredIpAddress,
            ClientSubnetMask,
            dhcpReceiveMessage->BootFileName,
            szBootFileName,
            &BootpServerIpAddress
        );
    }

    dhcpReceiveMessage->BootFileName[ BOOT_FILE_SIZE - 1 ] = '\0';

    if( fBootp ) {
        DhcpAssert( desiredIpAddress != 0 );
        if( NULL != RequestContext->Reservation ) {
            //
            // For BOOTP reservations, we use INFINITE_LEASE...
            //
            leaseDuration = INFINIT_LEASE;
        }
    }

    if( fBootp && (desiredIpAddress != 0) ) {
        LPBYTE HardwareAddress = NULL;
        ULONG HardwareAddressLength;

        if( INADDR_NONE == BootpServerIpAddress ) {
            //
            // Illegal bootp server specified by admin
            //
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }

        DhcpDetermineHostName(
            RequestContext,
            desiredIpAddress,
            DhcpOptions,
            &NewMachineName,
            LocalBufferForMachineNameUnicodeString,
            sizeof(LocalBufferForMachineNameUnicodeString)/sizeof(WCHAR)
            );

        Error = DhcpMakeClientUID(
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            dhcpReceiveMessage->HardwareAddressType,
            ClientSubnetAddress,
            &HardwareAddress,
            &HardwareAddressLength
            );
        if( ERROR_SUCCESS != Error ) {
            if ( NULL != NewMachineName ) {
                DhcpFreeMemory( NewMachineName );
            }
            return Error;
        }

        PrintHWAddress( HardwareAddress, (BYTE)HardwareAddressLength );

        LOCK_DATABASE();
        DhcpDnsDecideOptionsForClient(
            desiredIpAddress,
            RequestContext,
            DhcpOptions,
            &StateFlags
            );

        Error = DhcpJetOpenKey(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
            (PVOID)&desiredIpAddress,
            sizeof(desiredIpAddress)
            );
        Error = DhcpCreateClientEntry(
            desiredIpAddress,
            HardwareAddress,
            HardwareAddressLength,
            DhcpCalculateTime(leaseDuration),
            NewMachineName,
            NULL,
            CLIENT_TYPE_BOOTP,
            ntohl(RequestContext->EndPointIpAddress),
            (CHAR)(StateFlags | ADDRESS_STATE_ACTIVE ),
            ERROR_SUCCESS == Error
            );

        UNLOCK_DATABASE();
        DhcpFreeMemory(HardwareAddress);

        if( ERROR_SUCCESS != Error ) {
            CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_NOADDRESS);
            return Error;
        }

        CALLOUT_RENEW_BOOTP(AdditionalContext, desiredIpAddress, leaseDuration );
        DhcpUpdateAuditLog(
            RequestContext->Reservation ? DHCP_IP_LOG_BOOTP : DHCP_IP_LOG_DYNBOOTP,
            GETSTRING( (RequestContext->Reservation ?
                        DHCP_IP_LOG_BOOTP_NAME : DHCP_IP_LOG_DYNBOOTP_NAME
                )),
            desiredIpAddress,
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            NewMachineName
            );

        if ( NULL != NewMachineName ) {
            DhcpFreeMemory( NewMachineName );
        }
    }

    dhcpSendMessage = (LPDHCP_MESSAGE) RequestContext->SendBuffer;
    RtlZeroMemory( RequestContext->SendBuffer, DHCP_SEND_MESSAGE_SIZE );

    dhcpSendMessage->Operation = BOOT_REPLY;
    dhcpSendMessage->TransactionID = dhcpReceiveMessage->TransactionID;
    dhcpSendMessage->YourIpAddress = htonl( desiredIpAddress );
    if( FALSE == fBootp ) {
        dhcpSendMessage->Reserved = dhcpReceiveMessage->Reserved;
    } else {
        dhcpSendMessage->Reserved = dhcpReceiveMessage->Reserved | DHCP_BROADCAST;
    }

    dhcpSendMessage->HardwareAddressType = dhcpReceiveMessage->HardwareAddressType;
    dhcpSendMessage->HardwareAddressLength = dhcpReceiveMessage->HardwareAddressLength;
    RtlCopyMemory(
        dhcpSendMessage->HardwareAddress,
        dhcpReceiveMessage->HardwareAddress,
        dhcpReceiveMessage->HardwareAddressLength
    );

    if( BootpServerIpAddress && (fBootp || desiredIpAddress != 0) ) {
        dhcpSendMessage->BootstrapServerAddress = BootpServerIpAddress;
    } else {
        dhcpSendMessage->BootstrapServerAddress = RequestContext->EndPointIpAddress;
    }

    dhcpSendMessage->RelayAgentIpAddress =  dhcpReceiveMessage->RelayAgentIpAddress;

    RtlZeroMemory( dhcpSendMessage->HostName, BOOT_SERVER_SIZE );

    if ( fBootp || desiredIpAddress != 0 ) {
        strncpy( dhcpSendMessage->BootFileName, szBootFileName, BOOT_FILE_SIZE );
    }

    Option = &dhcpSendMessage->Option;
    if( fBootp ) {
        OptionEnd = (LPBYTE)dhcpSendMessage + BOOTP_MESSAGE_SIZE;
    } else {
        OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;
    }

    Option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) Option, OptionEnd );

    if( FALSE == fBootp ) {
        messageType = DHCP_OFFER_MESSAGE;
        Option = DhcpAppendOption(
            Option,
            OPTION_MESSAGE_TYPE,
            &messageType,
            1,
            OptionEnd
            );
    }

    fSwitchedSubnet = DhcpSubnetIsSwitched(RequestContext->Subnet);

    if ( fSwitchedSubnet ) {                           // see dhcpsrv.doc for details on switched subnets
        networkOrderIpAddress = htonl( desiredIpAddress );
        Option = DhcpAppendOption(                     // set router to self ==> all subnets are on the same wire
            Option,
            OPTION_ROUTER_ADDRESS,
            &networkOrderIpAddress,
            sizeof( networkOrderIpAddress ),
            OptionEnd
        );
    }

    if ( fBootp || desiredIpAddress != 0 ) {

        ClientSubnetMask = DhcpGetSubnetMaskForAddress(desiredIpAddress);
        networkOrderSubnetMask = htonl( ClientSubnetMask );
        Option = DhcpAppendOption(
            Option,
            OPTION_SUBNET_MASK,
            &networkOrderSubnetMask,
            sizeof(networkOrderSubnetMask),
            OptionEnd
        );
    }

    if( FALSE == fBootp && desiredIpAddress != 0 ) {
        T1 = htonl( T1 );
        Option = DhcpAppendOption(
            Option,
            OPTION_RENEWAL_TIME,
            &T1,
            sizeof(T1),
            OptionEnd
            );

        T2 = htonl( T2 );
        Option = DhcpAppendOption(
            Option,
            OPTION_REBIND_TIME,
            &T2,
            sizeof(T2),
            OptionEnd
            );

        leaseDuration = htonl( leaseDuration );
        Option = DhcpAppendOption(
            Option,
            OPTION_LEASE_TIME,
            &leaseDuration,
            sizeof(leaseDuration),
            OptionEnd
            );
    }

    if( FALSE == fBootp ) {

        Option = DhcpAppendOption(
            Option,
            OPTION_SERVER_IDENTIFIER,
            &RequestContext->EndPointIpAddress,
            sizeof(RequestContext->EndPointIpAddress),
            OptionEnd
            );

    }

    if( fBootp && 0 != StateFlags ) {
        Option = DhcpAppendDnsRelatedOptions(
            Option,
            DhcpOptions,
            OptionEnd,
            IS_DOWN_LEVEL(StateFlags)
            );
    }

    if( FALSE == fBootp ) {
        //
        //  If requested & appropriate inform client of BINL service
        //

        //
        //Option = BinlProcessRequest(RequestContext, DhcpOptions, Option, OptionEnd);
        //
        BinlProcessDiscover(RequestContext, DhcpOptions );
    }

    if( fBootp && NULL == DhcpOptions->ParameterRequestList ) {
        //
        // Fake request list for bootp clients
        //
        DhcpOptions->ParameterRequestList = pbOptionList;
        DhcpOptions->ParameterRequestListLength = sizeof(pbOptionList);
    }

    if ( DhcpOptions->ParameterRequestList != NULL ) { // if client requested for parameters add 'em
        Option = AppendClientRequestedParameters(
            desiredIpAddress,
            RequestContext,
            DhcpOptions->ParameterRequestList,
            DhcpOptions->ParameterRequestListLength,
            Option,
            OptionEnd,
            fSwitchedSubnet,
            FALSE
        );
    }

    if( fBootp && DhcpOptions->ParameterRequestList == pbOptionList ) {
        DhcpOptions->ParameterRequestList = NULL;
        DhcpOptions->ParameterRequestListLength = 0;
    }

    if( fBootp || desiredIpAddress != 0 ) {
        Option = ConsiderAppendingOption(
            desiredIpAddress,
            RequestContext,
            Option,
            OPTION_VENDOR_SPEC_INFO,
            OptionEnd,
            fSwitchedSubnet
            );
    }

    Option = DhcpAppendOption(                         // done it
        Option,
        OPTION_END,
        NULL,
        0,
        OptionEnd
    );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    DhcpAssert( RequestContext->SendMessageSize <= DHCP_SEND_MESSAGE_SIZE );

    DhcpPrint((DEBUG_STOC, "DhcpDiscover leased address %s.\n", DhcpIpAddressToDottedString(desiredIpAddress)));

    InterlockedIncrement(&DhcpGlobalNumOffers);        // successful offers.
    return ERROR_SUCCESS;
}

DWORD
DhcpProcessDiscoverForValidatedAddress(                // add to pending list and send a validated address
    IN      DWORD                  desiredIpAddress,   // validated address
    IN OUT  PDHCP_REQUEST_CONTEXT  RequestContext,
    IN      LPPACKET               AdditionalContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    IN      LPBYTE                 OptionHardwareAddress,
    IN      DWORD                  OptionHardwareAddressLength,
    IN      BOOL                   AddToPendingList    // use this if dont wish to add to pending list
)
{
    DWORD                          Error, Error2;
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_MESSAGE                 dhcpSendMessage;

    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                ClientSubnetMask = 0;
    DHCP_IP_ADDRESS                desiredSubnetMask;

    DWORD                          leaseDuration;
    DWORD                          T1;
    DWORD                          T2;
    BOOL                           fBootp;

    fBootp = (NULL == DhcpOptions->MessageType);
    DhcpSubnetGetSubnetAddressAndMask(
        RequestContext->Subnet,
        &ClientSubnetAddress,
        &ClientSubnetMask
    );
    desiredSubnetMask = ClientSubnetMask;
    dhcpReceiveMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;
    DhcpAssert((desiredIpAddress & desiredSubnetMask) == ClientSubnetAddress);
    DhcpAssert(desiredIpAddress != ClientSubnetAddress);

    if( NULL == RequestContext->Reservation ) {
        if( DhcpSubnetIsAddressExcluded(
            RequestContext->Subnet , desiredIpAddress
            ) ||
            DhcpSubnetIsAddressOutOfRange(
                RequestContext->Subnet, desiredIpAddress, fBootp
                )
            ) {
            DhcpPrint((DEBUG_STOC, "Request for excluded"
                       " or out of range address tossed out\n"));
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
    }

    GetLeaseInfo(                                      // determine lease time and other details
        desiredIpAddress,
        RequestContext,
        &leaseDuration,
        &T1,
        &T2,
        DhcpOptions->RequestLeaseTime
    );

    if( NULL == DhcpOptions->MessageType ) {
        //
        // No pending list for BOOTP
        //
        AddToPendingList = FALSE;
    }

    if( AddToPendingList ) {                           // add to pending list only if asked to
        LOCK_INPROGRESS_LIST();
        Error = DhcpAddPendingCtxt(
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            desiredIpAddress,
            leaseDuration,
            T1,
            T2,
            0,
            DhcpCalculateTime( DHCP_CLIENT_REQUESTS_EXPIRE ),
            FALSE                                      // this record has been processed, nothing more to do
        );
        UNLOCK_INPROGRESS_LIST();
        DhcpAssert(ERROR_SUCCESS == Error);            // expect everything to go well here
    }

    return DhcpRespondToDiscover(
        RequestContext,
        AdditionalContext,
        DhcpOptions,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        desiredIpAddress,
        leaseDuration,
        T1,
        T2
    );
}

DWORD
ProcessDhcpDiscover(                                   // forward declaration
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    OUT     LPPACKET               AdditionalContext,
    OUT     LPDWORD                AdditionalStatus
);

DWORD
HandlePingCallback(                                    // asynchronous ping returns..
    IN      PDHCP_REQUEST_CONTEXT  RequestContext,     // the context with which we return
    IN      LPPACKET               AdditionalContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,        // parsed options
    IN      LPPACKET               Packet,             // ping context
    IN      DWORD                 *Status,             // status? useless really
    IN      LPBYTE                 OptionHardwareAddress,
    IN      DWORD                  OptionHardwareAddressLength
)
{
    LPDHCP_PENDING_CTXT            PendingCtxt;
    DWORD                          leaseDuration;
    DWORD                          T1, T2;
    DWORD                          Error;
    DWORD                          IpAddress;

    DhcpAssert(0 != Packet->PingAddress );
    LOCK_INPROGRESS_LIST();
    Error = DhcpFindPendingCtxt(
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        0,
        &PendingCtxt                                   // find the pending context if one exists for above hw address
    );
    if( ERROR_SUCCESS != Error ) {                     // oops, could not find a corresponding packet?
        UNLOCK_INPROGRESS_LIST();
        return Error;                                  // whoever deleted the context would also have released the address
    }

    // Ping call back should never find a madcap PC. Assert if it does.
    if (( PendingCtxt->Address != Packet->PingAddress ) ||
        ( FALSE == PendingCtxt->Processing )) {
        DhcpAssert(( !CLASSD_HOST_ADDR( PendingCtxt->Address )) ||
                   ( !CLASSD_HOST_ADDR( Packet->PingAddress )));
        DhcpPrint((DEBUG_STOC, "Pending ctxt for ping diff..\n"));
        UNLOCK_INPROGRESS_LIST();
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    PendingCtxt->Processing = FALSE;                   // just finished processing

    if(  Packet->DestReachable ) {                     // ok to make offer?
        Error = DhcpRemovePendingCtxt(
            PendingCtxt
        );
        UNLOCK_INPROGRESS_LIST();
        DhcpAssert(ERROR_SUCCESS == Error);
        CALLOUT_CONFLICT(Packet);
        GetLeaseInfo(
            Packet->PingAddress,
            RequestContext,
            &leaseDuration,
            &T1,
            &T2,
            NULL
        );
        LOCK_DATABASE();
        IpAddress = Packet->PingAddress;
        Error = DhcpCreateClientEntry(
            (Packet->PingAddress),
            (LPBYTE)&(Packet->PingAddress),
            sizeof(Packet->PingAddress),
            DhcpCalculateTime(leaseDuration),
            GETSTRING( DHCP_BAD_ADDRESS_NAME ),
            GETSTRING( DHCP_BAD_ADDRESS_INFO ),
            (BYTE)((NULL == DhcpOptions->MessageType) ? CLIENT_TYPE_BOOTP : CLIENT_TYPE_DHCP),
            ntohl(RequestContext->EndPointIpAddress),
            ADDRESS_STATE_DECLINED,
            ERROR_SUCCESS == DhcpJetOpenKey(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,&IpAddress,sizeof(IpAddress)
                )
            //TRUE                                     // Existing client? actually dont know, but dont matter
        );
        UNLOCK_DATABASE();

        DhcpFreeMemory(PendingCtxt);                   // dont use DhcpDeletePendingCtxt as that free's address
        Packet->PingAddress = 0;                       // zero it to indicate fresh call..
        Packet->DestReachable = FALSE;                 // initialize this ..
        DhcpOptions->RequestedAddress = NULL;          // ignore any requested address now..
        return ProcessDhcpDiscover(                    // start all over again and try to find an address
            RequestContext,
            DhcpOptions,
            Packet,
            Status
        );
    }

    // valid lease being offered
    UNLOCK_INPROGRESS_LIST();

    Error = DhcpGetSubnetForAddress(
        Packet->PingAddress,
        RequestContext
    );
    if( ERROR_SUCCESS != Error ) return Error;         // if this subnet no longer exists.. sorry buddy we got shoved

    return DhcpProcessDiscoverForValidatedAddress(
        Packet->PingAddress,
        RequestContext,
        AdditionalContext,
        DhcpOptions,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        FALSE                                          // no need to add to pending list, already there
    );
}

DWORD
ProcessDhcpDiscover(                                   // process discover packets
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,     // ptr to current request context
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,        // parsed options from the message
    OUT     LPPACKET               AdditionalContext,  // asynchronous conflict detection context
    OUT     LPDWORD                AdditionalStatus    // asynchronous conflict detection status
)
{
    WCHAR                          ServerName[MAX_COMPUTERNAME_LENGTH + 10];
    DWORD                          Length;
    DWORD                          Error, Error2;
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_MESSAGE                 dhcpSendMessage;

    BYTE                           bAllowedClientType;
    BYTE                          *OptionHardwareAddress;
    DWORD                          OptionHardwareAddressLength;

    DHCP_IP_ADDRESS                desiredIpAddress = NO_DHCP_IP_ADDRESS;
    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                ClientSubnetMask = 0;
    DHCP_IP_ADDRESS                desiredSubnetMask;

    LPDHCP_PENDING_CTXT            PendingContext;

    DWORD                          leaseDuration;
    DWORD                          T1;
    DWORD                          T2;
    DATE_TIME                      ZeroDateTime = {0, 0};
    BOOL                           fBootp;

    DhcpPrint(( DEBUG_STOC, "DhcpDiscover arrived.\n" ));

    if(AdditionalStatus) *AdditionalStatus = ERROR_SUCCESS;

    if( NULL == AdditionalContext || 0 == AdditionalContext->PingAddress ) {
        // This is a valid packet not a re-run because of ping-retry
        InterlockedIncrement(&DhcpGlobalNumDiscovers); // increment discovery counter.
    }

    fBootp = (NULL == DhcpOptions->MessageType ) ;

    dhcpReceiveMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;
    dhcpReceiveMessage->HostName[ BOOT_SERVER_SIZE - 1] = '\0';
    dhcpReceiveMessage->BootFileName[ BOOT_FILE_SIZE - 1 ] = '\0';

    if( fBootp ) {
        //
        // Bootp Clients -- verify if the server name is us (if present)
        //
        if( dhcpReceiveMessage->HostName[0] ) {
            WCHAR szHostName[ BOOT_SERVER_SIZE ];

            if( !DhcpOemToUnicode( dhcpReceiveMessage->HostName, szHostName ) ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }


            Length = MAX_COMPUTERNAME_LENGTH + 10;         // get the server name
            if( !GetComputerName( ServerName, &Length ) ) {
                Error = GetLastError();                   // need to use gethostname..
                DhcpPrint(( DEBUG_ERRORS, "Can't get computer name, %ld.\n", Error ));

                return Error ;
            }

            DhcpAssert( Length <= MAX_COMPUTERNAME_LENGTH );
            ServerName[Length] = L'\0';

            if( _wcsicmp( szHostName, ServerName ) ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
        }
    }

    if ( DhcpOptions->Server != NULL ) {               // if client specified a server in its message
        if ( *DhcpOptions->Server != RequestContext->EndPointIpAddress ) {
            return ERROR_DHCP_INVALID_DHCP_CLIENT;     // we are not the server the client wants
        }
    }

    Error = DhcpDetermineInfoFromMessage(              // find h/w address and subnet address of client
        RequestContext,
        DhcpOptions,
        &OptionHardwareAddress,
        &OptionHardwareAddressLength,
        &ClientSubnetAddress
    );
    if( ERROR_SUCCESS != Error ) return Error;

    //
    //  if binl is running and this client already has an IP address and
    //  the client specified PXECLIENT as an option, then we just pass this
    //  discover on to BINL
    //

    if (CheckForBinlOnlyRequest( RequestContext, DhcpOptions )) {

        return DhcpRespondToDiscover(
            RequestContext,
            AdditionalContext,
            DhcpOptions,
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            0,              // desiredIpAddress
            0,              // leaseDuration
            0,              // T1
            0               // T2
            );
    }

    if( NULL != AdditionalContext && 0 != AdditionalContext->PingAddress ) {
        return HandlePingCallback(
            RequestContext,
            AdditionalContext,
            DhcpOptions,
            AdditionalContext,
            AdditionalStatus,
            OptionHardwareAddress,
            OptionHardwareAddressLength
        );
    }

    LOCK_INPROGRESS_LIST();
    Error = DhcpFindPendingCtxt(
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        0,
        &PendingContext                                // find the pending context if one exists for above hw address
    );
    if( NULL != PendingContext ) {                     // if we found a matching pending context

        // Is this a MADCAP PC?
        if ( CLASSD_HOST_ADDR( PendingContext->Address )) {
            UNLOCK_INPROGRESS_LIST();
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }

        if( PendingContext->Processing ) {             // if a ping is pending on this context
            UNLOCK_INPROGRESS_LIST();
            if ( NULL != AdditionalContext ) {
                CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_DUPLICATE);
            }
            return ERROR_IO_PENDING;                   // return SOME error -- note that *AdditionalStatus is not set..
        }

        desiredIpAddress = PendingContext->Address;

        UNLOCK_INPROGRESS_LIST();

        Error = DhcpGetSubnetForAddress(               // get the subnet for this request
            desiredIpAddress,
            RequestContext
        );

	GetLeaseInfo(desiredIpAddress, RequestContext,
		     &leaseDuration, &T1, &T2, NULL);

        if( ERROR_SUCCESS == Error ) {

            if( DhcpSubnetIsAddressOutOfRange(
                RequestContext->Subnet, desiredIpAddress, fBootp
                ) ) {
                return ERROR_DHCP_INVALID_DHCP_CLIENT;
            }

            Error = DhcpRespondToDiscover(
                RequestContext,
                AdditionalContext,
                DhcpOptions,
                OptionHardwareAddress,
                OptionHardwareAddressLength,
                desiredIpAddress,
                leaseDuration,
                T1,
                T2
            );
        }
        return Error;
    }

    desiredIpAddress = 0;

    Error = DhcpLookupReservationByHardwareAddress(    // first check if this is a reservation
        ClientSubnetAddress,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        RequestContext
    );

    if( ERROR_SUCCESS == Error ) {                     // found the reservation
        UNLOCK_INPROGRESS_LIST();
        DhcpReservationGetAddressAndType(
            RequestContext->Reservation,
            &desiredIpAddress,
            &bAllowedClientType
        );
        if( FALSE == fBootp ) {
            if( !(bAllowedClientType & CLIENT_TYPE_DHCP ) )
                return ERROR_DHCP_INVALID_DHCP_CLIENT;
        } else {
            if( !(bAllowedClientType & CLIENT_TYPE_BOOTP ) )
                return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }

        //
        // For Reservations, we allow things to go through even if the
        // address pool allows only DHCP or only BOOTP etc so long as it
        // is NOT disabled..
        //

        if( DhcpIsSubnetStateDisabled(RequestContext->Subnet->State) ) {
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }

        return DhcpProcessDiscoverForValidatedAddress(
            desiredIpAddress,
            RequestContext,
            AdditionalContext,
            DhcpOptions,
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            FALSE                                      // dont really need to keep in pending list for this case
        );
    }

    if ( ERROR_FILE_NOT_FOUND != Error ) {
        UNLOCK_INPROGRESS_LIST();
        return Error;
    }

    DhcpAssert(ERROR_FILE_NOT_FOUND == Error);         // dont expect any other kind of errors

    // Nothing for this client on the pending list, and no reservations either

    Error = DhcpGetSubnetForAddress(                   // find which subnet this client belongs to
        ClientSubnetAddress,
        RequestContext
    );
    if( ERROR_SUCCESS != Error ) {
        UNLOCK_INPROGRESS_LIST();
        return ERROR_DHCP_INVALID_DHCP_CLIENT;         // uknown subnet
    }

    LOCK_DATABASE();
    Error = DhcpLookupDatabaseByHardwareAddress(       // see if this client has any address in the database
        RequestContext,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        &desiredIpAddress                              // and this is the desired address
    );
    UNLOCK_DATABASE();

    if( ERROR_SUCCESS == Error ) {
        if( DhcpSubnetIsDisabled(RequestContext->Subnet, fBootp ) ) {
            Error = DhcpRemoveClientEntry(desiredIpAddress, NULL, 0, TRUE, FALSE);
            DhcpAssert(ERROR_SUCCESS == Error);        // should be able to get rid of old request of this client..
            Error = ERROR_FILE_NOT_FOUND;              // finding in disabled subnet -- as good as not finding..
        } else {
            Error = DhcpProcessDiscoverForValidatedAddress(
                desiredIpAddress,
                RequestContext,
                AdditionalContext,
                DhcpOptions,
                OptionHardwareAddress,
                OptionHardwareAddressLength,
                TRUE                                   // yes, add this to pending list
            );
            if( ERROR_DHCP_INVALID_DHCP_CLIENT != Error ) {
                UNLOCK_INPROGRESS_LIST();
                return Error;
            }
            //
            // OOPS! We have a record for the client in the DB
            // But it isn't acceptable for some reason (excluded, out of range?)
            //
            Error = DhcpRemoveClientEntry(desiredIpAddress, NULL, 0, TRUE, FALSE);
            DhcpAssert(ERROR_SUCCESS == Error);
            Error = ERROR_FILE_NOT_FOUND;
        }
    } // if

    if ( ERROR_FILE_NOT_FOUND != Error ) {
        UNLOCK_INPROGRESS_LIST();
        return Error;
    }

    DhcpAssert(ERROR_FILE_NOT_FOUND == Error);         // this better be the only reason for failure

    Error = DhcpDiscoverValidateRequestedAddress(
        RequestContext,
        DhcpOptions->RequestedAddress,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        fBootp,
        &desiredIpAddress                              // this is the ip address to offer
    );
    if( ERROR_SUCCESS != Error ) {
        if( ERROR_IO_PENDING != Error ) {              // could be an indication that a ping may need to be scheduled
            UNLOCK_INPROGRESS_LIST();
            DhcpAssert(FALSE);                         // should not happen really
            return Error;
        }
        if( DhcpGlobalDetectConflictRetries ) {        // ok need to schedule a ping
            Error = DhcpAddPendingCtxt(
                OptionHardwareAddress,
                OptionHardwareAddressLength,
                desiredIpAddress,
                0,
                0,
                0,
                0,
                DhcpCalculateTime( DHCP_CLIENT_REQUESTS_EXPIRE ),
                TRUE                                   // yes, ping is scheduled on this
            );
            if( ERROR_SUCCESS == Error ) {
                AdditionalContext->PingAddress = desiredIpAddress;
                AdditionalContext->DestReachable = FALSE;
                *AdditionalStatus = ERROR_IO_PENDING;
            }
            UNLOCK_INPROGRESS_LIST();
            return Error;
        }
    }

    DhcpSubnetGetSubnetAddressAndMask(
        RequestContext->Subnet,
        &ClientSubnetAddress,
        &desiredSubnetMask
        );

    if( desiredIpAddress != ClientSubnetAddress ) {    // gotcha! got an address to send ..
        Error = DhcpProcessDiscoverForValidatedAddress(
            desiredIpAddress,
            RequestContext,
            AdditionalContext,
            DhcpOptions,
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            TRUE
        );
        if( ERROR_DHCP_INVALID_DHCP_CLIENT != Error ) {
            UNLOCK_INPROGRESS_LIST();
            return Error;
        }
    }

    desiredIpAddress = ClientSubnetAddress;
    Error = DhcpRequestSomeAddress(                    // try to get some address..
        RequestContext,
        &desiredIpAddress,
        fBootp
    );
    if( Error == ERROR_DHCP_RANGE_FULL ) {             // failed because of lack of addresses
        DhcpGlobalScavengeIpAddress = TRUE;            // flag scanvenger to scavenge ip addresses
    }

    if( ERROR_SUCCESS == Error ) {
        if( DhcpGlobalDetectConflictRetries ) {        // cause a ping to be scheduled
            Error = DhcpAddPendingCtxt(
                OptionHardwareAddress,
                OptionHardwareAddressLength,
                desiredIpAddress,
                0,
                0,
                0,
                0,
                DhcpCalculateTime( DHCP_CLIENT_REQUESTS_EXPIRE ),
                TRUE                                   // yes, ping is scheduled on this
            );
            if( ERROR_SUCCESS == Error ) {
                AdditionalContext->PingAddress = desiredIpAddress;
                AdditionalContext->DestReachable = FALSE;
                *AdditionalStatus = ERROR_IO_PENDING;
            }
        } else {
            Error = DhcpProcessDiscoverForValidatedAddress(
                desiredIpAddress,
                RequestContext,
                AdditionalContext,
                DhcpOptions,
                OptionHardwareAddress,
                OptionHardwareAddressLength,
                TRUE
            );
        }
    }
    UNLOCK_INPROGRESS_LIST();
    return Error;
}

DWORD
DhcpDetermineClientRequestedAddress(                   // find which address is requested by the client
    IN      DHCP_MESSAGE          *pRequestMessage,    // input message
    IN      DHCP_SERVER_OPTIONS   *pOptions,           // parsed options
    IN      DHCP_REQUEST_CONTEXT  *pContext,           // the client context
    OUT     DHCP_IP_ADDRESS       *pIPAddress          // fill this in with the ip address requested by the client
)
{
    if( pRequestMessage->ClientIpAddress != 0 ) {      // if the "ciaddr" field has been filled in, use it
        // the client must be either in the RENEWING or REBINDING state.
       *pIPAddress = ntohl( pRequestMessage->ClientIpAddress );
    } else if ( pOptions->RequestedAddress != NULL ) { // try the option 50 "Requested Ip address"
        // the client's IP address was specified via option 50,
        // 'requested IP address'.  the client must be in SELECTING or INIT_REBOOT STATE
       *pIPAddress  = ntohl( *pOptions->RequestedAddress );
    } else {
        // the client did not request an IP address.  According to section 4.3.2
        // of the DHCP draft, the client must specify the requested IP address
        // in either 'ciaddr' or option 50, depending on the client's state:
        //
        // State        'ciaddr'            Option 50
        //
        // SELECTING    must not specify    must specify
        // INIT-REBOOT  must not specify    must specify
        // RENEWING     must specify        must not specify
        // REBINDING    must specify        must not specify
        //
        // if the client didn't request an address, this points to a bug in the
        // clients DHCP implementation.  If we simply ignore the problem, the client
        // will never receive an address.  So, we send a Nack which will cause the
        // client to return to the INIT state and send a DHCPDISCOVER.
        // set IpAddress to 0 so a garbage address won't appear in the log.
       *pIPAddress = 0;
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    return ERROR_SUCCESS;
}

DWORD
DhcpValidIpAddressRequested (
    IN      DHCP_MESSAGE          *pRequestMessage,
    IN      DHCP_SERVER_OPTIONS   *pOptions,
    IN      DHCP_REQUEST_CONTEXT  *pContext,
    IN      DHCP_IP_ADDRESS        IPAddress
)
{
    DHCP_IP_ADDRESS                LocalAddress;

    if( ! pRequestMessage->RelayAgentIpAddress) {      // either this is unicast or not across a relay
        LocalAddress = ntohl( pContext->EndPointIpAddress);
        if( !pOptions->Server && pRequestMessage->ClientIpAddress )
            return ERROR_SUCCESS;                      // Client in RENEW state according to the draft
    } else {                                           // client is across a relay.
        LocalAddress  = ntohl( pRequestMessage->RelayAgentIpAddress );
    }

    // At this point: LocalAddress is either the relay agent's or local interface's address
    // And IpAddress is the ip address requested by the client

    if ( !DhcpInSameSuperScope( IPAddress, LocalAddress ))
        return ERROR_DHCP_INVALID_DHCP_CLIENT;         // nope they are not in the same superscope, NACK

    return ERROR_SUCCESS;                              // more validation in ProcessDhcpRequest
}

DWORD
DhcpRetractOffer(                                      // remove pending list and database entries
    IN      PDHCP_REQUEST_CONTEXT  RequestContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    IN      LPBYTE                 HardwareAddress,
    IN      DWORD                  HardwareAddressLength
)
{
    DWORD                          Error;
    DHCP_IP_ADDRESS                desiredIpAddress;
    LPDHCP_PENDING_CTXT            PendingCtxt;

    DhcpPrint((DEBUG_STOC, "Retracting offer (clnt accepted from %s)\n",
               DhcpIpAddressToDottedString(DhcpOptions->Server?*(DhcpOptions->Server):-1)));

    LOCK_INPROGRESS_LIST();
    Error = DhcpFindPendingCtxt(                       // try to see if we have this pending
        HardwareAddress,
        HardwareAddressLength,
        0,
        &PendingCtxt
    );
    if (( ERROR_SUCCESS == Error ) && 
        ( !PendingCtxt->Processing ) &&
        ( !CLASSD_HOST_ADDR( PendingCtxt->Address ))) {
        desiredIpAddress = PendingCtxt->Address;
        Error = DhcpRemovePendingCtxt(PendingCtxt);
        DhcpAssert(ERROR_SUCCESS == Error);
        Error = DhcpDeletePendingCtxt(PendingCtxt);
        DhcpAssert(ERROR_SUCCESS == Error);
    }
    UNLOCK_INPROGRESS_LIST();

    return ERROR_DHCP_INVALID_DHCP_CLIENT;
} // DhcpRetractOffer()

DWORD  _inline
DhcpDetermineRequestedAddressInfo(
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    IN      LPDHCP_MESSAGE         dhcpReceiveMessage,
    IN      BOOL                   fDirectedAtUs,
    OUT     DHCP_IP_ADDRESS       *RequestedIpAddress,
    OUT     BOOL                  *fSendNack
)
/*++

Routine Description:

    This function looks at the packet and determines the Requested Address
    for this client and validates that it is OK for the client to request this
    Address -- by verifying the client's subnet address matches the requested
    address (same superscope).

    The client's subnet address is the relay-agent's address if present or the
    interface's address through which this client's packet was received.

    0.  If SIADDR is some other server, just retrieve ip address..
        and return ERROR_SUCCESS.

    1.  If there is no CIADDR or RequestedAddrOption, we NACK if SIADDR is
        not set to any valid IP address or set to this server's IP address.

    2.  If the packet comes through a Relay Agent (giaddr set) and the
        RelayAgent is not in any configured scope:
           If the SIADDR was set to OUR IpAddress we NACK it else we DROP it.

    3.  If the requested subnet doesn't exist, but we the interface we received
        the message was not configured either, we DONT send a NACK unless the
        message had SIADDR set to our IP address.

    4.  If the requested Subnet doesn't exist (with interface configured),
        we NACK it if SIADDR is set to our IP address or if SIADDR is not valid.

    5.  If client is SELECTING or INIT-REBOOTING (CIADDR = 0), and if the
        interface on which we received it has an IP address for which no
        scope is configured, we NACK it (if SIADDR is invalid or points to us,
        otherwise, we DROP it).
        This check should also be done for REBIND but there is no way to tell
        a REBIND from a RENEW in case of no relay agent, so we don't do that.

Arguments:

    RequestContext                 context for incoming request -- in case of success
                                   the correct subnet will be configured here..

    DhcpOptions                    the parsed options received from the client

    dhcpReceoveMessage             the incoming message

    fDirectedAtUs                  FALSE ==> pointedly directed at some other server
                                   TRUE ==> SIADDR = self or invalid SIADDR

    RequestedIpAddress             This is the IP address that the client wants to use

    fSendNack                      Should we send a NACK?

Returns:

    Returns either ERROR_SUCCESS or ERROR_DHCP_INVALID_DHCP_CLIENT or
                   ERROR_DHCP_UNSUPPORTED_CLIENT.

    Note that ERROR_SUCCESS could be returned directly if fDirectedAtus is false.

    In any case, fSendNack is set to TRUE if a Nack needs to be sent.
    If the return value is not success, the packet has to be dropped.

--*/
{
    ULONG                          Error;
    DHCP_IP_ADDRESS                ClientAddress, ClientSubnetAddress, ClientMask;
    DHCP_IP_ADDRESS                InterfaceSubnetAddress, InterfaceMask;
    BOOL                           fRenewOrRebind;
    BOOL                           fBootp;

    fBootp = (NULL == DhcpOptions->MessageType );

    //
    // Generally, don't send a NACK if the packet wasn't directed at us..
    //

    *fSendNack = fDirectedAtUs;
    fRenewOrRebind = FALSE;
    *RequestedIpAddress = 0;

    //
    // Determine client's IP address from ci-addr first then requested address..
    // According to RFC2131, CIADDR must be specified only in RENEW or REBIND
    //

    if( 0 != dhcpReceiveMessage->ClientIpAddress ) {

        ClientAddress = ntohl( dhcpReceiveMessage->ClientIpAddress );
        fRenewOrRebind = TRUE;

    } else if( NULL != DhcpOptions->RequestedAddress ) {

        ClientAddress = ntohl( *DhcpOptions->RequestedAddress );

    } else {

        DhcpPrint((DEBUG_ERRORS, "Invalid client -- no CIADDR or Requested Address option\n"));
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    *RequestedIpAddress = ClientAddress;

    DhcpPrint((DEBUG_STOC, "REQUEST for address %s\n", inet_ntoa(*(struct in_addr *)&ClientAddress)));

    if( !fDirectedAtUs ) {
        Error = DhcpGetSubnetForAddress(
            ClientAddress,
            RequestContext
        );

        DhcpPrint((DEBUG_STOC, "Ignoring SELECTING request for another server: %ld\n", Error));
        return Error;
    }

    //
    // Verify relay agent sanity. If it is an unknown relay agent, drop the packet
    // unless the message was directed explicity at us.
    //

    if( 0 != dhcpReceiveMessage->RelayAgentIpAddress ) {

        InterfaceSubnetAddress = ntohl(dhcpReceiveMessage->RelayAgentIpAddress);
        InterfaceMask = DhcpGetSubnetMaskForAddress( InterfaceSubnetAddress );

        DhcpPrint((DEBUG_STOC, "REQUEST from relay agent: %s\n",
                   inet_ntoa(*(struct in_addr *)&InterfaceSubnetAddress )));

        if( 0 == InterfaceMask ) {

            if( DhcpOptions->Server &&
                *DhcpOptions->Server == RequestContext->EndPointIpAddress ) {

                DhcpPrint((DEBUG_ERRORS, "Directed request from unsupported GIADDR\n"));
                return ERROR_DHCP_INVALID_DHCP_CLIENT;
            }

            DhcpPrint((DEBUG_ERRORS, "Undirected request from unsupported GIADDR ignored\n"));
            *fSendNack = FALSE;
            return ERROR_DHCP_UNSUPPORTED_CLIENT;
        }
    } else {

        InterfaceSubnetAddress = ntohl(RequestContext->EndPointIpAddress);
        // We Don't have interface mask yet.  We do that later on.

        InterfaceMask = 0;
    }

    //
    // retrieve subnet of client's requested address -- if we don't have one or scope
    // is disabled, got to NACK it..
    //

    Error = DhcpGetSubnetForAddress(
        ClientAddress,
        RequestContext
    );

    if( ERROR_SUCCESS != Error ) {
        //
        //  We don't know about the requested address.  Do we know about the interface
        //  it came on? If we don't know about the interface then we DONT NACK it.
        //

        if( 0 == InterfaceMask ) {
            InterfaceMask = DhcpGetSubnetMaskForAddress( InterfaceSubnetAddress );
        }

        if( 0 == InterfaceMask ) {
            if( DhcpOptions->Server &&
                *DhcpOptions->Server == RequestContext->EndPointIpAddress ) {

                DhcpPrint((DEBUG_ERRORS, "Directed request from unsupported INTERFACE\n"));
                return ERROR_DHCP_INVALID_DHCP_CLIENT;
            }

            DhcpPrint((DEBUG_ERRORS, "Undirected request from unsupported INTERFACE ignored\n"));
            *fSendNack = FALSE;
            return ERROR_DHCP_UNSUPPORTED_CLIENT;
        }

        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    if( ERROR_SUCCESS != Error || DhcpSubnetIsDisabled( RequestContext->Subnet, fBootp ) ) {

        if( ERROR_SUCCESS == Error ) {
            DhcpPrint((DEBUG_ERRORS, "REQUEST on a disabled subnet, ignored\n"));
            *fSendNack = FALSE;
            return ERROR_SUCCESS;
        } else {
            DhcpPrint((DEBUG_ERRORS, "INVALID requested address\n"));
        }

        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    //
    // We need to do more checks for REBIND, but since we can't detect a REBIND
    // from the RENEW, we leave it at that and go ahead...  Note that if we do have a
    // relay agent IP address, then it can't be RENEW as RENEW has to be a UNICAST.
    // So, we figure that out and proceed with the checks in case of REBIND from across
    // a relay agent.
    //

    if( fRenewOrRebind && 0 == dhcpReceiveMessage->RelayAgentIpAddress ) {
        DhcpPrint((DEBUG_STOC, "Possibly RENEW (REBIND) request -- allowed\n"));
        *fSendNack = FALSE;
        return ERROR_SUCCESS;
    }

    //
    // More checks for SELECTING or INIT_REBOOTING or REBIND-from-across-relay state..
    //

    if( 0 == dhcpReceiveMessage->RelayAgentIpAddress ) {
        InterfaceMask = DhcpGetSubnetMaskForAddress( InterfaceSubnetAddress );
        if( 0 == InterfaceMask ) {
            DhcpPrint((DEBUG_ERRORS, "REQUEST came over wrong interface!\n"));

            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }

        InterfaceSubnetAddress &= InterfaceMask;
    }

    DhcpAssert( InterfaceMask );
    DhcpAssert( InterfaceSubnetAddress );

    DhcpPrint((DEBUG_STOC, "Interface subnet = %s\n", inet_ntoa(*(struct in_addr*)&InterfaceSubnetAddress)));

    if( !DhcpSubnetInSameSuperScope( RequestContext->Subnet, InterfaceSubnetAddress) ) {

        DhcpPrint((DEBUG_ERRORS, "Superscope check failed \n"));
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    *fSendNack = FALSE;
    return ERROR_SUCCESS;
}

DWORD
ProcessDhcpRequest(                                    // process a client REQUEST packet..
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,     // current client request structure
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,       // parsed options from the message
    OUT     LPPACKET               AdditionalContext, // used to store info in case or asynchronous ping
    OUT     LPDWORD                AdditionalStatus   // used to return status in case of asynchronous ping
)
{
    DWORD                          Error, Error2;
    DWORD                          LeaseDuration;
    DWORD                          T1, T2;
    DWORD                          dwcb;

    BOOL                           fDirectedAtUs;
    BOOL                           fSwitchedSubnet;
    BOOL                           fJustCreatedEntry = FALSE;
    BOOL                           existingClient;
    BOOL                           fSendNack;

    BYTE                          *HardwareAddress = NULL;
    BYTE                          *OptionHardwareAddress;
    DWORD                          HardwareAddressLength = 0;
    DWORD                          OptionHardwareAddressLength;

    BOOL                           fValidated, fReserved, fReconciled;
    DWORD                          StateFlags = 0;
    BYTE                           bAddressState;
    BYTE                          *OptionEnd;
    OPTION                        *Option;

    WCHAR                          LocalBufferForMachineNameUnicodeString[OPTION_END+2];
    LPWSTR                         NewMachineName = NULL;

    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_MESSAGE                 dhcpSendMessage;

    LPDHCP_PENDING_CTXT            PendingCtxt;

    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                networkOrderIpAddress;
    DHCP_IP_ADDRESS                NetworkOrderSubnetMask;
    DHCP_IP_ADDRESS                ClientSubnetMask = 0;
    DHCP_IP_ADDRESS                IpAddress;
    DHCP_IP_ADDRESS                realIpAddress;

    DhcpPrint(( DEBUG_STOC, "Processing DHCPREQUEST.\n" ));

    dhcpReceiveMessage  = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;
    dhcpSendMessage     = (LPDHCP_MESSAGE)RequestContext->SendBuffer;

    InterlockedIncrement(&DhcpGlobalNumRequests);

    if( AdditionalStatus ) {
        *AdditionalStatus   = ERROR_SUCCESS;
    }

    //
    //  Figure out some basic stuff -- is the packet looking good ? right interface etc..
    //

    if( DhcpOptions->Server && *DhcpOptions->Server != RequestContext->EndPointIpAddress ) {
        fDirectedAtUs = FALSE;                         // this is not sent to us specifically
    } else {
        fDirectedAtUs = TRUE;                          // this IS intended for this  server
    }

    OptionHardwareAddress = NULL; OptionHardwareAddressLength = 0;
    if( DhcpOptions->ClientHardwareAddress ) {
        OptionHardwareAddress = DhcpOptions->ClientHardwareAddress;
        OptionHardwareAddressLength = DhcpOptions->ClientHardwareAddressLength;
    } else {
        OptionHardwareAddress = dhcpReceiveMessage->HardwareAddress;
        OptionHardwareAddressLength = dhcpReceiveMessage->HardwareAddressLength;
    }

    //
    //  if binl is running and this client already has an IP address and
    //  the client specified PXECLIENT as an option, then we just pass this
    //  discover on to BINL
    //

    if (CheckForBinlOnlyRequest( RequestContext, DhcpOptions )) {

        Option = FormatDhcpAck(
            RequestContext,
            dhcpReceiveMessage,
            dhcpSendMessage,
            0,                  // ip address
            0,                  // lease duration
            0,                  // T1
            0,                  // T2
            RequestContext->EndPointIpAddress
        );

        OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

        fSwitchedSubnet = DhcpSubnetIsSwitched(RequestContext->Subnet);

        if ( fSwitchedSubnet ) {
            IpAddress = ((struct sockaddr_in *)(&RequestContext->SourceName))->sin_addr.s_addr ;
            DhcpAssert(0 != IpAddress );
            networkOrderIpAddress = htonl( IpAddress );
            Option = DhcpAppendOption(
                Option,
                OPTION_ROUTER_ADDRESS,
                &networkOrderIpAddress,
                sizeof( networkOrderIpAddress ),
                OptionEnd
            );
        }

        //  If requested & appropriate inform client of BINL service
        Option = BinlProcessRequest(RequestContext, DhcpOptions, Option, OptionEnd );

        if ( DhcpOptions->ParameterRequestList != NULL ) { // add any client requested parameters
            Option = AppendClientRequestedParameters(
                IpAddress,
                RequestContext,
                DhcpOptions->ParameterRequestList,
                DhcpOptions->ParameterRequestListLength,
                Option,
                OptionEnd,
                fSwitchedSubnet,
                TRUE
            );
        }

        Option = DhcpAppendOption(
            Option,
            OPTION_END,
            NULL,
            0,
            OptionEnd
        );

        RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

        DhcpPrint(( DEBUG_STOC, "DhcpRequest bypassed, binl only request for (%ws).\n",
                    NewMachineName? NewMachineName : L"<no-name>"
        ));

        return ERROR_SUCCESS;
    }

    fSendNack = FALSE;                                 // do we need to NACK?
    Error = DhcpDetermineRequestedAddressInfo(
        RequestContext,
        DhcpOptions,
        dhcpReceiveMessage,
        fDirectedAtUs,
        &IpAddress,
        &fSendNack
    );

    if( fSendNack ) goto Nack;                         // NACK
    if( ERROR_SUCCESS != Error ) return Error;         // DROP

    if( !fDirectedAtUs ) {
        return DhcpRetractOffer(                       // RETRACT & DROP
            RequestContext,
            DhcpOptions,
            OptionHardwareAddress,
            OptionHardwareAddressLength
        );
    }

    DhcpDetermineHostName(                             // find the client machine name
        RequestContext,
        IpAddress,
        DhcpOptions,
        &NewMachineName,
        LocalBufferForMachineNameUnicodeString,
        sizeof(LocalBufferForMachineNameUnicodeString)/sizeof(WCHAR)
    );

    DhcpAssert(IpAddress && RequestContext->Subnet);   // got to have these by now..

    DhcpSubnetGetSubnetAddressAndMask(
        RequestContext->Subnet,
        &ClientSubnetAddress,
        &ClientSubnetMask
    );

    DhcpAssert( ClientSubnetMask );
    DhcpAssert( ClientSubnetAddress );

    Error = DhcpMakeClientUID(
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        dhcpReceiveMessage->HardwareAddressType,
        ClientSubnetAddress,
        &HardwareAddress,
        &HardwareAddressLength
        );
    if( ERROR_SUCCESS != Error ) return Error;     // should not really happen

    //
    // Check if this is a reservation etc.
    //

    fValidated = DhcpValidateClient(
        IpAddress, HardwareAddress, HardwareAddressLength
        );
    if( fValidated ) {
        fReserved = DhcpServerIsAddressReserved(DhcpGetCurrentServer(), IpAddress);
    } else {
        fReserved = FALSE;
    }

    //
    // This is a renewal request.  Verify if it is correctly in range etc..
    //
    if( DhcpIsSubnetStateDisabled(RequestContext->Subnet->State) ||
        DhcpSubnetIsAddressOutOfRange(
            RequestContext->Subnet, IpAddress, FALSE
            ) ||
        DhcpSubnetIsAddressExcluded(RequestContext->Subnet, IpAddress) ) {

        Error = ERROR_DHCP_INVALID_DHCP_CLIENT ;
        DhcpPrint((DEBUG_STOC, "ProcessDhcpRequest: OutOfRange/Excluded ipaddress\n"));

        if( fReserved
            && !DhcpIsSubnetStateDisabled(RequestContext->Subnet->State) ) {
            //
            // For reserved clients, if subnet is not disabled,
            // we send ACK even if the client is out of range  etc.
            //
            DhcpPrint((DEBUG_STOC, "Allowing reserved out of range client.\n"));
            Error = ERROR_SUCCESS;
        } else if( DhcpOptions->Server || fValidated ) {
            //
            // Either client is in SELECTING state -- in which case we have to
            // NACK.
            // Or, we have this client's record -- Delete the record as well as
            // send him a NACK.  Next time through, we would just ignore this...
            //

            DhcpRemoveClientEntry(
                IpAddress, HardwareAddress, HardwareAddressLength,
                TRUE, FALSE /* release address from bitmap, delete all records.. */
                );

            goto Nack;
        } else {
            //
            // Client wasn't validated.. it wasn't in selecting state either.
            // So, we just ignore this out of range request..
            //

            DhcpPrint((DEBUG_STOC, "Unknown client, out of range IP, ignored.\n"));
            if( HardwareAddress ) DhcpFreeMemory( HardwareAddress );
            HardwareAddress = NULL;
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
    }

    //
    // At this point, the IP address is in a valid range that we serve. Also,
    // the request is not directed at some other server -- so if anything is invalid
    // we can safely NACK
    //

    GetLeaseInfo(
        IpAddress,
        RequestContext,
        &LeaseDuration,
        &T1,
        &T2,
        DhcpOptions->RequestLeaseTime
    );

    LOCK_INPROGRESS_LIST();
    Error = DhcpFindPendingCtxt(
        NULL,
        0,
        IpAddress,
        &PendingCtxt
    );
    DhcpPrint(( DEBUG_STOC,
		"Finding pending context for %#x, returned %x\n",
		IpAddress, Error ));
    
    if( ERROR_SUCCESS == Error ) {                     // there is some pending ctxt with this address
	DhcpPrint(( DEBUG_STOC,
		    "ProcessDhcpRequest(): DhcpFindPendingCtxt() for %#x asking for %#x is successful\n",
		    PendingCtxt->Address, IpAddress ));
        if( OptionHardwareAddressLength != PendingCtxt->nBytes ||
            0 != memcmp(OptionHardwareAddress, PendingCtxt->RawHwAddr, PendingCtxt->nBytes) ) {
            UNLOCK_INPROGRESS_LIST();
            Error = ERROR_DHCP_INVALID_DHCP_CLIENT;    // some one else is expected to take up this address
            goto Nack;
        }
        if( PendingCtxt->Processing ) {                // async ping is in progres.. drop its
            UNLOCK_INPROGRESS_LIST();
            return ERROR_DHCP_INVALID_DHCP_CLIENT;     // dont NACK.. just ignore it
        }
	PendingCtxt->Processing = TRUE;
    }  // if found pending context
    else {                                           // if not pending, need to request the particular address and "block" it
        //
        // Need to check if the same client obtained a different
        // hardware address..
        //
	DhcpPrint(( DEBUG_STOC, "ProcessDhcpRequest(): Failed to find pending context\n" ));
        Error = DhcpFindPendingCtxt(
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            0,
            &PendingCtxt
            );
        if( ERROR_SUCCESS == Error
            && PendingCtxt->Address != IpAddress ) {
            //
            // Hmm.. we offered client diff address, now he's
            // asking for diff..
            //
            UNLOCK_INPROGRESS_LIST();
            DhcpPrint((DEBUG_STOC, "Client w/ ip address 0x%lx"
                       " asking for 0x%lx\n", PendingCtxt->Address,
                       IpAddress
                ));
            goto Nack;
        }

        LOCK_DATABASE();
        Error = DhcpLookupDatabaseByHardwareAddress(
           RequestContext,
           OptionHardwareAddress,
           OptionHardwareAddressLength,
           &realIpAddress
        );
        UNLOCK_DATABASE();
        if( ERROR_SUCCESS == Error) {
            if( IpAddress != realIpAddress ) {
                UNLOCK_INPROGRESS_LIST();
                DhcpPrint((DEBUG_STOC, "found by hwaddr : Client with ip address 0x%lx asking 0x%lx\n", realIpAddress, IpAddress));
                Error = ERROR_DHCP_INVALID_DHCP_CLIENT;
                goto Nack;
            }
        }

        Error = DhcpRequestSpecificAddress(RequestContext, IpAddress);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_STOC, "Requested specific new address 0x%lx (failed %ld [0x%lx])\n", IpAddress, Error,Error));
            // DhcpAssert(FALSE);                      // this can happen if this address is given to someone else
        }
    } // else pending context not found

    UNLOCK_INPROGRESS_LIST();

    PrintHWAddress( HardwareAddress, (BYTE)HardwareAddressLength );

    fReconciled = FALSE;
    LOCK_DATABASE();
    if( !DhcpIsClientValid(
        IpAddress, OptionHardwareAddress,
        OptionHardwareAddressLength, &fReconciled) ) { 
        // nope, this record is definitiely taken by some OTHER client
        UNLOCK_DATABASE();

	// remove the pending context
        // At this point, this pending ctxt is a DHCP pending ctxt,
        // check it any way for MADCAP.
	if (( NULL != PendingCtxt ) &&
            ( !CLASSD_HOST_ADDR( PendingCtxt->Address ))) {
	    LOCK_INPROGRESS_LIST();
	    DhcpPrint(( DEBUG_STOC,
			"ProcessDhcpRequest(): Removing existing pending context\n" ));
	    // remove & free pending context and proceed..
	    Error = DhcpRemovePendingCtxt(PendingCtxt); 
	    DhcpAssert(ERROR_SUCCESS == Error);
	    DhcpFreeMemory(PendingCtxt);
	    PendingCtxt = NULL;
	    UNLOCK_INPROGRESS_LIST();
	} // if 

        Error = ERROR_DHCP_INVALID_DHCP_CLIENT;
        goto Nack;
    }

    // Before we do this, we need to check out and see if this client needs to be
    // register both forward and backward..
    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        &IpAddress,
        sizeof(IpAddress)
    );
    if( ERROR_SUCCESS  == Error ) {
        dwcb = sizeof(BYTE);
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[STATE_INDEX].ColHandle,
            &bAddressState,
            &dwcb
        );
        existingClient = TRUE;
    } else {
        existingClient = FALSE;
    }

    if( ERROR_SUCCESS != Error ) {
        bAddressState = ADDRESS_STATE_OFFERED;
    }

    DhcpDnsDecideOptionsForClient(
        IpAddress,                                     // The ip address to do the calcualations for
        RequestContext,                                // The subnet the client belongs to.
        DhcpOptions,                                   // need to look at the client specified options
        &StateFlags                                    // Additional flags to mark state
    );

    Error = DhcpCreateClientEntry(
        IpAddress,
        HardwareAddress,
        HardwareAddressLength,
        DhcpCalculateTime( LeaseDuration ),
        NewMachineName,
        fReconciled ? L"" : NULL, // if reconciled, clear the comment away
        CLIENT_TYPE_DHCP,
        ntohl(RequestContext->EndPointIpAddress),
        (CHAR)(StateFlags | ADDRESS_STATE_ACTIVE),
        existingClient
    );
    UNLOCK_DATABASE();
    DhcpFreeMemory(HardwareAddress);
    HardwareAddress = NULL; HardwareAddressLength =0;


    // remove the pending context
    if ( NULL != PendingCtxt ) {
	LOCK_INPROGRESS_LIST();
	DhcpPrint(( DEBUG_STOC,
		    "ProcessDhcpRequest(): Removing existing pending context\n" ));
	// remove & free pending context and proceed..
	Error = DhcpRemovePendingCtxt(PendingCtxt); 
	DhcpAssert(ERROR_SUCCESS == Error);
	DhcpFreeMemory(PendingCtxt);
	PendingCtxt = NULL;
	UNLOCK_INPROGRESS_LIST();
    }

    if( Error != ERROR_SUCCESS ) {
        if( !existingClient ) {
            DhcpPrint((DEBUG_STOC, "Releasing attempted address: 0x%lx\n", IpAddress));
            Error2 = DhcpReleaseAddress(IpAddress);
        }
        if ( NULL != NewMachineName ) {
            DhcpFreeMemory( NewMachineName );
        }
        return Error;
    }

    CALLOUT_RENEW_DHCP(AdditionalContext, IpAddress, LeaseDuration, existingClient);
    if( IS_ADDRESS_STATE_ACTIVE(bAddressState) ) {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_RENEW,
            GETSTRING( DHCP_IP_LOG_RENEW_NAME ),
            IpAddress,
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            NewMachineName
        );
    } else {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_ASSIGN,
            GETSTRING( DHCP_IP_LOG_ASSIGN_NAME ),
            IpAddress,
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            NewMachineName
        );
    }

    Option = FormatDhcpAck(
        RequestContext,
        dhcpReceiveMessage,
        dhcpSendMessage,
        htonl(IpAddress),
        htonl(LeaseDuration),
        htonl(T1),
        htonl(T2),
        RequestContext->EndPointIpAddress
    );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    fSwitchedSubnet = DhcpSubnetIsSwitched(RequestContext->Subnet);

    if ( fSwitchedSubnet ) {
        networkOrderIpAddress = htonl( IpAddress );
        Option = DhcpAppendOption(
            Option,
            OPTION_ROUTER_ADDRESS,
            &networkOrderIpAddress,
            sizeof( networkOrderIpAddress ),
            OptionEnd
        );
    }

    NetworkOrderSubnetMask = htonl( ClientSubnetMask );
    Option = DhcpAppendOption(
        Option,
        OPTION_SUBNET_MASK,
        &NetworkOrderSubnetMask,
        sizeof( NetworkOrderSubnetMask ),
        OptionEnd
    );

    //  If requested & appropriate inform client of BINL service
    Option = BinlProcessRequest(RequestContext, DhcpOptions, Option, OptionEnd );

    if( 0 != StateFlags ) {                            // if required, append dyndns related stuff
        Option = DhcpAppendDnsRelatedOptions(
            Option,
            DhcpOptions,
            OptionEnd,
            IS_DOWN_LEVEL(StateFlags)
        );
    }

    if ( DhcpOptions->ParameterRequestList != NULL ) { // add any client requested parameters
        Option = AppendClientRequestedParameters(
            IpAddress,
            RequestContext,
            DhcpOptions->ParameterRequestList,
            DhcpOptions->ParameterRequestListLength,
            Option,
            OptionEnd,
            fSwitchedSubnet,
            FALSE
        );
    }

    Option = ConsiderAppendingOption(
        IpAddress,
        RequestContext,
        Option,
        OPTION_VENDOR_SPEC_INFO,
        OptionEnd,
        fSwitchedSubnet
    );

    Option = DhcpAppendOption(
        Option,
        OPTION_END,
        NULL,
        0,
        OptionEnd
    );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    DhcpPrint(( DEBUG_STOC, "DhcpRequest committed, address %s (%ws).\n",
                DhcpIpAddressToDottedString(IpAddress),
                NewMachineName? NewMachineName : L"<no-name>"
    ));

    if( HardwareAddress ) {
        DhcpFreeMemory(HardwareAddress);
        HardwareAddress = NULL;
    }

    if ( NULL != NewMachineName ) {
        DhcpFreeMemory( NewMachineName );
    }

    return ERROR_SUCCESS;

Nack:
    if( HardwareAddress ) {
        DhcpFreeMemory(HardwareAddress);
        HardwareAddress = NULL;
    }

    DhcpPrint(( DEBUG_STOC, "Invalid DHCPREQUEST for %s Nack'd.\n", DhcpIpAddressToDottedString ( IpAddress ) ));
    CALLOUT_NACK_DHCP(AdditionalContext, IpAddress);

/*------------- ft 06/30
 *  out as per Munil and Karoly suggestions for bug #172529
 *  post Beta 2 might get back in with a filtering on different levels of systemLog.
 *-------------

    DhcpServerEventLogSTOC(
        EVENT_SERVER_LEASE_NACK,
        EVENTLOG_WARNING_TYPE,
        IpAddress,
        OptionHardwareAddress,
        OptionHardwareAddressLength
    );

---------------*/

    DhcpUpdateAuditLog(
        DHCP_IP_LOG_NACK,
        GETSTRING( DHCP_IP_LOG_NACK_NAME ),
        IpAddress,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        NewMachineName
    );

    RequestContext->SendMessageSize =
        FormatDhcpNak(
            dhcpReceiveMessage,
            dhcpSendMessage,
            RequestContext->EndPointIpAddress
        );
    
    RequestContext->fNak = TRUE;

    // Free the memory created for NewMachineName
    if (NewMachineName != NULL) {
	DhcpFreeMemory(NewMachineName);
	NewMachineName = NULL;
    } // 

    return ERROR_SUCCESS;
} // ProcessDhcpRequest()

DWORD
ProcessDhcpInform(
    IN      LPDHCP_REQUEST_CONTEXT RequestContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    IN      LPPACKET               AdditionalContext
)
{
    DWORD                          Error;
    DWORD                          dwcb;
    DWORD                          HardwareAddressLength;
    DWORD                          OptionHardwareAddressLength;
    LPBYTE                         HardwareAddress = NULL;
    LPBYTE                         OptionHardwareAddress;
    BYTE                           bAddressState;
    BOOL                           DatabaseLocked = FALSE;
    BOOL                           fSwitchedSubnet;

    LPBYTE                         OptionEnd;
    OPTION                        *Option;

    WCHAR                          LocalBufferForMachineNameUnicodeString[OPTION_END+2];
    LPWSTR                         NewMachineName = NULL;

    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_MESSAGE                 dhcpSendMessage;

    LPDHCP_PENDING_CTXT            PendingCtxt;

    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                NetworkOrderSubnetMask;
    DHCP_IP_ADDRESS                ClientSubnetMask    = 0;
    DHCP_IP_ADDRESS                IpAddress;

    DhcpDumpMessage(
        DEBUG_MESSAGE,
        (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer,
        DHCP_MESSAGE_SIZE
        );

    InterlockedIncrement(&DhcpGlobalNumInforms);

    DhcpPrint((DEBUG_STOC, "Processing DHCPINFORM\n"));
    dhcpReceiveMessage  = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;
    dhcpSendMessage     = (LPDHCP_MESSAGE)RequestContext->SendBuffer;


    OptionHardwareAddress = NULL; OptionHardwareAddressLength = 0;
    Error = DhcpDetermineInfoFromMessage(
        RequestContext,
        DhcpOptions,
        &OptionHardwareAddress,
        &OptionHardwareAddressLength,
        &ClientSubnetAddress
    );
    DhcpAssert(NULL != OptionHardwareAddress);

    // if( ERROR_SUCCESS != Error ) return Error;      // ignore errors here..

    if( DhcpOptions->DSDomainNameRequested ) {         // if another server is asking for DS domain name..
        Error = DhcpDetermineClientRequestedAddress(   // this may fail but ignore that..
            dhcpReceiveMessage,
            DhcpOptions,
            RequestContext,
            &IpAddress
        );
        ClientSubnetMask = ClientSubnetAddress =0;
    } else {
        Error = DhcpDetermineClientRequestedAddress(
            dhcpReceiveMessage,
            DhcpOptions,
            RequestContext,
            &IpAddress
        );
        if( ERROR_SUCCESS != Error ) return Error;     // unknown subnet

        Error = DhcpGetSubnetForAddress(
            IpAddress,
            RequestContext
        );
        if( ERROR_SUCCESS != Error ) return Error;     // unknown subnet

        DhcpSubnetGetSubnetAddressAndMask(
            RequestContext->Subnet,
            &ClientSubnetAddress,
            &ClientSubnetMask
        );

        DhcpAssert( IpAddress );
    }

    Option = FormatDhcpInformAck(                      // Here come the actual formatting of the ack!
        dhcpReceiveMessage,
        dhcpSendMessage,
        htonl(IpAddress),
        RequestContext->EndPointIpAddress
    );
    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    fSwitchedSubnet = DhcpSubnetIsSwitched(RequestContext->Subnet);

    if ( fSwitchedSubnet ) {
        DHCP_IP_ADDRESS networkOrderIpAddress = htonl( IpAddress );

        Option = DhcpAppendOption(
            Option,
            OPTION_ROUTER_ADDRESS,
            &networkOrderIpAddress,
            sizeof( networkOrderIpAddress ),
            OptionEnd
        );
    }

    NetworkOrderSubnetMask = htonl( ClientSubnetMask );
    Option = DhcpAppendOption(
        Option,
        OPTION_SUBNET_MASK,
        &NetworkOrderSubnetMask,
        sizeof( NetworkOrderSubnetMask ),
        OptionEnd
    );

    if (DhcpOptions->DSDomainNameRequested) {          // if our enterprise name was requested, append it
        PUCHAR  pIp = (PUCHAR)(&IpAddress);

        DhcpPrint((DEBUG_ERRORS,"%d.%d.%d.%d is trying to come up as a DHCP server\n",
            *(pIp+3),*(pIp+2),*(pIp+1),*pIp));

        Option = DhcpAppendEnterpriseName(
            Option,
            DhcpGlobalDSDomainAnsi,
            OptionEnd
        );

        // also, make the server send out a broadcast: if someone is using a bad
        // ipaddr, we should make sure we reach him

        dhcpReceiveMessage->Reserved = htons(DHCP_BROADCAST);
    }

    if ( NULL != RequestContext->Subnet && DhcpOptions->ParameterRequestList != NULL ) {
        Option = AppendClientRequestedParameters(      // finally add anything requested by the client
            IpAddress,
            RequestContext,
            DhcpOptions->ParameterRequestList,
            DhcpOptions->ParameterRequestListLength,
            Option,
            OptionEnd,
            fSwitchedSubnet,
            TRUE
        );
    }

    Option = DhcpAppendOption(
        Option,
        OPTION_END,
        NULL,
        0,
        OptionEnd
    );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    DhcpPrint(( DEBUG_STOC,"DhcpInform Ack'ed, address %s.\n",
                DhcpIpAddressToDottedString(IpAddress)
    ));
    return ERROR_SUCCESS;
}


DWORD
ProcessDhcpDecline(                                    // process a decline packet from the client
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,     // context block for this client
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,        // parsed options
    IN      LPPACKET               AdditionalContext   // additional context information
)
{
    DWORD                          Error;
    DWORD                          LeaseDuration;
    DWORD                          T1, T2, dwcb;
    DHCP_IP_ADDRESS                ipAddress;
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_PENDING_CTXT            PendingCtxt;

    LPBYTE                         HardwareAddress = NULL;
    DWORD                          HardwareAddressLength;

    LPBYTE                         OptionHardwareAddress;
    DWORD                          OptionHardwareAddressLength;

    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                ClientSubnetMask = 0;
    BOOL                           DatabaseLocked = FALSE;

    //
    // If this client validates, then mark this address bad.
    //

    DhcpPrint(( DEBUG_STOC, "DhcpDecline arrived.\n" ));
    InterlockedIncrement(&DhcpGlobalNumDeclines);       // increment decline counter.

    dhcpReceiveMessage = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;

    //
    // If requested options is present, use that.. else if ciaddr is present use that.
    //

    if( DhcpOptions->RequestedAddress ) {
        ipAddress = ntohl( *(DhcpOptions->RequestedAddress));
    } else {
        ipAddress = ntohl( dhcpReceiveMessage->ClientIpAddress );
    }

    if( 0 == ipAddress || ~0 == ipAddress ) {
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    if( 0 == (ClientSubnetMask = DhcpGetSubnetMaskForAddress(ipAddress)) ) {
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    ClientSubnetAddress = ( ipAddress & ClientSubnetMask );

    if( DhcpOptions->ClientHardwareAddress ) {
        OptionHardwareAddress = DhcpOptions->ClientHardwareAddress;
        OptionHardwareAddressLength = DhcpOptions->ClientHardwareAddressLength;
    } else {
        OptionHardwareAddress = dhcpReceiveMessage->HardwareAddress;
        OptionHardwareAddressLength = dhcpReceiveMessage->HardwareAddressLength;
    }

    HardwareAddress = NULL;
    Error = DhcpMakeClientUID(
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        dhcpReceiveMessage->HardwareAddressType,
        ClientSubnetAddress,
        &HardwareAddress,
        &HardwareAddressLength
    );
    if( Error != ERROR_SUCCESS ) return Error;

    DhcpAssert( (HardwareAddress != NULL) && (HardwareAddressLength != 0) );

    PrintHWAddress( HardwareAddress, (BYTE)HardwareAddressLength );

    LOCK_DATABASE();
    DatabaseLocked = TRUE;

    if ( DhcpValidateClient(ipAddress,HardwareAddress,HardwareAddressLength ) ) {
        BYTE                       BadHWAddress[sizeof(DHCP_IP_ADDRESS) + sizeof("BAD")-1];
        DWORD                      BadHWAddressLength;
        DWORD                      BadHWAddressOffset = 0;

        //
        // Create a database entry for this bad IP address.
        // The client ID for this entry is of the following form
        // "ipaddress""BAD"
        //
        // we postfix BAD so DHCP admn can display this entry
        // separately.
        //
        // we prefix ipaddress so that if the same client declines
        // more than one address, we dont run into DuplicateKey problem
        //

        BadHWAddressLength = sizeof(DHCP_IP_ADDRESS) + sizeof("BAD") -1;
        memcpy( BadHWAddress, &ipAddress, sizeof(DHCP_IP_ADDRESS) );
        BadHWAddressOffset = sizeof(DHCP_IP_ADDRESS);
        memcpy( BadHWAddress + BadHWAddressOffset, "BAD", sizeof("BAD")-1);

        CALLOUT_DECLINED(AdditionalContext, ipAddress);
        GetLeaseInfo(
            ipAddress,
            RequestContext,
            &LeaseDuration,
            &T1,
            &T2,
            NULL
        );


        Error = DhcpCreateClientEntry(
            ipAddress,
            BadHWAddress,
            BadHWAddressLength,
            DhcpCalculateTime(LeaseDuration),          //DhcpCalculateTime(INFINIT_LEASE),
            GETSTRING( DHCP_BAD_ADDRESS_NAME ),
            GETSTRING( DHCP_BAD_ADDRESS_INFO ),
            CLIENT_TYPE_DHCP,
            ntohl(RequestContext->EndPointIpAddress),
            ADDRESS_STATE_DECLINED,
            TRUE                                       // Existing
        );

/*------------- ft 07/01
 *  out as per Thiru suggestion for bug #172529
 *  post Beta 2 might get back in with a filtering on different levels of systemLog.
 *-------------
        DhcpServerEventLogSTOC(
            EVENT_SERVER_LEASE_DECLINED,
            EVENTLOG_ERROR_TYPE,
            ipAddress,
            HardwareAddress,
            HardwareAddressLength
        );
---------------*/

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // finally if there is any pending request with this ipaddress,
        // remove it now.
        //

        UNLOCK_DATABASE();
        DatabaseLocked = FALSE;
        LOCK_INPROGRESS_LIST();
        // Searching on IP address is okay.
        Error = DhcpFindPendingCtxt(
            NULL,
            0,
            ipAddress,
            &PendingCtxt
        );
        if( PendingCtxt ) {
            if ( TRUE == PendingCtxt->Processing ) {
                UNLOCK_INPROGRESS_LIST();
                return ERROR_DHCP_INVALID_DHCP_CLIENT;
            }
            DhcpRemovePendingCtxt(PendingCtxt);
            DhcpFreeMemory(PendingCtxt);
        }
        UNLOCK_INPROGRESS_LIST();
    }

    DhcpPrint(( DEBUG_STOC, "DhcpDecline address %s.\n",
                    DhcpIpAddressToDottedString(ipAddress) ));

    Error = ERROR_SUCCESS;

Cleanup:

    if( DatabaseLocked ) {
        UNLOCK_DATABASE();
    }

    if( HardwareAddress != NULL ) {
        DhcpFreeMemory( HardwareAddress );
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_STOC, "DhcpDecline failed, %ld.\n", Error ));
    }

    return( Error );
}

DWORD
ProcessDhcpRelease(                                    // process the DHCP Release packet from a client
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,     // client context
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,        // parsed options
    IN      LPPACKET               AdditionalContext   // additional ctxt info
)
{
    DWORD                          Error;
    DWORD                          Error2;
    DHCP_IP_ADDRESS                ClientIpAddress;
    DHCP_IP_ADDRESS                addressToRemove = 0;
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_PENDING_CTXT            PendingCtxt;

    LPBYTE                         HardwareAddress = NULL;
    DWORD                          HardwareAddressLength;

    LPBYTE                         OptionHardwareAddress;
    DWORD                          OptionHardwareAddressLength;

    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                ClientSubnetMask = 0;
    BOOL                           DatabaseLocked = FALSE;

    WCHAR                         *pwszName;
    DWORD                          dwcb;

    DhcpPrint(( DEBUG_STOC, "DhcpRelease arrived.\n" ));
    InterlockedIncrement(&DhcpGlobalNumReleases);      // increment Release counter.

    dhcpReceiveMessage = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;

    Error = DhcpDetermineInfoFromMessage(
        RequestContext,
        DhcpOptions,
        &OptionHardwareAddress,
        &OptionHardwareAddressLength,
        NULL
    );
    if( ERROR_SUCCESS != Error) return Error;          // invalid subnet of origin

    LOCK_INPROGRESS_LIST();
    Error2 = DhcpFindPendingCtxt(                      // remove any pending offers we have for this guy..
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        0,
        &PendingCtxt
    );
    if( ERROR_SUCCESS == Error2 ) {
        if (( CLASSD_HOST_ADDR( PendingCtxt->Address )) ||
              ( TRUE == PendingCtxt->Processing )) {
            UNLOCK_INPROGRESS_LIST();
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
        // weird scenario, more likely a bug?
        Error2 = DhcpRemovePendingCtxt(
            PendingCtxt
        );
        DhcpAssert( ERROR_SUCCESS == Error2);
    } else PendingCtxt = NULL;

    if( PendingCtxt ) {                                // actually free up the address in bitmap..
        Error2 = DhcpDeletePendingCtxt(
            PendingCtxt
        );
        DhcpAssert(ERROR_SUCCESS == Error);
    }
    UNLOCK_INPROGRESS_LIST();


    //
    // to fix whistler bug 291164.
    // the ClientSubnetAddress could be something other than the relay ip
    // when the request comes from a relay ip. ( superscope case )
    // finding ClientSubnetAddress below for relay and non relay
    // based on ClientIpAddress
    //

    if( 0 != dhcpReceiveMessage->ClientIpAddress ) {
        ClientIpAddress = ntohl(dhcpReceiveMessage->ClientIpAddress);
        ClientSubnetMask = DhcpGetSubnetMaskForAddress( ClientIpAddress );
        if( ClientSubnetMask == 0 ) {                  // unsupported subnet
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
        ClientSubnetAddress = ClientSubnetMask & ClientIpAddress;
    }

    HardwareAddress = NULL;
    Error = DhcpMakeClientUID(
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        dhcpReceiveMessage->HardwareAddressType,
        ClientSubnetAddress,
        &HardwareAddress,
        &HardwareAddressLength
    );

    if( Error != ERROR_SUCCESS ) return Error;

    DhcpAssert( (HardwareAddress != NULL) && (HardwareAddressLength != 0) );

    PrintHWAddress( HardwareAddress, (BYTE)HardwareAddressLength );

    LOCK_DATABASE();
    DatabaseLocked = TRUE;

    if( dhcpReceiveMessage->ClientIpAddress != 0 ) {   // client informed us of his ip address
        ClientIpAddress = ntohl( dhcpReceiveMessage->ClientIpAddress );

        if ( DhcpValidateClient(ClientIpAddress,HardwareAddress,HardwareAddressLength ) ) {
            addressToRemove = ClientIpAddress;         // ok, address matches with what we got in out db
        }
    } else {                                           // look up ip info from db, as client didnt say
        if(!DhcpGetIpAddressFromHwAddress(HardwareAddress,(BYTE)HardwareAddressLength,&addressToRemove)) {
            addressToRemove = 0;
        }
    }

    if( 0 == addressToRemove ) {                       // could not find the required address..
        Error = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }

    // MISSING DhcpJetOpenKey(addressToRemove) --> DhcpValidateClient or DhcpGetIpAddressFromHwAddress

    dwcb = 0;
    Error = DhcpJetGetValue(                           // try to get client's name..
        DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
        &pwszName,
        &dwcb
    );
    if ( ERROR_SUCCESS != Error ) pwszName = NULL;


    DhcpPrint((DEBUG_STOC, "DhcpRelease address, %s.\n",
               DhcpIpAddressToDottedString(addressToRemove) ));

    if ( addressToRemove == 0 ) {
        Error = ERROR_SUCCESS;
    } else {
        Error = DhcpRemoveClientEntry(
            addressToRemove,
            HardwareAddress,
            HardwareAddressLength,
            TRUE,       // release address from bit map.
            FALSE       // delete non-pending record
        );

        // if this reserved client, keep his database entry, he would be using this address again.

        if( Error == ERROR_DHCP_RESERVED_CLIENT ) {
            Error = ERROR_SUCCESS;
        }

        if (Error == ERROR_SUCCESS) {

            CALLOUT_RELEASE(AdditionalContext, addressToRemove);
            //
            // log the activity   -- added by t-cheny
            //

            DhcpUpdateAuditLog(
                DHCP_IP_LOG_RELEASE,
                GETSTRING( DHCP_IP_LOG_RELEASE_NAME ),
                addressToRemove,
                OptionHardwareAddress,
                OptionHardwareAddressLength,
                pwszName
            );

            if( pwszName ) MIDL_user_free( pwszName );
        }
    }

Cleanup:

    if( DatabaseLocked ) {
        UNLOCK_DATABASE();
    }

    if( HardwareAddress != NULL ) {
        DhcpFreeMemory( HardwareAddress );
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_STOC, "DhcpRelease failed, %ld.\n", Error ));
    }

    //
    // Do not send a response.
    //

    return( Error );
}

VOID
SetMicrosoftVendorClassInformation(
    IN OUT LPDHCP_REQUEST_CONTEXT Ctxt,
    IN LPBYTE VendorClass,
    IN ULONG VendorClassLength
    )
/*++

Routine Description:
    This routine sets additional information on whether
    the current client is a MSFT client or not based on
    the vendor class information.

--*/
{
    BOOL fMicrosoftClient = FALSE;

    if( VendorClassLength > DHCP_MSFT_VENDOR_CLASS_PREFIX_SIZE ) {
        ULONG RetVal;

        RetVal = memcmp(
            VendorClass,
            DHCP_MSFT_VENDOR_CLASS_PREFIX,
            DHCP_MSFT_VENDOR_CLASS_PREFIX_SIZE
            );
        if( 0 == RetVal ) fMicrosoftClient = TRUE;
    }

    if( fMicrosoftClient ) {
        DhcpPrint((DEBUG_STOC, "Processing MSFT client\n"));
    } else {
        DhcpPrint((DEBUG_STOC, "Processing non MSFT client\n"));
    }

    Ctxt->fMSFTClient = fMicrosoftClient;
}


//================================================================================
// Must be called with READ_LOCK taken on memory, and ServerObject filled in RequestContext
//================================================================================
DWORD
ProcessMessage(                                        // Dispatch call to correct handler based on message type
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,
    IN OUT  LPPACKET               AdditionalContext,
    IN OUT  LPDWORD                AdditionalStatus
)
{
    DWORD                          Error;
    BOOL                           fSendResponse;
    DHCP_SERVER_OPTIONS            dhcpOptions;
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    BOOLEAN                        fInOurEnterprise=TRUE;

    DhcpPrint(( DEBUG_STOC, "ProcessMessage entered\n" ));

    if ( !DhcpGlobalOkToService ) {
        CALLOUT_DROPPED( AdditionalContext, DHCP_DROP_UNAUTH );
        return ERROR_DHCP_ROGUE_NOT_AUTHORIZED;
    }

    if( SERVICE_PAUSED == DhcpGlobalServiceStatus.dwCurrentState ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_PAUSED);
        return ERROR_DHCP_SERVICE_PAUSED;
    }
    dhcpReceiveMessage = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;
    if( 0 == DhcpServerGetSubnetCount(RequestContext->Server)) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_NO_SUBNETS);
        return ERROR_DHCP_SUBNET_NOT_PRESENT;          // discard as no subnets configured
    }

    RtlZeroMemory( &dhcpOptions, sizeof( dhcpOptions ) );

    if( BOOT_REQUEST != dhcpReceiveMessage->Operation ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_INVALID);
        return ERROR_DHCP_INVALID_DHCP_MESSAGE;        // discard non-bootp packets
    }

    Error = ExtractOptions(
        dhcpReceiveMessage,
        &dhcpOptions,
        RequestContext->ReceiveMessageSize
    );
    if( Error != ERROR_SUCCESS ) {                     // discard malformed packets
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_INVALID);
        return Error;
    }
    CALLOUT_MARK_OPTIONS(AdditionalContext, &dhcpOptions);

    RequestContext->ClassId = DhcpServerGetClassId(
        RequestContext->Server,
        dhcpOptions.ClassIdentifier,
        dhcpOptions.ClassIdentifierLength
    );

    RequestContext->VendorId = DhcpServerGetVendorId(
        RequestContext->Server,
        dhcpOptions.VendorClass,
        dhcpOptions.VendorClassLength
    );

    SetMicrosoftVendorClassInformation(
        RequestContext,
        dhcpOptions.VendorClass,
        dhcpOptions.VendorClassLength
        );

    RequestContext->BinlClassIdentifier = dhcpOptions.VendorClass;
    RequestContext->BinlClassIdentifierLength = dhcpOptions.VendorClassLength;

    fSendResponse = TRUE;
    if ( dhcpOptions.MessageType == NULL ) {           // no msg type ==> BOOTP message
        RequestContext->MessageType = 0;               // no msg type ==> mark it as some invalid type..

        if( FALSE == DhcpGlobalDynamicBOOTPEnabled ) {
            Error = ProcessBootpRequest(
                RequestContext,
                &dhcpOptions,
                AdditionalContext,
                AdditionalStatus
                );
        } else {
            if( RequestContext->ClassId == 0 ) {
                //
                // No class-Id specified for BOOTP clients?
                // Then lets give one to it!
                //
                RequestContext->ClassId = DhcpServerGetClassId(
                    RequestContext->Server,
                    DEFAULT_BOOTP_CLASSID,
                    DEFAULT_BOOTP_CLASSID_LENGTH
                    );
            }

            Error = ProcessDhcpDiscover(
                RequestContext,
                &dhcpOptions,
                AdditionalContext,
                AdditionalStatus
                );
        }

        if( ERROR_SUCCESS == Error && ERROR_SUCCESS != *AdditionalStatus )
            fSendResponse = FALSE;                     //  We have scheduled a ping, Send response later
    } else {
        RequestContext->MessageType = *dhcpOptions.MessageType ;

#if DBG
        if( TRUE == fDhcpGlobalProcessInformsOnlyFlag ) {
            if( DHCP_INFORM_MESSAGE != *dhcpOptions.MessageType ) {
                *dhcpOptions.MessageType = 0;          // some invalid type, will get dropped
            }
        }
#endif

        switch( *dhcpOptions.MessageType ) {           // dispatch based on message type
        case DHCP_DISCOVER_MESSAGE:
            Error = ProcessDhcpDiscover(               // may need to schedule a ping (check AdditionalStatus)
                RequestContext,                        // if so, schedule it, and dont send response now
                &dhcpOptions,                          // note that in all other cases, we still send response,
                AdditionalContext,                     // in particular, even if Error is not ERROR_SUCESS
                AdditionalStatus
            );
            fSendResponse = (ERROR_SUCCESS == *AdditionalStatus);
            break;
        case DHCP_REQUEST_MESSAGE:
            Error = ProcessDhcpRequest(                 // see comments for ProcessDhcpDiscover case above -- same.
                RequestContext,
                &dhcpOptions,
                AdditionalContext,
                AdditionalStatus
            );
            fSendResponse = (ERROR_SUCCESS == *AdditionalStatus);
            break;
        case DHCP_DECLINE_MESSAGE:
            Error = ProcessDhcpDecline(
                RequestContext,
                &dhcpOptions,
                AdditionalContext
            );
            fSendResponse = FALSE;
            break;
        case DHCP_RELEASE_MESSAGE:
            Error = ProcessDhcpRelease(
                RequestContext,
                &dhcpOptions,
                AdditionalContext
            );
            fSendResponse = FALSE;
            break;
        case DHCP_INFORM_MESSAGE:
            Error = ProcessDhcpInform(
                RequestContext,
                &dhcpOptions,
                AdditionalContext
            );
            fSendResponse = TRUE;
            break;
        default:
            DhcpPrint((DEBUG_STOC,"Received a invalid message type, %ld.\n",*dhcpOptions.MessageType ));
            Error = ERROR_DHCP_INVALID_DHCP_MESSAGE;
            break;
        }
    }

    if ( ERROR_SUCCESS == Error && fSendResponse ) {
#ifdef DEBUG
        if ( DhcpGlobalDebugFlag & DEBUG_MESSAGE ) {
            DhcpDumpMessage( DEBUG_MESSAGE,
                             (LPDHCP_MESSAGE)RequestContext->SendBuffer,
                             DHCP_MESSAGE_SIZE );
        }
#endif
        CALLOUT_SENDPKT( AdditionalContext );
        DhcpSendMessage( RequestContext );
    }

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_STOC, "ProcessMessage: returning 0x%lx, [decimal %ld]\n", Error, Error));
    }

    if( ERROR_DHCP_INVALID_DHCP_MESSAGE == Error ||
        ERROR_DHCP_INVALID_DHCP_CLIENT == Error ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_INVALID);
    } else if( ERROR_SUCCESS == Error && ERROR_IO_PENDING == *AdditionalStatus ) {
        CALLOUT_PINGING(AdditionalContext);
    } else if( ERROR_SUCCESS != Error ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_GEN_FAILURE);
    }

    return Error;
}

//================================================================================
// Must be called with READ_LOCK taken on memory, and ServerObject filled in RequestContext
//================================================================================
DWORD
ProcessMadcapMessage(                                        // Dispatch call to correct handler based on message type
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,
    IN OUT  LPPACKET               AdditionalContext,
    IN OUT  LPDWORD                AdditionalStatus
) {
    DWORD                          Error;
    BOOL                           fSendResponse;
    MADCAP_SERVER_OPTIONS            MadcapOptions;
    LPMADCAP_MESSAGE                 dhcpReceiveMessage;
    BOOLEAN                        fInOurEnterprise=TRUE;

    DhcpPrint(( DEBUG_STOC, "ProcessMadcapMessage entered\n" ));

    if( SERVICE_PAUSED == DhcpGlobalServiceStatus.dwCurrentState ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_PAUSED);
        return ERROR_DHCP_SERVICE_PAUSED;
    }
    dhcpReceiveMessage = (PMADCAP_MESSAGE)RequestContext->ReceiveBuffer;
    if( 0 == DhcpServerGetMScopeCount(RequestContext->Server)) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_NO_SUBNETS);
        return ERROR_DHCP_SUBNET_NOT_PRESENT;          // discard as no subnets configured
    }

    RtlZeroMemory( &MadcapOptions, sizeof( MadcapOptions ) );

    if( MADCAP_VERSION < dhcpReceiveMessage->Version ||
        MADCAP_ADDR_FAMILY_V4 != ntohs(dhcpReceiveMessage->AddressFamily)) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_INVALID);
        return ERROR_DHCP_INVALID_DHCP_MESSAGE;
    }

    Error = ExtractMadcapOptions(
        dhcpReceiveMessage,
        &MadcapOptions,
        RequestContext->ReceiveMessageSize
    );
    if( Error != ERROR_SUCCESS ) {                     // discard malformed packets
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_INVALID);
        return Error;
    }

    fSendResponse = FALSE;


    switch( dhcpReceiveMessage->MessageType ) {           // dispatch based on message type
    case MADCAP_DISCOVER_MESSAGE:
    case MADCAP_REQUEST_MESSAGE:
        Error = ProcessMadcapDiscoverAndRequest(
            RequestContext,
            &MadcapOptions,
            dhcpReceiveMessage->MessageType,
            &fSendResponse
        );
        break;
    case MADCAP_RENEW_MESSAGE:
        Error = ProcessMadcapRenew(
            RequestContext,
            &MadcapOptions,
            &fSendResponse
        );
        break;

    case MADCAP_RELEASE_MESSAGE:
        Error = ProcessMadcapRelease(
            RequestContext,
            &MadcapOptions,
            &fSendResponse
        );
        break;
    case MADCAP_INFORM_MESSAGE:
        Error = ProcessMadcapInform(
            RequestContext,
            &MadcapOptions,
            &fSendResponse
        );
        break;
    default:
        DhcpPrint((DEBUG_STOC,"Received a invalid message type, %ld.\n",dhcpReceiveMessage->MessageType ));
        Error = ERROR_DHCP_INVALID_DHCP_MESSAGE;
        break;
    }

    if ( fSendResponse ) {
#ifdef DEBUG
        if ( DhcpGlobalDebugFlag & DEBUG_MESSAGE ) {
            MadcapDumpMessage( DEBUG_MESSAGE,
                               (PMADCAP_MESSAGE)RequestContext->SendBuffer,
                               DHCP_MESSAGE_SIZE );
        }
#endif
        CALLOUT_SENDPKT( AdditionalContext );
        MadcapSendMessage( RequestContext );
    }

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_STOC, "ProcessMadcapMessage: returning 0x%lx, [decimal %ld]\n", Error, Error));
    }

    if( ERROR_DHCP_INVALID_DHCP_MESSAGE == Error ||
        ERROR_DHCP_INVALID_DHCP_CLIENT == Error ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_INVALID);
    } else if( ERROR_SUCCESS != Error ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_GEN_FAILURE);
    }

    return Error;
}

DWORD
DhcpInitializeClientToServer(
    VOID
    )
/*++

Routine Description:

    This function initializes client to server communications.  It
    initializes the DhcpRequestContext block, and then creates and initializes
    a socket for each address the server uses.

    It also initializes the receive buffers and receive buffer queue.

Arguments:

    DhcpRequest - Pointer to a location where the request context pointer
        is returned.

Return Value:

    Error Code.

--*/
{
    DWORD                 Error,
                          LastError,
                          i,
                          cInitializedEndpoints;


    DHCP_REQUEST_CONTEXT    *pRequestContext;

    LPSOCKET_ADDRESS_LIST  interfaceList;


    // initialize locks that the threads take on processing packets
    Error = DhcpReadWriteInit();
    if( ERROR_SUCCESS != Error ) return Error;

    // create an event to indicate endpoint status.
    DhcpGlobalEndpointReadyEvent =
        CreateEvent( NULL, TRUE, FALSE, NULL );

    if( NULL == DhcpGlobalEndpointReadyEvent ) {
        return GetLastError();
    }

    Error = InitializeEndPoints();
    if ( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "InitailizeEndPoints: 0x%lx\n", Error));
    }

    //
    //  Initialize vars in thread.c, start the ping thread, start
    //  message and processing threads in thread.c
    //

    Error = ThreadsDataInit(
        g_cMaxProcessingThreads,
        g_cMaxActiveThreads
    );

    if( ERROR_SUCCESS != Error )
        return Error;

    Error = PingInit();

    if( ERROR_SUCCESS != Error )
        return Error;

    Error = ThreadsStartup();

    if( ERROR_SUCCESS != Error )
        return Error;

    return ERROR_SUCCESS;
}

VOID
DhcpCleanupClientToServer(
    VOID
    )
/*++

Routine Description:

    This function frees up all resources that are allocated for the client
    to server protocol.

Arguments:

    DhcpRequest - Pointer to request context.

Return Value:

    None.

--*/
{
    ThreadsStop();
    PingCleanup();
    ThreadsDataCleanup();

    CleanupEndPoints();
    WaitForMessageThreadToQuit();
    DhcpReadWriteCleanup();
} // DhcpCleanupClientToServer()

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\upgrade\postupg.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    postupg.c

Abstract:

    test program to test post upgrade phase

--*/

#include <upgrade.h>

void _cdecl main(void)
{
    DWORD Error = DhcpUpgConvertTempToDhcpDb(NULL);
    if( NO_ERROR != Error ) {
        printf("ConvertTextToDhcpDatabase: %ld\n", Error);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\upgrade\upg.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    upg.c

Abstract:

    test program to test upgrade phase

--*/

#include <upgrade.h>

void _cdecl main(void)
{
    DWORD Error;
    Error = DhcpUpgConvertDhcpDbToTemp();
    if( NO_ERROR != Error ) {
        printf("ConvertDhcpDatabaseToText: %ld\n", Error);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\server\util.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains miscellaneous utility routines used by the
    DHCP server service.

Author:

    Madan Appiah (madana) 10-Sep-1993
    Manny Weiser (mannyw) 12-Aug-1992

Revision History:

--*/
#include <dhcppch.h>
#include "dhcp_srv.h"

#define  MESSAGE_BOX_WIDTH_IN_CHARS  65

LPSTR
ConvertDhcpSpeficErrors(
    IN ULONG ErrorCode
    )
{
    HMODULE hDhcpModule;
    LPSTR pMsg;
    ULONG nBytes;
                    
    if( ErrorCode < ERROR_FIRST_DHCP_SERVER_ERROR ||
        ErrorCode > ERROR_LAST_DHCP_SERVER_ERROR
        ) {
        return NULL;
    }

    //
    // Attempt to format the error correctly.
    //
    hDhcpModule = LoadLibrary(DHCP_SERVER_MODULE_NAME);
    
    nBytes = FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_HMODULE |
        FORMAT_MESSAGE_IGNORE_INSERTS ,
        (LPVOID)hDhcpModule,
        ErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // default country id
        (LPSTR)&pMsg,
        0,
        NULL
        );

    FreeLibrary(hDhcpModule);
    
    if( 0 == nBytes ) return NULL;

    DhcpAssert(NULL != pMsg);
    return pMsg;
}

VOID
DhcpServerEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode
    )
/*++

Routine Description:

    Logs an event in EventLog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event


    ErrorCode - Error Code to be Logged.

Return Value:

    None.

--*/

{
    DWORD Error;
    LPSTR Strings[1];
    CHAR ErrorCodeOemString[32 + 1];

    strcpy( ErrorCodeOemString, "%%" );
    _ultoa( ErrorCode, ErrorCodeOemString + 2, 10 );

    Strings[0] = ConvertDhcpSpeficErrors(ErrorCode);
    if( NULL == Strings[0] ) {
        Strings[0] = ErrorCodeOemString;
    }
    
    Error = DhcpReportEventA(
                DHCP_EVENT_SERVER,
                EventID,
                EventType,
                1,
                sizeof(ErrorCode),
                Strings,
                &ErrorCode );

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,
            "DhcpReportEventW failed, %ld.\n", Error ));
    }

    if( Strings[0] != ErrorCodeOemString ) {
        LocalFree(Strings[0]);
    }
    
    return;
}

VOID
DhcpServerJetEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode,
    LPSTR CallerInfo OPTIONAL
    )
/*++

Routine Description:

    Logs an event in EventLog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event


    ErrorCode - JET error code to be Logged.

    CallerInfo - info to locate where the call failed.

Return Value:

    None.

--*/

{
    DWORD Error;
    LPSTR Strings[2];
    CHAR ErrorCodeOemString[32 + 1];

    _ltoa( ErrorCode, ErrorCodeOemString, 10 );
    Strings[0] = ErrorCodeOemString;
    Strings[1] = CallerInfo? CallerInfo : "";

    Error = DhcpReportEventA(
                DHCP_EVENT_SERVER,
                EventID,
                EventType,
                2,
                sizeof(ErrorCode),
                Strings,
                &ErrorCode );

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,
            "DhcpReportEventW failed, %ld.\n", Error ));
    }

    return;
}

VOID
DhcpServerEventLogSTOC(
    DWORD EventID,
    DWORD EventType,
    DHCP_IP_ADDRESS IPAddress,
    LPBYTE HardwareAddress,
    DWORD HardwareAddressLength
    )

/*++

Routine Description:

    Logs an event in EventLog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event


    IPAddress - IP address to LOG.

    HardwareAddress - Hardware Address to log.

    HardwareAddressLength - Length of Hardware Address.

Return Value:

    None.

--*/
{
    DWORD Error;
    LPWSTR Strings[2];
    WCHAR IpAddressString[DOT_IP_ADDR_SIZE];
    LPWSTR HWAddressString = NULL;

    Strings[0] = DhcpOemToUnicode(
                    DhcpIpAddressToDottedString(IPAddress),
                    IpAddressString );

    //
    // allocate memory for the hardware address hex string.
    // Each byte in HW address is converted into two characters
    // in hex buffer. 255 -> "FF"
    //

    HWAddressString = DhcpAllocateMemory(
                        (2 * HardwareAddressLength + 1) *
                        sizeof(WCHAR) );

    if( HWAddressString == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    DhcpHexToString( HWAddressString, HardwareAddress, HardwareAddressLength );

    //
    // terminate Hex address string buffer.
    //

    HWAddressString[ 2 * HardwareAddressLength ] = L'\0';

    Strings[1] = HWAddressString;

    Error = DhcpReportEventW(
                DHCP_EVENT_SERVER,
                EventID,
                EventType,
                2,
                HardwareAddressLength,
                Strings,
                HardwareAddress );

Cleanup:

    if( HWAddressString != NULL ) {
        DhcpFreeMemory( HWAddressString );
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,
            "DhcpReportEventW failed, %ld.\n", Error ));
    }

    return;
}




DWORD
DisplayUserMessage(
    DWORD MessageId,
    ...
    )
/*++

Routine Description:

    This function starts a new thread to display a message box.

Arguments:

    MessageId - The ID of the message to display.
        On NT, messages are attached to the TCPIP service DLL.

Return Value:

    None.

--*/
{
    unsigned msglen;
    va_list arglist;
    LPVOID  pMsg;
    HINSTANCE hModule;
    DWORD   Error;


    hModule = LoadLibrary(DHCP_SERVER_MODULE_NAME);
    if ( hModule == NULL ) {
        Error = GetLastError();

        DhcpPrint((
            DEBUG_ERRORS,"DisplayUserMessage: FormatMessage failed with error = (%d)\n",
            Error ));
        return Error;

    }
    va_start(arglist, MessageId);
    if (!(msglen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
          FORMAT_MESSAGE_FROM_HMODULE | MESSAGE_BOX_WIDTH_IN_CHARS ,
          hModule,
          MessageId,
          0L,       // Default country ID.
          (LPTSTR)&pMsg,
          0,
          &arglist)))
    {
        Error = GetLastError();

        DhcpPrint((
            DEBUG_ERRORS,"DisplayUserMessage: FormatMessage failed with error = (%d)\n",
            Error ));
    }
    else
    {

      if(MessageBoxEx(
            NULL, pMsg, DHCP_SERVER_FULL_NAME, 
            MB_SYSTEMMODAL | MB_OK | MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION | MB_ICONSTOP, 
            MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL)) == 0)
      {
          Error = GetLastError();
          DhcpPrint((
              DEBUG_ERRORS,"DisplayUserMessage: MessageBoxEx failed with error = (%d)\n",
              Error ));


      }
      LocalFree(pMsg);

      Error = ERROR_SUCCESS;
    }

    FreeLibrary(hModule);

    return Error;
}


BOOL
CreateDirectoryPathW(
    IN LPWSTR StringPath,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

Routine Description:
    This routine creates the database path specified.
    (If a path a\b..x\y\z is specified, all the directories
    a,b,c.. etc are created if they do not exist.

Arguments:
    StringPath -- UNICIDE string for path to create
    pSecurityDescriptor -- security descriptor to use

Return Values:
    TRUE -- succeeded.
    FALSE -- failed, use GetLastError for error.
    
--*/
{
    BOOL fRetVal;
    ULONG Error;
    LPWSTR Next;
    SECURITY_ATTRIBUTES Attr = {
        sizeof(SECURITY_ATTRIBUTES), pSecurityDescriptor, FALSE
    };
    
    if( StringPath == NULL || L'\0' == *StringPath ) {
        SetLastError(ERROR_BAD_PATHNAME);
        return FALSE;
    }
    
    //
    // First simply try to create the directory specified.
    // If not possible we go about and do the long solution.
    // 
    // If the directory already exists, then we mask that
    // error and return success.
    //

    DhcpPrint(( DEBUG_MISC, "CreateDirectoryPathW() : Creating %ws\n",
                StringPath ));
//      fRetVal = CreateDirectory( StringPath, &Attr );
    fRetVal = CreateDirectory( StringPath, NULL );

    DhcpPrint(( DEBUG_MISC, "CreateDirectory : Error = %ld, %ld\n",
                fRetVal, GetLastError() ));
    if( FALSE != fRetVal ) return fRetVal;

    Error = GetLastError();
    if( ERROR_ALREADY_EXISTS == Error ) {
        return TRUE;
    }

    //
    // Aargh.  Nope, directory doesn't exist?
    //
    DhcpPrint((DEBUG_ERRORS, "CreateDirectory(%ws): 0x%lx\n",
               StringPath,Error));

    //
    // While trying to create directory, if the error is something
    // other than that the path doesn't exist, we don't bother creatin
    // parent directories..
    //
    
    if( ERROR_PATH_NOT_FOUND != Error ) return FALSE;

    //
    // Now loop until the required directory could be created.
    //

    Next = wcsrchr(StringPath, L'\\');
    if( NULL == Next ) {
        SetLastError(ERROR_BAD_PATHNAME);
        return FALSE;
    }

    (*Next) = L'\0';

    fRetVal = CreateDirectoryPathW(
        StringPath, pSecurityDescriptor
        );

    (*Next) = L'\\';

    //
    // If we couldn't create the parent directory, return error..
    //
    if( FALSE == fRetVal ) return fRetVal;

    //
    // Now attempt to create the child direcotry..
    //
//      fRetVal = CreateDirectory( StringPath, &Attr );
    fRetVal = CreateDirectory( StringPath, NULL );

    if( FALSE != fRetVal ) return fRetVal;

    DhcpPrint((DEBUG_ERRORS, "CreateDirectory(%ws): 0xlx\n",
               StringPath, GetLastError()));

    return fRetVal;
}

BOOL
CreateDirectoryPathOem(
    IN LPCSTR OemStringPath,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

Routine Description:
    This routine creates the database path specified.
    (If a path a\b..x\y\z is specified, all the directories
    a,b,c.. etc are created if they do not exist.

Arguments:
    OemStringPath -- OEM string for path to create
    pSecurityDescriptor -- security descriptor to use

Return Values:
    TRUE -- succeeded.
    FALSE -- failed, use GetLastError for error.
    
--*/
{
    LPWSTR UnicodeString;
    BOOL fRetVal;
    ULONG Error = 0;

    UnicodeString = DhcpOemToUnicode(
        (LPSTR)OemStringPath, NULL
        );
    if( NULL == UnicodeString ) {
        SetLastError(ERROR_CAN_NOT_COMPLETE);
        return FALSE;
    }

    fRetVal = CreateDirectoryPathW(
        UnicodeString, pSecurityDescriptor
        );

    if( FALSE == fRetVal ) {
        Error = GetLastError();
    }

    DhcpFreeMemory(UnicodeString);

    if( FALSE == fRetVal ) {
        SetLastError(Error);
    }

    return fRetVal;
}

ULONG
GetUserAndDomainNames(
    IN OUT WCHAR *UnameBuf,
    IN OUT PULONG UnameBufLen,
    IN OUT WCHAR *DomainBuf,
    IN OUT PULONG DomainBufLen
    )
/*++

Routine Description:
    This routine finds the user and domain
    name for the caller.  If the caller is
    impersonated, the user and domain name
    are the impersonated callers user and domain names.

Arguments:
    UnameBuf - buffer to hold user name.
    UnameBufLen - length of above buffer in wchars
    DomainBuf -- buffer to hold domain name.
    DomainBufLen -- length of above buffer in whcars

Return Values:
    Win32 errors.

    N.B The user name domain name buffers are passed to
    LookupAccountSid which can fail with ERROR_MORE_DATA or
    other errors if the buffers are of insufficient size.
    LookupAccountSid won't fail for lack of space if 
    both buffers are atleast 256 WCHARs long.

--*/
{
    HANDLE Token;
    TOKEN_USER *pTokenUser;
    ULONG Error, Len;
    PSID pSid;
    SID_NAME_USE eUse;
    BOOL fImpersonated = FALSE;

    if( RPC_S_OK == RpcImpersonateClient(NULL)) {
        fImpersonated = TRUE;
    }
    
    //
    // Get process token.
    //

    Error = NO_ERROR;
    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &Token)) {
        Error = GetLastError();
    }

    if( ERROR_ACCESS_DENIED == Error ) {
        Error = NO_ERROR;
        if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &Token)) {
            Error = GetLastError();
        }
    }

    if( NO_ERROR != Error ) {
        if( fImpersonated ) 
        {
            Error = RpcRevertToSelf();
        }
        return Error;
    }

    //
    // Query for user info.
    //

    do {
        Len = 0;
        GetTokenInformation(Token, TokenUser, NULL, 0, &Len);
        if( 0 == Len ) {
            Error = GetLastError();
            break;
        }
        
        pTokenUser = LocalAlloc(LPTR, Len);
        if( NULL == pTokenUser ) {
            Error = GetLastError();
            break;
        }

        if(!GetTokenInformation(
            Token, TokenUser, pTokenUser, Len, &Len
            )){
            Error = GetLastError();
            break;
        }

        pSid = pTokenUser->User.Sid;
        
        Error = NO_ERROR;
        if(!LookupAccountSid(
            NULL, pSid, UnameBuf, UnameBufLen, DomainBuf, DomainBufLen, &eUse
            )) {
            Error = GetLastError();
        }
        
        LocalFree(pTokenUser);
    } while ( 0 );

    CloseHandle(Token);

    if( fImpersonated )
    {
        Error = RpcRevertToSelf();
    }

    return Error;
}

ULONG
GetUserAndDomainName(
    IN WCHAR Buf[]
    )
/*++

Routine Description:
    This routine finds the caller's user and domain, and if
    the caller is impersonated a client, this gives the
    client's user and domain name.

    If the domain exists, the format is domain\username
    Otherwise it is just "username".

Return Values:
    Win32 errors..

--*/
{
    WCHAR UName[UNLEN+1];
    WCHAR DName[DNLEN+1];
    ULONG USize = UNLEN+1, DSize = DNLEN+1;
    ULONG Error;

    Buf[0] = L'\0';
    Error = GetUserAndDomainNames(UName, &USize, DName, &DSize);
    if( ERROR_SUCCESS != Error ) return Error;

    wcscpy(Buf, DName);
    if( DSize ) Buf[DSize++] = L'\\';
    wcscpy(&Buf[DSize], UName);
    return NO_ERROR;
}

//
// abstract: Initialize dynamic dns. Impersonate secret user to do so. 
// If secret user is not configured default attempt initializing dnsapi
// when not running on a DC.
// input : None
// output: ERROR_SUCCESS always.
// side-effect: DhcpGlobalUseNoDns is set not to do DNS updates when
// not appropriate.
//

DWORD
DynamicDnsInit(
    VOID
)
{

    DWORD Error  = ERROR_SUCCESS;
    DWORD Error1 = ERROR_SUCCESS;
    DWORD RunningOnDc = 0;
    WCHAR Uname[256], Domain[256], Passwd[256];
    DNS_CREDENTIALS   DnsDhcpCreds;

    LPWSTR DnsRegValName = L"DnsRegistrationUseDcCredentials";
    const DWORD  DnsRegValType = REG_DWORD;
    DWORD DnsRegistrationUseDcCredentials = 0;


    Uname[ 0 ]  = L'\0';
    Domain[ 0 ] = L'\0';
    Passwd[ 0 ] = L'\0';


    //
    // Terminate DynDNS thread if already running
    //

    if ( FALSE == DhcpGlobalUseNoDns ) {
        DnsDhcpSrvRegisterTerm();
        DhcpGlobalUseNoDns = TRUE;
    } // if

    //
    // figure out if running on DC.
    //

    RunningOnDc = IsRunningOnDc( );

    // Get the DnsRegistrationUseDcCredentials reg value
    // Defaults to don't use.
    Error = DhcpRegGetValue( DhcpGlobalRegParam,
                             DnsRegValName, DnsRegValType,
                             ( LPBYTE ) &DnsRegistrationUseDcCredentials );
    if ( ERROR_SUCCESS != Error ) {
        DnsRegistrationUseDcCredentials = 0;
    }


    // Get the account credentials to use
    Error = DhcpQuerySecretUname(
        ( LPWSTR ) Uname, sizeof( Uname ) / sizeof( WCHAR ),
        ( LPWSTR ) Domain, sizeof( Domain ) / sizeof( WCHAR ),
        ( LPWSTR ) Passwd, sizeof( Passwd ) / sizeof( WCHAR ));

    // Initialize the credential structure
    DnsDhcpCreds.pUserName = &Uname[ 0 ];
    DnsDhcpCreds.pDomain   = &Domain[ 0 ];
    DnsDhcpCreds.pPassword = &Passwd[ 0 ];

    //
    // Now try to call DNS API for impersonation of a valid user
    //

    if (( NO_ERROR == Error ) &&
        ( Uname[ 0 ] != L'\0' )) {

        // Max queue length could be upto 0xffff, but defaults to 0x400
        Error1 = DnsDhcpSrvRegisterInit( &DnsDhcpCreds, 0 );

    } // if impersonation account is configured
    else {
        if ( RunningOnDc ) {
            if ( DnsRegistrationUseDcCredentials ) {
                Error1 = DnsDhcpSrvRegisterInit( NULL, 0 );
            }
            else {
                DhcpServerEventLog( DHCP_EVENT_NO_DNSCREDENTIALS_ON_DC,
                                    EVENTLOG_WARNING_TYPE, 0 );
                Error1 = ERROR_INVALID_OPERATION;
            }
        }
        else {
            Error1 = DnsDhcpSrvRegisterInit( NULL, 0 );
        }
    } // not configured with impersonation account

    DhcpGlobalUseNoDns = ( Error1 != ERROR_SUCCESS );
    if ( DhcpGlobalUseNoDns ) {
        DnsDhcpSrvRegisterTerm();
    }
    //
    // dont shut down the service if dynamic dns initialization fails.
    //

    SecureZeroMemory( Passwd, sizeof( Passwd ));
    return ( ERROR_SUCCESS );
} // DynamicDnsInit()


DWORD
RevertFromSecretUser(
    IN VOID
    )
{
    if( FALSE == RevertToSelf() ) return GetLastError();
    return NO_ERROR;
}

BOOL
IsThisTheComputerName(
    IN LPWSTR Name
    )
{
    WCHAR ComputerName[300];
    DWORD Error, Size;

    DhcpPrint((DEBUG_MISC, "DC Name = %ws\n", Name ));

    if( NULL == Name || Name[0] == L'\0' ) return FALSE;
    if( Name[0] == L'\\' && Name[1] == L'\\' ) {
        Name += 2;
    }

    Size = sizeof(ComputerName)/sizeof(WCHAR);
    Error = GetComputerNameEx(
        ComputerNameDnsHostname, ComputerName, &Size );
    if( FALSE == Error ) {

        //
        // If this fails, there is probably no domain name at all
        //

        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "GetComputerNameEx(Host): %ld\n", Error));
        return FALSE;
    }

    if( 0 == _wcsicmp(Name, ComputerName) ) return TRUE;

    Size = sizeof(ComputerName)/sizeof(WCHAR);
    Error = GetComputerNameEx(
        ComputerNameDnsFullyQualified, ComputerName, &Size );
    if( FALSE == Error ) {

        //
        // If this fails, there is probably no domain name at all
        //
        
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "GetComputerNameEx(Fqdn): %ld\n", Error));
        return FALSE;
    }

    if( 0 == _wcsicmp(Name, ComputerName) ) return TRUE;
    return FALSE;
}

BOOL
IsRunningOnDc(
    VOID
    )
{
    DWORD Error, Size;
    WCHAR DomainName[300];
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    
    Size = sizeof(DomainName)/sizeof(WCHAR);
    Error = GetComputerNameEx(
        ComputerNameDnsDomain, DomainName, &Size );
    if( FALSE == Error ) {

        //
        // If this fails, there is probably no domain name at all
        //
        
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "GetComputerNameEx2: %ld\n", Error));
        return FALSE;
    }

    Error = DsGetDcName(
        NULL, DomainName, NULL, NULL,
        DS_DIRECTORY_SERVICE_REQUIRED | 
        DS_IS_DNS_NAME | DS_RETURN_DNS_NAME, &pDcInfo );

    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "DsGetDcName: %ld\n", Error));
    } else {

        if( pDcInfo != NULL ) {
            Error = IsThisTheComputerName(pDcInfo->DomainControllerName);
            NetApiBufferFree(pDcInfo);
            if( Error == TRUE ) return TRUE;
        }
    }

    return FALSE;    
}

DWORD
DhcpBeginWriteApi(
    IN LPSTR ApiName
    )
{
    DWORD Error;

    DhcpPrint((DEBUG_APIS, "%s called\n", ApiName));
    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if( NO_ERROR != Error ) return Error;
    
    DhcpAcquireWriteLock();
    LOCK_DATABASE();


#if 0
    //
    // The following code has problems because of the size of the
    // database update that can be done within a BeginWriteApi
    // and EndWriteApi.  So, the proposal is to just do the
    // transaction recovery in the EndWriteApi.DhcpConfigSave routine.
    //
    Error = DhcpJetBeginTransaction();
    if( NO_ERROR != Error ) {
        UNLOCK_DATABASE();
        DhcpReleaseWriteLock();
    }
#endif
    
    return Error;
}

DWORD
DhcpEndWriteApiEx(
    IN LPSTR ApiName,
    IN ULONG Error,
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DHCP_IP_ADDRESS Subnet OPTIONAL,
    IN DWORD Mscope OPTIONAL,
    IN DHCP_IP_ADDRESS Reservation OPTIONAL
    )
{
    if( NO_ERROR == Error ) {
        Error = DhcpConfigSave(
            fClassChanged, fOptionsChanged, Subnet, Mscope,
            Reservation );
        if( NO_ERROR != Error ) {
            DhcpPrint((DEBUG_ERRORS, "DhcpConfigSave: 0x%lx\n", Error));
        }
    }

    DhcpPrint((DEBUG_APIS, "%s returned %ld\n", ApiName, Error));
        
#if 0
    //
    // See comments in DhcpBeginWriteApi
    //
    
    if( NO_ERROR == Error ) {
        Error = DhcpJetCommitTransaction();
    } else {
        Error = DhcpJetRollBack();
    }

    DhcpAssert( NO_ERROR == Error );
#endif

    UNLOCK_DATABASE();
    DhcpReleaseWriteLock();

    if( NO_ERROR == Error ) {
        DhcpScheduleRogueAuthCheck();
    }

    return Error;
}


DWORD
DhcpEndWriteApi(
    IN LPSTR ApiName,
    IN ULONG Error
    )
{
    return DhcpEndWriteApiEx(
        ApiName, Error, FALSE, FALSE, 0, 0, 0 );
}

DWORD
DhcpBeginReadApi(
    IN LPSTR ApiName
    )
{
    DWORD Error;

    DhcpPrint((DEBUG_APIS, "%s called\n", ApiName));
    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if( NO_ERROR != Error ) return Error;

    DhcpAcquireReadLock();

    return NO_ERROR;
}

VOID
DhcpEndReadApi(
    IN LPSTR ApiName,
    IN ULONG Error
    )
{
    DhcpPrint((DEBUG_APIS, "%s returned %ld\n", ApiName, Error));
    DhcpReleaseReadLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\upgrade\db.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    db.c

Abstract:

    Upgrade databases from NT3.51, NT4.0 and NT5.0 to Whistler.

    N.B: Most of this is taken from dhcp\server\server\database.c
    
--*/

#include <upgrade.h>

//
// Debugging and logging
//
typedef enum {
    Winnt32LogSevereError,
    Winnt32LogError,
    Winnt32LogWarning,
    Winnt32LogInformation,
    Winnt32LogDetailedInformation,
    Winnt32LogMax
} Winnt32DebugLevel;

HANDLE hInst;
HANDLE hDebugLog;
Winnt32DebugLevel DebugLevel;
typedef DWORD (WINAPI *GetClusterStateFn)( LPCWSTR, DWORD*);

ULONG
ByteSwap(
    IN ULONG Source
    )
{
    ULONG swapped;

    swapped = ((Source)              << (8 * 3)) |
              ((Source & 0x0000FF00) << (8 * 1)) |
              ((Source & 0x00FF0000) >> (8 * 1)) |
              ((Source)              >> (8 * 3));

    return swapped;
}

LPSTR
IpAddressToString(
    IN ULONG Address
    )
{
    static CHAR Buffer[30];
    PUCHAR pAddress;

    pAddress = (PUCHAR)&Address;
    sprintf(Buffer, "%d.%d.%d.%d", pAddress[0], pAddress[1],
            pAddress[2], pAddress[3] );
    return Buffer;
}

VOID
ConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    )

/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
        path separator and Path2 does not start with one, then a path sep
        is appended to Path1 before appending Path2.

    BufferSizeChars - supplies the size in chars (Unicode version) or
        bytes (Ansi version) of the buffer pointed to by Path1. The string
        will be truncated as necessary to not overflow that size.

Return Value:

    None.

--*/

{
    BOOL NeedBackslash = TRUE;
    DWORD l;
     
    if(!Path1)
        return;

    l = lstrlen(Path1);

    if(BufferSizeChars >= sizeof(TCHAR)) {
        //
        // Leave room for terminating nul.
        //
        BufferSizeChars -= sizeof(TCHAR);
    }

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == TEXT('\\'))) {

        NeedBackslash = FALSE;
    }

    if(Path2 && *Path2 == TEXT('\\')) {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary and if it fits.
    //
    if(NeedBackslash && (l < BufferSizeChars)) {
        lstrcat(Path1,TEXT("\\"));
    }

    //
    // Append second part of string to first part if it fits.
    //
    if(Path2 && ((l+lstrlen(Path2)) < BufferSizeChars)) {
        lstrcat(Path1,Path2);
    }
}


LPTSTR
DupString(
    IN LPCTSTR String
    )

/*++

Routine Description:

    Make a duplicate of a nul-terminated string.

Arguments:

    String - supplies pointer to nul-terminated string to copy.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    LPTSTR p;

    if(p = LocalAlloc(LPTR, (lstrlen(String)+1)*sizeof(TCHAR))) {
        lstrcpy(p,String);
    }

    return(p);
}


/***
*void Parse_Cmdline(cmdstart, argv, lpstr, numargs, numbytes)
*
*Purpose:
*       Parses the command line and sets up the Unicode argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, lpstr
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only counting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numbytes has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       LPWSTR cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       TCHAR **argv - where to build argv array; NULL means don't
*                      build array
*       LPWSTR lpstr - where to place argument text; NULL means don't
*                      store text
*
*Exit:
*       no return value
*       INT *numargs - returns number of argv entries created
*       INT *numbytes - number of bytes used in args buffer
*
*Exceptions:
*
*******************************************************************************/

void Parse_Cmdline (
    LPTSTR cmdstart,
    LPTSTR*argv,
    LPTSTR lpstr,
    INT *numargs,
    INT *numbytes
    )
{
    LPTSTR p;
    TCHAR c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *numbytes = 0;
    *numargs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = cmdstart;
    if (argv)
        *argv++ = lpstr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to numbytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;
        }
        /* append the terminating null */
        *numbytes += sizeof(WCHAR);
        if (lpstr)
            *lpstr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;

            c = *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (lpstr)
                *(lpstr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = lpstr;         /* store ptr to arg */
        ++*numargs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (lpstr)
                    *lpstr++ = TEXT('\\');
                *numbytes += sizeof(WCHAR);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (lpstr)
                        *lpstr++ = *p;
                *numbytes += sizeof(WCHAR);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (lpstr)
            *lpstr++ = TEXT('\0');         /* terminate string */
        *numbytes += sizeof(WCHAR);
    }

}


LPTSTR *
CommandLineToArgv(
    OUT int *NumArgs
    )
{
    LPTSTR CommandLine;
    TCHAR  ModuleName[MAX_PATH];
    LPTSTR Start;
    INT    Size;
    LPTSTR *Args;

    CommandLine = GetCommandLine();
    GetModuleFileName(NULL,ModuleName,MAX_PATH);

    //
    // If there's no command line at all (won't happen from cmd.exe, but
    // possibly another program), then we use pgmname as the command line
    // to parse, so that argv[0] is initialized to the program name
    //
    Start = *CommandLine ? CommandLine : ModuleName;

    //
    // Find out how much space is needed to store args,
    // allocate space for argv[] vector and strings,
    // and store args and argv ptrs in block we allocate
    //

    Parse_Cmdline(Start,NULL,NULL,NumArgs,&Size);

    Args = (LPTSTR *)LocalAlloc(LMEM_ZEROINIT,((*NumArgs+1) * sizeof(LPTSTR)) + Size);
    if(!Args) {
        return(NULL);
    }

    Parse_Cmdline(Start,Args,(LPTSTR)(Args + *NumArgs),NumArgs,&Size);

    return(Args);
}

BOOL
StartDebugLog(
    IN LPCTSTR DebugFileLog,
    IN Winnt32DebugLevel Level
    )
{
    if( hDebugLog ) return TRUE;

    hInst = LoadLibrary(TEXT("DHCPUPG.DLL"));
    
    if(Level >= Winnt32LogMax) Level = Winnt32LogMax-1;
    DebugLevel = Level;

    hDebugLog = CreateFile(
        DebugFileLog, GENERIC_WRITE,
        FILE_SHARE_READ, NULL, OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        NULL );

    if( hDebugLog == INVALID_HANDLE_VALUE) {
        hDebugLog = NULL;
        return FALSE;
    }

    if(GetLastError() == ERROR_ALREADY_EXISTS) {
        //
        // Appending to existing file
        //

        SetFilePointer(hDebugLog,0,NULL,FILE_END);
    }

    return(TRUE);
}

VOID
CloseDebugLog(
    VOID
    )
{
    if( hDebugLog ) {
        CloseHandle( hDebugLog );
        hDebugLog = NULL;
    }
}

VOID
StartDebug(
    VOID
    )
/*++

Routine Description:

    Parse arguments passed to the program.  Perform syntactic validation
    and fill in defaults where necessary.

    Valid arguments:

    /debug[level][:filename]    maintain debug log at level, defaults to warning level 2
                                and file c:\winnt32.log

    /tempdrive:letter           manually specify drive for local source

Arguments:

    None. Arguments are retreived via GetCommandLine().

Return Value:

    None.

--*/

{
    LPTSTR Arg;
    LPTSTR BadParam = NULL;
    LPTSTR Colon;
    LPTSTR p;
    BOOL Valid;
    LPCTSTR DebugFileLog;
    LONG lDebugLevel;
    BOOL b;
    unsigned u;
    int argc;
    LPTSTR *argv;
    BOOL Downloaded = FALSE;

    argv = CommandLineToArgv(&argc);

    //
    // Skip program name. We should always get back argc as at least 1,
    // but be robust anyway.
    //
    if(argc) {
        argc--;
        argv++;
    }

    DebugFileLog = NULL;
    lDebugLevel = 0;
    Valid = FALSE;

    while(argc--) {
        Arg = *argv++;
        if((*Arg == TEXT('/')) || (*Arg == TEXT('-'))) {

            switch(_totupper(Arg[1])) {

            case TEXT('D'):

                if(DebugFileLog || _tcsnicmp(Arg+1,TEXT("debug"),5)) {
                    break;
                }

                lDebugLevel = _tcstol(Arg+6,&Colon,10);
                if((lDebugLevel == -1) || (*Colon && (*Colon != TEXT(':')))) {
                    break;
                }

                if(Colon == Arg+6) {
                    //
                    // No debug level specified, use default
                    //
                    lDebugLevel = Winnt32LogWarning;
                }

                if(*Colon) {
                    //
                    // Log file name was specified.
                    //
                    Colon++;
                    if(*Colon) {
                        // Hardcode debug file to
                        // %windir%\dhcpupg.log for now
                        // DebugFileLog = Colon;
                    } 
                }
                break;

            }
        }
    }

    if( lDebugLevel == 0 || lDebugLevel == -1 ) {
        lDebugLevel = Winnt32LogInformation;
    }
    if( DebugFileLog == NULL ) {
        TCHAR   Buffer[MAX_PATH];
        if( 0 == GetWindowsDirectory( Buffer, MAX_PATH )) {
            ZeroMemory(Buffer, sizeof(Buffer));
        }
        ConcatenatePaths( Buffer, TEXT("DHCPUPG.LOG"), MAX_PATH );
        DebugFileLog = DupString( Buffer );
    }

    if( DebugFileLog ) Valid = StartDebugLog(DebugFileLog,lDebugLevel);
    if( !Valid ) {
        DbgPrint( "DHCPUPG: Logging not done.\n" );
    } 
}

struct _MSG_MAP {
    DWORD MessageId;
    LPWSTR MessageStr;
} MessageMap[] = {
    MSGERR_STARTLOG,L"DHCPUPG: **************  Starting conversion to text.\n",
    MSGERR_STARTLOG2,L"DHCPUPG: **************  Starting conversion from text.\n",
    MSGERR_VALUE,L"DHCPUPG: Error reading registry value %1!s! : %2!d!.\n",
    MSGERR_EXPAND,L"DHCPUPG: Error expanding environment variables in string %1!s!.\n",
    MSGERR_OPENPARAMSKEY,L"DHCPUPG: Error opening the Parameters key: %1!d!.\n",
    MSGERR_GETDBPARAMS,L"DHCPUPG: Successfully read DHCP registry parameters.\n",
    MSGERR_LOAD,L"DHCPUPG: %2!s! failed to load: %1!d!.\n",
    MSGERR_GETPROCADDR,L"DHCPUPG: Error linking to routine %2!s!: %1!d!.\n",
    MSGERR_SETDBPARAM,L"DHCPUPG: Error attempting to set database param %2!d!: %1!d!.\n",
    MSGERR_JETINIT,L"DHCPUPG: Error initializing Jet database: %1!d!.\n",
    MSGERR_JETBEGINSESSION,L"DHCPUPG: Error initializing Jet session: %1!d!.\n",
    MSGERR_JETDETACHDB,L"DHCPUPG: Error detaching Jet database: %1!d!.\n",
    MSGERR_JETATTACHDB,L"DHCPUPG: Error attaching Jet database: %1!d!.\n",
    MSGERR_JETOPENDB,L"DHCPUPG: Error opening Jet database: %1!d!.\n",
    MSGERR_JETOPENTABLE,L"DHCPUPG: Error opening Jet database table: %1!d!.\n",
    MSGERR_JETGETCOL,L"DHCPUPG: Error opening Jet table column: %1!d!.\n",
    MSGERR_JETOPENMTABLE,L"DHCPUPG: Error opening Jet database mcast table: %1!d!.\n",
    MSGERR_JETGETMCOL,L"DHCPUPG: Error opening Jet mcast table column: %1!d!.\n",
    MSGERR_INITDB,L"DHCPUPG: Attempting to intialize jet database (version %1!d!).\n",
    MSGERR_REGISTRY,L"DHCPUPG: Error reading parameters from registry: %1!d!.\n",
    MSGERR_LOADESE,L"DHCPUPG: Error failed to initialize ESE database: %1!d!.\n",
    MSGERR_LOAD500,L"DHCPUPG: Error failed to initialize Jet500 database: %1!d!.\n",
    MSGERR_LOAD200,L"DHCPUPG: Error failed to initialize Jet200 database: %1!d!.\n",
    MSGERR_GETCOL,L"DHCPUPG: Error retrieving column %2!d!: %1!d!.\n",
    MSGERR_GETMCOL,L"DHCPUPG: Error retrieving mcast column %2!d!: %1!d!.\n",
    MSGERR_SETINDEX,L"DHCPUPG: Error attempting to set the index for the database: %1!d!.\n",
    MSGERR_INVALIDIP,L"DHCPUPG: Invalid record -- IP address value is not of the right size.\n",
    MSGERR_INVALIDMASK,L"DHCPUPG: Invalid record -- Subnet Mask value is not of the right size.\n",
    MSGERR_INVALIDNAME,L"DHCPUPG: Invalid record -- Name value is not of the right size.\n",
    MSGERR_INVALIDINFO,L"DHCPUPG: Invalid record -- Machine Info value is not of the right size.\n",
    MSGERR_INVALIDEXPIRATION,L"DHCPUPG: Invalid record -- Lease value is not of the right size.\n",
    MSGERR_SCANCOUNT,L"DHCPUPG: Scanned %1!d! records.\n",
    MSGERR_SETMINDEX,L"DHCPUPG: Error attempting to set the index for the mcast table: %1!d!.\n",
    MSGERR_INVALIDMIP,L"DHCPUPG: Invalid mcast record -- IP address value is not of the right size.\n",
    MSGERR_INVALIDSCOPEID,L"DHCPUPG: Invalid mcast record -- ScopeId value is not of the right size.\n",
    MSGERR_INVALIDMEXPIRATION,L"DHCPUPG: Invalid mcast record -- Lease value is not of the right size.\n",
    MSGERR_INVALIDMSTART,L"DHCPUPG: Invalid mcast record -- LeaseStart value is not of the right size.\n",
    MSGERR_SCANMCOUNT,L"DHCPUPG: Scanned %1!d! mcast records.\n",
    MSGERR_CONVERT_FAILED,L"DHCPUPG: Failed to convert DHCP database to temporary format.\n",
    MSGERR_CONVERT_SUCCEEDED,L"DHCPUPG: Successfully converted DHCP database to temporary format.\n",
    MSGERR_CREATE_FILE_FAILED,L"DHCPUPG: Cannot create the destination temporary file: %1!d!.\n",
    MSGERR_OPENSCM,L"DHCPUPG: Unable to open the services control manager: %1!d!.\n",
    MSGERR_OPENSVC,L"DHCPUPG: Unable to open the DHCPServer service: %1!d!.\n",
    MSGERR_SVCQUERY,L"DHCPUPG: Unable to query the status of DHCPServer service: %1!d!.\n",
    MSGERR_SVCWAIT,L"DHCPUPG: DHCPServer service is in %1!d! state -- waiting for it to stop.\n",
    MSGERR_SVCCTRL,L"DHCPUPG: DHCPServer failed to stop: %1!d!.\n",
    MSGERR_SVCSTOP_SUCCESS,L"DHCPUPG: DHCPServer service has stopped successfully.\n",
    MSGERR_CREATE_MAP,L"DHCPUPG: Failed to create a mapping object for file: %1!d!.\n",
    MSGERR_CREATE_VIEW,L"DHCPUPG: Failed to create memory view for file: %1!d!.\n",
    MSGERR_SETVALUE,L"DHCPUPG: Failed to set the \"Version\" registry value: %1!d!.\n",
    MSGERR_DELETEFILE,L"DHCPUPG: Failed to delete the temporary file: %1!d!.\n",
    MSGERR_CHANGEPERMS,L"DHCPUPG: Failed to convert permissions on database: %1!d!.\n",
    MSGERR_INVALIDRECORDTYPE, L"DHCPUPG: Error invalid record type. Offset: %1!d!\n",
    0xFFFFFFFF, 0
};

BOOL
DebugLog(
    IN Winnt32DebugLevel Level,
    IN UINT MessageId,
    ...
    )
{
    CHAR MessageA[5000];
    va_list arglist;
    DWORD Size, Written, i;
    LPWSTR Message;
    BOOL b;

    if( !hDebugLog ) return FALSE;
    if( Level > DebugLevel ) return TRUE;

    va_start(arglist,MessageId);

    Size = FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        hInst, MessageId, 0, (LPWSTR)&Message, 0, &arglist );

    if( Size == 0 ) {
        for( i = 0; MessageMap[i].MessageId != 0xFFFFFFFF ; i ++ ) {
            if( MessageMap[i].MessageId == MessageId ) break;
        }
        if( MessageMap[i].MessageId == MessageId ) {
            Size = FormatMessageW(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                MessageMap[i].MessageStr, MessageId, 0,
                (LPWSTR)&Message, 0, &arglist ); 
        }
    }
    
    va_end(arglist);

    b = FALSE;
    if(Size) {
        Size = WideCharToMultiByte(
            CP_ACP, 0, Message, -1, MessageA, sizeof(MessageA),
            NULL, NULL );

        if( Size ) b = WriteFile(
            hDebugLog, MessageA, Size-1, &Written, NULL );

        LocalFree((HLOCAL)Message);
    } 

    return b;
}

//
// reading the database
//

enum {
    LoadJet200,
    LoadJet500,
    LoadJet97,
};

typedef enum {
    RecordTypeDbEntry,
    RecordTypeMcastDbEntry,
} RECORD_TYPE;

//
// database table and field names.
//

#define IPADDRESS_INDEX                                0
#define HARDWARE_ADDRESS_INDEX                         1
#define STATE_INDEX                                    2
#define MACHINE_INFO_INDEX                             3
#define MACHINE_NAME_INDEX                             4
#define LEASE_TERMINATE_INDEX                          5
#define SUBNET_MASK_INDEX                              6
#define SERVER_IP_ADDRESS_INDEX                        7
#define SERVER_NAME_INDEX                              8
#define CLIENT_TYPE_INDEX                              9
#define MAX_INDEX                                      10


#define LogErr printf
#define LogInf printf
#define LogError(A,B) if(Error)LogErr("DHCP: %s:%s:0x%lx\n",#A,#B,Error)
#define LogErrorEx(A,B,C) if(Error)LogErr("DHCP: %s:%s:%s:0x%lx\n",#A,#B,#C,Error)
#define LogInfo(A,B,C) LogInf("DHCP: " #A B, C)

//
// Globals
//

DWORD LastError;
DWORD JetVersion;
CHAR DatabaseName[1024], DatabasePath[1024];
HMODULE hJet;
JET_INSTANCE JetInstance;
JET_SESID JetSession;
JET_DBID JetDb;
JET_TABLEID JetTbl;
HANDLE hTextFile, hMapping;
PVOID FileView;
DWORD LoSize, HiSize;
WCHAR Winnt32Path[MAX_PATH*2];
CHAR System32Path[MAX_PATH*2];

JET_ERR (JET_API *pJetSetCurrentIndex)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName
    );
JET_ERR (JET_API *pJetRetrieveColumn)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	void			*pvData,
	unsigned long	cbData,
	unsigned long	*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo );

JET_ERR (JET_API *pJetMove)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	long			cRow,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetSetSystemParameter)(
	JET_INSTANCE	*pinstance,
	JET_SESID		sesid,
	unsigned long	paramid,
	ULONG_PTR		lParam,
	const char		*sz );

JET_ERR (JET_API *pJetTerm)( JET_INSTANCE instance );

JET_ERR (JET_API *pJetTerm2)( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR (JET_API *pJetEndSession)( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR (JET_API *pJetBeginSession)(
	JET_INSTANCE	instance,
	JET_SESID		*psesid,
	const char		*szUserName,
	const char		*szPassword );

JET_ERR (JET_API *pJetInit)( JET_INSTANCE *pinstance);

JET_ERR (JET_API *pJetDetachDatabase)(
	JET_SESID		sesid,
	const char		*szFilename );

JET_ERR (JET_API *pJetAttachDatabase)(
	JET_SESID		sesid,
	const char		*szFilename,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetOpenDatabase)(
	JET_SESID		sesid,
	const char		*szFilename,
	const char		*szConnect,
	JET_DBID		*pdbid,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetCloseDatabase)(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetOpenTable)(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	const void		*pvParameters,
	unsigned long	cbParameters,
	JET_GRBIT		grbit,
	JET_TABLEID		*ptableid );

JET_ERR (JET_API *pJetCloseTable)( JET_SESID sesid, JET_TABLEID tableid );

JET_ERR (JET_API *pJetGetTableColumnInfo)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR (JET_API *pJetGetIndexInfo)(
        JET_SESID               sesid,
        JET_DBID                dbid,
        const char              *szTableName,
        const char              *szIndexName,
        void                    *pvResult,
        unsigned long   cbResult,
        unsigned long   InfoLevel );

#define DB_FUNC(F,I,S) \
{#F, TEXT(#F), #F "@" #S, I, (FARPROC *)& p ## F }

typedef struct _DB_FUNC_ENTRY {
    LPSTR FuncName;
    LPWSTR FuncNameW;
    LPSTR AltName;
    DWORD Index;
    FARPROC *FuncPtr;
} DB_FUNC_ENTRY;

DB_FUNC_ENTRY FuncTable[] = {
    DB_FUNC(JetSetCurrentIndex, 164, 12),
    DB_FUNC(JetRetrieveColumn, 157, 32),
    DB_FUNC(JetMove, 147, 16),
    DB_FUNC(JetSetSystemParameter, 165, 20),
    DB_FUNC(JetTerm, 167, 4),
    DB_FUNC(JetTerm2, 0, 8),
    DB_FUNC(JetEndSession, 124, 8),
    DB_FUNC(JetBeginSession, 104, 16),
    DB_FUNC(JetInit, 145, 4),
    DB_FUNC(JetDetachDatabase, 121, 8),
    DB_FUNC(JetAttachDatabase, 102, 12),
    DB_FUNC(JetOpenDatabase, 148, 20),
    DB_FUNC(JetOpenTable, 149, 28),
    DB_FUNC(JetGetTableColumnInfo, 137, 24),
    DB_FUNC(JetCloseTable,108, 8),
    DB_FUNC(JetCloseDatabase, 107, 12),
    DB_FUNC(JetGetIndexInfo, 131, 28),
};

#define JetSetCurrentIndex pJetSetCurrentIndex
#define JetRetrieveColumn pJetRetrieveColumn
#define JetMove pJetMove
#define JetSetSystemParameter pJetSetSystemParameter
#define JetTerm pJetTerm
#define JetTerm2 pJetTerm2
#define JetEndSession pJetEndSession
#define JetBeginSession pJetBeginSession
#define JetInit pJetInit
#define JetDetachDatabase pJetDetachDatabase
#define JetAttachDatabase pJetAttachDatabase
#define JetOpenDatabase pJetOpenDatabase
#define JetOpenTable pJetOpenTable
#define JetGetTableColumnInfo pJetGetTableColumnInfo
#define JetCloseTable pJetCloseTable
#define JetCloseDatabase pJetCloseDatabase
#define JetGetIndexInfo pJetGetIndexInfo

typedef struct _TABLE_INFO {
    CHAR *ColName;
    JET_COLUMNID ColHandle;
    BOOL fPresent;
    JET_COLTYP ColType;
} TABLE_INFO, *LPTABLE_INFO;

#define IPADDRESS_STRING        "IpAddress"
#define HARDWARE_ADDRESS_STRING "HardwareAddress"
#define STATE_STRING            "State"
#define MACHINE_INFO_STRING     "MachineInformation"
#define MACHINE_NAME_STRING     "MachineName"
#define LEASE_TERMINATE_STRING  "LeaseTerminates"
#define SUBNET_MASK_STRING      "SubnetMask"
#define SERVER_IP_ADDRESS_STRING "ServerIpAddress"
#define SERVER_NAME_STRING      "ServerName"
#define CLIENT_TYPE             "ClientType"

static TABLE_INFO ClientTable[] = {
    { IPADDRESS_STRING        , 0, 1, JET_coltypLong },
    { HARDWARE_ADDRESS_STRING , 0, 1, JET_coltypBinary },
    { STATE_STRING            , 0, 1, JET_coltypUnsignedByte },
    { MACHINE_INFO_STRING     , 0, 1, JET_coltypBinary }, // must modify MACHINE_INFO_SIZE if this changes
    { MACHINE_NAME_STRING     , 0, 1, JET_coltypBinary },
    { LEASE_TERMINATE_STRING  , 0, 1, JET_coltypCurrency },
    { SUBNET_MASK_STRING      , 0, 1, JET_coltypLong },
    { SERVER_IP_ADDRESS_STRING, 0, 1, JET_coltypLong },
    { SERVER_NAME_STRING      , 0, 1, JET_coltypBinary },
    { CLIENT_TYPE             , 0, 1, JET_coltypUnsignedByte }
};

#define MCAST_CLIENT_TABLE_NAME       "MCastClientTableVer3"

#define MCAST_TBL_IPADDRESS_STR "MCastIpAddr"
#define MCAST_TBL_CLIENT_ID_STR "MCastClientID"
#define MCAST_TBL_CLIENT_INFO_STR "MCastClientInfo"
#define MCAST_TBL_STATE_STR     "MCastState"
#define MCAST_TBL_FLAGS_STR     "MCastFlags"
#define MCAST_TBL_SCOPE_ID_STR     "ScopeId"
#define MCAST_TBL_LEASE_START_STR   "MCastLeaseStart"
#define MCAST_TBL_LEASE_END_STR     "MCastLeaseEnd"
#define MCAST_TBL_SERVER_IP_ADDRESS_STR "MCastServerIp"
#define MCAST_TBL_SERVER_NAME_STR "MCastServerName"

enum {
    MCAST_TBL_IPADDRESS,
    MCAST_TBL_CLIENT_ID,
    MCAST_TBL_CLIENT_INFO,
    MCAST_TBL_STATE,
    MCAST_TBL_FLAGS,
    MCAST_TBL_SCOPE_ID,
    MCAST_TBL_LEASE_START,
    MCAST_TBL_LEASE_END,
    MCAST_TBL_SERVER_IP_ADDRESS,
    MCAST_TBL_SERVER_NAME,
    MCAST_MAX_COLUMN
};

TABLE_INFO MadcapClientTable[] = {
    { MCAST_TBL_IPADDRESS_STR        , 0, 1, JET_coltypLongBinary },
    { MCAST_TBL_CLIENT_ID_STR        , 0, 1, JET_coltypBinary },
    { MCAST_TBL_CLIENT_INFO_STR      , 0, 1, JET_coltypLongBinary },
    { MCAST_TBL_STATE_STR            , 0, 1, JET_coltypUnsignedByte },
    { MCAST_TBL_FLAGS_STR            , 0, 1, JET_coltypLong },
    { MCAST_TBL_SCOPE_ID_STR         , 0, 1, JET_coltypBinary },
    { MCAST_TBL_LEASE_START_STR      , 0, 1, JET_coltypCurrency },
    { MCAST_TBL_LEASE_END_STR  ,       0, 1, JET_coltypCurrency },
    { MCAST_TBL_SERVER_IP_ADDRESS_STR, 0, 1, JET_coltypLongBinary },
    { MCAST_TBL_SERVER_NAME_STR,       0, 1, JET_coltypBinary },
};

JET_TABLEID MadcapTbl;

VOID static
CleanupDatabase(
    VOID
    )
{
    if( JetTbl != 0 ) {
        JetCloseTable( JetSession, JetTbl );
        JetTbl = 0;
    }

    if( MadcapTbl != 0 ) {
        JetCloseTable( JetSession, MadcapTbl );
        MadcapTbl = 0;
    }
    
    if( JetSession != 0 ) {
        JetEndSession( JetSession, 0 );
        JetSession = 0;
    }

    if( NULL != hJet ) {
        if( NULL != JetTerm2 ) {
            JetTerm2( JetInstance, JET_bitTermComplete );
        } else {
            JetTerm( JetInstance );
        }

        FreeLibrary( hJet ); hJet = NULL;
    }

    JetInstance = 0;
}

DWORD
ReadString(
    IN HKEY hKey,
    IN LPSTR KeyName,
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    DWORD Error, Size, Type;
    CHAR Str[1024];

    Size = sizeof(Str);
    Error = RegQueryValueExA(
        hKey, KeyName, NULL, &Type, (LPSTR)Str, &Size );
    if( NO_ERROR == Error ) {
        if( 0 == Size || 1 == Size ) Error = ERROR_NOT_FOUND;
        if( Type != REG_SZ && Type != REG_EXPAND_SZ && Type !=
            REG_MULTI_SZ ) Error = ERROR_BAD_FORMAT;
    }

    if( NO_ERROR != Error ) return Error;

    Size = ExpandEnvironmentStringsA( (LPSTR)Str, Buffer, BufSize );
    if( Size == 0 || Size > BufSize ) {
        Error = ERROR_META_EXPANSION_TOO_LONG;
    }

    if(Error) DebugLog(Winnt32LogError,MSGERR_EXPAND,KeyName);
    return Error;
}

DWORD
ReadRegistry(
    VOID
    )
{
    HKEY hKey;
    DWORD Error, Size;
    CHAR Str[1024];

    //
    // Open dhcp server parameters key
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_READ, &hKey );

    if(Error)DebugLog(Winnt32LogError, MSGERR_OPENPARAMSKEY, Error );
    if( NO_ERROR != Error ) return Error;

    //
    // Read database details
    //

    do {
        Error = ReadString(
            hKey, "DatabasePath", (LPSTR)DatabasePath,
            sizeof(DatabasePath) );

        if(Error)DebugLog(Winnt32LogError,MSGERR_VALUE, L"DatabasePath", Error);
        if( NO_ERROR != Error ) break;

        Error = ReadString(
            hKey, "DatabaseName", (LPSTR)DatabaseName,
            sizeof(DatabaseName) );

        if(Error)DebugLog(Winnt32LogError,MSGERR_VALUE, L"DatabaseName", Error);
        if( NO_ERROR != Error ) break;

        Error = NO_ERROR;

        DebugLog(Winnt32LogInformation, MSGERR_GETDBPARAMS );
    } while( 0 );

    RegCloseKey( hKey );
    return Error;
}

DWORD
LoadAndLinkRoutines(
    IN DWORD JetVersion
    )
{
    DWORD Error, i;
    LPTSTR Module;
    LPSTR FuncName;

    Module = NULL;
    switch( JetVersion ) {
    case LoadJet97 : Module = TEXT("esent.dll"); break;
    case LoadJet500 : Module = TEXT("jet500.dll"); break;
    case LoadJet200 : Module = TEXT("jet.dll"); break;
    default: Module = TEXT("esent.dll"); break;
    }

    hJet = LoadLibrary( Module );
    if( NULL == hJet ) {
        Error = GetLastError();
    } else {
        Error = NO_ERROR;
    }

    if(Error)DebugLog(Winnt32LogInformation, MSGERR_LOAD, Error, Module );
    if( NO_ERROR != Error ) return Error;

    for( i = 0; i < sizeof(FuncTable)/sizeof(FuncTable[0]); i ++ ) {
        (*FuncTable[i].FuncPtr) = NULL;
    }

    for( i = 0; i < sizeof(FuncTable)/sizeof(FuncTable[0]); i ++ ) {
        if( LoadJet200 != JetVersion ) {
            FuncName = FuncTable[i].FuncName;
        } else {
            if( 0 == FuncTable[i].Index ) {
                (*FuncTable[i].FuncPtr) = NULL;
                continue;
            }

            FuncName = (LPSTR)ULongToPtr(FuncTable[i].Index);
        }

        Error = NO_ERROR;

        (*FuncTable[i].FuncPtr) = GetProcAddress(hJet, FuncName);

        if( NULL == FuncTable[i].FuncPtr ) {
            Error = GetLastError();

            if( LoadJet97 == JetVersion ) {
                (*FuncTable[i].FuncPtr) = GetProcAddress(
                    hJet, FuncTable[i].AltName );
                if( NULL != FuncTable[i].FuncPtr ) continue;

                Error = GetLastError();
            }
        }

        if(Error) DebugLog(Winnt32LogError, MSGERR_GETPROCADDR, Error, FuncTable[i].FuncNameW );
        if( NO_ERROR != Error ) break;
    }

    //
    // if erred out, cleanup
    //

    if( NO_ERROR != Error ) {
        FreeLibrary( hJet );
        hJet = NULL;
    }

    return Error;
}

DWORD
SetJetParams(
    IN DWORD JetVersion,
    IN LPSTR DbName,
    IN LPSTR DbPath
    )
{
    DWORD Error, JetParam;
    CHAR Temp[2048];
    LPSTR DbSysFile = "\\system.mdb";
    LPSTR DbBaseName = "j50";

    Temp[ 0 ] = '\0';
    JetInstance = 0;

    if ( strlen( DbPath ) < 2048 )
        strcpy(Temp, DbPath);

    if( LoadJet200 == JetVersion ) {
        strcat(Temp, DbSysFile);
        JetParam = JET_paramSysDbPath_OLD;
    } else {
        strcat(Temp, "\\");
        if( LoadJet97 != JetVersion ) {
            JetParam = JET_paramSystemPath_OLD;
        } else {
            JetParam = JET_paramSystemPath;
        }
    }

    Error = JetSetSystemParameter(
        &JetInstance, (JET_SESID)0, JetParam, 0, Temp );

    if(Error)DebugLog(Winnt32LogError, MSGERR_SETDBPARAM, Error, JetParam );
    if( NO_ERROR != Error ) return Error;

    if( LoadJet200 != JetVersion ) {
        if( LoadJet97 != JetVersion ) {
            JetParam = JET_paramBaseName_OLD;
        } else {
            JetParam = JET_paramBaseName;
        }

        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JetParam, 0, DbBaseName  );

        if(Error)DebugLog(Winnt32LogError, MSGERR_SETDBPARAM, Error, JetParam );
        if( NO_ERROR != Error ) return Error;
    }

    if( LoadJet200 != JetVersion ) {
        if( LoadJet97 == JetVersion ) {
            JetParam = JET_paramLogFileSize;
        } else {
            JetParam = JET_paramLogFileSize_OLD;
        }

        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JetParam, 1000, NULL );
        if(Error) DebugLog(Winnt32LogError, MSGERR_SETDBPARAM, Error,
                           JetParam );
        if( NO_ERROR != Error ) return Error;
    }

    if( LoadJet200 != JetVersion ) {
        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0,
            JET_paramCheckFormatWhenOpenFail, 1, NULL );
        LogError(SetJetParams, OpenFail );

        JetParam = JET_paramCheckFormatWhenOpenFail;
        if(Error)DebugLog(Winnt32LogError, MSGERR_SETDBPARAM, Error, JetParam );
        if( NO_ERROR != Error ) return Error;
    }

    if( LoadJet200 != JetVersion ) {
        if( LoadJet97 != JetVersion ) {
            JetParam = JET_paramRecovery_OLD;
        } else {
            JetParam = JET_paramRecovery;
        }

        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JetParam, 0, "on");

        if(Error)DebugLog(Winnt32LogError, MSGERR_SETDBPARAM, Error, JetParam );
        if( NO_ERROR != Error ) return Error;
    }

    //
    // Note: Ideally, the log files should never exist.  Even
    // if the database is opened in readonly mode, they seem to
    // exist.  Not sure what else can be done
    //

    if( LoadJet97 == JetVersion ) {
        JetParam = JET_paramLogFilePath;
    } else {
        JetParam = JET_paramLogFilePath_OLD;
    }

    strcpy(Temp, DbPath); strcat( Temp, "\\");

    Error = JetSetSystemParameter(
        &JetInstance, (JET_SESID)0, JetParam, 0, Temp );
    if(Error)DebugLog(Winnt32LogError, MSGERR_SETDBPARAM, Error, JetParam );

    return Error;
}

DWORD
OpenDatabase(
    IN DWORD JetVersion,
    IN LPSTR DbName,
    IN LPSTR DbPath
    )
{
    LONG Error;
    DWORD i;
    CHAR FilePath[2048];
    JET_INDEXLIST TmpIdxList;

    JetSession = 0;
    JetDb = 0;
    JetTbl = 0;
    MadcapTbl = 0;

    FilePath[ 0 ] = '\0';

    Error = JetInit( &JetInstance );

    if(Error) DebugLog(Winnt32LogError, MSGERR_JETINIT, Error );
    if( NO_ERROR != Error ) return Error;

    Error = JetBeginSession(
        JetInstance, &JetSession, "admin", "" );

    if(Error) DebugLog(Winnt32LogError, MSGERR_JETBEGINSESSION, Error );
    if( Error < 0 ) return Error;

    if ( ( strlen( DbPath ) + strlen( DbName ) + 2 ) < 2048 )
    {
        strcpy(FilePath, DbPath );
        strcat(FilePath, "\\" );
        strcat(FilePath, DbName );
    }

    Error = JetDetachDatabase( JetSession, NULL );

    if(Error) DebugLog(Winnt32LogError, MSGERR_JETDETACHDB, Error );
    if( Error < 0 ) return Error;

    Error = JetAttachDatabase( JetSession, FilePath, JET_bitDbRecoveryOff );

    if(Error) DebugLog(Winnt32LogError, MSGERR_JETATTACHDB, Error );
    if( Error < 0 ) return Error;

    Error = JetOpenDatabase(
        JetSession, FilePath, NULL, &JetDb,
        JET_bitDbSingleExclusive | JET_bitDbReadOnly );

    if(Error) DebugLog(Winnt32LogError, MSGERR_JETOPENDB, Error );
    if( Error < 0 ) return Error;

    // Open DHCP lease table

    Error = JetOpenTable(
        JetSession, JetDb, (LPSTR)"ClientTable",
        NULL, 0, JET_bitTableReadOnly,&JetTbl );

    if(Error) DebugLog(Winnt32LogError, MSGERR_JETOPENTABLE, Error );
    if( Error < 0 ) return Error;

    for( i = 0; i < sizeof(ClientTable)/sizeof(ClientTable[0]); i ++ ) {
        JET_COLUMNDEF ColDef;

        Error = JetGetTableColumnInfo(
            JetSession, JetTbl, ClientTable[i].ColName, &ColDef,
            sizeof(ColDef), 0 );

        if(Error && JET_errColumnNotFound != Error ) {
            DebugLog(Winnt32LogError, MSGERR_JETGETCOL, Error );
        }

        if( Error < 0 ) {
            if( JET_errColumnNotFound == Error ) {
                ClientTable[i].fPresent = FALSE;
                continue;
            } else {
                return Error;
            }
        }

        if( ColDef.coltyp != ClientTable[i].ColType ) {
            ASSERT( FALSE );
            Error = ERROR_BAD_FORMAT;
            return Error;
        }

        ClientTable[i].ColHandle = ColDef.columnid;
    }

    // Open MADCAP lease table

    Error = JetOpenTable(
        JetSession, JetDb, (LPSTR)"MCastClientTableVer3",
        NULL, 0, JET_bitTableReadOnly, &MadcapTbl );
    if( JET_errObjectNotFound == Error ) {
        Error = NO_ERROR;
    } else {
        if(Error) DebugLog(Winnt32LogError, MSGERR_JETOPENMTABLE, Error );
        if( Error < 0 ) return Error;

        for( i = 0; i < sizeof(MadcapClientTable)/sizeof(MadcapClientTable[0]); i ++ ) {
            JET_COLUMNDEF ColDef;

            Error = JetGetTableColumnInfo(
                JetSession, MadcapTbl, MadcapClientTable[i].ColName, &ColDef,
                sizeof(ColDef), 0 );

            if(Error && Error != JET_errColumnNotFound) {
                DebugLog(Winnt32LogError, MSGERR_JETGETMCOL, Error );
            }

            if( Error < 0 ) {
                if( JET_errColumnNotFound == Error ) {
                    MadcapClientTable[i].fPresent = FALSE;
                    continue;
                } else {
                    return Error;
                }
            }

            if( ColDef.coltyp != MadcapClientTable[i].ColType ) {
                ASSERT( FALSE );
                Error = ERROR_BAD_FORMAT;
                return Error;
            }

            MadcapClientTable[i].ColHandle = ColDef.columnid;
        }
    }

    return NO_ERROR;
}

DWORD
LoadAndInitializeDatabase(
    IN DWORD JetVersion,
    IN LPSTR DbName,
    IN LPSTR DbPath
    )
{
    DWORD Error;

    //
    // Attempt to load DLL and retrieve function pointers
    //

    DebugLog(Winnt32LogInformation, MSGERR_INITDB, JetVersion );

    Error = LoadAndLinkRoutines( JetVersion );
    if( NO_ERROR != Error ) return Error;

    //
    // set standard jet params
    //

    Error = SetJetParams( JetVersion, DbName, DbPath );
    if( NO_ERROR != Error ) {
        FreeLibrary( hJet ); hJet = NULL;
        return Error;
    }

    //
    // Attempt to open database
    //

    Error = OpenDatabase( JetVersion, DbName, DbPath );
    if( NO_ERROR != Error ) {
        CleanupDatabase();
        return Error;
    }

    return NO_ERROR;
}

DWORD
LoadAndLinkSecurityRoutines(
    OUT FARPROC *pGetInfo,
    OUT FARPROC *pSetInfo
    )
{
    HMODULE hAdvapi32;

    hAdvapi32 = GetModuleHandle(TEXT("ADVAPI32.DLL"));
    if( NULL == hAdvapi32 ) return GetLastError();

    (*pGetInfo) = GetProcAddress(hAdvapi32, "GetNamedSecurityInfoA");
    if( NULL == *pGetInfo ) return GetLastError();

    (*pSetInfo) = GetProcAddress(hAdvapi32, "SetNamedSecurityInfoA");
    if( NULL == *pSetInfo ) return GetLastError();

    return NO_ERROR;
}

DWORD
ConvertPermissionsOnDbFiles(
    VOID
    )
{
    DWORD Error, dwVersion = GetVersion();
    PSECURITY_DESCRIPTOR pSec;
    PACL pAcl;
    HANDLE hSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAA FileData;
    CHAR FileName[1024];
    FARPROC pGetInfo, pSetInfo;
    CHAR DriversDirPath[MAX_PATH *2 +1];
    DWORD PathLen = sizeof(DriversDirPath)-1;

    //
    // Check if version is atleast NT5.
    //

    dwVersion =  (DWORD)(LOBYTE(LOWORD(dwVersion)));
    if( dwVersion < 5 ) return NO_ERROR;

    //
    // First get the requried function pointers..
    //

    Error = LoadAndLinkSecurityRoutines(
        &pGetInfo, &pSetInfo );
    if( NO_ERROR != Error ) return Error;

    ZeroMemory(DriversDirPath, PathLen+1);
    PathLen = ExpandEnvironmentStringsA(
        "%SystemRoot%\\system32\\drivers", DriversDirPath, PathLen );
    if( PathLen == 0 ) {
        Error = GetLastError();
        return Error;
    }

    pSec = NULL;
    pAcl = NULL;
    Error = (DWORD)pGetInfo(
        "MACHINE\\SYSTEM\\CurrentControlSet\\Services\\DHCPServer",
        SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL,
        &pAcl, NULL, &pSec );

    if( NO_ERROR != Error ) return Error;

    Error = (DWORD)pSetInfo(
        DatabasePath, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION,
        NULL, NULL, pAcl, NULL );
    if( NO_ERROR != Error ) return Error;

    strcpy(FileName, DatabasePath);
    if( FileName[strlen(FileName)-1] != '\\' ) {
        strcat(FileName, "\\");
    }
    strcat(FileName, DatabaseName);

    Error = (DWORD)pSetInfo(
        FileName, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION,
        NULL, NULL, pAcl, NULL );
    if( NO_ERROR != Error ) goto Cleanup;

    //
    // Now for all files matching "*.log", repeat above operation
    //

    strcpy(FileName, DatabasePath);
    if( FileName[strlen(FileName)-1] != '\\' ) {
        strcat(FileName, "\\");
    }
    strcat(FileName, "*.*");

    hSearch = FindFirstFileA( FileName, &FileData );
    if( INVALID_HANDLE_VALUE == hSearch ) {
        Error = GetLastError();
        goto Cleanup;
    }

    do {

        if( 0 != strcmp(FileData.cFileName, ".") &&
            0 != strcmp(FileData.cFileName, "..") ) {
            strcpy(FileName, DatabasePath);
            if( FileName[strlen(FileName)-1] != '\\' ) {
                strcat(FileName, "\\");
            }
            strcat(FileName, FileData.cFileName);

            Error = (DWORD)pSetInfo(
                FileName, SE_FILE_OBJECT,
                DACL_SECURITY_INFORMATION, NULL, NULL, pAcl, NULL );
            if( NO_ERROR != Error ) break;
        }

        Error = FindNextFileA( hSearch, &FileData );
        if( FALSE != Error ) Error = NO_ERROR;
        else Error = GetLastError();

    } while( NO_ERROR == Error );

    FindClose( hSearch );

 Cleanup:

    LocalFree( pSec );

    if( ERROR_FILE_NOT_FOUND == Error ) return NO_ERROR;
    if( ERROR_NO_MORE_FILES == Error ) return NO_ERROR;
    return Error;
}

DWORD
InitializeDatabase(
    VOID
    )
{
    DWORD Error;

    Error = ReadRegistry();
    if(Error) DebugLog(Winnt32LogError, MSGERR_REGISTRY, Error );
    if( NO_ERROR != Error ) return Error;

    // Do not set the ACLs on %SystemRoot%\\system32\\dhcp
//      Error = ConvertPermissionsOnDbFiles();
//      if(Error) DebugLog(Winnt32LogError, MSGERR_CHANGEPERMS, Error );

    // ignore error and try best effort

    if( FALSE == SetCurrentDirectoryA(DatabasePath) ) {
        Error = GetLastError();
        if( ERROR_FILE_NOT_FOUND == Error ||
            ERROR_PATH_NOT_FOUND == Error ) {
            return ERROR_SERVICE_DOES_NOT_EXIST;
        }

        return Error;
    }

    Error = LoadAndInitializeDatabase(
        LoadJet97, (LPSTR)DatabaseName, (LPSTR)DatabasePath );

    if(Error) DebugLog( Winnt32LogInformation, MSGERR_LOADESE, Error );
    if( NO_ERROR == Error ) return NO_ERROR;

    Error = LoadAndInitializeDatabase(
        LoadJet500, (LPSTR)DatabaseName, (LPSTR)DatabasePath );

    if(Error) DebugLog( Winnt32LogInformation, MSGERR_LOAD500, Error );
    if( NO_ERROR == Error ) return NO_ERROR;

    Error = LoadAndInitializeDatabase(
        LoadJet200, (LPSTR)DatabaseName, (LPSTR)DatabasePath );

    if(Error) DebugLog( Winnt32LogInformation, MSGERR_LOAD200, Error );
    return Error;
}

DWORD
GetColumnValue(
    IN DWORD Index,
    IN LPSTR Buffer,
    IN OUT ULONG *BufSize
    )
{
    JET_ERR Error = NO_ERROR;
    DWORD Size;

    if( ClientTable[Index].fPresent == FALSE ) {
        (*BufSize) = 0;
        return NO_ERROR;
    }

    Error = JetRetrieveColumn(
        JetSession, JetTbl, ClientTable[Index].ColHandle, Buffer,
        *BufSize, &Size, 0, NULL );

    if( JET_errColumnNotFound == Error ) {
        Error = NO_ERROR;
        Size = 0;
    }

    if(Error) DebugLog( Winnt32LogWarning, MSGERR_GETCOL, Error, Index);
    if( Error < 0 ) return Error;

    (*BufSize) = Size;
    return NO_ERROR;
}

DWORD
GetMadcapColumnValue(
    IN DWORD Index,
    IN LPSTR Buffer,
    IN OUT ULONG *BufSize
    )
{
    JET_ERR Error = NO_ERROR;
    DWORD Size;

    if( ClientTable[Index].fPresent == FALSE ) {
        (*BufSize) = 0;
        return NO_ERROR;
    }

    Error = JetRetrieveColumn(
        JetSession, MadcapTbl,
        MadcapClientTable[Index].ColHandle, Buffer,
        *BufSize, &Size, 0, NULL );

    if( JET_errColumnNotFound == Error ) {
        Error = NO_ERROR;
        Size = 0;
    }

    if(Error) DebugLog( Winnt32LogWarning, MSGERR_GETMCOL, Error, Index);
    if( Error < 0 ) return Error;

    (*BufSize) = Size;
    return NO_ERROR;
}

#define CLIENT_TYPE_UNSPECIFIED     0x0 // for backward compatibility
#define CLIENT_TYPE_DHCP            0x1
#define CLIENT_TYPE_BOOTP           0x2
#define CLIENT_TYPE_BOTH    ( CLIENT_TYPE_DHCP | CLIENT_TYPE_BOOTP )

#define ADDRESS_STATE_OFFERED 0
#define ADDRESS_STATE_ACTIVE 1
#define ADDRESS_STATE_DECLINED 2
#define ADDRESS_STATE_DOOM 3
#define ADDRESS_BIT_DELETED  0x80
#define ADDRESS_BIT_UNREGISTERED 0x40
#define ADDRESS_BIT_BOTH_REC 0x20
#define ADDRESS_BIT_CLEANUP 0x10
#define ADDRESS_BITS_MASK 0xF0

DWORD
AddRecord(
    IN LPSTR Buffer,
    IN ULONG BufSize
    );

DWORD
AddScannedClient(
    IN DWORD IpAddressNetOrder,
    IN DWORD SubnetMaskNetOrder,
    IN LPBYTE HwAddr,
    IN ULONG HwLen,
    IN LPWSTR MachineName,
    IN LPWSTR MachineInfo,
    IN ULONGLONG ExpirationFileTime,
    IN BYTE State,
    IN BYTE ClientType
    )
{
    DWORD i;
    CHAR Buffer[1024];
    ULONG Length, Size;

    Length = 0;
    Buffer[Length++] = (BYTE)RecordTypeDbEntry;

    CopyMemory(
        &Buffer[Length], (PVOID)&IpAddressNetOrder, sizeof(DWORD) );
    Length += sizeof(DWORD);

    CopyMemory(
        &Buffer[Length], (PVOID)&SubnetMaskNetOrder, sizeof(DWORD) );
    Length += sizeof(DWORD);

    Buffer[Length++] = (BYTE)HwLen;
    CopyMemory(&Buffer[Length], HwAddr, HwLen );
    Length += HwLen;

    if( NULL == MachineName || 0 == *MachineName ) Size = 0;
    else Size = sizeof(WCHAR)*(1+wcslen(MachineName));

    CopyMemory(&Buffer[Length], (PVOID)&Size, sizeof(DWORD));
    Length += sizeof(DWORD);
    if ( NULL != MachineName ) {
        CopyMemory(&Buffer[Length], (PVOID)MachineName, Size );
        Length += Size;
    }

    if( NULL == MachineInfo || 0 == *MachineInfo ) Size = 0;
    else Size = sizeof(WCHAR)*(1+wcslen(MachineInfo));

    CopyMemory(&Buffer[Length], (PVOID)&Size, sizeof(DWORD));
    Length += sizeof(DWORD);
    if ( NULL != MachineInfo ) {
        CopyMemory(&Buffer[Length], (PVOID)MachineInfo, Size );
        Length += Size;
    }

    CopyMemory(&Buffer[Length], (PVOID)&ExpirationFileTime, sizeof(ULONGLONG));
    Length += sizeof(ULONGLONG);
    Buffer[Length++] = State;
    Buffer[Length++] = ClientType;

    return AddRecord( Buffer, Length );
}

DWORD
AddScannedMadcapClient(
    IN DWORD IpAddressNetOrder,
    IN DWORD ScopeIdNetOrder,
    IN LPBYTE ClientId,
    IN ULONG HwLen,
    IN LPWSTR MachineInfo,
    IN ULONGLONG ExpirationFileTime,
    IN ULONGLONG StartFileTime,
    IN BYTE State
    )
{
    DWORD i;
    CHAR Buffer[1024];
    ULONG Length, Size;

    Length = 0;
    Buffer[Length++] = (BYTE)RecordTypeMcastDbEntry;

    CopyMemory(
        &Buffer[Length], (PVOID)&IpAddressNetOrder, sizeof(DWORD) );
    Length += sizeof(DWORD);

    CopyMemory(
        &Buffer[Length], (PVOID)&ScopeIdNetOrder, sizeof(DWORD) );
    Length += sizeof(DWORD);

    Buffer[Length++] = (BYTE)HwLen;
    CopyMemory(&Buffer[Length], ClientId, (BYTE)HwLen );
    Length += (BYTE)HwLen;

    if( NULL == MachineInfo || 0 == *MachineInfo ) Size = 0;
    else Size = sizeof(WCHAR)*(1+wcslen(MachineInfo));

    CopyMemory(&Buffer[Length], (PVOID)&Size, sizeof(DWORD));
    Length += sizeof(DWORD);
    if ( NULL != MachineInfo ) {
        CopyMemory(&Buffer[Length], (PVOID)MachineInfo, Size );
        Length += Size;
    }

    CopyMemory(&Buffer[Length], (PVOID)&ExpirationFileTime, sizeof(ULONGLONG));
    Length += sizeof(ULONGLONG);

    CopyMemory(&Buffer[Length], (PVOID)&StartFileTime, sizeof(ULONGLONG));
    Length += sizeof(ULONGLONG);

    Buffer[Length++] = State;

    return AddRecord( Buffer, Length );
}


DWORD static
ScanDatabase(
    VOID
    )
{
    LONG Error;
    DWORD Count;

    Error = JetSetCurrentIndex(
        JetSession, JetTbl, NULL );

    if( Error ) DebugLog(Winnt32LogError, MSGERR_SETINDEX, Error );
    if( Error < 0 ) return Error;

    Error = JetMove( JetSession, JetTbl, JET_MoveFirst, 0 );

    for( Count = 0 ; Error >= 0 ; Count ++,
         Error = JetMove(JetSession, JetTbl, JET_MoveNext, 0) ) {

        DWORD IpAddress, SubnetMask, Size, HwLen;
        FILETIME Expiration;
        CHAR HwAddress[256];
        WCHAR MachineName[300], MachineInfo[300];
        BYTE Type, State;

        //
        // Get current client's info.
        //

        Size = sizeof(IpAddress);
        Error = GetColumnValue(
            IPADDRESS_INDEX, (PVOID)&IpAddress, &Size );

        if( NO_ERROR != Error ) break;
        if( Size != sizeof(IpAddress) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDIP );
            continue;
        }

        Size = sizeof(SubnetMask);
        Error = GetColumnValue(
            SUBNET_MASK_INDEX, (PVOID)&SubnetMask, &Size );

        if( NO_ERROR != Error ) break;
        if( Size != sizeof(SubnetMask) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDMASK );
            continue;
        }

        HwLen = sizeof(HwAddress);
        Error = GetColumnValue(
            HARDWARE_ADDRESS_INDEX, (PVOID)HwAddress, &HwLen );
        if( NO_ERROR != Error ) break;

        Size = sizeof(MachineName);
        Error = GetColumnValue(
            MACHINE_NAME_INDEX, (PVOID)MachineName, &Size );
        if( NO_ERROR != Error ) break;

        if( (Size % 2) != 0 ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDNAME );
            continue;
        }

        MachineName[Size/2] = L'\0';

        Size = sizeof(MachineInfo);
        Error = GetColumnValue(
            MACHINE_INFO_INDEX, (PVOID)MachineInfo, &Size );
        if( NO_ERROR != Error ) break;

        if( (Size % 2) != 0 ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDINFO );
            continue;
        }

        MachineInfo[Size/2] = L'\0';

        Size = sizeof(Expiration);
        Error = GetColumnValue(
            LEASE_TERMINATE_INDEX, (PVOID)&Expiration, &Size );
        if( NO_ERROR != Error ) break;

        if( Size != sizeof(Expiration) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDEXPIRATION );
            Error = ERROR_INVALID_DATA;
            break;
        }

        Size = sizeof(Type);
        Error = GetColumnValue(
            CLIENT_TYPE_INDEX, (PVOID)&Type, &Size );

        if( NO_ERROR != Error || 0 == Size ) {
            Type = CLIENT_TYPE_DHCP;
        }

        Size = sizeof(State);
        Error = GetColumnValue(
            STATE_INDEX, (PVOID)&State, &Size );

        if( NO_ERROR != Error || 0 == Size ) {
            State = ADDRESS_STATE_ACTIVE;
        }

        if( ADDRESS_STATE_OFFERED == State ) {
            continue;
        }

        //
        // Try to add the client
        //

        Error = AddScannedClient(
            ByteSwap(IpAddress), ByteSwap(SubnetMask), HwAddress, HwLen,
            MachineName, MachineInfo, *(PULONGLONG)&Expiration,
            State, Type );

        if( NO_ERROR != Error ) break;
    }

    DebugLog( Winnt32LogInformation, MSGERR_SCANCOUNT, Count );

    if( JET_errNoCurrentRecord == Error ) return NO_ERROR;
    if( Error < 0 ) return Error;
    return NO_ERROR;
} // ScanDatabase()

DWORD
ScanMadcapDatabase(
    VOID
    )
{
    LONG Error;
    DWORD Count;

    if( 0 == MadcapTbl ) return NO_ERROR;

    Error = JetSetCurrentIndex(
        JetSession, MadcapTbl, NULL );

    if( Error ) DebugLog(Winnt32LogError, MSGERR_SETMINDEX, Error );
    if( Error < 0 ) return Error;

    Error = JetMove( JetSession, MadcapTbl, JET_MoveFirst, 0 );

    for( Count = 0 ; Error >= 0 ; Count ++,
         Error = JetMove(JetSession, MadcapTbl, JET_MoveNext, 0) ) {

        DWORD IpAddress, ScopeId, Size, HwLen;
        FILETIME Expiration, Start;
        CHAR ClientId[300];
        WCHAR ClientInfo[300], MachineInfo[300];
        BYTE State;

        //
        // Get current client's info.
        //

        Size = sizeof(IpAddress);
        Error = GetMadcapColumnValue(
            MCAST_TBL_IPADDRESS, (PVOID)&IpAddress, &Size );

        if( NO_ERROR != Error ) break;
        if( Size != sizeof(IpAddress) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDMIP );
            continue;
        }

        Size = sizeof(ScopeId);
        Error = GetMadcapColumnValue(
            MCAST_TBL_SCOPE_ID, (PVOID)&ScopeId, &Size );

        if( NO_ERROR != Error ) break;
        if( Size != sizeof( ScopeId ) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDSCOPEID);
            continue;
        }

        HwLen = sizeof(ClientId);
        Error = GetMadcapColumnValue(
            MCAST_TBL_CLIENT_ID, (PVOID)ClientId, &HwLen );
        if( NO_ERROR != Error ) break;


        Size = sizeof(MachineInfo);
        Error = GetMadcapColumnValue(
            MCAST_TBL_CLIENT_INFO, (PVOID)MachineInfo, &Size );
        if( NO_ERROR != Error ) break;

        if( (Size % 2) != 0 ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDINFO );
            continue;
        }

        MachineInfo[Size/2] = L'\0';
        Size = sizeof(Expiration);
        Error = GetMadcapColumnValue(
            MCAST_TBL_LEASE_END, (PVOID)&Expiration, &Size );
        if( NO_ERROR != Error ) break;

        if( Size != sizeof(Expiration) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDMEXPIRATION );
            Error = ERROR_INVALID_DATA;
            break;
        }


        Size = sizeof(Start);
        Error = GetMadcapColumnValue(
            MCAST_TBL_LEASE_START, (PVOID)&Start, &Size );
        LogError( ScanMadcapDatabase, GetLeaseExpiration );
        if( NO_ERROR != Error ) break;

        if( Size != sizeof(Start) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDMSTART );
            Error = ERROR_INVALID_DATA;
            break;
        }


        Size = sizeof(State);
        Error = GetMadcapColumnValue(
            MCAST_TBL_STATE, (PVOID)&State, &Size );
        if( NO_ERROR != Error ) break;

        //
        // Try to add the client
        //

        Error = AddScannedMadcapClient(
            ByteSwap(IpAddress), ByteSwap(ScopeId), ClientId, HwLen,
            MachineInfo, *(PULONGLONG)&Expiration,
            *(PULONGLONG)&Start, State );
        if( NO_ERROR != Error ) break;
    }

    DebugLog( Winnt32LogInformation, MSGERR_SCANMCOUNT, Count );

    if( JET_errNoCurrentRecord == Error ) return NO_ERROR;
    if( Error < 0 ) return Error;
    return NO_ERROR;
}

DWORD
DumpData(
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    return NO_ERROR;
}

DWORD
AddRecord(
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    DWORD Written = 0;
    DWORD RecSize = BufSize;

    ASSERT( NULL != Buffer );
    // Write the buffer size
    if ( FALSE == WriteFile( hTextFile, &RecSize, sizeof( RecSize ),
                             &Written, NULL )) {
        return GetLastError();
    }
    if ( Written != sizeof( RecSize )) {
            return ERROR_CAN_NOT_COMPLETE;
    }

    if ( FALSE == WriteFile( hTextFile, Buffer, BufSize,
                             &Written, NULL )) {
        return GetLastError();
    }

    if ( Written != BufSize ) {
            return ERROR_CAN_NOT_COMPLETE;
    }

    return ERROR_SUCCESS;
} // AddRecord()

DWORD
OpenTextFile(
    BOOL fRead
    )
{
    CHAR FileName[4096];
    DWORD Error, Flags;

    strcpy(FileName, DatabasePath);
    if( DatabasePath[strlen(DatabasePath)-1] != '\\' ) {
        strcat(FileName, "\\dhcpdb.txt" );
    } else {
        strcat(FileName, "dhcpdb.txt");
    }

    Flags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN;

    hTextFile = CreateFileA(
        FileName, GENERIC_READ | GENERIC_WRITE | DELETE,
        FILE_SHARE_READ, NULL,
        fRead ? OPEN_EXISTING : CREATE_ALWAYS,
        Flags, NULL );

    if( hTextFile == INVALID_HANDLE_VALUE ) {
        hTextFile = NULL;
        Error = GetLastError();
        if( !fRead || ERROR_FILE_NOT_FOUND != Error ) {
            DebugLog( Winnt32LogError, MSGERR_CREATE_FILE_FAILED, Error);
        }
        return Error;
    }

    if( !fRead ) return NO_ERROR;

    LoSize = GetFileSize( hTextFile, &HiSize );
    if( -1 == LoSize && NO_ERROR != GetLastError() ) {
        return GetLastError();
    }

    if( LoSize == 0 && HiSize == 0 ) return NO_ERROR;

    hMapping = CreateFileMapping(
        hTextFile, NULL, PAGE_READONLY | SEC_COMMIT, HiSize, LoSize,
        NULL );
    if( NULL == hMapping ) {
        Error = GetLastError();
        DebugLog( Winnt32LogError, MSGERR_CREATE_MAP, Error );
        return Error;
    }

    FileView = MapViewOfFile(
        hMapping, FILE_MAP_READ, 0, 0, 0 );

    if( NULL == FileView ) {
        Error = GetLastError();
        DebugLog( Winnt32LogError, MSGERR_CREATE_VIEW, Error );
        return Error;
    }

    return NO_ERROR;
}

DWORD
StopDhcpService(
    VOID
    )
{
    SC_HANDLE hSc, hSvc;
    DWORD Error;

    Error = NO_ERROR;
    hSc = NULL;
    hSvc = NULL;

    do {
        hSc = OpenSCManager(
            NULL, NULL, SC_MANAGER_CONNECT | GENERIC_WRITE | GENERIC_WRITE );
        if( NULL == hSc ) {
            Error = GetLastError();

            DebugLog( Winnt32LogError, MSGERR_OPENSCM, Error );
            break;
        }

        hSvc = OpenService(
            hSc, TEXT("DHCPServer"), SERVICE_STOP| SERVICE_QUERY_STATUS );
        if( NULL == hSvc ) {
            Error = GetLastError();

            DebugLog( Winnt32LogError, MSGERR_OPENSVC, Error );
            break;
        }

        while( NO_ERROR == Error ) {
            SERVICE_STATUS Status;

            if( FALSE == QueryServiceStatus( hSvc, &Status ) ) {
                Error = GetLastError();
                DebugLog( Winnt32LogError, MSGERR_SVCQUERY, Error );
                break;
            }

            if( Status.dwCurrentState == SERVICE_STOPPED ) break;
            if( Status.dwCurrentState != SERVICE_RUNNING &&
                Status.dwCurrentState != SERVICE_PAUSED ) {
                DebugLog( Winnt32LogInformation, MSGERR_SVCWAIT,
                          Status.dwCurrentState );

                if( Status.dwWaitHint < 1000 ) {
                    Status.dwWaitHint = 1000;
                }

                Sleep(Status.dwWaitHint);
            } else {
                Error = ControlService(
                    hSvc, SERVICE_CONTROL_STOP, &Status );
                if( FALSE != Error ) Error = NO_ERROR;
                else {
                    Error = GetLastError();
                    DebugLog( Winnt32LogError, MSGERR_SVCCTRL, Error );
                    break;
                }
            }
        }
    } while( 0 );

    if( NO_ERROR == Error ) {
        DebugLog( Winnt32LogInformation, MSGERR_SVCSTOP_SUCCESS );
    }

    if( NULL != hSvc ) CloseServiceHandle( hSvc );
    if( NULL != hSc ) CloseServiceHandle( hSc );

    return Error;
}

BOOL
UpgradeNotNeeded(
    VOID
    )
{
    HKEY hKey;
    DWORD Error, Type, Value, Size;


    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_READ, &hKey );

    if( NO_ERROR != Error ) return FALSE;

    Type = REG_DWORD; Value = 0; Size = sizeof(Value);
    Error = RegQueryValueEx(
        hKey, TEXT("Version"), NULL, &Type, (PVOID)&Value, &Size );

    RegCloseKey( hKey );

    //
    // if this value is not present, then upgrade is needed
    //

    return (Error == NO_ERROR );
}

DWORD __stdcall
DhcpUpgConvertDhcpDbToTemp(
    VOID
    )
{
    DWORD Error;
    DWORD clusState;
    DWORD Error1 = ERROR_SUCCESS;
    GetClusterStateFn pGetClusterStateFn = NULL;
    HINSTANCE hLib;

    LastError = NO_ERROR;
    if( UpgradeNotNeeded() ) return NO_ERROR;

    Error = GetCurrentDirectoryW(
        sizeof(Winnt32Path)/sizeof(WCHAR), Winnt32Path );
    if( 0 != Error ) {
        Error = NO_ERROR;
    } else {
        Error = GetLastError();
        return Error;
    }

    Error = NO_ERROR;

    StartDebug();
    DebugLog( Winnt32LogInformation, MSGERR_STARTLOG );

    do {
        Error = StopDhcpService();
        if( NO_ERROR != Error ) break;

        Error = InitializeDatabase();
        if( NO_ERROR != Error ) break;

        Error = OpenTextFile(FALSE);
        if( NO_ERROR != Error ) break;

        Error = ScanDatabase();
        if( NO_ERROR != Error ) break;

        Error = ScanMadcapDatabase();
        if( NO_ERROR != Error ) break;

    } while( 0 );

    CleanupDatabase();

    if( NULL != hTextFile ) CloseHandle( hTextFile );
    hTextFile = NULL;


    //
    // if the error code is ERROR_BUSY, it could be a cluster node
    // that doesnt have access to the db. Check if this is the case.
    //

    if ( ERROR_BUSY == Error )
    {

        hLib = LoadLibrary( L"clusapi.dll" );

        if ( hLib != NULL )
        {
            pGetClusterStateFn = (GetClusterStateFn)GetProcAddress( hLib, "GetNodeClusterState" );

        }

        if ( pGetClusterStateFn != NULL )
        {
            Error1 = pGetClusterStateFn( NULL, &clusState );

            if ( Error1 == ERROR_SUCCESS )
            {
                 if ( ( clusState & ClusterStateNotRunning ) ||
                      ( clusState & ClusterStateRunning ) )
                {

                    //
                    // the error code remains the same if the above
                    // condition is not met.
                    //

                    Error = ERROR_SUCCESS;
                }
            }
         }

        if ( hLib != NULL )
        {
            FreeLibrary( hLib );
        }

    }

    //
    // If the service never existed, not much to do
    //

    if( ERROR_SERVICE_DOES_NOT_EXIST == Error ) Error = NO_ERROR;

    if( NO_ERROR != Error ) {
        DebugLog( Winnt32LogError, MSGERR_CONVERT_FAILED, Error );
    } else {
        DebugLog( Winnt32LogInformation, MSGERR_CONVERT_SUCCEEDED );
    }

    CloseDebugLog();

    if( FALSE == SetCurrentDirectoryW(Winnt32Path) ) {
        if( NO_ERROR == Error ) Error = GetLastError();
    }

    LastError = Error;
    return NO_ERROR;
}


VOID
DeleteDatabaseTempFile(
    VOID
    )
{
    CHAR FileName[4096];
    DWORD Error;

    //
    // Attempt to delete the temporary database stuff
    //


    strcpy(FileName, DatabasePath);
    if( DatabasePath[strlen(DatabasePath)-1] != '\\' ) {
        strcat(FileName, "\\dhcpdb.txt" );
    } else {
        strcat(FileName, "dhcpdb.txt");
    }

    if( FALSE == DeleteFileA( FileName ) ) {
        Error = GetLastError();

        DebugLog(
            Winnt32LogError, MSGERR_DELETEFILE, Error );
    }
}

VOID
FixRegistryAndDeleteFiles(
    VOID
    )
{
    DWORD Error;
    HKEY hKey;

    //
    // Attempt to write the version key
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_WRITE, &hKey );

    if( NO_ERROR != Error ) {
        DebugLog(
            Winnt32LogError, MSGERR_OPENPARAMSKEY, Error );
    } else {
        DWORD Version = 0, Size = sizeof(Version);

        Error = RegSetValueEx(
            hKey, TEXT("Version"), 0, REG_DWORD, (PVOID)&Version,
            Size );
        if( NO_ERROR != Error ) {
            DebugLog(
                Winnt32LogError, MSGERR_SETVALUE, Error );
        }

        RegCloseKey( hKey );
    }

    DeleteDatabaseTempFile();
}

DWORD __stdcall PrintRecord(
    IN PDHCP_RECORD Recx
    )
{
    DWORD i;
    DHCP_RECORD Rec = *Recx;

    if( Rec.fMcast ) {
        printf("Mcast Record\n" );
        printf("Address: %s\n", IpAddressToString(
            Rec.Info.Mcast.Address ));
        printf("ScopeId: %s\n", IpAddressToString(
            Rec.Info.Mcast.ScopeId ));

        printf("ClientId:");
        for( i = 0 ; i < (DWORD)Rec.Info.Mcast.HwLen; i ++ ) {
            printf(" %02X", Rec.Info.Mcast.ClientId[i]);
        }
        printf("\nState = %02X\n", Rec.Info.Mcast.State);

    } else {
        printf("DHCP Record\n" );
        printf("Address: %s\n", IpAddressToString(
            Rec.Info.Dhcp.Address ));
        printf("Mask: %s\n", IpAddressToString(
            Rec.Info.Dhcp.Mask ));

        printf("ClientId:");
        for( i = 0 ; i < (DWORD)Rec.Info.Dhcp.HwLen; i ++ ) {
            printf(" %02X", Rec.Info.Dhcp.HwAddr[i]);
        }
        printf("\nState = %02X\n", Rec.Info.Dhcp.State);
        printf("\nType = %02X\n", Rec.Info.Dhcp.Type);
        if( Rec.Info.Dhcp.Name ) {
            printf("Name = %ws\n", Rec.Info.Dhcp.Name );
        }

        if( Rec.Info.Dhcp.Info ) {
            printf("Comment = %ws\n", Rec.Info.Dhcp.Info );
        }
    }

    return NO_ERROR;
} // PrintRecord()

DWORD
ProcessDbEntries(
    IN LPSTR Buffer,
    IN ULONG  BufSize,
    IN DHCP_ADD_RECORD_ROUTINE AddRec
    )
{
    DWORD RecSize, Size;
    RECORD_TYPE    DbEntry;
    LPSTR          Buf;
    DWORD          Address, i, Error;
    FILETIME       Time;
    DHCP_RECORD    Rec;

    Error = NO_ERROR;

    Buf = Buffer;

    while ( BufSize >  0 ) {
        // Get the record size
        CopyMemory( &RecSize, Buf, sizeof( DWORD ));
        ASSERT( RecSize > 0 );
        Buf += sizeof( DWORD );
        BufSize -= sizeof( DWORD );

        // Get the record type
        DbEntry = ( RECORD_TYPE ) *Buf;
        ++Buf;

        // Read the contents into the record
        ZeroMemory( &Rec, sizeof(Rec));

        switch ( DbEntry ) {
        default : {
            DebugLog( Winnt32LogError, MSGERR_INVALIDRECORDTYPE, Buf );
            return ERROR_INVALID_DATA;
        }

        case RecordTypeDbEntry : {
            Rec.fMcast = FALSE;
            // copy IP Addr
            CopyMemory( &Rec.Info.Dhcp.Address, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);

            // Copy subnet
            CopyMemory( &Rec.Info.Dhcp.Mask, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);

            // copy hw addr and size
            Size = Rec.Info.Dhcp.HwLen = *Buf;
            ++Buf;
            Rec.Info.Dhcp.HwAddr = Buf;
            Buf += Size;

            // copy machine name and size
            CopyMemory(&Size, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);
            if( Size ) {
                Rec.Info.Dhcp.Name = (PVOID)Buf;
                Buf += Size;
            }

            // copy machine info and size
            CopyMemory(&Size, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);
            if( Size ) {
                Rec.Info.Dhcp.Info = (PVOID)Buf;
                Buf += Size;
            }

            // copy expiry time
            CopyMemory(&Rec.Info.Dhcp.ExpTime, Buf, sizeof(FILETIME));
            Buf += sizeof(FILETIME);

            // copy client state and type
            Rec.Info.Dhcp.State = *Buf;
            ++Buf;
            Rec.Info.Dhcp.Type = *Buf;
            ++Buf;

            Error = AddRec( &Rec );

            break;
        } // RecordTypeDbEntry
        case RecordTypeMcastDbEntry : {
            Rec.fMcast = TRUE;

            // IP address
            CopyMemory( &Rec.Info.Mcast.Address, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);

            // Scope Id
            CopyMemory( &Rec.Info.Mcast.ScopeId, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);

            // Hardware address and size
            Size = Rec.Info.Mcast.HwLen = *Buf++;
            Rec.Info.Mcast.ClientId = Buf;
            Buf += Size;

            // Machine info and size
            CopyMemory(&Size, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);
            if( Size ) {
                Rec.Info.Mcast.Info = (PVOID)Buf;
                Buf += Size;
            }

            // Expiration time
            CopyMemory(&Rec.Info.Mcast.End, Buf, sizeof(FILETIME));
            Buf += sizeof(FILETIME);

            // Start time
            CopyMemory(&Rec.Info.Mcast.Start, Buf, sizeof(FILETIME));
            Buf += sizeof(FILETIME);

            // State
            Rec.Info.Mcast.State = *Buf++;

            Error = AddRec( &Rec );
            break;
        } // RecordTypeMcastDbEntry()
        } // switch

        // DWORD is the size of the record.
        ASSERT( BufSize >= RecSize );
        BufSize -= RecSize;
        if( NO_ERROR != Error ) return Error;
    } // while

    return NO_ERROR;
} // ProcessDbEntries()

DWORD
MoveBootpTable()
{
    LPWSTR ValueName = L"BootFileTable";
    LPWSTR OldLocation = L"SOFTWARE\\Microsoft\\DhcpServer\\Configuration\\GlobalOptionValues";
    LPWSTR NewLocation = L"SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters";
    HKEY OldKey, NewKey;
    BYTE *pValue = NULL;
    DWORD Size = 0, Error, Type;

    Error = RegOpenKey( HKEY_LOCAL_MACHINE, OldLocation, &OldKey );
    if ( ERROR_SUCCESS != Error ) {
        return Error;
    }

    Error = RegOpenKey( HKEY_LOCAL_MACHINE, NewLocation, &NewKey );
    if ( ERROR_SUCCESS != Error ) {
        RegCloseKey( OldKey );
        return Error;
    }

    do {

        // find the space needed
        Error = RegQueryValueEx( OldKey, ValueName, 0,
                                  &Type, NULL, &Size );
        if ( ERROR_SUCCESS != Error ) {
            break;
        }

        if ( REG_MULTI_SZ != Type ) {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }

        pValue = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Size );
        if ( NULL == pValue ) {
            Error =  ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        Error = RegQueryValueEx( OldKey, ValueName, 0,
                                &Type, pValue, &Size );
        if ( ERROR_SUCCESS != Error ) {
            break;
        }

        Error = RegSetValueEx( NewKey, ValueName, 0,
                                REG_MULTI_SZ, ( CONST BYTE * ) pValue, Size );
        if ( ERROR_SUCCESS != Error ) {
            break;
        }

        Error = RegDeleteValue( OldKey, ValueName );
        break;

    } while ( 0 );

    RegCloseKey( OldKey );
    RegCloseKey( NewKey );
    LocalFree( pValue );

    return Error;
} // MoveBootpTable()


DWORD __stdcall
DhcpUpgConvertTempToDhcpDb(
    IN DHCP_ADD_RECORD_ROUTINE AddRec
    )
{
    DWORD Error;

    if( UpgradeNotNeeded() ) return NO_ERROR;

    if( NULL == AddRec ) {
        //
        // If caller didn't specify, then the intention is to
        // just get us to dump.. so just print the stuff out.
        //

        AddRec = PrintRecord;
    }

    Error = NO_ERROR;

    StartDebug();
    DebugLog( Winnt32LogInformation, MSGERR_STARTLOG2 );

    do {
        Error = ReadRegistry();
        if( NO_ERROR != Error ) break;

        Error = OpenTextFile(TRUE);
        if( NO_ERROR != Error ) {
            if( ERROR_FILE_NOT_FOUND == Error ) {
                Error = NO_ERROR;
            }

            break;
        }

        //
        // Walk through the database-text and parse the fields out
        //

        Error = ProcessDbEntries(
            FileView, LoSize, AddRec
            );
        ASSERT( ERROR_SUCCESS == Error );

    } while( 0 );

    if( NULL != FileView ) UnmapViewOfFile( FileView );
    FileView = NULL;

    if( NULL != hMapping ) CloseHandle( hMapping );
    hMapping = NULL;

    if( NULL != hTextFile ) CloseHandle( hTextFile );
    hTextFile = NULL;

    if( NO_ERROR != Error ) {
        DebugLog( Winnt32LogError, MSGERR_CONVERT_FAILED, Error );
    } else {
        //
        // Whack the registry keys
        //

        MoveBootpTable();
        FixRegistryAndDeleteFiles();
        DebugLog( Winnt32LogInformation, MSGERR_CONVERT_SUCCEEDED );
    }

    CloseDebugLog();

    return Error;
}

DWORD __stdcall
DhcpUpgGetLastError(
    VOID
    )
{
    return LastError;
}

DWORD __stdcall
DhcpUpgCleanupDhcpTempFiles(
    VOID
    )
{
    DWORD Error;

    //
    // This routine is supposed to delete the special dhcp
    // database file because the operation was cancelled.
    //

    if( UpgradeNotNeeded() ) return NO_ERROR;
    StartDebug();

    Error = ReadRegistry();
    if( NO_ERROR == Error ) {

        DeleteDatabaseTempFile();
    }

    CloseDebugLog();

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dhcp\server\upgrade\upgrade.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    upgrade.h

Abstract:

    precompiled header.
    
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <windows.h>
#include <time.h>
#include <esent.h>
#include <stdio.h>
#include <winsock.h>
#include <shellapi.h>
#include <tchar.h>
#include <winsvc.h>
#include <setupapi.h>
#include <oemupgex.h>
#include <accctrl.h>
#include <msgs.h>
#include <dhcpupg.h>
#include <clusapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\autonet.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      autonet.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--
#include "precomp.h"
#include "dhcptest.h"


//$Review (nsun) Now we just print "Autonet address is in use" if autonet. 
// we don't send Dhcp broadcast.
// Maybe later we should send the Dhcp broadcast to see if the Dhcp server works or not
// for all DHCP enabled card
//-------------------------------------------------------------------------//
//######  A u t o n e t T e s t ()  #######################################//
//-------------------------------------------------------------------------//
HRESULT
AutonetTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//++
//
//  Routine Description:
//
//      Checks if we have autonet addresses on all adapters. If we do than 
//      the workstation couldn't reach a DHCP server on any adapters.
//      Potential HW or NDIS issue.
//    
//  Arguments:
//
//      None.
//
//  Return Value:
//
//      S_FALSE :   Test failed, all adapters are autoconfigure.
//      S_OK    :   Test succeeded, we found at least one non-autoconfigure.
//      other   :   error codes
//
//--
{
    PIP_ADAPTER_INFO pIpAdapterInfo;
    HRESULT         hr = S_FALSE;    // Assume that this will fail

    int i;

    PrintStatusMessage(pParams, 4, IDS_AUTONET_STATUS_MSG);

    //
    //  scan all adapters for a non-autonet address
    //

    for( i = 0; i < pResults->cNumInterfaces; i++)
    {
        pIpAdapterInfo = pResults->pArrayInterface[i].IpConfig.pAdapterInfo;
        //if this is not an active connection, skip it.
        
        if (!pResults->pArrayInterface[i].IpConfig.fActive ||
            NETCARD_DISCONNECTED == pResults->pArrayInterface[i].dwNetCardStatus)
            continue;

        if ( !pResults->pArrayInterface[i].IpConfig.fAutoconfigActive ) 
        {
            //$REVIEW (nsun) maybe we need to DhcpBroadcast(pIpAdapterInfo) here instead
            // of for the AutoNet adapters
            pResults->pArrayInterface[i].AutoNet.fAutoNet = FALSE;
            hr = S_OK;
            continue;
        }
        // Skip WAN Cards
        if ( ! strstr(pIpAdapterInfo->AdapterName,"NdisWan") ) 
            pResults->pArrayInterface[i].AutoNet.fAutoNet = TRUE;
    }

    if ( FHrOK(hr) )
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_PASS_NL);
        pResults->AutoNet.fAllAutoConfig = FALSE;
    }
    else
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_FAIL_NL);
        pResults->AutoNet.fAllAutoConfig = TRUE;
    }
    
    return hr;
} /* END OF AutonetTest() */




void AutonetGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (pParams->fVerbose || pResults->AutoNet.fAllAutoConfig)
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_AUTONET_LONG,
                             IDS_AUTONET_SHORT,
                             TRUE,
                             pResults->AutoNet.fAllAutoConfig ?
                             S_FALSE : S_OK, 0);
    }

    if(pResults->AutoNet.fAllAutoConfig)
    {
        //IDS_AUTONET_11601                  "    [FATAL] All adapters are autoconfigured!\n" 
        PrintMessage(pParams,  IDS_AUTONET_11601 );
        //IDS_AUTONET_11602                  "    The DHCP servers are unreachable. Please check cables, hubs, and taps!\n\n" 
        PrintMessage(pParams,  IDS_AUTONET_11602 );
    }
    else
    {
        if (pParams->fReallyVerbose)
            //IDS_AUTONET_11603                  "    PASS - you have at least one non-autoconfigured IP address\n" 
            PrintMessage(pParams,  IDS_AUTONET_11603 );
    }
}


void AutonetPerInterfacePrint(NETDIAG_PARAMS *pParams, 
                              NETDIAG_RESULT *pResults, 
                              INTERFACE_RESULT *pInterfaceResults)
{
    if (!pInterfaceResults->IpConfig.fActive || 
        NETCARD_DISCONNECTED == pInterfaceResults->dwNetCardStatus)
        return;

    if (pParams->fVerbose)
    {
        //IDS_AUTONET_11604                  "        Autonet results : " 
        PrintMessage(pParams, IDS_AUTONET_11604);
        if(pInterfaceResults->AutoNet.fAutoNet)
        {
            PrintMessage(pParams, IDS_GLOBAL_FAIL_NL);
            //IDS_AUTONET_11605                  "            [WARNING] AutoNet is in use. DHCP not available!\n" 
            PrintMessage(pParams, IDS_AUTONET_11605);
        }
        else
        {
            PrintMessage(pParams, IDS_GLOBAL_PASS_NL);
            if(pParams->fReallyVerbose)
                //IDS_AUTONET_11606                  "            AutoNet is not in use. \n" 
                PrintMessage(pParams, IDS_AUTONET_11606);
        }
    }
}

void AutonetCleanup(IN NETDIAG_PARAMS *pParams, IN OUT NETDIAG_RESULT *pResults)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\bindings.h ===
/*--
Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:
       
     bindings.h

Abstract:

     This file contains the includes, definitions , data structures and function prototypes
     needed for the bindings test.

Author:

     4-Aug-1998 (t-rajkup).

Revision History:

     None.
--*/

#ifndef HEADER_BINDINGS
#define HEADER_BINDINGS

#define CINTERFACE
#include <devguid.h>
#include <netcfgx.h>

//This is the CLSID used to CoCreate the object implementing INetCfg
EXTERN_C const CLSID CLSID_NetCfg = {0x5B035261,0x40F9,0x11D1,{0xAA,0xEC,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

typedef struct _devclass {
  const GUID *pGuid;
} devclass;

#define MAX_CLASS_GUID       4
const devclass c_pNetClassGuid[] =
{
 &GUID_DEVCLASS_NETTRANS,
 &GUID_DEVCLASS_NETCLIENT,
 &GUID_DEVCLASS_NETSERVICE,
 &GUID_DEVCLASS_NET
};

//
// These IIDs are not publicly available yet. Sumitc will put it out for public
// after which we need to use the publicly available IIDs.
//

EXTERN_C const IID IID_INetCfg = {0xC0E8AE93,0x306E,0x11D1,{0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E}};     
EXTERN_C const IID IID_INetCfgClass = {0xC0E8AE97,0x306E,0x11D1,{0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E}};
EXTERN_C const IID IID_INetCfgComponent = { 0xC0E8AE99,0x306E,0x11D1,{0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E}}; 
EXTERN_C const IID IID_INetCfgComponentBindings = { 0xC0E8AE9E,0x306E,0x11D1,{0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E }};
EXTERN_C const IID IID_IEnumNetCfgComponent = { 0xC0E8AE92,0x306E,0x11D1,{0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E} };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\bindings.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      bindings.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--
#include "precomp.h"

#undef IsEqualGUID
#include "bindings.h"


HRESULT
BindingsTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//++
// Description:
// This Test uses the INetCfg COM interface to get the bingings.
// COM Interface is accessed using C, not C++.
//
// Arguments:
// None.
//
// Author:
// Rajkumar .P ( 07/17/98 )
//
//--
{
    INetCfg* pINetCfg = NULL;
    INetCfgClass *pINetCfgClass = NULL;
    IEnumNetCfgComponent *pIEnumNetCfgComponent = NULL;
    INetCfgComponent *pINetCfgComponent = NULL;
    INetCfgComponentBindings *pINetCfgComponentBindings = NULL;
    IEnumNetCfgBindingPath *pEnumNetCfgBindingPath = NULL;
    INetCfgBindingPath *pINetCfgBindingPath = NULL;
    IEnumNetCfgBindingInterface *pIEnumNetCfgBindingInterface = NULL;
    INetCfgBindingInterface *pINetBindingInterface = NULL;
    INetCfgComponent *pUpperComponent = NULL;
    INetCfgComponent *pLowerComponent = NULL;
    INetCfgComponent *pOwner = NULL;


    HRESULT hr;
    wchar_t *pszwDisplayName;
    wchar_t *pszwBindName;
    wchar_t *pszwDescription;
    wchar_t *pszwInterfaceName;
    wchar_t *pszwUpperComponent;
    wchar_t *pszwLowerComponent;
    wchar_t *pszwOwner;

    TCHAR szBuffer[512];

    DWORD dwPathId;
    int i;

    PrintStatusMessage( pParams, 4, IDS_BINDINGS_STATUS_MSG );

    InitializeListHead( &pResults->Bindings.lmsgOutput );

    // Only do this test if in really verbose mode
    if (!pParams->fReallyVerbose)
        return S_OK;

    //  Initialize the COM library
    CoInitialize(NULL);

    hr = CoCreateInstance(&CLSID_NetCfg,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          &IID_INetCfg,
                          (void**)&pINetCfg) ;


    if(FAILED(hr))
    {
        DebugMessage("CreateInstance for IID_INetCfg failed\n");
        goto end_BindingsTest;
    }

    hr = pINetCfg->lpVtbl->Initialize(pINetCfg, NULL);

    if(FAILED(hr))
    {
        DebugMessage("pINetCfg->Initialize failed.\n");
        goto end_BindingsTest;
    }



    for ( i = 0; i < MAX_CLASS_GUID ; i++ )
    {

        hr = pINetCfg->lpVtbl->QueryNetCfgClass(pINetCfg,
                                          c_pNetClassGuid[i].pGuid,
                                          &IID_INetCfgClass, // This arg is undocumented
                                          &pINetCfgClass
                                         );

        if(FAILED(hr))
        {
            DebugMessage("QueryNetCfgClass failed\n");
            goto end_BindingsTest;
        }

        hr = pINetCfgClass->lpVtbl->EnumComponents(pINetCfgClass,
                                            &pIEnumNetCfgComponent);

        pINetCfgClass->lpVtbl->Release(pINetCfgClass);
        pINetCfgClass = NULL;

        if(FAILED(hr))
        {
            DebugMessage("EnumComponents failed\n");
            goto end_BindingsTest;
        }

        // pIEnumNetCfgComponent is a standard COM enumerator

        while (S_OK == pIEnumNetCfgComponent->lpVtbl->Next(pIEnumNetCfgComponent,1,&pINetCfgComponent,NULL))
        {
            HRESULT hrTmp;

            hrTmp = pINetCfgComponent->lpVtbl->GetDisplayName(pINetCfgComponent,
                                          (LPWSTR *)&pszwDisplayName
                                          );


            if (hrTmp == S_OK)
            {
                WideCharToMultiByte(CP_ACP, 0, pszwDisplayName, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                //IDS_BINDINGS_14801                  "Component Name : %s\n"
                AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14801, szBuffer);
                CoTaskMemFree(pszwDisplayName);
            }

            hrTmp = pINetCfgComponent->lpVtbl->GetBindName(pINetCfgComponent,
                                               (LPWSTR *)&pszwBindName);

            if ( SUCCEEDED(hrTmp) )
            {
                WideCharToMultiByte(CP_ACP, 0, pszwBindName, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                //IDS_BINDINGS_14802                  "Bind Name: %s\n"
                AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14802, szBuffer);
//$REVIEW nsun: maybe we should use SysFreeString to free the buffer
                CoTaskMemFree(pszwBindName);
            }

//
//  This function though found in doc , is not yet available
//

/*
                        hrTmp = pINetCfgComponent->lpVtbl->GetDescriptionText(pINetCfgComponent,
                                                              (LPWSTR *)&pszwDescription);

                        if (hrTmp == S_OK) {
                            WideCharToMultiByte(CP_ACP, 0, pszwBindName, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
//IDS_BINDINGS_14804                  "Description: %s\n"
                            wsPrintMessage(&pResults->Bindings.lmsgOutput, IDS_BINDINGS_14804,pszwDescription);
                            CoTaskMemFree(pszwDescription);
                        }
*/

            AddMessageToListSz(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, _T("    Binding Paths:\n"));
            hrTmp = pINetCfgComponent->lpVtbl->QueryInterface(pINetCfgComponent,
                                                  &IID_INetCfgComponentBindings,
                                                  &pINetCfgComponentBindings);

            pINetCfgComponent->lpVtbl->Release(pINetCfgComponent);
            pINetCfgComponent = NULL;

            if (FAILED(hrTmp)) 
                continue;

            hrTmp = pINetCfgComponentBindings->lpVtbl->EnumBindingPaths(pINetCfgComponentBindings,EBP_BELOW,&pEnumNetCfgBindingPath);

            pINetCfgComponentBindings->lpVtbl->Release(pINetCfgComponentBindings);
            pINetCfgComponentBindings = NULL;

            if (FAILED(hrTmp)) 
                continue;

            while ( S_OK == pEnumNetCfgBindingPath->lpVtbl->Next(pEnumNetCfgBindingPath, 1,&pINetCfgBindingPath,NULL))
            {
//
// Got some problems using these two calls - need to take this up with sumitc
//

                hrTmp = pINetCfgBindingPath->lpVtbl->GetOwner(pINetCfgBindingPath,
                                                   &pOwner);

                if ( SUCCEEDED(hrTmp) )
                {
                   hrTmp = pOwner->lpVtbl->GetDisplayName(pOwner,
                                                       &pszwOwner);

                   if (hrTmp == S_OK) {
                       WideCharToMultiByte(CP_ACP, 0, pszwOwner, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                       //IDS_BINDINGS_14805                  "Owner of the binding path : %s\n"
                       AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14805, szBuffer);
                       CoTaskMemFree(pszwOwner);
                   }
                }

                pOwner->lpVtbl->Release(pOwner);
                pOwner = NULL;

                hrTmp = pINetCfgBindingPath->lpVtbl->IsEnabled(pINetCfgBindingPath);

                if (hrTmp == S_OK)
                    //IDS_BINDINGS_14806                  "Binding Enabled: Yes\n"
                    AddMessageToListId(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14806);
                else
                if (hrTmp == S_FALSE)
                    //IDS_BINDINGS_14807                  "Binding Enabled: No\n"
                    AddMessageToListId(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14807);
                else
                if (hrTmp == NETCFG_E_NOT_INITIALIZED)
                    //IDS_BINDINGS_14808                  "Binding Enabled: Binding has not yet been intialized\n"
                    AddMessageToListId(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14808);

                AddMessageToListSz(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, _T("    Interfaces of the binding path: \n"));
                hrTmp = pINetCfgBindingPath->lpVtbl->EnumBindingInterfaces(
                                                   pINetCfgBindingPath,
                                                  &pIEnumNetCfgBindingInterface);

                pINetCfgBindingPath->lpVtbl->Release(pINetCfgBindingPath);
                pINetCfgBindingPath = NULL;

                if( FAILED(hrTmp) )
                {
                    DebugMessage("EnumBindingInterfaces failed\n" );
                    continue;
                }

                while ( S_OK == pIEnumNetCfgBindingInterface->lpVtbl->Next(pIEnumNetCfgBindingInterface,1,&pINetBindingInterface,NULL))
                {

                    hrTmp = pINetBindingInterface->lpVtbl->GetName(pINetBindingInterface,
                                                     &pszwInterfaceName);

                    if (hrTmp == S_OK)
                    {
                        WideCharToMultiByte(CP_ACP, 0, pszwInterfaceName, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                        //IDS_BINDINGS_14810                  "Interface Name: %s\n"
                        AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14810, szBuffer);
                        CoTaskMemFree(pszwInterfaceName);
                    }

                    hrTmp = pINetBindingInterface->lpVtbl->GetUpperComponent(
                                                   pINetBindingInterface,
                                                   &pUpperComponent);

                    if (hrTmp == S_OK)
                    {
                        pszwUpperComponent = NULL;

                        hrTmp = pUpperComponent->lpVtbl->GetDisplayName(
                                                pUpperComponent,
                                                &pszwUpperComponent);
                        
                        pUpperComponent->lpVtbl->Release(pUpperComponent);
                        pUpperComponent = NULL;

                        if (hrTmp == S_OK)
                        {
                            assert(pszwUpperComponent);
                            WideCharToMultiByte(CP_ACP, 0, pszwUpperComponent, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                            //IDS_BINDINGS_14811                  "Upper Component: %s\n"
                            AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14811, szBuffer);
                            CoTaskMemFree(pszwUpperComponent);
                        }

                    }

                    hrTmp = pINetBindingInterface->lpVtbl->GetLowerComponent(
                                                     pINetBindingInterface,
                                                     &pLowerComponent);

                    pINetBindingInterface->lpVtbl->Release(pINetBindingInterface);
                    pINetBindingInterface = NULL;

                    if (hrTmp == S_OK )
                    {
                        pszwLowerComponent = NULL;
                        hrTmp = pLowerComponent->lpVtbl->GetDisplayName(
                                                  pLowerComponent,
                                                  &pszwLowerComponent);

                        pLowerComponent->lpVtbl->Release(pLowerComponent);
                        pLowerComponent = NULL;

                        if (hrTmp == S_OK )
                        {
                            assert(pszwLowerComponent);
                            WideCharToMultiByte(CP_ACP, 0, pszwLowerComponent, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                            //IDS_BINDINGS_14812                  "Lower Component: %s\n"
                            AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14812, szBuffer);
                            CoTaskMemFree(pszwLowerComponent);
                        }
                    }
                }

                pIEnumNetCfgBindingInterface->lpVtbl->Release(pIEnumNetCfgBindingInterface);
                pIEnumNetCfgBindingInterface = NULL;

                AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_GLOBAL_EmptyLine);
            }

            AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_GLOBAL_EmptyLine);
            pEnumNetCfgBindingPath->lpVtbl->Release(pEnumNetCfgBindingPath);
            pEnumNetCfgBindingPath = NULL;
        }
        pIEnumNetCfgComponent->lpVtbl->Release(pIEnumNetCfgComponent);
        pIEnumNetCfgComponent = NULL;
     }
     pINetCfg->lpVtbl->Uninitialize(pINetCfg);
     pINetCfg->lpVtbl->Release(pINetCfg);


end_BindingsTest:

    // Unitialize COM Library
    CoUninitialize();
    pResults->Bindings.hrTestResult = hr;
    return hr;
}


void BindingsGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (pParams->fVerbose || !FHrOK(pResults->Bindings.hrTestResult))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_BINDINGS_LONG,
                             IDS_BINDINGS_SHORT,
                             TRUE,
                             pResults->Bindings.hrTestResult,
                             0);
    }

    PrintMessageList(pParams, &pResults->Bindings.lmsgOutput);
}


void BindingsPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    //no pre interface print
}

void BindingsCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Bindings.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\brnames.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wsnames.h

Abstract:

    Private header file which defines the Workstation names.

Author:

    Rita Wong (ritaw) 06-May-1991

Revision History:

--*/

#define BROWSER_INTERFACE_NAME    TEXT("browser")

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\bowser.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      browser.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "malloc.h"
#include "nbtutil.h"

NET_API_STATUS GetBrowserTransportList(OUT PLMDR_TRANSPORT_LIST *TransportList);
//$review (nsun) there is a recursive calling of this function
NTSTATUS
NettestBrowserSendDatagram(
    IN PLIST_ENTRY listNetbtTransports,
    IN PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo,
    IN PVOID ContextDomainInfo,
    IN ULONG IpAddress,
    IN LPWSTR UnicodeDestinationName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN LPWSTR pswzTransportName,
    IN LPSTR OemMailslotName,
    IN PVOID Buffer,
    IN ULONG BufferSize
    );
BOOL MailslotTest(NETDIAG_PARAMS* pParams,
                  IN LPWSTR DestinationName,
                  NETDIAG_RESULT* pResults);




BOOL
BrowserTest(
      NETDIAG_PARAMS*  pParams,
      NETDIAG_RESULT*  pResults
    )
/*++

Routine Description:

    Determine the machines role and membership.

Arguments:

    None.

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS NetStatus;
    HRESULT hrRetVal = S_OK;

    BOOL BrowserIsUp = TRUE;
    BOOL RedirIsUp = TRUE;
    PLMDR_TRANSPORT_LIST TransportList = NULL;
    PLMDR_TRANSPORT_LIST TransportEntry;
    LONG NetbtTransportCount;
    LONG RealNetbtTransportCount;
    PNETBT_TRANSPORT NetbtTransport;
    BOOL PrintIt;
    PWKSTA_TRANSPORT_INFO_0 pWti0 = NULL;
    DWORD EntriesRead;
    DWORD TotalEntries;
    DWORD i;
    WCHAR DestinationName[MAX_PATH+1];
    BOOL MailslotTested = FALSE;
    PTESTED_DOMAIN TestedDomain;
    PLIST_ENTRY ListEntry;

    USES_CONVERSION;

    PrintStatusMessage( pParams, 4, IDS_BROWSER_STATUS_MSG );
	pResults->Browser.fPerformed = TRUE;

    InitializeListHead( &pResults->Browser.lmsgOutput );

    //
    // Ensure the workstation service is running.
    //

    NetStatus = IsServiceStarted( _T("LanmanWorkstation") );

    if ( NetStatus != NO_ERROR )
    {
        //IDS_BROWSER_13001                  "    [FATAL] Workstation service is not running. [%s]\n"
        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet,
                            IDS_BROWSER_13001, NetStatusToString(NetStatus) );
        hrRetVal = S_OK;
        goto Cleanup;
    }

	if (!pResults->Global.fHasNbtEnabledInterface)
	{
		AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Verbose,
						  IDS_BROWSER_NETBT_DISABLED);
		pResults->Browser.fPerformed = FALSE;
		hrRetVal = S_OK;
		goto Cleanup;
	}

    //
    //  Get the transports bound to the Redir
    //

    if ( pParams->fReallyVerbose )
    {
        //IDS_BROWSER_13002                  "    List of transports currently bound to the Redir\n"
        AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_ReallyVerbose, IDS_BROWSER_13002 );
    }
    else if ( pParams->fVerbose )
    {
        //IDS_BROWSER_13003                  "    List of NetBt transports currently bound to the Redir\n"
        AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_Verbose, IDS_BROWSER_13003 );
    }


   NetStatus = NetWkstaTransportEnum(
                   NULL,
                   0,
                   (LPBYTE *)&pWti0,
                   0xFFFFFFFF,      // MaxPreferredLength
                   &EntriesRead,
                   &TotalEntries,
                   NULL );          // Optional resume handle

    if (NetStatus != NERR_Success)
    {
        //IDS_BROWSER_13004                  "    [FATAL] Unable to retrieve transport list from Redir. [%s]\n"
        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13004, NetStatusToString(NetStatus) );
        hrRetVal = S_FALSE;
        RedirIsUp = FALSE;
    }
    else
    {
        NetbtTransportCount = 0;
        RealNetbtTransportCount = 0;
        for ( i = 0; i < EntriesRead; i++ )
        {
            UNICODE_STRING ustrTransportName;
            LPTSTR  pszTransportName;

            RtlInitUnicodeString( &ustrTransportName, (LPWSTR)pWti0[i].wkti0_transport_name );

            // Strip off the "\Device\" off of the beginning of
            // the string
            pszTransportName = W2T(MapGuidToServiceNameW(ustrTransportName.Buffer + 8));


            PrintIt = FALSE;

            if ( ustrTransportName.Length >= sizeof(NETBT_DEVICE_PREFIX) &&
                _wcsnicmp( ustrTransportName.Buffer, NETBT_DEVICE_PREFIX, (sizeof(NETBT_DEVICE_PREFIX)/sizeof(WCHAR)-1)) == 0 )
            {

                //
                // Determine if this Netbt transport really exists.
                //

                NetbtTransport = FindNetbtTransport( pResults, ustrTransportName.Buffer );

                if ( NetbtTransport == NULL )
                {
                    //IDS_BROWSER_13005                  "    [FATAL] Transport %s is bound to the redir but is not a configured NetbtTransport."
                    AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13005, pszTransportName );
                    hrRetVal = S_FALSE;
                }
                else
                {
                    if ( NetbtTransport->Flags & BOUND_TO_REDIR )
                    {
                        //IDS_BROWSER_13006                  "    [WARNING] Transport %s is bound to redir more than once."
                        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Verbose, IDS_BROWSER_13006, pszTransportName );
                    }
                    else
                    {
                        NetbtTransport->Flags |= BOUND_TO_REDIR;
                        RealNetbtTransportCount ++;
                    }
                }

                //
                // Count the found transports.
                //
                NetbtTransportCount ++;
                if ( pParams->fVerbose ) {
                    PrintIt = TRUE;
                }
            }

            //IDS_BROWSER_13007                  "        %s\n"
            AddMessageToList( &pResults->Browser.lmsgOutput, PrintIt ? Nd_Verbose : Nd_ReallyVerbose, IDS_BROWSER_13007, pszTransportName);//&ustrTransportName );
        }

        //
        // Ensure the redir is bound to some Netbt transports.
        //
        if ( NetbtTransportCount == 0 )
        {
            //IDS_BROWSER_13008                  "    [FATAL] The redir isn't bound to any NetBt transports."
            AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13008);
            hrRetVal = S_FALSE;
            RedirIsUp = FALSE;
        }
        else
        {
                //IDS_BROWSER_13009                  "    The redir is bound to %ld NetBt transport%s.\n"
                AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Verbose,
                       IDS_BROWSER_13009,
                       NetbtTransportCount,
                       NetbtTransportCount > 1 ? "s" : "" );
        }

        //
        // Ensure the redir is bound to all of the Netbt transports.
        //

        if ( RealNetbtTransportCount != pResults->NetBt.cTransportCount )
        {
            //IDS_BROWSER_13010                  "    [FATAL] The redir is only bound to %ld of the %ld NetBt transports."
            AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet,
                   IDS_BROWSER_13010,
                   RealNetbtTransportCount,
                   pResults->NetBt.cTransportCount );
            hrRetVal = S_FALSE;
        }
    }


    //
    //  Get the transports bound to the browser.
    //

    //IDS_BROWSER_13011                  "\n"
    AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_Verbose, IDS_BROWSER_13011);

    if ( pParams->fReallyVerbose )
        //IDS_BROWSER_13012                  "    List of transports currently bound to the browser\n"
        AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_ReallyVerbose, IDS_BROWSER_13012 );
    else if ( pParams->fVerbose )
        //IDS_BROWSER_13013                  "    List of NetBt transports currently bound to the browser\n"
        AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_Verbose, IDS_BROWSER_13013 );


    NetStatus = GetBrowserTransportList(&TransportList);

    if (NetStatus != NERR_Success)
    {
        //IDS_BROWSER_13014                  "    [FATAL] Unable to retrieve transport list from browser. [%s]\n"
        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13014, NetStatusToString(NetStatus) );
        hrRetVal = S_FALSE;
        BrowserIsUp = FALSE;
    }
    else
    {
        TransportEntry = TransportList;

        NetbtTransportCount = 0;
        RealNetbtTransportCount = 0;
        while (TransportEntry != NULL)
        {
            UNICODE_STRING ustrTransportName;
            LPTSTR  pszTransportName;

            ustrTransportName.Buffer = TransportEntry->TransportName;
            ustrTransportName.Length = (USHORT)TransportEntry->TransportNameLength;
            ustrTransportName.MaximumLength = (USHORT)TransportEntry->TransportNameLength;

            pszTransportName = W2T(MapGuidToServiceNameW(ustrTransportName.Buffer + 8));

            PrintIt = FALSE;
            if ( ustrTransportName.Length >= sizeof(NETBT_DEVICE_PREFIX) &&
                _wcsnicmp( ustrTransportName.Buffer, NETBT_DEVICE_PREFIX, (sizeof(NETBT_DEVICE_PREFIX)/sizeof(WCHAR)-1)) == 0 )
            {

                //
                // Determine if this Netbt transport really exists.
                //

                NetbtTransport = FindNetbtTransport( pResults, ustrTransportName.Buffer );

                if ( NetbtTransport == NULL )
                {
                    //IDS_BROWSER_13015                  "    [FATAL] Transport %s is bound to the browser but is not a configured NetbtTransport."
                    AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13015, pszTransportName );
                    hrRetVal = S_FALSE;
                }
                else
                {
                    if ( NetbtTransport->Flags & BOUND_TO_BOWSER )
                    {
                        //IDS_BROWSER_13016                  "    [FATAL] Transport %s is bound to browser more than once."
                        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13016, pszTransportName );
                        hrRetVal = S_FALSE;
                    }
                    else
                    {
                        NetbtTransport->Flags |= BOUND_TO_BOWSER;
                        RealNetbtTransportCount ++;
                    }

                }

                //
                // Count the found transports.
                //
                NetbtTransportCount ++;
                if ( pParams->fVerbose )
                    PrintIt = TRUE;
            }

            //IDS_BROWSER_13017                  "        %s\n"
            AddMessageToList( &pResults->Browser.lmsgOutput,
                                PrintIt ? Nd_Verbose : Nd_ReallyVerbose,
                                IDS_BROWSER_13017, pszTransportName );


            if (TransportEntry->NextEntryOffset == 0)
            {
                TransportEntry = NULL;
            }
            else
            {
                TransportEntry = (PLMDR_TRANSPORT_LIST)((PCHAR)TransportEntry+TransportEntry->NextEntryOffset);
            }
        }

        if ( NetbtTransportCount == 0 )
        {
            //IDS_BROWSER_13018                  "    [FATAL] The browser isn't bound to any NetBt transports"
            AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_Quiet,
                                IDS_BROWSER_13018 );
            hrRetVal = S_FALSE;
            BrowserIsUp = FALSE;
        }
        else
        {
            //IDS_BROWSER_13019                  "    The browser is bound to %ld NetBt transport%s.\n"
            AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Verbose,
                       IDS_BROWSER_13019,
                       NetbtTransportCount,
                       NetbtTransportCount > 1 ? "s" : "" );
        }

        //
        // Ensure the browser is bound to all of the Netbt transports.
        //

        if ( RealNetbtTransportCount != pResults->NetBt.cTransportCount )
        {
            //IDS_BROWSER_13020                  "    [FATAL] The browser is only bound to %ld of the %ld NetBt transports."
            AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet,
                   IDS_BROWSER_13020,
                   RealNetbtTransportCount,
                   pResults->NetBt.cTransportCount );
            hrRetVal = FALSE;
        }
    }

    //
    // Ensure we can send mailslot messages.  (DsGetDcName uses them.)
    //
    // Try sending to each of the tested domains.
    //

    for ( ListEntry = pResults->Global.listTestedDomains.Flink ;
          ListEntry != &pResults->Global.listTestedDomains ;
          ListEntry = ListEntry->Flink )
    {

        //
        // Only test this domain if it is has a Netbios domain name
        //

        TestedDomain = CONTAINING_RECORD( ListEntry, TESTED_DOMAIN, Next );

        if ( TestedDomain->NetbiosDomainName != NULL )
        {
            //
            // Send the message to the <DomainName>[1C] name
            //
            wcscpy( DestinationName, TestedDomain->NetbiosDomainName );
            wcscat( DestinationName, L"*" );
            if ( !MailslotTest( pParams, DestinationName, pResults ) ) {
                hrRetVal = S_FALSE;
            }
            else
            {
                USES_CONVERSION;
                //IDS_BROWSER_13021                  "Mailslot test for %s passed.\n"
                AddMessageToList( &pResults->Browser.lmsgOutput, Nd_ReallyVerbose, IDS_BROWSER_13021, W2CT(DestinationName));
            }
            MailslotTested = TRUE;
        }
    }


    //
    // If we still haven't tested mailslots,
    //  test them by sending the message to our own computername.
    //

//#ifdef notdef   // crashes build 1728
    if ( !MailslotTested ) {
        wcscpy( DestinationName, pResults->Global.swzNetBiosName );
        if ( !MailslotTest( pParams, DestinationName, pResults ) ) {
            hrRetVal = S_FALSE;
        }
        MailslotTested = TRUE;
    }
//#endif // notdef   // crashes build 1728


Cleanup:
    if ( pWti0 )
    {
        NetApiBufferFree( pWti0 );
    }

    if ( TransportList != NULL )
    {
        NetApiBufferFree(TransportList);
    }

    if ( FHrOK(hrRetVal) )
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_PASS_NL);
    }
    else
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_FAIL_NL);
    }


    pResults->Browser.hrTestResult = hrRetVal;

    return hrRetVal;
}




NET_API_STATUS
GetBrowserTransportList(
    OUT PLMDR_TRANSPORT_LIST *TransportList
    )

/*++

Routine Description:

    This routine returns the list of transports bound into the browser.

Arguments:

    OUT PLMDR_TRANSPORT_LIST *TransportList - Transport list to return.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{

    NET_API_STATUS NetStatus;
    HANDLE BrowserHandle;
    LMDR_REQUEST_PACKET RequestPacket;

    NetStatus = OpenBrowser(&BrowserHandle);

    if (NetStatus != NERR_Success) {
        DebugMessage2("    [FATAL] Unable to open browser driver. [%s]\n",  NetStatusToString(NetStatus) );
        return NetStatus;
    }

    RequestPacket.Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket.Type = EnumerateXports;

    RtlInitUnicodeString(&RequestPacket.TransportName, NULL);
    RtlInitUnicodeString(&RequestPacket.EmulatedDomainName, NULL);

    NetStatus = DeviceControlGetInfo(
                BrowserHandle,
                IOCTL_LMDR_ENUMERATE_TRANSPORTS,
                &RequestPacket,
                sizeof(RequestPacket),
                (PVOID *)TransportList,
                0xffffffff,
                4096,
                NULL);

    NtClose(BrowserHandle);

    return NetStatus;
}





BOOL
MailslotTest(
    NETDIAG_PARAMS* pParams,
    IN LPWSTR DestinationName,
    NETDIAG_RESULT* pResults
    )
/*++

Routine Description:

    Ensure we can send mailslot messages.

    Test both via redir and browser.

    Don't test responses (since that really tests if the DC is up).

Arguments:

    DestinationName - Name to send the message to
        Name ends in * if destination is the [1c] name.

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    BOOL RetVal = TRUE;

    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    HANDLE ResponseMailslotHandle = NULL;
    TCHAR ResponseMailslotName[MAX_PATH+1];
    WCHAR NetlogonMailslotName[MAX_PATH+1];

    WCHAR BrowserDestinationName[MAX_PATH+1];
    DWORD BrowserDestinationNameLen;
    DGRECEIVER_NAME_TYPE NameType;

    PVOID PingMessage = NULL;
    ULONG PingMessageSize = 0;

    //
    // Open a mailslot to get ping responses on.
    //
    //

    NetStatus = NetpLogonCreateRandomMailslot( ResponseMailslotName,
                                               &ResponseMailslotHandle );

    if (NetStatus != NO_ERROR ) {
        //IDS_BROWSER_13022                  "    [FATAL] Cannot create temp mailslot. [%s]\n"
        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13022,   NetStatusToString(NetStatus)  );
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Allocate a mailslot message to send
    //

    NetStatus = NetpDcBuildPing (
        FALSE,  // Not only PDC
        0,      // Retry count
        pResults->Global.swzNetBiosName, //replace GlobalNetbiosComputerName,
        NULL,   // No Account name
        ResponseMailslotName,
        0,      // no AllowableAccountControlBits,
        NULL,   // No Domain SID
        0,      // Not NT Version 5
        &PingMessage,
        &PingMessageSize );

    if ( NetStatus != NO_ERROR ) {
        //IDS_BROWSER_13023                  "    [FATAL] Cannot allocate mailslot message. [%s]\n"
        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13023,
                            NetStatusToString(NetStatus) );
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Build the destination mailslot name.
    //

    NetlogonMailslotName[0] = '\\';
    NetlogonMailslotName[1] = '\\';
    wcscpy(NetlogonMailslotName + 2, DestinationName );
    wcscat( NetlogonMailslotName, NETLOGON_LM_MAILSLOT_W );

    //
    // Send the mailslot via the redir.
    //
    NetStatus = NetpLogonWriteMailslot(
                        NetlogonMailslotName,
                        (PCHAR)PingMessage,
                        PingMessageSize );

    if ( NetStatus != NO_ERROR ) {
        //IDS_BROWSER_13024                  "    [FATAL] Cannot send mailslot message to '%ws' via redir. [%s]\n"
        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13024,
                            NetlogonMailslotName,  NetStatusToString(NetStatus)  );
        RetVal = FALSE;
        goto Cleanup;
    }


    //
    // Send the mailslot via the browser
    //
    // Avoid this test if this build has an old value for the IOCTL function
    //  code to the browser.
    //

    if ( _ttoi(pResults->Global.pszCurrentBuildNumber) < NTBUILD_BOWSER )
    {
        if ( pParams->fReallyVerbose ) {
            //IDS_BROWSER_13025                  "    Cannot sending mailslot messages via the browser since this machine is running build %ld. [Test skipped.]\n"
            AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13025, pResults->Global.pszCurrentBuildNumber  );
        }
    }
    else
    {
        wcscpy( BrowserDestinationName, DestinationName );
        BrowserDestinationNameLen = wcslen(BrowserDestinationName);

        if ( BrowserDestinationName[BrowserDestinationNameLen-1] == L'*' )
        {
            BrowserDestinationName[BrowserDestinationNameLen-1] = L'\0';
            NameType = DomainName;  // [1c] name
        }
        else
        {
            NameType = PrimaryDomain; // [00] name
        }

        Status = NettestBrowserSendDatagram(
                    &pResults->NetBt.Transports,
                    pResults->Global.pPrimaryDomainInfo,
                    NULL,
                    ALL_IP_TRANSPORTS,
                    BrowserDestinationName,
                    NameType,
                    NULL,       // All transports
                    NETLOGON_LM_MAILSLOT_A,
                    PingMessage,
                    PingMessageSize );

        if ( !NT_SUCCESS(Status) )
        {
            NetStatus = NetpNtStatusToApiStatus(Status);
            //IDS_BROWSER_13026                  "    [FATAL] Cannot send mailslot message to '%ws' via browser. [%s]\n"
            AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13026,
                              DestinationName,  NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;
        }
    }

Cleanup:
    if ( PingMessage != NULL ) {
        NetpMemoryFree( PingMessage );
    }
    if ( ResponseMailslotHandle != NULL ) {
        CloseHandle(ResponseMailslotHandle);
    }
    return RetVal;
}




NTSTATUS
NettestBrowserSendDatagram(
    IN PLIST_ENTRY plistNetbtTransports,
    IN PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo,
    IN PVOID ContextDomainInfo,
    IN ULONG IpAddress,
    IN LPWSTR UnicodeDestinationName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN LPWSTR TransportName,
    IN LPSTR OemMailslotName,
    IN PVOID Buffer,
    IN ULONG BufferSize
    )
/*++

Routine Description:

    Send the specified mailslot message to the specified mailslot on the
    specified server on the specified transport..

Arguments:

    DomainInfo - Hosted domain sending the datagram

    IpAddress - IpAddress of the machine to send the message to.
        If zero, UnicodeDestinationName must be specified.
        If ALL_IP_TRANSPORTS, UnicodeDestination must be specified but the datagram
            will only be sent on IP transports.

    UnicodeDestinationName -- Name of the server to send to.

    NameType -- Type of name represented by UnicodeDestinationName.

    TransportName -- Name of the transport to send on.
        Use NULL to send on all transports.

    OemMailslotName -- Name of the mailslot to send to.

    Buffer -- Specifies a pointer to the mailslot message to send.

    BufferSize -- Size in bytes of the mailslot message

Return Value:

    Status of the operation.

    STATUS_NETWORK_UNREACHABLE: Cannot write to network.

--*/
{
    PLMDR_REQUEST_PACKET RequestPacket = NULL;
    NET_API_STATUS NetStatus;

    DWORD OemMailslotNameSize;
    DWORD TransportNameSize;
    DWORD DestinationNameSize;
    WCHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1];
    ULONG Information;
    HANDLE BrowserHandle = NULL;

    NTSTATUS Status;
    LPBYTE Where;
    LONG    test;

    //
    // If the transport isn't specified,
    //  send on all transports.
    //

    if ( TransportName == NULL ) {
        ULONG i;
        PLIST_ENTRY ListEntry;
        NTSTATUS SavedStatus = STATUS_NETWORK_UNREACHABLE;

        //
        // Loop through the list of netbt transports finding this one.
        //

        for ( ListEntry = plistNetbtTransports->Flink ;
              ListEntry != plistNetbtTransports ;
              ListEntry = ListEntry->Flink ) {

            PNETBT_TRANSPORT NetbtTransport;

            //
            // If the transport names match,
            //  return the entry
            //

            NetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

            //
            // Skip deleted transports.
            //
            if ( (NetbtTransport->Flags & BOUND_TO_BOWSER) == 0 ) {
                continue;
            }

            Status = NettestBrowserSendDatagram(
                              plistNetbtTransports,
                              pPrimaryDomainInfo,
                              ContextDomainInfo,
                              IpAddress,
                              UnicodeDestinationName,
                              NameType,
                              NetbtTransport->pswzTransportName,
                              OemMailslotName,
                              Buffer,
                              BufferSize );

            if ( NT_SUCCESS(Status) ) {
                // If any transport works, we've been successful
                SavedStatus = STATUS_SUCCESS;
            } else {
                // Remember the real reason for the failure instead of the default failure status
                // Remember only the first failure.
                if ( SavedStatus == STATUS_NETWORK_UNREACHABLE ) {
                    SavedStatus = Status;
                }
            }

        }
        return SavedStatus;
    }



    //
    // Open a handle to the browser.
    //

    NetStatus = OpenBrowser(&BrowserHandle);

    if (NetStatus != NERR_Success) {
        DebugMessage2("    [FATAL] Unable to open browser driver. [%s]\n", NetStatusToString(NetStatus));
        Status = NetpApiStatusToNtStatus( NetStatus );
        goto Cleanup;
    }



    //
    // Allocate a request packet.
    //

    OemMailslotNameSize = strlen(OemMailslotName) + 1;
    TransportNameSize = (wcslen(TransportName) + 1) * sizeof(WCHAR);

    if ( UnicodeDestinationName == NULL ) {
        return STATUS_INTERNAL_ERROR;
    }

    DestinationNameSize = wcslen(UnicodeDestinationName) * sizeof(WCHAR);

    RequestPacket = NetpMemoryAllocate(
                                  sizeof(LMDR_REQUEST_PACKET) +
                                  TransportNameSize +
                                  OemMailslotNameSize +
                                  DestinationNameSize + sizeof(WCHAR) +
                                  (wcslen( pPrimaryDomainInfo->DomainNameFlat ) + 1) * sizeof(WCHAR) +
                                  sizeof(WCHAR)) ; // For alignment


    if (RequestPacket == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }



    //
    // Fill in the Request Packet.
    //

    RequestPacket->Type = Datagram;
    RequestPacket->Parameters.SendDatagram.DestinationNameType = NameType;


    //
    // Fill in the name of the machine to send the mailslot message to.
    //

    RequestPacket->Parameters.SendDatagram.NameLength = DestinationNameSize;

    Where = (LPBYTE) RequestPacket->Parameters.SendDatagram.Name;
    RtlCopyMemory( Where, UnicodeDestinationName, DestinationNameSize );
    Where += DestinationNameSize;


    //
    // Fill in the name of the mailslot to send to.
    //

    RequestPacket->Parameters.SendDatagram.MailslotNameLength =
        OemMailslotNameSize;
    strcpy( Where, OemMailslotName);
    Where += OemMailslotNameSize;
    Where = ROUND_UP_POINTER( Where, ALIGN_WCHAR );


    //
    // Fill in the TransportName
    //

    wcscpy( (LPWSTR) Where, TransportName);
    RtlInitUnicodeString( &RequestPacket->TransportName, (LPWSTR) Where );
    Where += TransportNameSize;


    //
    // Copy the hosted domain name to the request packet.
    //
	//If the machine doesn't belong to a domain, we shouldn't get to here
	assert(pPrimaryDomainInfo->DomainNameFlat);
	if (pPrimaryDomainInfo->DomainNameFlat)  
	{
		wcscpy( (LPWSTR)Where,
				pPrimaryDomainInfo->DomainNameFlat );
		RtlInitUnicodeString( &RequestPacket->EmulatedDomainName,
							  (LPWSTR)Where );
		Where += (wcslen( pPrimaryDomainInfo->DomainNameFlat ) + 1) * sizeof(WCHAR);
	}


    //
    // Send the request to the browser.
    //

    NetStatus = BrDgReceiverIoControl(
                   BrowserHandle,
                   IOCTL_LMDR_WRITE_MAILSLOT,
                   RequestPacket,
                   (ULONG)(Where - (LPBYTE)RequestPacket),
                   Buffer,
                   BufferSize,
                   &Information );


    if ( NetStatus != NO_ERROR ) {
        Status = NetpApiStatusToNtStatus( NetStatus );
    }

    //
    // Free locally used resources.
    //
Cleanup:
    if ( BrowserHandle != NULL ) {
        NtClose(BrowserHandle);
    }

    if ( RequestPacket != NULL ) {
        NetpMemoryFree( RequestPacket );
    }

    return Status;
}


void BrowserGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (pParams->fVerbose || !FHrOK(pResults->Browser.hrTestResult))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_BROWSER_LONG,
                             IDS_BROWSER_SHORT,
                             pResults->Browser.fPerformed,
                             pResults->Browser.hrTestResult,
                             0);
    }
    PrintMessageList(pParams, &pResults->Browser.lmsgOutput);

}

void BrowserPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    //no per interface results
}

void BrowserCleanup(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Browser.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\bowser.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue May 02 14:36:51 2000
 */
/* Compiler settings for .\bowser.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __bowser_h__
#define __bowser_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

/* header files for imported files */
#include "imports.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __browser_INTERFACE_DEFINED__
#define __browser_INTERFACE_DEFINED__

/* interface browser */
/* [implicit_handle][unique][ms_union][version][uuid] */ 

#pragma once

typedef /* [handle] */ wchar_t __RPC_FAR *BROWSER_IMPERSONATE_HANDLE;

typedef /* [handle] */ wchar_t __RPC_FAR *BROWSER_IDENTIFY_HANDLE;

typedef struct  _SERVER_INFO_100_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPSERVER_INFO_100 Buffer;
    }	SERVER_INFO_100_CONTAINER;

typedef struct _SERVER_INFO_100_CONTAINER __RPC_FAR *PSERVER_INFO_100_CONTAINER;

typedef struct _SERVER_INFO_100_CONTAINER __RPC_FAR *LPSERVER_INFO_100_CONTAINER;

typedef struct  _SERVER_INFO_101_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPSERVER_INFO_101 Buffer;
    }	SERVER_INFO_101_CONTAINER;

typedef struct _SERVER_INFO_101_CONTAINER __RPC_FAR *PSERVER_INFO_101_CONTAINER;

typedef struct _SERVER_INFO_101_CONTAINER __RPC_FAR *LPSERVER_INFO_101_CONTAINER;

typedef struct  _BROWSER_STATISTICS_100_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ PBROWSER_STATISTICS_100 Buffer;
    }	BROWSER_STATISTICS_100_CONTAINER;

typedef struct _BROWSER_STATISTICS_100_CONTAINER __RPC_FAR *PBROWSER_STATISTICS_100_CONTAINER;

typedef struct  _BROWSER_STATISTICS_101_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ PBROWSER_STATISTICS_101 Buffer;
    }	BROWSER_STATISTICS_101_CONTAINER;

typedef struct _BROWSER_STATISTICS_101_CONTAINER __RPC_FAR *PBROWSER_STATISTICS_101_CONTAINER;

typedef struct  _BROWSER_EMULATED_DOMAIN_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ PBROWSER_EMULATED_DOMAIN Buffer;
    }	BROWSER_EMULATED_DOMAIN_CONTAINER;

typedef struct _BROWSER_EMULATED_DOMAIN_CONTAINER __RPC_FAR *PBROWSER_EMULATED_DOMAIN_CONTAINER;

typedef struct  _SERVER_ENUM_STRUCT
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union _SERVER_ENUM_UNION
        {
        /* [case()] */ LPSERVER_INFO_100_CONTAINER Level100;
        /* [case()] */ LPSERVER_INFO_101_CONTAINER Level101;
        /* [default] */  /* Empty union arm */ 
        }	ServerInfo;
    }	SERVER_ENUM_STRUCT;

typedef struct _SERVER_ENUM_STRUCT __RPC_FAR *PSERVER_ENUM_STRUCT;

typedef struct _SERVER_ENUM_STRUCT __RPC_FAR *LPSERVER_ENUM_STRUCT;

typedef struct  _BROWSER_STATISTICS_STRUCT
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union _BROWSER_STATISTICS_UNION
        {
        /* [case()] */ PBROWSER_STATISTICS_100_CONTAINER Level100;
        /* [case()] */ PBROWSER_STATISTICS_101_CONTAINER Level101;
        /* [default] */  /* Empty union arm */ 
        }	Statistics;
    }	BROWSER_STATISTICS_STRUCT;

typedef struct _BROWSER_STATISTICS_STRUCT __RPC_FAR *PBROWSER_STATISTICS_STRUCT;

typedef struct _BROWSER_STATISTICS_STRUCT __RPC_FAR *LPBROWSER_STATISTICS_STRUCT;

DWORD I_BrowserrServerEnum( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *TransportName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *ClientName,
    /* [out][in] */ LPSERVER_ENUM_STRUCT InfoStruct,
    /* [in] */ DWORD PreferedMaximumLength,
    /* [out] */ LPDWORD TotalEntries,
    /* [in] */ DWORD ServerType,
    /* [unique][string][in] */ wchar_t __RPC_FAR *Domain,
    /* [unique][out][in] */ LPDWORD ResumeHandle);

DWORD I_BrowserrDebugCall( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [in] */ DWORD DebugFunction,
    /* [in] */ DWORD OptionalValue);

DWORD I_BrowserrQueryOtherDomains( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [out][in] */ LPSERVER_ENUM_STRUCT InfoStruct,
    /* [out] */ LPDWORD TotalEntries);

DWORD I_BrowserrResetNetlogonState( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName);

DWORD I_BrowserrDebugTrace( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [string][in] */ LPSTR TraceString);

DWORD I_BrowserrQueryStatistics( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE servername,
    /* [out] */ LPBROWSER_STATISTICS __RPC_FAR *statistics);

DWORD I_BrowserrResetStatistics( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE servername);

DWORD NetrBrowserStatisticsClear( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE servername);

DWORD NetrBrowserStatisticsGet( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE servername,
    /* [in] */ DWORD Level,
    /* [out][in] */ LPBROWSER_STATISTICS_STRUCT StatisticsStruct);

DWORD I_BrowserrSetNetlogonState( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [string][in] */ wchar_t __RPC_FAR *DomainName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *EmulatedComputerName,
    /* [in] */ DWORD Role);

DWORD I_BrowserrQueryEmulatedDomains( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [out][in] */ PBROWSER_EMULATED_DOMAIN_CONTAINER EmulatedDomains);

DWORD I_BrowserrServerEnumEx( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *TransportName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *ClientName,
    /* [out][in] */ LPSERVER_ENUM_STRUCT InfoStruct,
    /* [in] */ DWORD PreferedMaximumLength,
    /* [out] */ LPDWORD TotalEntries,
    /* [in] */ DWORD ServerType,
    /* [unique][string][in] */ wchar_t __RPC_FAR *Domain,
    /* [unique][string][in] */ wchar_t __RPC_FAR *FirstNameToReturn);


extern handle_t browser_bhandle;


extern RPC_IF_HANDLE browser_ClientIfHandle;
extern RPC_IF_HANDLE browser_ServerIfHandle;
#endif /* __browser_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

handle_t __RPC_USER BROWSER_IDENTIFY_HANDLE_bind  ( BROWSER_IDENTIFY_HANDLE );
void     __RPC_USER BROWSER_IDENTIFY_HANDLE_unbind( BROWSER_IDENTIFY_HANDLE, handle_t );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\dcutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dcutil.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_DCUTIL
#define HEADER_DCUTIL

PTESTED_DC
AddTestedDc(IN NETDIAG_PARAMS *pParams,
			IN OUT NETDIAG_RESULT *pResults,
			IN PTESTED_DOMAIN TestedDomain,
			IN LPWSTR ComputerName,
			IN ULONG Flags
		   );

PTESTED_DC
FindTestedDc(IN OUT NETDIAG_RESULT *pResults,
			 IN LPWSTR ComputerName
			);

NET_API_STATUS
GetADc(IN NETDIAG_PARAMS *pParams,
	   IN OUT NETDIAG_RESULT *pResults,
       OUT PLIST_ENTRY plmsgOutput,
	   IN DSGETDCNAMEW *DsGetDcRoutine,
	   IN PTESTED_DOMAIN TestedDomain,
	   IN DWORD Flags,
	   OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
	  );

PTESTED_DC
GetUpTestedDc(
    IN PTESTED_DOMAIN TestedDomain
    );

BOOL
GetIpAddressForDc(PTESTED_DC TestedDc);

NET_API_STATUS
DoDsGetDcName(IN NETDIAG_PARAMS *pParams,
			  IN OUT NETDIAG_RESULT *pResults,
              OUT PLIST_ENTRY   plmsgOutput,
			  IN PTESTED_DOMAIN pTestedDomain,
			  IN DWORD Flags,
			  IN LPTSTR pszDcType,
			  IN BOOLEAN IsFatal,
			  OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
			 );

VOID
NetpIpAddressToStr(
    ULONG IpAddress,
    CHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1]
    );

VOID
NetpIpAddressToWStr(
    ULONG IpAddress,
    WCHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1]
    );

NET_API_STATUS
NetpDcBuildPing(
    IN BOOL PdcOnly,
    IN ULONG RequestCount,
    IN LPCWSTR UnicodeComputerName,
    IN LPCWSTR UnicodeUserName OPTIONAL,
    IN LPCSTR ResponseMailslotName,
    IN ULONG AllowableAccountControlBits,
    IN PSID RequestedDomainSid OPTIONAL,
    IN ULONG NtVersion,
    OUT PVOID *Message,
    OUT PULONG MessageSize
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\dclist.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      dclist.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"

BOOL
GetDcListFromDs(
    IN NETDIAG_PARAMS*      pParams,
    IN OUT NETDIAG_RESULT*  pResults,
    IN PTESTED_DOMAIN       TestedDomain
    );

BOOL
GetDcListFromSam(
    IN NETDIAG_PARAMS*  pParams,
    IN OUT  NETDIAG_RESULT*  pResults,
    IN PTESTED_DOMAIN   TestedDomain
    );

NET_API_STATUS
GetBrowserServerList(
    IN PUNICODE_STRING TransportName,
    IN LPCWSTR Domain,
    OUT LPWSTR *BrowserList[],
    OUT PULONG BrowserListLength,
    IN BOOLEAN ForceRescan
    );

NET_API_STATUS
EnumServersForTransport(
    IN PUNICODE_STRING TransportName,
    IN LPCWSTR DomainName OPTIONAL,
    IN ULONG level,
    IN ULONG prefmaxlen,
    IN ULONG servertype,
    IN LPWSTR CurrentComputerName,
    OUT PINTERIM_SERVER_LIST InterimServerList,
    OUT PULONG TotalEntriesOnThisTransport,
    IN LPCWSTR FirstNameToReturn,
    IN BOOLEAN WannishTransport,
    IN BOOLEAN RasTransport,
    IN BOOLEAN IpxTransport
    );
NET_API_STATUS NET_API_FUNCTION
LocalNetServerEnumEx(
    IN  LPCWSTR     servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPCWSTR     domain OPTIONAL,
    IN  LPCWSTR     FirstNameToReturnArg OPTIONAL,
    IN  NETDIAG_PARAMS *pParams,
    IN OUT NETDIAG_RESULT *pResults
    );
BOOL GetDcListFromDc(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults,
                     IN PTESTED_DOMAIN TestedDomain);


HRESULT
DcListTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
/*++

Routine Description:

    This test builds a list of all the DCs in the tested domains.

Arguments:

    None.

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    HRESULT hrRetVal = S_OK;
    PTESTED_DOMAIN pTestedDomain = (PTESTED_DOMAIN) pParams->pDomain;
    NET_API_STATUS NetStatus;

    PSERVER_INFO_101 ServerInfo101 = NULL;
    DWORD EntriesRead;
    DWORD TotalEntries;
    PTESTED_DC TestedDc = NULL;
    PLIST_ENTRY ListEntry;

    ULONG i;

    PrintStatusMessage(pParams, 0, IDS_DCLIST_STATUS_MSG, pTestedDomain->PrintableDomainName);

    //if the machine is a member machine or DC, DcListTest will get called. 
    //Otherwise, DcList test will be skipped
    pResults->DcList.fPerformed = TRUE;

    //the Dclist test will be called for every domain, but we only want to initialize
    //the message list once.
    if(pResults->DcList.lmsgOutput.Flink == NULL)       
        InitializeListHead( &pResults->DcList.lmsgOutput );

    //
    // First try getting the list of DCs from the DS
    //

    if ( !GetDcListFromDs( pParams, pResults, pTestedDomain ) ) {
        pResults->DcList.hr = S_FALSE;
        hrRetVal = S_FALSE;
    }

    //
    // If that failed,
    //  then try using the browser.
    //

    if( FHrOK(pResults->DcList.hr) )
    {
        if ( pTestedDomain->NetbiosDomainName ) 
        {
            NetStatus = LocalNetServerEnumEx(
                            NULL,
                            101,
                            (LPBYTE *)&ServerInfo101,
                            MAX_PREFERRED_LENGTH,
                            &EntriesRead,
                            &TotalEntries,
                            SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL,
                            pTestedDomain->NetbiosDomainName,
                            NULL,       // Resume handle
                            pParams,
                            pResults);

            if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA )
            {
                // "NetServerEnum failed. [%s]\n"
                SetMessage(&pResults->DcList.msgErr, Nd_Quiet,
                           IDS_DCLIST_NETSERVERENUM_FAILED, NetStatusToString(NetStatus));
                pResults->DcList.hr = HResultFromWin32(NetStatus);
                hrRetVal = S_FALSE;
                goto LERROR;
            }

            for ( i=0; i<EntriesRead; i++ )
            {
                //
                // Skip non-NT entries
                //

                if ( (ServerInfo101[i].sv101_type & SV_TYPE_NT) == 0 ) {
                    continue;
                }

                AddTestedDc( pParams,
                             pResults,
                             pTestedDomain,
                             ServerInfo101[i].sv101_name,
                             ServerInfo101[i].sv101_version_major >= 5 ?
                             DC_IS_NT5 :
                             DC_IS_NT4 );
            }
        }
        else
        {
            if ( pParams->fDebugVerbose )
            {
                // "'%ws' is not a Netbios domain name.  Cannot use NetServerEnum to find DCs\n"
                PrintMessage(pParams, IDS_DCLIST_NOT_A_NETBIOS_DOMAIN,
                             pTestedDomain->PrintableDomainName);
            }
        }
    }

    //
    // If we're really interested,
    //  get a list from SAM on the discovered DC.
    //  (But it's really slow)
    //

    if ( pParams->fDcAccountEnum ) {
        if ( !GetDcListFromSam( pParams, pResults, pTestedDomain ) ) {
            pResults->DcList.hr = S_FALSE;
            hrRetVal = S_FALSE;
        }
    }

LERROR:

    return hrRetVal;
}



NET_API_STATUS
GetBrowserServerList(
    IN PUNICODE_STRING TransportName,
    IN LPCWSTR Domain,
    OUT LPWSTR *BrowserList[],
    OUT PULONG BrowserListLength,
    IN BOOLEAN ForceRescan
    )
/*++

Routine Description:

    This function will return a list of browser servers.

Arguments:

    IN PUNICODE_STRING TransportName - Transport to return list.


Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{


    NET_API_STATUS Status;
    HANDLE BrowserHandle;
    PLMDR_REQUEST_PACKET RequestPacket = NULL;

//    DbgPrint("Getting browser server list for transport %wZ\n", TransportName);

    Status = OpenBrowser(&BrowserHandle);

    if (Status != NERR_Success) {
        return Status;
    }

    RequestPacket = Malloc( sizeof(LMDR_REQUEST_PACKET)+(DNLEN*sizeof(WCHAR))+TransportName->MaximumLength);
    if (RequestPacket == NULL) {
        NtClose(BrowserHandle);
        return(GetLastError());
    }

    ZeroMemory( RequestPacket, sizeof(LMDR_REQUEST_PACKET)+(DNLEN*sizeof(WCHAR))+TransportName->MaximumLength );

    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket->Level = 0;

    RequestPacket->Parameters.GetBrowserServerList.ForceRescan = ForceRescan;

    if (Domain != NULL)
    {
        wcscpy(RequestPacket->Parameters.GetBrowserServerList.DomainName, Domain);

        RequestPacket->Parameters.GetBrowserServerList.DomainNameLength = (USHORT)wcslen(Domain) * sizeof(WCHAR);
    }
    else
    {
        RequestPacket->Parameters.GetBrowserServerList.DomainNameLength = 0;
        RequestPacket->Parameters.GetBrowserServerList.DomainName[0] = L'\0';

    }

    RequestPacket->TransportName.Buffer = (PWSTR)((PCHAR)RequestPacket+sizeof(LMDR_REQUEST_PACKET)+DNLEN*sizeof(WCHAR));
    RequestPacket->TransportName.MaximumLength = TransportName->MaximumLength;

    RtlCopyUnicodeString(&RequestPacket->TransportName, TransportName);
    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, NULL );

    RequestPacket->Parameters.GetBrowserServerList.ResumeHandle = 0;

    Status = DeviceControlGetInfo(
                BrowserHandle,
                IOCTL_LMDR_GET_BROWSER_SERVER_LIST,
                RequestPacket,
                sizeof(LMDR_REQUEST_PACKET)+
                    (DNLEN*sizeof(WCHAR))+TransportName->MaximumLength,
                (PVOID *)BrowserList,
                0xffffffff,
                4096,
                NULL);

    if (Status == NERR_Success)
    {
        *BrowserListLength = RequestPacket->Parameters.GetBrowserServerList.EntriesRead;
    }

    NtClose(BrowserHandle);
    Free(RequestPacket);

    return Status;
}




#define API_SUCCESS(x)  ((x) == NERR_Success || (x) == ERROR_MORE_DATA)
NET_API_STATUS
EnumServersForTransport(
    IN PUNICODE_STRING TransportName,
    IN LPCWSTR DomainName OPTIONAL,
    IN ULONG level,
    IN ULONG prefmaxlen,
    IN ULONG servertype,
    IN LPWSTR CurrentComputerName,
    OUT PINTERIM_SERVER_LIST InterimServerList,
    OUT PULONG TotalEntriesOnThisTransport,
    IN LPCWSTR FirstNameToReturn,
    IN BOOLEAN WannishTransport,
    IN BOOLEAN RasTransport,
    IN BOOLEAN IpxTransport
    )
{
    PWSTR *BrowserList = NULL;
    ULONG BrowserListLength = 0;
    NET_API_STATUS Status;
    PVOID ServerList = NULL;
    ULONG EntriesInList = 0;
    ULONG ServerIndex = 0;

    //
    //  Skip over IPX transports - we can't contact machines over them anyway.
    //

    *TotalEntriesOnThisTransport = 0;

    if (IpxTransport) {
        return NERR_Success;
    }

    //
    //  Retrieve a new browser list.  Do not force a revalidation.
    //

    Status = GetBrowserServerList(TransportName,
                                    DomainName,
                                    &BrowserList,
                                    &BrowserListLength,
                                    FALSE);

    //
    //  If a domain name was specified and we were unable to find the browse
    //  master for the domain and we are running on a wannish transport,
    //  invoke the "double hop" code and allow a local browser server
    //  remote the API to the browse master for that domain (we assume that
    //  this means that the workgroup is on a different subnet of a WAN).
    //

    if (!API_SUCCESS(Status) &&
        DomainName != NULL) {

        Status = GetBrowserServerList(TransportName,
                                    NULL,
                                    &BrowserList,
                                    &BrowserListLength,
                                    FALSE);


    }


    //
    //  If we were able to retrieve the list, remote the API.  Otherwise
    //  return.
    //

    if (API_SUCCESS(Status)) {

        do {
            LPWSTR Transport;
            LPWSTR ServerName;
            BOOL AlreadyInTree;

            //
            // Remote the API to that server.
            //

            Transport = TransportName->Buffer;
            ServerName = BrowserList[0];
            *TotalEntriesOnThisTransport = 0;

                Status = RxNetServerEnum(
                             ServerName,
                             Transport,
                             level,
                             (LPBYTE *)&ServerList,
                             prefmaxlen,
                             &EntriesInList,
                             TotalEntriesOnThisTransport,
                             servertype,
                             DomainName,
                             FirstNameToReturn );



            if ( !API_SUCCESS(Status)) {
                NET_API_STATUS GetBListStatus;

                //
                //  If we failed to remote the API for some reason,
                //  we want to regenerate the bowsers list of browser
                //  servers.
                //

                if (BrowserList != NULL) {

                    LocalFree(BrowserList);

                    BrowserList = NULL;
                }


                GetBListStatus = GetBrowserServerList(TransportName,
                                                            DomainName,
                                                            &BrowserList,
                                                            &BrowserListLength,
                                                            TRUE);
                if (GetBListStatus != NERR_Success) {

                    //
                    //  If we were unable to reload the list,
                    //  try the next transport.
                    //

                    break;
                }

                ServerIndex += 1;

                //
                //  If we've looped more times than we got servers
                //  in the list, we're done.
                //

                if ( ServerIndex > BrowserListLength ) {
                    break;
                }

            } else {

                NET_API_STATUS TempStatus;
                TempStatus = MergeServerList(
                                        InterimServerList,
                                        level,
                                        ServerList,
                                        EntriesInList,
                                        *TotalEntriesOnThisTransport );

                if ( TempStatus != NERR_Success ) {
                    Status = TempStatus;
                }

                //
                //  The remote API succeeded.
                //
                //  Now free up the remaining parts of the list.
                //

                if (ServerList != NULL) {
                    NetApiBufferFree(ServerList);
                    ServerList = NULL;
                }

                // We're done regardless of the success or failure of MergeServerList.
                break;

            }

        } while ( !API_SUCCESS(Status) );

    }

    //
    //  Free up the browser list.
    //

    if (BrowserList != NULL) {
        LocalFree(BrowserList);
        BrowserList = NULL;
    }

    return Status;
}


NET_API_STATUS NET_API_FUNCTION
LocalNetServerEnumEx(
    IN  LPCWSTR     servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPCWSTR     domain OPTIONAL,
    IN  LPCWSTR     FirstNameToReturnArg OPTIONAL,
    IN  NETDIAG_PARAMS *pParams,
    IN OUT NETDIAG_RESULT *pResults
    )
/*++

Routine Description:

    This is identical to the real NetServerEnumEx except it only uses the
    Netbt transport that the nettest utility has found.

Arguments:

    servername - Supplies the name of server to execute this function

    level - Supplies the requested level of information.

    bufptr - Returns a pointer to a buffer which contains the
        requested transport information.

    prefmaxlen - Supplies the number of bytes of information
        to return in the buffer.  If this value is MAXULONG, we will try
        to return all available information if there is enough memory
        resource.

    entriesread - Returns the number of entries read into the buffer.  This
        value is returned only if the return code is NERR_Success or
        ERROR_MORE_DATA.

    totalentries - Returns the total number of entries available.  This value
        is returned only if the return code is NERR_Success or ERROR_MORE_DATA.

    servertype - Supplies the type of server to enumerate.

    domain - Supplies the name of one of the active domains to enumerate the
        servers from.  If NULL, servers from the primary domain, logon domain
        and other domains are enumerated.

    FirstNameToReturnArg - Supplies the name of the first domain or server entry to return.
        The caller can use this parameter to implement a resume handle of sorts by passing
        the name of the last entry returned on a previous call.  (Notice that the specified
        entry will, also, be returned on this call unless it has since been deleted.)
        Pass NULL (or a zero length string) to start with the first entry available.


Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

    ERROR_MORE_DATA - More servers are available to be enumerated.

        It is possible to return ERROR_MORE_DATA and zero entries in the case
        where the browser server used doesn't support enumerating all the entries
        it has. (e.g., an NT 3.5x Domain Master Browser that downloaded a domain
        list from WINS and the WINS list is more than 64Kb long.) The caller
        should simply ignore the additional data.

        It is possible to fail to return ERROR_MORE_DATA and return a truncated
        list.  (e.g., an NT 3.5x Backup browser or WIN 95 backup browser in the
        above mentioned domain.  Such a backup browser replicates only 64kb
        of data from the DMB (PDC) then represents that list as the entire list.)
        The caller should ignore this problem.  The site should upgrade its
        browser servers.

--*/
{
    INTERIM_SERVER_LIST InterimServerList;
    NET_API_STATUS Status;
    DWORD DomainNameSize = 0;
    WCHAR DomainName[DNLEN + 1];
    WCHAR FirstNameToReturn[DNLEN+1];
    DWORD LocalTotalEntries;
    BOOLEAN AnyTransportHasMoreData = FALSE;


    //
    // Canonicalize the input parameters to make later comparisons easier.
    //

    if (ARGUMENT_PRESENT(domain)) {

        if ( I_NetNameCanonicalize(
                          NULL,
                          (LPWSTR) domain,
                          DomainName,
                          (DNLEN + 1) * sizeof(WCHAR),
                          NAMETYPE_WORKGROUP,
                          LM2X_COMPATIBLE
                          ) != NERR_Success) {
            return ERROR_INVALID_PARAMETER;
        }

        DomainNameSize = wcslen(DomainName) * sizeof(WCHAR);

        domain = DomainName;
    }

    if (ARGUMENT_PRESENT(FirstNameToReturnArg)  && *FirstNameToReturnArg != L'\0') {

        if ( I_NetNameCanonicalize(
                          NULL,
                          (LPWSTR) FirstNameToReturnArg,
                          FirstNameToReturn,
                          sizeof(FirstNameToReturn),
                          NAMETYPE_WORKGROUP,
                          LM2X_COMPATIBLE
                          ) != NERR_Success) {
            return ERROR_INVALID_PARAMETER;
        }

    } else {
        FirstNameToReturn[0] = L'\0';
    }

    if ((servername != NULL) &&
        ( *servername != L'\0')) {

        //
        // Call downlevel version of the API
        //

        Status = RxNetServerEnum(
                     servername,
                     NULL,
                     level,
                     bufptr,
                     prefmaxlen,
                     entriesread,
                     totalentries,
                     servertype,
                     domain,
                     FirstNameToReturn );

        return Status;
    }

    //
    // Only levels 100 and 101 are valid
    //

    if ((level != 100) && (level != 101)) {
        return ERROR_INVALID_LEVEL;
    }

    if (servertype != SV_TYPE_ALL) {
        if (servertype & SV_TYPE_DOMAIN_ENUM) {
            if (servertype != SV_TYPE_DOMAIN_ENUM) {
                return ERROR_INVALID_FUNCTION;
            }
        }
    }

    //
    //  Initialize the buffer to a known value.
    //

    *bufptr = NULL;

    *entriesread = 0;

    *totalentries = 0;


    Status = InitializeInterimServerList(&InterimServerList, NULL, NULL, NULL, NULL);

    try {
        BOOL AnyEnumServersSucceeded = FALSE;
        LPWSTR MyComputerName = NULL;
        PLIST_ENTRY ListEntry;
        PNETBT_TRANSPORT NetbtTransport;

        Status = NetpGetComputerName( &MyComputerName);

        if ( Status != NERR_Success ) {
            goto try_exit;
        }

        //
        // Loop through the list of netbt transports browsing on each one
        //

        for ( ListEntry = pResults->NetBt.Transports.Flink ;
              ListEntry != &pResults->NetBt.Transports ;
              ListEntry = ListEntry->Flink ) {

            UNICODE_STRING TransportName;

            //
            // If the transport names match,
            //  return the entry
            //

            NetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

            if ( (NetbtTransport->Flags & BOUND_TO_BOWSER) == 0 ) {
                continue;
            }

            RtlInitUnicodeString( &TransportName, NetbtTransport->pswzTransportName );

            Status = EnumServersForTransport(&TransportName,
                                             domain,
                                             level,
                                             prefmaxlen,
                                             servertype,
                                             MyComputerName,
                                             &InterimServerList,
                                             &LocalTotalEntries,
                                             FirstNameToReturn,
                                             FALSE,
                                             FALSE,
                                             FALSE );

            if (API_SUCCESS(Status)) {
                if ( Status == ERROR_MORE_DATA ) {
                    AnyTransportHasMoreData = TRUE;
                }
                AnyEnumServersSucceeded = TRUE;
                if ( LocalTotalEntries > *totalentries ) {
                    *totalentries = LocalTotalEntries;
                }
            }

        }

        if ( MyComputerName != NULL ) {
            (void) NetApiBufferFree( MyComputerName );
        }

        if (AnyEnumServersSucceeded) {

            //
            //  Pack the interim server list into its final form.
            //

            Status = PackServerList(&InterimServerList,
                            level,
                            servertype,
                            prefmaxlen,
                            (PVOID *)bufptr,
                            entriesread,
                            &LocalTotalEntries,  // Pack thinks it has ALL the entries
                            NULL ); // The server has already returned us the right entries

            if ( API_SUCCESS( Status ) ) {
                if ( LocalTotalEntries > *totalentries ) {
                    *totalentries = LocalTotalEntries;
                }
            }
        }

try_exit:NOTHING;
    } finally {
        UninitializeInterimServerList(&InterimServerList);
    }

    if ( API_SUCCESS( Status )) {

        //
        // At this point,
        //  *totalentries is the largest of:
        //      The TotalEntries returned from any transport.
        //      The actual number of entries read.
        //
        // Adjust TotalEntries returned for reality.
        //

        if ( Status == NERR_Success ) {
            *totalentries = *entriesread;
        } else {
            if ( *totalentries <= *entriesread ) {
                *totalentries = *entriesread + 1;
            }
        }

        //
        // Ensure we return ERROR_MORE_DATA if any transport has more data.
        //

        if ( AnyTransportHasMoreData ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return Status;
}



BOOL
GetDcListFromDs(
    IN NETDIAG_PARAMS*      pParams,
    IN OUT NETDIAG_RESULT*  pResults,
    IN PTESTED_DOMAIN       TestedDomain
    )
/*++

Routine Description:

    Get a list of DCs in this domain from the DS on an up DC.

Arguments:

    TestedDomain - Domain to get the DC list for

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS NetStatus;
    PDS_DOMAIN_CONTROLLER_INFO_1W DcInfo = NULL;
    HANDLE DsHandle = NULL;
    DWORD DcCount;
    BOOL RetVal = TRUE;
    ULONG i;
    const WCHAR c_szDcPrefix[] = L"\\\\";
    LPWSTR pwszDcName;
	LPTSTR pszDcType;

    PTESTED_DC TestedDc;

    //
    // Get a DC to seed the algorithm with
    //

    if ( TestedDomain->DcInfo == NULL ) {

        if ( TestedDomain->fTriedToFindDcInfo ) {
            //"    '%ws': Cannot find DC to get DC list from.\n" 
            AddMessageToList(&pResults->DcList.lmsgOutput, Nd_Quiet, IDS_DCLIST_NO_DC, 
                         TestedDomain->PrintableDomainName );
            RetVal = FALSE;
            goto Cleanup;
        }

		pszDcType = LoadAndAllocString(IDS_DCTYPE_DC);

        NetStatus = DoDsGetDcName( pParams,
                                   pResults,
                                   &pResults->DcList.lmsgOutput,
                                   TestedDomain,
                                   DS_DIRECTORY_SERVICE_PREFERRED,
                                   pszDcType,
                                   FALSE,
                                   &TestedDomain->DcInfo );

		Free(pszDcType);

        TestedDomain->fTriedToFindDcInfo = TRUE;

        if ( NetStatus != NO_ERROR ) {
             //"    '%ws': Cannot find DC to get DC list from.\n" 
             AddMessageToList(&pResults->DcList.lmsgOutput, Nd_Quiet, IDS_DCLIST_NO_DC);
             AddIMessageToList(&pResults->DcList.lmsgOutput, Nd_Quiet, 4, 
                                  IDS_GLOBAL_STATUS, NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;
        }
    }

    // if the DC doesn't support DS, we should not try to call DsBindW()
    if (!(TestedDomain->DcInfo->Flags & DS_DS_FLAG))
        goto Cleanup;

    //
    // Get a DC that's UP.
    //

    TestedDc = GetUpTestedDc( TestedDomain );

    if ( TestedDc == NULL ) {
        //IDS_DCLIST_NO_DC_UP   "    '%ws': No DCs are up.\n"
        AddMessageToList(&pResults->DcList.lmsgOutput, Nd_Quiet, IDS_DCLIST_NO_DC_UP,
               TestedDomain->PrintableDomainName );
        PrintGuruMessage2("    '%ws': No DCs are up.\n", TestedDomain->PrintableDomainName );
        PrintGuru( 0, DSGETDC_GURU );
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Bind to the target DC
    //

    pwszDcName = Malloc((wcslen(TestedDc->ComputerName) + wcslen(c_szDcPrefix) + 1) * sizeof(WCHAR));
    if (pwszDcName == NULL)
    {
        DebugMessage("Out of Memory!");
        RetVal = FALSE;
        goto Cleanup;
    }
    wcscpy(pwszDcName, c_szDcPrefix);

	assert(TestedDc->ComputerName);

	if (TestedDc->ComputerName)
	{
		wcscat(pwszDcName, TestedDc->ComputerName);	
	}
    
    NetStatus = DsBindW( pwszDcName,
                         NULL,
                         &DsHandle );

    Free(pwszDcName);

    if ( NetStatus != NO_ERROR ) {

        //
        // Only warn if we don't have access
        //

        if ( NetStatus == ERROR_ACCESS_DENIED ) {
            //IDS_DCLIST_NO_ACCESS_DSBIND   "        You don't have access to DsBind to %ws (%ws) (Trying NetServerEnum). [%s]\n"
            AddMessageToList(&pResults->DcList.lmsgOutput, Nd_ReallyVerbose, IDS_DCLIST_NO_ACCESS_DSBIND,
                   TestedDc->NetbiosDcName,
                   TestedDc->DcIpAddress,
                   NetStatusToString(NetStatus));
        } else {
            //IDS_DCLIST_ERR_DSBIND     "    [WARNING] Cannot call DsBind to %ws (%ws). [%s]\n"
            AddMessageToList(&pResults->DcList.lmsgOutput, Nd_Quiet, IDS_DCLIST_ERR_DSBIND,
                   TestedDc->ComputerName,
                   TestedDc->DcIpAddress,
                   NetStatusToString(NetStatus));
            PrintGuruMessage3("    [WARNING] Cannot call DsBind to %ws (%ws).\n",
                   TestedDc->NetbiosDcName,
                   TestedDc->DcIpAddress );
            PrintGuru( NetStatus, DS_GURU );
        }
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Get the list of DCs from the target DC.
    //
    NetStatus = DsGetDomainControllerInfoW(
                    DsHandle,
                    TestedDomain->DnsDomainName != NULL ?
                        TestedDomain->DnsDomainName :
                        TestedDomain->NetbiosDomainName,
                    1,      // Info level
                    &DcCount,
                    &DcInfo );

    if ( NetStatus != NO_ERROR ) {
        //IDS_DCLIST_ERR_GETDCINFO      "    [WARNING] Cannot call DsGetDomainControllerInfoW to %ws (%ws). [%s]\n"
        AddMessageToList( &pResults->DcList.lmsgOutput, Nd_Quiet, IDS_DCLIST_ERR_GETDCINFO,
               TestedDc->NetbiosDcName,
               TestedDc->DcIpAddress, NetStatusToString(NetStatus) );
        PrintGuruMessage3("    [WARNING] Cannot call DsGetDomainControllerInfoW to %ws (%ws).",
               TestedDc->NetbiosDcName,
               TestedDc->DcIpAddress );
        PrintGuru( NetStatus, DS_GURU );
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Loop though the list of DCs.
    //

    if(pParams->fDebugVerbose)
    {
        // IDS_DCLIST_DCS   "   DC list for domain %ws:\n"
        PrintMessage(pParams, IDS_DCLIST_DCS, TestedDomain->PrintableDomainName);
    }

    for ( i=0; i<DcCount; i++ ) 
    {
        if ( pParams->fDebugVerbose ) 
        {

            //IDS_DCLIST_13421                  "        %ws" 
            PrintMessage(pParams, IDS_DCLIST_13421,
                   DcInfo[i].DnsHostName != NULL ?
                        DcInfo[i].DnsHostName :
                        DcInfo[i].NetbiosName );
            if ( DcInfo[i].fIsPdc ) {
                //IDS_DCLIST_13422                  " [PDC emulator]" 
				//if is NT4 DC, just say PDC
                PrintMessage(pParams, DcInfo[i].fDsEnabled ? IDS_DCLIST_13422 : IDS_DCLIST_NT4_PDC);
            }
            if ( DcInfo[i].fDsEnabled ) {
                //IDS_DCLIST_13423                  " [DS]" 
                PrintMessage(pParams, IDS_DCLIST_13423);
            }
            if ( DcInfo[i].SiteName != NULL ) {
                //IDS_DCLIST_13424                  " Site: %ws" 
                PrintMessage(pParams, IDS_DCLIST_13424, DcInfo[i].SiteName );
            }
            //IDS_DCLIST_13425                  "\n" 
            PrintMessage(pParams, IDS_DCLIST_13425);
        }

        //
        // Add this DC to the list of DCs to test.
        //
        AddTestedDc( pParams,
                     pResults,
                     TestedDomain,
                     DcInfo[i].DnsHostName != NULL ?
                         DcInfo[i].DnsHostName :
                         DcInfo[i].NetbiosName,
                     DcInfo[i].fDsEnabled ?
                            DC_IS_NT5 :
                            DC_IS_NT4 );
    }


    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( DcInfo != NULL ) {
        DsFreeDomainControllerInfoW( 1, DcCount, DcInfo );
    }

    if ( DsHandle != NULL ) {
        DsUnBindW( &DsHandle );
    }
    return RetVal;
}


BOOL
GetDcListFromSam(
    IN NETDIAG_PARAMS*  pParams,
    IN OUT  NETDIAG_RESULT*  pResults,
    IN PTESTED_DOMAIN   TestedDomain
    )
/*++

Routine Description:

    Get a list of DCs in this domain from SAM on the current DC.

Arguments:

    TestedDomain - Domain to get the DC list for

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    BOOL RetVal = TRUE;

    SAM_HANDLE LocalSamHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;

    LSA_HANDLE  LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES LSAObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;

    PDOMAIN_DISPLAY_MACHINE MachineInformation = NULL;
    NTSTATUS SamStatus;
    ULONG SamIndex;
	LPTSTR pszDcType;

    //
    // Get a DC to seed the algorithm with
    //

    if ( TestedDomain->DcInfo == NULL ) {

        if ( TestedDomain->fTriedToFindDcInfo ) {
            if(pParams->fDebugVerbose)
            {
                //IDS_DCLIST_13426                  "        Cannot find DC to get DC list from (Test skipped).\n" 
                PrintMessage(pParams, IDS_DCLIST_13426 );
            }
            goto Cleanup;
        }

		pszDcType = LoadAndAllocString(IDS_DCTYPE_DC);
        NetStatus = DoDsGetDcName( pParams,
                                   pResults,
                                   &pResults->DcList.lmsgOutput,
                                   TestedDomain,
                                   DS_DIRECTORY_SERVICE_PREFERRED,
                                   pszDcType,
                                   FALSE,
                                   &TestedDomain->DcInfo );
		Free(pszDcType);

        TestedDomain->fTriedToFindDcInfo = TRUE;

        if ( NetStatus != NO_ERROR ) {
            if(pParams->fDebugVerbose)
            {
                //IDS_DCLIST_13427                  "    Cannot find DC to get DC list from (Test skipped). [%s]\n" 
                PrintMessage(pParams, IDS_DCLIST_13427, NetStatusToString(NetStatus) );
                PrintMessage(pParams, IDS_GLOBAL_STATUS, NetStatusToString( NetStatus ));
            }
            goto Cleanup;
        }
    }

    if ( pParams->fReallyVerbose ) {
//IDS_DCLIST_13428                  "    Get list of DC accounts from SAM in domain '%ws'.\n" 
        PrintMessage(pParams, IDS_DCLIST_13428, TestedDomain->PrintableDomainName);
    }


    //
    // Connect to the SAM server
    //

    Status = NettestSamConnect( pParams,
                TestedDomain->DcInfo->DomainControllerName,
                &LocalSamHandle );

    if ( !NT_SUCCESS(Status)) {
        if ( Status == STATUS_ACCESS_DENIED ) {
            RetVal = FALSE;
        }
        goto Cleanup;
    }

    //
    // If we don't have a domain sid,
    //  find out what it is.
    //

    if ( TestedDomain->DomainSid == NULL ) {
        UNICODE_STRING ServerNameString;


        //
        // Open LSA to read account domain info.
        //

        InitializeObjectAttributes( &LSAObjectAttributes,
                                      NULL,             // Name
                                      0,                // Attributes
                                      NULL,             // Root
                                      NULL );           // Security Descriptor

        RtlInitUnicodeString( &ServerNameString, TestedDomain->DcInfo->DomainControllerName );

        Status = LsaOpenPolicy( &ServerNameString,
                                &LSAObjectAttributes,
                                POLICY_VIEW_LOCAL_INFORMATION,
                                &LSAPolicyHandle );

        if( !NT_SUCCESS(Status) ) {
            if(pParams->fDebugVerbose)
            {
                //IDS_DCLIST_13429                  "    [FATAL] Cannot LsaOpenPolicy to LSA on '%ws'." 
                PrintMessage(pParams, IDS_DCLIST_13429, TestedDomain->DcInfo->DomainControllerName );
            }
            PrintGuruMessage2("    [FATAL] Cannot LsaOpenPolicy to LSA on '%ws'." , TestedDomain->DcInfo->DomainControllerName );
            PrintGuru( NetpNtStatusToApiStatus( Status ), LSA_GURU );
            RetVal = FALSE;
            goto Cleanup;
        }


        //
        // Now read account domain info from LSA.
        //

        Status = LsaQueryInformationPolicy(
                        LSAPolicyHandle,
                        PolicyAccountDomainInformation,
                        (PVOID *) &AccountDomainInfo );

        if( !NT_SUCCESS(Status) ) {
            AccountDomainInfo = NULL;
            if(pParams->fDebugVerbose)
            {
                //IDS_DCLIST_13430                  "    [FATAL] Cannot LsaQueryInformationPolicy (AccountDomainInfor) to LSA on '%ws'." 
                PrintMessage(pParams, IDS_DCLIST_13430, TestedDomain->DcInfo->DomainControllerName );
            }
            PrintGuruMessage2("    [FATAL] Cannot LsaQueryInformationPolicy (AccountDomainInfor) to LSA on '%ws'.", TestedDomain->DcInfo->DomainControllerName );
            PrintGuru( NetpNtStatusToApiStatus( Status ), LSA_GURU );
            RetVal = FALSE;
            goto Cleanup;
        }

        //
        // Save the domain sid for other tests
        //

        pResults->Global.pMemberDomain->DomainSid =
            Malloc( RtlLengthSid( AccountDomainInfo->DomainSid ) );

        if ( pResults->Global.pMemberDomain->DomainSid == NULL ) {
            //IDS_DCLIST_13431                  "Out of memory\n" 
            PrintMessage(pParams, IDS_DCLIST_13431);
            RetVal = FALSE;
            goto Cleanup;
        }

        RtlCopyMemory( pResults->Global.pMemberDomain->DomainSid,
                       AccountDomainInfo->DomainSid,
                       RtlLengthSid( AccountDomainInfo->DomainSid ) );

        if ( pParams->fReallyVerbose ) {
            //IDS_DCLIST_13432                  "    Domain Sid:          " 
            PrintMessage(pParams, IDS_DCLIST_13432);
            PrintSid( pParams, pResults->Global.pMemberDomain->DomainSid );
        }
    }

    //
    // Open the domain.
    //

    Status = SamOpenDomain( LocalSamHandle,
                            DOMAIN_LIST_ACCOUNTS |
                                DOMAIN_LOOKUP,
                            pResults->Global.pMemberDomain->DomainSid,
                            &DomainHandle );

    if ( !NT_SUCCESS( Status ) ) {
        if(pParams->fDebugVerbose)
        {
            //IDS_DCLIST_13433                  "    [FATAL] Cannot SamOpenDomain on '%ws'." 
            PrintMessage(pParams, IDS_DCLIST_13433, TestedDomain->DcInfo->DomainControllerName );
        }
        PrintGuruMessage2("    [FATAL] Cannot SamOpenDomain on '%ws'.", TestedDomain->DcInfo->DomainControllerName );
        PrintGuru( NetpNtStatusToApiStatus( Status ), SAM_GURU );
        RetVal = FALSE;
        goto Cleanup;
    }



    //
    // Loop building a list of DC names from SAM.
    //
    // On each iteration of the loop,
    //  get the next several machine accounts from SAM.
    //  determine which of those names are DC names.
    //  Merge the DC names into the list we're currently building of all DCs.
    //

    SamIndex = 0;
    do {
        //
        // Arguments to SamQueryDisplayInformation
        //
        ULONG TotalBytesAvailable;
        ULONG BytesReturned;
        ULONG EntriesRead;

        DWORD i;

        //
        // Get the list of machine accounts from SAM
        //

        SamStatus = SamQueryDisplayInformation (
                        DomainHandle,
                        DomainDisplayMachine,
                        SamIndex,
                        4096,   // Machines per pass
                        0xFFFFFFFF, // PrefMaxLen
                        &TotalBytesAvailable,
                        &BytesReturned,
                        &EntriesRead,
                        &MachineInformation );

        if ( !NT_SUCCESS(SamStatus) ) {
            Status = SamStatus;
            if(pParams->fDebugVerbose)
            {
                //IDS_DCLIST_13434                  "    [FATAL] Cannot SamQueryDisplayInformation on '%ws'." 
                PrintMessage(pParams, IDS_DCLIST_13434, TestedDomain->DcInfo->DomainControllerName );
            }
            PrintGuruMessage2("    [FATAL] Cannot SamQueryDisplayInformation on '%ws'.", TestedDomain->DcInfo->DomainControllerName );
            PrintGuru( NetpNtStatusToApiStatus( Status ), SAM_GURU );
            RetVal = FALSE;
            goto Cleanup;
        }

        //
        // Set up for the next call to Sam.
        //

        if ( SamStatus == STATUS_MORE_ENTRIES ) {
            SamIndex = MachineInformation[EntriesRead-1].Index;
        }


        //
        // Loop though the list of machine accounts finding the Server accounts.
        //

        for ( i=0; i<EntriesRead; i++ ) {

            //
            // Ensure the machine account is a server account.
            //

            if ( MachineInformation[i].AccountControl &
                    USER_SERVER_TRUST_ACCOUNT ) {
                WCHAR LocalComputerName[CNLEN+1];
                ULONG LocalComputerNameLength;


                //
                // Insert the server session.
                //
                if(pParams->fDebugVerbose)
                {
                    //IDS_DCLIST_13435                  "%wZ %ld\n" 
                    PrintMessage(pParams,  IDS_DCLIST_13435, &MachineInformation[i].Machine, MachineInformation[i].Rid );
                }

                LocalComputerNameLength =
                        min( MachineInformation[i].Machine.Length/sizeof(WCHAR) - 1,
                             CNLEN );
                RtlCopyMemory( LocalComputerName,
                               MachineInformation[i].Machine.Buffer,
                               LocalComputerNameLength * sizeof(WCHAR) );
                LocalComputerName[LocalComputerNameLength] = '\0';

                AddTestedDc( pParams,
                             pResults,
                             TestedDomain, LocalComputerName, 0 );

            }
        }

        //
        // Free the buffer returned from SAM.
        //

        if ( MachineInformation != NULL ) {
            SamFreeMemory( MachineInformation );
            MachineInformation = NULL;
        }

    } while ( SamStatus == STATUS_MORE_ENTRIES );


    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( DomainHandle != NULL ) {
        (VOID) SamCloseHandle( DomainHandle );
    }
    if ( AccountDomainInfo != NULL ) {
        LsaFreeMemory( AccountDomainInfo );
        AccountDomainInfo = NULL;
    }

    if ( LocalSamHandle != NULL ) {
        (VOID) SamCloseHandle( LocalSamHandle );
    }

    if( LSAPolicyHandle != NULL ) {
        LsaClose( LSAPolicyHandle );
    }

    return RetVal;
}


//(nsun) _delete
/*
BOOL
GetDcListFromDc(
                IN NETDIAG_PARAMS *pParams,
                IN OUT NETDIAG_RESULT *pResults,
                IN PTESTED_DOMAIN pTestedDomain
    )
*++

Routine Description:

    Get a list of DCs in this domain from the current DC.

Arguments:

    pTestedDomain - Domain to get the DC list for

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    BOOL RetVal = TRUE;

    SAM_HANDLE LocalSamHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;

    LSA_HANDLE  LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES LSAObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    
    PDOMAIN_DISPLAY_MACHINE MachineInformation = NULL;
    NTSTATUS SamStatus;
    ULONG SamIndex;
    
    LPWSTR LocalShareName = NULL;
    PTESTED_DC  pTestedDC;

    //
    // Get a DC to seed the algorithm with
    //

    if ( pTestedDomain->DcInfo == NULL )
    {

        NetStatus = GetADc( pParams,
                            pResults,
                            DsGetDcNameW,
                            pTestedDomain,
                            DS_DIRECTORY_SERVICE_PREFERRED,
                            &pTestedDomain->DcInfo );

        if ( NetStatus != NO_ERROR )
        {
//IDS_DCLIST_13436                  "    [FATAL] Cannot find DC to get DC list from." 
//            PrintMessage(pParams, IDS_DCLIST_13436 );
            RetVal = FALSE;
            goto Cleanup;
        }
    }

//    if ( pParams->fVerbose )
//  {
//IDS_DCLIST_13437                  "    Get list of DC account in domain '%ws'.\n" 
//        PrintMessage(pParams, IDS_DCLIST_13437, pTestedDomain->DomainName);
//    }


    //
    // Connect to the SAM server
    //

    Status = NettestSamConnect(
                               pParams,
                               pTestedDomain->DcInfo->DomainControllerName,
                               &LocalSamHandle,
                               &LocalShareName );

    if ( !NT_SUCCESS(Status)) {
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // If we don't have a domain sid,
    //  find out what it is.
    //

    if ( pTestedDomain->DomainSid == NULL ) {
        UNICODE_STRING ServerNameString;


        //
        // Open LSA to read account domain info.
        //

        InitializeObjectAttributes( &LSAObjectAttributes,
                                      NULL,             // Name
                                      0,                // Attributes
                                      NULL,             // Root
                                      NULL );           // Security Descriptor

        RtlInitUnicodeString( &ServerNameString, pTestedDomain->DcInfo->DomainControllerName );

        Status = LsaOpenPolicy( &ServerNameString,
                                &LSAObjectAttributes,
                                POLICY_VIEW_LOCAL_INFORMATION,
                                &LSAPolicyHandle );

        if( !NT_SUCCESS(Status) )
        {
            // "    [FATAL] Cannot LsaOpenPolicy to LSA on '%ws'.", 
            if (pParams->fDebugVerbose)
                PrintMessage(pParams, IDS_DCLIST_LSAOPENPOLICY,
                             pTestedDomain->DcInfo->DomainControllerName );
            RetVal = FALSE;
            goto Cleanup;
        }


        //
        // Now read account domain info from LSA.
        //

        Status = LsaQueryInformationPolicy(
                        LSAPolicyHandle,
                        PolicyAccountDomainInformation,
                        (PVOID *) &AccountDomainInfo );

        if( !NT_SUCCESS(Status) )
        {
            AccountDomainInfo = NULL;

            // "    [FATAL] Cannot LsaQueryInformationPolicy (AccountDomainInfor) to LSA on '%ws'."
            if (pParams->fDebugVerbose)
                PrintMessage(pParams, IDS_DCLIST_LSAQUERYINFO,
                             pTestedDomain->DcInfo->DomainControllerName);
                
            RetVal = FALSE;
            goto Cleanup;
        }

        //
        // Save the domain sid for other tests
        //

        pResults->Global.pMemberDomain->DomainSid =
            Malloc( RtlLengthSid( AccountDomainInfo->DomainSid ) );

        if ( pResults->Global.pMemberDomain->DomainSid == NULL )
        {
            RetVal = FALSE;
            goto Cleanup;
        }

        // We have the domain SID
        pResults->Global.pMemberDomain->fDomainSid = TRUE;
        RtlCopyMemory( pResults->Global.pMemberDomain->DomainSid,
                       AccountDomainInfo->DomainSid,
                       RtlLengthSid( AccountDomainInfo->DomainSid ) );

//        if ( pParams->fVerbose ) {
//IDS_DCLIST_13438                  "    Domain Sid:          " 
//            PrintMessage(pParams, IDS_DCLIST_13438);
//            NlpDumpSid( pResults->Global.pMemberDomain->DomainSid );
//        }
    }

    //
    // Open the domain.
    //

    Status = SamOpenDomain( LocalSamHandle,
                            DOMAIN_LIST_ACCOUNTS |
                                DOMAIN_LOOKUP,
                            pResults->Global.pMemberDomain->DomainSid,
                            &DomainHandle );

    if ( !NT_SUCCESS( Status ) )
    {
        // "    [FATAL] Cannot SamOpenDomain on '%ws'."
        if (pParams->fDebugVerbose)
            PrintMessage(pParams, IDS_DCLIST_SAMOPENDOMAIN,
                         pTestedDomain->DcInfo->DomainControllerName);
        RetVal = FALSE;
        goto Cleanup;
    }



    //
    // Loop building a list of DC names from SAM.
    //
    // On each iteration of the loop,
    //  get the next several machine accounts from SAM.
    //  determine which of those names are DC names.
    //  Merge the DC names into the list we're currently building of all DCs.
    //

    SamIndex = 0;
    do {
        //
        // Arguments to SamQueryDisplayInformation
        //
        ULONG TotalBytesAvailable;
        ULONG BytesReturned;
        ULONG EntriesRead;

        DWORD i;

        //
        // Get the list of machine accounts from SAM
        //

        SamStatus = SamQueryDisplayInformation (
                        DomainHandle,
                        DomainDisplayMachine,
                        SamIndex,
                        4096,   // Machines per pass
                        0xFFFFFFFF, // PrefMaxLen
                        &TotalBytesAvailable,
                        &BytesReturned,
                        &EntriesRead,
                        &MachineInformation );

        if ( !NT_SUCCESS(SamStatus) )
        {
            Status = SamStatus;

            if (pParams->fDebugVerbose)
            {
                // "    [FATAL] Cannot SamQueryDisplayInformation on '%ws'."
                PrintMessage(pParams, IDS_DCLIST_SAMQUERYDISPLAYINFO,
                             pTestedDomain->DcInfo->DomainControllerName);
            }

            RetVal = FALSE;
            goto Cleanup;
        }

        //
        // Set up for the next call to Sam.
        //

        if ( SamStatus == STATUS_MORE_ENTRIES ) {
            SamIndex = MachineInformation[EntriesRead-1].Index;
        }


        //
        // Loop though the list of machine accounts finding the Server accounts.
        //

        for ( i=0; i<EntriesRead; i++ ) {

            //
            // Ensure the machine account is a server account.
            //

            if ( MachineInformation[i].AccountControl &
                    USER_SERVER_TRUST_ACCOUNT ) {
                WCHAR LocalComputerName[CNLEN+1];
                ULONG LocalComputerNameLength;


                //
                // Insert the server session.
                //
//IDS_DCLIST_13439                  "%wZ %ld\n" 
                //  PrintMessage(pParams,  IDS_DCLIST_13439, &MachineInformation[i].Machine, MachineInformation[i].Rid );

                LocalComputerNameLength =
                        min( MachineInformation[1].Machine.Length/sizeof(WCHAR) - 1,
                             CNLEN );
                RtlCopyMemory( LocalComputerName,
                               MachineInformation[1].Machine.Buffer,
                               LocalComputerNameLength * sizeof(WCHAR) );
                LocalComputerName[LocalComputerNameLength] = '\0';

                pTestedDC = AddTestedDc( pParams,
                                         pResults,
                                         pTestedDomain,
                                         LocalComputerName,
                                         0 );
                pTestedDC->Rid = MachineInformation[i].Rid;

            }
        }

        //
        // Free the buffer returned from SAM.
        //

        if ( MachineInformation != NULL ) {
            SamFreeMemory( MachineInformation );
            MachineInformation = NULL;
        }

    } while ( SamStatus == STATUS_MORE_ENTRIES );


    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( DomainHandle != NULL ) {
        (VOID) SamCloseHandle( DomainHandle );
    }
    if ( AccountDomainInfo != NULL ) {
        LsaFreeMemory( AccountDomainInfo );
        AccountDomainInfo = NULL;
    }

    if ( LocalSamHandle != NULL ) {
        (VOID) SamCloseHandle( LocalSamHandle );
    }

    if( LSAPolicyHandle != NULL ) {
        LsaClose( LSAPolicyHandle );
    }

    if ( LocalShareName != NULL )
    {

        NET_API_STATUS TempStatus;

        TempStatus = NetUseDel( NULL, LocalShareName, FALSE );

        if ( (TempStatus != NERR_Success) && (pParams->fDebugVerbose) )
        {
            // "     [WARNING] Cannot NetUseDel '%ws' NULL session."
            PrintMessage(pParams, IDS_DCLIST_NETUSEDEL, LocalShareName );
        }

        NetpMemoryFree( LocalShareName );
    }

    return RetVal;
}
*/



/*!--------------------------------------------------------------------------
    DcListGlobalPrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DcListGlobalPrint( NETDIAG_PARAMS* pParams,
                          NETDIAG_RESULT*  pResults)
{
    LIST_ENTRY *            pListEntry;
    LIST_ENTRY *            pListEntryDC;
    TESTED_DOMAIN *         pDomain;
    TESTED_DC *             pTestedDC;
    int                     i;
    
    if (!pResults->IpConfig.fEnabled)
    {
        return;
    }
    
    if (pParams->fVerbose || !FHrOK(pResults->DcList.hr))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, IDS_DCLIST_LONG, IDS_DCLIST_SHORT,
                             pResults->DcList.fPerformed, 
                             pResults->DcList.hr, 0);
        PrintNdMessage(pParams, &pResults->DcList.msgErr);

        //The message list contains the error info
        PrintMessageList(pParams, &pResults->DcList.lmsgOutput);

        if (pParams->fReallyVerbose)
        {
            // Iterate through the list of tested domain
            // Iterate through each domain
            for (pListEntry = pResults->Global.listTestedDomains.Flink;
                 pListEntry != &pResults->Global.listTestedDomains;
                 pListEntry = pListEntry->Flink)
            {
                pDomain = CONTAINING_RECORD(pListEntry, TESTED_DOMAIN, Next);
                
                //  "    List of DCs in Domain '%ws':\n"                
                PrintMessage(pParams, IDS_DCLIST_DOMAIN_HEADER,
                             pDomain->PrintableDomainName);

                if (pDomain->fDomainSid)
                {
                    // print out the sid for the domain
                    PrintMessage(pParams, IDS_DCLIST_DOMAIN_SID);
                    PrintSid( pParams, pResults->Global.pMemberDomain->DomainSid );
                }

                for (pListEntryDC = pDomain->TestedDcs.Flink;
                     pListEntryDC != &pDomain->TestedDcs;
                     pListEntryDC = pListEntryDC->Flink)
                {
                    pTestedDC = CONTAINING_RECORD(pListEntryDC,
                        TESTED_DC, Next);
                    
                    PrintMessage(pParams, IDS_DCLIST_DC_INFO,
                                 pTestedDC->ComputerName);

                    if (pTestedDC->Rid)
                    {
                        PrintMessage(pParams, IDS_DCLIST_RID,
                                     pTestedDC->Rid);
                    }

                    if (pTestedDC->Flags & DC_IS_DOWN)
                    {
                        PrintMessage(pParams, IDS_DCLIST_DC_IS_DOWN);
                        
                        if (pTestedDC->Flags & DC_FAILED_PING)
                        {
                            PrintNewLine(pParams, 1);
                            PrintMessage(pParams, IDS_DCLIST_DC_FAILED_PING,
                                        pTestedDC->ComputerName);
                        }
                    }
                    PrintNewLine(pParams, 1);
                }
                
            }
            
        }
    }
}

/*!--------------------------------------------------------------------------
    DcListPerInterfacePrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DcListPerInterfacePrint( NETDIAG_PARAMS* pParams,
                                NETDIAG_RESULT*  pResults,
                                INTERFACE_RESULT *pInterfaceResults)
{
    // no per-interface results
}


/*!--------------------------------------------------------------------------
    DcListCleanup
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DcListCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    int     i;
    
    ClearMessage(&pResults->DcList.msgErr);
    MessageListCleanUp(&pResults->DcList.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\defgw.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      defgw.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//      NSun       08/30/98
//
//--

#include "precomp.h"


//-------------------------------------------------------------------------//
//######  D e f G w T e s t ()  ###########################################//
//-------------------------------------------------------------------------//
HRESULT
DefGwTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//++
//
//  Routine Description:
//
//      Tests that the default gateway can be pinged. This doesn't really 
//      confirms forwarding on that IP address but it's a start.
//    
//  Arguments:
//
//      None.
//
//  Return Value:
//
//      TRUE:  Test suceeded.
//      FALSE: Test failed
//
//--
{
    DWORD   nReplyCnt;
    IPAddr  GwAddress;
    int     nGwsReachable = 0;
    int     i;

    PIP_ADAPTER_INFO  pIpAdapterInfo;
    IP_ADDR_STRING Gateway;

    PrintStatusMessage(pParams, 4, IDS_DEFGW_STATUS_MSG);

    //
    //  try to ping all gateways on all adapters
    //
    for( i = 0; i < pResults->cNumInterfaces; i++)
    {
        pIpAdapterInfo = pResults->pArrayInterface[i].IpConfig.pAdapterInfo;

        InitializeListHead( &pResults->pArrayInterface[i].DefGw.lmsgOutput );
        
        if (!pResults->pArrayInterface[i].IpConfig.fActive ||
            NETCARD_DISCONNECTED == pResults->pArrayInterface[i].dwNetCardStatus)
            continue;
        
        pResults->pArrayInterface[i].DefGw.dwNumReachable = 0;


        Gateway = pIpAdapterInfo->GatewayList;
        if ( Gateway.IpAddress.String[0] == 0 ) 
        {
            //No default gateway configured
            pResults->pArrayInterface[i].DefGw.dwNumReachable = -1;
            continue;
        }
        while ( TRUE ) {
            AddMessageToList(&pResults->pArrayInterface[i].DefGw.lmsgOutput, Nd_ReallyVerbose, IDS_DEFGW_12003, Gateway.IpAddress.String );
            //IDS_DEFGW_12003                  "       Pinging gateway %s "
            
            if ( IsIcmpResponseA(Gateway.IpAddress.String) )
            {
                AddMessageToListId(&pResults->pArrayInterface[i].DefGw.lmsgOutput, Nd_ReallyVerbose, IDS_DEFGW_12004 );
                //IDS_DEFGW_12004                  "- reachable\n" 
                nGwsReachable++;
                pResults->pArrayInterface[i].DefGw.dwNumReachable ++;
            }
            else {
                AddMessageToListId(&pResults->pArrayInterface[i].DefGw.lmsgOutput, Nd_ReallyVerbose, IDS_DEFGW_12005 );
                //IDS_DEFGW_12005                  "- not reachable\n" 
            }
            if ( Gateway.Next == NULL ) { break; }
            Gateway = *(Gateway.Next);
        }
    }

    // 
    //  No gateway is reachable - fatal.
    //
    if ( nGwsReachable == 0 )
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_FAIL_NL);
        pResults->DefGw.hrReachable = S_FALSE;
    }
    else
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_PASS_NL);
        pResults->DefGw.hrReachable = S_OK;
    }

    return pResults->DefGw.hrReachable;
} /* END OF DefGwTest() */


//----------------------------------------------------------------
//
// DefGwGlobalPrint
//
// Author   NSun
//
//------------------------------------------------------------------

void DefGwGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (!pResults->IpConfig.fEnabled)
    {
        return;
    }
    
    if (pParams->fVerbose || !FHrOK(pResults->DefGw.hrReachable))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_DEFGW_LONG,
							 IDS_DEFGW_SHORT,
                             TRUE,
                             pResults->DefGw.hrReachable,
                             0);
    }

    if(FHrOK(pResults->DefGw.hrReachable))
    {
        if (pParams->fReallyVerbose)
            PrintMessage(pParams,  IDS_DEFGW_12011 );
        //IDS_DEFGW_12011  "\n    PASS - you have at least one reachable gateway.\n"
    }
    else
    {
        //IDS_DEFGW_12006                  "\n" 
        PrintMessage(pParams,  IDS_DEFGW_12006 );
        //IDS_DEFGW_12007                  "    [FATAL] NO GATEWAYS ARE REACHABLE.\n" 
        PrintMessage(pParams,  IDS_DEFGW_12007 );
        //IDS_DEFGW_12008                  "    You have no connectivity to other network segments.\n" 
        PrintMessage(pParams,  IDS_DEFGW_12008 );
        //IDS_DEFGW_12009                  "    If you configured the IP protocol manually then\n" 
        PrintMessage(pParams,  IDS_DEFGW_12009 );
        //IDS_DEFGW_12010                  "    you need to add at least one valid gateway.\n" 
        PrintMessage(pParams,  IDS_DEFGW_12010 );
    }

}


//----------------------------------------------------------------
//
// DefGwPerInterfacePrint
//
// Author   NSun
//
//------------------------------------------------------------------
void DefGwPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    if (!pInterfaceResults->fActive || 
        !pInterfaceResults->IpConfig.fActive ||
        NETCARD_DISCONNECTED == pInterfaceResults->dwNetCardStatus)
        return;
    
    if (pParams->fVerbose)
    {
        PrintNewLine(pParams, 1);
        if(-1 == pInterfaceResults->DefGw.dwNumReachable) //test skipped on this interface
            PrintTestTitleResult(pParams, IDS_DEFGW_LONG, IDS_DEFGW_SHORT, FALSE, S_FALSE, 8);
        else if(pInterfaceResults->DefGw.dwNumReachable == 0)
            PrintTestTitleResult(pParams, IDS_DEFGW_LONG, IDS_DEFGW_SHORT, TRUE, S_FALSE, 8);
        else
            PrintTestTitleResult(pParams, IDS_DEFGW_LONG, IDS_DEFGW_SHORT, TRUE, S_OK, 8);
    }

    PrintMessageList(pParams, &pInterfaceResults->DefGw.lmsgOutput);
    if(pParams->fVerbose)
    {
        if(-1 == pInterfaceResults->DefGw.dwNumReachable)
            PrintMessage(pParams, IDS_DEFGW_12002 );
            //IDS_DEFGW_12002                  "    There is no gateway defined for this adapter.\n" 
        else if( 0 == pInterfaceResults->DefGw.dwNumReachable)
            PrintMessage(pParams, IDS_DEFGW_12001);
            //IDS_DEFGW_12001                  "    No gateway reachable for this adapter. \n"
        else if (pParams->fReallyVerbose)
            PrintMessage(pParams, IDS_DEFGW_12012);
            //IDS_DEFGW_12012                   "   At least one gateway for this adapter is reachable. \n"

        PrintNewLine(pParams, 1);
    }
}



//----------------------------------------------------------------
//
// DefGwCleanup
//
// Author   NSun
//
//------------------------------------------------------------------
void DefGwCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    int i;
    for(i = 0; i < pResults->cNumInterfaces; i++)
    {
        MessageListCleanUp(&pResults->pArrayInterface[i].DefGw.lmsgOutput);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\dhcptest.h ===
/*--

Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:

      dhcptest.h

Abstract:

      Contains function prototypes, defines and data structures used in dhcp test as part of
      autonet test.

Author:
       
      4-Aug-1998 (t-rajkup)

Environment:

      User mode only.

Revision History:

      None.

--*/
#ifndef HEADER_DHCPTEST
#define HEADER_DHCPTEST

#define OPTION_MSFT_CONTINUED           250
#define OPTION_USER_CLASS               77

#define MAX_DISCOVER_RETRIES            4

//
// The format of Adapter Status responses
//

typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} tADAPTERSTATUS;

UCHAR nameToQry[NETBIOS_NAME_SIZE + 1];


/*
VOID
ExtractDhcpResponse(
   IN PDHCP_MESSAGE pDhcpMessage
  );
*/


/*=======================< Dhcp related function prototypes >================*/


/*
DWORD
DhcpCalculateWaitTime(
    IN      DWORD                  RoundNum,
    OUT     DWORD                 *WaitMilliSecs
  );
 

BOOL
GetSpecifiedDhcpMessage(
          IN SOCKET sock,
          IN PIP_ADAPTER_INFO pAdapterInfo,
          OUT PDHCP_MESSAGE pDhcpMessage,
          IN DWORD Xid,
          IN DWORD TimeToWait
);

VOID
SendDhcpMessage(
 IN SOCKET sock,
 IN PDHCP_MESSAGE pDhcpMessage,
 IN DWORD MessageLength,
 IN DWORD TransactionId,
 IN PIP_ADAPTER_INFO pAdapterInfo
 );

LPBYTE
DhcpAppendMagicCookie(
    OUT LPBYTE Option,
    IN LPBYTE OptionEnd
    );

LPOPTION
DhcpAppendClassIdOption(
    IN OUT     PDHCP_CONTEXT          DhcpContext,
    OUT     LPBYTE                 BufStart,
    IN      LPBYTE                 BufEnd
);

LPOPTION
DhcpAppendClientIDOption(
    OUT LPOPTION Option,
    IN BYTE ClientHWType,
    IN LPBYTE ClientHWAddr,
    IN BYTE ClientHWAddrLength,
    IN LPBYTE OptionEnd
    );

DWORD
OpenDriver(
    OUT HANDLE *Handle,
    IN LPWSTR DriverName
);


LPOPTION
DhcpAppendOption(
    OUT LPOPTION Option,
    IN  BYTE OptionType,
    IN  PVOID OptionValue,
    IN  ULONG OptionLength,
    IN  LPBYTE OptionEnd
);
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\dnscmn.h ===
/*++

Copyright (C) Microsoft Corporation, 1998-2002

Module Name:

    dnscmn.h

Abstract:

    Domain Name System (DNS) Netdiag tests.

Author:

    Elena Apreutesei (elenaap) 10/22/98

Revision History:

    jamesg  May 2002    -- cleanup for network info changes
    jamesg  Sept 2000   -- more scrub and cleanup

--*/


#ifndef _DNSCOMMON_H_
#define _DNSCOMMON_H_

#include <dnslib.h>


//
//  Version note:
//      - code cleanup but
//      - uses "fixed up" DNS_NETWORK_INFORMATION  (UTF8)
//      - not converted to public DNS_NETWORK_INFO struct
//      - not unicode
//      - not IP6 aware
//

//
//  Currently getting DNS info in UTF8
//

//#define PDNS_NETINFO      PDNS_NETWORK_INFOW
//#define PDNS_ADAPTER      PDNS_ADAPTER_INFOW

//#define PDNS_NETINFO        PDNS_NETWORK_INFORMATION
//#define PDNS_ADAPTER        PDNS_ADAPTER_INFORMATION
//#define PDNS_SERVER_INFO    PDNS_SERVER_INFORMATION



//
//  DNS structures
//
//  DCR:  replace with public DNS structures
//
//  These are a mapping of old public DNS structures onto private
//  netdiag structures to preserve the netdiag names and
//  field names.  They should be replaced by switching to a
//  new set of unicode public structures.
//

typedef struct
{
    IP4_ADDRESS     IpAddress;
    DWORD           Priority;
}
DNS_SERVER_INFO, *PDNS_SERVER_INFO;

typedef struct
{
    PSTR            pszAdapterGuidName;
    PSTR            pszAdapterDomain;
    PVOID           pReserved1;
    PVOID           pReserved2;
    DWORD           InfoFlags;
    DWORD           ServerCount;
    DNS_SERVER_INFO ServerArray[1];
}
DNS_ADAPTER, *PDNS_ADAPTER;

typedef struct
{
    PSTR            pszDomainOrZoneName;
    DWORD           NameCount;
    PSTR            SearchNameArray[1];
}
SEARCH_LIST, *PSEARCH_LIST;

typedef struct
{
    PSEARCH_LIST    pSearchList;
    DWORD           AdapterCount;
    PDNS_ADAPTER    AdapterArray[1];
}
DNS_NETINFO, *PDNS_NETINFO;


//
//  Build sanity check
//

C_ASSERT( sizeof(SEARCH_LIST)       == sizeof(DNS_SEARCH_INFORMATION) );
C_ASSERT( sizeof(DNS_SERVER_INFO)   == sizeof(DNS_SERVER_INFORMATION) );
C_ASSERT( sizeof(DNS_ADAPTER)       == sizeof(DNS_ADAPTER_INFORMATION) );
C_ASSERT( sizeof(DNS_NETINFO)       == sizeof(DNS_NETWORK_INFORMATION) );


//
//  Map dnsapi.h def for network config retrieval
//

#define DnsConfigNetworkInfoUTF8    DnsConfigNetworkInformation


//
//   Private dnsapi.dll interface for netdiag
//

DNS_STATUS
DnsNetworkInformation_CreateFromFAZ(
    IN      PCSTR               pszName,
    IN      DWORD               dwFlags,
    IN      PIP4_ARRAY          pIp4Servers,
    OUT     PDNS_NETINFO *      ppNetworkInfo
    );



//
//  Private defines
//

#define MAX_NAME_SERVER_COUNT   (20)
#define MAX_ADDRS               (35)    
#define DNS_QUERY_DATABASE      (0x200)
#define IP_ARRAY_SIZE(a)        (sizeof(DWORD) + (a)*sizeof(IP_ADDRESS))
#define IP4_ARRAY_SIZE(a)       IP_ARRAY_SIZE(a)

//  Use dnslib memory routines
#define ALLOCATE_HEAP(iSize)            Dns_Alloc(iSize)
#define ALLOCATE_HEAP_ZERO(iSize)       Dns_AllocZero(iSize)
#define REALLOCATE_HEAP(pMem,iSize)     Dns_Realloc((pMem),(iSize))
#define FREE_HEAP(pMem)                 Dns_Free(pMem)


//
//  Registration info blob
//

typedef struct
{
    PVOID       pNext;
    char        szDomainName[DNS_MAX_NAME_BUFFER_LENGTH];
    char        szAuthoritativeZone[DNS_MAX_NAME_BUFFER_LENGTH];
    DWORD       dwAuthNSCount;
    IP_ADDRESS  AuthoritativeNS[MAX_NAME_SERVER_COUNT];
    DWORD       dwIPCount;
    IP_ADDRESS  IPAddresses[MAX_ADDRS];
    DNS_STATUS  AllowUpdates;
}
REGISTRATION_INFO, *PREGISTRATION_INFO;


//
//  DNS test functions
//

BOOL
SameAuthoritativeServers(
    IN      PREGISTRATION_INFO  pCurrent,
    IN      PIP4_ARRAY          pNS
    );

DNS_STATUS
ComputeExpectedRegistration(
    IN      LPSTR                   pszHostName,
    IN      LPSTR                   pszPrimaryDomain,
    IN      PDNS_NETINFO            pNetworkInfo,
    OUT     PREGISTRATION_INFO *    ppExpectedRegistration,
    OUT     NETDIAG_PARAMS *        pParams, 
    OUT     NETDIAG_RESULT *        pResults
    );

VOID
AddToExpectedRegistration(
    IN      LPSTR                   pszDomain,
    IN      PDNS_ADAPTER            pAdapterInfo,
    IN      PDNS_NETINFO            pFazResult, 
    IN      PIP4_ARRAY              pNS,
    OUT     PREGISTRATION_INFO *    ppExpectedRegistration
    );

HRESULT
VerifyDnsRegistration(
    IN      LPSTR               pszHostName,
    IN      PREGISTRATION_INFO  pExpectedRegistration,
    IN      NETDIAG_PARAMS *    pParams,  
    IN OUT  NETDIAG_RESULT *    pResults
    );

HRESULT
CheckDnsRegistration(
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      NETDIAG_PARAMS *    pParams, 
    IN OUT  NETDIAG_RESULT *    pResults
    );

VOID
CompareCachedAndRegistryNetworkInfo(
    IN      PDNS_NETINFO        pNetworkInfo
    );

PIP4_ARRAY
ServerInfoToIpArray(
    IN      DWORD               ServerCount,
    IN      PDNS_SERVER_INFO    ServerArray
    );

DNS_STATUS
DnsFindAllPrimariesAndSecondaries(
    IN      LPSTR               pszName,
    IN      DWORD               dwFlags,
    IN      PIP4_ARRAY          aipQueryServers,
    OUT     PDNS_NETINFO *      ppNetworkInfo,
    OUT     PIP4_ARRAY *        ppNameServers,
    OUT     PIP4_ARRAY *        ppPrimaries
    );

PIP4_ARRAY
GrabNameServersIp(
    IN      PDNS_RECORD     pDnsRecord
    );

DNS_STATUS
IsDnsServerPrimaryForZone_UTF8(
    IN      IP4_ADDRESS     Ip,
    IN      PSTR            pZone
    );

DNS_STATUS
IsDnsServerPrimaryForZone_W(
    IN      IP4_ADDRESS     Ip,
    IN      PWSTR           pZone
    );

DNS_STATUS
DnsUpdateAllowedTest_UTF8(
    IN      HANDLE          hContextHandle  OPTIONAL,
    IN      PSTR            pszName,
    IN      PSTR            pszAuthZone,
    IN      PIP4_ARRAY      pDnsServers
    );

DNS_STATUS
DnsUpdateAllowedTest_W(
    IN      HANDLE          hContextHandle  OPTIONAL,
    IN      LPWSTR          pwszName,
    IN      LPWSTR          pwszAuthZone,
    IN      PIP4_ARRAY      pDnsServers
    );

DNS_STATUS
DnsQueryAndCompare(
    IN      LPSTR           lpstrName,
    IN      WORD            wType,
    IN      DWORD           fOptions,
    IN      PIP4_ARRAY      aipServers          OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResultsSet   OPTIONAL,
    IN OUT  PVOID *         pReserved           OPTIONAL,
    IN      PDNS_RECORD     pExpected           OPTIONAL, 
    IN      BOOL            bInclusionOk,
    IN      BOOL            bUnicode,
    IN OUT  PDNS_RECORD *   ppDiff1             OPTIONAL,
    IN OUT  PDNS_RECORD *   ppDiff2             OPTIONAL
    );

BOOLEAN
DnsCompareRRSet_W (
    IN      PDNS_RECORD     pRRSet1,
    IN      PDNS_RECORD     pRRSet2,
    OUT     PDNS_RECORD *   ppDiff1,
    OUT     PDNS_RECORD *   ppDiff2
    );

DNS_STATUS
QueryDnsServerDatabase( 
    IN      LPSTR           pszName, 
    IN      WORD            wType, 
    IN      IP4_ADDRESS     ServerIp, 
    OUT     PDNS_RECORD *   ppDnsRecord, 
    IN      BOOL            bUnicode,
    OUT     BOOL *          pIsLocal
    );

BOOL
GetAnswerTtl(
    IN      PDNS_RECORD     pRec,
    OUT     PDWORD          pTtl
    );

DNS_STATUS
GetAllDnsServersFromRegistry(
    IN      PDNS_NETINFO    pNetworkInfo, 
    OUT     PIP4_ARRAY *    pIpArray
    );

LPSTR
UTF8ToAnsi(
    IN      LPSTR           pStr
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\browser1.c ===
#include <precomp.h>
#include <nt.h>                  // DbgPrint prototype
#include <ntrtl.h>                  // DbgPrint
#include <nturtl.h>                 // Needed by winbase.h

#include <windef.h>                 // DWORD
#include <winbase.h>                // LocalFree

#include <rpcutil.h>                // GENERIC_ENUM_STRUCT

#include <lmcons.h>                 // NET_API_STATUS
#include <lmerr.h>                  // NetError codes
#include <lmremutl.h>               // SUPPORTS_RPC

#include <brnames.h>                // Service and interface names

#include <netlib.h>
#include <netdebug.h>

#include <winsvc.h>

#include <lmserver.h>
#include <tstr.h>

#include <ntddbrow.h>
#include <brcommon.h>               // Routines common between client & server

VOID
UpdateInterimServerListElement(
    IN PINTERIM_SERVER_LIST ServerList,
    IN PINTERIM_ELEMENT Element,
    IN ULONG Level,
    IN BOOLEAN NewElement
    );

PINTERIM_ELEMENT
AllocateInterimServerListEntry(
    IN PSERVER_INFO_101 ServerInfo,
    IN ULONG Level
    );

NET_API_STATUS
MergeServerList(
    IN OUT PINTERIM_SERVER_LIST InterimServerList,
    IN ULONG Level,
    IN PVOID NewServerList,
    IN ULONG NewEntriesRead,
    IN ULONG NewTotalEntries
    )
/*++

Routine Description:

    This function will merge two server lists.  It will reallocate the buffer
    for the old list if appropriate.

Arguments:

    IN OUT PINTERIM_SERVER_LIST InterimServerList - Supplies an interim server list to merge into.

    IN ULONG Level - Supplies the level of the list (100 or 101).  Special
        level 1010 is really level 101 with the special semantic that no
        fields from this the NewServerList override existing fields in the
        InterimServerList.

    IN ULONG NewServerList - Supplies the list to merge into the interim list

    IN ULONG NewEntriesRead - Supplies the entries read in the list.

    IN ULONG NewTotalEntries - Supplies the total entries available in the list.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    ULONG i;
    ULONG ServerElementSize;
    PSERVER_INFO_101 ServerInfo = NewServerList;
    PINTERIM_ELEMENT InterimEntry = NULL;
    PLIST_ENTRY InterimList;
    PINTERIM_ELEMENT NewElement = NULL;


    if (Level == 100) {
        ServerElementSize = sizeof(SERVER_INFO_100);
    } else if ( Level == 101 || Level == 1010 ) {
        ServerElementSize = sizeof(SERVER_INFO_101);
    } else {
        return(ERROR_INVALID_LEVEL);
    }

    //
    //  Early out if no entries in list.
    //

    if (NewEntriesRead == 0) {
        return NERR_Success;
    }

    PrepareServerListForMerge(NewServerList, Level, NewEntriesRead);

    InterimList = InterimServerList->ServerList.Flink;

    //
    //  Walk the existing structure, packing it into an interim element, and
    //  sticking the element into the interim table.
    //

    for (i = 0; i < NewEntriesRead; i ++) {
        BOOLEAN EntryInserted = FALSE;

        //
        //  Walk forward in the interim element and find the appropriate place
        //  to insert this element.
        //

        while (InterimList != &InterimServerList->ServerList) {

            LONG CompareResult;

            InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

//            KdPrint(("MergeServerList: Compare %ws and %ws\n", NewElement->Name, InterimEntry->Name));

#if DBG
            //
            //  Make sure that this entry is lexically less than the next
            //  entry.
            //

            {
                PLIST_ENTRY NextList = InterimList->Flink;
                PINTERIM_ELEMENT NextEntry = CONTAINING_RECORD(NextList, INTERIM_ELEMENT, NextElement);

                if (NextList != &InterimServerList->ServerList) {
                    ASSERT (wcscmp(InterimEntry->Name, NextEntry->Name) < 0);
                }

                //
                //  Now make sure that the input buffer also doesn't contain
                //  duplicate entries.
                //

                if (i < (NewEntriesRead-1)) {
                    PSERVER_INFO_101 NextServerInfo = (PSERVER_INFO_101)((PCHAR)ServerInfo+ServerElementSize);

                    ASSERT (wcscmp(ServerInfo->sv101_name, NextServerInfo->sv101_name) <= 0);
                }

            }
#endif

            CompareResult = wcscmp(ServerInfo->sv101_name, InterimEntry->Name);

            if (CompareResult == 0) {

//                KdPrint(("MergeServerList: Elements equal - update\n"));

                //
                // If the new information should override the old information,
                //  copy it on top of the new info.
                //
                if ( Level != 1010 ) {
                    InterimEntry->PlatformId = ServerInfo->sv101_platform_id;

                    if (Level >= 101) {
                        InterimEntry->MajorVersionNumber = ServerInfo->sv101_version_major;

                        InterimEntry->MinorVersionNumber = ServerInfo->sv101_version_minor;

                        InterimEntry->Type = ServerInfo->sv101_type;

                        InterimServerList->TotalBytesNeeded -= wcslen(InterimEntry->Comment) * sizeof(WCHAR) + sizeof(WCHAR);

                        wcscpy(InterimEntry->Comment, ServerInfo->sv101_comment);

                        InterimServerList->TotalBytesNeeded += wcslen(InterimEntry->Comment) * sizeof(WCHAR) + sizeof(WCHAR);

                    }
                }

                UpdateInterimServerListElement(InterimServerList, InterimEntry, Level, FALSE);

                EntryInserted = TRUE;

                break;

            } else if (CompareResult > 0) {

//                KdPrint(("MergeServerList: Elements greater.  Skip element\n"));

                InterimList = InterimList->Flink;

            } else {

                NewElement = AllocateInterimServerListEntry(ServerInfo, Level);

                if (NewElement == NULL) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
//                KdPrint(("MergeServerList: Elements less.  Insert at end\n"));

                //
                //  The new entry is < than the previous entry.  Insert it
                //  before this entry.
                //

                InsertTailList(&InterimEntry->NextElement, &NewElement->NextElement);

                //
                //  Skip to the next element in the list.
                //

                InterimList = &NewElement->NextElement;

                UpdateInterimServerListElement(InterimServerList, NewElement, Level, TRUE);

                EntryInserted = TRUE;

                break;
            }
        }

        if (!EntryInserted &&
            (InterimList == &InterimServerList->ServerList)) {

            NewElement = AllocateInterimServerListEntry(ServerInfo, Level);

            if (NewElement == NULL) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
//            KdPrint(("MergeServerList: Insert %ws at end of list\n", NewElement->Name));

            InsertTailList(&InterimServerList->ServerList, &NewElement->NextElement);

            InterimList = &NewElement->NextElement;

            UpdateInterimServerListElement(InterimServerList, NewElement, Level, TRUE);

        }

        ServerInfo = (PSERVER_INFO_101)((PCHAR)ServerInfo+ServerElementSize);
    }

#if 0
    {
        PLIST_ENTRY InterimList;
        ULONG TotalNeededForList = 0;

        for (InterimList = InterimServerList->ServerList.Flink ;
             InterimList != &InterimServerList->ServerList ;
             InterimList = InterimList->Flink ) {
             ULONG ServerElementSize;

             InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

             if (Level == 100) {
                 ServerElementSize = sizeof(SERVER_INFO_100);
             } else {
                 ServerElementSize = sizeof(SERVER_INFO_101);
             }

             ServerElementSize += wcslen(InterimEntry->Name)*sizeof(WCHAR)+sizeof(WCHAR);

             ServerElementSize += wcslen(InterimEntry->Comment)*sizeof(WCHAR)+sizeof(WCHAR);

//             KdPrint(("MergeInterimServerList: %ws.  %ld needed\n", InterimEntry->Name, ServerElementSize));

             TotalNeededForList += ServerElementSize;
         }

         if (TotalNeededForList != InterimServerList->TotalBytesNeeded) {
             KdPrint(("UpdateInterimServerList:  Wrong number of bytes (%ld) for interim server list.  %ld needed\n", InterimServerList->TotalBytesNeeded, TotalNeededForList));
         }
     }

#endif
//    KdPrint(("%lx bytes needed to hold server list\n", InterimServerList->TotalBytesNeeded));

    //
    //  Also, we had better have the whole table locally.
    //

    ASSERT (InterimServerList->EntriesRead == InterimServerList->TotalEntries);

    return(NERR_Success);
}

ULONG
__cdecl
CompareServerInfo(
    const void * Param1,
    const void * Param2
    )
{
    const SERVER_INFO_100 * ServerInfo1 = Param1;
    const SERVER_INFO_100 * ServerInfo2 = Param2;

    return wcscmp(ServerInfo1->sv100_name, ServerInfo2->sv100_name);
}

VOID
PrepareServerListForMerge(
    IN PVOID ServerInfoList,
    IN ULONG Level,
    IN ULONG EntriesInList
    )
/*++

Routine Description:

    MergeServerList requires that the inputs to the list be in a strictly
    sorted order.  This routine guarantees that this list will be of
    an "appropriate" form to be merged.

Arguments:

    IN PVOID ServerInfoList - Supplies the list to munge.

    IN ULONG Level - Supplies the level of the list (100 or 101).
        (Or level 1010 which is identical to level 101.)

    IN ULONG EntriesInList - Supplies the number of entries in the list.

Return Value:

    None.

Note:
    In 99% of the cases, the list passed in will already be sorted.  We want to
    take the input list and first check to see if it is sorted.  If it is,
    we can return immediately.  If it is not, we need to sort the list.

    We don't just unilaterally sort the list, because the input is mostly
    sorted anyway, and there are no good sorting algorithms that handle mostly
    sorted inputs.  Since we will see unsorted input only rarely (basically,
    we will only see it from WfW machines), we just take the penalty of a worst
    case quicksort if the input is unsorted.

--*/

{
    LONG i;
    ULONG ServerElementSize;
    PSERVER_INFO_101 ServerInfo = ServerInfoList;
    BOOLEAN MisOrderedList = FALSE;

    ASSERT (Level == 100 || Level == 101 || Level == 1010);

    //
    //  Figure out the size of each element.
    //

    if (Level == 100) {
        ServerElementSize = sizeof(SERVER_INFO_100);
    } else {
        ServerElementSize = sizeof(SERVER_INFO_101);
    }

    //
    //  Next check to see if the input list is sorted.
    //

    for (i = 0 ; i < ((LONG)EntriesInList - 1) ; i += 1 ) {
        PSERVER_INFO_101 NextServerInfo = (PSERVER_INFO_101)((PCHAR)ServerInfo+ServerElementSize);

        if (wcscmp(ServerInfo->sv101_name, NextServerInfo->sv101_name) >= 0) {
            MisOrderedList = TRUE;
            break;
        }

        ServerInfo = NextServerInfo;
    }

    //
    //  This list is sorted.  Return right away, it's fine.
    //

    if (!MisOrderedList) {
        return;
    }

    //
    //  This list isn't sorted.  We need to sort it.
    //

    qsort(ServerInfoList, EntriesInList, ServerElementSize, CompareServerInfo);


}

PINTERIM_ELEMENT
AllocateInterimServerListEntry(
    IN PSERVER_INFO_101 ServerInfo,
    IN ULONG Level
    )
{
    PINTERIM_ELEMENT NewElement;

    NewElement = MIDL_user_allocate(sizeof(INTERIM_ELEMENT));

    if (NewElement == NULL) {
        return NULL;
    }

    //
    //  Initialize TimeLastSeen and Periodicity.
    //

    NewElement->TimeLastSeen = 0;

    NewElement->Periodicity = 0;

    NewElement->PlatformId = ServerInfo->sv101_platform_id;

    ASSERT (wcslen(ServerInfo->sv101_name) <= CNLEN);

    wcscpy(NewElement->Name, ServerInfo->sv101_name);

    if (Level == 100) {
        NewElement->MajorVersionNumber = 0;
        NewElement->MinorVersionNumber = 0;
        *NewElement->Comment = L'\0';
        NewElement->Type = SV_TYPE_ALL;
    } else {
        NewElement->MajorVersionNumber = ServerInfo->sv101_version_major;

        NewElement->MinorVersionNumber = ServerInfo->sv101_version_minor;

        NewElement->Type = ServerInfo->sv101_type;

        ASSERT (wcslen(ServerInfo->sv101_comment) <= LM20_MAXCOMMENTSZ);

        wcscpy(NewElement->Comment, ServerInfo->sv101_comment);

    }

    return NewElement;
}


VOID
UpdateInterimServerListElement(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN PINTERIM_ELEMENT InterimElement,
    IN ULONG Level,
    IN BOOLEAN NewElement
    )
{
#if 0
    PINTERIM_ELEMENT InterimEntry;
    ULONG TotalNeededForList = 0;
#endif

    //
    //  If this is a new element, update the size of the table to match.
    //

    if (NewElement) {
        ULONG ServerElementSize;

        if (Level == 100) {
            ServerElementSize = sizeof(SERVER_INFO_100);
        } else {
            ServerElementSize = sizeof(SERVER_INFO_101);
        }

        InterimServerList->EntriesRead += 1;

        ServerElementSize += wcslen(InterimElement->Name)*sizeof(WCHAR)+sizeof(WCHAR);

        if (Level == 100) {
            ServerElementSize += sizeof(WCHAR);
        } else {
            ServerElementSize += wcslen(InterimElement->Comment)*sizeof(WCHAR)+sizeof(WCHAR);
        }

        InterimServerList->TotalBytesNeeded += ServerElementSize;

        InterimServerList->TotalEntries += 1;

        if (InterimServerList->NewElementCallback != NULL) {
            InterimServerList->NewElementCallback(InterimServerList,
                                                            InterimElement);
        } else {
            InterimElement->Periodicity = 0xffffffff;
            InterimElement->TimeLastSeen = 0xffffffff;
        }


    } else {
        if (InterimServerList->ExistingElementCallback != NULL) {
            InterimServerList->ExistingElementCallback(InterimServerList,
                                                       InterimElement);
        } else {
            InterimElement->Periodicity = 0xffffffff;
            InterimElement->TimeLastSeen = 0xffffffff;
        }

    }

#if 0
    {
        PLIST_ENTRY InterimList;
        ULONG TotalNeededForList = 0;

        for (InterimList = InterimServerList->ServerList.Flink ;
             InterimList != &InterimServerList->ServerList ;
             InterimList = InterimList->Flink ) {
             ULONG ServerElementSize;

             InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

             if (Level == 100) {
                 ServerElementSize = sizeof(SERVER_INFO_100);
             } else {
                 ServerElementSize = sizeof(SERVER_INFO_101);
             }

             ServerElementSize += wcslen(InterimEntry->Name)*sizeof(WCHAR)+sizeof(WCHAR);

             ServerElementSize += wcslen(InterimEntry->Comment)*sizeof(WCHAR)+sizeof(WCHAR);

             TotalNeededForList += ServerElementSize;
         }

         if (TotalNeededForList != InterimServerList->TotalBytesNeeded) {
             KdPrint(("UpdateInterimServerList:  Wrong number of bytes (%ld) for interim server list.  %ld needed\n", InterimServerList->TotalBytesNeeded, TotalNeededForList));
         }
     }

#endif

    return;

}

NET_API_STATUS
PackServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN ULONG Level,
    IN ULONG ServerType,
    IN ULONG PreferedMaximumLength,
    OUT PVOID *ServerList,
    OUT PULONG EntriesRead,
    OUT PULONG TotalEntries,
    IN LPCWSTR FirstNameToReturn
    )
/*++

Routine Description:

    This function will take an interim server list and "pack" it into an array
    of server_info_xxx structures.

Arguments:

    IN PINTERIM_SERVER_LIST InterimServerList - Supplies an interim server list to merge into.

    IN ULONG Level - Supplies the level of the list (100 or 101).

    IN ULONG ServerType - Supplies the type to filter on the list.

    IN ULONG PreferedMaximumLength - Supplies the prefered size of the list.

    OUT PVOID *ServerList - Where to put the destination list.

    OUT PULONG EntriesEntries - Receives the entries packed in the list.

    OUT PULONG TotalEntries - Receives the total entries available in the list.

    FirstNameToReturn - Supplies the name of the first domain or server entry to return.
        The caller can use this parameter to implement a resume handle of sorts by passing
        the name of the last entry returned on a previous call.  (Notice that the specified
        entry will, also, be returned on this call unless it has since been deleted.)
        Pass NULL to start with the first entry available.

        Passed name must be the canonical form of the name.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    ULONG EntriesPacked = 0;
    PLIST_ENTRY InterimList;
    PSERVER_INFO_101 ServerEntry;
    ULONG EntrySize = 0;
    LPWSTR BufferEnd;
    BOOLEAN ReturnWholeList = FALSE;
    BOOLEAN TrimmingNames;
    BOOLEAN BufferFull = FALSE;

    if (Level == 100) {
        EntrySize = sizeof(SERVER_INFO_100);
    } else if (Level == 101) {
        EntrySize = sizeof(SERVER_INFO_101);
    } else {
        return(ERROR_INVALID_LEVEL);
    }

    //
    //  Set the entries read based on the information we collected before.
    //

    *TotalEntries = 0;

    if (PreferedMaximumLength == 0xffffffff) {
        *ServerList = MIDL_user_allocate(InterimServerList->TotalBytesNeeded);

        BufferEnd = (LPWSTR)((ULONG_PTR)(*ServerList)+InterimServerList->TotalBytesNeeded);

    } else {
        *ServerList = MIDL_user_allocate(PreferedMaximumLength);

        BufferEnd = (LPWSTR)((ULONG_PTR)(*ServerList)+PreferedMaximumLength);
    }

    if (ServerType == SV_TYPE_ALL || ServerType == SV_TYPE_DOMAIN_ENUM) {
        ReturnWholeList = TRUE;
    }

    if ( *ServerList == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);

    }

    TrimmingNames = (FirstNameToReturn != NULL && *FirstNameToReturn != L'\0');
    ServerEntry = *ServerList;

    for (InterimList = InterimServerList->ServerList.Flink ;
         InterimList != &InterimServerList->ServerList ;
         InterimList = InterimList->Flink ) {

        PINTERIM_ELEMENT InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

#if DBG
        //
        //  Make sure that this entry is lexically less than the next
        //  entry.
        //

        {
            PLIST_ENTRY NextList = InterimList->Flink;
            PINTERIM_ELEMENT NextEntry = CONTAINING_RECORD(NextList, INTERIM_ELEMENT, NextElement);

            if (NextList != &InterimServerList->ServerList) {
                ASSERT (wcscmp(InterimEntry->Name, NextEntry->Name) < 0);
            }

        }
#endif

        //
        // Trim the first several names from the list.
        //

        if ( TrimmingNames ) {
            if ( wcscmp( InterimEntry->Name, FirstNameToReturn ) < 0 ) {
                continue;
            }
            TrimmingNames = FALSE;
        }

        //
        //  If the server's type matches the type filter, pack it into the buffer.
        //

        if (InterimEntry->Type & ServerType) {

            (*TotalEntries) += 1;

            //
            //  If this entry will fit into the buffer, pack it in.
            //
            //  Please note that we only count an entry if the entire entry
            //  (server and comment) fits in the buffer.  This is NOT
            //  strictly Lan Manager compatible.
            //

            if ( !BufferFull &&
                 ((ULONG_PTR)ServerEntry+EntrySize <= (ULONG_PTR)BufferEnd)) {

                ServerEntry->sv101_platform_id = InterimEntry->PlatformId;

                ServerEntry->sv101_name = InterimEntry->Name;

                if (NetpPackString(&ServerEntry->sv101_name,
                                    (LPBYTE)((PCHAR)ServerEntry)+EntrySize,
                                    &BufferEnd)) {

                    if (Level == 101) {

                        ServerEntry->sv101_version_major = InterimEntry->MajorVersionNumber;;

                        ServerEntry->sv101_version_minor = InterimEntry->MinorVersionNumber;;

                        ServerEntry->sv101_type = InterimEntry->Type;

                        ServerEntry->sv101_comment = InterimEntry->Comment;

                        if (NetpPackString(&ServerEntry->sv101_comment,
                                    (LPBYTE)((PCHAR)ServerEntry)+EntrySize,
                                    &BufferEnd)) {
                            EntriesPacked += 1;
                        } else {
                            BufferFull = TRUE;
                        }
                    } else {
                        EntriesPacked += 1;
                    }
#if DBG
                    {
                        PSERVER_INFO_101 PreviousServerInfo = (PSERVER_INFO_101)((PCHAR)ServerEntry-EntrySize);
                        if (PreviousServerInfo >= (PSERVER_INFO_101)*ServerList) {
                            ASSERT (wcscmp(ServerEntry->sv101_name, PreviousServerInfo->sv101_name) > 0);
                        }

                    }
#endif
                } else {
                    BufferFull = TRUE;
                }

            } else {

                //
                //  If we're returning the entire list and we have exceeded
                //  the amount that fits in the list, we can early out
                //  now.
                //

                if (ReturnWholeList) {

                    *TotalEntries = InterimServerList->TotalEntries;

                    break;
                }

                BufferFull = TRUE;
            }

            //
            //  Step to the next server entry.
            //

            ServerEntry = (PSERVER_INFO_101)((PCHAR)ServerEntry+EntrySize);
        }
    }

    ASSERT (InterimServerList->EntriesRead >= EntriesPacked);

    *EntriesRead = EntriesPacked;

    if (EntriesPacked != *TotalEntries) {
        return ERROR_MORE_DATA;
    } else {
        return NERR_Success;
    }

}


NET_API_STATUS
InitializeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN PINTERIM_NEW_CALLBACK NewCallback,
    IN PINTERIM_EXISTING_CALLBACK ExistingCallback,
    IN PINTERIM_DELETE_CALLBACK DeleteElementCallback,
    IN PINTERIM_AGE_CALLBACK AgeElementCallback
    )
{

    InitializeListHead(&InterimServerList->ServerList);

    InterimServerList->TotalBytesNeeded = 0;
    InterimServerList->TotalEntries = 0;
    InterimServerList->EntriesRead = 0;

    InterimServerList->NewElementCallback = NewCallback;
    InterimServerList->ExistingElementCallback = ExistingCallback;
    InterimServerList->DeleteElementCallback = DeleteElementCallback;
    InterimServerList->AgeElementCallback = AgeElementCallback;
    return(NERR_Success);
}

NET_API_STATUS
UninitializeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList
    )
{
    PINTERIM_ELEMENT InterimElement;


//    KdPrint(("BROWSER: Uninitialize Interim Server List %lx\n", InterimServerList));

    //
    //  Enumerate the elements in the table, deleting them as we go.
    //

    while (!IsListEmpty(&InterimServerList->ServerList)) {
        PLIST_ENTRY Entry;

        Entry = RemoveHeadList(&InterimServerList->ServerList);

        InterimElement = CONTAINING_RECORD(Entry, INTERIM_ELEMENT, NextElement);

        if (InterimServerList->DeleteElementCallback != NULL) {
            InterimServerList->DeleteElementCallback(InterimServerList, InterimElement);
        }

        //
        //  There is one less element in the list.
        //

        InterimServerList->EntriesRead -= 1;

        InterimServerList->TotalEntries -= 1;

        MIDL_user_free(InterimElement);
    }

    ASSERT (InterimServerList->EntriesRead == 0);

    return(NERR_Success);
}

ULONG
NumberInterimServerListElements(
    IN PINTERIM_SERVER_LIST InterimServerList
    )
{
    PLIST_ENTRY InterimList;
    ULONG NumberOfEntries = 0;

    for (InterimList = InterimServerList->ServerList.Flink ;
         InterimList != &InterimServerList->ServerList ;
         InterimList = InterimList->Flink ) {
        NumberOfEntries += 1;

    }

    return NumberOfEntries;
}

NET_API_STATUS
AgeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList
    )
{
    PLIST_ENTRY InterimList, NextElement;
    PINTERIM_ELEMENT InterimElement;

    if (InterimServerList->AgeElementCallback != NULL) {

        //
        //  Enumerate the elements in the table, aging them as we go.
        //


        for (InterimList = InterimServerList->ServerList.Flink ;
             InterimList != &InterimServerList->ServerList ;
             InterimList = NextElement) {
            InterimElement = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

            //
            //  Call into the aging routine and if this entry is too old,
            //  remove it from the interim list.
            //

            if (InterimServerList->AgeElementCallback(InterimServerList, InterimElement)) {
                ULONG ElementSize = sizeof(SERVER_INFO_101) + ((wcslen(InterimElement->Comment) + 1) * sizeof(WCHAR)) + ((wcslen(InterimElement->Name) + 1) * sizeof(WCHAR));

                ASSERT (ElementSize <= InterimServerList->TotalBytesNeeded);

                NextElement = InterimList->Flink;

                //
                //  Remove this entry from the list.
                //

                RemoveEntryList(&InterimElement->NextElement);

                if (InterimServerList->DeleteElementCallback != NULL) {
                    InterimServerList->DeleteElementCallback(InterimServerList, InterimElement);
                }

                //
                //  There is one less element in the list.
                //

                InterimServerList->EntriesRead -= 1;

                InterimServerList->TotalEntries -= 1;

                //
                //  Since this element isn't in the table any more, we don't
                //  need to allocate memory for it.
                //

                InterimServerList->TotalBytesNeeded -= ElementSize;

                MIDL_user_free(InterimElement);

            } else {
                NextElement = InterimList->Flink;
            }
        }
#if 0
    {
        PINTERIM_ELEMENT InterimEntry;
        ULONG TotalNeededForList = 0;

        for (InterimList = InterimServerList->ServerList.Flink ;
             InterimList != &InterimServerList->ServerList ;
             InterimList = InterimList->Flink ) {
             ULONG ServerElementSize;

             InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

             ServerElementSize = sizeof(SERVER_INFO_101);

             ServerElementSize += wcslen(InterimEntry->Name)*sizeof(WCHAR)+sizeof(WCHAR);

             ServerElementSize += wcslen(InterimEntry->Comment)*sizeof(WCHAR)+sizeof(WCHAR);

             TotalNeededForList += ServerElementSize;
         }

         if (TotalNeededForList != InterimServerList->TotalBytesNeeded) {
             KdPrint(("AgeInterimServerList:  Too few bytes (%ld) for interim server list.  %ld needed\n", InterimServerList->TotalBytesNeeded, TotalNeededForList));
         }
     }
#endif

    }

    return(NERR_Success);
}

PINTERIM_ELEMENT
LookupInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN LPWSTR ServerNameToLookUp
    )
{
    PLIST_ENTRY InterimList;

    for (InterimList = InterimServerList->ServerList.Flink ;
         InterimList != &InterimServerList->ServerList ;
         InterimList = InterimList->Flink ) {

        PINTERIM_ELEMENT InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);
        LONG CompareResult;

        if ((CompareResult = _wcsicmp(InterimEntry->Name, ServerNameToLookUp) == 0)) {
            return InterimEntry;
        }

        //
        //  If we went past this guy, return an error.
        //

        if (CompareResult > 0) {
            return NULL;
        }

    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\dcutil.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      dcutil.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//      the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information.
//--

//
// Common include files.
//
#include "precomp.h"
#include <iphlpint.h>
#include "dcutil.h"
#include "ipcfgtest.h"

DWORD CheckDomainConfig(IN PWSTR pwzDomainName, OUT PLIST_ENTRY plmsgOutput);
DWORD CheckAdapterDnsConfig( OUT PLIST_ENTRY plmsgOutput);
DWORD DnsDcSrvCheck(PWSTR pwzDnsDomain, OUT PLIST_ENTRY plmsgOutput);
DWORD ValidateDnsDomainName(PWSTR pwzDnsDomain,  OUT PLIST_ENTRY plmsgOutput);
PWSTR ConcatonateStrings(PWSTR pwzFirst, PWSTR pwzSecond);
BOOL AddToList(PWSTR * ppwzList, PWSTR pwz);
BOOL BuildDomainList(PWSTR * ppwzDomainList, PWSTR pwzDnsDomain);
PWSTR AllocString(PWSTR pwz);
DWORD GetInterfacesStr( PWSTR *ppwIfStr);

const PWSTR g_pwzSrvRecordPrefix = L"_ldap._tcp.dc._msdcs.";

//(nsun) DC related routines

PTESTED_DC
GetUpTestedDc(
    IN PTESTED_DOMAIN TestedDomain
    )
/*++

Routine Description:

    Returns a DC that's currently up and running.

Arguments:

    TestedDomain - Domain the DC is in

Return Value:

    Returns pointer to structure describing the DC

    NULL: There are no 'up' DCs

--*/
{
    PLIST_ENTRY ListEntry;
    PTESTED_DC TestedDc;


    //
    // Find a DC that's up to run the test
    //

    for ( ListEntry = TestedDomain->TestedDcs.Flink ;
          ListEntry != &TestedDomain->TestedDcs ;
          ListEntry = ListEntry->Flink ) {


        //
        // Loop through the list of DCs in this domain
        //

        TestedDc = CONTAINING_RECORD( ListEntry, TESTED_DC, Next );

        if ( (TestedDc->Flags & DC_IS_DOWN) == 0) {
            return TestedDc;
        }
    }

    return NULL;
}



PTESTED_DC
AddTestedDc(
            IN NETDIAG_PARAMS *pParams,
            IN OUT NETDIAG_RESULT *pResults,
            IN PTESTED_DOMAIN TestedDomain,
            IN LPWSTR ComputerName,
            IN ULONG Flags
           )
/*++

Routine Description:

    Add a DC to the list of DCs to test in a particular domain

Arguments:

    TestedDomain - Domain the DC is in

    ComputerName - Netbios or DNS computer name of the DC
        Without the leading \\

    Flags - Flags to set on the DC

Return Value:

    Returns pointer to structure describing the DC

    NULL: Memory allocation failure.

--*/
{
    PTESTED_DC TestedDc = NULL;
    PLIST_ENTRY ListEntry;
    LPWSTR Period;



    //
    // Check if the domain is already defined.
    //

    TestedDc = FindTestedDc( pResults, ComputerName );

    //
    // Ensure the DC is for the right domain
    //

    if ( TestedDc != NULL )
    {
        if ( TestedDc->TestedDomain != TestedDomain )
        {
            return NULL;
        }
    }


    //
    // Allocate a structure to describe the domain.
    //

    if ( TestedDc == NULL )
    {
        TestedDc = Malloc( sizeof(TESTED_DC) );

        if ( TestedDc == NULL )
        {
            DebugMessage(" AddTestedDc(): Out of Memory!\n");
            return NULL;
        }

        ZeroMemory( TestedDc, sizeof(TESTED_DC) );

        TestedDc->ComputerName = NetpAllocWStrFromWStr( ComputerName );

        if ( TestedDc->ComputerName == NULL )
        {
            Free(TestedDc);
            return NULL;
        }

        //
        // Convert the computername to netbios (Use the API when in becomes available.
        //

        if ((Period = wcschr( ComputerName, L'.' )) == NULL )
        {
            wcsncpy( TestedDc->NetbiosDcName, ComputerName, CNLEN );
            TestedDc->NetbiosDcName[CNLEN] = L'\0';
        }
        else
        {
            ULONG CharsToCopy = (ULONG) min( CNLEN, Period-ComputerName);

            wcsncpy( TestedDc->NetbiosDcName, ComputerName, CharsToCopy );
            TestedDc->NetbiosDcName[CharsToCopy] = '\0';
        }

        TestedDc->TestedDomain = TestedDomain;

        InsertTailList( &TestedDomain->TestedDcs, &TestedDc->Next );
    }

    //
    // Set the flags requested by the caller.
    //

//    if ( Flags & DC_IS_NT5 ) {
//        if ( TestedDc->Flags & DC_IS_NT4 ) {
//            printf("        [WARNING] '%ws' is both an NT 5 and NT 4 DC.\n", ComputerName );
//        }
//    }
//    if ( Flags & DC_IS_NT4 ) {
//        if ( TestedDc->Flags & DC_IS_NT5 ) {
//            printf("        [WARNING] '%ws' is both an NT 4 and NT 5 DC.\n", ComputerName );
//        }
//    }
    TestedDc->Flags |= Flags;

    //
    // Ensure we have the IpAddress of this DC.
    //

    (VOID) GetIpAddressForDc( TestedDc );


    //
    // Ping the DC
    //

    if ( (TestedDc->Flags & DC_PINGED) == 0  && (TestedDc->Flags & DC_IS_DOWN) == 0)
    {
        if ( !IsIcmpResponseW( TestedDc->DcIpAddress ) ) {
            DebugMessage2("    [WARNING] Cannot ping '%ws' (it must be down).\n", TestedDc->ComputerName );
            TestedDc->Flags |= DC_IS_DOWN;
            TestedDc->Flags |= DC_FAILED_PING;
        }
        TestedDc->Flags |= DC_PINGED;
    }

    //try to query DC info to check if the DC is really up
    if( (TestedDc->Flags & DC_IS_DOWN) == 0 )
    {
        PSERVER_INFO_100  pServerInfo100 = NULL;
        NET_API_STATUS  NetStatus;
        NetStatus = NetServerGetInfo( TestedDc->ComputerName,
                          100,
                          (LPBYTE *)&pServerInfo100 );
        if(NetStatus != NO_ERROR && NetStatus != ERROR_ACCESS_DENIED)
        {
            TestedDc->Flags |= DC_IS_DOWN;

            // IDS_GLOBAL_DC_DOWN   "Cannot get information for DC %ws. [%s] Assume it is down.\n"
            PrintDebug(pParams, 4, IDS_GLOBAL_DC_DOWN, TestedDc->ComputerName,
                            NetStatusToString(NetStatus));
        }
        else
            NetApiBufferFree( pServerInfo100 );

    }

    return TestedDc;
}



PTESTED_DC
FindTestedDc(
             IN OUT NETDIAG_RESULT *pResults,
             IN LPWSTR ComputerName
            )
/*++

Routine Description:

    Find the tested DC structure for the named DC

Arguments:

    ComputerName - Netbios or DNS computer name of the DC
        Without the leading \\

Return Value:

    Returns pointer to structure describing the DC

    NULL: No Such DC is currently defined

--*/
{
    PTESTED_DC TestedDc = NULL;
    PTESTED_DOMAIN TestedDomain = NULL;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListEntry2;
    WCHAR NetbiosDcName[CNLEN+1];
    LPWSTR Period;

    //
    // Convert the computername to netbios (Use the API when in becomes available.
    //

    if ((Period = wcschr( ComputerName, L'.' )) == NULL )
    {
        wcsncpy( NetbiosDcName, ComputerName, CNLEN );
        NetbiosDcName[CNLEN] = L'\0';
    }
    else
    {
        ULONG CharsToCopy = (ULONG) min( CNLEN, Period-ComputerName);

        wcsncpy( NetbiosDcName, ComputerName, CharsToCopy );
        NetbiosDcName[CharsToCopy] = '\0';
    }


    //
    //  Loop through the list of domains
    //

    for ( ListEntry = pResults->Global.listTestedDomains.Flink ;
          ListEntry != &pResults->Global.listTestedDomains ;
          ListEntry = ListEntry->Flink ) {


        //
        // Loop through the list of DCs in this domain
        //

        TestedDomain = CONTAINING_RECORD( ListEntry, TESTED_DOMAIN, Next );

        for ( ListEntry2 = TestedDomain->TestedDcs.Flink ;
              ListEntry2 != &TestedDomain->TestedDcs ;
              ListEntry2 = ListEntry2->Flink ) {


            //
            // Loop through the list of DCs in this domain
            //

            TestedDc = CONTAINING_RECORD( ListEntry2, TESTED_DC, Next );


            //
            // If the Netbios computer names match,
            //  we found it.
            //

            if ( _wcsicmp( TestedDc->NetbiosDcName, NetbiosDcName ) == 0 ) {
                return TestedDc;
            }
        }

    }

    return NULL;
}




NET_API_STATUS
GetADc(IN NETDIAG_PARAMS *pParams,
       IN OUT NETDIAG_RESULT *pResults,
       OUT PLIST_ENTRY plmsgOutput,
       IN DSGETDCNAMEW *DsGetDcRoutine,
       IN PTESTED_DOMAIN TestedDomain,
       IN DWORD Flags,
       OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
/*++

Routine Description:

    Does a DsGetDcName

Arguments:

    DsGetDcRoutine - Routine to call to find a DC

    TestedDomain - Domain to test

    Flags - Flags to pass to DsGetDcName

    DomainControllerInfo - Return Domain Controller information

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;
    PDOMAIN_CONTROLLER_INFOW LocalDomainControllerInfo = NULL;
    PDOMAIN_CONTROLLER_INFOW LocalDomainControllerInfo2;
    static BOOL s_fDcNameInitialized = FALSE;

    //
    // Initialize internal version of DsGetDcName
    //
	if( !s_fDcNameInitialized )
    {

// Commented out to port to Source Depot - smanda
#ifdef SLM_TREE
	    NetStatus = DCNameInitialize();

	    if ( NetStatus != NO_ERROR )
	    {
		    DebugMessage2("    [FATAL] Cannot initialize DsGetDcName. [%s]\n",
                         NetStatusToString(NetStatus));
            PrintGuru( NetStatus, DSGETDC_GURU );
		    goto Cleanup;
	    }
#endif

        //$REVIEW (nsun 10/05/98) make sure we just init once
        s_fDcNameInitialized = TRUE;
    }



    //
    // Try it first not asking for IP.
    //
    // Though technically wrong, specify DS_DIRECTORY_SERVICE_PREFERRED here
    // or I won't be able to tell that this is an NT 5 domain below.
    //

    NetStatus = (*DsGetDcRoutine)( NULL,
                              TestedDomain->QueryableDomainName,
                              NULL,
                              NULL,
                              DS_FORCE_REDISCOVERY |
                                DS_DIRECTORY_SERVICE_PREFERRED |
                                Flags,
                              &LocalDomainControllerInfo );

    // If DsGetDcName return ERROR_NO_SUCH_DOMAIN then try to findout the exact reason for the error
    // Based on DoctorDNS specs for join command
    if ( NetStatus == ERROR_NO_SUCH_DOMAIN && TestedDomain->QueryableDomainName != NULL && plmsgOutput != NULL ) {
        CheckDomainConfig(TestedDomain->QueryableDomainName, plmsgOutput);
    }

    if ( NetStatus != NO_ERROR ) {
        DebugMessage2( "    DsGetDcRoutine failed. [%s]\n", NetStatusToString(NetStatus));
        goto Cleanup;
    }

    //
    // Add this DC to the list of DCs in the domain
    //

    (VOID) AddTestedDc( pParams,
                        pResults,
                        TestedDomain,
                        LocalDomainControllerInfo->DomainControllerName+2,
                        (LocalDomainControllerInfo->Flags & DS_DS_FLAG ) ?
                            DC_IS_NT5 :
                            DC_IS_NT4 );

    //
    // If this DC wasn't discovered using IP,
    //  and it is an NT 5 DC,
    //  try again requiring IP.
    //
    // (I can't require IP in the first place since NT 4.0 DCs can't return
    // their IP address.)
    //

    if ( LocalDomainControllerInfo->DomainControllerAddressType != DS_INET_ADDRESS &&
         (LocalDomainControllerInfo->Flags & DS_DS_FLAG) != 0 ) {

        NetStatus = (*DsGetDcRoutine)( NULL,
                                  TestedDomain->QueryableDomainName,
                                  NULL,
                                  NULL,
                                  DS_FORCE_REDISCOVERY |
                                    DS_IP_REQUIRED |
                                    Flags,
                                  &LocalDomainControllerInfo2 );

        if ( NetStatus == NO_ERROR ) {
            NetApiBufferFree( LocalDomainControllerInfo );
            LocalDomainControllerInfo = LocalDomainControllerInfo2;

            //
            // Add this DC to the list of DCs in the domain
            //

            (VOID) AddTestedDc( pParams,
                                pResults,
                                TestedDomain,
                                LocalDomainControllerInfo->DomainControllerName+2,
                                (LocalDomainControllerInfo->Flags & DS_DS_FLAG ) ?
                                    DC_IS_NT5 :
                                    DC_IS_NT4 );
        }

    }

    //
    // Check to ensure KDC consistency
    //

    // This is also checked in DoDsGetDcName()
    if ( (LocalDomainControllerInfo->Flags & (DS_DS_FLAG|DS_KDC_FLAG)) == DS_DS_FLAG ) {
        DebugMessage3("    [WARNING] KDC is not running on NT 5 DC '%ws' in domain '%ws'.",
               LocalDomainControllerInfo->DomainControllerName,
               TestedDomain->PrintableDomainName );
    }

    //
    // Return the info to the caller
    //

    *DomainControllerInfo = LocalDomainControllerInfo;
    LocalDomainControllerInfo = NULL;
    NetStatus = NO_ERROR;

Cleanup:
    if ( LocalDomainControllerInfo != NULL ) {
        NetApiBufferFree( LocalDomainControllerInfo );
        LocalDomainControllerInfo = NULL;
    }

    return NetStatus;
}



//used in DCList and LDAP tests
BOOL
GetIpAddressForDc( PTESTED_DC TestedDc )
/*++

Routine Description:

    Get the IP address for the tested DC

Arguments:

    TestedDc - DC to get the IP address for.
    None.

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    BOOL RetVal = TRUE;
    NET_API_STATUS NetStatus;
    HOSTENT *HostEnt;
    LPSTR AnsiComputerName;

     if ( TestedDc->DcIpAddress == NULL ) {

         AnsiComputerName = NetpAllocStrFromWStr( TestedDc->ComputerName );

         if ( AnsiComputerName == NULL ) {
             DebugMessage( "Out of memory!\n" );
             RetVal = FALSE;
             TestedDc->Flags |= DC_IS_DOWN;
         } else {

             HostEnt = gethostbyname( AnsiComputerName );

             NetApiBufferFree( AnsiComputerName );

             if ( HostEnt == NULL )
             {
                 NetStatus = WSAGetLastError();
                 DebugMessage3("    [WARNING] Cannot gethostbyname for '%ws'. [%s]\n",
                                TestedDc->ComputerName, NetStatusToString(NetStatus) );
                 TestedDc->Flags |= DC_IS_DOWN;
             }
             else
             {
                 WCHAR LocalIpAddressString[NL_IP_ADDRESS_LENGTH+1];
                 NetpIpAddressToWStr( *(PULONG)HostEnt->h_addr_list[0], LocalIpAddressString );
                 TestedDc->DcIpAddress = NetpAllocWStrFromWStr( LocalIpAddressString );
                 if (TestedDc->DcIpAddress == NULL )
                 {
                     RetVal = FALSE;
                     TestedDc->Flags |= DC_IS_DOWN;
                 }
             }
         }

     }

     return RetVal;
}


DWORD CheckDomainConfig(IN PWSTR pwzDomainName, OUT PLIST_ENTRY plmsgOutput)
{
    DNS_STATUS status;
    status = ValidateDnsDomainName(pwzDomainName, plmsgOutput);
    if (status == ERROR_SUCCESS)
    {
        status = CheckAdapterDnsConfig(plmsgOutput);
        if (status == ERROR_SUCCESS)
        {
            status = DnsDcSrvCheck(pwzDomainName, plmsgOutput);
        }
        else
        {
            AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13242);
        }
    }
    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:   CheckAdapterDnsConfig
//
// Synopsis:   Check whether at least one enabled adapter/connection is
//             configured with a DNS server.
//
//-----------------------------------------------------------------------------
DWORD
CheckAdapterDnsConfig( OUT PLIST_ENTRY plmsgOutput )
{
   // IpConfig reads the registry and I can't find a good alternative way to do
   // this remotely. For now using DnsQueryConfig which is not remoteable nor
   // does it return per-adapter listings.
   //
   PIP_ARRAY pipArray;
   DNS_STATUS status;
   DWORD i, dwBufSize = sizeof(IP_ARRAY);

   status = DnsQueryConfig(DnsConfigDnsServerList, DNS_CONFIG_FLAG_ALLOC, NULL,
                           NULL, &pipArray, &dwBufSize);

   if (ERROR_SUCCESS != status || !pipArray)
   {
      DebugMessage2(L"Attempt to obtain DNS name server info failed with error %d\n", status);
      return status;
   }

   return (pipArray->AddrCount) ? ERROR_SUCCESS : DNS_INFO_NO_RECORDS;
}


//+----------------------------------------------------------------------------
//
// Function:   DnsDcSrvCheck
//
// Synopsis:   Check whether the SRV DNS record for
//             _ldap._tcp.dc._msdcs.<DNS name of Active Directory Domain>
//             is in place.
//
//-----------------------------------------------------------------------------
DWORD
DnsDcSrvCheck(PWSTR pwzDnsDomain, OUT PLIST_ENTRY plmsgOutput)
{
   PDNS_RECORD rgDnsRecs, pDnsRec;
   DNS_STATUS status;
   BOOL fSuccess;
   PWSTR pwzFullSrvRecord, pwzSrvList = NULL;

   pwzFullSrvRecord = ConcatonateStrings(g_pwzSrvRecordPrefix, pwzDnsDomain);

   if (!pwzFullSrvRecord)
   {
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   // First query for the SRV records for this 
   status = DnsQuery_W(pwzFullSrvRecord, DNS_TYPE_SRV, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDnsRecs, NULL);

   pDnsRec = rgDnsRecs;

   if (ERROR_SUCCESS == status)
   {
      if (!pDnsRec)
      {
         //  PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_NO_SRV, pwzDnsDomain);
      }
      else
      {
         PDNS_RECORD rgARecs;
         fSuccess = FALSE;

         while (pDnsRec)
         {
            if (DNS_TYPE_SRV == pDnsRec->wType)
            {
               WCHAR UnicodeDCName[MAX_PATH+1];
               NetpCopyStrToWStr( UnicodeDCName, pDnsRec->Data.Srv.pNameTarget);
               status = DnsQuery_W(UnicodeDCName, DNS_TYPE_A,
                                   DNS_QUERY_BYPASS_CACHE,
                                   NULL, &rgARecs, NULL);

               if (ERROR_SUCCESS != status || !rgARecs)
               {
                  // failure.
                  if (!AddToList(&pwzSrvList, UnicodeDCName))
                  {
                     return ERROR_NOT_ENOUGH_MEMORY;
                  }
               }
               else
               {
                  fSuccess = TRUE;
                  DebugMessage2(L"SRV name: %s\n",
                              pDnsRec->Data.Srv.nameTarget);
                  DnsRecordListFree(rgARecs, TRUE);
               }
            }
            pDnsRec = pDnsRec->pNext;
         }

         DnsRecordListFree(rgDnsRecs, TRUE);

         if (fSuccess)
         {
            // Success message
         }
         else
         {
            AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13243, 
                    pwzDnsDomain,  pwzSrvList);
            LocalFree(pwzSrvList);
         }
      }
   }
   else
   {
      PWSTR pwzDomainList;

      switch (status)
      {
      case DNS_ERROR_RCODE_FORMAT_ERROR:
      case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13244, 
                         pwzDnsDomain );
         break;

      case DNS_ERROR_RCODE_SERVER_FAILURE:
         if (!BuildDomainList(&pwzDomainList, pwzDnsDomain))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13245, 
                         pwzDnsDomain, pwzFullSrvRecord, pwzDomainList );
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_NAME_ERROR:
         if (!BuildDomainList(&pwzDomainList, pwzDnsDomain))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13246, 
                         pwzDnsDomain, pwzDnsDomain, pwzFullSrvRecord, pwzDomainList );
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_REFUSED:
         if (!BuildDomainList(&pwzDomainList, pwzDnsDomain))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13247, 
                         pwzDnsDomain, pwzDomainList );
         LocalFree(pwzDomainList);
         break;

      case DNS_INFO_NO_RECORDS:
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13248, 
                         pwzDnsDomain, pwzDnsDomain, pwzDnsDomain );
         break;

      case ERROR_TIMEOUT:
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13249);
         break;

      default:
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13250, 
                         status );
         break;
      }
   }

   LocalFree(pwzFullSrvRecord);

   return status;
}



//+----------------------------------------------------------------------------
//
// Function:   ValidateDnsDomainName
//
// Synopsis:   Validate the DNS domain name.
//
//-----------------------------------------------------------------------------
DWORD
ValidateDnsDomainName(PWSTR pwzDnsDomain,  OUT PLIST_ENTRY plmsgOutput)
{
   DNS_STATUS status;

   status = DnsValidateName_W(pwzDnsDomain, DnsNameDomain);

   switch (status)
   {
   case ERROR_INVALID_NAME:
   case DNS_ERROR_INVALID_NAME_CHAR:
   case DNS_ERROR_NUMERIC_NAME:
       AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13240, 
                       pwzDnsDomain, DNS_MAX_LABEL_LENGTH );
       return status;

   case DNS_ERROR_NON_RFC_NAME:
       //
       // Not an error, print warning message.
       //
       AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13241, 
                       pwzDnsDomain );
       break;

   case ERROR_SUCCESS:
       break;
   }

   return status;
}

PWSTR ConcatonateStrings(PWSTR pwzFirst, PWSTR pwzSecond)
{
   PWSTR pwz;

   pwz = (PWSTR)LocalAlloc(LMEM_FIXED,
                           ((int)wcslen(pwzFirst) + (int)wcslen(pwzSecond) + 1) * sizeof(WCHAR));

   if (!pwz)
   {
      return NULL;
   }

   wcscpy(pwz, pwzFirst);
   wcscat(pwz, pwzSecond);

   return pwz;
}

BOOL AddToList(PWSTR * ppwzList, PWSTR pwz)
{
   PWSTR pwzTmp;

   if (*ppwzList)
   {
      pwzTmp = (PWSTR)LocalAlloc(LMEM_FIXED,
                                 ((int)wcslen(*ppwzList) + (int)wcslen(pwz) + 3) * sizeof(WCHAR));
      if (!pwzTmp)
      {
         return FALSE;
      }

      wcscpy(pwzTmp, *ppwzList);
      wcscat(pwzTmp, L", ");
      wcscat(pwzTmp, pwz);

      LocalFree(*ppwzList);

      *ppwzList = pwzTmp;
   }
   else
   {
      pwzTmp = AllocString(pwz);

      if (!pwzTmp)
      {
         return FALSE;
      }

      *ppwzList = pwzTmp;
   }
   return TRUE;
}

BOOL BuildDomainList(PWSTR * ppwzDomainList, PWSTR pwzDnsDomain)
{
   PWSTR pwzDot, pwzTmp;

   pwzTmp = AllocString(pwzDnsDomain);

   if (!pwzTmp)
   {
      return FALSE;
   }

   pwzDot = pwzDnsDomain;

   while (pwzDot = wcschr(pwzDot, L'.'))
   {
      pwzDot++;
      if (!pwzDot)
      {
         break;
      }

      if (!AddToList(&pwzTmp, pwzDot))
      {
         return FALSE;
      }
   }

   *ppwzDomainList = pwzTmp;

   return TRUE;
}

// string helpers.

PWSTR AllocString(PWSTR pwz)
{
   PWSTR pwzTmp;

   pwzTmp = (PWSTR)LocalAlloc(LMEM_FIXED, ((int)wcslen(pwz) + 1) * sizeof(WCHAR));

   if (!pwzTmp)
   {
      return NULL;
   }

   wcscpy(pwzTmp, pwz);

   return pwzTmp;
}


VOID
NetpIpAddressToStr(
    ULONG IpAddress,
    CHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1]
    )
/*++

Routine Description:

    Convert an IP address to a string.

Arguments:

    IpAddress - IP Address to convert

    IpAddressString - resultant string.

Return Value:

    None.

--*/
{
    struct in_addr InetAddr;
    char * InetAddrString;

    //
    // Convert the address to ascii
    //
    InetAddr.s_addr = IpAddress;
    InetAddrString = inet_ntoa( InetAddr );

    //
    // Copy the string our to the caller.
    //

    if ( InetAddrString == NULL || strlen(InetAddrString) > NL_IP_ADDRESS_LENGTH ) {
        *IpAddressString = L'\0';
    } else {
        strcpy( IpAddressString, InetAddrString );
    }

    return;
}

VOID
NetpIpAddressToWStr(
    ULONG IpAddress,
    WCHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1]
    )
/*++

Routine Description:

    Convert an IP address to a string.

Arguments:

    IpAddress - IP Address to convert

    IpAddressString - resultant string.

Return Value:

    None.

--*/
{
    CHAR IpAddressStr[NL_IP_ADDRESS_LENGTH+1];
    NetpIpAddressToStr( IpAddress, IpAddressStr );
    NetpCopyStrToWStr( IpAddressString, IpAddressStr );
}


NET_API_STATUS
NetpDcBuildPing(
    IN BOOL PdcOnly,
    IN ULONG RequestCount,
    IN LPCWSTR UnicodeComputerName,
    IN LPCWSTR UnicodeUserName OPTIONAL,
    IN LPCSTR ResponseMailslotName,
    IN ULONG AllowableAccountControlBits,
    IN PSID RequestedDomainSid OPTIONAL,
    IN ULONG NtVersion,
    OUT PVOID *Message,
    OUT PULONG MessageSize
    )

/*++

Routine Description:

    Build the message to ping a DC to see if it exists.
    Copied from net\svcdlls\logonsv\netpdc.c

Arguments:

    PdcOnly - True if only the PDC should respond.

    RequestCount - Retry count of this operation.

    UnicodeComputerName - Netbios computer name of the machine to respond to.

    UnicodeUserName - Account name of the user being pinged.
        If NULL, DC will always respond affirmatively.

    ResponseMailslotName - Name of the mailslot DC is to respond to.

    AllowableAccountControlBits - Mask of allowable account types for UnicodeUserName.

    RequestedDomainSid - Sid of the domain the message is destined to.

    NtVersion - Version of the message.
        0: For backward compatibility.
        NETLOGON_NT_VERSION_5: for NT 5.0 message.
        NETLOGON_NT_VERSION_5EX: for extended NT 5.0 message

    Message - Returns the message to be sent to the DC in question.
        Buffer must be free using NetpMemoryFree().

    MessageSize - Returns the size (in bytes) of the returned message


Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - The message could not be allocated.

--*/
{
    NET_API_STATUS NetStatus;
    LPSTR Where;
    PNETLOGON_SAM_LOGON_REQUEST SamLogonRequest = NULL;
    LPSTR OemComputerName = NULL;

    //
    // If only the PDC should respond,
    //  build a primary query packet.
    //

    if ( PdcOnly ) {
        PNETLOGON_LOGON_QUERY LogonQuery;

        //
        // Allocate memory for the primary query message.
        //

        SamLogonRequest = NetpMemoryAllocate( sizeof(NETLOGON_LOGON_QUERY) );

        if( SamLogonRequest == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        LogonQuery = (PNETLOGON_LOGON_QUERY)SamLogonRequest;



        //
        // Translate to get an Oem computer name.
        //

#ifndef WIN32_CHICAGO
        OemComputerName = NetpLogonUnicodeToOem( (LPWSTR)UnicodeComputerName );
#else
        OemComputerName = MyNetpLogonUnicodeToOem( (LPWSTR)UnicodeComputerName );
#endif

        if ( OemComputerName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Build the query message.
        //

        LogonQuery->Opcode = LOGON_PRIMARY_QUERY;

        Where = LogonQuery->ComputerName;

        NetpLogonPutOemString(
                    OemComputerName,
                    sizeof(LogonQuery->ComputerName),
                    &Where );

        NetpLogonPutOemString(
                    (LPSTR) ResponseMailslotName,
                    sizeof(LogonQuery->MailslotName),
                    &Where );

        NetpLogonPutUnicodeString(
                    (LPWSTR) UnicodeComputerName,
                    sizeof( LogonQuery->UnicodeComputerName ),
                    &Where );

        // Join common code to add NT 5 specific data.


    //
    // If any DC can respond,
    //  build a logon query packet.
    //

    } else {
        ULONG DomainSidSize;

        //
        // Allocate memory for the logon request message.
        //

#ifndef WIN32_CHICAGO
        if ( RequestedDomainSid != NULL ) {
            DomainSidSize = RtlLengthSid( RequestedDomainSid );
        } else {
            DomainSidSize = 0;
        }
#else // WIN32_CHICAGO
        DomainSidSize = 0;
#endif // WIN32_CHICAGO

        SamLogonRequest = NetpMemoryAllocate(
                        sizeof(NETLOGON_SAM_LOGON_REQUEST) +
                        DomainSidSize +
                        sizeof(DWORD) // for SID alignment on 4 byte boundary
                        );

        if( SamLogonRequest == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


        //
        // Build the query message.
        //

        SamLogonRequest->Opcode = LOGON_SAM_LOGON_REQUEST;
        SamLogonRequest->RequestCount = (WORD) RequestCount;

        Where = (PCHAR) &SamLogonRequest->UnicodeComputerName;

        NetpLogonPutUnicodeString(
                (LPWSTR) UnicodeComputerName,
                sizeof(SamLogonRequest->UnicodeComputerName),
                &Where );

        NetpLogonPutUnicodeString(
                (LPWSTR) UnicodeUserName,
                sizeof(SamLogonRequest->UnicodeUserName),
                &Where );

        NetpLogonPutOemString(
                (LPSTR) ResponseMailslotName,
                sizeof(SamLogonRequest->MailslotName),
                &Where );

        NetpLogonPutBytes(
                &AllowableAccountControlBits,
                sizeof(SamLogonRequest->AllowableAccountControlBits),
                &Where );

        //
        // Place domain SID in the message.
        //

        NetpLogonPutBytes( &DomainSidSize, sizeof(DomainSidSize), &Where );
        NetpLogonPutDomainSID( RequestedDomainSid, DomainSidSize, &Where );

    }

    NetpLogonPutNtToken( &Where, NtVersion );

    //
    // Return the message to the caller.
    //

    *Message = SamLogonRequest;
    *MessageSize = (ULONG)(Where - (PCHAR)SamLogonRequest);
    SamLogonRequest = NULL;

    NetStatus = NO_ERROR;


    //
    // Free locally used resources.
    //
Cleanup:

    if ( OemComputerName != NULL ) {
        NetpMemoryFree( OemComputerName );
    }

    if ( SamLogonRequest != NULL ) {
        NetpMemoryFree( SamLogonRequest );
    }
    return NetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\dnscmn.c ===
/*++

Copyright (C) Microsoft Corporation, 1998-2002

Module Name:

    dnscmn.c

Abstract:

    Domain Name System (DNS) Netdiag Tests

Author:

    Elena Apreutesei (elenaap) 10/22/98

Revision History:

    jamesg  May 2002    -- cleanup for network info changes
    jamesg  Sept 2000   -- more scrub and cleanup

--*/


#include "precomp.h"
#include "dnscmn.h"
#include <malloc.h>


LPSTR
UTF8ToAnsi(
    IN      PSTR            szuStr
    )
//
//  note this is not MT safe
//
{
    WCHAR wszBuff[2048];
    static CHAR aszBuff[2048];

    strcpy( aszBuff, "" );

    if ( !szuStr )
    {
        return aszBuff;
    }

    if ( MultiByteToWideChar(
                CP_UTF8,
                0L,
                szuStr,
                -1,
                wszBuff,
                DimensionOf(wszBuff)
                ))
    {
            WideCharToMultiByte(
                    CP_ACP,
                    0L,
                    wszBuff,
                    -1,
                    aszBuff,
                    DimensionOf(aszBuff),
                    NULL,
                    NULL);
    }
    
    return aszBuff;
}


HRESULT
CheckDnsRegistration(
    IN      PDNS_NETINFO        pNetworkInfo,
    OUT     NETDIAG_PARAMS *    pParams,
    OUT     NETDIAG_RESULT *    pResults
    )
{
    LPSTR               pszHostName = NULL;
    LPSTR               pszPrimaryDomain = NULL;
    LPSTR               pszDomain = NULL;
    IP4_ADDRESS         dwServerIP;
    IP4_ADDRESS         dwIP;
    INT                 idx;
    INT                 idx1;
    INT                 idx2;
    BOOL                RegDnOk;
    BOOL                RegPdnOk;
    BOOL                RegDnAll;
    BOOL                RegPdnAll;
    char                szName[DNS_MAX_NAME_BUFFER_LENGTH];
    char                szIP[1500];
    DNS_RECORD          recordA[MAX_ADDRS];
    DNS_RECORD          recordPTR;
    DNS_STATUS          status;
    PREGISTRATION_INFO  pExpectedRegistration = NULL;
    HRESULT             hResult = hrOK;


    DNSDBG( TRACE, (
        "\n\nNETDIAG:  CheckDnsRegistration( %p )\n\n",
        pNetworkInfo
        ));

    // print out DNS settings
    pszHostName = (PSTR) DnsQueryConfigAlloc(
                            DnsConfigHostName_UTF8,
                            NULL );
    if (NULL == pszHostName)
    {
        //IDS_DNS_NO_HOSTNAME              "    [FATAL] Cannot find DNS host name."
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_NO_HOSTNAME);
        hResult = S_FALSE;
        goto L_ERROR;
    }

    pszPrimaryDomain = (PSTR) DnsQueryConfigAlloc(
                                DnsConfigPrimaryDomainName_UTF8,
                                NULL );
    
    // compute the expected DNS registration
    status = ComputeExpectedRegistration(
                    pszHostName,
                    pszPrimaryDomain,
                    pNetworkInfo,
                    &pExpectedRegistration,
                    pParams, 
                    pResults);

    // verifies the DNS registration
    if (pExpectedRegistration)
        hResult = VerifyDnsRegistration(
                    pszHostName, 
                    pExpectedRegistration, 
                    pParams, 
                    pResults);

L_ERROR:
    return hResult;
}


DNS_STATUS
ComputeExpectedRegistration(
    IN      LPSTR                   pszHostName,
    IN      LPSTR                   pszPrimaryDomain,
    IN      PDNS_NETINFO            pNetworkInfo,
    OUT     PREGISTRATION_INFO *    ppExpectedRegistration,
    OUT     NETDIAG_PARAMS *        pParams, 
    OUT     NETDIAG_RESULT *        pResults
    )
{
    DWORD               idx;
    DWORD               idx1;
    DNS_STATUS          status;
    char                szName[DNS_MAX_NAME_BUFFER_LENGTH];
    PDNS_NETINFO        pFazResult = NULL;
    LPSTR               pszDomain;
    DWORD               dwIP;
    PIP4_ARRAY          pDnsServers = NULL;
    PIP4_ARRAY          pNameServers = NULL;
    PIP4_ARRAY          pNS = NULL;
    IP4_ARRAY           PrimaryDNS; 
    LPWSTR              pwAdapterGuidName = NULL;
    BOOL                bRegEnabled = FALSE;
    BOOL                bAdapterRegEnabled = FALSE;

    DNSDBG( TRACE, (
        "\n\nNETDIAG:  ComputeExpectedRegistration( %s, %s, %p )\n\n",
        pszHostName,
        pszPrimaryDomain,
        pNetworkInfo
        ));

    *ppExpectedRegistration = NULL;

    for (idx = 0; idx < pNetworkInfo->AdapterCount; idx++)
    {
        PDNS_ADAPTER        padapter = pNetworkInfo->AdapterArray[idx];

//IDS_DNS_12878                  "      Interface %s\n" 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12878, padapter->pszAdapterGuidName);
        pszDomain = padapter->pszAdapterDomain;
//IDS_DNS_12879                  "        DNS Domain: %s\n" 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12879, UTF8ToAnsi(pszDomain));
//IDS_DNS_12880                  "        DNS Servers: " 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12880);
        for (idx1 = 0; idx1 < padapter->ServerCount; idx1++)
        {
            dwIP = padapter->ServerArray[idx1].IpAddress;
//IDS_DNS_12881                  "%s " 
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12881, IP_STRING(dwIP));
        }
//IDS_DNS_12882                  "\n        IP Address: " 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12882);

#if 0
    //
    //  DCR:  local addresses now kept as DNS_ADDR
    //

        if( (pNetworkInfo->AdapterArray[0])->pAdapterIPAddresses )
        {
            for(idx1 = 0; idx1 < padapter->pAdapterIPAddresses->AddrCount; idx1++)
            {
                dwIP = padapter->pAdapterIPAddresses->AddrArray[idx1];
    //IDS_DNS_12883                  "%s " 
                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12883, IP_STRING(dwIP));
            }
    //IDS_DNS_12884                  "\n" 
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12884);
        }
#endif

        pDnsServers = ServerInfoToIpArray(
                                padapter->ServerCount,
                                padapter->ServerArray
                                );

        //
        // Verify if DNS registration is enabled for interface and for adapter's DNS domain name
        //
        bRegEnabled = bAdapterRegEnabled = FALSE;
        pwAdapterGuidName = LocalAlloc(LPTR, sizeof(WCHAR)*(1+strlen(padapter->pszAdapterGuidName)));
        if (pwAdapterGuidName)
        {
                    MultiByteToWideChar(
                          CP_ACP,
                          0L,  
                          padapter->pszAdapterGuidName,  
                          -1,         
                          pwAdapterGuidName, 
                          sizeof(WCHAR)*(1+strlen(padapter->pszAdapterGuidName)) 
                          );
                    bRegEnabled = (BOOL) DnsQueryConfigDword(
                                            DnsConfigRegistrationEnabled,
                                            pwAdapterGuidName );

                    bAdapterRegEnabled = (BOOL) DnsQueryConfigDword(
                                            DnsConfigAdapterHostNameRegistrationEnabled,
                                            pwAdapterGuidName );
                    LocalFree(pwAdapterGuidName);
        }
        if(bRegEnabled)
        {
            if(pDnsServers)
            {
                // compute expected registration with PDN
                if (pszPrimaryDomain && strlen(pszPrimaryDomain))
                {
                    sprintf(szName, "%s.%s.", pszHostName, pszPrimaryDomain);

                    //
                    //  aVOID double dot terminated name
                    //      - can happen with explicit dot-terminated primary name
                    {
                        DWORD   length = strlen( szName );
                        if ( length >= 2 &&
                             szName[ length-2 ] == '.' )
                        {
                            szName[ length-1 ] = 0;
                        }
                    }

    //IDS_DNS_12886                  "        Expected registration with PDN (primary DNS domain name):\n           Hostname: %s\n" 
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12886, UTF8ToAnsi(szName));
                    pFazResult = NULL;
                    pNameServers = NULL;
                    status = DnsFindAllPrimariesAndSecondaries(
                                szName,
                                DNS_QUERY_BYPASS_CACHE,
                                pDnsServers,
                                &pFazResult,
                                &pNameServers,
                                NULL);

                    if (pFazResult)
                    {
    //IDS_DNS_12887                  "          Authoritative zone: %s\n" 
                        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12887,
UTF8ToAnsi(pFazResult->pSearchList->pszDomainOrZoneName));
    //IDS_DNS_12888                  "          Primary DNS server: %s %s\n" 
                        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12888, UTF8ToAnsi(pFazResult->AdapterArray[0]->pszAdapterDomain),
                                        IP_STRING(pFazResult->AdapterArray[0]->ServerArray[0].IpAddress));
                        if (pNameServers)
                        {
    //IDS_DNS_12889                  "          Authoritative NS:" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12889);
                            for(idx1=0; idx1 < pNameServers->AddrCount; idx1++)
    //IDS_DNS_12890              "%s " 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12890,
IP_STRING(pNameServers->AddrArray[idx1]));
    //IDS_DNS_12891              "\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12891);
                            pNS = pNameServers;                
                        }
                        else
                        {
    //IDS_DNS_12892                  "          NS query failed with %d %s\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12892, status, DnsStatusString(status));
                            PrimaryDNS.AddrCount = 1;
                            PrimaryDNS.AddrArray[0] = pFazResult->AdapterArray[0]->ServerArray[0].IpAddress;
                            pNS = &PrimaryDNS;
                        }
                        status = DnsUpdateAllowedTest_UTF8(
                                    NULL,
                                    szName,
                                    pFazResult->pSearchList->pszDomainOrZoneName,
                                    pNS);
                        if ((status == NO_ERROR) || (status == ERROR_TIMEOUT))
                            AddToExpectedRegistration(
                                pszPrimaryDomain,
                                padapter,
                                pFazResult, 
                                pNS,
                                ppExpectedRegistration);
                        else
    //IDS_DNS_12893                  "          Update is not allowed in zone %s.\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12893, UTF8ToAnsi(pFazResult->pSearchList->pszDomainOrZoneName));
                    }
                    else
                    {
    //IDS_DNS_12894                  "          [WARNING] Cannot find the authoritative server for the DNS name '%s'. [%s]\n                    The name '%s' may not be registered properly on the DNS servers.\n"
                        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12894, UTF8ToAnsi(szName), DnsStatusString(status), UTF8ToAnsi(szName));
                    }
                }

                // compute expected registration with DN for this adapter
                if (pszDomain && strlen(pszDomain) && 
                   (!pszPrimaryDomain || !strlen(pszPrimaryDomain) || 
                   (pszPrimaryDomain && pszDomain && _stricmp(pszDomain, pszPrimaryDomain))))
                { 
                    sprintf(szName, "%s.%s." , pszHostName, pszDomain);
                    //
                    //  aVOID double dot terminated name
                    //      - can happen with explicit dot-terminated domain name
                    {
                        DWORD   length = strlen( szName );
                        if ( length >= 2 &&
                             szName[ length-2 ] == '.' )
                        {
                            szName[ length-1 ] = 0;
                        }
                    }
        //IDS_DNS_12896                  "        Expected registration with adapter's DNS Domain Name:\n             Hostname: %s\n" 
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12896, UTF8ToAnsi(szName));
                
                    if (bAdapterRegEnabled)
                    {
                        
                        pFazResult = NULL;
                        pNameServers = NULL;
                        status = DnsFindAllPrimariesAndSecondaries(
                                    szName,
                                    DNS_QUERY_BYPASS_CACHE,
                                    pDnsServers,
                                    &pFazResult,
                                    &pNameServers,
                                    NULL);
                        if (pFazResult)
                        {
        //IDS_DNS_12897                  "          Authoritative zone: %s\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12897, UTF8ToAnsi(pFazResult->pSearchList->pszDomainOrZoneName));
        //IDS_DNS_12898                  "          Primary DNS server: %s %s\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12898, UTF8ToAnsi(pFazResult->AdapterArray[0]->pszAdapterDomain),
                                            IP_STRING(pFazResult->AdapterArray[0]->ServerArray[0].IpAddress));
                            if (pNameServers)
                            {
        //IDS_DNS_12899                  "          Authoritative NS:" 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12899);
                                for(idx1=0; idx1 < pNameServers->AddrCount; idx1++)
        //IDS_DNS_12900                  "%s " 
                                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12900,
IP_STRING(pNameServers->AddrArray[idx1]));
        //IDS_DNS_12901                  "\n" 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12901);
                                pNS = pNameServers;                
                            }
                            else
                            {
        //IDS_DNS_12902                  "          NS query failed with %d %s\n" 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12902, status, DnsStatusString(status));
                                PrimaryDNS.AddrCount = 1;
                                PrimaryDNS.AddrArray[0] = pFazResult->AdapterArray[0]->ServerArray[0].IpAddress;
                                pNS = &PrimaryDNS;
                            }

                            status = DnsUpdateAllowedTest_UTF8(
                                        NULL,
                                        szName,
                                        pFazResult->pSearchList->pszDomainOrZoneName,
                                        pNS);
                            if ((status == NO_ERROR) || (status == ERROR_TIMEOUT))
                                AddToExpectedRegistration(
                                    pszDomain,
                                    padapter,
                                    pFazResult, 
                                    pNS,
                                    ppExpectedRegistration);
                            else
        //IDS_DNS_12903                  "          Update is not allowed in zone %s\n" 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12903, UTF8ToAnsi(pFazResult->pSearchList->pszDomainOrZoneName));
                        }
                        else
                        {
        //IDS_DNS_12894                  "          [WARNING] Cannot find the authoritative server for the DNS name '%s'. [%s]\n                    The name '%s' may not be registered properly on the DNS servers.\n"
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12894, UTF8ToAnsi(szName), DnsStatusString(status), UTF8ToAnsi(szName));
                        }

                    }
                    else
                    {
                        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12939);
                    }
                }

                LocalFree(pDnsServers);
            }
        }
        else // if(bRegEnabled)
        {
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12947);
        }
    }
    return NO_ERROR;
}

VOID
AddToExpectedRegistration(
    IN      LPSTR                   pszDomain,
    IN      PDNS_ADAPTER            pAdapterInfo,
    IN      PDNS_NETINFO            pFazResult, 
    IN      PIP4_ARRAY              pNS,
    OUT     PREGISTRATION_INFO *    ppExpectedRegistration
    )
{
#if 0
    //
    //  DCR:  local addresses now kept as DNS_ADDR
    //
    //  note, this function doesn't seem to work anyway as the test below
    //  for existence of pAdapterInfo->pAdapterIPAddresses is backwards
    //

    PREGISTRATION_INFO  pCurrent = *ppExpectedRegistration;
    PREGISTRATION_INFO  pNew = NULL;
    PREGISTRATION_INFO  pLast = NULL;
    BOOL                done = FALSE;
    BOOL                found = FALSE;
    DWORD               i,j;
    IP4_ARRAY            ipArray;
    DWORD               dwAddrToRegister = 0;
    DWORD               dwMaxAddrToRegister;

    USES_CONVERSION;

    dwMaxAddrToRegister = DnsQueryConfigDword(
                                DnsConfigAddressRegistrationMaxCount,
                                A2W(pAdapterInfo->pszAdapterGuidName ));

    if( pAdapterInfo->pAdapterIPAddresses )
    {
        // It might be NULL
        return;
    }

    dwAddrToRegister = (pAdapterInfo->pAdapterIPAddresses->AddrCount < dwMaxAddrToRegister) ?
                               pAdapterInfo->pAdapterIPAddresses->AddrCount : dwMaxAddrToRegister;

    while(pCurrent)
    {
        if(!done &&
           !_stricmp(pCurrent->szDomainName, pszDomain) && 
           !_stricmp(pCurrent->szAuthoritativeZone, pFazResult->pSearchList->pszDomainOrZoneName) &&
           SameAuthoritativeServers(pCurrent, pNS))
        {
           // found a node under the same domain name / authoritative server list
           done = TRUE;
           if(pCurrent->dwIPCount + pAdapterInfo->pAdapterIPAddresses->AddrCount > MAX_ADDRS)
           {
//IDS_DNS_12905                  "   WARNING - more than %d IP addresses\n" 
//               AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Verbose, IDS_DNS_12905, MAX_ADDRS);
               return;
           }

           // add the new IPs
           for(i=0; i < dwAddrToRegister; i++)
           {
                pCurrent->IPAddresses[pCurrent->dwIPCount + i] = pAdapterInfo->pAdapterIPAddresses->AddrArray[i];
           }
           pCurrent->dwIPCount += dwAddrToRegister;
           
           // for each NS check if it's already in the list, if not add it
           for(i=0; i < pNS->AddrCount; i++)
           {
                found = FALSE;
                for(j=0; !found && (j < pCurrent->dwAuthNSCount); j++)
                    if(pNS->AddrArray[i] == pCurrent->AuthoritativeNS[j])
                        found = TRUE;
                if (!found && pCurrent->dwAuthNSCount < MAX_NAME_SERVER_COUNT)
                    pCurrent->AuthoritativeNS[pCurrent->dwAuthNSCount++] = pNS->AddrArray[i];
           }

           // check if DNS servers allow updates
           if (pCurrent->AllowUpdates == ERROR_TIMEOUT)
           {
               ipArray.AddrCount = 1;
               ipArray.AddrArray[0] = pFazResult->AdapterArray[0]->ServerArray[0].IpAddress;
               pCurrent->AllowUpdates = DnsUpdateTest_UTF8(
                                            NULL,       // Context handle
                                            pCurrent->szAuthoritativeZone, 
                                            0,          //DNS_UPDATE_TEST_USE_LOCAL_SYS_ACCT,
                                            &ipArray);  // use the DNS server returned from FAZ
           }
        }
        pLast = pCurrent;
        pCurrent = pCurrent->pNext;
    }

    if (!done)
    {
        // need to allocate new entry
        pNew = LocalAlloc(LMEM_FIXED, sizeof(REGISTRATION_INFO));
        if( !pNew)
            return;
        pNew->pNext = NULL;
        strcpy(pNew->szDomainName, pszDomain);
        strcpy(pNew->szAuthoritativeZone, pFazResult->pSearchList->pszDomainOrZoneName);
        pNew->dwIPCount = 0;
        for(i=0; i < dwAddrToRegister; i++)
        {
           if(pNew->dwIPCount < MAX_ADDRS)
               pNew->IPAddresses[pNew->dwIPCount++] = pAdapterInfo->pAdapterIPAddresses->AddrArray[i];
           else
           {
//IDS_DNS_12905                  "   WARNING - more than %d IP addresses\n" 
//               AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Verbose, IDS_DNS_12905, MAX_ADDRS);
               break;
           }
        }

        pNew->dwAuthNSCount = 0;
        for(i=0; i < pNS->AddrCount; i++)
        {
           if (pNew->dwAuthNSCount < MAX_NAME_SERVER_COUNT)
               pNew->AuthoritativeNS[pNew->dwAuthNSCount++] = pNS->AddrArray[i];
           else
               break;
        }
        
        // check if DNS servers allow updates
        ipArray.AddrCount = 1;
        ipArray.AddrArray[0] = pFazResult->AdapterArray[0]->ServerArray[0].IpAddress;
        pNew->AllowUpdates = DnsUpdateTest_UTF8(
                                          NULL,    // Context handle
                                          pNew->szAuthoritativeZone, 
                                          0, //DNS_UPDATE_TEST_USE_LOCAL_SYS_ACCT,
                                          &ipArray);  // use the DNS server returned from FAZ

        if(pLast)
            pLast->pNext = (LPVOID)pNew;
        else
            *ppExpectedRegistration = pNew;
    }
#endif
}


BOOL
SameAuthoritativeServers(
    IN      PREGISTRATION_INFO  pCurrent,
    IN      PIP4_ARRAY          pNS
    )
{
    BOOL same = FALSE, found = FALSE;
    DWORD i, j;

    for (i=0; i<pCurrent->dwAuthNSCount; i++)
    {
        found = FALSE;
        for (j=0; j<pNS->AddrCount; j++)
            if(pNS->AddrArray[j] == pCurrent->AuthoritativeNS[i])
                found = TRUE;
        if (found)
            same = TRUE;
    }

    return same;
}


HRESULT
VerifyDnsRegistration(
    IN      LPSTR               pszHostName,
    IN      PREGISTRATION_INFO  pExpectedRegistration,
    IN      NETDIAG_PARAMS *    pParams,  
    IN OUT  NETDIAG_RESULT *    pResults
    )
{
    PREGISTRATION_INFO  pCurrent = pExpectedRegistration;
    BOOL                regOne;
    BOOL                regAll;
    BOOL                partialMatch;
    DWORD               i;
    DWORD               j;
    DWORD               numOfMissingAddr;
    DNS_STATUS          status;
    PDNS_RECORD         pExpected=NULL;
    PDNS_RECORD         pDiff1=NULL;
    PDNS_RECORD         pDiff2=NULL;
    PDNS_RECORD         pThis = NULL;
    char                szFqdn[DNS_MAX_NAME_BUFFER_LENGTH];
    IP4_ARRAY           DnsServer;
    HRESULT             hr = hrOK;

    DNSDBG( TRACE, (
        "\n\nNETDIAG:  VerifyDnsRegistration( %s, reg=%p )\n\n",
        pszHostName,
        pExpectedRegistration ));

//IDS_DNS_12906                  "      Verify DNS registration:\n" 
    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12906);
    DnsServer.AddrCount = 1;
    while(pCurrent)
    {
        regOne = FALSE; regAll = TRUE;
        partialMatch = FALSE;
        numOfMissingAddr = 0;
        sprintf(szFqdn, "%s.%s" , pszHostName, pCurrent->szDomainName);
//IDS_DNS_12908                  "        Name: %s\n" 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12908, UTF8ToAnsi(szFqdn));
        
        // build the expected RRset
        pExpected = LocalAlloc(LMEM_FIXED, pCurrent->dwIPCount * sizeof(DNS_RECORD));
        if(!pExpected)
        {
//IDS_DNS_12909                  "        LocalAlloc() failed, exit verify\n" 
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12909);
            return S_FALSE;
        }
        memset(pExpected, 0, pCurrent->dwIPCount * sizeof(DNS_RECORD));
//IDS_DNS_12910                  "        Expected IP: " 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12910);
        for (j=0; j<pCurrent->dwIPCount; j++)
        {
            pExpected[j].pName = szFqdn;
            pExpected[j].wType = DNS_TYPE_A;
            pExpected[j].wDataLength = sizeof(DNS_A_DATA);
            pExpected[j].Data.A.IpAddress = pCurrent->IPAddresses[j];
            pExpected[j].pNext = (j < (pCurrent->dwIPCount - 1))?(&pExpected[j+1]):NULL;
            pExpected[j].Flags.S.Section = DNSREC_ANSWER;
//IDS_DNS_12911                  "%s " 
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12911, IP_STRING(pCurrent->IPAddresses[j]));
        }
//IDS_DNS_12912                  "\n" 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12912);

        // verify on each server
        for (i=0; i < pCurrent->dwAuthNSCount; i++)
        {
            DnsServer.AddrArray[0] = pCurrent->AuthoritativeNS[i];
/*
            //
            // Ping the DNS server.
            //
            IpAddressString = inet_ntoa(inetDnsServer.AddrArray[0]);
            if ( IpAddressString )
                if (!IsIcmpResponseA( IpAddressString )
                {
                    PrintStatusMessage(pParams, 12, IDS_DNS_CANNOT_PING, IpAddressString);

                    pIfResults->Dns.fOutput = TRUE;
                    AddIMessageToList(&pIfResults->Dns.lmsgOutput, Nd_Quiet, 16,
                                      IDS_DNS_CANNOT_PING, IpAddressString);
                    RetVal = FALSE;
                    goto Cleanup;
                }
*/
            pDiff1 = pDiff2 = NULL;
            status = DnsQueryAndCompare(
                            szFqdn,
                            DNS_TYPE_A,
                            DNS_QUERY_DATABASE,
                            &DnsServer,
                            NULL,       // no record results
                            NULL,       // don't want the full DNS message
                            pExpected,
                            FALSE,
                            FALSE,
                            &pDiff1,
                            &pDiff2
                            );
            if(status != NO_ERROR)
            {
                if (status == ERROR_NO_MATCH)
                {
//IDS_DNS_12913                  "          Server %s: ERROR_NO_MATCH\n" 
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12913,
IP_STRING(DnsServer.AddrArray[0]));
                    if(pDiff2)
                    {
//IDS_DNS_12914                  "            Missing IP from DNS: " 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12914);
                            for (pThis = pDiff2; pThis; pThis = pThis->pNext, numOfMissingAddr++)
//IDS_DNS_12915                  "%s " 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12915, IP_STRING (pThis->Data.A.IpAddress));
//IDS_DNS_12916                  "\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12916);
                            if (numOfMissingAddr != pCurrent->dwIPCount)
                               partialMatch = TRUE;
                    }
                    if(pDiff1)
                    {
//IDS_DNS_12917                  "            Wrong IP in DNS: " 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12917);
                            for (pThis = pDiff1; pThis; pThis = pThis->pNext)
//IDS_DNS_12918                  "%s " 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12918, IP_STRING (pThis->Data.A.IpAddress));
//IDS_DNS_12919                  "\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12919);
                    }
                }
                else
//IDS_DNS_12920                  "          Server %s: Error %d %s\n" 
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12920,
IP_STRING(DnsServer.AddrArray[0]), status, DnsStatusToErrorString_A(status));
                if ( status != ERROR_TIMEOUT )
                    regAll = FALSE;
            }
            else
            {
//IDS_DNS_12921                  "          Server %s: NO_ERROR\n" 
                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12921,
IP_STRING(DnsServer.AddrArray[0]));
                regOne = TRUE;
            }
        }
        if (regOne && !regAll)
//IDS_DNS_12922                  "          WARNING: The DNS registration is correct only on some DNS servers, pls. wait 15 min for replication and try this test again\n" 
        {
            PrintStatusMessage(pParams, 0,  IDS_DNS_12922, UTF8ToAnsi(szFqdn));
            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12922, UTF8ToAnsi(szFqdn));


        }
        if (!regOne && !regAll && !partialMatch)
//IDS_DNS_12923                  "          FATAL: The DNS registration is incorrect on all DNS servers.\n" 
        {
            PrintStatusMessage(pParams, 0,  IDS_DNS_12923, UTF8ToAnsi(szFqdn));
            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12923, UTF8ToAnsi(szFqdn));
            hr = S_FALSE;
        }

        if (!regOne && !regAll && partialMatch)
//IDS_DNS_12951                  "       [WARNING] Not all DNS registrations for %s is correct on all DNS Servers.  Please run netdiag /v /test:dns for more detail. \n"
        {
            PrintStatusMessage(pParams, 0,  IDS_DNS_12951, UTF8ToAnsi(szFqdn));
            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12951, UTF8ToAnsi(szFqdn));
            hr = S_FALSE;
        }

        if (!regOne && regAll)
//IDS_DNS_12924                  "          FATAL: All DNS servers are currently down.\n" 
        {
            PrintStatusMessage(pParams, 0,  IDS_DNS_12924, UTF8ToAnsi(szFqdn));
            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12924, UTF8ToAnsi(szFqdn));


            hr = S_FALSE;
        }

        if (regOne && regAll)
        {
            PrintStatusMessage(pParams, 6,  IDS_DNS_12940, UTF8ToAnsi(szFqdn));
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, 0,
                                IDS_DNS_12940, UTF8ToAnsi(szFqdn));


        }

        pCurrent = pCurrent->pNext;
    }
    return hr;
}


PIP4_ARRAY
ServerInfoToIpArray(
    IN      DWORD               ServerCount,
    IN      PDNS_SERVER_INFO    ServerArray
    )
{
    PIP4_ARRAY  pipDnsServers = NULL;
    DWORD       i;

    pipDnsServers = LocalAlloc(LMEM_FIXED, IP4_ARRAY_SIZE(ServerCount));
    if (!pipDnsServers)
    {
        return NULL;
    }

    pipDnsServers->AddrCount = ServerCount;
    for (i=0; i < ServerCount; i++)
    {
        pipDnsServers->AddrArray[i] = ServerArray[i].IpAddress;
    }
    
    return pipDnsServers;
}


DNS_STATUS
DnsFindAllPrimariesAndSecondaries(
    IN      LPSTR               pszName,
    IN      DWORD               dwFlags,
    IN      PIP4_ARRAY          aipQueryServers,
    OUT     PDNS_NETINFO *      ppNetworkInfo,
    OUT     PIP4_ARRAY *        ppNameServers,
    OUT     PIP4_ARRAY *        ppPrimaries
    )
{
    DNS_STATUS      status;
    PDNS_RECORD     pDnsRecord = NULL;
    PIP4_ARRAY      pDnsServers = NULL;
    DWORD           i;

    DNSDBG( TRACE, (
        "\nNETDIAG:  DnsFindAllPrimariesAndSecondaries( %s, %08x, serv==%p )\n\n",
        pszName,
        dwFlags,
        aipQueryServers ));

    //
    //  check arguments \ init OUT params
    //

    if (!pszName || !ppNetworkInfo || !ppNameServers)
        return ERROR_INVALID_PARAMETER;

    *ppNameServers = NULL;
    *ppNetworkInfo = NULL;

    //
    //  FAZ
    //

    status = DnsNetworkInformation_CreateFromFAZ(
                    pszName,
                    dwFlags,
                    aipQueryServers,
                    ppNetworkInfo );

    if ( status != NO_ERROR )
    {
        return status;
    }
    
    //
    // Get all NS records for the Authoritative Domain Name
    //

    pDnsServers = ServerInfoToIpArray(
                                ((*ppNetworkInfo)->AdapterArray[0])->ServerCount,
                                ((*ppNetworkInfo)->AdapterArray[0])->ServerArray
                                );
    status = DnsQuery_UTF8(
                    (*ppNetworkInfo)->pSearchList->pszDomainOrZoneName, 
                    DNS_TYPE_NS,
                    DNS_QUERY_BYPASS_CACHE,
                    aipQueryServers,
                    &pDnsRecord,
                    NULL);

    if (status != NO_ERROR)
        return status;

    *ppNameServers = GrabNameServersIp(pDnsRecord);

    //
    //  select primaries
    //

    if (ppPrimaries)
    {
        *ppPrimaries = NULL;
        if (*ppNameServers)
        {
            *ppPrimaries = LocalAlloc(LPTR, IP4_ARRAY_SIZE((*ppNameServers)->AddrCount));
            if(*ppPrimaries)
            {
                (*ppPrimaries)->AddrCount = 0;
                for (i=0; i<(*ppNameServers)->AddrCount; i++)
                    if(NO_ERROR == IsDnsServerPrimaryForZone_UTF8(
                                        (*ppNameServers)->AddrArray[i], 
                                        pszName))
                    {
                        (*ppPrimaries)->AddrArray[(*ppPrimaries)->AddrCount] = (*ppNameServers)->AddrArray[i];
                        ((*ppPrimaries)->AddrCount)++;
                    }
            }
        }
    }

    return status;
}

/*
VOID
CompareCachedAndRegistryNetworkInfo(PDNS_NETINFO           pNetworkInfo)
{
    DNS_STATUS              status1, status2;
    PDNS_RPC_ADAPTER_INFO   pRpcAdapterInfo = NULL, pCurrentCache;
    PDNS_RPC_SERVER_INFO    pRpcServer = NULL;
    PDNS_ADAPTER            pCurrentRegistry;
    PDNS_IP_ADDR_LIST       pIpList = NULL;
    BOOL                    cacheOk = TRUE, sameServers = TRUE, serverFound = FALSE;
    DWORD                   iCurrentAdapter, iServer, count = 0;

    status1 = GetCachedAdapterInfo( &pRpcAdapterInfo );
    status2 = GetCachedIpAddressList( &pIpList );

//IDS_DNS_12925                  "\nCheck DNS cached network info: \n" 
    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12925);
    if(status1)
    {
//IDS_DNS_12926                  "  ERROR: CRrGetAdapterInfo() failed with error %d %s\n" 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12926, status1, DnsStatusToErrorString_A(status1) );
        return;
    }
    if (!pRpcAdapterInfo)
    {
//IDS_DNS_12927                  "  ERROR: CRrGetAdapterInfo() returned NO_ERROR but empty Adapter Info\n" 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12927);
        return;
    }

    // check adapter count
    count = 0;
    for(pCurrentCache = pRpcAdapterInfo; pCurrentCache; pCurrentCache = pCurrentCache->pNext)
        count++;
    if(count != pNetworkInfo->AdapterCount)
    {
//IDS_DNS_12928                  "  ERROR: mismatch between adapter count from cache and registry\n" 
        PrintMessage(pParams, IDS_DNS_12928);
        PrintCacheAdapterInfo(pRpcAdapterInfo);
        PrintRegistryAdapterInfo(pNetworkInfo);
        return;
    }

    pCurrentCache = pRpcAdapterInfo;
    iCurrentAdapter = 0;
    while(pCurrentCache && (iCurrentAdapter < pNetworkInfo->AdapterCount))
    {
        // check DNS domain name
        pCurrentRegistry = pNetworkInfo->AdapterArray[iCurrentAdapter];
        if((pCurrentCache->pszAdapterDomainName && !pCurrentRegistry->pszAdapterDomain) ||
           (!pCurrentCache->pszAdapterDomainName && pCurrentRegistry->pszAdapterDomain) ||
           (pCurrentCache->pszAdapterDomainName && pCurrentRegistry->pszAdapterDomain &&
            _stricmp(pCurrentCache->pszAdapterDomainName, pCurrentRegistry->pszAdapterDomain)))
        {
            cacheOk = FALSE;
//IDS_DNS_12929                  "  ERROR: mismatch between cache and registry info on adapter %s\n" 
            PrintMessage(pParams, IDS_DNS_12929, pCurrentRegistry->pszAdapterGuidName);
//IDS_DNS_12930                  "    DNS Domain Name in cache: %s\n" 
            PrintMessage(pParams, IDS_DNS_12930, pCurrentCache->pszAdapterDomainName);
//IDS_DNS_12931                  "    DNS Domain Name in registry: %s\n" 
            PrintMessage(pParams, IDS_DNS_12931, pCurrentRegistry->pszAdapterDomain);
        }

        // check DNS server list
        sameServers = TRUE;
        pRpcServer = pCurrentCache->pServerInfo;
        count = 0;
        while(pRpcServer)
        {
            count++;
            serverFound = FALSE;
            for (iServer = 0; iServer < pCurrentRegistry->ServerCount; iServer++)
                if(pRpcServer->ipAddress == (pCurrentRegistry->aipServers[iServer]).ipAddress)
                    serverFound = TRUE;
            if(!serverFound)
                sameServers = FALSE;
            pRpcServer = pRpcServer->pNext;
        }
        if (count != pCurrentRegistry->ServerCount)
            sameServers = FALSE;
        if(!sameServers)
        {
            cacheOk = FALSE;
//IDS_DNS_12932                  "  ERROR: mismatch between cache and registry info on adapter %s\n" 
            PrintMessage(pParams, IDS_DNS_12932, pCurrentRegistry->pszAdapterGuidName);
//IDS_DNS_12933                  "    DNS server list in cache: " 
            PrintMessage(pParams, IDS_DNS_12933);
            for( pRpcServer = pCurrentCache->pServerInfo; pRpcServer; pRpcServer = pRpcServer->pNext)
//IDS_DNS_12934                  "%s " 
                PrintMessage(pParams, IDS_DNS_12934, IP_STRING(pRpcServer->ipAddress));
//IDS_DNS_12935                  "\n    DNS server list in registry: " 
            PrintMessage(pParams, IDS_DNS_12935);
            for (iServer = 0; iServer < pCurrentRegistry->ServerCount; iServer++)
//IDS_DNS_12936                  "%s " 
                PrintMessage(pParams, IDS_DNS_12936, IP_STRING((pCurrentRegistry->aipServers[iServer]).ipAddress));
//IDS_DNS_12937                  "\n" 
            PrintMessage(pParams, IDS_DNS_12937);
        }
        
        pCurrentCache = pCurrentCache->pNext;
        iCurrentAdapter++;
    }
    if (cacheOk)
//IDS_DNS_12938                  "  NO_ERROR\n" 
        PrintMessage(pParams, IDS_DNS_12938);
}
*/

DNS_STATUS
DnsQueryAndCompare(
    IN      LPSTR           pszName,
    IN      WORD            wType,
    IN      DWORD           fOptions,
    IN      PIP4_ARRAY      aipServers              OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResultsSet       OPTIONAL,
    IN OUT  PVOID *         pResponseMsg            OPTIONAL,
    IN      PDNS_RECORD     pExpected               OPTIONAL, 
    IN      BOOL            bInclusionOk,
    IN      BOOL            bUnicode,
    IN OUT  PDNS_RECORD *   ppDiff1                 OPTIONAL,
    IN OUT  PDNS_RECORD *   ppDiff2                 OPTIONAL
    )
{
    BOOL            bCompare = FALSE;
    DNS_STATUS      status;
    DNS_RRSET       rrset;
    PDNS_RECORD     pDnsRecord = NULL;
    PDNS_RECORD     pAnswers = NULL;
    PDNS_RECORD     pAdditional = NULL;
    PDNS_RECORD     pLastAnswer = NULL;
    BOOL            bIsLocal = FALSE;

    DNSDBG( TRACE, (
        "\nNETDIAG:  DnsQueryAndCompare( %s, type=%d, %08x, serv==%p )\n\n",
        pszName,
        wType,
        fOptions,
        aipServers ));

    //
    // Run the query and get the result 
    //

    if ( fOptions | DNS_QUERY_DATABASE )
    {
        if (!aipServers || !aipServers->AddrCount)
        {
            return ERROR_INVALID_PARAMETER;
        }
        status = QueryDnsServerDatabase(
                    pszName,
                    wType,
                    aipServers->AddrArray[0],
                    ppQueryResultsSet,
                    bUnicode,
                    &bIsLocal );
    }
    else
    {
        if ( !bUnicode )
        {
            status = DnsQuery_UTF8(
                        pszName,
                        wType,
                        fOptions,
                        aipServers,
                        ppQueryResultsSet,
                        pResponseMsg );
        }
        else            // Unicode call
        {
            status = DnsQuery_W(
                        (LPWSTR)pszName,
                        wType,
                        fOptions,
                        aipServers,
                        ppQueryResultsSet,
                        pResponseMsg);
        }
    }
    
    if ( pExpected && !status )  //succeed, compare the result
    {
        // no need to compare if wanted reponse from database and result is from outside
        if ( (fOptions | DNS_QUERY_DATABASE) && !bIsLocal )
        {
            return DNS_INFO_NO_RECORDS;
        }

        pDnsRecord = *ppQueryResultsSet;

        //
        //  Truncate temporary the record set to answers only 
        //
        
        if ((pDnsRecord == NULL) || (pDnsRecord->Flags.S.Section > DNSREC_ANSWER))
        {
            pAnswers = NULL;
            pAdditional = pDnsRecord;
        }
        else
        {
            pAnswers = pDnsRecord;
            pAdditional = pDnsRecord;
            while (pAdditional->pNext && pAdditional->pNext->Flags.S.Section == DNSREC_ANSWER)
                pAdditional = pAdditional->pNext;
            if(pAdditional->pNext)
            {
                pLastAnswer = pAdditional;
                pAdditional = pAdditional->pNext;
                pLastAnswer->pNext = NULL;
            }
            else
                pAdditional = NULL;
        }

        //
        //  Compare the answer with what's expected
        //
        status = DnsRecordSetCompare(
                        pAnswers,
                        pExpected, 
                        ppDiff1,
                        ppDiff2);
        //
        //  Restore the list
        //
        if (pAnswers && pAdditional)
        {
            pLastAnswer->pNext = pAdditional;
        }

        // 
        // check if inclusion acceptable 
        //
        if (status == TRUE)
            status = NO_ERROR;
        else
            if (bInclusionOk && (ppDiff2 == NULL))
                status = NO_ERROR;
            else
                status = ERROR_NO_MATCH;
    }

    return( status );
}


DNS_STATUS
QueryDnsServerDatabase(
    IN      LPSTR           pszName,
    IN      WORD            wType,
    IN      IP4_ADDRESS     ServerIp,
    OUT     PDNS_RECORD *   ppDnsRecord,
    IN      BOOL            bUnicode,
    OUT     BOOL *          pIsLocal
    )
{
    PDNS_RECORD     pDnsRecord1 = NULL;
    PDNS_RECORD     pDnsRecord2 = NULL;
    PDNS_RECORD     pdiff1 = NULL;
    PDNS_RECORD     pdiff2 = NULL;
    DNS_STATUS      status1;
    DNS_STATUS      status2;
    DNS_STATUS      ret = NO_ERROR;
    PIP4_ARRAY      pipServer = NULL;
    BOOL            bMatch = FALSE;
    DWORD           dwTtl1;
    DWORD           dwTtl2;

    DNSDBG( TRACE, (
        "\nNETDIAG:  QueryDnsServerDatabase( %s%S, type=%d, %s )\n\n",
        bUnicode ? "" : pszName,
        bUnicode ? (PWSTR)pszName : L"",
        wType,
        IP4_STRING( ServerIp ) ));

    //
    //  init results \ validate
    //

    *pIsLocal = FALSE;
    *ppDnsRecord = NULL;

    if ( ServerIp == INADDR_NONE )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    pipServer = Dns_CreateIpArray( 1 );
    if ( ! pipServer )
    {
        return ERROR_OUTOFMEMORY;
    }

    pipServer->AddrArray[0] = ServerIp;

    status1 = DnsQuery_UTF8(
                    pszName, 
                    wType, 
                    DNS_QUERY_BYPASS_CACHE, 
                    pipServer, 
                    &pDnsRecord1, 
                    NULL
                    );
    
    if (status1 != NO_ERROR)
        status2 = status1;
    else
    {
        Sleep(1500);
        status2 = DnsQuery_UTF8(
                        pszName, 
                        wType, 
                        DNS_QUERY_BYPASS_CACHE, 
                        pipServer, 
                        &pDnsRecord2, 
                        NULL
                        );
    }

    if ((status1 == ERROR_TIMEOUT) || (status2 == ERROR_TIMEOUT))
    {
        ret = ERROR_TIMEOUT;
        goto Cleanup;
    }

    if ((status1 != NO_ERROR) || (status2 != NO_ERROR))
    {
        ret = (status1 != NO_ERROR)?status1:status2;
        goto Cleanup;
    }

    bMatch = DnsRecordSetCompare(
                        pDnsRecord1,
                        pDnsRecord2,
                        &pdiff1,
                        &pdiff2
                        );
    if (!bMatch)
    {
        ret = DNS_ERROR_TRY_AGAIN_LATER;
        goto Cleanup;
    }
    
    if (GetAnswerTtl( pDnsRecord1, &dwTtl1 ) && GetAnswerTtl( pDnsRecord2, &dwTtl2 ))
        if ( dwTtl1 != dwTtl2 )
        {
            ret = NO_ERROR;
            *pIsLocal = FALSE;
        }
        else 
        {
            ret = NO_ERROR;
            *pIsLocal = TRUE;
        }
    else
        ret = DNS_INFO_NO_RECORDS;

Cleanup:

    Dns_Free( pipServer );

    if (pdiff1)
        DnsRecordListFree( pdiff1, TRUE );
    if (pdiff2)
      DnsRecordListFree( pdiff2, TRUE );
    if (pDnsRecord1)
        DnsRecordListFree( pDnsRecord1, TRUE );
    if (pDnsRecord2 && (ret != NO_ERROR))
        DnsRecordListFree( pDnsRecord2, TRUE );
    if (ret == NO_ERROR)
        *ppDnsRecord = pDnsRecord2;
    else 
        *ppDnsRecord = NULL;
    return ret;
}


BOOL
GetAnswerTtl(
    IN      PDNS_RECORD     pRec,
    OUT     PDWORD          pTtl
    )
{
    PDNS_RECORD     pDnsRecord = NULL;
    BOOL            bGotAnswer = FALSE;

    *pTtl = 0;

    //
    //  Look for answer section
    //
        
    for (pDnsRecord = pRec; !bGotAnswer && pDnsRecord; pDnsRecord = pDnsRecord->pNext)
    {
        if (pDnsRecord->Flags.S.Section == DNSREC_ANSWER)
        {
            bGotAnswer = TRUE;
            *pTtl = pDnsRecord->dwTtl;
        }
    }
    
    return bGotAnswer;
}


// Get A records from additional section and build a PIP4_ARRAY

PIP4_ARRAY
GrabNameServersIp(
    IN      PDNS_RECORD     pDnsRecord
    )
{
    DWORD       i = 0;
    PDNS_RECORD pCurrent = pDnsRecord;
    PIP4_ARRAY   pIpArray = NULL;
    
    // count records
    while (pCurrent)
    {
        if((pCurrent->wType == DNS_TYPE_A) &&
           (pCurrent->Flags.S.Section == DNSREC_ADDITIONAL))
           i++;
        pCurrent = pCurrent->pNext;
    }

    if (!i)
        return NULL;

    // allocate PIP4_ARRAY
    pIpArray = LocalAlloc(LMEM_FIXED, IP4_ARRAY_SIZE(i));
    if (!pIpArray)
        return NULL;

    // fill PIP4_ARRAY
    pIpArray->AddrCount = i;
    pCurrent = pDnsRecord;
    i=0;
    while (pCurrent)
    {
        if((pCurrent->wType == DNS_TYPE_A) && (pCurrent->Flags.S.Section == DNSREC_ADDITIONAL))
            (pIpArray->AddrArray)[i++] = pCurrent->Data.A.IpAddress;
        pCurrent = pCurrent->pNext;
    }
    return pIpArray;
}


DNS_STATUS
DnsUpdateAllowedTest_W(
    IN      HANDLE          hContextHandle OPTIONAL,
    IN      PWSTR           pwszName,
    IN      PWSTR           pwszAuthZone,
    IN      PIP4_ARRAY      pAuthDnsServers
    )
{
    PDNS_RECORD     pResult = NULL;
    DNS_STATUS      status;
    BOOL            bAnyAllowed = FALSE;
    BOOL            bAllTimeout = TRUE;
    DWORD           i;

    DNSDBG( TRACE, (
        "\nNETDIAG:  DnsUpdateAllowedTest_W()\n"
        "\thand     = %p\n"
        "\tname     = %S\n"
        "\tzone     = %S\n"
        "\tservers  = %p\n",
        hContextHandle,
        pwszName,
        pwszAuthZone,
        pAuthDnsServers ));

    // 
    // Check arguments
    //
    if (!pwszName || !pwszAuthZone || !pAuthDnsServers || !pAuthDnsServers->AddrCount)
        return ERROR_INVALID_PARAMETER;

    // 
    // go through server list 
    //
    for(i=0; i<pAuthDnsServers->AddrCount; i++)
    {
        //
        // verify if server is a primary
        //
        status = IsDnsServerPrimaryForZone_W(
                    pAuthDnsServers->AddrArray[i],
                    pwszAuthZone);
        switch(status)
        {
        case ERROR_TIMEOUT:
        case DNS_ERROR_RCODE:
            //
            // it's ok to go check the next server; this one timeouted or it's a secondary
            //
            break; 
        case NO_ERROR:  // server is a primary
            //
            // Check if update allowed
            //
            status = DnsUpdateTest_W(
                hContextHandle,
                pwszName,
                0,
                pAuthDnsServers);
            switch(status)
            {
            case ERROR_TIMEOUT:
                break;
            case NO_ERROR:
            case DNS_ERROR_RCODE_YXDOMAIN:
                return NO_ERROR;
                break;
            case DNS_ERROR_RCODE_REFUSED:
            default:
                return status;
                break;
            }
            break;
        default:
            return status;
            break;
        }
    }
    return ERROR_TIMEOUT;
}


DNS_STATUS
DnsUpdateAllowedTest_UTF8(
    IN      HANDLE          hContextHandle OPTIONAL,
    IN      PSTR            pszName,
    IN      PSTR            pszAuthZone,
    IN      PIP4_ARRAY      pAuthDnsServers
    )
{
    PDNS_RECORD     pResult = NULL;
    DNS_STATUS      status;
    BOOL            bAnyAllowed = FALSE;
    BOOL            bAllTimeout = TRUE;
    DWORD           i;

    DNSDBG( TRACE, (
        "\nNETDIAG:  DnsUpdateAllowedTest_UTF8()\n"
        "\thand     = %p\n"
        "\tname     = %s\n"
        "\tzone     = %s\n"
        "\tservers  = %p\n",
        hContextHandle,
        pszName,
        pszAuthZone,
        pAuthDnsServers ));

    // 
    // Check arguments
    //
    if (!pszName || !pszAuthZone || !pAuthDnsServers || !pAuthDnsServers->AddrCount)
        return ERROR_INVALID_PARAMETER;

    // 
    // go through server list 
    //
    for(i=0; i<pAuthDnsServers->AddrCount; i++)
    {
        //
        // verify if server is a primary
        //
        status = IsDnsServerPrimaryForZone_UTF8(
                    pAuthDnsServers->AddrArray[i],
                    pszAuthZone);
        switch(status)
        {
        case ERROR_TIMEOUT:
        case DNS_ERROR_RCODE:
            //
            // it's ok to go check the next server; this one timeouted or it's a secondary
            //
            break; 
        case NO_ERROR:  // server is a primary
            //
            // Check if update allowed
            //
            status = DnsUpdateTest_UTF8(
                        hContextHandle,
                        pszName,
                        0,
                        pAuthDnsServers);
            switch(status)
            {
            case ERROR_TIMEOUT:
                    break;
            case NO_ERROR:
            case DNS_ERROR_RCODE_YXDOMAIN:
                    return NO_ERROR;
                    break;
            case DNS_ERROR_RCODE_REFUSED:
            default:
                return status;
                break;
            }
            break;
        default:
            return status;
            break;
        }
    }
    return ERROR_TIMEOUT;
}


DNS_STATUS
IsDnsServerPrimaryForZone_UTF8(
    IN      IP4_ADDRESS     Ip,
    IN      PSTR            pZone
    )
{
    PDNS_RECORD     pDnsRecord = NULL;
    DNS_STATUS      status;
    IP4_ARRAY       ipArray;
    PIP4_ARRAY      pResult = NULL;
    BOOL            bFound = FALSE;
    DWORD           i;

    //
    // query for SOA
    //
    ipArray.AddrCount = 1;
    ipArray.AddrArray[0] = Ip;
    status = DnsQuery_UTF8(
                pZone,
                DNS_TYPE_SOA,
                DNS_QUERY_BYPASS_CACHE,
                &ipArray,
                &pDnsRecord,
                NULL);

    if(status == NO_ERROR)
    {
        pResult = GrabNameServersIp(pDnsRecord);
        if (pResult)
        {
            bFound = FALSE;
            for (i=0; i<pResult->AddrCount; i++)
                if(pResult->AddrArray[i] == Ip)
                    bFound = TRUE;
            LocalFree(pResult);
            if(bFound)
                return NO_ERROR;
            else
                return DNS_ERROR_RCODE;
        }
        else
            return DNS_ERROR_ZONE_CONFIGURATION_ERROR;
    }
    else
        return status;
}


DNS_STATUS
IsDnsServerPrimaryForZone_W(
    IN      IP4_ADDRESS     Ip,
    IN      PWSTR           pZone
    )
{
    PDNS_RECORD     pDnsRecord = NULL;
    DNS_STATUS      status;
    IP4_ARRAY       ipArray;
    PIP4_ARRAY      pResult = NULL;
    BOOL            bFound = FALSE;
    DWORD           i;

    //
    // query for SOA
    //

    ipArray.AddrCount = 1;
    ipArray.AddrArray[0] = Ip;
    status = DnsQuery_W(
                pZone,
                DNS_TYPE_SOA,
                DNS_QUERY_BYPASS_CACHE,
                &ipArray,
                &pDnsRecord,
                NULL);

    if( status == NO_ERROR )
    {
        pResult = GrabNameServersIp(pDnsRecord);
        if (pResult)
        {
            bFound = FALSE;
            for (i=0; i<pResult->AddrCount; i++)
            {
                if(pResult->AddrArray[i] == Ip)
                    bFound = TRUE;
            }
            LocalFree(pResult);
            if(bFound)
                return NO_ERROR;
            else
                return DNS_ERROR_RCODE;
        }
        else
            return DNS_ERROR_ZONE_CONFIGURATION_ERROR;
    }
    else
        return status;
}


DNS_STATUS
GetAllDnsServersFromRegistry(
    IN      PDNS_NETINFO    pNetworkInfo,
    OUT     PIP4_ARRAY *    ppIpArray
    )
{
    DNS_STATUS  status = NO_ERROR;
    DWORD       i;
    DWORD       j;
    DWORD       idx;
    DWORD       idx1;
    DWORD       count = 0;
    DWORD       dwIP;
    BOOL        bFound = FALSE;
    PIP_ARRAY   parray = NULL;


    DNSDBG( TRACE, (
        "\nNETDIAG:  GetAllDnsServersFromRegistry()\n"
        "\tnetinfo  = %p\n"
        "\tpparray  = %p\n",
        pNetworkInfo,
        ppIpArray ));

    //
    //  DCR:  eliminate this routine
    //      we already have network info->IP4 routine in dnsapi.dll
    //

    *ppIpArray = NULL;

    if (!pNetworkInfo)
    {
        //
        // Get the DNS Network Information
        // Force rediscovery
        //

        pNetworkInfo = DnsQueryConfigAlloc(
                            DnsConfigNetworkInfoUTF8,
                            NULL );
        if (!pNetworkInfo)
        {
            status = GetLastError(); 
            return status;
        }
    }

    for (idx = 0; idx < pNetworkInfo->AdapterCount; idx++)
    {
        count += pNetworkInfo->AdapterArray[idx]->ServerCount;
    }

    if( count == 0 )
    {
        return DNS_ERROR_INVALID_DATA;
    }

    parray = LocalAlloc(LPTR, sizeof(DWORD) + count*sizeof(IP_ADDRESS));
    if ( !parray )
    {
        return GetLastError();
    }
    
    i = 0;
    for (idx = 0; idx < pNetworkInfo->AdapterCount; idx++)
    {
        PDNS_ADAPTER      padapter = pNetworkInfo->AdapterArray[idx];

        for (idx1 = 0; idx1 < padapter->ServerCount; idx1++)
        {
            dwIP = padapter->ServerArray[idx1].IpAddress;
            bFound = FALSE;
            if ( i>0 )
            {
                for (j = 0; j < i; j++)
                {
                    if(dwIP == parray->AddrArray[j])
                        bFound = TRUE;
                }
            }
            if (!bFound)
                parray->AddrArray[i++] = dwIP;
        }
    }

    parray->AddrCount = i;
    *ppIpArray = parray;

    return DNS_ERROR_RCODE_NO_ERROR;
}

//
//  End dnscmn.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\domutil.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      domutil.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//      the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information. 
//--

//
// Common include files.
//
#include "precomp.h"
#include "domutil.h"

#include "ipcfgtest.h"


/*!--------------------------------------------------------------------------
    AddTestedDomain
        Add a domain to the list of domains to test.
        
        Arguments:

            pswzNetbiosDomainName - Name of the domain.
                If pswzDnsDomainName is NULL, this can be either a netbios or dns domain name.
                If pswzDnsDomainName is not NULL, this must be the netbios name of the domain.

            pwszDnsDomainName - Another name of the domain.
                If specified, this must be the DNS name of the domain.

    
            PrimaryDomain - True if this is the primary domain
        
        Return Value:
        
            Returns pointer to structure describing the domain
            NULL: Memory allocation failure.
    Author: KennT
 ---------------------------------------------------------------------------*/
PTESTED_DOMAIN
AddTestedDomain(
                IN NETDIAG_PARAMS *pParams,
                IN NETDIAG_RESULT *pResults,
                IN LPWSTR pswzNetbiosDomainName,
                IN LPWSTR pswzDnsDomainName,
                IN BOOL bPrimaryDomain
    )
{
    PTESTED_DOMAIN pTestedDomain = NULL;
    PLIST_ENTRY pListEntry;
    BOOL fIsNetbios;
    BOOL fIsDns;

    //
    // Determine if the passed in parameters are Netbios or DNS names
    //

    if ( pswzDnsDomainName == NULL ) {
        fIsDns = NetpDcValidDnsDomain( pswzNetbiosDomainName );
        fIsNetbios = NetpIsDomainNameValid( pswzNetbiosDomainName );
        // Don't allow a single name to be both netbios and dns.
        if ( fIsDns && fIsNetbios ) {
            //
            // If there is a period in the name,
            //  it is a DNS name, otherwise
            //  it is a Netbios Name
            //
            if ( wcschr( pswzNetbiosDomainName, L'.' ) != NULL ) {
                fIsNetbios = FALSE;
            } else {
                fIsDns = FALSE;
            }
        }

        if ( !fIsNetbios && !fIsDns ) {
            DebugMessage2("'%ws' is not a valid domain name\n\n", pswzNetbiosDomainName );
            return NULL;
        }

        if ( fIsDns ) {
            pswzDnsDomainName = pswzNetbiosDomainName;
        }

        if ( !fIsNetbios ) {
            pswzNetbiosDomainName = NULL;
        }

    } else {

        fIsNetbios = NetpIsDomainNameValid( pswzNetbiosDomainName );

        if ( !fIsNetbios ) {
            DebugMessage2("'%ws' is not a valid Netbios domain name\n\n", pswzNetbiosDomainName );
            return NULL;
        }

        fIsDns = NetpDcValidDnsDomain( pswzDnsDomainName );

        if ( !fIsDns ) {
            DebugMessage2("'%ws' is not a valid DNS domain name\n\n", pswzDnsDomainName );
            return NULL;
        }
    }

    //
    // Check if the domain is already defined.
    //

    for ( pListEntry = pResults->Global.listTestedDomains.Flink ;
          pListEntry != &pResults->Global.listTestedDomains ;
          pListEntry = pListEntry->Flink )
    {
        //
        // If the entry is found,
        //  use it.
        //

        pTestedDomain = CONTAINING_RECORD( pListEntry, TESTED_DOMAIN, Next );

        if ( pswzNetbiosDomainName != NULL &&
             pTestedDomain->NetbiosDomainName != NULL &&
             _wcsicmp( pTestedDomain->NetbiosDomainName, pswzNetbiosDomainName ) == 0 ) {

            //
            // The netbios domain name matched.
            //  So the DNS name must match if it exists.
            //

            if ( pswzDnsDomainName != NULL &&
                 pTestedDomain->DnsDomainName != NULL ) {

                if ( !NlEqualDnsName( pTestedDomain->DnsDomainName, pswzDnsDomainName ) ) {
                    DebugMessage3("'%ws' and '%ws' DNS domain names different\n\n", pTestedDomain->DnsDomainName, pswzDnsDomainName );
                    return NULL;
                }
            }

            break;
        }

        if ( pswzDnsDomainName != NULL &&
             pTestedDomain->DnsDomainName != NULL &&
             NlEqualDnsName( pTestedDomain->DnsDomainName, pswzDnsDomainName ) ) {
            break;
        }

        pTestedDomain = NULL;
    }

    //
    // Allocate a structure to describe the domain.
    //

    if ( pTestedDomain == NULL )
    {
        pTestedDomain = Malloc( sizeof(TESTED_DOMAIN) );
        if ( pTestedDomain == NULL )
        {
            PrintMessage(pParams, IDS_GLOBAL_OutOfMemory);
            return NULL;
        }
        
        ZeroMemory( pTestedDomain, sizeof(TESTED_DOMAIN) );

        InitializeListHead( &pTestedDomain->TestedDcs );

        InsertTailList( &pResults->Global.listTestedDomains, &pTestedDomain->Next );
    }

    //
    // Update the domain name.
    //

    if ( pTestedDomain->DnsDomainName == NULL && pswzDnsDomainName != NULL ) {
        pTestedDomain->DnsDomainName = NetpAllocWStrFromWStr( pswzDnsDomainName );

        if ( pTestedDomain->DnsDomainName == NULL ) {
            PrintMessage( pParams, IDS_GLOBAL_OutOfMemory);
            return NULL;
        }
    }

    if ( pTestedDomain->NetbiosDomainName == NULL && pswzNetbiosDomainName != NULL ) {
        pTestedDomain->NetbiosDomainName = NetpAllocWStrFromWStr( pswzNetbiosDomainName );

        if ( pTestedDomain->NetbiosDomainName == NULL ) {
            PrintMessage( pParams, IDS_GLOBAL_OutOfMemory);
            return NULL;
        }
    }


    //
    // Fill in other fields.
    //

    if ( bPrimaryDomain ) {
        pTestedDomain->fPrimaryDomain = TRUE;
    }

    if ( pTestedDomain->fPrimaryDomain ) {
        pTestedDomain->QueryableDomainName = NULL;
    } else {
        //
        // The queryable domain name is the DNS domain name (if known)
        if ( pTestedDomain->DnsDomainName != NULL ) {
            pTestedDomain->QueryableDomainName = pTestedDomain->DnsDomainName;
        } else {
            pTestedDomain->QueryableDomainName = pTestedDomain->NetbiosDomainName;
        }
    }

    // The printable domain name is the Netbios domain name (if known)
    if (pTestedDomain->NetbiosDomainName != NULL ) {
        pTestedDomain->PrintableDomainName = pTestedDomain->NetbiosDomainName;
    } else {
        pTestedDomain->PrintableDomainName = pTestedDomain->DnsDomainName;
    }


    return pTestedDomain;
}

BOOL
NetpDcValidDnsDomain(
    IN LPCWSTR DnsDomainName
)
/*++

Routine Description:

    Returns whether the specified string is a valid DNS Domain name.

Arguments:


    DnsDomainName - DNS domain name to validate.

Return Value:

    TRUE - The specified name is syntactically a DNS Domain name.

    FALSE - The specified name in not syntactically a DNS Domain name.

--*/
{
    DNS_STATUS DnsStatus;
    DnsStatus = DnsValidateDnsName_W( DnsDomainName );

    if ( DnsStatus == ERROR_SUCCESS ||
         DnsStatus == DNS_ERROR_NON_RFC_NAME ) {
        return TRUE;
    }

    return FALSE;

}


BOOL
NlEqualDnsName(
    IN LPCWSTR Name1,
    IN LPCWSTR Name2
    )
/*++

Routine Description:

    This routine compares two DNS names for equality.

    Case is ignored.  A single trailing . is ignored.
    Null is compared equal to a zero length string.

Arguments:

    Name1 - First DNS name to compare

    Name2 - Second DNS name to compare

Return Value:

    TRUE: DNS names are equal.

--*/
{
    if ( Name1 == NULL ) {
        return (Name2 == NULL);
    } else if ( Name2 == NULL ) {
        return FALSE;
    }

    return DnsNameCompare_W( (LPWSTR) Name1, (LPWSTR) Name2 );
}


// from net\netlib\names.c
BOOL
NetpIsDomainNameValid(
    IN LPWSTR DomainName
    )

/*++

Routine Description:
    NetpIsDomainNameValid checks for "domain" format.
    The name is only checked syntactically; no attempt is made to determine
    whether or not a domain with that name actually exists.

Arguments:

    DomainName - Supplies an alleged Domain name.

Return Value:

    BOOL - TRUE if name is syntactically valid, FALSE otherwise.

--*/
{
    NET_API_STATUS ApiStatus = NO_ERROR;
    WCHAR CanonBuf[DNLEN+1];

    if (DomainName == (LPWSTR) NULL) {
        return (FALSE);
    }
    if ( (*DomainName) == (TCHAR)'\0' ) {
        return (FALSE);
    }

    ApiStatus = NetpNameCanonicalize(
            NULL,                       // no server name
            DomainName,                 // name to validate
            CanonBuf,                   // output buffer
            (DNLEN+1) * sizeof(WCHAR), // output buffer size
            NAMETYPE_DOMAIN,           // type
            0 );                       // flags: none

    return (ApiStatus == NO_ERROR);

} // NetpIsDomainNameValid
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\domutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       domutil.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_DOMUTIL
#define HEADER_DOMUTIL

PTESTED_DOMAIN
AddTestedDomain(
                IN NETDIAG_PARAMS *pParams,
                IN NETDIAG_RESULT *pResults,
                IN LPWSTR pswzNetbiosDomainName,
                IN LPWSTR pswzDnsDomainName,
                IN BOOL bPrimaryDomain
    );

BOOL
NetpIsDomainNameValid(
    IN LPWSTR DomainName
    );

BOOL
NetpDcValidDnsDomain(
    IN LPCWSTR DnsDomainName
    );

BOOL
NlEqualDnsName(
    IN LPCWSTR Name1,
    IN LPCWSTR Name2
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\dsgetdc.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      dsgetdc.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "objbase.h"

VOID PrintDsGetDcName(IN NETDIAG_RESULT *pResults,
                      IN OUT PLIST_ENTRY plmsgOutput,
					  IN PDOMAIN_CONTROLLER_INFOW DomainControllerInfo);

NET_API_STATUS SetPrimaryGuid(IN GUID *GuidToSet);


HRESULT
DsGetDcTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
/*++

Routine Description:

    Ensure that we can find domain controllers

Arguments:

    None.

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
	NET_API_STATUS NetStatus;
	NET_API_STATUS LocalNetStatus;
	BOOL RetVal = TRUE;
	HRESULT		hr = hrOK;
	LPTSTR	pszDcType;
	
	PTESTED_DOMAIN pTestedDomain = (PTESTED_DOMAIN) pParams->pDomain;
	PDOMAIN_CONTROLLER_INFOW LocalDomainControllerInfo = NULL;

	//if the machine is a member machine or DC, DsGetDc Test will get called. 
	//Otherwise, this test will be skipped
	pResults->DsGetDc.fPerformed = TRUE;

	//the DsGetDc test will be called for every domain, but we only want to initialize
	//the message list once.
	if(pResults->DsGetDc.lmsgOutput.Flink == NULL)		
		InitializeListHead(&pResults->DsGetDc.lmsgOutput);
	
	PrintStatusMessage(pParams, 4, IDS_DSGETDC_STATUS_MSG);
	

	//
	// Find a generic DC
	//

	PrintStatusMessage(pParams, 4, IDS_DSGETDC_STATUS_DC);

	pszDcType = LoadAndAllocString(IDS_DCTYPE_DC);
	NetStatus = DoDsGetDcName( pParams,
							   pResults,
                               &pResults->DsGetDc.lmsgOutput,
							   pTestedDomain,
							   DS_DIRECTORY_SERVICE_PREFERRED,
							   pszDcType, //_T("DC"),
							   TRUE,
							   &pTestedDomain->DcInfo );
	Free(pszDcType);
	
    pTestedDomain->fTriedToFindDcInfo = TRUE;

	if ( NetStatus != NO_ERROR ) {
        hr = S_FALSE;
        goto Error;
	}
	
	//
	// Find a PDC
	//  (Failure isn't fatal.)
	//
	PrintStatusMessage(pParams, 4, IDS_DSGETDC_STATUS_PDC);

	pszDcType = LoadAndAllocString(IDS_DCTYPE_PDC);
	LocalNetStatus = DoDsGetDcName(pParams,
								   pResults,
                                   &pResults->DsGetDc.lmsgOutput,
								   pTestedDomain,
								   DS_PDC_REQUIRED,
								   pszDcType, //_T("PDC"),
								   FALSE,
								   &LocalDomainControllerInfo );
	Free(pszDcType);
	
	if ( LocalNetStatus == NO_ERROR )
	{
		if ( LocalDomainControllerInfo != NULL )
		{
			NetApiBufferFree( LocalDomainControllerInfo );
			LocalDomainControllerInfo = NULL;
		}
	}
	
	//
	// Find an NT 5 DC
	//  (Failure isn't fatal.)
	//
	PrintStatusMessage(pParams, 4, IDS_DSGETDC_STATUS_NT5DC);
	
	pszDcType = LoadAndAllocString(IDS_DCTYPE_W2K_DC);	
	LocalNetStatus = DoDsGetDcName(pParams,
								   pResults,
                                   &pResults->DsGetDc.lmsgOutput,
								   pTestedDomain,
								   DS_DIRECTORY_SERVICE_REQUIRED,
								   pszDcType, //_T("Windows 2000 DC"),
								   FALSE,
								   &LocalDomainControllerInfo );
	Free(pszDcType);
	
	if ( LocalNetStatus == NO_ERROR )
	{
		if ( LocalDomainControllerInfo != NULL )
		{
			NetApiBufferFree( LocalDomainControllerInfo );
			LocalDomainControllerInfo = NULL;
		}
	}
	
	
	//
	// Ensure the returned domain GUID is the domain GUID stored in the LSA
	//
	if ( pTestedDomain == pResults->Global.pMemberDomain )
	{
		
		if ( !IsEqualGUID( &pResults->Global.pPrimaryDomainInfo->DomainGuid, &NlDcZeroGuid ) &&
			 !IsEqualGUID( &pTestedDomain->DcInfo->DomainGuid, &NlDcZeroGuid )  &&
			 !IsEqualGUID( &pResults->Global.pPrimaryDomainInfo->DomainGuid,
						   &pTestedDomain->DcInfo->DomainGuid ) )
		{
			// Need to convert the two GUIDS
			WCHAR	swzGuid1[64];
			WCHAR	swzGuid2[64];

			StringFromGUID2(&pResults->Global.pPrimaryDomainInfo->DomainGuid,
							swzGuid1,
							DimensionOf(swzGuid1));
			StringFromGUID2(&pTestedDomain->DcInfo->DomainGuid,
							swzGuid2,
							DimensionOf(swzGuid2));

			// "    [FATAL] Your machine thinks the domain GUID of domain '%ws' is\n        '"
			// "' but \n        '%ws' thinks it is\n        '"
			AddMessageToList(&pResults->DsGetDc.lmsgOutput,
							 Nd_Quiet,
							 IDS_DSGETDC_FATAL_GUID,
							 pResults->Global.pPrimaryDomainInfo->DomainNameFlat,
							 swzGuid1,
							 pTestedDomain->DcInfo->DomainControllerName,
							 swzGuid2);
							

			hr = S_FALSE;
			
			//
			// Attempt to fix the problem.
			//
			
			if ( !pParams->fFixProblems )
			{
				// "\nConsider running 'nettest /fix' to try to fix this problem\n"
				AddMessageToList( &pResults->DsGetDc.lmsgOutput, Nd_Quiet, IDS_DSGETDC_13206 );
			}
			else
			{
				NetStatus = SetPrimaryGuid( &pTestedDomain->DcInfo->DomainGuid );
				
				if ( NetStatus != NO_ERROR )
				{
					if ( NetStatus == ERROR_ACCESS_DENIED )
					{
						// "\nCannot fix domain GUID since you are not an administrator.  Leave then rejoin the domain.\n"
						AddMessageToList( &pResults->DsGetDc.lmsgOutput, Nd_Quiet, IDS_DSGETDC_13207 );
					}
					else
					{
						// "    [FATAL] Failed to fix Domain Guid. [%s]\n"
						AddMessageToList( &pResults->DsGetDc.lmsgOutput, Nd_Quiet,
                                           IDS_DSGETDC_13208, NetStatusToString(NetStatus) );
					}
				}
				else
				{
					// "\nFixed domain GUID.  Reboot then run 'nettest' again to ensure everything is working.\n"
					AddMessageToList( &pResults->DsGetDc.lmsgOutput, Nd_Quiet, IDS_DSGETDC_13209 );
				}
			}
			
		}
	}
	
Error:
    //$REVIEW (nsun 10/05/98) CliffV deleted DCNameClose()
    //DCNameClose();
    pResults->DsGetDc.hr = hr;
    return hr;
}



VOID
PrintDsGetDcName(
				 IN NETDIAG_RESULT *pResults,
                 IN OUT PLIST_ENTRY plmsgOutput,
				 IN PDOMAIN_CONTROLLER_INFOW DomainControllerInfo
    )
/*++

Routine Description:

    Prints the information returned from DsGetDcName

Arguments:

    DomainControllerInfo - Information to print

Return Value:

    None.

--*/
{
	// "                   DC: %ws\n"
    AddMessageToList( plmsgOutput,
					  Nd_Quiet,
					  IDS_DSGETDC_13210,
					  DomainControllerInfo->DomainControllerName );
	
	// "              Address: %ws\n"
    AddMessageToList( plmsgOutput,
					  Nd_Quiet,
					  IDS_DSGETDC_13211,
					  DomainControllerInfo->DomainControllerAddress );

    if ( !IsEqualGUID( &DomainControllerInfo->DomainGuid, &NlDcZeroGuid) )
	{
		WCHAR	swzGuid[64];
		StringFromGUID2(&DomainControllerInfo->DomainGuid,
						swzGuid,
						DimensionOf(swzGuid));
		
		// "        Domain Guid . . . . . . : %ws\n"
        AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13212,
						  swzGuid);
    }

    if ( DomainControllerInfo->DomainName != NULL )
	{
		// "             Dom Name: %ws\n"
        AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13214,
						  DomainControllerInfo->DomainName );
    }
	
    if ( DomainControllerInfo->DnsForestName != NULL )
	{
		// "          Forest Name: %ws\n"
		AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13215,
						  DomainControllerInfo->DnsForestName );
    }
	
    if ( DomainControllerInfo->DcSiteName != NULL )
	{
		// "         Dc Site Name: %ws\n"
        AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13216,
						  DomainControllerInfo->DcSiteName );
    }
	
    if ( DomainControllerInfo->ClientSiteName != NULL )
	{
		// "        Our Site Name: %ws\n"
        AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13217,
						  DomainControllerInfo->ClientSiteName );
    }
	
    if ( DomainControllerInfo->Flags )
	{
        ULONG LocalFlags = DomainControllerInfo->Flags;
		
		//  "                Flags:"
        AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13218 );
		
        if ( LocalFlags & DS_PDC_FLAG )
		{
			// " PDC"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  (LocalFlags & DS_DS_FLAG) ? IDS_DSGETDC_13219 : IDS_DSGETDC_NT4_PDC);
            LocalFlags &= ~DS_PDC_FLAG;
        }
		
        if ( LocalFlags & DS_GC_FLAG ) {
//IDS_DSGETDC_13220                  " GC"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13220);
            LocalFlags &= ~DS_GC_FLAG;
        }
        if ( LocalFlags & DS_DS_FLAG ) {
//IDS_DSGETDC_13221                  " DS"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13221);
            LocalFlags &= ~DS_DS_FLAG;
        }
        if ( LocalFlags & DS_KDC_FLAG ) {
//IDS_DSGETDC_13222                  " KDC"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13222);
            LocalFlags &= ~DS_KDC_FLAG;
        }
        if ( LocalFlags & DS_TIMESERV_FLAG ) {
//IDS_DSGETDC_13223                  " TIMESERV"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13223);
            LocalFlags &= ~DS_TIMESERV_FLAG;
        }
        if ( LocalFlags & DS_GOOD_TIMESERV_FLAG ) {
//IDS_DSGETDC_13224                  " GTIMESERV"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13224);
            LocalFlags &= ~DS_GOOD_TIMESERV_FLAG;
        }
        if ( LocalFlags & DS_WRITABLE_FLAG ) {
//IDS_DSGETDC_13225                  " WRITABLE"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13225);
            LocalFlags &= ~DS_WRITABLE_FLAG;
        }
        if ( LocalFlags & DS_DNS_CONTROLLER_FLAG ) {
//IDS_DSGETDC_13226                  " DNS_DC"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13226);
            LocalFlags &= ~DS_DNS_CONTROLLER_FLAG;
        }
        if ( LocalFlags & DS_DNS_DOMAIN_FLAG ) {
//IDS_DSGETDC_13227                  " DNS_DOMAIN"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13227);
            LocalFlags &= ~DS_DNS_DOMAIN_FLAG;
        }
        if ( LocalFlags & DS_DNS_FOREST_FLAG ) {
//IDS_DSGETDC_13228                  " DNS_FOREST"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13228);
            LocalFlags &= ~DS_DNS_FOREST_FLAG;
        }
        if ( LocalFlags & DS_CLOSEST_FLAG ) {
//IDS_DSGETDC_13229                  " CLOSE_SITE"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13229);
            LocalFlags &= ~DS_CLOSEST_FLAG;
        }
        if ( LocalFlags != 0 ) {
//IDS_DSGETDC_13230                  " 0x%lX"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13230,
							  LocalFlags);
        }
//IDS_DSGETDC_13231                  "\n"
        AddMessageToList( plmsgOutput,
							  Nd_Quiet,
						  IDS_DSGETDC_13231);
    }
}



NET_API_STATUS
DoDsGetDcName(IN NETDIAG_PARAMS *pParams,
			  IN OUT NETDIAG_RESULT *pResults,
              OUT PLIST_ENTRY   plmsgOutput,
			  IN PTESTED_DOMAIN pTestedDomain,
			  IN DWORD Flags,
			  IN LPTSTR pszDcType,
			  IN BOOLEAN IsFatal,
			  OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
			 )
/*++

Routine Description:

    Does a DsGetDcName

Arguments:

    plmsgOutput  -  The message list to dump output
    pTestedDomain - Domain to test

    Flags - Flags to pass to DsGetDcName

    pszDcType - English description of Flags

    IsFatal - True if failure is fatal

    DomainControllerInfo - Return Domain Controller information

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;
    PDOMAIN_CONTROLLER_INFOW LocalDomainControllerInfo = NULL;
    LPSTR Severity;


    //
    // Initialization
    //

    if ( IsFatal ) {
        Severity = "[FATAL]";
    } else {
        Severity = "[WARNING]";
    }
	if ( pParams->fReallyVerbose )
	{
		//   "\n    Find %s in domain '%ws':\n"
        AddMessageToList( plmsgOutput, Nd_ReallyVerbose, IDS_DSGETDC_13232, pszDcType, pTestedDomain->PrintableDomainName );
    }

    //
    // Find a DC in the domain.
    //  Use the DsGetDcName built into nettest.
    //

    NetStatus = GetADc( pParams,
						pResults,
                        plmsgOutput,
// Commented out to port to Source Depot - smanda
#ifdef SLM_TREE
						NettestDsGetDcNameW,
#else
                        DsGetDcNameW,
#endif
                        pTestedDomain,
                        Flags,
                        DomainControllerInfo );

    if ( NetStatus != NO_ERROR )
	{
		//  "    %s Cannot find %s in domain '%ws'. [%s]\n"
        AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13233,
						  Severity,
						  pszDcType,
						  pTestedDomain->PrintableDomainName,
                          NetStatusToString(NetStatus));
		
        if ( NetStatus == ERROR_NO_SUCH_DOMAIN ) {
            if ( Flags & DS_DIRECTORY_SERVICE_REQUIRED )
		    {
			    // "\n        This isn't a problem if domain '%ws' does not have any NT 5.0 DCs.\n"
                AddMessageToList( plmsgOutput,
							      Nd_Quiet,
							      IDS_DSGETDC_13234,
							      pTestedDomain->PrintableDomainName );
            }
            else if ( Flags & DS_PDC_REQUIRED )
            {
                PrintGuruMessage2("        If the PDC for domain '%ws' is up, ", TestedDomain->PrintableDomainName );
                PrintGuru( 0, DSGETDC_GURU );
            } else
            {
                PrintGuruMessage3("        If any %s for domain '%ws' is up, ", DcType, TestedDomain->PrintableDomainName );
                PrintGuru( 0, DSGETDC_GURU );
            }
        }
        else
        {
            PrintGuru( NetStatus, DSGETDC_GURU );
        }

    //
    // If that worked,
    //  try again through netlogon this time.
    //
    }
	else
	{

        if (pParams->fReallyVerbose )
		{
			// "    Found this %s in domain '%ws':\n"
            AddMessageToList( plmsgOutput,
							  Nd_ReallyVerbose,
							  IDS_DSGETDC_13235,
							  pszDcType,
							  pTestedDomain->PrintableDomainName );
            PrintDsGetDcName( pResults, plmsgOutput, *DomainControllerInfo );
        }
		else if ( pParams->fVerbose )
		{
			// "    Found %s '%ws' in domain '%ws'.\n"
            AddMessageToList( plmsgOutput,
							  Nd_Verbose,
							  IDS_DSGETDC_13236,
							  pszDcType,
							  (*DomainControllerInfo)->DomainControllerName,
							  pTestedDomain->PrintableDomainName );
        }

        if ( ((*DomainControllerInfo)->Flags & (DS_DS_FLAG|DS_KDC_FLAG)) == DS_DS_FLAG )
		{
			// "    %s: KDC is not running on NT 5 DC '%ws' in domain '%ws'."
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13237,
							  Severity,
							  (*DomainControllerInfo)->DomainControllerName,
							  pTestedDomain->PrintableDomainName );
        }


        //
        // If netlogon is running,
        //  try it again using the netlogon service.
        //

        if ( pResults->Global.fNetlogonIsRunning )
		{

            NetStatus = GetADc( pParams,
								pResults,
                                plmsgOutput,
								DsGetDcNameW,
                                pTestedDomain,
                                Flags,
                                &LocalDomainControllerInfo );

            if ( NetStatus != NO_ERROR )
			{
				// "    %s: Netlogon cannot find %s in domain '%ws'. [%s]\n"
                AddMessageToList( plmsgOutput,
								  Nd_Quiet,
								  IDS_DSGETDC_13238,
								  Severity,
								  pszDcType,
								  pTestedDomain->PrintableDomainName,
                                  NetStatusToString(NetStatus));

            //
            // If that worked,
            //  sanity check the returned DC.
            //

            }
			else
			{

                if ( (LocalDomainControllerInfo->Flags & (DS_DS_FLAG|DS_KDC_FLAG)) == DS_DS_FLAG )
				{
					// "    %s: KDC is not running on NT 5 DC '%ws' in domain '%ws'."
                    AddMessageToList( plmsgOutput,
									  Nd_Quiet,
									  IDS_DSGETDC_13239,
									  Severity,
									  LocalDomainControllerInfo->DomainControllerName,
									  pTestedDomain->PrintableDomainName );
                }
            }
        }
    }

    if ( LocalDomainControllerInfo != NULL ) {
        NetApiBufferFree( LocalDomainControllerInfo );
        LocalDomainControllerInfo = NULL;
    }

    return NetStatus;
}





NET_API_STATUS
SetPrimaryGuid(
    IN GUID *GuidToSet
    )
/*++

Routine Description:

    Set the primary GUID to the specified value.

Arguments:

    GuidToSet - Guid to set as the primary GUID

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    LSA_HANDLE PolicyHandle = NULL;
    PPOLICY_DNS_DOMAIN_INFO PrimaryDomainInfo = NULL;
    OBJECT_ATTRIBUTES ObjAttributes;


    //
    // Open a handle to the LSA.
    //

    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    Status = LsaOpenPolicy(
                   NULL,
                   &ObjAttributes,
                   POLICY_VIEW_LOCAL_INFORMATION |
                    POLICY_TRUST_ADMIN,
                   &PolicyHandle
                   );

    if (! NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }

    //
    // Get the name of the primary domain from LSA
    //

    Status = LsaQueryInformationPolicy(
                   PolicyHandle,
                   PolicyDnsDomainInformation,
                   (PVOID *) &PrimaryDomainInfo
                   );

    if (! NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }

    //
    // Set the new GUID of the primary domain into the LSA
    //

    PrimaryDomainInfo->DomainGuid = *GuidToSet;

    Status = LsaSetInformationPolicy(
                   PolicyHandle,
                   PolicyDnsDomainInformation,
                   (PVOID) PrimaryDomainInfo
                   );

    if (! NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }


    NetStatus = NO_ERROR;

Cleanup:
    if ( PrimaryDomainInfo != NULL ) {
        (void) LsaFreeMemory((PVOID) PrimaryDomainInfo);
    }
    if ( PolicyHandle != NULL ) {
        (void) LsaClose(PolicyHandle);
    }

    return NetStatus;

}



/*!--------------------------------------------------------------------------
	DsGetDcGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void DsGetDcGlobalPrint( NETDIAG_PARAMS* pParams,
						  NETDIAG_RESULT*  pResults)
{
	if (pParams->fVerbose || !FHrOK(pResults->DsGetDc.hr))
	{
		PrintNewLine(pParams, 2);
		PrintTestTitleResult(pParams, IDS_DSGETDC_LONG, IDS_DSGETDC_SHORT, pResults->DsGetDc.fPerformed, 
							 pResults->DsGetDc.hr, 0);
		
		if (pParams->fReallyVerbose || !FHrOK(pResults->DsGetDc.hr))
			PrintMessageList(pParams, &pResults->DsGetDc.lmsgOutput);
	}

}

/*!--------------------------------------------------------------------------
	DsGetDcPerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void DsGetDcPerInterfacePrint( NETDIAG_PARAMS* pParams,
								NETDIAG_RESULT*  pResults,
								INTERFACE_RESULT *pInterfaceResults)
{
	// no per-interface results
}


/*!--------------------------------------------------------------------------
	DsGetDcCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void DsGetDcCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	MessageListCleanUp(&pResults->DsGetDc.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\format.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       format.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_FORMAT
#define HEADER_FORMAT


void    PrintNewLine(NETDIAG_PARAMS *pParams, int cNewLine);
void    PrintTestTitleResult(NETDIAG_PARAMS *pParams,
                             UINT idsTestLongName,
                             UINT idsTestShortName,
                             BOOL fPerformed,
                             HRESULT hr,
                             int nIndent);
void    PrintError(NETDIAG_PARAMS *pParams, UINT idsContext, HRESULT hr);

LPTSTR  MAP_YES_NO(BOOL fYes);
LPTSTR  MAP_ON_OFF(BOOL fOn);
LPTSTR  MapWinsNodeType(UINT Parm);
LPTSTR  MapAdapterType(UINT type);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\format.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      format.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//		the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information. 
//--

//
// Common include files.
//
#include "precomp.h"


#include "ipcfgtest.h"


void FormatWin32Error(DWORD dwErr, TCHAR *pszBuffer, UINT cchBuffer)
{
	DWORD	dwErrMsg;
	
	assert(dwErr != ERROR_SUCCESS);

	dwErrMsg = FormatMessage(
							 FORMAT_MESSAGE_FROM_SYSTEM,
							 NULL,
							 dwErr,
							 0,
							 pszBuffer,
							 cchBuffer,
							 NULL);
	pszBuffer[cchBuffer-1] = 0;

}


static TCHAR	s_szPass[32] = _T("");
static TCHAR	s_szFail[32] = _T("");
static TCHAR	s_szSkip[32] = _T("");

void PrintTestTitleResult(NETDIAG_PARAMS *pParams, UINT idsTestLongName, UINT idsTestShortName,
						  BOOL fPerformed, HRESULT hr, int nIndent)
{
	TCHAR	szBuffer[256];
	TCHAR	szTitle[256];
	TCHAR	szTitleTest[256];
	LPTSTR	pszPassFail = NULL;
	int		cch, i;
	TCHAR	szContactInfo[MAX_CONTACT_STRING] = _T("");

	if (s_szPass[0] == 0)
	{
		LoadString(NULL, IDS_GLOBAL_PASS, s_szPass, DimensionOf(s_szPass));
		LoadString(NULL, IDS_GLOBAL_FAIL, s_szFail, DimensionOf(s_szFail));
		LoadString(NULL, IDS_GLOBAL_SKIP, s_szSkip, DimensionOf(s_szSkip));
	}

	// Fill the buffer up with ' .'
	for ( i=0; i<DimensionOf(szBuffer); i+= 2)
	{
		szBuffer[i] = _T(' ');
		szBuffer[i+1] = _T('.');
	}

	// Fill up the indents
	for ( i=0; i<nIndent; i++)
		szBuffer[i] = _T(' ');

	// Add the test name
	LoadString(NULL, idsTestLongName, szTitle,
			   DimensionOf(szTitle));
	szTitle[DimensionOf(szTitle)-1] = 0;

	wsprintf(szTitleTest, _T("%s test"), szTitle);

	cch = StrLen(szTitleTest);

	// Do NOT use StrCpyN or lstrcpyn here!
	// They will automatically fill in a terminating NULl character
	// which I do not want.
	_tcsncpy(szBuffer+nIndent, szTitleTest, cch);

	if (!fPerformed)
		pszPassFail = s_szSkip;
	else
	{
		if (FHrOK(hr))
			pszPassFail = s_szPass;
		else
		{
			TCHAR	szTitleShort[256];
			pszPassFail = s_szFail;

			LoadString(NULL, idsTestShortName, szTitleShort,
						DimensionOf(szTitleShort));
			LoadContact(szTitleShort, szContactInfo, DimensionOf(szContactInfo));
		}
	}


	if ((nIndent + cch) > 35)
		wsprintf(szBuffer+nIndent+cch, _T(": %s\n"), pszPassFail);
	else
		wsprintf(szBuffer+35, _T(": %s\n"), pszPassFail);

	PrintMessageSz(pParams, szBuffer);

	//print the contact info if any
	if (_tcslen(szContactInfo))
	{

		// Fill up the indents
		for ( i=0; i<nIndent; i++)
		{
			szBuffer[i] = _T(' ');
		}

		szBuffer[i] = 0;

		PrintMessageSz(pParams, szBuffer);

		PrintMessage(pParams, IDS_CONTACT, szContactInfo);
	}
}


void PrintNewLine(NETDIAG_PARAMS *pParams, int cNewLine)
{
	int		i;
	for ( i=0; i<cNewLine; i++)
		PrintMessageSz(pParams, _T("\n"));
}

LPTSTR MAP_YES_NO(BOOL fYes)
{
	static	TCHAR	s_szYes[64] = _T("");
	static	TCHAR	s_szNo[64] = _T("");

	if (s_szYes[0] == 0)
	{
		LoadString(NULL, IDS_GLOBAL_YES, s_szYes, DimensionOf(s_szYes));
		LoadString(NULL, IDS_GLOBAL_NO, s_szNo, DimensionOf(s_szNo));
	}

	return fYes ? s_szYes : s_szNo;
}


LPTSTR MAP_ON_OFF(BOOL fOn)
{
	static	TCHAR	s_szOn[64] = _T("");
	static	TCHAR	s_szOff[64] = _T("");

	if (s_szOn[0] == 0)
	{
		LoadString(NULL, IDS_GLOBAL_ON, s_szOn, DimensionOf(s_szOn));
		LoadString(NULL, IDS_GLOBAL_OFF, s_szOff, DimensionOf(s_szOff));
	}

	return fOn ? s_szOn : s_szOff;
}


LPTSTR MapWinsNodeType(UINT Parm)
{
	static	BOOL s_fMapWinsNodeTypeInit = FALSE;
	static	LPTSTR s_pszWinsNodeType[LAST_NODE_TYPE+1];
    DWORD dwParm = LAST_NODE_TYPE + 1;


	if (!s_fMapWinsNodeTypeInit)
	{
		s_fMapWinsNodeTypeInit = TRUE;

		// Load all of the strings, (they can be leaked)
		s_pszWinsNodeType[0] = NULL;
		s_pszWinsNodeType[1] = LoadAndAllocString(IDS_GLOBAL_BROADCAST_NODE);
		s_pszWinsNodeType[2] = LoadAndAllocString(IDS_GLOBAL_PEER_PEER_NODE);
		s_pszWinsNodeType[3] = LoadAndAllocString(IDS_GLOBAL_MIXED_NODE);
		s_pszWinsNodeType[4] = LoadAndAllocString(IDS_GLOBAL_HYBRID_NODE);
		assert(LAST_NODE_TYPE == 4);
	}
			
    //
    // 1, 2, 4, 8 => log2(n) + 1 [1, 2, 3, 4]
    //

    switch (Parm) {
    case 0:

        //
        // according to JStew value of 0 will be treated as BNode (default)
        //

    case BNODE:
        dwParm = 1;
        break;

    case PNODE:
        dwParm = 2;
        break;

    case MNODE:
        dwParm = 3;
        break;

    case HNODE:
        dwParm = 4;
        break;
    }
    if ((dwParm >= FIRST_NODE_TYPE) && (dwParm <= LAST_NODE_TYPE)) {
        return s_pszWinsNodeType[dwParm];
    }

    //
    // if no node type is defined then we default to Hybrid
    //

    return s_pszWinsNodeType[LAST_NODE_TYPE];
}

#define MAX_ADAPTER_TYPES	8

LPTSTR MapAdapterType(UINT type)
{
	static	BOOL	s_fInitMapAdapterType = FALSE;
	static	LPTSTR	s_pszAdapterTypes[MAX_ADAPTER_TYPES];

	if (!s_fInitMapAdapterType)
	{
		s_fInitMapAdapterType = TRUE;

		s_pszAdapterTypes[0] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_OTHER);
		s_pszAdapterTypes[1] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_ETHERNET);
		s_pszAdapterTypes[2] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_TOKEN_RING);
		s_pszAdapterTypes[3] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_FDDI);
		s_pszAdapterTypes[4] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_PPP);
		s_pszAdapterTypes[5] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_LOOPBACK);
		s_pszAdapterTypes[6] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_SLIP);
		s_pszAdapterTypes[7] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_UNKNOWN);
	}
			
    switch (type)
	{
		case IF_TYPE_OTHER:
			return s_pszAdapterTypes[0];

		case IF_TYPE_ETHERNET_CSMACD:
			return s_pszAdapterTypes[1];

		case IF_TYPE_ISO88025_TOKENRING:
			return s_pszAdapterTypes[2];
			
		case IF_TYPE_FDDI:
			return s_pszAdapterTypes[3];

		case IF_TYPE_PPP:
			return s_pszAdapterTypes[4];
			
		case IF_TYPE_SOFTWARE_LOOPBACK:
			return s_pszAdapterTypes[5];
			
		case IF_TYPE_SLIP:
			return s_pszAdapterTypes[6];
			
		default:
			return s_pszAdapterTypes[7];
	}
    return _T("");
}

void PrintError(NETDIAG_PARAMS *pParams, UINT idsContext, HRESULT hr)
{

	PTSTR	ptzSysMsg = NULL;
	UINT cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
					NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
					(PTSTR)&ptzSysMsg, 0, NULL);

	if (!cch)	// not found with system
    {
		TCHAR	t[20]; 
    	
		_ultot(hr, t, 16);
		PrintMessage(pParams, idsContext, ptzSysMsg);
	}
	else
	{
		PrintMessage(pParams, idsContext, ptzSysMsg);
		LocalFree(ptzSysMsg);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\dnstest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      dnstest.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//      ElenaAp - 10-22-1998
//
//--

#include "precomp.h"
#include "dnscmn.h"



BOOL DnsServerUp(LPSTR IpAddressString,
                 NETDIAG_PARAMS *pParams,
                 NETDIAG_RESULT *pResults,
                 INTERFACE_RESULT *pIfResults);

BOOL DnsServerHasRecords(LPSTR IpAddressString,
                         NETDIAG_PARAMS *pParams,
                         NETDIAG_RESULT *pResults,
                         INTERFACE_RESULT *pIfResults);

BOOL DnsServerHasDCRecords (NETDIAG_PARAMS *pParams,
                            NETDIAG_RESULT *pResults,
                            LPSTR   IpAddressString);

BOOL ReadStringToDnsRecord(IN LPSTR lpstrString, OUT PDNS_RECORD pDNSRecord);

VOID PrintDNSError(IN NETDIAG_PARAMS *pParams,
                   IN NETDIAG_RESULT *pResults,
                   IN DWORD status,
                                   IN NdVerbose ndv);

VOID PrintARecord (IN NETDIAG_PARAMS *pParams, IN  PDNS_RECORD pDnsRecord );
VOID PrintSRVRecord (IN NETDIAG_PARAMS *pParams, IN  PDNS_RECORD pDnsRecord );
VOID PrintCNAMERecord (IN NETDIAG_PARAMS *pParams, IN  PDNS_RECORD pDnsRecord );
VOID PrintRecord (IN NETDIAG_PARAMS *pParams,
                  IN NETDIAG_RESULT *pResults,
                  IN  PDNS_RECORD pDnsRecord,
                                  IN NdVerbose ndv);




HRESULT
DnsTest(
    IN      NETDIAG_PARAMS *    pParams,
    IN OUT  NETDIAG_RESULT *    pResults
    )
/*++

Routine Description:

    Test DNS

Arguments:

    pParams -- netdiag test params

    pResults -- netdiag results buffer

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS      NetStatus;
    PIP_ADDR_STRING     DnsServer;
    ULONG               WorkingDnsServerCount = 0;
    ULONG               ConfiguredDnsServerCount = 0;
    BOOL                fRecordsRegistered = FALSE;
    BOOL                fDSRecordsRegistered = FALSE;
    BOOL                fFixOnce = FALSE;
    BOOL                fBogusDnsRecord = FALSE;
    INTERFACE_RESULT *  pVariableInfo;
    PIP_ADAPTER_INFO    pIpVariableInfo;
    IP_ADDR_STRING      LocalDnsServerList;
    PIP_ADDR_STRING     DnsServerList;
    BOOL                fUseOldDnsServerList = FALSE;
    HRESULT             hr = hrOK;
    HRESULT             hrTemp = hrOK;
    WCHAR               wszBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD               dwSize = DNS_MAX_NAME_BUFFER_LENGTH;
    int                 i;
    int                 ids;
    PDNS_NETINFO        pNetworkInfo = NULL;
    DNS_STATUS          dwStatus = NO_ERROR;
    LPTSTR              pError = NULL;
    BOOL                bDnscacheRunning = TRUE;
    BOOL                bGetComputerName = TRUE;
    PIP4_ARRAY          pDnsServers = NULL;
    DWORD               dwError;
    DWORD               idx;

    //
    //  initialize DNS debug
    //

    Dns_StartDebugEx(
        0,                  //  no flag value
        "dnsnetd.flag",     //  read flag from file
        NULL,               //  no flag
        "dnsnetd.log",      //  log to file
        0,                  //  no wrap limit
        FALSE,              //  don't use existing file
        FALSE,              //  don't use existing flag
        TRUE                //  make this file global
        );

    DNSDBG( TRACE, ( "\n\nNETDIAG:  DnsTest\n\n" ));

    //
    //  init results
    //

    InitializeListHead(&pResults->Dns.lmsgOutput);

    for ( i=0; i<pResults->cNumInterfaces; i++)
    {
        InitializeListHead( &pResults->pArrayInterface[i].Dns.lmsgOutput );
    }

    PrintStatusMessage(pParams, 4, IDS_DNS_STATUS_MSG);


    //
    //  check that DNS cache resolver is running.
    //

    DNSDBG( TRACE, ( "NETDIAG:  resolver running test\n\n" ));

    NetStatus = IsServiceStarted( _T("DnsCache") );
    if ( NetStatus != NO_ERROR )
    {
        PrintStatusMessage(pParams, 0, IDS_DNS_RESOLVER_CACHE_IS_OFF, NetStatusToString(NetStatus));

        pResults->Dns.fOutput = TRUE;
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet,
                         IDS_DNS_RESOLVER_CACHE_IS_OFF, NetStatusToString(NetStatus));
        bDnscacheRunning = FALSE;
    }


    //
    //  get FQDN
    //      - note use unicode
    //

    DNSDBG( TRACE, ( "\nNETDIAG:  get-validate FQDN\n\n" ));

    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified, wszBuffer, &dwSize ) )
    {
        dwError = GetLastError();
        // "[WARNING] GetComputerNameExW() failed with error %d\n"
        PrintStatusMessage(pParams, 0,  IDS_DNS_12948, dwError);
        pResults->Dns.fOutput = TRUE;
        AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                              IDS_DNS_12948, dwError);
    }
    else
    {
        NetStatus = DnsValidateDnsName_W( wszBuffer );

        if ( NetStatus != NO_ERROR )
        {
            if ( NetStatus == DNS_ERROR_NON_RFC_NAME )
            {
                // "[WARNING] DnsHostName '%S' valid only on NT 5.0 DNS servers. [%s]\n"
                ids = IDS_DNS_NAME_VALID_NT5_ONLY;
            }
            else
            {
                // "[FATAL] DnsHostName '%S' is not valid. [%s]\n",
                ids = IDS_DNS_NAME_INVALID;
                hr = S_FALSE;
            }

            PrintStatusMessage(pParams, 0,  ids, wszBuffer, NetStatusToString(NetStatus));
            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                              ids, wszBuffer, NetStatusToString(NetStatus));
        }
    }

    //
    //  get the DNS Network Information
    //

    DNSDBG( TRACE, ( "\nNETDIAG:  getting network info\n\n" ));

    pNetworkInfo = DnsQueryConfigAlloc(
                        DnsConfigNetworkInfoUTF8,
                        NULL );
    if ( !pNetworkInfo )
    {
        dwStatus = GetLastError(); pError = NetStatusToString(dwStatus);
        // [FATAL] Cannot get the DNS Adapter Information from registry, error 0x%x %s\n
        PrintStatusMessage(pParams, 0, IDS_DNS_12877, dwStatus, pError);

        pResults->Dns.fOutput = TRUE;
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet,
                         IDS_DNS_12877, dwStatus, pError);
        hr = S_FALSE;
        goto Error;
    }

    //
    //  verify at least one DNS server
    //      - no DNS servers is fatal
    //

    DNSDBG( TRACE, ( "\nNETDIAG:  DNS server test\n\n" ));

    dwStatus = GetAllDnsServersFromRegistry(pNetworkInfo, &pDnsServers);
    if (dwStatus)
    {
        if (dwStatus == DNS_ERROR_INVALID_DATA)
        {
            // IDS_DNS_12872 "[FATAL] No DNS servers are configured.\n"
            PrintStatusMessage(pParams, 8,  IDS_DNS_12872);

            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12872);
        }
        else
        {
            // IDS_DNS_12885 "[FATAL] Cannot get the DNS server list, error %d %s\n"
            PrintStatusMessage(pParams, 8,  IDS_DNS_12885, dwStatus, NetStatusToString(dwStatus));

            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12885, dwStatus, NetStatusToString(dwStatus));
        }

        hr = S_FALSE;
        goto Error;

    }

    //
    //  check the DNS registration
    //

    DNSDBG( TRACE, ( "\nNETDIAG:  checking DNS registrations\n\n" ));

    hrTemp = CheckDnsRegistration(
                pNetworkInfo,
                pParams,
                pResults );

    hr = ((hr == S_FALSE) ? hr : hrTemp);

    //
    //  DC registration check
    //
    //  if this is a DC, check all netlogon.dns records are registered
    //  on all DNS servers
    //

    if ( (pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleBackupDomainController) ||
         (pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RolePrimaryDomainController) )
    {
        DNSDBG( TRACE, ( "\nNETDIAG:  checking DC registrations\n\n" ));

        //
        // go through list of DNS servers and check DC registration
        //
        for (idx = 0; idx < pDnsServers->AddrCount; idx++)
        {
            //
            //(nsun) we need just fix the DC records on one DNS server and that DNS server will replicate the
            //      the fix on other DNS servers
            //
            if ( !fFixOnce )
            {
                if ( DnsServerHasDCRecords(
                            pParams,
                            pResults,
                            IP4_STRING(pDnsServers->AddrArray[idx] )))
                     fDSRecordsRegistered = TRUE;
            }
            if ( pParams->fFixProblems )
            {
                fFixOnce = TRUE;
            }
        }

        if( !fDSRecordsRegistered )
        {
            PrintStatusMessage(pParams, 8, IDS_DNS_DC_FAILURE);
            //IDS_DNS_DC_FAILURE "[FATAL] No DNS servers have our DNS records for this DC registered.\n"
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_DC_FAILURE);
            hr = S_FALSE;
        }
    }

/*
    //
    // If we're running a build that's older than ipconfig can handle,
    //  build our own list of DNS servers directly from the registry.
    //
    if ( _ttoi(pResults->Global.pszCurrentBuildNumber) < NTBUILD_DNSSERVERLIST)
    {
        HKEY TcpipParametersKey;
        HKEY TransientKey;
        LPSTR Name;
        BOOLEAN ok;
        BOOL   ReadRegistryIpAddrString(HKEY, LPSTR, PIP_ADDR_STRING);

        RtlZeroMemory( &LocalDnsServerList, sizeof(LocalDnsServerList));

        Name = "SYSTEM\\CurrentControlSet\\Services\\TcpIp\\Parameters";
        NetStatus = RegOpenKey( HKEY_LOCAL_MACHINE, Name, &TcpipParametersKey );

        if ( NetStatus != NO_ERROR )
        {
            PrintDebugSz(pParams, 0, _T("        [FATAL] Cannot open key '%s'. [%s]\n"),
                          Name, NetStatusToString(NetStatus) );
            hr = S_FALSE;
            goto Error;
        }
        //
        // NameServer: 1st try Transient key then NameServer (override) in
        // Parameters key, and finally DhcpNameServer in parameters key
        //

        if (RegOpenKey(TcpipParametersKey, "Transient", &TransientKey) == ERROR_SUCCESS) {
            ok = ReadRegistryIpAddrString(TransientKey,
                                          "NameServer",
                                          &LocalDnsServerList
                                          );
            RegCloseKey(TransientKey);
        } else {
            ok = FALSE;
        }

        if (!ok) {
            ok = ReadRegistryIpAddrString(TcpipParametersKey,
                                          "NameServer",
                                          &LocalDnsServerList
                                          );
        }

        if (!ok) {
            ok = ReadRegistryIpAddrString(TcpipParametersKey,
                                          "DhcpNameServer",
                                          &LocalDnsServerList
                                          );
        }

        RegCloseKey(TcpipParametersKey);

        fUseOldDnsServerList = TRUE;
    }


    //
    // Test the DNS servers for each adapter
    //
    for ( i=0; i<pResults->cNumInterfaces; i++)
    {
        pVariableInfo = pResults->pArrayInterface + i;
        pIpVariableInfo = pVariableInfo->IpConfig.pAdapterInfo;

        if (!pVariableInfo->IpConfig.fActive)
            continue;

        //
        // Use the old Dns server list or the per adapter one depending on
        //  what build we're running.
        //

        if ( fUseOldDnsServerList )
        {
            DnsServerList = &LocalDnsServerList;
        }
        else
        {
            DnsServerList = &pVariableInfo->IpConfig.DnsServerList;

            PrintStatusMessage(pParams, 8, IDS_DNS_CHECKING_DNS_SERVERS,
                               pVariableInfo->pszFriendlyName);

            AddMessageToListSz(&pVariableInfo->Dns.lmsgOutput, Nd_ReallyVerbose,
                               _T("            "));
            AddMessageToList(&pVariableInfo->Dns.lmsgOutput, Nd_ReallyVerbose,
                             IDS_DNS_CHECKING_DNS_SERVERS,
                             pVariableInfo->pszFriendlyName);
        }

        //
        // Make sure all of the DNS servers are up.
        //

        for ( DnsServer = DnsServerList;
              DnsServer;
              DnsServer = DnsServer->Next)
        {
            if ( DnsServer->IpAddress.String[0] == '\0' )
            {
                fBogusDnsRecord = TRUE;
                continue;
            }

            ConfiguredDnsServerCount++;

            if ( DnsServerUp( DnsServer->IpAddress.String,
                              pParams,
                              pResults,
                              pVariableInfo) )
            {
                if ( pParams->fReallyVerbose)
                {
                    // IDS_DNS_SERVER_IS_UP "DNS server at %s is up.\n"
                    AddMessageToList(&pVariableInfo->Dns.lmsgOutput,
                                     Nd_ReallyVerbose,
                                     IDS_DNS_SERVER_IS_UP,
                                     DnsServer->IpAddress.String );
                }
                WorkingDnsServerCount ++;


                //
                // Since the server is up,
                //  check to see that it has all of the right records registered.
                //

                if ( DnsServerHasRecords( DnsServer->IpAddress.String, pParams, pResults, pVariableInfo) ) {
                    fRecordsRegistered = TRUE;
                }

    if ((hr == hrOK))
    {
                // check DC dns entry here
                //
                //if this is a DC, we check if all the dns entries in
                //netlogon.dns are registered on DNS server
                //
                if ( pResults->Global.pPrimaryDomainInfo->MachineRole ==
                        DsRole_RoleBackupDomainController ||
                     pResults->Global.pPrimaryDomainInfo->MachineRole ==
                        DsRole_RolePrimaryDomainController )
                {
                    //(nsun) we need just fix the DC records on one DNS server and that DNS server will replicate the
                    //      the fix on other DNS servers
                     if ( !fFixOnce )
                     {
                        if (DnsServerHasDCRecords( pParams,
                                                   pResults,
                                                   DnsServer->IpAddress.String))
                            fDSRecordsRegistered = TRUE;
                     }

                     if ( pParams->fFixProblems )
                         fFixOnce = TRUE;
                }
                // if it is not a DC, we don't check it later.
                else
                   fDSRecordsRegistered = TRUE;
    }
            }
        }

        //
        // There isn't one old list per adapter
        //
        if ( fUseOldDnsServerList ) {
            break;
        }

    }

    //
    // If there are no DNS servers at all,
    //  That's fatal.
    //

    if ( ConfiguredDnsServerCount == 0 )
    {
        if ( !fBogusDnsRecord )
        {
            // IDS_DNS_12872 "[FATAL] No DNS servers are configured.\n"
            PrintStatusMessage(pParams, 8,  IDS_DNS_12872);

            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12872);


            hr = S_FALSE;
        }

        //
        // If there are no working DNS servers,
        //  That's fatal.
        //

    }
    else if ( WorkingDnsServerCount == 0 )
    {
        // IDS_DNS_12873  "[FATAL] No DNS servers are working.\n"
        PrintStatusMessage(pParams, 8, IDS_DNS_12873);

        pResults->Dns.fOutput = TRUE;
        AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                          IDS_DNS_12873);
        hr = S_FALSE;

    }
    else
    {
        if ( !fRecordsRegistered )
        {
            //
            // Warn if no DNS servers have our addresses registered.
            //  (But still not fatal).
            //
            // IDS_DNS_12874 "[WARNING] No DNS servers have our records registered.\n"
            PrintStatusMessage(pParams, 8, IDS_DNS_12874);

            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                               IDS_DNS_12874);
        }
*/


Error:

    //
    //  cleanup
    //

    if ( pNetworkInfo )
    {
        DnsFreeConfigStructure(
            pNetworkInfo,
            DnsConfigNetworkInfoUTF8 );
    }

    if ( pDnsServers )
    {
        LocalFree (pDnsServers);
    }
    pResults->Dns.hr = hr;
    return hr;
}





BOOL
DnsServerUp(
    IN      LPSTR               IpAddressString,
    IN      NETDIAG_PARAMS *    pParams,
    IN OUT  NETDIAG_RESULT *    pResults,
    OUT     INTERFACE_RESULT *  pIfResults
    )
/*++

Routine Description:

    Determine if the DNS server at the specified address is up and running.

Arguments:

    IpAddressString - Ip Address of a DNS server

Return Value:

    TRUE: Dns server is up.
    FALSE: Dns server is not up

--*/
{
    NET_API_STATUS  NetStatus;
    BOOL            RetVal = TRUE;
    CHAR            SoaNameBuffer[DNS_MAX_NAME_LENGTH+1];
    PCHAR           SoaName;
    PCHAR           OldSoaName;
    PDNS_RECORD     DnsRecord = NULL;
    SOCKADDR_IN     SockAddr;
    ULONG           SockAddrSize;
    IP4_ARRAY       DnsServer;

    //
    // Ping the DNS server.
    //

    if ( !IsIcmpResponseA( IpAddressString) )
    {
        PrintStatusMessage(pParams, 12, IDS_DNS_CANNOT_PING, IpAddressString);

        pIfResults->Dns.fOutput = TRUE;
        AddIMessageToList(&pIfResults->Dns.lmsgOutput, Nd_Quiet, 16,
                          IDS_DNS_CANNOT_PING, IpAddressString);
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Compute the name of an SOA record.
    //

    if (pResults->Global.pszDnsDomainName == NULL)
    {
//IDS_DNS_12821                  "    [FATAL] Cannot test DNS server at %s since no DnsDomainName\n."
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12821, IpAddressString );
        RetVal = FALSE;
        goto Cleanup;
    }

    strcpy( SoaNameBuffer, pResults->Global.pszDnsDomainName );
    SoaName = SoaNameBuffer;

    //
    // Tell DNS which Dns Server to use
    //

    DnsServer.AddrCount = 1;
    SockAddrSize = sizeof(SockAddr);
    NetStatus = WSAStringToAddress( IpAddressString,
                                    AF_INET,
                                    NULL,
                                    (LPSOCKADDR) &SockAddr,
                                    &SockAddrSize );

    if ( NetStatus != NO_ERROR ) {
        NetStatus = WSAGetLastError();
//IDS_DNS_12822                  "    [FATAL] Cannot convert DNS server address %s to SockAddr. [%s]\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12822, IpAddressString, NetStatusToString(NetStatus));
        RetVal = FALSE;
        goto Cleanup;
    }

    DnsServer.AddrArray[0] = SockAddr.sin_addr.S_un.S_addr;

    //
    // Loop until the real SOA record is found
    //

    for (;;) {

        //
        // Query this DNS server for the SOA record.
        //

        NetStatus = DnsQuery( SoaName,
                              DNS_TYPE_SOA,
                              DNS_QUERY_BYPASS_CACHE |
                                DNS_QUERY_NO_RECURSION,
                              &DnsServer,
                              &DnsRecord,
                              NULL );

        if ( NetStatus == NO_ERROR ) {
            if ( DnsRecord != NULL ) {
                DnsRecordListFree ( DnsRecord, TRUE );
            }
            DnsRecord = NULL;
            break;
        }

        switch ( NetStatus ) {
        case ERROR_TIMEOUT:     // DNS server isn't available
        case DNS_ERROR_RCODE_SERVER_FAILURE:  // Server failed
            // IDS_DNS_12823  "    [WARNING] DNS server at %s is down for SOA record '%s'. [%s]\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12823, IpAddressString, SoaName, NetStatusToString(NetStatus) );
            //IDS_DNS_12825                  "\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12825);
            RetVal = FALSE;
            goto Cleanup;

        case DNS_ERROR_NO_TCPIP:    // TCP/IP not configured
            // IDS_DNS_12826 "    [FATAL] DNS (%s) thinks IP is not configured for SOA record '%s'. [%s]\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12826, IpAddressString, SoaName, NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;

        case DNS_ERROR_NO_DNS_SERVERS:  // DNS not configured
            // IDS_DNS_12827 "    [FATAL] DNS (%s) thinks DNS is not configured for SOA record '%s'. [%s]\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12827, IpAddressString, SoaName, NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;

        case DNS_ERROR_RCODE_NAME_ERROR:    // no RR's by this name
        case DNS_INFO_NO_RECORDS:           // RR's by this name but not of the requested type:
            break;
        default:
            // IDS_DNS_12828 "    [FATAL] Cannot query DNS server at %s for SOA record '%s'. [%s]\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12828, IpAddressString, SoaName, NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;
        }

        //
        // Remove the next label from the potential SOA name and use it.
        //

        SoaName = strchr( SoaName, '.' );

        if ( SoaName == NULL )
        {
            // IDS_DNS_12829  "    [FATAL] DNS server at %s could not find an SOA record for '%s'.\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12829, IpAddressString, pResults->Global.pszDnsDomainName );
            RetVal = FALSE;
            goto Cleanup;
        }

        SoaName ++;
    }

Cleanup:
    if ( DnsRecord != NULL ) {
        DnsRecordListFree ( DnsRecord, TRUE );
    }
    return RetVal;
}





BOOL
DnsServerHasRecords(
    IN      LPSTR               IpAddressString,
    IN      NETDIAG_PARAMS *    pParams,
    IN OUT  NETDIAG_RESULT *    pResults,
    OUT     INTERFACE_RESULT *  pIfResults
    )
/*++

Routine Description:

    Determine if the DNS server at the specified address has all of records
    registered that that machine is supposed to have registered.

Arguments:

    IpAddressString - Ip Address of a DNS server

Return Value:

    TRUE: Dns server is up.
    FALSE: Dns server is not up

--*/
{
    NET_API_STATUS      NetStatus;
    BOOL                RetVal = TRUE;
    CHAR                LocalIpAddressString[NL_IP_ADDRESS_LENGTH+1];
    PDNS_RECORD         DnsRecord = NULL;
    PDNS_RECORD         CurrentDnsRecord;
    SOCKADDR_IN         SockAddr;
    ULONG               SockAddrSize;
    PLIST_ENTRY         ListEntry;
    PNETBT_TRANSPORT    NetbtTransport;
    IP4_ARRAY           DnsServer;

    //
    // Avoid this test if this build is incompatible with the current
    //  Dynamic DNS servers.
    //

    if ( _ttoi(pResults->Global.pszCurrentBuildNumber) < NTBUILD_DYNAMIC_DNS)
    {
            // IDS_DNS_CANNO_TEST_DNS "Cannot test Dynamic DNS to %s since this machine is running build %ld. [Test skipped.]\n",
        AddMessageToList(&pIfResults->Dns.lmsgOutput,
                             Nd_ReallyVerbose,
                             IDS_DNS_CANNOT_TEST_DNS,
                             IpAddressString, pResults->Global.pszCurrentBuildNumber );
        return TRUE;
    }

    //
    // Tell DNS which Dns Server to use
    //

    DnsServer.AddrCount = 1;
    SockAddrSize = sizeof(SockAddr);
    NetStatus = WSAStringToAddress( IpAddressString,
                                    AF_INET,
                                    NULL,
                                    (LPSOCKADDR) &SockAddr,
                                    &SockAddrSize );

    if ( NetStatus != NO_ERROR )
    {
        NetStatus = WSAGetLastError();

        PrintDebugSz(pParams, 0, _T("    [FATAL] Cannot convert DNS server address %s to SockAddr. [%s]\n"),
                        IpAddressString, NetStatusToString(NetStatus));

        AddMessageToList(&pIfResults->Dns.lmsgOutput,
                         Nd_ReallyVerbose,
                         IDS_DNS_CANNOT_CONVERT_DNS_ADDRESS,
                         IpAddressString, NetStatusToString(NetStatus));

        RetVal = FALSE;
        goto Cleanup;
    }

    DnsServer.AddrArray[0] = SockAddr.sin_addr.S_un.S_addr;


    //
    // Query this DNS server for A record for this hostname
    //

    NetStatus = DnsQuery( pResults->Global.szDnsHostName,
                          DNS_TYPE_A,
                          DNS_QUERY_BYPASS_CACHE,
                          &DnsServer,
                          &DnsRecord,
                          NULL );

    switch ( NetStatus )
    {
        case NO_ERROR:
            break;
        case ERROR_TIMEOUT:     // DNS server isn't available
        case DNS_ERROR_RCODE_SERVER_FAILURE:  // Server failed
            // IDS_DNS_SERVER_IS_DOWN "    [WARNING] DNS server at %s is down. [%s]\n"
            PrintStatusMessage(pParams, 12, IDS_DNS_SERVER_IS_DOWN, IpAddressString, NetStatusToString(NetStatus));
            AddIMessageToList(&pIfResults->Dns.lmsgOutput,
                              Nd_ReallyVerbose,
                              16,
                              IDS_DNS_SERVER_IS_DOWN,
                              IpAddressString, NetStatusToString(NetStatus));
            RetVal = FALSE;
            goto Cleanup;
        case DNS_ERROR_NO_TCPIP:    // TCP/IP not configured
            //IDS_DNS_THINKS_IP_IS_UNCONFIGURED "    [FATAL] DNS (%s) thinks IP is not configured. [%s]\n"
            AddMessageToList(&pIfResults->Dns.lmsgOutput,
                             Nd_ReallyVerbose,
                             IDS_DNS_THINKS_IP_IS_UNCONFIGURED,
                             IpAddressString, NetStatusToString(NetStatus));
            RetVal = FALSE;
            goto Cleanup;
        case DNS_ERROR_NO_DNS_SERVERS:  // DNS not configured
            // IDS_DNS_IS_UNCONFIGURED "    [FATAL] DNS (%s) thinks DNS is not configured. [%s]\n"
            AddMessageToList(&pIfResults->Dns.lmsgOutput,
                             Nd_ReallyVerbose,
                             IDS_DNS_IS_UNCONFIGURED,
                             IpAddressString, NetStatusToString(NetStatus));
            RetVal = FALSE;
            goto Cleanup;
        case DNS_ERROR_RCODE_NAME_ERROR:    // no RR's by this name
        case DNS_INFO_NO_RECORDS:           // RR's by this name but not of the requested type:
            // IDS_DNS_HAS_NO_RECORD "    [WARNING] DNS server at %s has no A record for '%s'. [%s]\n"
            AddMessageToList(&pIfResults->Dns.lmsgOutput,
                             Nd_ReallyVerbose,
                             IDS_DNS_HAS_NO_RECORD,
                             IpAddressString,
                             pResults->Global.szDnsHostName,
                             NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;
        default:
            // IDS_DNS_CANNOT_QUERY "    [FATAL] Cannot query DNS server at %s. [%s]\n"
            AddMessageToList(&pIfResults->Dns.lmsgOutput,
                             Nd_ReallyVerbose,
                             IDS_DNS_CANNOT_QUERY,
                             IpAddressString, pResults->Global.szDnsHostName,
                             NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;
    }

    //
    // We have an A record for ourselves.
    //
#ifdef notdef
//IDS_DNS_12830                  "    DNS server at %s has an A record for '%s'.\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12830, IpAddressString, pResults->Global.szDnsHostName );
        if ( pParams->fDebugVerbose ) {
                        PrintMessage(pParams, IDS_DNS_12830, IpAddressString, pResults->Global.szDnsHostName );
//IDS_DNS_12831                  "    A"
            DnsPrint_RecordSet( &PrintMessage(pParams,  IDS_DNS_12831, DnsRecord );
        }
#endif // notdef

    //
    // Match the IP address on the A records with the IP address of this machine
    //
    // Mark each transport that its IP address hasn't yet been found.
    //

    for ( ListEntry = pResults->NetBt.Transports.Flink ;
          ListEntry != &pResults->NetBt.Transports ;
          ListEntry = ListEntry->Flink ) {

        NetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

        NetbtTransport->Flags &= ~IP_ADDRESS_IN_DNS;

    }

    //
    // Loop through the A records
    //
    for ( CurrentDnsRecord = DnsRecord;
          CurrentDnsRecord;
          CurrentDnsRecord = CurrentDnsRecord->pNext )
    {

        //
        // Ignore everything but A records.
        //

        if ( CurrentDnsRecord->wType == DNS_TYPE_A )
        {
            BOOLEAN FoundIt = FALSE;

            //
            // Loop through the list of netbt transports finding one with this IP address.
            //

            for ( ListEntry = pResults->NetBt.Transports.Flink ;
                  ListEntry != &pResults->NetBt.Transports ;
                  ListEntry = ListEntry->Flink )
            {

                NetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

                if ( NetbtTransport->IpAddress == CurrentDnsRecord->Data.A.IpAddress )
                {
                    FoundIt = TRUE;
                    NetbtTransport->Flags |= IP_ADDRESS_IN_DNS;
                }

            }


            if ( !FoundIt )
            {
                NetpIpAddressToStr( CurrentDnsRecord->Data.A.IpAddress, LocalIpAddressString );

                // IDS_DNS_HAS_A_RECORD "    [WARNING] DNS server at %s has an A record for '%s' with wrong IP address: %s", IpAddressString, pResults->Global.szDnsHostName, LocalIpAddressString );

                AddMessageToList(&pIfResults->Dns.lmsgOutput,
                                 Nd_ReallyVerbose,
                                 IDS_DNS_HAS_A_RECORD,
                                 IpAddressString,
                                 pResults->Global.szDnsHostName,
                                 LocalIpAddressString );

                RetVal = FALSE;
            }

        }
    }

    //
    // If all of the addresses of this machine aren't registered,
    //  complain.
    //

    for ( ListEntry = pResults->NetBt.Transports.Flink ;
          ListEntry != &pResults->NetBt.Transports ;
          ListEntry = ListEntry->Flink )
    {
        NetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

        if ( (NetbtTransport->Flags & IP_ADDRESS_IN_DNS) == 0 )
        {
            NetpIpAddressToStr( NetbtTransport->IpAddress, LocalIpAddressString );
            // IDS_DNS_HAS_NO_A_RECORD "    [WARNING] DNS server at %s does not have an A record for '%s' with IP address: %s (%ws)", IpAddressString, pResults->Global.szDnsHostName, LocalIpAddressString, NetbtTransport->pswzTransportName );
            AddMessageToList(&pIfResults->Dns.lmsgOutput,
                             Nd_ReallyVerbose,
                             IDS_DNS_HAS_NO_A_RECORD,
                             IpAddressString,
                             pResults->Global.szDnsHostName,
                             LocalIpAddressString,
                             NetbtTransport->pswzTransportName );


            RetVal = FALSE;
        }

    }


Cleanup:
    if ( DnsRecord != NULL ) {
        DnsRecordListFree ( DnsRecord, TRUE );
    }
    return RetVal;
}


BOOL
DnsServerHasDCRecords(
    IN      NETDIAG_PARAMS *    pParams,
    IN OUT  NETDIAG_RESULT *    pResults,
    IN      LPSTR               IpAddressString
    )
/*++

Routine Description:
   On a DC machine, Open file (%systemroot%\system32\config\netlogon.dns) and read the dns entry from it.
   Query the specified dns server for the entry and confirm it is correct.
   Reupdate these entry if /fix option is on.

Arguments:  IpAddressString - DNS server IP address

Return Value:

    TRUE: Query succeed.
    FALSE: failed.

--*/

{
    char            pchDnsDataFileName[MAX_PATH] = "\\config\\netlogon.dns";
    char            pchDnsDataFileExpandName[MAX_PATH];
    FILE *          fDnsFile;
    PIP4_ARRAY      pIpArray = NULL;
    CHAR            achTempLine[ NL_MAX_DNS_LENGTH*3+1 ];
    INT             iMaxLineLength;
    DWORD           status;
    DWORD           dwOptions = DNS_QUERY_BYPASS_CACHE;
    PDNS_RECORD     pDNSRecord = NULL;
    PDNS_RECORD     pDNSTempRecord = NULL;
    PDNS_RECORD     pDiff1=NULL;
    PDNS_RECORD     pDiff2=NULL;
    PDNS_RECORD     pNotUsedSet = NULL;
    BOOL            bReRegister;
    BOOL            bReadData = FALSE;
    BOOL            bFixFail = FALSE;
    BOOL            fRetVal = TRUE;

    enum _Results               // Declare enum type
    {
        enumSuccess,
        enumRegistered,
        enumProblem,
        enumTimeout
    } Results;

    Results = enumSuccess;

    pIpArray = (PIP4_ARRAY) LocalAlloc( LPTR,
                    ( sizeof(IP4_ADDRESS) + sizeof(DWORD) ));

    // "Check the DNS registration for DCs entries on DNS server %s\n"
    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12944, IpAddressString);

    if ( !pIpArray )
    {
        DebugMessage("   [FATAL] No enough memory to create IpArray.");
        return ( FALSE );
    }
    pIpArray->AddrCount = 1;
    pIpArray->AddrArray[0] = inet_addr( IpAddressString );

    if ( pIpArray->AddrArray[0] == INADDR_NONE) {
         //IDS_DNS_IPADDR_ERR   "   [FATAL] Cannot convert DNS server address %s, failed in inet_addr().\n"
        PrintStatusMessage(pParams, 0,  IDS_DNS_IPADDR_ERR, IpAddressString);
        pResults->Dns.fOutput = TRUE;
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_IPADDR_ERR, IpAddressString);
         return( FALSE );
    }

    //
    //open file
    //
    if ( ! GetSystemDirectory ( pchDnsDataFileExpandName, MAX_PATH)) {
        // IDS_DNS_12832                  "    [FATAL] Could not GetSystemDir %s for reading."
            PrintStatusMessage(pParams, 0,  IDS_DNS_12832,  pchDnsDataFileExpandName);
            pResults->Dns.fOutput = TRUE;
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet,
                    IDS_DNS_12832,
                    pchDnsDataFileExpandName);
            return FALSE;
        }
    strcat( pchDnsDataFileExpandName, pchDnsDataFileName);
    if (( fDnsFile = fopen (pchDnsDataFileExpandName, "rt")) == NULL) {
        //IDS_DNS_12833                  "   [FATAL] Could not open file %s for reading."
            PrintStatusMessage(pParams, 0,  IDS_DNS_12833,  pchDnsDataFileExpandName);
            pResults->Dns.fOutput = TRUE;
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet,
                    IDS_DNS_12833,
                    pchDnsDataFileExpandName);
            return FALSE ;
        }

    //
    //allocate memory for pDNSRecord
    //

    pDNSRecord = (PDNS_RECORD) Malloc( sizeof( DNS_RECORD ) );

    if ( !pDNSRecord )
    {
        // IDS_DNS_12834 "Out of Memory: LocalAlloc(sizeof(DNS_RECORD)) call failed.\n"
        PrintStatusMessage(pParams, 0,  IDS_DNS_12834);
        pResults->Dns.fOutput = TRUE;
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12834 );
        return( FALSE );
    }

    ZeroMemory( pDNSRecord, sizeof( DNS_RECORD ) );

    //read each line
    //do query one by one
    //print out msg
    //do reupdate
    //check the result

    //
    // Parse the file line by line
    //
    iMaxLineLength = NL_MAX_DNS_LENGTH*3+1 ;
    while( fgets( achTempLine, iMaxLineLength, fDnsFile ) != NULL)
    {
        //
        // Read the data into pDNSRecord
        //
        if (ReadStringToDnsRecord(achTempLine, pDNSRecord))
        {

            bReadData = TRUE ;

            if ( pParams->fDebugVerbose )
            {
//IDS_DNS_12835                  "\n********** * ********** * ********** * ********** * ********** *\n"
                 AddMessageToList(&pResults->Dns.lmsgOutput, Nd_DebugVerbose, IDS_DNS_12835);
//IDS_DNS_12836                  "* CHECK NAME %s on DNS server %s\n"
                 AddMessageToList(&pResults->Dns.lmsgOutput, Nd_DebugVerbose, IDS_DNS_12836,
UTF8ToAnsi(pDNSRecord->pName), IpAddressString);
//IDS_DNS_12837                  "********** * ********** * ********** * ********** * ********** *\n\n"
                 AddMessageToList(&pResults->Dns.lmsgOutput, Nd_DebugVerbose, IDS_DNS_12837);
            }

            bReRegister = FALSE;
            //
            // make the query
            //
            status = DnsQuery_UTF8(
                        pDNSRecord->pName,
                        pDNSRecord->wType,
                        dwOptions,
                        pIpArray,
                        &pDNSTempRecord,
                        NULL );

            if ( status )
            {

//IDS_DNS_12838                  "Query for DC DNS entry %s on DNS server %s failed.\n"
                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12838,
UTF8ToAnsi(pDNSRecord->pName), IpAddressString);
                PrintDNSError( pParams, pResults, status, Nd_ReallyVerbose );
                bReRegister = TRUE;
                Results = enumProblem;

                //
                // if result was TIMEOUT do not continue querying this server
                //
                if ( status == ERROR_TIMEOUT )
                {
                    Results = enumTimeout;
                    break;
                }
            }
            else
            {
                //
                // Sometimes when DnsQuery is called, the returned record set
                // contains additional records of different types than what
                // was queried for. Need to strip off the additional records
                // from the query results.
                //
                pNotUsedSet = DnsRecordSetDetach( pDNSTempRecord );

                if ( pNotUsedSet )  {
                    DnsRecordListFree( pNotUsedSet, TRUE );
                    pNotUsedSet = NULL;
                    }

                if ( DnsRecordSetCompare(
                            pDNSRecord,
                            pDNSTempRecord,
                            &pDiff1,
                            &pDiff2 ))
                {
                    //
                    // The response from dns server is the same as the data in the file
                    //
                    //PrintDebugSz(pParams, 0, _T("The Record is correct on dns server %s!\n\n"), IpAddressString);
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12941, IpAddressString);
                }
                else
                {
                    //
                    // The RR on dns server is different, we check if it is one of the RR on dns server
                    //
                    // PrintDebugSz(pParams, 0, _T("The Record is different on dns server %s.\n"), IpAddressString);
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12942,  IpAddressString);
                    if (pDiff1 == NULL)
                    {
                        //"DNS server has more than one entries for this name, usually this means there are multiple DCs for this domain.\nYour DC entry is one of them on DNS server %s, no need to re-register.\n"
                        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12943, IpAddressString);
                        if ( Results ==  enumSuccess )
                            Results = enumRegistered;
                    }
                    else
                    {
                        Results = enumProblem;
                        bReRegister = TRUE;
                    }

//IDS_DNS_12839                  "\n+------------------------------------------------------+\n"
                     AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12839);
//IDS_DNS_12840                  "The record on your DC is: \n"
                     AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12840);
                     PrintRecord(pParams, pResults, pDNSRecord, Nd_ReallyVerbose );
//IDS_DNS_12841                  "\nThe record on DNS server %s is:\n"
                     AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12841, IpAddressString);
                     PrintRecord(pParams, pResults, pDNSTempRecord, Nd_ReallyVerbose );
//IDS_DNS_12842                  "+------------------------------------------------------+\n\n"
                     AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12842);

                }
            }
            if ( bReRegister && pParams->fFixProblems)
            {
                //
                // Send to  register again
                //
                // IDS_DNS_12843  "  [Fix] Try to re-register the record on DNS server %s...\n"
                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12843, IpAddressString);

                status = DnsModifyRecordsInSet(
                                pDNSRecord,         // add records
                                NULL,               // no delete records
                                0,                  // no options
                                NULL,               // default security context
                                pIpArray,           // DNS servers
                                NULL
                                );

                if ( status != ERROR_SUCCESS )
                {
                    // IDS_DNS_12844 "    [FATAL] Failed to fix: DC DNS entry %s re-registeration on DNS server %s failed. \n"
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12844, pDNSRecord->pName, IpAddressString);
                    PrintDNSError( pParams, pResults, status, Nd_Quiet );
                    bFixFail = TRUE;
                }
                else
                {
//IDS_DNS_12845                  "  [FIX] re-register DC DNS entry %s on DNS server %s succeed.\n"
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Verbose, IDS_DNS_12845, UTF8ToAnsi(pDNSRecord->pName), IpAddressString );
                }
            }



            //
            // free the memory after process each line
            //
            if ( pDNSTempRecord ) {
                DnsRecordListFree( pDNSTempRecord, TRUE );
                pDNSTempRecord = NULL;
            }
            if ( pDiff1 ){
                DnsRecordListFree( pDiff1, TRUE );
                pDiff1 = NULL;
            }
            if ( pDiff2 ) {
                DnsRecordListFree( pDiff2, TRUE );
                pDiff2 = NULL;
            }
        }
        else {
            bReadData = FALSE ;
        }

    }
    // "\n ** ** Check DC DNS NAME FINAL RESULT ** ** \n"
    if ( pParams->fDebugVerbose )
    {
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_DebugVerbose, IDS_DNS_12945);
    }

    if (bReadData == FALSE)
    {
        // PrintDebugSz(pParams, 0, _T("   [FATAL] File %s contains invalid dns entries. Send the file to DnsDev"), pchDnsDataFileName);
        PrintStatusMessage(pParams, 0,  IDS_DNS_12946, pchDnsDataFileName);
        pResults->Dns.fOutput = TRUE;
        AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12946, pchDnsDataFileName);
        fRetVal = FALSE;
    }
    else
    {
        switch (Results)
        {
        case enumSuccess:
            // IDS_DNS_12846 "    PASS - All the DNS entries for DC are registered on DNS server %s.\n"
            PrintStatusMessage(pParams, 0,  IDS_DNS_12846, IpAddressString);
            pResults->Dns.fOutput = TRUE;
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12846, IpAddressString);
            fRetVal = TRUE;
            break;
        case enumRegistered:
            // IDS_DNS_12847 "    PASS - All the DNS entries for DC are registered on DNS server %s and other DCs also have some of the names registered.\n"
            PrintStatusMessage(pParams, 0,  IDS_DNS_12847, IpAddressString);
            pResults->Dns.fOutput = TRUE;
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12847, IpAddressString);
            fRetVal = TRUE;
            break;
        case enumTimeout:
            // IDS_DNS_12850  "       [WARNING] The DNS entries for this DC cannot be verified right now on DNS server %s, ERROR_TIMEOUT. \n"
            PrintStatusMessage(pParams, 0,  IDS_DNS_12949, IpAddressString);
            pResults->Dns.fOutput = TRUE;
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12949, IpAddressString);
            fRetVal = FALSE;
            break;
        case enumProblem:
        default:
            if (pParams->fFixProblems)
            {
                if (bFixFail == FALSE )
                {
                    // IDS_DNS_12848 "   FIX PASS - nettest re-registered missing DNS entries for this DC successfully on DNS server %s.\n"
                    PrintStatusMessage(pParams, 0,  IDS_DNS_12848, IpAddressString);
                    pResults->Dns.fOutput = TRUE;
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12848, IpAddressString);
                }
                else
                {
                    // IDS_DNS_12849  "   [FATAL] Fix Failed: nettest failed to re-register missing DNS entries for this DC on DNS server %s.\n"
                    PrintStatusMessage(pParams, 0,  IDS_DNS_12849, IpAddressString);
                    pResults->Dns.fOutput = TRUE;
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12849, IpAddressString);
                }
            }
            else
            {
                // IDS_DNS_12850  "       [WARNING] The DNS entries for this DC are not registered correctly on DNS server %s. Please wait for 30 minutes for DNS server replication.\n"
                PrintStatusMessage(pParams, 0,  IDS_DNS_12850, IpAddressString);
                pResults->Dns.fOutput = TRUE;
                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12850, IpAddressString);
            }
            fRetVal = FALSE;
        }
    }

    Free(pDNSRecord);
    return fRetVal;
}


//
// The following are for dns DC entry check
//
BOOL
ReadStringToDnsRecord(
    IN      LPSTR           lpstrString,
    OUT     PDNS_RECORD     pDNSRecord
    )
/*++

Routine Description:

   Parse a string and put the data into DNS record

Arguments:

  lpstrString - The input string, the format is:
                DnsName IN Type Data
  pDNSRecord - The result DNS record

Return Value:

  TRUE: if succeed. False otherwise

--*/
{
    BOOL    bComments;
    LPSTR   lpstrType;
    LPSTR   lpstrTemp;
    PCHAR   pchEnd;
    DWORD   dwTemp;
    PCTSTR  pszWhite = _T(" \t\n");

    // skip white spaces and comments lines
    // comments start with ;

    //
    // Initialize pDNSRecord
    //
    pDNSRecord->pNext = NULL;
// Commented out to port to Source Depot - smanda
#ifdef SLM_TREE
    pDNSRecord->Flags.S.Unicode = FALSE;
#endif
    pDNSRecord->dwTtl = 0;
    // name
    pDNSRecord->pName = strtok(lpstrString, pszWhite);
    if(!pDNSRecord->pName || pDNSRecord->pName[0] == _T(';'))
    {
        return ( FALSE );
    }

    // ttl: this is added since build 1631
    // we need to check which format the netlogon.dns is using

    lpstrTemp = strtok(NULL,pszWhite);
    if (lpstrTemp)
    {
       dwTemp = strtoul( lpstrTemp, &pchEnd, 10 );
       if ( (lpstrTemp != pchEnd) && (*pchEnd == '\0') )
       {
           pDNSRecord->dwTtl = dwTemp ;
           // skip the class IN
           strtok(NULL, pszWhite);
       }
    }

    // type
    lpstrType = strtok(NULL,pszWhite);

    if (lpstrType)
    {
       if (_stricmp(lpstrType,_T("A")) == 0)
       {
           pDNSRecord->wType = DNS_TYPE_A;
           pDNSRecord->wDataLength = sizeof( DNS_A_DATA );

           // IP address
           lpstrTemp = strtok(NULL,pszWhite);
           if (lpstrTemp)
              pDNSRecord->Data.A.IpAddress = inet_addr ( lpstrTemp );
       }
       else if (_stricmp(lpstrType,_T("SRV")) == 0)
       {

           pDNSRecord->wType = DNS_TYPE_SRV;
           pDNSRecord->wDataLength = sizeof( DNS_SRV_DATA );

           // wPriority
           lpstrTemp = strtok(NULL,pszWhite);
           if (lpstrTemp)
              pDNSRecord->Data.SRV.wPriority = (WORD) atoi ( lpstrTemp );
           // wWeight
           lpstrTemp = strtok(NULL,pszWhite);
           if (lpstrTemp)
              pDNSRecord->Data.SRV.wWeight = (WORD) atoi ( lpstrTemp );
           // wPort
           lpstrTemp = strtok(NULL,pszWhite);
           if (lpstrTemp)
              pDNSRecord->Data.SRV.wPort = (WORD) atoi ( lpstrTemp );
           // pNameTarget
           pDNSRecord->Data.SRV.pNameTarget = strtok(NULL,pszWhite);
       }
       else if (_stricmp(lpstrType,_T("CNAME")) == 0)
       {
           pDNSRecord->wType = DNS_TYPE_CNAME;
           pDNSRecord->wDataLength = sizeof( DNS_PTR_DATA );
           // name host
           pDNSRecord->Data.CNAME.pNameHost = strtok(NULL,pszWhite);
       }
    }

    return ( TRUE );
}

VOID PrintDNSError(
                   NETDIAG_PARAMS *pParams,
                   NETDIAG_RESULT *pResults,
                   IN DWORD status,
                                   NdVerbose ndv)
/*++

Routine Description:

   Print out error message

Arguments:

  status - error code

Return Value:

  none

--*/
{
    // IDS_DNS_12851                  "DNS Error code: "
    AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12851);
    switch ( status ) {

    case ERROR_SUCCESS:
        // IDS_DNS_12852                  "ERROR_SUCCESS\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12852);
        break;
    case DNS_ERROR_RCODE_FORMAT_ERROR :
        // IDS_DNS_12853                  "DNS_ERROR_RCODE_FORMAT_ERROR\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12853);
        break;
    case DNS_ERROR_RCODE_SERVER_FAILURE :
        // IDS_DNS_12854                  "DNS_ERROR_RCODE_SERVER_FAILURE\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12854);
        break;
    case DNS_ERROR_RCODE_NAME_ERROR :
        // IDS_DNS_12855                  "DNS_ERROR_RCODE_NAME_ERROR (Name does not exist on DNS server)\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12855);
        break;
    case DNS_ERROR_RCODE_NOT_IMPLEMENTED :
        // IDS_DNS_12856                  "DNS_ERROR_RCODE_NOT_IMPLEMENTED\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12856);
        break;
    case DNS_ERROR_RCODE_REFUSED :
        // IDS_DNS_12857                  "DNS_ERROR_RCODE_REFUSED\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12857);
        break;
    case DNS_ERROR_RCODE_NOTAUTH :
        // IDS_DNS_12858                  "DNS_ERROR_RCODE_NOTAUTH\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12858);
        break;
    case DNS_ERROR_TRY_AGAIN_LATER :
        // IDS_DNS_12859                  "DNS_ERROR_TRY_AGAIN_LATER\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12859);
        break;
    case 0xcc000055 :
        // IDS_DNS_12860                  "DNS_ERROR_NOT_UNIQUE\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12860);
        break;
    case 0x5b4:
        // IDS_DNS_12861                  "ERROR_TIMEOUT (Dns server may be down!)\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12861);
        break;
    case 0x4c000030:
        // IDS_DNS_12862                  "DNS_INFO_NO_RECORDS\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12862 );
        break;
    default:
        // IDS_DNS_12863                  "0x%.8X\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12863,status);
    }
}


/*
VOID
PrintARecord (
              IN NETDIAG_PARAMS *pParams,
              IN  PDNS_RECORD pDnsRecord )
{
//IDS_DNS_12864                  "            A  %d.%d.%d.%d\n"
    PrintMessage(pParams,  IDS_DNS_12864,
            ((BYTE *) &pDnsRecord->Data.A.IpAddress)[0],
            ((BYTE *) &pDnsRecord->Data.A.IpAddress)[1],
            ((BYTE *) &pDnsRecord->Data.A.IpAddress)[2],
            ((BYTE *) &pDnsRecord->Data.A.IpAddress)[3] );
}

VOID
PrintSRVRecord (
                IN NETDIAG_PARAMS *pParams,
                IN  PDNS_RECORD pDnsRecord )
{
//IDS_DNS_12865                  "            SRV "
    PrintMessage(pParams,  IDS_DNS_12865 );

//IDS_DNS_12866                  "%d %d %d %s \n"
    PrintMessage(pParams,  IDS_DNS_12866,
            pDnsRecord->Data.SRV.wPriority,
            pDnsRecord->Data.SRV.wWeight,
            pDnsRecord->Data.SRV.wPort,
            pDnsRecord->Data.SRV.pNameTarget );
}

VOID
PrintCNAMERecord (
                  IN NETDIAG_PARAMS *pParams,
                  IN  PDNS_RECORD pDnsRecord )
{
//IDS_DNS_12867                  "            CNAME %s \n"
    PrintMessage(pParams,  IDS_DNS_12867,
            pDnsRecord->Data.CNAME.pNameHost);
}
*/

VOID
PrintRecord (
             IN NETDIAG_PARAMS *pParams,
             IN NETDIAG_RESULT *pResults,
             IN  PDNS_RECORD pDnsRecord,
                         IN NdVerbose ndv)
{
    PDNS_RECORD pCur;

    if (pDnsRecord==NULL)
        return;
    //IDS_DNS_12868                  "DNS NAME = %s\n"
    AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12868, UTF8ToAnsi(pDnsRecord->pName));
    //IDS_DNS_12869                  "DNS DATA = \n"
    AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12869);
    pCur = pDnsRecord;
    while ( pCur )
    {
        switch( pCur->wType ){
        case DNS_TYPE_A :
            //IDS_DNS_12864                  "            A  %d.%d.%d.%d\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12864,
                ((BYTE *) &pCur->Data.A.IpAddress)[0],
                ((BYTE *) &pCur->Data.A.IpAddress)[1],
                ((BYTE *) &pCur->Data.A.IpAddress)[2],
                ((BYTE *) &pCur->Data.A.IpAddress)[3] );
            break;
         case DNS_TYPE_SRV :
            //IDS_DNS_12865                  "            SRV "
            AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12865 );

            //IDS_DNS_12866                  "%d %d %d %s \n"
            AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12866,
                    pCur->Data.SRV.wPriority,
                    pCur->Data.SRV.wWeight,
                    pCur->Data.SRV.wPort,
                    pCur->Data.SRV.pNameTarget );
            break;
         case DNS_TYPE_CNAME :
            //IDS_DNS_12867                  "            CNAME %s \n"
            AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12867,
                    UTF8ToAnsi(pCur->Data.CNAME.pNameHost));
            break;
         default :
             // IDS_DNS_12870  "Don't know how to print record type %d\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12870,
                    pCur->wType);
        }
        pCur = pCur->pNext;
    }
}


/*!--------------------------------------------------------------------------
    DnsGlobalPrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DnsGlobalPrint( NETDIAG_PARAMS* pParams,
                          NETDIAG_RESULT*  pResults)
{
    if (!pResults->IpConfig.fEnabled)
        return;

    if (pParams->fVerbose || !FHrOK(pResults->Dns.hr) || pResults->Dns.fOutput)
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, IDS_DNS_LONG, IDS_DNS_SHORT, TRUE, pResults->Dns.hr, 0);
        PrintMessageList(pParams, &pResults->Dns.lmsgOutput);
    }
}

/*!--------------------------------------------------------------------------
    DnsPerInterfacePrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DnsPerInterfacePrint( NETDIAG_PARAMS* pParams,
                                NETDIAG_RESULT*  pResults,
                                INTERFACE_RESULT *pInterfaceResults)
{
/*    BOOL    fVerboseT;
    BOOL    fReallyVerboseT;

    if (!pResults->IpConfig.fEnabled)
        return;

    if (!pInterfaceResults->IpConfig.fActive)
        return;

    if (pParams->fVerbose || pInterfaceResults->Dns.fOutput)
    {
        fVerboseT = pParams->fVerbose;
        fReallyVerboseT = pParams->fReallyVerbose;
        pParams->fReallyVerbose = TRUE;

        PrintNewLine(pParams, 1);
//IDS_DNS_12871                  "        DNS test results :\n"
        PrintMessage(pParams, IDS_DNS_12871);
        PrintMessageList(pParams, &pInterfaceResults->Dns.lmsgOutput);

        pParams->fReallyVerbose = fReallyVerboseT;
        pParams->fVerbose = fVerboseT;
    }
    */
    return;
}


/*!--------------------------------------------------------------------------
    DnsCleanup
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DnsCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    int     i;

    MessageListCleanUp(&pResults->Dns.lmsgOutput);

    for ( i=0; i<pResults->cNumInterfaces; i++)
    {
        MessageListCleanUp(&pResults->pArrayInterface[i].Dns.lmsgOutput);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\global.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       global.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_GLOBAL
#define HEADER_GLOBAL

/*!--------------------------------------------------------------------------
	WsaInitialize
		Initialize winsock.		
	Author: NSun
 ---------------------------------------------------------------------------*/
int
WsaInitialize(
			  NETDIAG_PARAMS * pParams,
			  NETDIAG_RESULT *pResults
			 );


NET_API_STATUS
BrDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    );


NET_API_STATUS
DeviceControlGetInfo(
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG Information OPTIONAL
    );


NET_API_STATUS
OpenBrowser(
    OUT PHANDLE BrowserHandle
    );

int match( const char * p, const char * s );

LONG CountInterfaces(PIP_ADAPTER_INFO ListAdapterInfo);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\global.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      global.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//      the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information.
//--

//
// Common include files.
//
#include "precomp.h"


#include "ipcfgtest.h"


/*!--------------------------------------------------------------------------
    WsaInitialize
        Initialize winsock.
    Author: NSun
 ---------------------------------------------------------------------------*/
int
WsaInitialize(
              NETDIAG_PARAMS * pParams,
              NETDIAG_RESULT *pResults
             )
{
    int         iStatus;
    WORD        wVersionRequested;
    int         err;
    WSADATA     wsaData;

    // Requesting version 1.1
    // ----------------------------------------------------------------
    wVersionRequested = MAKEWORD( 1, 1 );

    iStatus = WSAStartup( wVersionRequested, &wsaData );
    if (iStatus != 0)
    {
        PrintMessage(pParams, IDS_GLOBAL_WSA_WSAStartup_Failed);
//      TracePrintf(_T("WSAStartup (1.1) failed with WinSock error %d"),
//              iStatus);
        return iStatus;
    }

    if ( (LOBYTE( wsaData.wVersion ) != 1) ||
         (HIBYTE( wsaData.wVersion ) != 1) )
    {
        WSACleanup();
        PrintMessage(pParams, IDS_GLOBAL_WSA_BadWSAVersion,
                     wsaData.wVersion);
        return WSANOTINITIALISED;
    }

    // Set the results of the WSA call into the results structure
    // ----------------------------------------------------------------
    pResults->Global.wsaData = wsaData;

    return NO_ERROR;
}





NET_API_STATUS
BrDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    )
/*++

Routine Description:

Arguments:

    FileHandle - Supplies a handle to the file or device on which the service
        is being performed.

    DgReceiverControlCode - Supplies the NtDeviceIoControlFile function code
        given to the datagram receiver.

    Drp - Supplies the datagram receiver request packet.

    DrpSize - Supplies the length of the datagram receiver request packet.

    SecondBuffer - Supplies the second buffer in call to NtDeviceIoControlFile.

    SecondBufferLength - Supplies the length of the second buffer.

    Information - Returns the information field of the I/O status block.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    PLMDR_REQUEST_PACKET RealDrp;
    HANDLE CompletionEvent;
    LPBYTE Where;

    if (FileHandle == NULL) {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Allocate a copy of the request packet where we can put the transport and
    //  emulated domain name in the packet itself.
    //
    RealDrp = Malloc(     DrpSize+
                          Drp->TransportName.Length+sizeof(WCHAR)+
                          Drp->EmulatedDomainName.Length+sizeof(WCHAR) );

    if (RealDrp == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory( RealDrp, DrpSize+
                         Drp->TransportName.Length+sizeof(WCHAR)+
                         Drp->EmulatedDomainName.Length+sizeof(WCHAR) );

    //
    // Copy the request packet into the local copy.
    //
    RtlCopyMemory(RealDrp, Drp, DrpSize);
    RealDrp->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    Where = (LPBYTE)RealDrp+DrpSize;
    if (Drp->TransportName.Length != 0) {
        RealDrp->TransportName.Buffer = (LPWSTR)Where;
        RealDrp->TransportName.MaximumLength = Drp->TransportName.Length+sizeof(WCHAR);
        RtlCopyUnicodeString(&RealDrp->TransportName, &Drp->TransportName);
        Where += RealDrp->TransportName.MaximumLength;
    }

    if (Drp->EmulatedDomainName.Length != 0) {
        RealDrp->EmulatedDomainName.Buffer = (LPWSTR)Where;
        RealDrp->EmulatedDomainName.MaximumLength = Drp->EmulatedDomainName.Length+sizeof(WCHAR);
        RtlCopyUnicodeString(&RealDrp->EmulatedDomainName, &Drp->EmulatedDomainName);
        Where += RealDrp->EmulatedDomainName.MaximumLength;
    }



    //
    // Create a completion event
    //
    CompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (CompletionEvent == NULL) {

        Free(RealDrp);

        return(GetLastError());
    }

    //
    // Send the request to the Datagram Receiver DD.
    //

    ntstatus = NtDeviceIoControlFile(
                   FileHandle,
                   CompletionEvent,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   DgReceiverControlCode,
                   RealDrp,
                   (ULONG)(Where-(LPBYTE)RealDrp),
                   SecondBuffer,
                   SecondBufferLength
                   );

    if (NT_SUCCESS(ntstatus)) {

        //
        //  If pending was returned, then wait until the request completes.
        //

        if (ntstatus == STATUS_PENDING) {

            do {
                ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
            } while ( ntstatus == WAIT_IO_COMPLETION );
        }


        if (NT_SUCCESS(ntstatus)) {
            ntstatus = IoStatusBlock.Status;
        }
    }

    if (ARGUMENT_PRESENT(Information)) {
        *Information = (ULONG)IoStatusBlock.Information;
    }

    Free(RealDrp);

    CloseHandle(CompletionEvent);

    return NetpNtStatusToApiStatus(ntstatus);
}

NET_API_STATUS
DeviceControlGetInfo(
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG Information OPTIONAL
    )
/*++

Routine Description:

    This function allocates the buffer and fill it with the information
    that is retrieved from the datagram receiver.

Arguments:

    DeviceDriverType - Supplies the value which indicates whether to call
        the datagram receiver.

    FileHandle - Supplies a handle to the file or device of which to get
        information about.

    DeviceControlCode - Supplies the NtFsControlFile or NtIoDeviceControlFile
        function control code.

    RequestPacket - Supplies a pointer to the device request packet.

    RrequestPacketLength - Supplies the length of the device request packet.

    OutputBuffer - Returns a pointer to the buffer allocated by this routine
        which contains the use information requested.  This pointer is set to
         NULL if return code is not NERR_Success.

    PreferedMaximumLength - Supplies the number of bytes of information to
        return in the buffer.  If this value is MAXULONG, we will try to
        return all available information if there is enough memory resource.

    BufferHintSize - Supplies the hint size of the output buffer so that the
        memory allocated for the initial buffer will most likely be large
        enough to hold all requested data.

    Information - Returns the information code from the NtFsControlFile or
        NtIoDeviceControlFile call.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    NTSTATUS ntstatus;
    DWORD OutputBufferLength;
    DWORD TotalBytesNeeded = 1;
    ULONG OriginalResumeKey;
    IO_STATUS_BLOCK IoStatusBlock;
    PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;
    HANDLE CompletionEvent;

#define INITIAL_ALLOCATION_SIZE  48*1024  // First attempt size (48K)
#define FUDGE_FACTOR_SIZE        1024  // Second try TotalBytesNeeded
                                       //     plus this amount

    OriginalResumeKey = Drrp->Parameters.EnumerateNames.ResumeHandle;

    //
    // If PreferedMaximumLength is MAXULONG, then we are supposed to get all
    // the information, regardless of size.  Allocate the output buffer of a
    // reasonable size and try to use it.  If this fails, the Redirector FSD
    // will say how much we need to allocate.
    //
    if (PreferedMaximumLength == MAXULONG) {
        OutputBufferLength = (BufferHintSize) ?
                             BufferHintSize :
                             INITIAL_ALLOCATION_SIZE;
    }
    else {
        OutputBufferLength = PreferedMaximumLength;
    }

    OutputBufferLength = ROUND_UP_COUNT(OutputBufferLength, ALIGN_WCHAR);

    if ((*OutputBuffer = LocalAlloc( LMEM_ZEROINIT, OutputBufferLength)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (CompletionEvent == (HANDLE)-1) {
        LocalFree(*OutputBuffer);
        *OutputBuffer = NULL;
        return(GetLastError());
    }

    Drrp->Parameters.EnumerateServers.EntriesRead = 0;

    //
    // Make the request of the Datagram Receiver
    //

    ntstatus = NtDeviceIoControlFile(
                     FileHandle,
                     CompletionEvent,
                     NULL,              // APC routine
                     NULL,              // APC context
                     &IoStatusBlock,
                     DeviceControlCode,
                     Drrp,
                     RequestPacketLength,
                     *OutputBuffer,
                     OutputBufferLength
                     );

    if (NT_SUCCESS(ntstatus)) {

        //
        //  If pending was returned, then wait until the request completes.
        //

        if (ntstatus == STATUS_PENDING) {
            do {
                ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
            } while ( ntstatus == WAIT_IO_COMPLETION );
        }

        if (NT_SUCCESS(ntstatus)) {
            ntstatus = IoStatusBlock.Status;
        }
    }

    //
    // Map NT status to Win error
    //
    status = NetpNtStatusToApiStatus(ntstatus);

    if (status == ERROR_MORE_DATA) {

        ASSERT(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.TotalBytesNeeded
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.TotalBytesNeeded
                    )
                );

        ASSERT(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.GetBrowserServerList.TotalBytesNeeded
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.TotalBytesNeeded
                    )
                );

        TotalBytesNeeded = Drrp->Parameters.EnumerateNames.TotalBytesNeeded;
    }

    if ((TotalBytesNeeded > OutputBufferLength) &&
        (PreferedMaximumLength == MAXULONG)) {
        PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;

        //
        // Initial output buffer allocated was too small and we need to return
        // all data.  First free the output buffer before allocating the
        // required size plus a fudge factor just in case the amount of data
        // grew.
        //

        LocalFree(*OutputBuffer);

        OutputBufferLength =
            ROUND_UP_COUNT((TotalBytesNeeded + FUDGE_FACTOR_SIZE),
                           ALIGN_WCHAR);

        if ((*OutputBuffer = LocalAlloc(LMEM_ZEROINIT, OutputBufferLength)) == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }


        ASSERT(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.ResumeHandle
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.ResumeHandle
                    )
                );

        ASSERT(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.ResumeHandle
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.GetBrowserServerList.ResumeHandle
                    )
                );

        Drrp->Parameters.EnumerateNames.ResumeHandle = OriginalResumeKey;
        Drrp->Parameters.EnumerateServers.EntriesRead = 0;

        //
        //  Make the request of the Datagram Receiver
        //

        ntstatus = NtDeviceIoControlFile(
                         FileHandle,
                         CompletionEvent,
                         NULL,              // APC routine
                         NULL,              // APC context
                         &IoStatusBlock,
                         DeviceControlCode,
                         Drrp,
                         RequestPacketLength,
                         *OutputBuffer,
                         OutputBufferLength
                         );

        if (NT_SUCCESS(ntstatus)) {

            //
            //  If pending was returned, then wait until the request completes.
            //

            if (ntstatus == STATUS_PENDING) {
                do {
                    ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
                } while ( ntstatus == WAIT_IO_COMPLETION );
            }

            if (NT_SUCCESS(ntstatus)) {
                ntstatus = IoStatusBlock.Status;
            }
        }

        status = NetpNtStatusToApiStatus(ntstatus);

    }


    //
    // If not successful in getting any data, or if the caller asked for
    // all available data with PreferedMaximumLength == MAXULONG and
    // our buffer overflowed, free the output buffer and set its pointer
    // to NULL.
    //
    if ((status != NERR_Success && status != ERROR_MORE_DATA) ||
        (TotalBytesNeeded == 0) ||
        (PreferedMaximumLength == MAXULONG && status == ERROR_MORE_DATA) ||
        (Drrp->Parameters.EnumerateServers.EntriesRead == 0)) {

        LocalFree(*OutputBuffer);
        *OutputBuffer = NULL;

        //
        // PreferedMaximumLength == MAXULONG and buffer overflowed means
        // we do not have enough memory to satisfy the request.
        //
        if (status == ERROR_MORE_DATA) {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    CloseHandle(CompletionEvent);

    return status;

    UNREFERENCED_PARAMETER(Information);
}

NET_API_STATUS
OpenBrowser(
    OUT PHANDLE BrowserHandle
    )
/*++

Routine Description:

    This function opens a handle to the bowser device driver.

Arguments:

    OUT PHANDLE BrowserHandle - Returns the handle to the browser.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS Status;

    UNICODE_STRING DeviceName;

    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;


    //
    // Open the redirector device.
    //
    RtlInitUnicodeString(&DeviceName, DD_BROWSER_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                   BrowserHandle,
                   SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }

    return NetpNtStatusToApiStatus(Status);

}






// ========================================================================
// * matches one or more chars, eg. match( "a*b", "a..b" ).
// ? matches exactly one char,  eg. match( "a?b", "a.b" ).

int match( const char * p, const char * s )
/*++
Routine Description:
This routine is used to compare addresses.
Author:
 07/01/98 Rajkumar
--*/
{
    switch( *p ){
        case '\0' : return ! *s ;
        case '*'  : return match( p+1, s ) || *s && match( p, s+1 );
        case '?'  : return *s && match( p+1, s+1 );
        default   : return *p == *s && match( p+1, s+1 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\ipcfg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ipcfg.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_IPCFG
#define HEADER_IPCFG

HRESULT IpConfigTest(NETDIAG_PARAMS*  pParams,
					 NETDIAG_RESULT*  pResults);

void IpConfigCleanup(IN NETDIAG_PARAMS *pParams,
					 IN OUT NETDIAG_RESULT *pResults);


HRESULT	InitIpconfig(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);

LONG CountInterfaces(PIP_ADAPTER_INFO ListAdapterInfo);

int AddIpAddressString(PIP_ADDR_STRING AddressList, LPSTR Address, LPSTR Mask);

VOID FreeIpAddressStringList(PIP_ADDR_STRING pAddressList);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\ipcfgmsg.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ipcfgmsg.mc

Abstract:

    Contains internationalizable message text for IPCONFIG

Author:

    Richard L Firth (rfirth) 05-Mar-1994

Revision History:

    05-Mar-1994 rfirth    Created
    31-Jul-97   MohsinA   PNP patterns for NT50.

--*/
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MSG_IPCONFIG_BANNER
//
// MessageText:
//
//  
//  Windows 2000 IP Configuration
//  
//
#define MSG_IPCONFIG_BANNER              0x00002710L

//
// MessageId: MSG_PRIMARY_HOST_NAME
//
// MessageText:
//
//  Host Name . . . . . . . . . . . . : %0
//
#define MSG_PRIMARY_HOST_NAME            0x00002711L

//
// MessageId: MSG_PRIMARY_DOMAIN_NAME
//
// MessageText:
//
//  Primary DNS Suffix  . . . . . . . : %0
//
#define MSG_PRIMARY_DOMAIN_NAME          0x00002712L

//
// MessageId: MSG_DOMAIN_NAME
//
// MessageText:
//
//  Connection-specific DNS Suffix  . : %0
//
#define MSG_DOMAIN_NAME                  0x00002713L

//
// MessageId: MSG_DNS_SERVERS
//
// MessageText:
//
//  DNS Servers . . . . . . . . . . . : %0
//
#define MSG_DNS_SERVERS                  0x00002714L

//
// MessageId: MSG_NODE_TYPE
//
// MessageText:
//
//  Node Type . . . . . . . . . . . . : %1
//
#define MSG_NODE_TYPE                    0x00002715L

//
// MessageId: MSG_SCOPE_ID
//
// MessageText:
//
//  NetBIOS Scope ID. . . . . . . . . : %1
//
#define MSG_SCOPE_ID                     0x00002716L

//
// MessageId: MSG_IP_ROUTING
//
// MessageText:
//
//  IP Routing Enabled. . . . . . . . : %1
//
#define MSG_IP_ROUTING                   0x00002717L

//
// MessageId: MSG_PROXY
//
// MessageText:
//
//  WINS Proxy Enabled. . . . . . . . : %1
//
#define MSG_PROXY                        0x00002718L

//
// MessageId: MSG_DNS_RESOLUTION
//
// MessageText:
//
//  NetBIOS Resolution Uses DNS . . . : %1
//
#define MSG_DNS_RESOLUTION               0x00002719L

//
// MessageId: MSG_DNS_SEARCH_LIST
//
// MessageText:
//
//  DNS Suffix Search List. . . . . . : %0
//
#define MSG_DNS_SEARCH_LIST              0x0000271AL

//
// These two entries are just there for alignment
// they should align with all entries above
//
//
// MessageId: MSG_DNS_SEARCH_LIST_ENTRY
//
// MessageText:
//
//                                      %0
//
#define MSG_DNS_SEARCH_LIST_ENTRY        0x0000271BL

//
// MessageId: MSG_DNS_SERVERS_ENTRY
//
// MessageText:
//
//                                      %0
//
#define MSG_DNS_SERVERS_ENTRY            0x0000271CL

//
// MessageId: MSG_PHYSICAL_ADDRESS
//
// MessageText:
//
//  Physical Address. . . . . . . . . : %1
//
#define MSG_PHYSICAL_ADDRESS             0x0000271DL

//
// MessageId: MSG_DESCRIPTION
//
// MessageText:
//
//  Description . . . . . . . . . . . : %1
//
#define MSG_DESCRIPTION                  0x0000271EL

//
// MessageId: MSG_DESCRIPTION_0
//
// MessageText:
//
//  Description . . . . . . . . . . . : %0
//
#define MSG_DESCRIPTION_0                0x0000271FL

//
// MessageId: MSG_DHCP_ENABLED
//
// MessageText:
//
//  DHCP Enabled. . . . . . . . . . . : %1
//
#define MSG_DHCP_ENABLED                 0x00002720L

//
// MessageId: MSG_AUTOCONFIG_ENABLED
//
// MessageText:
//
//  Autoconfiguration Enabled . . . . : %1
//
#define MSG_AUTOCONFIG_ENABLED           0x00002721L

//
// MessageId: MSG_IP_ADDRESS
//
// MessageText:
//
//  IP Address. . . . . . . . . . . . : %1
//
#define MSG_IP_ADDRESS                   0x00002722L

//
// MessageId: MSG_AUTOCONFIG_ADDRESS
//
// MessageText:
//
//  Autoconfiguration IP Address. . . : %1
//
#define MSG_AUTOCONFIG_ADDRESS           0x00002723L

//
// MessageId: MSG_SUBNET_MASK
//
// MessageText:
//
//  Subnet Mask . . . . . . . . . . . : %1
//
#define MSG_SUBNET_MASK                  0x00002724L

//
// MessageId: MSG_DEFAULT_GATEWAY
//
// MessageText:
//
//  Default Gateway . . . . . . . . . : %1
//
#define MSG_DEFAULT_GATEWAY              0x00002725L

//
// MessageId: MSG_DHCP_SERVER
//
// MessageText:
//
//  DHCP Server . . . . . . . . . . . : %1
//
#define MSG_DHCP_SERVER                  0x00002726L

//
// MessageId: MSG_WINS_SERVER_1
//
// MessageText:
//
//  Primary WINS Server . . . . . . . : %1
//
#define MSG_WINS_SERVER_1                0x00002727L

//
// MessageId: MSG_WINS_SERVER_2
//
// MessageText:
//
//  Secondary WINS Server . . . . . . : %1
//
#define MSG_WINS_SERVER_2                0x00002728L

//
// MessageId: MSG_LEASE_OBTAINED
//
// MessageText:
//
//  Lease Obtained. . . . . . . . . . : %1
//
#define MSG_LEASE_OBTAINED               0x00002729L

//
// MessageId: MSG_LEASE_EXPIRES
//
// MessageText:
//
//  Lease Expires . . . . . . . . . . : %1
//
#define MSG_LEASE_EXPIRES                0x0000272AL

//
// MessageId: MSG_MEDIA_DISCONNECTED
//
// MessageText:
//
//  Media State . . . . . . . . . . . : Cable Disconnected
//
#define MSG_MEDIA_DISCONNECTED           0x0000272BL

//
// MessageId: MSG_MEDIA_UNKNOWN_STATE
//
// MessageText:
//
//  Media State . . . . . . . . . . . : Unknown
//
#define MSG_MEDIA_UNKNOWN_STATE          0x0000272CL

//
// MessageId: MSG_DHCP_CLASS_ID
//
// MessageText:
//
//  DHCP Class ID . . . . . . . . . . : %1
//
#define MSG_DHCP_CLASS_ID                0x0000272DL

//
// MessageId: MSG_ERROR_STRING
//
// MessageText:
//
//  Error: %1
//
#define MSG_ERROR_STRING                 0x0000272EL

//
// MessageId: MSG_ADAPTER
//
// MessageText:
//
//  %1adapter %2:
//  
//
#define MSG_ADAPTER                      0x0000272FL

//
// MessageId: MSG_FATAL_ERROR
//
// MessageText:
//
//  Fatal error: %1
//  
//
#define MSG_FATAL_ERROR                  0x00002730L

//
// MessageId: MSG_INCORRECT_ARGS
//
// MessageText:
//
//  Error: Command line is incomplete or arguments conflict.
//  
//
#define MSG_INCORRECT_ARGS               0x00002731L

//
// MessageId: MSG_UNRECOGNIZED_ARG
//
// MessageText:
//
//  Error: Unrecognized command line argument "%1"
//  
//
#define MSG_UNRECOGNIZED_ARG             0x00002732L

//
// MessageId: MSG_USAGE
//
// MessageText:
//
//  
//  USAGE:
//     ipconfig [/? | /all | /release [adapter] | /renew [adapter] 
//              | /flushdns | /registerdns
//              | /showclassid adapter
//              | /setclassid adapter [classidtoset] ]
//  
//     adapter    Full name or pattern with '*' and '?' to 'match',
//                * matches any character, ? matches one character.
//     Options
//         /?           Display this help message.
//         /all         Display full configuration information.
//         /release     Release the IP address for the specified adapter.
//         /renew       Renew the IP address for the specified adapter.
//         /flushdns    Purges the DNS Resolver cache.
//         /registerdns Refreshes all DHCP leases and re-registers DNS names
//         /displaydns  Display the contents of the DNS Resolver Cache.
//         /showclassid Displays all the dhcp class IDs allowed for adapter.
//         /setclassid  Modifies the dhcp class id.
//  
//  The default is to display only the IP address, subnet mask and
//  default gateway for each adapter bound to TCP/IP.
//  
//  For Release and Renew, if no adapter name is specified, then the IP address
//  leases for all adapters bound to TCP/IP will be released or renewed.
//  
//  For SetClassID, if no class id is specified, then the classid is removed.
//  
//  Examples:
//      > ipconfig                       ... Show information.
//      > ipconfig /all                  ... Show detailed information
//      > ipconfig /renew                ... renew all adapters
//      > ipconfig /renew EL*            ... renew adapters named EL....
//      > ipconfig /release *ELINK?21*   ... release all matching adapters,
//                                           eg. ELINK-21, myELELINKi21adapter.
//
#define MSG_USAGE                        0x00002733L

//
// MessageId: MSG_BNODE
//
// MessageText:
//
//  Broadcast%0
//
#define MSG_BNODE                        0x00002734L

//
// MessageId: MSG_PNODE
//
// MessageText:
//
//  Peer-Peer%0
//
#define MSG_PNODE                        0x00002735L

//
// MessageId: MSG_MNODE
//
// MessageText:
//
//  Mixed%0
//
#define MSG_MNODE                        0x00002736L

//
// MessageId: MSG_HNODE
//
// MessageText:
//
//  Hybrid%0
//
#define MSG_HNODE                        0x00002737L

//
// MessageId: MSG_IF_TYPE_OTHER
//
// MessageText:
//
//  Other %0
//
#define MSG_IF_TYPE_OTHER                0x00002738L

//
// MessageId: MSG_IF_TYPE_ETHERNET
//
// MessageText:
//
//  Ethernet %0
//
#define MSG_IF_TYPE_ETHERNET             0x00002739L

//
// MessageId: MSG_IF_TYPE_TOKEN_RING
//
// MessageText:
//
//  Token Ring %0
//
#define MSG_IF_TYPE_TOKEN_RING           0x0000273AL

//
// MessageId: MSG_IF_TYPE_FDDI
//
// MessageText:
//
//  FDDI %0
//
#define MSG_IF_TYPE_FDDI                 0x0000273BL

//
// MessageId: MSG_IF_TYPE_PPP
//
// MessageText:
//
//  PPP %0
//
#define MSG_IF_TYPE_PPP                  0x0000273CL

//
// MessageId: MSG_IF_TYPE_LOOPBACK
//
// MessageText:
//
//  Loopback %0
//
#define MSG_IF_TYPE_LOOPBACK             0x0000273DL

//
// MessageId: MSG_IF_TYPE_SLIP
//
// MessageText:
//
//  SLIP %0
//
#define MSG_IF_TYPE_SLIP                 0x0000273EL

//
// MessageId: MSG_YES
//
// MessageText:
//
//  Yes%0
//
#define MSG_YES                          0x0000273FL

//
// MessageId: MSG_NO
//
// MessageText:
//
//  No%0
//
#define MSG_NO                           0x00002740L

//
// MessageId: MSG_INIT_FAILED
//
// MessageText:
//
//  Failed to initialize%0
//
#define MSG_INIT_FAILED                  0x00002741L

//
// MessageId: MSG_TCP_NOT_RUNNING
//
// MessageText:
//
//  TCP/IP is not running on this system%0
//
#define MSG_TCP_NOT_RUNNING              0x00002742L

//
// MessageId: MSG_REG_BINDINGS_ERROR
//
// MessageText:
//
//  Cannot access adapter bindings registry key%0
//
#define MSG_REG_BINDINGS_ERROR           0x00002743L

//
// MessageId: MSG_REG_INCONSISTENT_ERROR
//
// MessageText:
//
//  Inconsistent registry contents%0
//
#define MSG_REG_INCONSISTENT_ERROR       0x00002744L

//
// MessageId: MSG_TCP_BINDING_ERROR
//
// MessageText:
//
//  TCP/IP not bound to any adapters%0
//
#define MSG_TCP_BINDING_ERROR            0x00002745L

//
// MessageId: MSG_MEMORY_ERROR
//
// MessageText:
//
//  Allocating memory%0
//
#define MSG_MEMORY_ERROR                 0x00002746L

//
// MessageId: MSG_ALL
//
// MessageText:
//
//  all%0
//
#define MSG_ALL                          0x00002747L

//
// MessageId: MSG_RELEASE
//
// MessageText:
//
//  Release%0
//
#define MSG_RELEASE                      0x00002748L

//
// MessageId: MSG_RENEW
//
// MessageText:
//
//  Renew%0
//
#define MSG_RENEW                        0x00002749L

//
// MessageId: MSG_FLUSH_DNS
//
// MessageText:
//
//  FlushDNS%0
//
#define MSG_FLUSH_DNS                    0x0000274AL

//
// MessageId: MSG_REFRESH
//
// MessageText:
//
//  RegisterDNS%0
//
#define MSG_REFRESH                      0x0000274BL

//
// MessageId: MSG_DISPLAY_DNS
//
// MessageText:
//
//  DisplayDNS%0
//
#define MSG_DISPLAY_DNS                  0x0000274CL

//
// MessageId: MSG_DISPLAY_CLASSID
//
// MessageText:
//
//  ShowClassID%0
//
#define MSG_DISPLAY_CLASSID              0x0000274DL

//
// MessageId: MSG_SET_CLASSID
//
// MessageText:
//
//  SetClassID%0
//
#define MSG_SET_CLASSID                  0x0000274EL

//
// MessageId: MSG_ADAPTER_NOT_FOUND
//
// MessageText:
//
//  Error: Adapter "%1" is not bound to TCP/IP
//
#define MSG_ADAPTER_NOT_FOUND            0x0000274FL

//
// MessageId: MSG_NO_ADAPTERS_BOUND
//
// MessageText:
//
//  Error: No adapters bound to TCP/IP
//
#define MSG_NO_ADAPTERS_BOUND            0x00002750L

//
// MessageId: MSG_CANT_FIND_LIBRARY
//
// MessageText:
//
//  Fatal: Cannot find dynamic link library "%1"
//
#define MSG_CANT_FIND_LIBRARY            0x00002751L

//
// MessageId: MSG_CANT_FIND_ROUTINE
//
// MessageText:
//
//  Fatal: Cannot find function "%1" in library "%2"
//
#define MSG_CANT_FIND_ROUTINE            0x00002752L

//
// MessageId: MSG_ADAPTER_NAME_ERROR
//
// MessageText:
//
//  Error: The adapter name "%1" is invalid
//
#define MSG_ADAPTER_NAME_ERROR           0x00002753L

//
// MessageId: MSG_RELEASE_FAILED
//
// MessageText:
//
//  The following error occurred when releasing adapter %2: %1
//
#define MSG_RELEASE_FAILED               0x00002754L

//
// MessageId: MSG_ACQUIRE_FAILED
//
// MessageText:
//
//  The following error occurred when renewing adapter %2: %1
//
#define MSG_ACQUIRE_FAILED               0x00002755L

//
// MessageId: MSG_REFRESH_FAILED
//
// MessageText:
//
//  Error: %1: Refreshing DNS names
//
#define MSG_REFRESH_FAILED               0x00002756L

//
// MessageId: MSG_RELEASE_SUCCEEDED
//
// MessageText:
//
//  IP address successfully released for adapter "%2"
//
#define MSG_RELEASE_SUCCEEDED            0x00002757L

//
// MessageId: MSG_RELEASE_OK
//
// MessageText:
//
//  IP address successfully released for adapter "%1"
//
#define MSG_RELEASE_OK                   0x00002758L

//
// MessageId: MSG_REFRESH_SUCCEEDED
//
// MessageText:
//
//  Registration of the DNS resource records for all adapters of this computer has been initiated. Any errors will be reported in the Event Viewer in 15 minutes.
//
#define MSG_REFRESH_SUCCEEDED            0x00002759L

//
// MessageId: MSG_CLASSID_MODIFIED
//
// MessageText:
//
//  DHCP ClassId successfully modified for adapter "%1"
//
#define MSG_CLASSID_MODIFIED             0x0000275AL

//
// MessageId: MSG_CLASSID_MODIFY_FAILED
//
// MessageText:
//
//  Error: %1
//  DHCP ClassId was not modified for adapter "%2"
//
#define MSG_CLASSID_MODIFY_FAILED        0x0000275BL

//
// MessageId: MSG_NO_DHCP_ENABLED
//
// MessageText:
//
//  Error: No adapters bound to TCP/IP are enabled for DHCP
//
#define MSG_NO_DHCP_ENABLED              0x0000275CL

//
// MessageId: MSG_ADAPTER_NOT_DHCP
//
// MessageText:
//
//  Error: %1
//  Adapter "%2" is not enabled for DHCP
//
#define MSG_ADAPTER_NOT_DHCP             0x0000275DL

//
// MessageId: MSG_CLASSES_LIST_HEADER
//
// MessageText:
//
//  DHCP Class ID for Adapter "%1":
//
#define MSG_CLASSES_LIST_HEADER          0x0000275EL

//
// MessageId: MSG_CLASSID_NAME
//
// MessageText:
//
//  DHCP ClassID Name . . . . . . . . : %1
//
#define MSG_CLASSID_NAME                 0x0000275FL

//
// MessageId: MSG_CLASSID_DESCRIPTION
//
// MessageText:
//
//  DHCP ClassID Description  . . . . : %1
//
#define MSG_CLASSID_DESCRIPTION          0x00002760L

//
// MessageId: MSG_CLASSID_FAILED
//
// MessageText:
//
//  Error: %1
//  Failed to obtain the DHCP class ID list for adapter "%2"
//
#define MSG_CLASSID_FAILED               0x00002761L

//
// MessageId: MSG_CLASSES_LIST_EMPTY
//
// MessageText:
//
//  There are no DHCP classes for adapter "%1".
//
#define MSG_CLASSES_LIST_EMPTY           0x00002762L

//
// MessageId: MSG_ACCESS_DENIED
//
// MessageText:
//
//  Unexpected network failure or insufficient access%0
//
#define MSG_ACCESS_DENIED                0x00002763L

//
// MessageId: MSG_SERVER_UNAVAILABLE
//
// MessageText:
//
//  DHCP Server unreachable%0
//
#define MSG_SERVER_UNAVAILABLE           0x00002764L

//
// MessageId: MSG_ALREADY_RELEASED
//
// MessageText:
//
//  IP Address for adapter %1 is already released
//
#define MSG_ALREADY_RELEASED             0x00002765L

//
// MessageId: MSG_ADDRESS_CONFLICT
//
// MessageText:
//
//  The DHCP client obtained an address that is already in use on the network.
//
#define MSG_ADDRESS_CONFLICT             0x00002766L

//
// MessageId: MSG_CANT_OPERATE_DISCONNECTED_MEDIA
//
// MessageText:
//
//  No operation can be performed on adapter %1 as this connection has its media/cable disconnected.
//
#define MSG_CANT_OPERATE_DISCONNECTED_MEDIA 0x00002767L

//
// MessageId: MSG_CANT_RELEASE_AUTOCONFIG_ADAPTER
//
// MessageText:
//
//  Adapter %1 was automatically configured and does not currently have a DHCP address.  The IP address for this adapter can not be released.
//
#define MSG_CANT_RELEASE_AUTOCONFIG_ADAPTER 0x00002768L

//
// MessageId: MSG_NO_DHCP_ADDRESS
//
// MessageText:
//
//  All adapters bound to DHCP do not have DHCP addresses.  The addresses were automatically configured and can not be released.
//
#define MSG_NO_DHCP_ADDRESS              0x00002769L

//
// MessageId: MSG_FLUSHDNS_FAILED
//
// MessageText:
//
//  Could not flush the DNS Resolver Cache.
//
#define MSG_FLUSHDNS_FAILED              0x0000276AL

//
// MessageId: MSG_DHCP_NO_CONTEXT
//
// MessageText:
//
//  An internal error occurred.  Disconnect and reconnect the network interface or reboot the machine.
//
#define MSG_DHCP_NO_CONTEXT              0x0000276BL

//
// MessageId: MSG_FLUSHDNS_SUCCEEDED
//
// MessageText:
//
//  Successfully flushed the DNS Resolver Cache.
//
#define MSG_FLUSHDNS_SUCCEEDED           0x0000276CL

//
// MessageId: MSG_DISPLAYDNS_FAILED
//
// MessageText:
//
//  Could not display the DNS Resolver Cache.
//
#define MSG_DISPLAYDNS_FAILED            0x0000276DL

//
// MessageId: MSG_DNS_RECORD_NAME
//
// MessageText:
//
//       Record Name . . . . . : %0
//
#define MSG_DNS_RECORD_NAME              0x0000276EL

//
// MessageId: MSG_DNS_RECORD_TYPE
//
// MessageText:
//
//       Record Type . . . . . : %0
//
#define MSG_DNS_RECORD_TYPE              0x0000276FL

//
// MessageId: MSG_DNS_RECORD_TTL
//
// MessageText:
//
//       Time To Live  . . . . : %0
//
#define MSG_DNS_RECORD_TTL               0x00002770L

//
// MessageId: MSG_DNS_RECORD_DATALEN
//
// MessageText:
//
//       Data Length . . . . . : %0
//
#define MSG_DNS_RECORD_DATALEN           0x00002771L

//
// MessageId: MSG_DNS_RECORD_SECTION
//
// MessageText:
//
//       Section . . . . . . . : %0
//
#define MSG_DNS_RECORD_SECTION           0x00002772L

//
// MessageId: MSG_DNS_A_RECORD
//
// MessageText:
//
//       A (Host) Record . . . : %0
//
#define MSG_DNS_A_RECORD                 0x00002773L

//
// MessageId: MSG_DNS_SRV_RECORD
//
// MessageText:
//
//       SRV Record  . . . . . : %0
//
#define MSG_DNS_SRV_RECORD               0x00002774L

//
// MessageId: MSG_DNS_SOA_RECORD
//
// MessageText:
//
//       SOA Record  . . . . . : %0
//
#define MSG_DNS_SOA_RECORD               0x00002775L

//
// MessageId: MSG_DNS_NS_RECORD
//
// MessageText:
//
//       NS Record   . . . . . : %0
//
#define MSG_DNS_NS_RECORD                0x00002776L

//
// MessageId: MSG_DNS_PTR_RECORD
//
// MessageText:
//
//       PTR Record  . . . . . : %0
//
#define MSG_DNS_PTR_RECORD               0x00002777L

//
// MessageId: MSG_DNS_MX_RECORD
//
// MessageText:
//
//       MX Record . . . . . . : %0
//
#define MSG_DNS_MX_RECORD                0x00002778L

//
// MessageId: MSG_DNS_AAAA_RECORD
//
// MessageText:
//
//       AAAA Record . . . . . : %0
//
#define MSG_DNS_AAAA_RECORD              0x00002779L

//
// MessageId: MSG_DNS_ATMA_RECORD
//
// MessageText:
//
//       ATMA Record . . . . . : %0
//
#define MSG_DNS_ATMA_RECORD              0x0000277AL

//
// MessageId: MSG_DNS_CNAME_RECORD
//
// MessageText:
//
//       CNAME Record  . . . . : %0
//
#define MSG_DNS_CNAME_RECORD             0x0000277BL

//
// MessageId: MSG_DNS_ERR_NO_RECORDS
//
// MessageText:
//
//            Negative cache entry for no records%0
//
#define MSG_DNS_ERR_NO_RECORDS           0x0000277CL

//
// MessageId: MSG_DNS_ERR_NAME_ERROR
//
// MessageText:
//
//            Negative cache entry for name error%0
//
#define MSG_DNS_ERR_NAME_ERROR           0x0000277DL

//
// MessageId: MSG_DNS_ERR_UNABLE_TO_DISPLAY
//
// MessageText:
//
//            Record data for type could not be displayed%0
//
#define MSG_DNS_ERR_UNABLE_TO_DISPLAY    0x0000277EL

//
// MessageId: MSG_DNS_ERR_EXPIRED_CACHE_ENTRY
//
// MessageText:
//
//            Record data for type has expired%0
//
#define MSG_DNS_ERR_EXPIRED_CACHE_ENTRY  0x0000277FL

//
// MessageId: MSG_NETBIOS_DISABLED
//
// MessageText:
//
//  NetBIOS over Tcpip. . . . . . . . : Disabled
//
#define MSG_NETBIOS_DISABLED             0x00002780L
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\ipxtest.h ===
/*--

Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:

     ipxtest.h

Abstract:

     Header file for ipx test

Author:
   
     4-Aug-1998 (t-rajkup)

Revision History:

     None.

--*/

#ifndef HEADER_IPXTEST
#define HEADER_IPXTEST

#define INVALID_HANDLE  (HANDLE)(-1)

#define REORDER_ULONG(_Ulong) \
    ((((_Ulong) & 0xff000000) >> 24) | \
     (((_Ulong) & 0x00ff0000) >> 8) | \
     (((_Ulong) & 0x0000ff00) << 8) | \
     (((_Ulong) & 0x000000ff) << 24))

HRESULT InitIpxConfig(NETDIAG_PARAMS *pParams,
					  NETDIAG_RESULT *pResults);

#define IPX_TYPE_LAN		1
#define IPX_TYPE_UP_WAN		2
#define IPX_TYPE_DOWN_WAN	3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\ipcfgtest.h ===
/*++
Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:
  ipcfgtest.h

Author:
  05-Aug-1998 ( t-rajkup )

Arguments:
  None.

--*/
#ifndef HEADER_IPCFGTEST
#define HEADER_IPCFGTEST

#define DEBUG_PRINT(S) /* nothing */
#define TRACE_PRINT(S) /* nothing */

#define TCPIP_PARAMS_INTER_KEY "Tcpip\\Parameters\\Interfaces\\"
#define SERVICES_KEY        "SYSTEM\\CurrentControlSet\\Services"

#define STRING_ARRAY_DELIMITERS " \t,;"

#define MAX_STRING_LIST_LENGTH  32  // arbitrary

#ifndef FLAG_DONT_SHOW_PPP_ADAPTERS
#define FLAG_DONT_SHOW_PPP_ADAPTERS 0
#endif

BOOL	ZERO_IP_ADDRESS(LPCTSTR pszIp);
#define MAP_ADAPTER_GUID_TO_NAME(Guid)  MapAdapterGuidToName(Guid)

#define LAST_NODE_TYPE  4

#define NODE_TYPE_BROADCAST             1
#define NODE_TYPE_PEER_PEER             2
#define NODE_TYPE_MIXED                 4
#define NODE_TYPE_HYBRID                8

#define FIRST_NODE_TYPE 1

#define MAX_ALLOWED_ADAPTER_NAME_LENGTH (MAX_ADAPTER_NAME_LENGTH + 256)

#define BNODE               NODE_TYPE_BROADCAST
#define PNODE               NODE_TYPE_PEER_PEER
#define MNODE               NODE_TYPE_MIXED
#define HNODE               NODE_TYPE_HYBRID

typedef DWORD (__stdcall *PFNGUIDTOFRIENDLYNAME)(LPWSTR szGuidPath, LPWSTR szBuffer, DWORD cchBuffer);
 
extern PFNGUIDTOFRIENDLYNAME pfnGuidToFriendlyName;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\ipxtest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      ipxtest.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--
#include "precomp.h"
#include "ipxtest.h"

static HANDLE s_isnipxfd = INVALID_HANDLE;
static wchar_t isnipxname[] = L"\\Device\\NwlnkIpx";



void IPXprint_config(NETDIAG_PARAMS *pParams,
					 NETDIAG_RESULT *pResults
   );

int do_isnipxioctl(
                   IN HANDLE fd,
                   IN int cmd,
                   OUT char *datap,
                   IN int dlen
                   );

HRESULT LoadIpxInterfaceInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);
void get_emsg(NETDIAG_PARAMS *pParams, int rc);



HRESULT InitIpxConfig(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
	UNICODE_STRING FileString;
	OBJECT_ATTRIBUTES ObjectAttributes;
	IO_STATUS_BLOCK IoStatusBlock;
	NTSTATUS Status;
	HRESULT	hr = hrOK;

	PrintStatusMessage(pParams,0, IDS_IPX_STATUS_MSG);
	
	/** Open the isnipx driver **/
	
	RtlInitUnicodeString (&FileString, isnipxname);
	
	InitializeObjectAttributes(
							   &ObjectAttributes,
							   &FileString,
							   OBJ_CASE_INSENSITIVE,
							   NULL,
							   NULL);
	
	Status = NtOpenFile(
						&pResults->Ipx.hIsnIpxFd,
						SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
						&ObjectAttributes,
						&IoStatusBlock,
						FILE_SHARE_READ | FILE_SHARE_WRITE,
						FILE_SYNCHRONOUS_IO_ALERT);
	
	pResults->Ipx.fInstalled = TRUE;
	pResults->Ipx.fEnabled = TRUE;
	
	if (!NT_SUCCESS(Status))
	{
		pResults->Ipx.hIsnIpxFd = INVALID_HANDLE;
		
		// IDS_IPX_15603  "Opening \\Device\\NwlnkIpx failed\n"
		PrintDebug(pParams, 4, IDS_IPX_15603);

		pResults->Ipx.fInstalled = FALSE;
		pResults->Ipx.fEnabled = FALSE;

		// IPX is not installed, do not return the error code
		// but return S_FALSE.
		return S_FALSE;
	}

	// Fill in the IPX adapter interface data
	hr = LoadIpxInterfaceInfo(pParams, pResults);
	
	return hr;
}

IPX_TEST_FRAME*	PutIpxFrame(	
	// returns 0-3
	ULONG		uFrameType,
	// returns virtual net if NicId = 0
	ULONG		uNetworkNumber,
	// adapter's MAC address
	const UCHAR*	pNode,
	LIST_ENTRY*	pListHead		// if its NULL, then the new created will be head
)
{
	IPX_TEST_FRAME*	pFrame = NULL; 
	if(pListHead == NULL) return NULL;

	pFrame = (IPX_TEST_FRAME*)malloc(sizeof(IPX_TEST_FRAME));

	if(pFrame == NULL)	return NULL;

	if( pListHead->Flink == NULL && pListHead->Blink == NULL)	// the head is not initilized
		InitializeListHead(pListHead);

	pFrame->uFrameType = uFrameType;
	pFrame->uNetworkNumber = uNetworkNumber;
	memcpy(&pFrame->Node[0], pNode, sizeof(pFrame->Node));

	InsertTailList(pListHead, &(pFrame->list_entry));

	return pFrame;
}

HRESULT LoadIpxInterfaceInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
	int rc;
	USHORT nicid, nicidcount;
	ISN_ACTION_GET_DETAILS getdetails;
	HANDLE hMpr = NULL;
	DWORD dwErr;
	PVOID	pv;
	HRESULT		hr = hrOK;
	int			i, iIpx;
	INTERFACE_RESULT *	pIfResults;
	LPTSTR		pszAdapterName = NULL;
	
	unsigned char	node[6] = {0, 0,0,0,0,1};

	// Initialize the map from guid to interface name
	CheckErr( MprConfigServerConnect(NULL, &hMpr) );
	assert(hMpr != INVALID_HANDLE);
	
	/** First query nicid 0 **/
	
	getdetails.NicId = 0;
	
	rc = do_isnipxioctl(pResults->Ipx.hIsnIpxFd, MIPX_CONFIG, (char *)&getdetails, sizeof(getdetails));
	if (rc)
	{
		// IDS_IPX_15604 "Error querying config nwlnkipx :"
		PrintDebug(pParams, 0, IDS_IPX_15604);
		if (pParams->fDebugVerbose)
		{
			get_emsg(pParams, rc);
		}
		goto Error;
	}
	
	//
	// The NicId 0 query returns the total number.
	//
	nicidcount = getdetails.NicId;

	// We should have an open spot for the IPX internal interface
	// ----------------------------------------------------------------
	assert(pResults->cNumInterfacesAllocated > pResults->cNumInterfaces);

	
	// Set the first IPX interface as the IPX internal
	iIpx = pResults->cNumInterfaces;

	
	// Add the internal interface
	pIfResults = pResults->pArrayInterface + iIpx;
	pIfResults->fActive = TRUE;
	pIfResults->Ipx.fActive = TRUE;
	pIfResults->pszName = StrDup(_T("Internal"));
	pIfResults->pszFriendlyName = LoadAndAllocString(IDS_IPX_INTERNAL);
	pIfResults->Ipx.uNicId = 0;
	pIfResults->Ipx.fBindingSet = 0;
	pIfResults->Ipx.uType = 0;

	// multiple frame types
	PutIpxFrame(0, REORDER_ULONG(getdetails.NetworkNumber), node, &(pIfResults->Ipx.list_entry_Frames));

	iIpx++;		// move on to the next new interface structure
	pResults->cNumInterfaces++;
	
    InitializeListHead(&pResults->Dns.lmsgOutput);
    
	for (nicid = 1; nicid <= nicidcount; nicid++)
	{

		// get the next structure
		getdetails.NicId = nicid;
		
		rc = do_isnipxioctl(pResults->Ipx.hIsnIpxFd, MIPX_CONFIG, (char *)&getdetails, sizeof(getdetails)
						   );
		if (rc)
		{
			continue;
		}

		// convert the adapter name into ASCII
		pszAdapterName = StrDupTFromW(getdetails.AdapterName);

		// see if this interface is already in the list
		pIfResults = NULL;
		for ( i=0; i<pResults->cNumInterfaces; i++)
		{
			if (lstrcmpi(pResults->pArrayInterface[i].pszName,
						 pszAdapterName) == 0)
			{
				pIfResults = pResults->pArrayInterface + i;
				break;
			}
			
		}

		// if we didn't find a match, use one of the newly allocated
		// interfaces
		if (pIfResults == NULL)
		{
			// We need a new interface result structure, grab one
			// (if it is free), else allocate more.
			if (pResults->cNumInterfaces >= pResults->cNumInterfacesAllocated)
			{
				// Need to do a realloc to get more memory
				pv = Realloc(pResults->pArrayInterface,
							 sizeof(INTERFACE_RESULT)*(pResults->cNumInterfacesAllocated+8));
				if (pv == NULL)
					CheckHr( E_OUTOFMEMORY );

				pResults->pArrayInterface = pv;
				
				// Zero out the new section of memory
				ZeroMemory(pResults->pArrayInterface + pResults->cNumInterfacesAllocated,
						   sizeof(INTERFACE_RESULT)*8);

				pResults->cNumInterfacesAllocated += 8;
			}
			
			pIfResults = pResults->pArrayInterface + iIpx;
			iIpx++;
			pResults->cNumInterfaces++;

			pIfResults->pszName = _tcsdup(pszAdapterName);
		}

		free(pszAdapterName);
		pszAdapterName = NULL;

		// Enable IPX on this interface
		pIfResults->fActive = TRUE;
		pIfResults->Ipx.fActive = TRUE;

		pIfResults->Ipx.uNicId = nicid;

		// support multiple frame types
		PutIpxFrame(getdetails.FrameType, REORDER_ULONG(getdetails.NetworkNumber), &(getdetails.Node[0]), &(pIfResults->Ipx.list_entry_Frames));
		
		// Translate the adapter name (if needed)
		if (!pIfResults->pszFriendlyName)
		{
			if (getdetails.Type == IPX_TYPE_LAN)
			{
				WCHAR swzName[512];
				PWCHAR pszGuid = &(getdetails.AdapterName[0]);
				
				dwErr = MprConfigGetFriendlyName(hMpr,
					pszGuid,
					swzName,
					sizeof(swzName));
				
				if (dwErr == NO_ERROR)
					pIfResults->pszFriendlyName = StrDupTFromW(swzName);
				else
					pIfResults->pszFriendlyName =
						StrDupTFromW(getdetails.AdapterName);
			}
			else
				pIfResults->pszFriendlyName =
									StrDupTFromW(getdetails.AdapterName);
		}

		pIfResults->Ipx.fBindingSet = getdetails.BindingSet;
	}
	
Error:
	
	/** Close up and exit **/
	
	// Cleanup interface map
	if (hMpr)
		MprConfigServerDisconnect(hMpr);
	
	return hr;
}



HRESULT
IpxTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	return hrOK;
}



int do_isnipxioctl(
            IN HANDLE fd,
            IN int cmd,
            OUT char *datap,
            IN  int dlen)
{
    NTSTATUS Status;
    UCHAR buffer[sizeof(NWLINK_ACTION) + sizeof(ISN_ACTION_GET_DETAILS) - 1];
    PNWLINK_ACTION action;
    IO_STATUS_BLOCK IoStatusBlock;
    int rc;

    /** Fill out the structure **/

    action = (PNWLINK_ACTION)buffer;

    action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
    action->OptionType = NWLINK_OPTION_CONTROL;
    action->BufferLength = sizeof(ULONG) + dlen;
    action->Option = cmd;
    RtlMoveMemory(action->Data, datap, dlen);

    /** Issue the ioctl **/

    Status = NtDeviceIoControlFile(
                 fd,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 IOCTL_TDI_ACTION,
                 NULL,
                 0,
                 action,
                 FIELD_OFFSET(NWLINK_ACTION,Data) + dlen);

    if (Status != STATUS_SUCCESS) {
        if (Status == STATUS_INVALID_PARAMETER) {
            rc = ERANGE;
        } else {
            rc = EINVAL;
        }
    } else {
        if (dlen > 0) {
            RtlMoveMemory (datap, action->Data, dlen);
        }
        rc = 0;
    }

    return rc;

}

void get_emsg(NETDIAG_PARAMS *pParams, int rc)
{
    /**
        We have 3 defined error codes that can come back.

        1 - EINVAL means that we sent down parameters wrong
                   (SHOULD NEVER HAPPEN)

        2 - ERANGE means that the board number is invalid
                   (CAN HAPPEN IF USER ENTERS BAD BOARD)

        3 - ENOENT means that on remove - the address given
                   is not in the source routing table.
    **/

    switch (rc) {

    case EINVAL:
		// IDS_IPX_15605 "we sent down parameters wrong\n"
        PrintMessage(pParams, IDS_IPX_15605);
        break;

    case ERANGE:
		// IDS_IPX_15606 "board number is invalid\n"
        PrintMessage(pParams, IDS_IPX_15606);
        break;

    case ENOENT:
		// IDS_IPX_15607 "remove - the address given is not in the source routing table\n"
        PrintMessage(pParams, IDS_IPX_15607);
        break;

    default:
		// IDS_IPX_15608 "Unknown Error\n"
        PrintMessage(pParams, IDS_IPX_15608);
        break;
    }

    return;
}




/*!--------------------------------------------------------------------------
	IpxGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxGlobalPrint( NETDIAG_PARAMS* pParams,
						  NETDIAG_RESULT*  pResults)
{
	if (!pResults->Ipx.fInstalled)
		return;

#if 0
	if (pParams->fVerbose)
	{
		PrintNewLine(pParams, 2);
		PrintTestTitleResult(pParams, IDS_IPX_LONG, IDS_IPX_SHORT, TRUE, pResults->Ipx.hr, 0);
	}
#endif
}

/*!--------------------------------------------------------------------------
	IpxPerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxPerInterfacePrint( NETDIAG_PARAMS* pParams,
								NETDIAG_RESULT*  pResults,
								INTERFACE_RESULT *pInterfaceResults)
{
	int		ids;
	LPTSTR	pszFrameType = NULL;
	LIST_ENTRY* pEntry = NULL;
	IPX_TEST_FRAME* pFrameEntry = NULL;
	
	// no per-interface results
	if (!pResults->Ipx.fInstalled)
	{
		if (pParams->fReallyVerbose)
			// IDS_IPX_15609 "        IPX test : IPX is not installed on this machine.\n"
			PrintMessage(pParams, IDS_IPX_15609);
		return;
	}


	if (!pInterfaceResults->Ipx.fActive)
		return;

	// IDS_IPX_15610 "\n        Ipx configration\n"
	PrintMessage(pParams, IDS_IPX_15610);

	// support multiple frame types
	// loop all the frame in the list_entry
	pEntry = pInterfaceResults->Ipx.list_entry_Frames.Flink;

    for ( pEntry = pInterfaceResults->Ipx.list_entry_Frames.Flink ;
          pEntry != &pInterfaceResults->Ipx.list_entry_Frames ;
          pEntry = pEntry->Flink )
	{
		pFrameEntry = CONTAINING_RECORD(pEntry, IPX_TEST_FRAME, list_entry);

		ASSERT(pFrameEntry);
		// network number
		// IDS_IPX_15611 "            Network Number : %.8x\n"
		PrintMessage(pParams, IDS_IPX_15611,
				 pFrameEntry->uNetworkNumber);

		// node
		// IDS_IPX_15612 "            Node : %2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\n"
		PrintMessage(pParams, IDS_IPX_15612,
		   pFrameEntry->Node[0],
		   pFrameEntry->Node[1],
		   pFrameEntry->Node[2],
		   pFrameEntry->Node[3],
		   pFrameEntry->Node[4],
		   pFrameEntry->Node[5]);

		// frame type
		switch (pFrameEntry->uFrameType)
		{
			case 0 : ids = IDS_IPX_ETHERNET_II;		break;
			case 1 : ids = IDS_IPX_802_3;			break;
			case 2 : ids = IDS_IPX_802_2;			break;
			case 3 : ids = IDS_IPX_SNAP;			break;
			case 4 : ids = IDS_IPX_ARCNET;			break;
			default:
					 ids = IDS_IPX_UNKNOWN;			break;
		}
		pszFrameType = LoadAndAllocString(ids);
				
		// IDS_IPX_15613 "            Frame type : %s\n"
		PrintMessage(pParams, IDS_IPX_15613, pszFrameType);
	
		Free(pszFrameType);

		PrintNewLine(pParams, 1);
	}

	// type
	PrintNewLine(pParams, 1);
}


/*!--------------------------------------------------------------------------
	IpxCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	int i;
	LIST_ENTRY*	pEntry = NULL;
	IPX_TEST_FRAME* pFrameEntry = NULL;
	INTERFACE_RESULT*	pIfResults = NULL;
	
	if (pResults->Ipx.hIsnIpxFd != INVALID_HANDLE)
		NtClose(pResults->Ipx.hIsnIpxFd);
	pResults->Ipx.hIsnIpxFd = INVALID_HANDLE;


	// per interface stuff -- loop through
	for ( i = 0; i < pResults->cNumInterfacesAllocated; i++)
	{
		pIfResults = pResults->pArrayInterface + i;
		
		if(pIfResults->Ipx.list_entry_Frames.Flink)	// there is data need to be cleaned up
		{
			while (!IsListEmpty(&(pIfResults->Ipx.list_entry_Frames)))
			{
				pEntry = RemoveHeadList(&(pIfResults->Ipx.list_entry_Frames));
				// find data pointer
				pFrameEntry = CONTAINING_RECORD(pEntry, IPX_TEST_FRAME, list_entry);

				free(pFrameEntry);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\iploopbk.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      iploopbk.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--


#include "precomp.h"

//-------------------------------------------------------------------------//
//######  I p L o o p B k T e s t ()  #####################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Pings the IP loopback address. If this succeeds then the IP stack  //
//      is most probably in a working state.                               //
//  Arguments:                                                             //
//      none                                                               //
//  Return value:                                                          //
//      TRUE  - test passed                                                //
//      FALSE - test failed                                                //
//  Global variables used:                                                 //
//		none                                              		           //
//-------------------------------------------------------------------------//
HRESULT IpLoopBkTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    BOOL RetVal = TRUE;
	HRESULT	hr = hrOK;

	if (!pResults->IpConfig.fEnabled)
		return hrOK;

	PrintStatusMessage(pParams,0, IDS_IPLOOPBK_STATUS_MSG);

    RetVal = IsIcmpResponse( _T("127.0.0.1") );

    if ( RetVal == FALSE )
	{
		PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);

		hr = S_FALSE;
		pResults->LoopBack.hr = S_FALSE;
		SetMessage(&pResults->LoopBack.msgLoopBack,
					 Nd_Quiet,
				   IDS_IPLOOPBK_FAIL);
    }
    else
	{
		PrintStatusMessage(pParams,0, IDS_GLOBAL_PASS_NL);
		
		hr = S_OK;
		pResults->LoopBack.hr = S_OK;
		SetMessage(&pResults->LoopBack.msgLoopBack,
				Nd_ReallyVerbose,
				   IDS_IPLOOPBK_PASS);
    }

    return hr;

} /* END OF IpLoopBkTest() */


/*!--------------------------------------------------------------------------
	IpLoopBkGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpLoopBkGlobalPrint( NETDIAG_PARAMS* pParams,
						  NETDIAG_RESULT*  pResults)
{
	if (!pResults->IpConfig.fEnabled)
	{
		return;
	}
	
	if (pParams->fVerbose || !FHrOK(pResults->LoopBack.hr))
	{
		PrintNewLine(pParams, 2);
		PrintTestTitleResult(pParams, IDS_IPLOOPBK_LONG, IDS_IPLOOPBK_SHORT, TRUE, pResults->LoopBack.hr, 0);
		PrintNdMessage(pParams, &pResults->LoopBack.msgLoopBack);
	}
}

/*!--------------------------------------------------------------------------
	IpLoopBkPerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpLoopBkPerInterfacePrint( NETDIAG_PARAMS* pParams,
								NETDIAG_RESULT*  pResults,
								INTERFACE_RESULT *pInterfaceResults)
{
	// no per-interface results
}


/*!--------------------------------------------------------------------------
	IpLoopBkCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpLoopBkCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	ClearMessage(&pResults->LoopBack.msgLoopBack);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\ipcfg.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      ipcfg.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "ipcfg.h"
#include "regutil.h"
#include "mprapi.h"		// for friendly-name interface mapping
#include "strings.h"

LPTSTR MapScopeId(PVOID Param);
LPTSTR MapAdapterType(UINT type);
LPTSTR MapAdapterAddress(PIP_ADAPTER_INFO pAdapterInfo, LPTSTR Buffer);
VOID PingDhcpServer(NETDIAG_PARAMS *pParams, IPCONFIG_TST *pIpConfig);
VOID PingWinsServers(NETDIAG_PARAMS *pParams, IPCONFIG_TST *pIpConfig);


/*==========================< Iphlpapi functions >===========================*/

DWORD GetAdaptersInfo(
    PIP_ADAPTER_INFO pAdapterInfo,
    PULONG pOutBufLen
  );

DWORD GetNetworkParams(
    PFIXED_INFO pFixedInfo,
    PULONG pOutBufLen
  );
// -----------------------------------------------------------------
HRESULT GetAdditionalInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);




HRESULT
IpConfigTest(
  NETDIAG_PARAMS*  pParams,
  NETDIAG_RESULT*  pResults
 )
{
	HRESULT		hr = hrOK;
	int			i;
	IP_ADAPTER_INFO	*	pIpAdapterInfo;
	IPCONFIG_TST *	pIpConfig;
	ULONG			uDefGateway, uAddress, uMask;
	DWORD			dwDefGateway, dwAddress, dwMask;
	
	hr = InitIpconfig(pParams, pResults);
	if (!FHrSucceeded(hr))
	{
		// "Cannot retrieve IP configuration from registry!\n"
		PrintDebug(pParams, 0, IDS_IPCFG_CANNOT_GET_IP_INFO);
		return hr;
    }

	for ( i = 0; i<pResults->cNumInterfaces; i++)
	{
		pIpConfig = &pResults->pArrayInterface[i].IpConfig;
		pIpAdapterInfo = pIpConfig->pAdapterInfo;

		if (!pResults->pArrayInterface[i].IpConfig.fActive ||
			NETCARD_DISCONNECTED == pResults->pArrayInterface[i].dwNetCardStatus)
			continue;

		// Ping the DHCP server
		if (pIpAdapterInfo->DhcpEnabled)
		{
			if (!ZERO_IP_ADDRESS(pIpAdapterInfo->DhcpServer.IpAddress.String))
				PingDhcpServer(pParams,	pIpConfig);
			else
			{
				pIpConfig->hrPingDhcpServer = E_FAIL;
				pIpConfig->hr = E_FAIL;
				// "            [WARNING] Though, the card is Dhcp Enabled, you dont have a valid DHCP server address for the card.\n"
				SetMessage(&pIpConfig->msgPingDhcpServer,
						   Nd_Quiet,
						   IDS_IPCFG_INVALID_DHCP_ADDRESS);
			}
		}

		if (pResults->pArrayInterface[i].fNbtEnabled)
		{
			// Ping the primary and secondary WINS servers
			PingWinsServers(pParams, pIpConfig);
		}


        if(pIpAdapterInfo->GatewayList.IpAddress.String[0] != 0)
        {
		    // If the default gateway is defined, 
		    // then test to see if the gateway is on the same subnet as our IP address
		    //
		    uDefGateway = inet_addrA(pIpAdapterInfo->GatewayList.IpAddress.String);
		    uAddress = inet_addrA(pIpAdapterInfo->IpAddressList.IpAddress.String);
		    uMask = inet_addrA(pIpAdapterInfo->IpAddressList.IpMask.String);
		    
		    dwDefGateway = ntohl(uDefGateway);
		    dwAddress = ntohl(uAddress);
		    dwMask = ntohl(uMask);
		    
		    if ((dwDefGateway & dwMask) != (dwAddress & dwMask))
		    {
			    pIpConfig->hr = E_FAIL;
			    pIpConfig->hrDefGwSubnetCheck = E_FAIL;
		    }
        }
		
	}
   
	return hr;
}


LPTSTR MapScopeId(PVOID Param)
{
    return !strcmp((LPTSTR)Param, _T("*")) ? _T("") : (LPTSTR)Param;
}

#define dim(X) (sizeof(X)/sizeof((X)[0]))

/*!--------------------------------------------------------------------------
	MapGuidToServiceName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
LPTSTR MapGuidToServiceName(LPCTSTR pszServiceGuid)
{
    DWORD dwRetVal = ERROR_SUCCESS;
    static TCHAR s_szServiceName[MAX_ALLOWED_ADAPTER_NAME_LENGTH + 1];
    WCHAR swzServiceGuid[256], swzServiceName[256];

	// Copy guid into return buffer
	lstrcpyn(s_szServiceName, pszServiceGuid, DimensionOf(s_szServiceName));

    if( NULL == pfnGuidToFriendlyName )
		return s_szServiceName;

	StrCpyWFromT(swzServiceGuid, pszServiceGuid);

    if( !pfnGuidToFriendlyName(swzServiceGuid,
							swzServiceName,
							DimensionOf(swzServiceName)) )
	{
		StrnCpyTFromW(s_szServiceName, swzServiceName, DimensionOf(s_szServiceName));
    }

	return s_szServiceName;
}

/*!--------------------------------------------------------------------------
	MapGuidToServiceNameW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
LPWSTR MapGuidToServiceNameW(LPCWSTR pswzServiceGuid)
{
    DWORD dwRetVal = ERROR_SUCCESS;
    static WCHAR s_swzServiceName[1024];

	// Copy guid into return buffer
	StrnCpyW(s_swzServiceName, pswzServiceGuid, DimensionOf(s_swzServiceName));

    if (NULL == pfnGuidToFriendlyName)
        return s_swzServiceName;

	if (ERROR_SUCCESS != pfnGuidToFriendlyName((LPWSTR) pswzServiceGuid,
						   s_swzServiceName,
						   DimensionOf(s_swzServiceName)) )
    {
        //we still want to keep the GUID as service name if cannot find the friendly name
        StrnCpyW(s_swzServiceName, pswzServiceGuid, DimensionOf(s_swzServiceName));
    }

    return s_swzServiceName;
}

/*!--------------------------------------------------------------------------
	MapGuidToAdapterName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
LPTSTR MapGuidToAdapterName(LPCTSTR pszAdapterGuid)
{
	HANDLE	hConfig;
    WCHAR swzAdapterGuid[256], swzAdapterName[256];
	static TCHAR s_szAdapterName[1024];
	HRESULT	hr = hrOK;

	// Copy guid into return buffer
	StrnCpy(s_szAdapterName, pszAdapterGuid, DimensionOf(s_szAdapterName));

	StrnCpyWFromT(swzAdapterGuid, pszAdapterGuid, DimensionOf(swzAdapterGuid));

	CheckErr( MprConfigServerConnect(NULL, &hConfig) );
	CheckErr( MprConfigGetFriendlyName(hConfig, swzAdapterGuid,
									   swzAdapterName,
									   sizeof(swzAdapterName)
									  ) );
	MprConfigServerDisconnect(hConfig);

	StrnCpyTFromW(s_szAdapterName, swzAdapterName, DimensionOf(s_szAdapterName));

Error:
    return s_szAdapterName;
}

void
PingDhcpServer(
			   NETDIAG_PARAMS *pParams,
			   IPCONFIG_TST *pIpConfig)
{

	PrintStatusMessage(pParams, 4, IDS_IPCFG_STATUS_MSG);
	
	if (IsIcmpResponseA(pIpConfig->pAdapterInfo->DhcpServer.IpAddress.String))
	{
		pIpConfig->hrPingDhcpServer = S_OK;

		PrintStatusMessage(pParams,0, IDS_GLOBAL_PASS_NL);

		// "            Pinging DHCP server - reachable\n"
		SetMessage(&pIpConfig->msgPingDhcpServer,
				   Nd_ReallyVerbose,
				   IDS_IPCFG_PING_DHCP_OK);
	}
	else
	{
		pIpConfig->hrPingDhcpServer = S_FALSE;
		if (FHrSucceeded(pIpConfig->hr))
			pIpConfig->hr = S_FALSE;

		PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);

		// "            Pinging DHCP server  - not reachable\n"
		// "            WARNING: DHCP server may be down.\n"
		SetMessage(&pIpConfig->msgPingDhcpServer,
				   Nd_Quiet,
				   IDS_IPCFG_PING_DHCP_BAD);
	}
}

VOID
PingWinsServers(
				NETDIAG_PARAMS*  pParams,
				IPCONFIG_TST *pIpConfig)
{
	TCHAR	szBuffer[256];
	
	if (!ZERO_IP_ADDRESS(pIpConfig->pAdapterInfo->PrimaryWinsServer.IpAddress.String))
	{
		PrintStatusMessage(pParams,4, IDS_IPCFG_WINS_STATUS_MSG);
	
		if (IsIcmpResponseA(pIpConfig->pAdapterInfo->PrimaryWinsServer.IpAddress.String))
		{
			pIpConfig->hrPingPrimaryWinsServer = S_OK;

			PrintStatusMessage(pParams,0, IDS_GLOBAL_PASS_NL);

			// "            Pinging Primary WINS Server %s - reachable\n"
			SetMessage(&pIpConfig->msgPingPrimaryWinsServer,
					   Nd_ReallyVerbose,
					   IDS_IPCFG_PING_WINS,
					   pIpConfig->pAdapterInfo->PrimaryWinsServer.IpAddress.String);
					   
		}
		else
		{
			pIpConfig->hrPingPrimaryWinsServer = S_FALSE;
			if (FHrSucceeded(pIpConfig->hr))
				pIpConfig->hr = S_FALSE;

			PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);

			// "            Pinging Primary WINS Server %s - not reachable\n"
			SetMessage(&pIpConfig->msgPingPrimaryWinsServer,
					   Nd_Quiet,
					   IDS_IPCFG_PING_WINS_FAIL,
					   pIpConfig->pAdapterInfo->PrimaryWinsServer.IpAddress.String);
		}
	}
	
	if (!ZERO_IP_ADDRESS(pIpConfig->pAdapterInfo->SecondaryWinsServer.IpAddress.String))
	{
		PrintStatusMessage(pParams,4, IDS_IPCFG_WINS2_STATUS_MSG);
	
		if (IsIcmpResponseA(pIpConfig->pAdapterInfo->SecondaryWinsServer.IpAddress.String))
		{
			pIpConfig->hrPingSecondaryWinsServer = S_OK;

			PrintStatusMessage(pParams,0, IDS_GLOBAL_PASS_NL);

			// "            Pinging Secondary WINS Server %s - reachable\n"
			SetMessage(&pIpConfig->msgPingSecondaryWinsServer,
					   Nd_ReallyVerbose,
					   IDS_IPCFG_PING_WINS2,
					   pIpConfig->pAdapterInfo->SecondaryWinsServer.IpAddress.String);
		}
		else
		{
			pIpConfig->hrPingSecondaryWinsServer = S_FALSE;
			if (FHrSucceeded(pIpConfig->hr))
				pIpConfig->hr = S_FALSE;
		
			PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);

			// "            Pinging Secondary WINS Server %s - not reachable\n"
			SetMessage(&pIpConfig->msgPingSecondaryWinsServer,
					   Nd_Quiet,
					   IDS_IPCFG_PING_WINS2_FAIL,
					   pIpConfig->pAdapterInfo->SecondaryWinsServer.IpAddress.String);
		}
	}
	
	return;
}





LPTSTR MapAdapterAddress(PIP_ADAPTER_INFO pAdapterInfo, LPTSTR Buffer)
{

    LPTSTR format;
    int separator;
    int len;
    int i;
    LPTSTR pbuf = Buffer;
    UINT mask;

    len = min((int)pAdapterInfo->AddressLength, sizeof(pAdapterInfo->Address));

	mask = 0xff;
	separator = TRUE;
	
    switch (pAdapterInfo->Type)
	{
    case IF_TYPE_ETHERNET_CSMACD:
    case IF_TYPE_ISO88025_TOKENRING:
    case IF_TYPE_FDDI:
        format = _T("%02X");
        break;

    default:
        format = _T("%02x");
        break;
    }
	
    for (i = 0; i < len; ++i)
	{
        pbuf += wsprintf(pbuf, format, pAdapterInfo->Address[i] & mask);
        if (separator && (i != len - 1))
		{
            pbuf += wsprintf(pbuf, _T("-"));
        }
    }
    return Buffer;
}


void IpConfigCleanup(IN NETDIAG_PARAMS *pParams,
					 IN OUT NETDIAG_RESULT *pResults)
{
	int		i;
	IPCONFIG_TST *	pIpConfig;
	
	// Free up the global information
	// ----------------------------------------------------------------
	Free(pResults->IpConfig.pFixedInfo);
	pResults->IpConfig.pFixedInfo = NULL;

	// free up the list of adapters
	// ----------------------------------------------------------------
	Free(pResults->IpConfig.pAdapterInfoList);
	pResults->IpConfig.pAdapterInfoList = NULL;

	// set all of the adapter pointers to NULL
	// ----------------------------------------------------------------
	for ( i=0; i < pResults->cNumInterfaces; i++)
	{
		pIpConfig = &pResults->pArrayInterface[i].IpConfig;
		
		FreeIpAddressStringList(pIpConfig->DnsServerList.Next);
		pIpConfig->pAdapterInfo = NULL;

		ClearMessage(&pIpConfig->msgPingDhcpServer);
		ClearMessage(&pIpConfig->msgPingPrimaryWinsServer);
		ClearMessage(&pIpConfig->msgPingSecondaryWinsServer);
	}

	pResults->IpConfig.fInitIpconfigCalled = FALSE;
}




int AddIpAddressString(PIP_ADDR_STRING AddressList, LPSTR Address, LPSTR Mask)
{

    PIP_ADDR_STRING ipAddr;

    if (AddressList->IpAddress.String[0])
	{
        for (ipAddr = AddressList; ipAddr->Next; ipAddr = ipAddr->Next)
		{
            ;
        }
        ipAddr->Next = (PIP_ADDR_STRING) Malloc(sizeof(IP_ADDR_STRING));
        if (!ipAddr->Next)
		{
            return FALSE;
        }
		ZeroMemory(ipAddr->Next, sizeof(IP_ADDR_STRING));
        ipAddr = ipAddr->Next;
    }
	else
	{
        ipAddr = AddressList;
    }
	lstrcpynA(ipAddr->IpAddress.String, Address,
			  sizeof(ipAddr->IpAddress.String));
	lstrcpynA(ipAddr->IpMask.String, Mask,
			  sizeof(ipAddr->IpMask.String));
    return TRUE;
}

VOID FreeIpAddressStringList(PIP_ADDR_STRING pAddressList)
{
	PIP_ADDR_STRING	pNext;

	if (pAddressList == NULL)
		return;

	do
	{
		// get the next address
		pNext = pAddressList->Next;

		// free the current one
		Free(pAddressList);

		// move onto the next
		pAddressList = pNext;
		
	} while( pNext );

	return;
}

// Go through the ADAPTER_INFO list to count the number of interfaces
LONG CountInterfaces(PIP_ADAPTER_INFO ListAdapterInfo)
{
    LONG cNum = 0;
    PIP_ADAPTER_INFO pAdapter;
    for(pAdapter = ListAdapterInfo; pAdapter != NULL; pAdapter = pAdapter->Next) {
        cNum ++;
    }
    return cNum;
}


/*!--------------------------------------------------------------------------
	InitIpconfig

	Description:
	This function will get all the ipconfig information by using calls into 
	iphlpapi.lib.

	The iphlpapi.lib returns an IP_ADAPTER_INFO structure which doesnt contain
	many fields present int the ADAPTER_INFO structure found in ipconfig code.
	Since the majority of the code  uses ADAPTER_INFO structure, this fucntion
	will copy the values found in IP_ADAPTER_INFO  to ADAPTER_INFO.
	
	The values which are not supplied by iphlpapi.lib calls will be obtained
	by ourselves.
	
	Arguments:
	None.
	
	Author:
	05-aug-1998 (t-rajkup)
	
	Creation History:
	The function aims at breaking nettest code away from ipconfig code.
	
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
InitIpconfig(IN NETDIAG_PARAMS *pParams,
			 IN OUT NETDIAG_RESULT *pResults)
{
	DWORD		dwError;
	ULONG		uSize = 0;
	int			i;
	HRESULT		hr = hrOK;
	LONG		cInterfaces;
	IP_ADAPTER_INFO	*	pIpAdapter;
	HINSTANCE	hDll;
	
	// Just initialize this once
	if (pResults->IpConfig.fInitIpconfigCalled == TRUE)
		return hrOK;
	
	// LoadLibrary the pfnGuidToFriendlyName
	// ----------------------------------------------------------------
	hDll = LoadLibrary(_T("netcfgx.dll"));
	if (hDll)
	{
		pfnGuidToFriendlyName = (PFNGUIDTOFRIENDLYNAME) GetProcAddress(hDll, "GuidToFriendlyName");
	}

	// Get the size of the FIXED_INFO structure and allocate
	// some memory for it.
	// ----------------------------------------------------------------
	GetNetworkParams(NULL, &uSize);
	pResults->IpConfig.pFixedInfo = Malloc(uSize);
	if (pResults->IpConfig.pFixedInfo == NULL)
		return E_OUTOFMEMORY;

	ZeroMemory(pResults->IpConfig.pFixedInfo, uSize);

	dwError = GetNetworkParams(pResults->IpConfig.pFixedInfo, &uSize);

	if (dwError != ERROR_SUCCESS)
	{
		TCHAR	szError[256];
		FormatWin32Error(dwError, szError, DimensionOf(szError));

		PrintMessage(pParams, IDS_GLOBAL_ERR_InitIpConfig,
					 szError, dwError);
		CheckErr( dwError );
	}
	

	// Get the per-interface information from IP
	// ----------------------------------------------------------------
	GetAdaptersInfo(NULL, &uSize);

	pResults->IpConfig.pAdapterInfoList = Malloc(uSize);
	if (pResults->IpConfig.pAdapterInfoList == NULL)
	{
		Free(pResults->IpConfig.pFixedInfo);
		CheckHr( E_OUTOFMEMORY );
	}

	ZeroMemory(pResults->IpConfig.pAdapterInfoList, uSize);

	dwError = GetAdaptersInfo(pResults->IpConfig.pAdapterInfoList, &uSize);

	if (dwError != ERROR_SUCCESS)
	{
		TCHAR	szError[256];
		FormatWin32Error(dwError, szError, DimensionOf(szError));

		PrintMessage(pParams, IDS_GLOBAL_ERR_GetAdaptersInfo,
					 szError, dwError);
		CheckErr( dwError );
	}

	   
	// Now that we have the full list, count the number of interfaces
	// and setup the per-interface section of the results structure.
	// ----------------------------------------------------------------
	cInterfaces = CountInterfaces(pResults->IpConfig.pAdapterInfoList);

	// Allocate some additional interfaces (just in case for IPX)
	// ----------------------------------------------------------------
	pResults->pArrayInterface = Malloc((cInterfaces+8) * sizeof(INTERFACE_RESULT));
	if (pResults->pArrayInterface == NULL)
		CheckHr( E_OUTOFMEMORY );
	ZeroMemory(pResults->pArrayInterface, (cInterfaces+8)*sizeof(INTERFACE_RESULT));

	// set the individual interface pointers
	// ----------------------------------------------------------------
	pResults->cNumInterfaces = cInterfaces;
	pResults->cNumInterfacesAllocated = cInterfaces + 8;
	pIpAdapter = pResults->IpConfig.pAdapterInfoList;
	for (i=0; i<cInterfaces; i++)
	{
		assert(pIpAdapter);
		pResults->pArrayInterface[i].IpConfig.pAdapterInfo = pIpAdapter;

		pResults->pArrayInterface[i].fActive = TRUE;
		pResults->pArrayInterface[i].IpConfig.fActive = TRUE;
		
		if( FLAG_DONT_SHOW_PPP_ADAPTERS &&
			(pIpAdapter->Type == IF_TYPE_PPP))
		{
			// NDIS Wan adapter... Check to see if it has got any address..
			
			if( ZERO_IP_ADDRESS(pIpAdapter->IpAddressList.IpAddress.String) )
			{
				//  No address ? Dont display this!
				pResults->pArrayInterface[i].IpConfig.fActive = FALSE;

				// If IP is not active, then don't activate the entire
				// adapter.  If IPX is active, then it can reactivate
				// the adapter.
				pResults->pArrayInterface[i].fActive = FALSE;
			}
		}

		pResults->pArrayInterface[i].pszName = StrDup(pIpAdapter->AdapterName);

		pResults->pArrayInterface[i].pszFriendlyName =
			StrDup( MapGuidToAdapterName(pIpAdapter->AdapterName) );

		pIpAdapter = pIpAdapter->Next;   
	}
	
	// Read the rest of the per adapter information not provided by
	// GetAdaptersInfo
	// ----------------------------------------------------------------
	CheckHr( GetAdditionalInfo(pParams, pResults) );


	pResults->IpConfig.fInitIpconfigCalled = TRUE;
	pResults->IpConfig.fEnabled = TRUE;

Error:
	if (!FHrSucceeded(hr))
	{
		pResults->IpConfig.fEnabled = FALSE;
		IpConfigCleanup(pParams, pResults);
	}
	return hr;
}


DWORD GetNetbiosOptions(LPSTR paszAdapterName, BOOL * pfNbtOptions)
{
	HANDLE h;
    OBJECT_ATTRIBUTES objAttr;
    IO_STATUS_BLOCK iosb;
    STRING name;
    UNICODE_STRING uname;
    NTSTATUS status;
	char path[MAX_PATH];
	tWINS_NODE_INFO NodeInfo;    

	strcpy(path, "\\Device\\NetBT_Tcpip_");
    strcat(path, paszAdapterName);

    RtlInitString(&name, path);
    RtlAnsiStringToUnicodeString(&uname, &name, TRUE);

    InitializeObjectAttributes(
        &objAttr,
        &uname,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        (PSECURITY_DESCRIPTOR)NULL
        );

    status = NtCreateFile(&h,
                          SYNCHRONIZE | GENERIC_EXECUTE,
                          &objAttr,
                          &iosb,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF,
                          0,
                          NULL,
                          0
                          );

    RtlFreeUnicodeString(&uname);

    if (!NT_SUCCESS(status)) {
        DEBUG_PRINT(("GetWinsServers: NtCreateFile(path=%s) failed, err=%d\n",
                     path, GetLastError() ));
        return FALSE;
    }

    status = NtDeviceIoControlFile(h,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &iosb,
                                   IOCTL_NETBT_GET_WINS_ADDR,
                                   NULL,
                                   0,
                                   (PVOID)&NodeInfo,
                                   sizeof(NodeInfo)
                                   );
    
    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(h, TRUE, NULL);
        if (NT_SUCCESS(status)) {
            status = iosb.Status;
        }
    }

    NtClose(h);

    if (!NT_SUCCESS(status)) {
        DEBUG_PRINT(("GetWinsServers: NtDeviceIoControlFile failed, err=%d\n",
                     GetLastError() ));

        return FALSE;
    }

	*pfNbtOptions = NodeInfo.NetbiosEnabled;

	return TRUE;
}

/*!--------------------------------------------------------------------------
	GetAdditionalInfo
	++
	Description:
	Read the information not provided by GetAdaptersInfo and also copy the data
	into the PADAPTER_INFO structure.
	
	Arguments:
	None.
	
	Author:
	05-Aug-1998 (t-rajkup)
	--
		
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT	GetAdditionalInfo(IN NETDIAG_PARAMS *pParams,
						  IN OUT NETDIAG_RESULT *pResults)
{
	PIP_ADAPTER_INFO pIpAdapterInfo;
	HKEY             key;
	char             dhcpServerAddress[4 * 4];
	BOOL             ok;
	ULONG            length;
	DWORD            DhcpClassIDLen;
	int				i;
	INTERFACE_RESULT	*pInterface = NULL;
	
	
	for (i=0; i<pResults->cNumInterfaces; i++)
	{
		pInterface = pResults->pArrayInterface + i;
		pIpAdapterInfo = pInterface->IpConfig.pAdapterInfo;
		assert(pIpAdapterInfo);
		
		if (pIpAdapterInfo->AdapterName[0] &&
			OpenAdapterKey(pIpAdapterInfo->AdapterName, &key) )
		{		  
			if( ! ReadRegistryDword(key,
									c_szRegIPAutoconfigurationEnabled,
									&(pInterface->IpConfig.fAutoconfigEnabled) ))
			{			  
				// AUTOCONFIG enabled if no regval exists for this...
				pInterface->IpConfig.fAutoconfigEnabled = TRUE;
			}                        
			
			if ( pInterface->IpConfig.fAutoconfigEnabled )
			{
				ReadRegistryDword(key,
								  c_szRegAddressType,
								  &(pInterface->IpConfig.fAutoconfigActive)
								 );
				
			}
			
			
			//
			// domain: first try Domain then DhcpDomain
			//
			
			length = sizeof(pInterface->IpConfig.szDomainName);
			ok = ReadRegistryOemString(key,
									   L"Domain",
									   pInterface->IpConfig.szDomainName,
									   &length
									  );
			
			if (!ok)
			{
				length = sizeof(pInterface->IpConfig.szDomainName);
				ok = ReadRegistryOemString(key,
										   L"DhcpDomain",
										   pInterface->IpConfig.szDomainName,
										   &length
										  );
			}
			
			// DNS Server list.. first try NameServer and then try
			// DhcpNameServer..
			
			ok = ReadRegistryIpAddrString(key,
										  c_szRegNameServer,
										  &(pInterface->IpConfig.DnsServerList)
										 );
			
			if (!ok) {
				ok = ReadRegistryIpAddrString(key,
											  c_szRegDhcpNameServer,
											  &(pInterface->IpConfig.DnsServerList)
											 );
				
			}
			
			
			//
			// Read the DHCP Class Id for this interface - Rajkumar
			//
			
			ZeroMemory(pInterface->IpConfig.szDhcpClassID,
					   sizeof(pInterface->IpConfig.szDhcpClassID));
			
			ReadRegistryString(key,
							   c_szRegDhcpClassID,
							   pInterface->IpConfig.szDhcpClassID,
							   &DhcpClassIDLen
							  );
			
			RegCloseKey(key);
			
			//
			// before getting the WINS info we must set the NodeType
			//
			pInterface->IpConfig.uNodeType = pResults->IpConfig.pFixedInfo->NodeType;
		}
		else
		{
			// IDS_IPCFG_10003  "Opening registry key for %s failed!\n" 
			PrintMessage(pParams, IDS_IPCFG_10003,pIpAdapterInfo->AdapterName);
			return S_FALSE;
		} 	  

		//be default, NetBt is enabled
		pInterface->fNbtEnabled = TRUE; 
		GetNetbiosOptions(pIpAdapterInfo->AdapterName, &pInterface->fNbtEnabled);

		if (pInterface->fNbtEnabled)
		{
			pResults->Global.fHasNbtEnabledInterface = TRUE;
		}
	}
	
	return TRUE; 
}


/*!--------------------------------------------------------------------------
	IpConfigGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpConfigGlobalPrint(IN NETDIAG_PARAMS *pParams,
						 IN OUT NETDIAG_RESULT *pResults)
{
	PFIXED_INFO		pFixedInfo = pResults->IpConfig.pFixedInfo;

	if (pParams->fReallyVerbose)
	{
		PrintNewLine(pParams, 2);

		// IDS_IPCFG_10005 "IP General configuration \n" 
		// IDS_IPCFG_10006 "    LMHOSTS Enabled :" 
		PrintMessage(pParams, IDS_IPCFG_10005);
		PrintMessage(pParams, IDS_IPCFG_10006);
		
		if (pResults->Global.dwLMHostsEnabled) 
			PrintMessage(pParams, IDS_GLOBAL_YES_NL);
		else
			PrintMessage(pParams, IDS_GLOBAL_NO_NL);
		
		// IDS_IPCFG_10009 "    DNS for WINS resolution:" 
		PrintMessage(pParams, IDS_IPCFG_10009);
		if (pResults->Global.dwDnsForWINS)
			PrintMessage(pParams, IDS_GLOBAL_ENABLED_NL);
		else
			PrintMessage(pParams, IDS_GLOBAL_DISABLED_NL); 

		// NBT node type
        // ------------------------------------------------------------
        PrintMessage(pParams, IDSSZ_IPCFG_NODETYPE,
					 MapWinsNodeType(pFixedInfo->NodeType));
        
        // NBT scope id
        // ------------------------------------------------------------
        PrintMessage(pParams, IDSSZ_IPCFG_NBTSCOPEID,
					 MapScopeId(pFixedInfo->ScopeId));

        // ip routing
        // ------------------------------------------------------------
        PrintMessage(pParams, IDSSZ_IPCFG_RoutingEnabled,
					 MAP_YES_NO(pFixedInfo->EnableRouting));

        // WINS proxy
        // ------------------------------------------------------------
        PrintMessage(pParams, IDSSZ_IPCFG_WinsProxyEnabled,
					 MAP_YES_NO(pFixedInfo->EnableProxy));

        // DNS resolution for apps using NetBIOS
        // ------------------------------------------------------------
        PrintMessage(pParams, IDSSZ_IPCFG_DnsForNetBios,
                       MAP_YES_NO(pFixedInfo->EnableDns));

        // separate fixed and adapter information with an empty line
        // ------------------------------------------------------------
        PrintMessage(pParams, IDS_GLOBAL_EmptyLine);
    }

}


/*!--------------------------------------------------------------------------
	IpConfigPerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpConfigPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
							   IN NETDIAG_RESULT *pResults,
							   IN INTERFACE_RESULT *pInterfaceResults)
{
   PIP_ADDR_STRING dnsServer;
   PFIXED_INFO		pFixedInfo = pResults->IpConfig.pFixedInfo;
   IP_ADAPTER_INFO*	pIpAdapterInfo;
   PIP_ADDR_STRING ipAddr;
   IPCONFIG_TST *	pIpCfgResults;
   ULONG			uDefGateway, uAddress, uMask;
   DWORD			dwDefGateway, dwAddress, dwMask;
   int				ids;
		
   pIpAdapterInfo = pInterfaceResults->IpConfig.pAdapterInfo;
   
   pIpCfgResults = &(pInterfaceResults->IpConfig);

   if (!pIpCfgResults->fActive)
	   return;

   PrintNewLine(pParams, 1);
   if(pParams->fReallyVerbose)
   {
	   // IDS_IPCFG_10012 "        Adapter type :   %s\n" 
	   PrintMessage(pParams, IDS_IPCFG_10012,
			  MapAdapterType(pIpAdapterInfo->Type));
   }
	
   PrintMessage(pParams, IDSSZ_IPCFG_HostName, 
					pFixedInfo->HostName,
					pIpCfgResults->szDomainName[0] ? _T(".") : _T(""),
					pIpCfgResults->szDomainName[0] ?
					pIpCfgResults->szDomainName : _T(""));
   
	   
	   
      // return;
   
   if (pParams->fReallyVerbose)
   {
	   
	   // IDS_IPCFG_10014 "        Description                : %s\n" 
	   PrintMessage(pParams, IDS_IPCFG_10014, pIpAdapterInfo->Description );
	   
	   if (pIpAdapterInfo->AddressLength)
	   {		   
		   char buffer[MAX_ADAPTER_ADDRESS_LENGTH * sizeof(_T("02-"))];
		   
		   // IDS_IPCFG_10015 "        Physical Address           : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10015,
						MapAdapterAddress(pIpAdapterInfo, buffer));
	   }
	   
	   // IDS_IPCFG_10016 "        Dhcp Enabled               : %s\n" 
	   PrintMessage(pParams, IDS_IPCFG_10016,
			  MAP_YES_NO(pIpAdapterInfo->DhcpEnabled));
	   
	   
	   // IDS_IPCFG_10017 "        DHCP ClassID               : %s\n" 
	   PrintMessage(pParams, IDS_IPCFG_10017, pIpCfgResults->szDhcpClassID);
	   
	   // IDS_IPCFG_10018 "        Autoconfiguration Enabled  : %s\n" 
	   PrintMessage(pParams, IDS_IPCFG_10018,
					MAP_YES_NO(pIpCfgResults->fAutoconfigEnabled));
	   
   }
   
   //
   // the following 3 items are the only items displayed (per adapter) if
   // /all was NOT requested on the command line
   //
   
   for (ipAddr = &pIpAdapterInfo->IpAddressList;
		ipAddr;
		ipAddr = ipAddr->Next)
   {
	   
	   
	   if (pIpCfgResults->fAutoconfigActive)
		   // IDS_IPCFG_10019  "        Autoconfiguration IP Address : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10019,ipAddr->IpAddress.String);
	   else
		   // IDS_IPCFG_10020  "        IP Address                 : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10020,ipAddr->IpAddress.String);
	   	  	   
	   // IDS_IPCFG_10021 "        Subnet Mask                : %s\n" 
	   PrintMessage(pParams, IDS_IPCFG_10021, ipAddr->IpMask.String );
   }
   
   //
   // there will only be one default gateway
   //
   // IDS_IPCFG_10022 "        Default Gateway            : %s\n" 
   PrintMessage(pParams, IDS_IPCFG_10022,
				pIpAdapterInfo->GatewayList.IpAddress.String );
   
   if (pParams->fReallyVerbose)
   {   
	   if (pIpAdapterInfo->DhcpEnabled && FALSE == pIpCfgResults->fAutoconfigActive) {
		   
		   //
		   // there will only be 1 DHCP server (that we get info from)
		   //
		   
		   // IDS_IPCFG_10023 "        DHCP Server                : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10023,
				  pIpAdapterInfo->DhcpServer.IpAddress.String );
		   
	   }
   }
	   
   //
   // there is only 1 primary and 1 secondary WINS server
   //
	   
//   if (pParams->fReallyVerbose)
   {
	   if (pIpAdapterInfo->PrimaryWinsServer.IpAddress.String[0]
		   && !ZERO_IP_ADDRESS(pIpAdapterInfo->PrimaryWinsServer.IpAddress.String))
	   {
		   // IDS_IPCFG_10024 "        Primary WINS Server        : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10024,
				  pIpAdapterInfo->PrimaryWinsServer.IpAddress.String );
		   
	   }
	   
	   if (pIpAdapterInfo->SecondaryWinsServer.IpAddress.String[0]
		   && !ZERO_IP_ADDRESS(pIpAdapterInfo->SecondaryWinsServer.IpAddress.String)) {
		   // IDS_IPCFG_10025 "        Secondary WINS Server      : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10025,
				  pIpAdapterInfo->SecondaryWinsServer.IpAddress.String);
	   }

	   if (!pInterfaceResults->fNbtEnabled)
	   {
		   //IDS_IPCFG_NBT_DISABLED					"        NetBIOS over Tcpip . . . . : Disabled\n" 
		   PrintMessage(pParams, IDS_IPCFG_NBT_DISABLED);
	   }
   }

   //
   // only display lease times if this adapter is DHCP enabled and we
   // have a non-0 IP address and not using autoconfigured address..
   //
   
   if (pParams->fReallyVerbose) {
	   
	   if (pIpAdapterInfo->DhcpEnabled
		   && !ZERO_IP_ADDRESS(pIpAdapterInfo->IpAddressList.IpAddress.String)
		   && !pIpCfgResults->fAutoconfigActive) {
		   
		   // IDS_IPCFG_10026 "        Lease Obtained             : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10026 ,
				  MapTime(pIpAdapterInfo->LeaseObtained) );
		   
		   // IDS_IPCFG_10027 "        Lease Expires              : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10027,
				  MapTime(pIpAdapterInfo->LeaseExpires) );
	   }	
	   
   }

      //
   // display the list of DNS servers. If the list came from SYSTEM.INI then
   // just display that, else if the list came from DHCP.BIN, get all DNS
   // servers for all NICs and display the compressed list
   //
   
   PrintMessage(pParams, IDS_IPCFG_DnsServers);
   if (pIpCfgResults->DnsServerList.IpAddress.String[0])
   {
	   dnsServer = &pIpCfgResults->DnsServerList;

	   // print out the first one
	   PrintMessage(pParams, IDSSZ_GLOBAL_StringLine,
					dnsServer->IpAddress.String);

	   dnsServer = dnsServer->Next;
	   for ( ;
			dnsServer;
			dnsServer = dnsServer->Next)
	   {
		   // IDS_IPCFG_10013  "                             " 
		   PrintMessage(pParams, IDS_IPCFG_10013);     
		   PrintMessage(pParams, IDSSZ_GLOBAL_StringLine, dnsServer->IpAddress.String);
	   }
   }
   


   PrintNewLine(pParams, 1);

   // If this is a verbose output, or if an error occurred with
   // any of the tests then we will need a header
   // -----------------------------------------------------------------
   if (pParams->fReallyVerbose || !FHrOK(pIpCfgResults->hr))
   {
	   // IDS_IPCFG_10029 "        IpConfig results : " 
	   PrintMessage(pParams, IDS_IPCFG_10029);
	   if (FHrOK(pIpCfgResults->hr))
		   ids = IDS_GLOBAL_PASS_NL;
	   else
		   ids = IDS_GLOBAL_FAIL_NL;
	   PrintMessage(pParams, ids);
   }
   
   //
   // Ping the dhcp server
   //
   PrintNdMessage(pParams, &pInterfaceResults->IpConfig.msgPingDhcpServer);
   
   //
   // Ping the WINS servers
   //
   PrintNdMessage(pParams, &pInterfaceResults->IpConfig.msgPingPrimaryWinsServer);
   PrintNdMessage(pParams, &pInterfaceResults->IpConfig.msgPingSecondaryWinsServer);

   //
   // Test to see if the gateway is on the same subnet as our IP address
   //
   if (!FHrOK(pInterfaceResults->IpConfig.hrDefGwSubnetCheck))
   {
	   PrintNewLine(pParams, 1);
	   if (pIpAdapterInfo->DhcpEnabled)
		   PrintMessage(pParams, IDS_IPCFG_WARNING_BOGUS_SUBNET_DHCP);
	   else
		   PrintMessage(pParams, IDS_IPCFG_WARNING_BOGUS_SUBNET);
   }
   
      
   //
   // if there's more to come, separate lists with empty line
   //
   PrintNewLine(pParams, 1);
}


/*!--------------------------------------------------------------------------
	ZERO_IP_ADDRESS
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL ZERO_IP_ADDRESS(LPCTSTR pszIp)
{
	return (pszIp == NULL) ||
			(*pszIp == 0) ||
			(strcmp(pszIp, _T("0.0.0.0")) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\ipsec.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 2000
//
//  Module Name:
//
//      ipsec.c
//
//  Abstract:
//
//      IP Security stats for netdiag
//
//  Author:
//
//      DKalin  - 8/3/1999
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//      Changed behavior for Whistler - now we report registry/OU settings only
//        More specific code moved to net\ipsec\nshipsec tool
//--

#include "precomp.h"
#include "spdcheck.h"

#include <snmp.h>
#include "tcpinfo.h"
#include "ipinfo.h"
#include "llinfo.h"

#include <windows.h>
#include <winsock2.h>
#include <ipexport.h>
#include <icmpapi.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <wincrypt.h>
#include <stdio.h>
#include <objbase.h>
#include <dsgetdc.h>
#include <lm.h>
#include <userenv.h>

#define  STRING_TEXT_SIZE 4096
#define  NETDIAG_TEXT_LIMIT 3072

// magic strings
#define IPSEC_SERVICE_NAME TEXT("policyagent")
#define GPEXT_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions")
TCHAR   pcszGPTIPSecKey[]    = TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\IPSEC\\GPTIPSECPolicy");
TCHAR   pcszGPTIPSecName[]   = TEXT("DSIPSECPolicyName");
TCHAR   pcszGPTIPSecFlags[]  = TEXT("DSIPSECPolicyFlags");
TCHAR   pcszGPTIPSecPath[]   = TEXT("DSIPSECPolicyPath");
TCHAR   pcszLocIPSecKey[]    = TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\IPSEC\\Policy\\Local");
TCHAR   pcszLocIPSecPol[]    = TEXT("ActivePolicy");
TCHAR   pcszCacheIPSecKey[]  = TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\IPSEC\\Policy\\Cache");
TCHAR   pcszIPSecPolicy[]    = TEXT("ipsecPolicy");
TCHAR   pcszIPSecName[]      = TEXT("ipsecName");
TCHAR   pcszIPSecDesc[]      = TEXT("description");
TCHAR   pcszIPSecTimestamp[] = TEXT("whenChanged");
TCHAR   pcszIPSecID[] = TEXT("ipsecID");

typedef struct
{
	SERVICE_STATUS       servStat;    // service status
	QUERY_SERVICE_CONFIG servConfig;  // service configuration
} SERVICE_INFO, *PSERVICE_INFO;

typedef struct
{
	TCHAR   pszComputerOU[MAXSTRLEN]; // this computer' OU name
	PGROUP_POLICY_OBJECT pGPO;        // GPO that is assigning IPSec Policy
	TCHAR   pszPolicyOU  [MAXSTRLEN]; // OU that has the GPO assigned
} DS_POLICY_INFO, *PDS_POLICY_INFO;
 
DWORD MyFormatMessage ( DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId,
  LPTSTR lpBuffer, DWORD nSize, va_list *Arguments );

//void reportError ( DWORD hr, NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults );
void reportServiceInfo ( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults );
DWORD getPolicyInfo ( );
DWORD getMorePolicyInfo (NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults );
DWORD getServiceInfo ( PSERVICE_INFO pInfo );
PGROUP_POLICY_OBJECT getIPSecGPO ( );
void StringToGuid( TCHAR * szValue, GUID * pGuid );

BOOL bTestSkipped = FALSE;
BOOL bTestPassed = FALSE;
SERVICE_INFO   siIPSecStatus;
DS_POLICY_INFO dpiAssignedPolicy;
TCHAR   pszBuf[STRING_TEXT_SIZE];
WCHAR  StringTxt[STRING_TEXT_SIZE];

BOOL
IPSecTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//++
//  Description:
//      This is IPSec test
// 
//  Arguments:
//      None.
//
//  Author:
//      DKalin 08/03/99
//--
{

	DWORD dwError = ERROR_SUCCESS;
	BOOL bRet = S_OK;	
	PGROUP_POLICY_OBJECT pGPO = NULL;
	PGROUP_POLICY_OBJECT pLastGPO = NULL;

    PrintStatusMessage( pParams, 4, IDS_IPSEC_STATUS_MSG );

    InitializeListHead(&pResults->IPSec.lmsgGlobalOutput);
    InitializeListHead(&pResults->IPSec.lmsgAdditOutput);


	/* Crippling netdiag support, as netsh should take care of everything */

	// test skipped
	bTestSkipped = TRUE;
	
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
			IDS_IPSEC_NSHIPSEC );

	return S_OK;
	


	dwError = getServiceInfo(&siIPSecStatus);

	if (dwError != ERROR_SUCCESS || siIPSecStatus.servStat.dwCurrentState != SERVICE_RUNNING)
	{
		// test skipped
		bTestSkipped = TRUE;
        if (dwError == ERROR_SERVICE_DOES_NOT_EXIST)
		{
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_NOT_INSTALLED );
		}
		else if (dwError == ERROR_SUCCESS)
		{
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_NOT_STARTED );
			reportServiceInfo(pParams, pResults);
		}
		else
		{
			// some error
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_NO_INFO );
			reportError(dwError, pParams, pResults);
		}
		return S_OK;
	}
	else
	{
		// test passed
		bTestPassed = TRUE;

		reportServiceInfo(pParams, pResults);
    		dwError = getPolicyInfo();

		if (dwError != ERROR_SUCCESS)
		{
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_NO_POLICY_INFO );
			reportError(dwError, pParams, pResults);
		}
		else
		{
			switch (piAssignedPolicy.iPolicySource)
			{
			case PS_NO_POLICY:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_NO_POLICY );
				break;
			case PS_DS_POLICY:
				dwError = getMorePolicyInfo(pParams,pResults);
				if(dwError)
				{
					reportError(dwError, pParams, pResults);
					return S_OK;
				}
				pLastGPO = pGPO = getIPSecGPO();

				if (pGPO)
				{
					while ( 1 )
					{
						if ( pLastGPO->pNext )
							pLastGPO = pLastGPO->pNext;
						else
							break;
					}
				}

				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_DS_POLICY );
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_POLICY_NAME, piAssignedPolicy.pszPolicyName );

				// description and timestamp - not available yet
				/*
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_DESCRIPTION, piAssignedPolicy.pszPolicyDesc );
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_TIMESTAMP );
				if (piAssignedPolicy.timestamp == 0)
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDS_GLOBAL_ADAPTER_UNKNOWN);
				}
				else
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDSSZ_GLOBAL_String, _tctime(&(piAssignedPolicy.timestamp)));
				}
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_GLOBAL_EmptyLine);
				*/

				// GPO / OU
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_GPO);
				if (pLastGPO)
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDSSZ_GLOBAL_String, pLastGPO->lpDisplayName);
				}
				else
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDS_GLOBAL_ADAPTER_UNKNOWN);
				}
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_GLOBAL_EmptyLine);
                
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_OU);
				if (pLastGPO)
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDSSZ_GLOBAL_String, pLastGPO->lpLink);
				}
				else
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDS_GLOBAL_ADAPTER_UNKNOWN);
				}
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_GLOBAL_EmptyLine);

				// policy path
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_POLICY_PATH);
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDSSZ_GLOBAL_StringLine, piAssignedPolicy.pszPolicyPath);
				
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_GLOBAL_EmptyLine, piAssignedPolicy.pszPolicyPath);				
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_SPD_STATUS, piAssignedPolicy.pszPolicyPath);

                // Don't do the SPDCheckTEST as per bug XP 504035.
                // SPD will audit errors on policy read/process/apply now anyway.
                //
				// bRet = SPDCheckTEST(pParams,pResults);		

				// cleanup GPO
				if (pGPO)
				{
					FreeGPOList (pGPO);
				}

				
				
				break;
			case PS_LOC_POLICY:
				dwError = getMorePolicyInfo(pParams,pResults);
				if(dwError)
				{
					reportError(dwError, pParams, pResults);
					return S_OK;
				}
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_LOC_POLICY );
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_POLICY_NAME, piAssignedPolicy.pszPolicyName );

				// description and timestamp
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_DESCRIPTION, piAssignedPolicy.pszPolicyDesc );
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_TIMESTAMP );
				if (piAssignedPolicy.timestamp == 0)
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDS_GLOBAL_ADAPTER_UNKNOWN);
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDS_GLOBAL_EmptyLine);
				}
				else
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDSSZ_GLOBAL_String, _tctime(&(piAssignedPolicy.timestamp)));
				}

				// local policy path
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_POLICY_PATH);
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_LOCAL_PATH, piAssignedPolicy.pszPolicyPath);
				

				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_GLOBAL_EmptyLine, piAssignedPolicy.pszPolicyPath);
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_SPD_STATUS, piAssignedPolicy.pszPolicyPath);


                // Don't do the SPDCheckTEST as per bug XP 504035.
                // SPD will audit errors on policy read/process/apply now anyway.
                //
				// bRet = SPDCheckTEST(pParams,pResults);
				
				break;
			}
		}
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
				IDS_IPSEC_NSHIPSEC );
	}

    return bRet;
}

void IPSecGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
	PrintMessage(pParams, IDS_GLOBAL_EmptyLine);
	if (bTestSkipped)
	{
		PrintTestTitleResult(pParams, IDS_IPSEC_LONG, IDS_IPSEC_SHORT, FALSE, S_FALSE, 0);
	}
	if (bTestPassed)
	{
        PrintTestTitleResult(pParams, IDS_IPSEC_LONG, IDS_IPSEC_SHORT, TRUE, S_OK, 0);
	}
    PrintMessageList(pParams, &pResults->IPSec.lmsgGlobalOutput);
    PrintMessageList(pParams, &pResults->IPSec.lmsgAdditOutput);
}


void IPSecPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
       return;
}


void IPSecCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->IPSec.lmsgGlobalOutput);
    MessageListCleanUp(&pResults->IPSec.lmsgAdditOutput);
}

//#define MSG_HANDLE_INVALID TEXT("Handle is invalid. Is IPSEC Policy Agent Service running?")

// this will call SDK' FormatMessage function but will also correct some awkward messages
// will work only for FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM flag combination
DWORD MyFormatMessage(
  DWORD dwFlags,      // source and processing options
  LPCVOID lpSource,   // pointer to  message source
  DWORD dwMessageId,  // requested message identifier
  DWORD dwLanguageId, // language identifier for requested message
  LPTSTR lpBuffer,    // pointer to message buffer
  DWORD nSize,        // maximum size of message buffer
  va_list *Arguments  // pointer to array of message inserts
)
{
	LPTSTR* tmp = (LPTSTR*) lpBuffer;

	switch (dwMessageId)
	{
/*	case ERROR_INVALID_HANDLE: // patch for "handle is invalid" message. Suggest to check if service is started
		if (dwFlags == (FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM))
		{
			*tmp = (LPTSTR) malloc((_tcslen(MSG_HANDLE_INVALID)+1)*sizeof(TCHAR));
			_tcscpy(*tmp, MSG_HANDLE_INVALID);
			return _tcslen(*tmp);
		}
		else
		{
			return FormatMessage(dwFlags,lpSource,dwMessageId,dwLanguageId,lpBuffer,nSize,Arguments);
		}
*/	default: // call standard method
		return FormatMessage(dwFlags,lpSource,dwMessageId,dwLanguageId,lpBuffer,nSize,Arguments);
	}
}

/********************************************************************
	FUNCTION: getPolicyInfo

	PURPOSE:  gets information about currently assigned policy 
	          into piAssignedPolicy global structure
	INPUT:    none

	RETURNS:  DWORD. Will return ERROR_SUCCESS if everything is fine.
*********************************************************************/

DWORD getPolicyInfo ( )
{
	LONG    lRegistryCallResult;
	HKEY    hRegKey;

	DWORD   dwType;            // for RegQueryValueEx
	DWORD   dwBufLen;          // for RegQueryValueEx

	lRegistryCallResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
										pcszGPTIPSecKey,
										0,
										KEY_READ,
										&hRegKey);

	if (lRegistryCallResult == ERROR_SUCCESS)
	{
		DWORD dwType;
		DWORD dwValue;
		DWORD dwLength = sizeof(DWORD);

		// query for flags, if flags aint' there or equal to 0, we don't have domain policy
		lRegistryCallResult = RegQueryValueEx(hRegKey,
					                          pcszGPTIPSecFlags,
					                          NULL,
					                          &dwType,
					                          (LPBYTE)&dwValue,
					                          &dwLength);

		if (lRegistryCallResult == ERROR_SUCCESS)
		{
			if (dwValue == 0)
				lRegistryCallResult = ERROR_FILE_NOT_FOUND;
		}

		// now get name
		if (lRegistryCallResult == ERROR_SUCCESS)
		{
			dwBufLen = MAXSTRLEN*sizeof(TCHAR);
			lRegistryCallResult = RegQueryValueEx( hRegKey,
												   pcszGPTIPSecName,
												   NULL,
												   &dwType, // will be REG_SZ
												   (LPBYTE) pszBuf,
												   &dwBufLen);
		}
	}

	if (lRegistryCallResult == ERROR_SUCCESS)
	{
		piAssignedPolicy.iPolicySource = PS_DS_POLICY;
		piAssignedPolicy.pszPolicyPath[0] = 0;
		_tcscpy(piAssignedPolicy.pszPolicyName, pszBuf);

		dwBufLen = MAXSTRLEN*sizeof(TCHAR);
		lRegistryCallResult = RegQueryValueEx( hRegKey,
											   pcszGPTIPSecPath,
											   NULL,
											   &dwType, // will be REG_SZ
											   (LPBYTE) pszBuf,
											   &dwBufLen);
		if (lRegistryCallResult == ERROR_SUCCESS)
		{
			_tcscpy(piAssignedPolicy.pszPolicyPath, pszBuf);
		}

		RegCloseKey(hRegKey);
		return ERROR_SUCCESS;
	}
	else
	{
		RegCloseKey(hRegKey);
		if (lRegistryCallResult == ERROR_FILE_NOT_FOUND)
		{   // DS reg key not found, check local
			lRegistryCallResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
												pcszLocIPSecKey,
												0,
												KEY_READ,
												&hRegKey);
			if (lRegistryCallResult == ERROR_SUCCESS)
			{
				dwBufLen = MAXSTRLEN*sizeof(TCHAR);
				lRegistryCallResult = RegQueryValueEx( hRegKey,
													   pcszLocIPSecPol,
													   NULL,
													   &dwType, // will be REG_SZ
													   (LPBYTE) pszBuf,
													   &dwBufLen);
			}
			else
			{
				return lRegistryCallResult; // return whatever error we got
			}

			RegCloseKey(hRegKey);

			if (lRegistryCallResult == ERROR_FILE_NOT_FOUND)
			{	// no policy assigned
				piAssignedPolicy.iPolicySource = PS_NO_POLICY;
				piAssignedPolicy.pszPolicyPath[0] = 0;
				piAssignedPolicy.pszPolicyName[0] = 0;
				return ERROR_SUCCESS;
			}
			else
			{	// read it
				lRegistryCallResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
													pszBuf,
													0,
													KEY_READ,
													&hRegKey);
				_tcscpy(piAssignedPolicy.pszPolicyPath, pszBuf);
				if (lRegistryCallResult == ERROR_SUCCESS)
				{
					dwBufLen = MAXSTRLEN*sizeof(TCHAR);
					lRegistryCallResult = RegQueryValueEx( hRegKey,
														   pcszIPSecName,
														   NULL,
														   &dwType, // will be REG_SZ
														   (LPBYTE) pszBuf,
														   &dwBufLen);
				}

				RegCloseKey(hRegKey);

				if (lRegistryCallResult == ERROR_FILE_NOT_FOUND)
					{	// no policy assigned
						piAssignedPolicy.iPolicySource = PS_NO_POLICY;
						piAssignedPolicy.pszPolicyPath[0] = 0;
						return ERROR_SUCCESS;
					}
				else if (lRegistryCallResult == ERROR_SUCCESS)
				{	// found it
					piAssignedPolicy.iPolicySource = PS_LOC_POLICY;
					_tcscpy(piAssignedPolicy.pszPolicyName, pszBuf);
				}
			}
		}
		return (DWORD) lRegistryCallResult;
	}
}

/********************************************************************
	FUNCTION: getServiceInfo

	PURPOSE:  gets information about current state and configuration of IPSec Service 
	          into *pInfo structure
	INPUT:    pInfo - pointer to SERVICE_INFO structure which will be updated with current information
	TODO:	  

	RETURNS:  Win32 error codes. Will return ERROR_SUCCESS if everything is fine.
	          ERROR_SERVICE_DOES_NOT_EXIST is returned is service is not installed on the system
*********************************************************************/

DWORD getServiceInfo ( OUT PSERVICE_INFO pInfo )
{
	DWORD dwError = ERROR_SUCCESS;
	DWORD dwRequiredSize = 0;
	PVOID pLargeConfig = 0;
    SC_HANDLE   schMan = NULL;
    SC_HANDLE   schPA = NULL;

	if (!pInfo)
	{
		return ERROR_INVALID_PARAMETER;
	}

   memset(&(pInfo->servStat), 0, sizeof(SERVICE_STATUS));
   memset(&(pInfo->servConfig), 0, sizeof(QUERY_SERVICE_CONFIG));

	   
   schMan = OpenSCManager(NULL, NULL, GENERIC_READ);

   if (schMan == NULL)
   {
	   dwError = GetLastError();
	   goto error;
   }

   schPA = OpenService(schMan, IPSEC_SERVICE_NAME, GENERIC_READ);

   if (schMan == NULL)
   {
      dwError = GetLastError();
      goto error;
   }
   
   if (!QueryServiceStatus(schPA, &(pInfo->servStat)))
   {
      dwError = GetLastError();
      goto error;
   }
   
   if (!QueryServiceConfig(schPA, &(pInfo->servConfig), sizeof(QUERY_SERVICE_CONFIG), &dwRequiredSize))
   {
      dwError = GetLastError();
	  if (dwError == ERROR_INSUFFICIENT_BUFFER)
	  {
		  pLargeConfig = malloc(dwRequiredSize);
		  if (!pLargeConfig)
		  {
			  goto error;
		  }
          if (!QueryServiceConfig(schPA, (LPQUERY_SERVICE_CONFIG) pLargeConfig, dwRequiredSize, &dwRequiredSize))
		  {
		      dwError = GetLastError();
			  goto error;
		  }
		  // else we just got the information, copy over to *pInfo
		  memcpy(&(pInfo->servConfig), pLargeConfig, sizeof(QUERY_SERVICE_CONFIG));
		  dwError = ERROR_SUCCESS;
	  }

      goto error;
   }

error:
    if (schPA)
		CloseServiceHandle(schPA);
	if (schMan)
		CloseServiceHandle(schMan);
	if (pLargeConfig)
	{
		free(pLargeConfig);
	}
	return dwError;
}

/********************************************************************
	FUNCTION: reportError

	PURPOSE:  prints out message code and message itself
	INPUT: DWORD - error code

	RETURNS: none
*********************************************************************/

void reportError ( DWORD dwError, NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults )
{
	LPTSTR msg = NULL;

	MyFormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,  
		NULL, dwError, 0, (LPTSTR) &msg,    0,    NULL );
		
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
				IDS_IPSEC_ERROR_MSG, dwError, msg );
}

/********************************************************************
	FUNCTION: reportServiceInfo

	PURPOSE:  prints out service status and startup information
	INPUT: none

	RETURNS: none
*********************************************************************/
void reportServiceInfo ( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults )
{
	// print status information
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
			IDS_IPSEC_PA_STATUS );
	switch (siIPSecStatus.servStat.dwCurrentState)
	{
		case SERVICE_RUNNING:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_STARTED );
			break;
		case SERVICE_STOPPED:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_STOPPED );
			break;
		case SERVICE_PAUSED:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_PAUSED );
			break;
		default:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_GLOBAL_ADAPTER_UNKNOWN);
			break;
	}
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
			IDS_GLOBAL_EmptyLine);

	// print config information
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
			IDS_IPSEC_PA_STARTUP );
	switch (siIPSecStatus.servConfig.dwStartType)
	{
		case SERVICE_AUTO_START:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_AUTOMATIC );
			break;
		case SERVICE_DEMAND_START:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_MANUAL );
			break;
		case SERVICE_DISABLED:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_DISABLED );
			break;
		default:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_GLOBAL_ADAPTER_UNKNOWN);
			break;
	}
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
			IDS_GLOBAL_EmptyLine);
}

/********************************************************************
	FUNCTION: getIPSecGPO

	PURPOSE:  returns GPO that is assigning IPSec Policy
	INPUT:    none

	RETURNS: pointer to GROUP_POLICY_OBJECT structure
	         NULL if policy is not assigned or if GPO information is not retrievable
	NOTES:   Tested only with domain GPOs
	         Behaves unpredictably when run for the computer 
			   that does not have active Directory IPSec policy assigned
			 CALLER is responsible for freeing the memory!
*********************************************************************/
PGROUP_POLICY_OBJECT getIPSecGPO ( )
{
    HKEY hKey, hSubKey;
    DWORD dwType, dwSize, dwIndex, dwNameSize;
    LONG lResult;
    TCHAR szName[50];
    GUID guid;
    PGROUP_POLICY_OBJECT pGPO, pGPOTemp;
	PGROUP_POLICY_OBJECT pGPOReturn = NULL;
	DWORD dwResult;

    //
    // Enumerate the extensions
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, GPEXT_KEY, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS)
    {

        dwIndex = 0;
        dwNameSize = 50;

        while ((dwResult = RegEnumKeyEx (hKey, dwIndex++, szName, &dwNameSize, NULL, NULL,
                          NULL, NULL)) == ERROR_SUCCESS)
        {

	        dwNameSize = 50;

            //
            // Skip the registry extension since we did it above
            //

            if (lstrcmpi(TEXT("{35378EAC-683F-11D2-A89A-00C04FBBCFA2}"), szName))
            {

                //
                // Get the list of GPOs this extension applied
                //

                StringToGuid(szName, &guid);

                lResult = GetAppliedGPOList (GPO_LIST_FLAG_MACHINE, NULL, NULL,
                                             &guid, &pGPO);

                if (lResult == ERROR_SUCCESS)
                {
                    if (pGPO)
                    {
                        //
                        // Get the extension's friendly display name
                        //

                        lResult = RegOpenKeyEx (hKey, szName, 0, KEY_READ, &hSubKey);

                        if (lResult == ERROR_SUCCESS)
                        {
							if (!lstrcmpi(TEXT("{e437bc1c-aa7d-11d2-a382-00c04f991e27}"), szName))
                            {
                               // found IPSec
								return pGPO;
                            }
							else
							{
								FreeGPOList(pGPO);
							}
						}
					}
				}
			}
		}
	}

	return pGPOReturn;
}

//*************************************************************
//
//  StringToGuid()
//
//  Purpose:    Converts a GUID in string format to a GUID structure
//
//  Parameters: szValue - guid in string format
//              pGuid   - guid structure receiving the guid
//
//
//  Return:     void
//
//*************************************************************

void StringToGuid( TCHAR * szValue, GUID * pGuid )
{
    TCHAR wc;
    INT i;

    //
    // If the first character is a '{', skip it
    //
    if ( szValue[0] == TEXT('{') )
        szValue++;

    //
    // Since szValue may be used again, no permanent modification to
    // it is be made.
    //

    wc = szValue[8];
    szValue[8] = 0;
    pGuid->Data1 = _tcstoul( &szValue[0], 0, 16 );
    szValue[8] = wc;
    wc = szValue[13];
    szValue[13] = 0;
    pGuid->Data2 = (USHORT)_tcstoul( &szValue[9], 0, 16 );
    szValue[13] = wc;
    wc = szValue[18];
    szValue[18] = 0;
    pGuid->Data3 = (USHORT)_tcstoul( &szValue[14], 0, 16 );
    szValue[18] = wc;

    wc = szValue[21];
    szValue[21] = 0;
    pGuid->Data4[0] = (unsigned char)_tcstoul( &szValue[19], 0, 16 );
    szValue[21] = wc;
    wc = szValue[23];
    szValue[23] = 0;
    pGuid->Data4[1] = (unsigned char)_tcstoul( &szValue[21], 0, 16 );
    szValue[23] = wc;

    for ( i = 0; i < 6; i++ )
    {
        wc = szValue[26+i*2];
        szValue[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)_tcstoul( &szValue[24+i*2], 0, 16 );
        szValue[26+i*2] = wc;
    }
}

/********************************************************************
	FUNCTION: getMorePolicyInfo

	PURPOSE:  gets additional information about currently assigned policy 
	          into piAssignedPolicy global structure
	INPUT:    none, uses global piAssignedPolicy structure
	          particularly
			    iPolicySource
				pszPolicyName
				pszPolicyPath
			  fields

	RETURNS:  DWORD. Will return ERROR_SUCCESS if everything is fine.
	          Currently fills pszPolicyDesc and timestamp fields of the global structure

    NOTES:    This is separate from getPolicyInfo routine for two reasons
	             a) the information obtained here is optional and error during this particular routine
				    is not considered fatal
				 b) the code structure is simpler as this routine is "built on top" of what getPolicyInfo provides
*********************************************************************/

DWORD getMorePolicyInfo ( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	DWORD   dwError = ERROR_SUCCESS;
	HKEY    hRegKey = NULL;

	DWORD   dwType;            // for RegQueryValueEx
	DWORD   dwBufLen;          // for RegQueryValueEx
	DWORD   dwValue;
	DWORD   dwLength = sizeof(DWORD);

	PTCHAR* ppszExplodeDN = NULL;

	// set some default values
    piAssignedPolicy.pszPolicyDesc[0] = 0;
	piAssignedPolicy.timestamp  = 0;

	switch (piAssignedPolicy.iPolicySource)
	{
		case PS_LOC_POLICY:
			// open the key
			dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
									piAssignedPolicy.pszPolicyPath,
									0,
									KEY_READ,
									&hRegKey);
			BAIL_ON_WIN32_ERROR(dwError);

			// timestamp
			dwError = RegQueryValueEx(hRegKey,
					                  pcszIPSecTimestamp,
					                  NULL,
					                  &dwType,
					                  (LPBYTE)&dwValue,
					                  &dwLength);
			BAIL_ON_WIN32_ERROR(dwError);
			piAssignedPolicy.timestamp = dwValue;

			// description
			dwBufLen = MAXSTRLEN*sizeof(TCHAR);
			dwError  = RegQueryValueEx( hRegKey,
						 			   pcszIPSecDesc,
									   NULL,
									   &dwType, // will be REG_SZ
									   (LPBYTE) pszBuf,
									   &dwBufLen);
			BAIL_ON_WIN32_ERROR(dwError);
			_tcscpy(piAssignedPolicy.pszPolicyDesc, pszBuf);

			// policy guid
			dwBufLen = MAXSTRLEN*sizeof(TCHAR);
							
			dwError = RegQueryValueEx(hRegKey,
					                 		 pcszIPSecID,
					                  		NULL,
					                  		&dwType,
					                  		(LPBYTE) pszBuf,
					                  		&dwBufLen);
			BAIL_ON_WIN32_ERROR(dwError);		
			StringToGuid(pszBuf, &piAssignedPolicy.policyGUID);
			
			break;

		case PS_DS_POLICY:
			// get the policy name from DN
            _tcscpy(pszBuf, pcszCacheIPSecKey);
			ppszExplodeDN = ldap_explode_dn(piAssignedPolicy.pszPolicyPath, 1);
			if (!ppszExplodeDN)
			{
				goto error;
			}
			_tcscat(pszBuf, TEXT("\\"));
			_tcscat(pszBuf, ppszExplodeDN[0]);

			// open the regkey
			dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
									pszBuf,
									0,
									KEY_READ,
									&hRegKey);
			BAIL_ON_WIN32_ERROR(dwError);

			/* - tomestamp and description are not available yet
			// timestamp
			dwError = RegQueryValueEx(hRegKey,
					                  pcszIPSecTimestamp,
					                  NULL,
					                  &dwType,
					                  (LPBYTE)&dwValue,
					                  &dwLength);
			BAIL_ON_WIN32_ERROR(dwError);
			piAssignedPolicy.timestamp = dwValue;

			// description
			dwBufLen = MAXSTRLEN*sizeof(TCHAR);
			dwError  = RegQueryValueEx( hRegKey,
						 			    pcszIPSecDesc,
										NULL,
										&dwType, // will be REG_SZ
										(LPBYTE) pszBuf,
										&dwBufLen);
			BAIL_ON_WIN32_ERROR(dwError);
			_tcscpy(piAssignedPolicy.pszPolicyDesc, pszBuf);
			*/

			//get policy guid
			dwBufLen = MAXSTRLEN*sizeof(TCHAR);
			dwError = RegQueryValueEx(hRegKey,
					                 		 pcszIPSecID,
					                  		NULL,
					                  		&dwType,
					                  		(LPBYTE) pszBuf,
					                  		&dwBufLen);
			BAIL_ON_WIN32_ERROR(dwError);
			StringToGuid(pszBuf, &piAssignedPolicy.policyGUID);			

			break;
	}

error:
	if (hRegKey)
	{
		RegCloseKey(hRegKey);
	}
	if (ppszExplodeDN)
	{
		ldap_value_free(ppszExplodeDN);
	}
	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    makefile.inc.

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\machine.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       machine.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_MACHINE
#define HEADER_MACHINE


HRESULT	GetMachineSpecificInfo(IN NETDIAG_PARAMS *pParams,
							   IN OUT NETDIAG_RESULT *pResults);

void DoSystemPrint(IN NETDIAG_PARAMS *pParams, IN NETDIAG_RESULT *pResults);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\ldaptest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      ldaptest.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "malloc.h"

BOOL TestLdapOnDc(IN PTESTED_DC TestedDc, NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults);
DWORD TestSpnOnDC(IN PTESTED_DC pDcInfo, NETDIAG_RESULT*  pResults);

HRESULT LDAPTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    HRESULT     hr = S_OK;

    BOOL RetVal = TRUE;
    PTESTED_DOMAIN TestedDomain = pParams->pDomain;
    PTESTED_DC TestedDc = NULL;
    PLIST_ENTRY ListEntry;
    BOOLEAN OneLdapFailed = FALSE;
    BOOLEAN OneLdapWorked = FALSE;
    BOOL fSpnTested = FALSE;
    BOOL fSpnPassed = FALSE;

    NET_API_STATUS NetStatus;

    //if the machine is a member machine or DC, LDAP Test will get called. 
    //Otherwise, the test will be skipped
    pResults->LDAP.fPerformed = TRUE;

    // assume link entry is initialized to 0000
    if(pResults->LDAP.lmsgOutput.Flink == NULL)
        InitializeListHead(&pResults->LDAP.lmsgOutput);

    PrintStatusMessage(pParams, 4, IDS_LDAP_STATUS_MSG, TestedDomain->PrintableDomainName);

    //
    // If a DC hasn't been discovered yet,
    //  find one.
    //

    if ( TestedDomain->DcInfo == NULL ) 
    {
        LPTSTR pszDcType;

        if ( TestedDomain->fTriedToFindDcInfo ) 
        {
            CHK_HR_CONTEXT(pResults->LDAP, S_FALSE, IDS_LDAP_NODC);
        }

        pszDcType = LoadAndAllocString(IDS_DCTYPE_DC);
        NetStatus = DoDsGetDcName( pParams,
                                   pResults,
                                   &pResults->LDAP.lmsgOutput,
                                   TestedDomain,
                                   DS_DIRECTORY_SERVICE_PREFERRED,
                                   "DC",
                                   FALSE,
                                   &TestedDomain->DcInfo );
        Free(pszDcType);

        TestedDomain->fTriedToFindDcInfo = TRUE;

        if ( NetStatus != NO_ERROR ) 
        {
            CHK_HR_CONTEXT(pResults->LDAP, hr = HRESULT_FROM_WIN32(NetStatus), IDS_LDAP_NODC);
        }
    }



    //
    // Ensure the DC is running the Ds.
    //

    if ( (TestedDomain->DcInfo->Flags & DS_DS_FLAG) == 0 ) 
    {
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, IDS_LDAP_NOTRUNNINGDS, 
                          TestedDomain->DcInfo->DomainControllerName);
    }

    //
    // Test ldap on all of the found DCs in the domain.
    //

    for ( ListEntry = TestedDomain->TestedDcs.Flink ;
          ListEntry != &TestedDomain->TestedDcs ;
          ListEntry = ListEntry->Flink ) {


        //
        // Loop through the list of DCs in this domain
        //

        TestedDc = CONTAINING_RECORD( ListEntry, TESTED_DC, Next );

        //
        // Only run test on DCs that might support LDAP.
        //

        if ( TestedDc->Flags & DC_IS_NT5 ) 
        {
            if ( !TestLdapOnDc( TestedDc, pParams, pResults ) ) 
                OneLdapFailed = TRUE;
            else
                OneLdapWorked = TRUE;

            //test the SPN registration if this is a DC on the primary domain
            if (TestedDomain->fPrimaryDomain)
            {
                fSpnTested = TRUE;
                if (TestSpnOnDC(TestedDc, pResults))
                    fSpnPassed = TRUE;
            }
        } 
        else 
        {
            AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                        IDS_LDAP_NOTRUNNINGDS_SKIP, TestedDc->ComputerName);
        }

    }

    //
    // If one of the DCs failed,
    //  and none worked.
    //  Don't do any more tests.
    //
    if ( OneLdapFailed  && !OneLdapWorked ) 
    {
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                    IDS_LDAP_NOLDAPSERVERSWORK, TestedDomain->PrintableDomainName);
        
        CHK_HR_CONTEXT(pResults->LDAP, hr = E_FAIL, 0);
    }

    if ( fSpnTested && !fSpnPassed )
    {
        //IDS_LDAP_NO_SPN                       "    [FATAL] The default SPNs are not properly registered on and DCs.\n"
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                    IDS_LDAP_NO_SPN);
        CHK_HR_CONTEXT(pResults->LDAP, hr = E_FAIL, 0);
    }

L_ERR:

    //$REVIEW (nsun) we should return S_FALSE or S_OK 
    //so that we can go on with other tests
    if (!FHrOK(hr))
        hr = S_FALSE;
    return hr;
} 

DWORD TestSpnOnDC(IN PTESTED_DC pDcInfo, NETDIAG_RESULT*  pResults)
{
    WCHAR FlatName[ MAX_PATH + 1 ];
    PWSTR Dot ;
    HANDLE hDs = NULL;
    ULONG NetStatus ;
    PDS_NAME_RESULTW Result ;
    LPWSTR Flat = FlatName;
    LDAP *ld = NULL;
    int rc;
    LDAPMessage *e, *res = NULL;
    WCHAR *base_dn;
    WCHAR *search_dn, search_ava[ MAX_PATH + 30 ];
    WCHAR Domain[ MAX_PATH + 1 ];
    CHAR szDefaultFqdnSpn[MAX_PATH + 10];
    CHAR szDefaultShortSpn[MAX_PATH + 10];
    BOOL fFqdnSpnFound = FALSE;
    BOOL fShortSpnFound = FALSE;
    BOOL fFailQuerySpn = FALSE;
    
    USES_CONVERSION;

    //construct the default SPN's
    lstrcpy(szDefaultFqdnSpn, _T("HOST/"));
    lstrcat(szDefaultFqdnSpn, pResults->Global.szDnsHostName);
    lstrcpy(szDefaultShortSpn, _T("HOST/"));
    lstrcat(szDefaultShortSpn, W2T(pResults->Global.swzNetBiosName));

    wcscpy(Domain, GetSafeStringW(pDcInfo->TestedDomain->NetbiosDomainName ? 
                                                pDcInfo->TestedDomain->NetbiosDomainName :
                                                pDcInfo->TestedDomain->DnsDomainName));

    ld = ldap_open(W2A(pDcInfo->ComputerName), LDAP_PORT);
    if (ld == NULL) {
        DebugMessage2("ldap_init failed = %x", LdapGetLastError());
        fFailQuerySpn = TRUE;
        goto L_ERROR;
    }

    rc = ldap_bind_s(ld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    if (rc != LDAP_SUCCESS) {
        DebugMessage2("ldap_bind failed = %x", LdapGetLastError());
        fFailQuerySpn = TRUE;
        goto L_ERROR;

    }

    NetStatus = DsBindW( NULL, Domain, &hDs );
    if ( NetStatus != 0 )
    {
        DebugMessage3("Failed to bind to DC of domain %ws, %#x\n", 
               Domain, NetStatus );
        fFailQuerySpn = TRUE;
        goto L_ERROR;
    }

    Dot = wcschr( Domain, L'.' );

    if ( Dot )
    {
        *Dot = L'\0';
    }
    
    wcscpy( FlatName, Domain );

    if ( Dot )
    {
        *Dot = L'.' ;
    }

    wcscat( FlatName, L"\\" );
    wcscat( FlatName, pResults->Global.swzNetBiosName );
    wcscat( FlatName, L"$" );

    NetStatus = DsCrackNamesW(
                    hDs,
                    0,
                    DS_NT4_ACCOUNT_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &Flat,
                    &Result );

    if ( NetStatus != 0)
    {
        DebugMessage3("Failed to crack name %ws into the FQDN, %#x\n",
               FlatName, NetStatus );

        DsUnBind( &hDs );

        fFailQuerySpn = TRUE;
        goto L_ERROR;
    }

    search_dn = pResults->Global.swzNetBiosName;

    if (0 == Result->cItems)
    {
        DsUnBind( &hDs );

        fFailQuerySpn = TRUE;
        goto L_ERROR;
    }

    if (DS_NAME_NO_ERROR != Result->rItems[0].status || NULL == Result->rItems[0].pName)
    {
        DsUnBind( &hDs );

        fFailQuerySpn = TRUE;
        goto L_ERROR;
    }

    base_dn = wcschr(Result->rItems[0].pName, L',');

    if (!base_dn)
        base_dn = Result->rItems[0].pName;
    else
        base_dn++;
    
    DsUnBind( &hDs );

    swprintf(search_ava, L"(sAMAccountName=%s$)", search_dn);

    rc = ldap_search_s(ld, W2A(base_dn), LDAP_SCOPE_SUBTREE,
               W2A(search_ava), NULL, 0, &res);
    
    //base_dn can no longer be used because base_dn refers to that buffer
    DsFreeNameResultW( Result );

    if (rc != LDAP_SUCCESS) {
        DebugMessage2("ldap_search_s failed: %s", ldap_err2string(rc));
        fFailQuerySpn = TRUE;
        goto L_ERROR;
    }

    for (e = ldap_first_entry(ld, res);
     e;
     e = ldap_next_entry(ld, e)) 
    {
        BerElement *b;
        CHAR *attr;
        
        //IDS_LDAP_REG_SPN  "Registered Service Principal Names:\n"
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                    IDS_LDAP_REG_SPN);
        
        for (attr = ldap_first_attribute(ld, e, &b);
             attr;
             attr = ldap_next_attribute(ld, e, b)) 
        {
            CHAR **values, **p;
            values = ldap_get_values(ld, e, attr);
            for (p = values; *p; p++) 
            {
                if (strcmp(attr, "servicePrincipalName") == 0)
                {
                    // IDS_LDAP_SPN_NAME    "    %s\n"
                    AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0,
                                    IDS_LDAP_SPN_NAME, *p);
                    
                    if (0 == _stricmp(*p, szDefaultFqdnSpn))
                        fFqdnSpnFound = TRUE;
                    else if (0 == _stricmp(*p, szDefaultShortSpn))
                        fShortSpnFound = TRUE;
                }
            }
            ldap_value_free(values);
            ldap_memfree(attr);
        }

    }


L_ERROR:
    if (res)
    {
        ldap_msgfree(res);
    }

    if (ld)
    {
        ldap_unbind(ld);
    }

    //Only report fatal error when we successfully query SPN registration
    //and all DCs doesn't have the default SPN's
    if (fFailQuerySpn)
    {
        //IDS_LDAP_SPN_FAILURE  "Failed to query SPN registration from DC %ws.\n"
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0,
                        IDS_LDAP_SPN_FAILURE, pDcInfo->ComputerName);
        return TRUE;
    }
    else if (!fFqdnSpnFound || !fShortSpnFound)
    {
        //IDS_LDAP_SPN_MISSING              "    [WARNING] The default SPN registration for '%s' is missing on DC '%ws'.\n"
        if (!fFqdnSpnFound)
            AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0,
                        IDS_LDAP_SPN_MISSING, szDefaultFqdnSpn, pDcInfo->ComputerName);

        if (!fShortSpnFound)
            AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0,
                        IDS_LDAP_SPN_MISSING, szDefaultShortSpn, pDcInfo->ComputerName);

        return FALSE;
    }
    else
        return TRUE;
}

void LDAPGlobalPrint(IN NETDIAG_PARAMS *pParams, IN OUT NETDIAG_RESULT *pResults)
{
    if (pParams->fVerbose || !FHrOK(pResults->LDAP.hr))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, IDS_LDAP_LONG, IDS_LDAP_SHORT, pResults->LDAP.fPerformed, 
                             pResults->LDAP.hr, 0);
        
        if (!FHrOK(pResults->LDAP.hr))
        {
            if(pResults->LDAP.idsContext)
                PrintError(pParams, pResults->LDAP.idsContext, pResults->LDAP.hr);
        }

        PrintMessageList(pParams, &pResults->LDAP.lmsgOutput);
    }

}

void LDAPPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
                             IN OUT NETDIAG_RESULT *pResults,
                             IN INTERFACE_RESULT *pIfResult)
{
    // no perinterface information
}

void LDAPCleanup(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->LDAP.lmsgOutput);
    pResults->LDAP.lmsgOutput.Flink =  NULL;
}


BOOL
TestLdapOnDc(
    IN PTESTED_DC TestedDc,NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults
    )
/*++

Routine Description:


    Ensure we can use LDAP focused at the specified DC

Arguments:

    TestedDc - Description of DC to test

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    BOOL RetVal = TRUE;
    int LdapMessageId;
    PLDAPMessage LdapMessage = NULL;
    PLDAPMessage CurrentEntry;
    int LdapError;
    ULONG AuthType;
    LPSTR AuthTypeName;
    LPWSTR DcIpAddress;

    LDAP *LdapHandle = NULL;

    //
    // Avoid this test if the DC is already known to be down.
    //

    if ( TestedDc->Flags & DC_IS_DOWN ) {
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                IDS_LDAP_DCDOWN, TestedDc->ComputerName);

        goto Cleanup;
    }

    //
    // If there is no IP Address,
    //  get it.
    //

    if ( !GetIpAddressForDc( TestedDc ) ) {
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                IDS_LDAP_NOIPADDR, TestedDc->ComputerName);
        RetVal = FALSE;
        goto Cleanup;
    }

    DcIpAddress = TestedDc->DcIpAddress;

    //
    // Loop trying each type of authentication.
    //

    for ( AuthType = 0; AuthType < 3; AuthType++ ) {
        int AuthMethod;
        SEC_WINNT_AUTH_IDENTITY_W NtAuthIdentity;
        LPSTR AuthGuru;

        //
        // Bind as appropropriate
        //

        RtlZeroMemory( &NtAuthIdentity, sizeof(NtAuthIdentity));
        NtAuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
        switch ( AuthType ) {
        case 0:
            AuthTypeName = "un-";
            break;
        case 1:
            AuthTypeName = "NTLM ";
            AuthMethod = LDAP_AUTH_NTLM;
            AuthGuru = NTLM_GURU;
            break;
        case 2:
            AuthTypeName = "Negotiate ";
            AuthMethod = LDAP_AUTH_NEGOTIATE;
            AuthGuru = KERBEROS_GURU;
            break;

        }

        //
        // Only Members and Domain controllers can use authenticated RPC.
        //

        if ( AuthType != 0 ) {
            if ( pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleMemberWorkstation ||
                 pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleMemberServer ||
                 pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleBackupDomainController ||
                 pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RolePrimaryDomainController ) {

                //
                // If we're logged onto a local account,
                //  we can't test authenticated RPC.
                //

                if ( pResults->Global.pLogonDomain == NULL ) {
                    AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                        IDS_LDAP_LOGONASLOCALUSER, 
                        pResults->Global.pLogonDomainName, 
                        pResults->Global.pLogonUser, 
                        AuthTypeName, TestedDc->ComputerName);
                    goto Cleanup;
                }

            } else {
                goto Cleanup;
            }
        }

        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                    IDS_LDAP_DOAUTHEN, 
                    AuthTypeName, TestedDc->ComputerName);

        //
        // Cleanup from a previous iteration.
        //

        if ( LdapMessage != NULL ) 
        {
            ldap_msgfree( LdapMessage );
            LdapMessage = NULL;
        }

        if ( LdapHandle != NULL ) 
        {
            ldap_unbind( LdapHandle );
            LdapHandle = NULL;
        }

        //
        // Connect to the DC.
        //

        LdapHandle = ldap_openW( DcIpAddress, LDAP_PORT );

        if ( LdapHandle == NULL ) 
        {

            AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                    IDS_LDAP_CANNOTOPEN, 
                    TestedDc->ComputerName, DcIpAddress );
            goto Cleanup;
        }

        //
        // Bind to the DC.
        //

        if ( AuthType != 0 ) {
            LdapError = ldap_bind_s( LdapHandle, NULL, (char *)&NtAuthIdentity, AuthMethod );

            if ( LdapError != LDAP_SUCCESS ) {
                AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                    IDS_LDAP_CANNOTBIND, 
                    AuthTypeName, TestedDc->ComputerName, ldap_err2stringA(LdapError) );

                //
                // Try other authentication methods.
                //
                RetVal = FALSE;
                continue;
            }


        }


        //
        // Do a trivial search to isolate LDAP problems from authentication
        //  problems
        //

        LdapError = ldap_search_sA(
                            LdapHandle,
                            NULL,       // DN
                            LDAP_SCOPE_BASE,
                            "(objectClass=*)",          // filter
                            NULL,
                            FALSE,
                            &LdapMessage );

        if ( LdapError != LDAP_SUCCESS ) {
            AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                    IDS_LDAP_CANNOTSEARCH, 
                    AuthTypeName, TestedDc->ComputerName, ldap_err2stringA(LdapError) );
            goto Cleanup;
        }

        //
        // How many entries were returned.
        //
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                IDS_LDAP_ENTRIES, 
                ldap_count_entries( LdapHandle, LdapMessage ) );


        //
        // Print the entries.
        //

        CurrentEntry = ldap_first_entry( LdapHandle, LdapMessage );

        while ( CurrentEntry != NULL ) 
        {
            PVOID Context;
            char *AttrName;

            //
            // Test for error
            //
            if ( LdapHandle->ld_errno != 0 ) 
            {
                AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                        IDS_LDAP_CANNOTFIRSTENTRY, 
                        TestedDc->ComputerName, ldap_err2stringA(LdapHandle->ld_errno) );
                goto Cleanup;
            }

            //
            // Walk through the list of returned attributes.
            //

            AttrName = ldap_first_attributeA( LdapHandle, CurrentEntry, (PVOID)&Context );
            while ( AttrName != NULL ) 
            {
                PLDAP_BERVAL *Berval;


                //
                // Test for error
                //

                if ( LdapHandle->ld_errno != 0 ) {
                    AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                            IDS_LDAP_CANNOTFIRSTATTR, 
                            TestedDc->ComputerName, ldap_err2stringA(LdapHandle->ld_errno) );
                    goto Cleanup;
                }

                //
                // Grab the attribute and it's value
                //

                AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                        IDS_LDAP_ATTR, AttrName );

                Berval = ldap_get_values_lenA( LdapHandle, CurrentEntry, AttrName );

                if ( Berval == NULL ) 
                {
                    AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                        IDS_LDAP_CANNOTLEN, 
                        TestedDc->ComputerName, ldap_err2stringA(LdapHandle->ld_errno) );
                    goto Cleanup;
                } 
                else 
                {
                    int i;
                    for ( i=0; Berval[i] != NULL; i++ ) {
                        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                            IDS_LDAP_VAL, 
                            Berval[i]->bv_len, Berval[i]->bv_val );
                    }
                    ldap_value_free_len( Berval );
                }


                //
                // Get the next entry
                //

                AttrName = ldap_next_attributeA( LdapHandle, CurrentEntry, (PVOID)Context );
            }


            //
            // Get the next entry
            //

            CurrentEntry = ldap_next_entry( LdapHandle, CurrentEntry );

        }

    }



Cleanup:


    if ( LdapMessage != NULL ) {
        ldap_msgfree( LdapMessage );
    }

    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\kerberos.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      kerberos.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"

HRESULT KerberosTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	HRESULT	hr = S_OK;
	PTESTED_DOMAIN Context = pParams->pDomain;

	NET_API_STATUS NetStatus;
	NTSTATUS Status;
	BOOL RetVal = TRUE;

	HANDLE LogonHandle = NULL;
	STRING Name;
	ULONG PackageId;
	KERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
	PKERB_QUERY_TKT_CACHE_RESPONSE CacheResponse = NULL;
	ULONG ResponseSize;
	NTSTATUS SubStatus;
	ULONG Index;

	WCHAR KrbtgtOldTicketName[MAX_PATH+1];
	UNICODE_STRING KrbtgtOldTicketNameString;
	WCHAR KrbtgtTicketName[MAX_PATH+1];
	UNICODE_STRING KrbtgtTicketNameString;
	BOOLEAN KrbtgtTicketFound = FALSE;
	WCHAR OurMachineOldTicketName[MAX_PATH+1];
	UNICODE_STRING OurMachineOldTicketNameString;
	WCHAR OurMachineTicketName[MAX_PATH+1];
	UNICODE_STRING OurMachineTicketNameString;
	BOOLEAN OurMachineTicketFound = FALSE;
	TCHAR	endTime[MAX_PATH];	// though MAX_PATH is not directly related to time, it's sufficient
	TCHAR	renewTime[MAX_PATH];
    PTESTED_DOMAIN  TestedDomain;


	LPWSTR pwszDnsHostName;


	InitializeListHead(&pResults->Kerberos.lmsgOutput);

	PrintStatusMessage(pParams, 4, IDS_KERBEROS_STATUS_MSG);


	//
	// Only Members and Domain controllers use Kerberos.
	//

	if (!( pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleMemberWorkstation ||
    	pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleMemberServer ||
	    pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleBackupDomainController ||
	    pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RolePrimaryDomainController ))
	{
		PrintStatusMessage(pParams, 0, IDS_GLOBAL_SKIP_NL);
		pResults->Kerberos.fPerformed = FALSE;
		return hr;
	}
    
	//if there is no GUID for the primary domain, then it is NOT W2k domain
	if (! (pResults->Global.pPrimaryDomainInfo->Flags & DSROLE_PRIMARY_DOMAIN_GUID_PRESENT))

	{
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NOT_W2K_PRIMARY_DOMAIN);
		goto L_ERR;
	}

	//
	// If we're logged onto a local account,
	//  we can't test kerberos.
	//
	if ( pResults->Global.pLogonDomain == NULL ) 
	{
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_LOCALUSER);
		goto L_ERR;
	}

    TestedDomain = pResults->Global.pLogonDomain;

	//
	// If we're logged with cached credentials,
	//  we can't test kerberos.
	//
	if ( pResults->Global.fLogonWithCachedCredentials ) 
	{
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_CACHED);
		goto L_ERR;
	}


	//
	// If a DC hasn't been discovered yet,
	//  find one.
	//
    if ( TestedDomain->DcInfo == NULL ) 
	{
			LPTSTR pszDcType;

            if ( TestedDomain->fTriedToFindDcInfo ) {
                RetVal = FALSE;
                //IDS_DCLIST_NO_DC "    '%ws': Cannot find DC to get DC list from (Test skipped).\n"
                AddMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 
                                 IDS_DCLIST_NO_DC, TestedDomain->PrintableDomainName);
                goto L_ERR;
            }

			pszDcType = LoadAndAllocString(IDS_DCTYPE_DC);

            NetStatus = DoDsGetDcName( pParams,
                                       pResults,
                                       &pResults->Kerberos.lmsgOutput,
                                       TestedDomain,
                                       DS_DIRECTORY_SERVICE_PREFERRED,
                                       pszDcType, //"DC",
                                       FALSE,
                                       &TestedDomain->DcInfo );

			Free(pszDcType);

            TestedDomain->fTriedToFindDcInfo = TRUE;

            if ( NetStatus != NO_ERROR ) 
            {
                RetVal = FALSE;
			    AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NODC);
			    CHK_HR_CONTEXT(pResults->Kerberos, hr = HRESULT_FROM_WIN32(NetStatus), 0);
            }
        }


	//
	// If we're logged onto an account in an NT 4 domain,
	//  we can't test kerberos.
	//
	if ( (TestedDomain->DcInfo->Flags & DS_KDC_FLAG) == 0 ) 
	{
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NOKDC, pResults->Global.pLogonDomainName, pResults->Global.pLogonUser );
		goto L_ERR;
	}


	pResults->Kerberos.fPerformed = TRUE;

	//
	// Connect to the LSA.
	//

	Status = LsaConnectUntrusted( &LogonHandle );

	if (!NT_SUCCESS(Status)) {
		RetVal = FALSE;
		CHK_HR_CONTEXT(pResults->Kerberos, hr = HRESULT_FROM_WIN32(Status), IDS_KERBEROS_NOLSA);
	}

	RtlInitString( &Name, MICROSOFT_KERBEROS_NAME_A );

	Status = LsaLookupAuthenticationPackage(
            LogonHandle,
            &Name,
            &PackageId );

	if (!NT_SUCCESS(Status)) {
		RetVal = FALSE;
		//IDS_KERBEROS_NOPACKAGE              "    [FATAL] Cannot lookup package %Z.\n"
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NOPACKAGE, &Name);
		CHK_HR_CONTEXT(pResults->Kerberos, hr = HRESULT_FROM_WIN32(Status), IDS_KERBEROS_HRERROR);
	}

	//
	// Get the ticket cache from Kerberos.
	//

	CacheRequest.MessageType = KerbQueryTicketCacheMessage;
	CacheRequest.LogonId.LowPart = 0;
	CacheRequest.LogonId.HighPart = 0;

	Status = LsaCallAuthenticationPackage(
            LogonHandle,
            PackageId,
            &CacheRequest,
            sizeof(CacheRequest),
            (PVOID *) &CacheResponse,
            &ResponseSize,
            &SubStatus
            );

	if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus)) {
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NOCACHE, &Name);
		RetVal = FALSE;
		if(!NT_SUCCESS(Status))
		{
			CHK_HR_CONTEXT(pResults->Kerberos, hr = HRESULT_FROM_WIN32(Status), IDS_KERBEROS_HRERROR);
		}
		else
		{
			CHK_HR_CONTEXT(pResults->Kerberos, hr = HRESULT_FROM_WIN32(SubStatus), IDS_KERBEROS_HRERROR);
		}
	}

	//
	// Build the names of some mandatory tickets.
	//

	
	wcscpy( KrbtgtOldTicketName, GetSafeStringW(pResults->Global.pPrimaryDomainInfo->DomainNameFlat) );
	wcscat( KrbtgtOldTicketName, L"\\krbtgt" );
	RtlInitUnicodeString( &KrbtgtOldTicketNameString, KrbtgtOldTicketName );

	wcscpy(KrbtgtTicketName, L"krbtgt" );
	wcscat(KrbtgtTicketName, L"/" );
	wcscat(KrbtgtTicketName, GetSafeStringW(pResults->Global.pPrimaryDomainInfo->DomainNameDns) );
	RtlInitUnicodeString( &KrbtgtTicketNameString, KrbtgtTicketName );

	wcscpy( OurMachineOldTicketName, GetSafeStringW(pResults->Global.pPrimaryDomainInfo->DomainNameFlat) );
	wcscat( OurMachineOldTicketName, L"\\" );
	wcscat( OurMachineOldTicketName, GetSafeStringW(pResults->Global.swzNetBiosName) );
	wcscat( OurMachineOldTicketName, L"$" );
	RtlInitUnicodeString( &OurMachineOldTicketNameString, OurMachineOldTicketName );


	// russw
	// Need to convert szDnsHostName from TCHAR to WCHAR
	pwszDnsHostName = StrDupWFromT(pResults->Global.szDnsHostName);

	wcscpy( OurMachineTicketName, L"host/");
	wcscat( OurMachineTicketName, GetSafeStringW(pwszDnsHostName));

	RtlInitUnicodeString( &OurMachineTicketNameString, OurMachineTicketName );

	Free (pwszDnsHostName);
	

	// old
	//wcscpy( OurMachineTicketName, GetSafeStringW(pResults->Global.szDnsHostName) );
	// wcscat( OurMachineTicketName, L"$" )
	
	//
	// Ensure those tickets are defined.
	//


	AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_ReallyVerbose, 0, IDS_KERBEROS_CACHEDTICKER);

	for (Index = 0; Index < CacheResponse->CountOfTickets ; Index++ ) 
	{

    	if ( RtlEqualUnicodeString( &CacheResponse->Tickets[Index].ServerName,
                                &KrbtgtOldTicketNameString, TRUE ) 
             || RtlEqualUnicodeString( &CacheResponse->Tickets[Index].ServerName,
                                &KrbtgtTicketNameString,  TRUE )) 
	    {
    	    KrbtgtTicketFound = TRUE;
	    }
		
    	if ( RtlEqualUnicodeString( &CacheResponse->Tickets[Index].ServerName,
                                &OurMachineOldTicketNameString, TRUE ) 
            || RtlEqualUnicodeString( &CacheResponse->Tickets[Index].ServerName,
                                &OurMachineTicketNameString, TRUE )) 
	    {
    	    OurMachineTicketFound = TRUE;
	    }

 		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_ReallyVerbose, 0, IDS_KERBERO