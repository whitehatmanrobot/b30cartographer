int i) { return rgiILOffset [i];}
    	public virtual String GetFilename (int i) { return rgFilename [i];}
    	public virtual int GetLineNumber (int i) { return rgiLineNumber [i];}
    	public virtual int GetColumnNumber (int i) { return rgiColumnNumber [i];}
    	public virtual int GetNumberOfFrames () { return iFrameCount;}
    	public virtual void SetNumberOfFrames (int i) { iFrameCount = i;}
    }
    
    
    // Class which represents a description of a stack trace
    //
    /// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace"]/*' />
	[Serializable()]
    public class StackTrace
    {
    	private StackFrame[] frames;
    	private int m_iNumOfFrames;
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.METHODS_TO_SKIP"]/*' />
    	public const int METHODS_TO_SKIP = 0;
    	private int m_iMethodsToSkip;
    
    	// Constructs a stack trace from the current location.
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.StackTrace"]/*' />
    	public StackTrace()
    	{
    		m_iNumOfFrames = 0;
    		m_iMethodsToSkip = 0;
    		CaptureStackTrace (METHODS_TO_SKIP, false, null, null);
    	}

    	// Constructs a stack trace from the current location.
    	//
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.StackTrace1"]/*' />
    	public StackTrace(bool fNeedFileInfo)
    	{
    		m_iNumOfFrames = 0;
    		m_iMethodsToSkip = 0;
    		CaptureStackTrace (METHODS_TO_SKIP, fNeedFileInfo, null, null);
    	}
    
    	// Constructs a stack trace from the current location, in a caller's
    	// frame
    	//
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.StackTrace2"]/*' />
    	public StackTrace(int skipFrames)
    	{
    
    		if (skipFrames < 0)
    			throw new ArgumentOutOfRangeException ("skipFrames", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
    
    		m_iNumOfFrames = 0;
    		m_iMethodsToSkip = 0;
    
    		CaptureStackTrace (skipFrames+METHODS_TO_SKIP, false, null, null);
    	}
 
    	// Constructs a stack trace from the current location, in a caller's
    	// frame
    	//
    	// skipFrames : number of frames up the stack to start the trace
       	// fNeedFileInfo : if filename+linenumber+columnnumber
		//    is required to be retrieved while fetching the stacktrace
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.StackTrace3"]/*' />
    	public StackTrace(int skipFrames, bool fNeedFileInfo)
    	{
    
    		if (skipFrames < 0)
    			throw new ArgumentOutOfRangeException ("skipFrames", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
    
    		m_iNumOfFrames = 0;
    		m_iMethodsToSkip = 0;
    
    		CaptureStackTrace (skipFrames+METHODS_TO_SKIP, fNeedFileInfo, null, null);
    	}
 
    
    	// Constructs a stack trace from the current location.
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.StackTrace4"]/*' />
    	public StackTrace(Exception e)
    	{
            if (e == null)
                throw new ArgumentNullException("e");

    		m_iNumOfFrames = 0;
    		m_iMethodsToSkip = 0;
    		CaptureStackTrace (METHODS_TO_SKIP, false, null, e);
    	}

    	// Constructs a stack trace from the current location.
    	//
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.StackTrace5"]/*' />
    	public StackTrace(Exception e, bool fNeedFileInfo)
    	{
            if (e == null)
                throw new ArgumentNullException("e");

    		m_iNumOfFrames = 0;
    		m_iMethodsToSkip = 0;
    		CaptureStackTrace (METHODS_TO_SKIP, fNeedFileInfo, null, e);
    	}
    
    	// Constructs a stack trace from the current location, in a caller's
    	// frame
    	//
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.StackTrace6"]/*' />
    	public StackTrace(Exception e, int skipFrames)
    	{
            if (e == null)
                throw new ArgumentNullException("e");

    		if (skipFrames < 0)
    			throw new ArgumentOutOfRangeException ("skipFrames", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
    
    		m_iNumOfFrames = 0;
    		m_iMethodsToSkip = 0;
    
    		CaptureStackTrace (skipFrames+METHODS_TO_SKIP, false, null, e);
    	}
 
    	// Constructs a stack trace from the current location, in a caller's
    	// frame
    	//
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.StackTrace7"]/*' />
    	public StackTrace(Exception e, int skipFrames, bool fNeedFileInfo)
    	{
            if (e == null)
                throw new ArgumentNullException("e");

    		if (skipFrames < 0)
    			throw new ArgumentOutOfRangeException ("skipFrames", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
    
    		m_iNumOfFrames = 0;
    		m_iMethodsToSkip = 0;
    
    		CaptureStackTrace (skipFrames+METHODS_TO_SKIP, fNeedFileInfo, null, e);
    	}
 
    
    	// Constructs a "fake" stack trace, just containing a single frame.  Use
    	// when you don't want the overhead of a full stack trace.
    	//
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.StackTrace8"]/*' />
    	public StackTrace(StackFrame frame)
    	{
    		frames = new StackFrame[1];
    		frames[0] = frame;
    		m_iMethodsToSkip = 0;
    		m_iNumOfFrames = 1;
    	}


    	// Constructs a stack trace for the given thread
    	//
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.StackTrace9"]/*' />
    	public StackTrace(Thread targetThread, bool needFileInfo)
    	{    
    		m_iNumOfFrames = 0;
    		m_iMethodsToSkip = 0;

			if (targetThread != null)
			{
				if (targetThread != Thread.CurrentThread)
				{
					if (((targetThread.ThreadState & System.Threading.ThreadState.Suspended) != 0)
					 && ((targetThread.ThreadState & System.Threading.ThreadState.SuspendRequested) != 0)
					 && (targetThread.ThreadState != System.Threading.ThreadState.Stopped)
					 && (targetThread.ThreadState != System.Threading.ThreadState.Unstarted))
					{
		    			throw new ThreadStateException (
									Environment.GetResourceString("ThreadState_NeedSuspended"));						
					}
				}
				else
					targetThread = null;
			}

    		CaptureStackTrace (METHODS_TO_SKIP, needFileInfo, targetThread, null);

    	}

    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	internal static extern void GetStackFramesInternal(StackFrameHelper sfh, int iSkip, Exception e);
    
    	internal static int CalculateFramesToSkip (StackFrameHelper StackF, int iNumFrames)
    	{
    
    		int iRetVal = 0;
    		String PackageName = "System.Diagnostics";
    
    		// Check if this method is part of the System.Diagnostics
    		// package. If so, increment counter keeping track of 
    		// System.Diagnostics functions
    		for (int i=0; i<iNumFrames; i++)
    		{
				MethodBase mb = StackF.GetMethodBase(i);
				if (mb != null)
				{				
    				Type t = mb.DeclaringType;
					if (t == null)	
						break;
    				String ns = t.Namespace;
    				if (ns == null) 	
						break;
					if (String.Compare (ns, PackageName, false, CultureInfo.InvariantCulture) != 0)
						break;
				}
				iRetVal++;
    		}
    
    		return iRetVal;
    	}
    
    	// PRIVATE method to retrieve an object with stack trace information
    	// encoded.
    	//
    	// This version leaves out the first "iSkip" lines of the stacktrace.
    	private void CaptureStackTrace(int iSkip, bool fNeedFileInfo, Thread targetThread,
                                       Exception e)
    	{
    		m_iMethodsToSkip += iSkip;
    
    		StackFrameHelper StackF = new StackFrameHelper(fNeedFileInfo, targetThread);
    
    		GetStackFramesInternal (StackF, 0, e);
    
    		m_iNumOfFrames = StackF.GetNumberOfFrames();

            if (m_iNumOfFrames != 0)
            {
                frames = new StackFrame [m_iNumOfFrames];

                for (int i=0; i<m_iNumOfFrames; i++)
                {
                    bool fDummy1 = true;
                    bool fDummy2 = true;
                    StackFrame sfTemp = new StackFrame (fDummy1, fDummy2);

                    sfTemp.SetMethodBase (StackF.GetMethodBase(i));
                    sfTemp.SetOffset (StackF.GetOffset(i));
                    sfTemp.SetILOffset (StackF.GetILOffset(i));

                    if (fNeedFileInfo)
                    {
                        sfTemp.SetFileName (StackF.GetFilename (i));
                        sfTemp.SetLineNumber (StackF.GetLineNumber (i));
                        sfTemp.SetColumnNumber (StackF.GetColumnNumber (i));
                    } 

                    frames [i] = sfTemp;
                }

                // CalculateFramesToSkip skips all frames in the System.Diagnostics namespace,
                // but this is not desired if building a stack trace from an exception.
                if (e == null)
                    m_iMethodsToSkip += CalculateFramesToSkip (StackF, m_iNumOfFrames);

                m_iNumOfFrames -= m_iMethodsToSkip;
                if (m_iNumOfFrames < 0)
                    m_iNumOfFrames = 0;
            }

            // In case this is the same object being re-used, set frames to null
            else
                frames = null;
    	}
    
    	// Property to get the number of frames in the stack trace
    	//
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.FrameCount"]/*' />
    	public virtual int FrameCount
    	{
    		get { return m_iNumOfFrames;}
    	}
    
    
    	// Returns a given stack frame.  Stack frames are numbered starting at
    	// zero, which is the last stack frame pushed.
    	//
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.GetFrame"]/*' />
    	public virtual StackFrame GetFrame(int index)
    	{
    		if ((index < m_iNumOfFrames) && (index >= 0))
    			return frames [index+m_iMethodsToSkip];
    
    		return null;
    	}
    
    	// Builds a readable representation of the stack trace
    	//
    	/// <include file='doc\Stacktrace.uex' path='docs/doc[@for="StackTrace.ToString"]/*' />
    	public override String ToString()
    	{
            StringBuilder sb = new StringBuilder(255);
    		int iIndex;
    		
    		// need to skip over "n" frames which represent the 
    		// System.Diagnostics package frames
    		for (iIndex=m_iMethodsToSkip; iIndex < m_iNumOfFrames+m_iMethodsToSkip; iIndex++)
    		{
				MethodBase mb = frames [iIndex].GetMethod();
				if (mb != null)
				{
    				Type t = mb.DeclaringType;

					if (t != null)
					{
    					String ns = t.Namespace;
    								
    					sb.Append (Environment.NewLine + "\tat ");
    					if (ns != null)
    					{
    						sb.Append (ns);
    						sb.Append (".");
    					}
    
    					sb.Append (t.Name);
    					sb.Append (".");
    					sb.Append (frames [iIndex].GetMethod().Name);
    					sb.Append ("(");
    					
    					ParameterInfo[] pi = frames [iIndex].GetMethod().GetParameters();
    
    					int j=0;
    					bool fFirstParam = true;
    					while (j < pi.Length)
    					{
    						if (fFirstParam == false)
    							sb.Append (", ");
    						else
    							fFirstParam = false;
    
    						t = pi [j].ParameterType;
    						sb.Append (t.Name);				
    						j++;
    					}	
    					sb.Append (")");	
					}
				}
    		}
    
    		if (iIndex == m_iMethodsToSkip)
    			sb.Append (""); // empty string, since no frame was found...
    		else
    			sb.Append (Environment.NewLine);
    
    		return sb.ToString(); 
    	}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\isymwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ISymbolWriter
**
** Author: Mike Magruder (mikemag)
**
** Represents a symbol writer for managed code. Provides methods to
** define documents, sequence points, lexical scopes, and variables.
**
** Date:  Thu Aug 19 13:38:32 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
    
	using System;
    using System.Reflection;

	// Interface does not need to be marked with the serializable attribute
    /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter"]/*' />
    public interface ISymbolWriter
    {
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.Initialize"]/*' />
        // Set the IMetaDataEmitter that this symbol writer is associated
        // with. This must be done only once before any other ISymbolWriter
        // methods are called.
        void Initialize(IntPtr emitter, String filename, bool fFullBuild);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.DefineDocument"]/*' />
        
        // Define a source document. Guid's will be provided for the
        // languages, vendors, and document types that we currently know
        // about.
        ISymbolDocumentWriter DefineDocument(String url,
                                          Guid language,
                                          Guid languageVendor,
                                          Guid documentType);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.SetUserEntryPoint"]/*' />
    
        // Define the method that the user has defined as their entrypoint
        // for this module. This would be, perhaps, the user's main method
        // rather than compiler generated stubs before main.
        void SetUserEntryPoint(SymbolToken entryMethod);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.OpenMethod"]/*' />
    
        // Open a method to emit symbol information into. The given method
        // becomes the current method for calls do define sequence points,
        // parameters and lexical scopes. There is an implicit lexical
        // scope around the entire method. Re-opening a method that has
        // been previously closed effectivley erases any previously
        // defined symbols for that method.
        //
        // There can be only one open method at a time.
        void OpenMethod(SymbolToken method);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.CloseMethod"]/*' />
    
        // Close the current method. Once a method is closed, no more
        // symbols can be defined within it.
        void CloseMethod();
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.DefineSequencePoints"]/*' />
    
        // Define a group of sequence points within the current method.
        // Each line/column defines the start of a statement within a
        // method. The arrays should be sorted by offset. The offset is
        // always the offset from the start of the method, in bytes.
        void DefineSequencePoints(ISymbolDocumentWriter document,
                                  int[] offsets,
                                  int[] lines,
                                  int[] columns,
                                  int[] endLines,
                                  int[] endColumns);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.OpenScope"]/*' />
    
        // Open a new lexical scope in the current method. The scope
        // becomes the new current scope and is effectivley pushed onto a
        // stack of scopes. startOffset is the offset, in bytes from the
        // beginning of the method, of the first instruction in the
        // lexical scope. Scopes must form a hierarchy. Siblings are not
        // allowed to overlap.
        //
        // OpenScope returns an opaque scope id that can be used with
        // SetScopeRange to define a scope's start/end offset at a later
        // time. In this case, the offsets passed to OpenScope and
        // CloseScope are ignored.
        //
        // Note: scope id's are only valid in the current method.
        //
        // @todo: should we require that startOffset and endOffset for
        // scopes also be defined as sequence points?
        int OpenScope(int startOffset);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.CloseScope"]/*' />
    
        // Close the current lexical scope. Once a scope is closed no more
        // variables can be defined within it. endOffset points past the
        // last instruction in the scope.
        void CloseScope(int endOffset);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.SetScopeRange"]/*' />
    
        // Define the offset range for a given lexical scope.
        void SetScopeRange(int scopeID, int startOffset, int endOffset);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.DefineLocalVariable"]/*' />
    
        // Define a single variable in the current lexical
        // scope. startOffset and endOffset are optional. If 0, then they
        // are ignored and the variable is defined over the entire
        // scope. If non-zero, then they must fall within the offsets of
        // the current scope. This can be called multiple times for a
        // variable of the same name that has multiple homes throughout a
        // scope. (Note: start/end offsets must not overlap in such a
        // case.)
        void DefineLocalVariable(String name,
                                        FieldAttributes attributes,
                                        byte[] signature,
                                        SymAddressKind addrKind,
                                        int addr1,
                                        int addr2,
                                        int addr3,
                                        int startOffset,
                                        int endOffset);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.DefineParameter"]/*' />
    
        // Define a single parameter in the current method. The type of
        // each parameter is taken from its position (sequence) within the
        // method's signature.
        //
        // Note: if parameters are defined in the metadata for a given
        // method, then clearly one would not have to define them again
        // with calls to this method. The symbol readers will have to be
        // smart enough to check the normal metadata for these first then
        // fall back to the symbol store.
        void DefineParameter(String name,
                                    ParameterAttributes attributes,
                                    int sequence,
                                    SymAddressKind addrKind,
                                    int addr1,
                                    int addr2,
                                    int addr3);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.DefineField"]/*' />
    
        // Define a single variable not within a method. This is used for
        // certian fields in classes, bitfields, etc.
        void DefineField(SymbolToken parent,
                                String name,
                                FieldAttributes attributes,
                                byte[] signature,
                                SymAddressKind addrKind,
                                int addr1,
                                int addr2,
                                int addr3);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.DefineGlobalVariable"]/*' />
    
        // Define a single global variable.
        void DefineGlobalVariable(String name,
                                         FieldAttributes attributes,
                                         byte[] signature,
                                         SymAddressKind addrKind,
                                         int addr1,
                                         int addr2,
                                         int addr3);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.Close"]/*' />
    
        // Close will close the ISymbolWriter and commit the symbols
        // to the symbol store. The ISymbolWriter becomes invalid
        // after this call for further updates.
        void Close();
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.SetSymAttribute"]/*' />
    
        // Defines a custom attribute based upon its name. Not to be
        // confused with Metadata custom attributes, these attributes are
        // held in the symbol store.
        void SetSymAttribute(SymbolToken parent, String name, byte[] data);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.OpenNamespace"]/*' />
    
        // Opens a new namespace. Call this before defining methods or
        // variables that live within a namespace. Namespaces can be nested.
        void OpenNamespace(String name);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.CloseNamespace"]/*' />
    
        // Close the most recently opened namespace.
        void CloseNamespace();
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.UsingNamespace"]/*' />
    
        // Specifies that the given, fully qualified namespace name is
        // being used within the currently open lexical scope. Closing the
        // current scope will also stop using the namespace, and the
        // namespace will be in use in all scopes that inherit from the
        // currently open scope.
        void UsingNamespace(String fullName);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.SetMethodSourceRange"]/*' />
        
        // Specifies the true start and end of a method within a source
        // file. Use this to specify the extent of a method independently
        // of what sequence points exist within the method.
        void SetMethodSourceRange(ISymbolDocumentWriter startDoc,
                                         int startLine,
                                         int startColumn,
                                         ISymbolDocumentWriter endDoc,
                                         int endLine,
                                         int endColumn);
        /// <include file='doc\ISymWriter.uex' path='docs/doc[@for="ISymbolWriter.SetUnderlyingWriter"]/*' />

        // Used to set the underlying ISymUnmanagedWriter that a
        // managed ISymbolWriter may use to emit symbols with.
        void SetUnderlyingWriter(IntPtr underlyingWriter);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\isymvariable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ISymbolVariable
**
** Author: Mike Magruder (mikemag)
**
** Represents a variable within a symbol store. This could be a
** parameter, local variable, or some other non-local variable.
**
** Date:  Thu Aug 19 13:38:32 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
    // Interface does not need to be marked with the serializable attribute
    using System;

    /// <include file='doc\ISymVariable.uex' path='docs/doc[@for="ISymbolVariable"]/*' />
    public interface ISymbolVariable
    {
        /// <include file='doc\ISymVariable.uex' path='docs/doc[@for="ISymbolVariable.Name"]/*' />
        // Get the name of this variable.
        String Name { get; }
        /// <include file='doc\ISymVariable.uex' path='docs/doc[@for="ISymbolVariable.Attributes"]/*' />
    
        // Get the attributes of this variable.
        Object Attributes { get; }
        /// <include file='doc\ISymVariable.uex' path='docs/doc[@for="ISymbolVariable.GetSignature"]/*' />
    
        // Get the signature of this variable.
        byte[] GetSignature();
        /// <include file='doc\ISymVariable.uex' path='docs/doc[@for="ISymbolVariable.AddressKind"]/*' />
    
        SymAddressKind AddressKind { get; }
        /// <include file='doc\ISymVariable.uex' path='docs/doc[@for="ISymbolVariable.AddressField1"]/*' />
        int AddressField1 { get; }
        /// <include file='doc\ISymVariable.uex' path='docs/doc[@for="ISymbolVariable.AddressField2"]/*' />
        int AddressField2 { get; }
        /// <include file='doc\ISymVariable.uex' path='docs/doc[@for="ISymbolVariable.AddressField3"]/*' />
        int AddressField3 { get; }
        /// <include file='doc\ISymVariable.uex' path='docs/doc[@for="ISymbolVariable.StartOffset"]/*' />
    
        // Get the start/end offsets of this variable within its
        // parent. If this is a local variable within a scope, these will
        // fall within the offsets defined for the scope.
        int StartOffset { get; }
        /// <include file='doc\ISymVariable.uex' path='docs/doc[@for="ISymbolVariable.EndOffset"]/*' />
        int EndOffset { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\symdocumenttype.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  SymDocumentType
**
** Author: Mike Magruder (mikemag)
**
** A class to hold public guids for document types to be used with the
** symbol store.
**
** Date:  Tue Sep 07 13:05:53 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
    // Only statics does not need to be marked with the serializable attribute
    using System;

    /// <include file='doc\SymDocumentType.uex' path='docs/doc[@for="SymDocumentType"]/*' />
    public class SymDocumentType
    {
        /// <include file='doc\SymDocumentType.uex' path='docs/doc[@for="SymDocumentType.Text"]/*' />
        public static readonly Guid Text = new Guid(0x5a869d0b, 0x6611, 0x11d3, 0xbd, 0x2a, 0x0, 0x0, 0xf8, 0x8, 0x49, 0xbd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\symlanguagevendor.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  SymLanguageVendor
**
** Author: Mike Magruder (mikemag)
**
** A class to hold public guids for language vendors.
**
** Date:  Tue Sep 07 13:05:53 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
    // Only statics, does not need to be marked with the serializable attribute
    using System;

    /// <include file='doc\SymLanguageVendor.uex' path='docs/doc[@for="SymLanguageVendor"]/*' />
    public class SymLanguageVendor
    {
        /// <include file='doc\SymLanguageVendor.uex' path='docs/doc[@for="SymLanguageVendor.Microsoft"]/*' />
        public static readonly Guid Microsoft = new Guid(unchecked((int)0x994b45c4), unchecked((short) 0xe6e9), 0x11d2, 0x90, 0x3f, 0x00, 0xc0, 0x4f, 0xa3, 0x02, 0xa1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\token.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  SymbolToken
**
** Author: Mike Magruder (mikemag)
**
** Small value class used by the SymbolStore package for passing
** around metadata tokens.
**
** Date:  Thu Aug 19 13:38:32 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
    
    using System;

    /// <include file='doc\Token.uex' path='docs/doc[@for="SymbolToken"]/*' />
    public struct SymbolToken
    {
        internal int m_token;
        
        /// <include file='doc\Token.uex' path='docs/doc[@for="SymbolToken.SymbolToken"]/*' />
        public SymbolToken(int val) {m_token=val;}
    
        /// <include file='doc\Token.uex' path='docs/doc[@for="SymbolToken.GetToken"]/*' />
        public int GetToken() {return m_token;}
        
    	/// <include file='doc\Token.uex' path='docs/doc[@for="SymbolToken.GetHashCode"]/*' />
    	public override int GetHashCode() {return m_token;}
    	
    	/// <include file='doc\Token.uex' path='docs/doc[@for="SymbolToken.Equals"]/*' />
    	public override bool Equals(Object obj)
    	{
    		if (obj!=null && (obj is SymbolToken))
    			return ((SymbolToken)obj).m_token == m_token;
    		else
    			return false;
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\symaddresskind.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  SymAddressKind
**
** Author: Mike Magruder (mikemag)
**
** Represents address Kinds used with local variables, parameters, and
** fields.
**
** Date:  Tue Aug 24 02:13:09 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
	// Only statics, does not need to be marked with the serializable attribute    
    using System;

    /// <include file='doc\SymAddressKind.uex' path='docs/doc[@for="SymAddressKind"]/*' />
	[Serializable()]
    public enum SymAddressKind
    {
        // ILOffset: addr1 = IL local var or param index.
        /// <include file='doc\SymAddressKind.uex' path='docs/doc[@for="SymAddressKind.ILOffset"]/*' />
        ILOffset = 1,
    
        // NativeRVA: addr1 = RVA into module.
        /// <include file='doc\SymAddressKind.uex' path='docs/doc[@for="SymAddressKind.NativeRVA"]/*' />
        NativeRVA = 2,
    
        // NativeRegister: addr1 = register the var is stored in.
        /// <include file='doc\SymAddressKind.uex' path='docs/doc[@for="SymAddressKind.NativeRegister"]/*' />
        NativeRegister = 3,
    
        // NativeRegisterRelative: addr1 = register, addr2 = offset.
        /// <include file='doc\SymAddressKind.uex' path='docs/doc[@for="SymAddressKind.NativeRegisterRelative"]/*' />
        NativeRegisterRelative = 4,
    
        // NativeOffset: addr1 = offset from start of parent.
        /// <include file='doc\SymAddressKind.uex' path='docs/doc[@for="SymAddressKind.NativeOffset"]/*' />
        NativeOffset = 5,
    
        // NativeRegisterRegister: addr1 = reg low, addr2 = reg high.
        /// <include file='doc\SymAddressKind.uex' path='docs/doc[@for="SymAddressKind.NativeRegisterRegister"]/*' />
        NativeRegisterRegister = 6,
    
        // NativeRegisterStack: addr1 = reg low, addr2 = reg stk, addr3 = offset.
        /// <include file='doc\SymAddressKind.uex' path='docs/doc[@for="SymAddressKind.NativeRegisterStack"]/*' />
        NativeRegisterStack = 7,
    
        // NativeStackRegister: addr1 = reg stk, addr2 = offset, addr3 = reg high.
        /// <include file='doc\SymAddressKind.uex' path='docs/doc[@for="SymAddressKind.NativeStackRegister"]/*' />
        NativeStackRegister = 8,
    
        // BitField: addr1 = field start, addr = field length.
        /// <include file='doc\SymAddressKind.uex' path='docs/doc[@for="SymAddressKind.BitField"]/*' />
        BitField = 9,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\diagnostics\symbolstore\symlanguagetype.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  SymLanguageType
**
** Author: Mike Magruder (mikemag)
**
** A class to hold public guids for languages types.
**
** Date:  Tue Sep 07 13:05:53 1999
** 
===========================================================*/
namespace System.Diagnostics.SymbolStore {
    // Only statics, does not need to be marked with the serializable attribute
    using System;

    /// <include file='doc\SymLanguageType.uex' path='docs/doc[@for="SymLanguageType"]/*' />
    public class SymLanguageType
    {
        /// <include file='doc\SymLanguageType.uex' path='docs/doc[@for="SymLanguageType.C"]/*' />
        public static readonly Guid C = new Guid(0x63a08714, unchecked((short) 0xfc37), 0x11d2, 0x90, 0x4c, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1);
        /// <include file='doc\SymLanguageType.uex' path='docs/doc[@for="SymLanguageType.CPlusPlus"]/*' />
        public static readonly Guid CPlusPlus = new Guid(0x3a12d0b7, unchecked((short)0xc26c), 0x11d0, 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2);
    
        /// <include file='doc\SymLanguageType.uex' path='docs/doc[@for="SymLanguageType.CSharp"]/*' />
        public static readonly Guid CSharp = new Guid(0x3f5162f8, unchecked((short)0x07c6), 0x11d3, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1);
    
        /// <include file='doc\SymLanguageType.uex' path='docs/doc[@for="SymLanguageType.Basic"]/*' />
        public static readonly Guid Basic = new Guid(0x3a12d0b8, unchecked((short)0xc26c), 0x11d0, 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2);
    
        /// <include file='doc\SymLanguageType.uex' path='docs/doc[@for="SymLanguageType.Java"]/*' />
        public static readonly Guid Java = new Guid(0x3a12d0b4, unchecked((short)0xc26c), 0x11d0, 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2);
    
        /// <include file='doc\SymLanguageType.uex' path='docs/doc[@for="SymLanguageType.Cobol"]/*' />
        public static readonly Guid Cobol = new Guid(unchecked((int)0xaf046cd1), unchecked((short)0xd0e1), 0x11d2, 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc);
    
        /// <include file='doc\SymLanguageType.uex' path='docs/doc[@for="SymLanguageType.Pascal"]/*' />
        public static readonly Guid Pascal = new Guid(unchecked((int)0xaf046cd2), unchecked((short) 0xd0e1), 0x11d2, 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc);
    
        /// <include file='doc\SymLanguageType.uex' path='docs/doc[@for="SymLanguageType.ILAssembly"]/*' />
        public static readonly Guid ILAssembly = new Guid(unchecked((int)0xaf046cd3), unchecked((short)0xd0e1), 0x11d2, 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc);
    
        /// <include file='doc\SymLanguageType.uex' path='docs/doc[@for="SymLanguageType.JScript"]/*' />
        public static readonly Guid JScript = new Guid(0x3a12d0b6, unchecked((short)0xc26c), 0x11d0, 0xb4, 0x42, 0x00, 0xa0, 0x24, 0x4a, 0x1d, 0xd2);
    
        /// <include file='doc\SymLanguageType.uex' path='docs/doc[@for="SymLanguageType.SMC"]/*' />
        public static readonly Guid SMC = new Guid(unchecked((int)0xd9b9f7b), 0x6611, unchecked((short)0x11d3), 0xbd, 0x2a, 0x0, 0x0, 0xf8, 0x8, 0x49, 0xbd);
    
        /// <include file='doc\SymLanguageType.uex' path='docs/doc[@for="SymLanguageType.MCPlusPlus"]/*' />
        public static readonly Guid MCPlusPlus = new Guid(0x4b35fde8, unchecked((short)0x07c6), 0x11d3, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\calendar.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
    using System;
    using System.Runtime.CompilerServices;

    /// <include file='doc\Calendar.uex' path='docs/doc[@for="CalendarWeekRule"]/*' />
    [Serializable]
    public enum CalendarWeekRule
    {
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="CalendarWeekRule.FirstDay"]/*' />
        FirstDay = 0,           // Week 1 begins on the first day of the year
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="CalendarWeekRule.FirstFullWeek"]/*' />
        FirstFullWeek = 1,      // Week 1 begins on first FirstDayOfWeek not before the first day of the year
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="CalendarWeekRule.FirstFourDayWeek"]/*' />
        FirstFourDayWeek = 2    // Week 1 begins on first FirstDayOfWeek such that FirstDayOfWeek+3 is not before the first day of the year        
    };
    
    // This abstract class represents a calendar. A calendar reckons time in 
    // divisions such as weeks, months and years. The number, length and start of 
    // the divisions vary in each calendar.
    // 
    // Any instant in time can be represented as an n-tuple of numeric values using 
    // a particular calendar. For example, the next vernal equinox occurs at (0.0, 0
    // , 46, 8, 20, 3, 1999) in the Gregorian calendar. An  implementation of 
    // Calendar can map any DateTime value to such an n-tuple and vice versa. The 
    // DateTimeFormat class can map between such n-tuples and a textual 
    // representation such as "8:46 AM March 20th 1999 AD".
    // 
    // Most calendars identify a year which begins the current era. There may be any 
    // number of previous eras. The Calendar class identifies the eras as enumerated 
    // integers where the current era (CurrentEra) has the value zero.
    // 
    // For consistency, the first unit in each interval, e.g. the first month, is 
    // assigned the value one.
     // NOTE YSLin:
     // The calculation of hour/minute/second is moved to Calendar from GregorianCalendar,
     // since most of the calendars (or all?) have the same way of calcuating hour/minute/second.
    /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar"]/*' />
    [Serializable()] public abstract class Calendar
    {

        // Number of 100ns (10E-7 second) ticks per time unit
        internal const long TicksPerMillisecond   = 10000;
        internal const long TicksPerSecond        = TicksPerMillisecond * 1000;
        internal const long TicksPerMinute        = TicksPerSecond * 60;
        internal const long TicksPerHour          = TicksPerMinute * 60;
        internal const long TicksPerDay           = TicksPerHour * 24;
    
        // Number of milliseconds per time unit
        internal const int MillisPerSecond        = 1000;
        internal const int MillisPerMinute        = MillisPerSecond * 60;
        internal const int MillisPerHour          = MillisPerMinute * 60;
        internal const int MillisPerDay           = MillisPerHour * 24;    

        // Number of days in a non-leap year
        internal const int DaysPerYear            = 365;
        // Number of days in 4 years
        internal const int DaysPer4Years          = DaysPerYear * 4 + 1;
        // Number of days in 100 years
        internal const int DaysPer100Years        = DaysPer4Years * 25 - 1;
        // Number of days in 400 years
        internal const int DaysPer400Years        = DaysPer100Years * 4 + 1;
    
        // Number of days from 1/1/0001 to 1/1/10000
        internal const int DaysTo10000            = DaysPer400Years * 25 - 366;    

        internal const long MaxMillis             = (long)DaysTo10000 * MillisPerDay;

        //
        //  Calendar ID Values.  This is used to get data from calendar.nlp.
        //  The order of calendar ID means the order of data items in the table.
        //
        internal const int CAL_GREGORIAN                  = 1 ;     // Gregorian (localized) calendar
        internal const int CAL_GREGORIAN_US               = 2 ;     // Gregorian (U.S.) calendar
        internal const int CAL_JAPAN                      = 3 ;     // Japanese Emperor Era calendar
        internal const int CAL_TAIWAN                     = 4 ;     // Taiwan Era calendar
        internal const int CAL_KOREA                      = 5 ;     // Korean Tangun Era calendar
        internal const int CAL_HIJRI                      = 6 ;     // Hijri (Arabic Lunar) calendar
        internal const int CAL_THAI                       = 7 ;     // Thai calendar
        internal const int CAL_HEBREW                     = 8 ;     // Hebrew (Lunar) calendar
        internal const int CAL_GREGORIAN_ME_FRENCH        = 9 ;     // Gregorian Middle East French calendar
        internal const int CAL_GREGORIAN_ARABIC           = 10;     // Gregorian Arabic calendar
        internal const int CAL_GREGORIAN_XLIT_ENGLISH     = 11;     // Gregorian Transliterated English calendar
        internal const int CAL_GREGORIAN_XLIT_FRENCH      = 12;
        internal const int CAL_JULIAN      = 13;    

        internal int m_currentEraValue = -1;
        
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.Calendar"]/*' />
        protected Calendar() {
            //Do-nothing constructor.
        }

        ///
        // This can not be abstract, otherwise no one can create a subclass of Calendar.
        //
        internal virtual int ID {
            get {
                return (-1);
            }
        }

        /*=================================CurrentEraValue==========================
        **Action: This is used to convert CurretEra(0) to an appropriate era value.
        **Returns:
        **Arguments:
        **Exceptions:
        **Notes:
        ** The value is from calendar.nlp.
        ============================================================================*/
        
        internal virtual int CurrentEraValue {
            get {
                // The following code assumes that the current era value can not be -1.
                if (m_currentEraValue == -1) {
                    m_currentEraValue = CalendarTable.GetInt32Value(ID, CalendarTable.ICURRENTERA, false);
                }
                return (m_currentEraValue);
            }
        }

        // The current era for a calendar.
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.CurrentEra"]/*' />
        public const int CurrentEra = 0;
        
        internal int twoDigitYearMax = -1;
        
        internal DateTime Add(DateTime time, double value, int scale) {
            long millis = (long)(value * scale + (value >= 0? 0.5: -0.5));
            if (millis <= -MaxMillis || millis >= MaxMillis) {
                throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_AddValue"));
            }
            return (new DateTime(time.Ticks + millis * TicksPerMillisecond));
        }

        // Returns the DateTime resulting from adding a fractional number of
        // days to the specified DateTime. The result is computed by rounding the
        // fractional number of days given by value to the nearest
        // millisecond, and adding that interval to the specified DateTime. The
        // value argument is permitted to be negative.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.AddDays"]/*' />
        public virtual DateTime AddDays(DateTime time, int days) {
            return (Add(time, days, MillisPerDay));
        }

        // Returns the DateTime resulting from adding a fractional number of
        // hours to the specified DateTime. The result is computed by rounding the
        // fractional number of hours given by value to the nearest
        // millisecond, and adding that interval to the specified DateTime. The
        // value argument is permitted to be negative.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.AddHours"]/*' />
        public virtual DateTime AddHours(DateTime time, int hours) {
            return (Add(time, hours, MillisPerHour));
        }

        // Returns the DateTime resulting from adding the given number of
        // milliseconds to the specified DateTime. The result is computed by rounding
        // the number of milliseconds given by value to the nearest integer,
        // and adding that interval to the specified DateTime. The value
        // argument is permitted to be negative.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.AddMilliseconds"]/*' />
        public virtual DateTime AddMilliseconds(DateTime time, double milliseconds) {
            return (Add(time, milliseconds, 1));
        }

        // Returns the DateTime resulting from adding a fractional number of
        // minutes to the specified DateTime. The result is computed by rounding the
        // fractional number of minutes given by value to the nearest
        // millisecond, and adding that interval to the specified DateTime. The
        // value argument is permitted to be negative.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.AddMinutes"]/*' />
        public virtual DateTime AddMinutes(DateTime time, int minutes) {
            return (Add(time, minutes, MillisPerMinute));
        }


        // Returns the DateTime resulting from adding the given number of
        // months to the specified DateTime. The result is computed by incrementing
        // (or decrementing) the year and month parts of the specified DateTime by
        // value months, and, if required, adjusting the day part of the
        // resulting date downwards to the last day of the resulting month in the
        // resulting year. The time-of-day part of the result is the same as the
        // time-of-day part of the specified DateTime.
        //
        // In more precise terms, considering the specified DateTime to be of the
        // form y / m / d + t, where y is the
        // year, m is the month, d is the day, and t is the
        // time-of-day, the result is y1 / m1 / d1 + t,
        // where y1 and m1 are computed by adding value months
        // to y and m, and d1 is the largest value less than
        // or equal to d that denotes a valid day in month m1 of year
        // y1.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.AddMonths"]/*' />
        public abstract DateTime AddMonths(DateTime time, int months);
    
        // Returns the DateTime resulting from adding a number of
        // seconds to the specified DateTime. The result is computed by rounding the
        // fractional number of seconds given by value to the nearest
        // millisecond, and adding that interval to the specified DateTime. The
        // value argument is permitted to be negative.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.AddSeconds"]/*' />
        public virtual DateTime AddSeconds(DateTime time, int seconds) {
            return Add(time, seconds, MillisPerSecond);
        }
    
        // Returns the DateTime resulting from adding a number of
        // weeks to the specified DateTime. The
        // value argument is permitted to be negative.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.AddWeeks"]/*' />
        public virtual DateTime AddWeeks(DateTime time, int weeks) {
            return (AddDays(time, weeks * 7));
        }
        
    
        // Returns the DateTime resulting from adding the given number of
        // years to the specified DateTime. The result is computed by incrementing
        // (or decrementing) the year part of the specified DateTime by value
        // years. If the month and day of the specified DateTime is 2/29, and if the
        // resulting year is not a leap year, the month and day of the resulting
        // DateTime becomes 2/28. Otherwise, the month, day, and time-of-day
        // parts of the result are the same as those of the specified DateTime.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.AddYears"]/*' />
        public abstract DateTime AddYears(DateTime time, int years);
    
        // Returns the day-of-month part of the specified DateTime. The returned
        // value is an integer between 1 and 31.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetDayOfMonth"]/*' />
        public abstract int GetDayOfMonth(DateTime time);
    
        // Returns the day-of-week part of the specified DateTime. The returned value
        // is an integer between 0 and 6, where 0 indicates Sunday, 1 indicates
        // Monday, 2 indicates Tuesday, 3 indicates Wednesday, 4 indicates
        // Thursday, 5 indicates Friday, and 6 indicates Saturday.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetDayOfWeek"]/*' />
        public abstract DayOfWeek GetDayOfWeek(DateTime time);
    
        // Returns the day-of-year part of the specified DateTime. The returned value
        // is an integer between 1 and 366.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetDayOfYear"]/*' />
        public abstract int GetDayOfYear(DateTime time);
    
        // Returns the number of days in the month given by the year and
        // month arguments.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetDaysInMonth"]/*' />
        public virtual int GetDaysInMonth(int year, int month)
        {
            return (GetDaysInMonth(year, month, CurrentEra));
        }
    
        // Returns the number of days in the month given by the year and
        // month arguments for the specified era.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetDaysInMonth1"]/*' />
        public abstract int GetDaysInMonth(int year, int month, int era);
    
        // Returns the number of days in the year given by the year argument for the current era.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetDaysInYear"]/*' />
        public virtual int GetDaysInYear(int year)
        {
            return (GetDaysInYear(year, CurrentEra));
        }
    
        // Returns the number of days in the year given by the year argument for the current era.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetDaysInYear1"]/*' />
        public abstract int GetDaysInYear(int year, int era);
    
        // Returns the era for the specified DateTime value.
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetEra"]/*' />
        public abstract int GetEra(DateTime time);

        /*=================================Eras==========================
        **Action: Get the list of era values.
        **Returns: The int array of the era names supported in this calendar.
        **      null if era is not used.
        **Arguments: None.
        **Exceptions: None.
        ============================================================================*/
        
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.Eras"]/*' />
        public abstract int[] Eras {
            get;
        }
    

        // Returns the month part of the specified DateTime. The returned value is an
        // integer between 1 and 12.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetHour"]/*' />
        public virtual int GetHour(DateTime time) {
            return ((int)((time.Ticks / TicksPerHour) % 24));
        }

        // Returns the millisecond part of the specified DateTime. The returned value
        // is an integer between 0 and 999.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetMilliseconds"]/*' />
        public virtual double GetMilliseconds(DateTime time) {
            return (double)((time.Ticks / TicksPerMillisecond) % 1000);
        }

        // Returns the minute part of the specified DateTime. The returned value is
        // an integer between 0 and 59.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetMinute"]/*' />
        public virtual int GetMinute(DateTime time) {
            return ((int)((time.Ticks / TicksPerMinute) % 60));
        }
        
        // Returns the month part of the specified DateTime. The returned value is an
        // integer between 1 and 12.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetMonth"]/*' />
        public abstract int GetMonth(DateTime time);
    
        // Returns the number of months in the specified year in the current era.
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetMonthsInYear"]/*' />
        public virtual int GetMonthsInYear(int year)
        {
            return (GetMonthsInYear(year, CurrentEra));
        }
        
        // Returns the number of months in the specified year and era.
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetMonthsInYear1"]/*' />
        public abstract int GetMonthsInYear(int year, int era);
    
        // Returns the second part of the specified DateTime. The returned value is
        // an integer between 0 and 59.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetSecond"]/*' />
        public virtual int GetSecond(DateTime time) {
            return ((int)((time.Ticks / TicksPerSecond) % 60));
        }

        /*=================================GetFirstDayWeekOfYear==========================
        **Action: Get the week of year using the FirstDay rule.
        **Returns:  the week of year.
        **Arguments: 
        **  time  
        **  firstDayOfWeek  the first day of week (0=Sunday, 1=Monday, ... 6=Saturday)
        **Notes:
        **  The CalendarWeekRule.FirstDay rule: Week 1 begins on the first day of the year.
        **  Assume f is the specifed firstDayOfWeek,
        **  and n is the day of week for January 1 of the specified year.
        **  Assign offset = n - f;
        **  Case 1: offset = 0
        **      E.g.
        **                     f=1
        **          weekday 0  1  2  3  4  5  6  0  1
        **          date       1/1
        **          week#      1                    2
        **      then week of year = (GetDayOfYear(time) - 1) / 7 + 1
        **
        **  Case 2: offset < 0
        **      e.g.
        **                     n=1   f=3
        **          weekday 0  1  2  3  4  5  6  0
        **          date       1/1
        **          week#      1     2
        **      This means that the first week actually starts 5 days before 1/1.
        **      So week of year = (GetDayOfYear(time) + (7 + offset) - 1) / 7 + 1
        **  Case 3: offset > 0
        **      e.g.
        **                  f=0   n=2
        **          weekday 0  1  2  3  4  5  6  0  1  2
        **          date          1/1
        **          week#         1                    2
        **      This means that the first week actually starts 2 days before 1/1.
        **      So Week of year = (GetDayOfYear(time) + offset - 1) / 7 + 1
        ============================================================================*/
        
        internal int GetFirstDayWeekOfYear(DateTime time, int firstDayOfWeek) {
            int dayForJan1 = (int)GetDayOfWeek(ToDateTime(GetYear(time), 1, 1, 0, 0, 0, 0));
            int offset = dayForJan1 - firstDayOfWeek;
            
            if (offset < 0) {
                offset += 7;
            }

            return ((GetDayOfYear(time) + offset - 1) / 7 + 1);
        }
        
        internal int GetWeekOfYearFullDays(DateTime time, CalendarWeekRule rule, int firstDayOfWeek, int fullDays) {
            int dayForJan1;
            int offset;
            int year, month, day;
            
            year = GetYear(time);
            dayForJan1 = (int)GetDayOfWeek(ToDateTime(year, 1, 1,0,0,0,0));
            //
            // Calculate the number of days between the first day of year and the first day of the first week.
            //
            offset = firstDayOfWeek - dayForJan1;
            if (offset != 0)
            {
                if (offset < 0) {
                    offset += 7;
                }
                //
                // If the offset is greater than the value of fullDays, it means that
                // the first week of the year starts on the week where Jan/1 falls on.
                //
                if (offset >= fullDays) {
                    offset -= 7;
                }
            }
            //
            // Calculate the day of year for specified time by taking offset into account.
            //
            day = GetDayOfYear(time) - offset;
            if (day > 0) {
                //
                // If the day of year value is greater than zero, get the week of year.
                //
                return ((day - 1)/7 + 1);
            }
            //
            // Otherwise, the specified time falls on the week of previous year.
            // Call this method again by passing the last day of previous year.
            //
            year = GetYear(time)-1;
            month = GetMonthsInYear(year);
            day = GetDaysInMonth(year, month);
            return (GetWeekOfYearFullDays(ToDateTime(year, month, day,0,0,0,0), rule, firstDayOfWeek, fullDays));        
        }
        
        // Returns the week of year for the specified DateTime. The returned value is an
        // integer between 1 and 53.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetWeekOfYear"]/*' />
        public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
        {
            if ((int)firstDayOfWeek < 0 || (int)firstDayOfWeek > 6) {
                throw new ArgumentOutOfRangeException(
                    "firstDayOfWeek", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                    DayOfWeek.Sunday, DayOfWeek.Saturday));
            }        
            switch (rule) {
                case CalendarWeekRule.FirstDay:
                    return (GetFirstDayWeekOfYear(time, (int)firstDayOfWeek));
                case CalendarWeekRule.FirstFullWeek:
                    return (GetWeekOfYearFullDays(time, rule, (int)firstDayOfWeek, 7));
                case CalendarWeekRule.FirstFourDayWeek:
                    return (GetWeekOfYearFullDays(time, rule, (int)firstDayOfWeek, 4));
            }                    
            throw new ArgumentOutOfRangeException(
                "rule", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                CalendarWeekRule.FirstDay, CalendarWeekRule.FirstFourDayWeek));
            
        }
    
        // Returns the year part of the specified DateTime. The returned value is an
        // integer between 1 and 9999.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.GetYear"]/*' />
        public abstract int GetYear(DateTime time);
    
        // Checks whether a given day in the current era is a leap day. This method returns true if
        // the date is a leap day, or false if not.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.IsLeapDay"]/*' />
        public virtual bool IsLeapDay(int year, int month, int day)
        {
            return (IsLeapDay(year, month, day, CurrentEra));
        }
    
        // Checks whether a given day in the specified era is a leap day. This method returns true if
        // the date is a leap day, or false if not.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.IsLeapDay1"]/*' />
        public abstract bool IsLeapDay(int year, int month, int day, int era);
    
        // Checks whether a given month in the current era is a leap month. This method returns true if
        // month is a leap month, or false if not.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.IsLeapMonth"]/*' />
        public virtual bool IsLeapMonth(int year, int month) {
            return (IsLeapMonth(year, month, CurrentEra));
        }
        
        // Checks whether a given month in the specified era is a leap month. This method returns true if
        // month is a leap month, or false if not.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.IsLeapMonth1"]/*' />
        public abstract bool IsLeapMonth(int year, int month, int era);
    
        // Checks whether a given year in the current era is a leap year. This method returns true if
        // year is a leap year, or false if not.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.IsLeapYear"]/*' />
        public virtual bool IsLeapYear(int year)
        {
            return (IsLeapYear(year, CurrentEra));
        }
    
        // Checks whether a given year in the specified era is a leap year. This method returns true if
        // year is a leap year, or false if not.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.IsLeapYear1"]/*' />
        public abstract bool IsLeapYear(int year, int era);
    
        // Returns the date and time converted to a DateTime value.  Throws an exception if the n-tuple is invalid.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.ToDateTime"]/*' />
        public virtual DateTime ToDateTime(int year, int month,  int day, int hour, int minute, int second, int millisecond)
        {
            return (ToDateTime(year, month, day, hour, minute, second, millisecond, CurrentEra));
        }
        
        // Returns the date and time converted to a DateTime value.  Throws an exception if the n-tuple is invalid.
        //
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.ToDateTime1"]/*' />
        public abstract DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int nativeGetTwoDigitYearMax(int calID);
        
        // Returns and assigns the maximum value to represent a two digit year.  This 
        // value is the upper boundary of a 100 year range that allows a two digit year 
        // to be properly translated to a four digit year.  For example, if 2029 is the 
        // upper boundary, then a two digit value of 30 should be interpreted as 1930 
        // while a two digit value of 29 should be interpreted as 2029.  In this example
        // , the 100 year range would be from 1930-2029.  See ToFourDigitYear().
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.TwoDigitYearMax"]/*' />
        public virtual int TwoDigitYearMax
        {
            get
            {
                return (twoDigitYearMax);
            }
    
            set
            {
                twoDigitYearMax = value;
            }        
        }
    
        // Converts the year value to the appropriate century by using the 
        // TwoDigitYearMax property.  For example, if the TwoDigitYearMax value is 2029, 
        // then a two digit value of 30 will get converted to 1930 while a two digit 
        // value of 29 will get converted to 2029.
        /// <include file='doc\Calendar.uex' path='docs/doc[@for="Calendar.ToFourDigitYear"]/*' />
        public virtual int ToFourDigitYear(int year) {
            if (year < 0) {
                throw new ArgumentOutOfRangeException("year",
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));                
            }
            if (year < 100) {
                int y = year % 100;
                return ((TwoDigitYearMax/100 - ( y > TwoDigitYearMax % 100 ? 1 : 0))*100 + y);
            }
            // If the year value is above 100, just return the year value.  Don't have to do
            // the TwoDigitYearMax comparison.
            return (year);
        }    

        // Return the tick count corresponding to the given hour, minute, second.
        // Will check the if the parameters are valid.
        internal static long TimeToTicks(int hour, int minute, int second, int millisecond)
        {
            if (hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >=0 && second < 60)
            {
                if (millisecond < 0 || millisecond >= MillisPerSecond) {
                    throw new ArgumentOutOfRangeException("millisecond", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 0, MillisPerSecond - 1));
                }            
                return TimeSpan.TimeToTicks(hour, minute, second) + + millisecond * TicksPerMillisecond;
            }
            throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_BadHourMinuteSecond"));
        }

        private const String TwoDigitYearMaxSubKey = "Control Panel\\International\\Calendars\\TwoDigitYearMax";

        internal static int GetSystemTwoDigitYearSetting(int CalID, int defaultYearValue) {
            //
            // Call Win32 ::GetCalendarInfo() to retrieve CAL_ITWODIGITYEARMAX value.
            // This function only exists after Windows 98 and Windows 2000.
            //

            int twoDigitYearMax = nativeGetTwoDigitYearMax(CalID);
            if (twoDigitYearMax < 0) {
                //
                // The Win32 call fails, use the registry setting instead.
                //
                Microsoft.Win32.RegistryKey key = null;

                try { 
                    key = Microsoft.Win32.Registry.CurrentUser.InternalOpenSubKey(TwoDigitYearMaxSubKey, false);
                } catch (Exception) {
                    //If this fails for any reason, we'll just keep going anyway.
                }
                if (key != null) {
                    Object value = key.InternalGetValue(CalID.ToString(), null, false);
                    if (value != null) {
                        try {
                            twoDigitYearMax = Int32.Parse(value.ToString(), CultureInfo.InvariantCulture);
                        } catch (Exception) {
                            //
                            // If error happens in parsing the string. Leave as it is. We will 
                            // set twoDigitYearMax to the default value later.
                            //
                        }
                    }
                    key.Close();
                } 

                if (twoDigitYearMax < 0)
                {
                    twoDigitYearMax = defaultYearValue;
                }                        
            }
            return (twoDigitYearMax);
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\datetimeformat.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    using System.Text;
    using System.Threading;
    using System.Globalization;
    using ArrayList = System.Collections.ArrayList;
    /*  
     Customized format patterns:
     P.S. Format in the table below is the internal number format used to display the pattern.

     Patterns   Format      Description                           Example
     =========  ==========  ===================================== ========
        "h"     "0"         hour (12-hour clock)w/o leading zero  3
        "hh"    "00"        hour (12-hour clock)with leading zero 03
        "hh*"   "00"        hour (12-hour clock)with leading zero 03

        "H"     "0"         hour (24-hour clock)w/o leading zero  8
        "HH"    "00"        hour (24-hour clock)with leading zero 08
        "HH*"   "00"        hour (24-hour clock)                  08

        "m"     "0"         minute w/o leading zero
        "mm"    "00"        minute with leading zero
        "mm*"   "00"        minute with leading zero

        "s"     "0"         second w/o leading zero
        "ss"    "00"        second with leading zero
        "ss*"   "00"        second with leading zero

        "f"     "0"         second fraction (1 digit)
        "ff"    "00"        second fraction (2 digit)
        "fff"   "000"       second fraction (3 digit)
        "ffff"  "0000"      second fraction (4 digit)
        "fffff" "00000"         second fraction (5 digit)
        "ffffff"    "000000"    second fraction (6 digit)
        "fffffff"   "0000000"   second fraction (7 digit)

        "t"                 first character of AM/PM designator   A
        "tt"                AM/PM designator                      AM
        "tt*"               AM/PM designator                      PM

        "d"     "0"         day w/o leading zero                  1
        "dd"    "00"        day with leading zero                 01
        "ddd"               short weekday name (abbreviation)     Mon
        "dddd"              full weekday name                     Monday
        "dddd*"             full weekday name                     Monday
        

        "M"     "0"         month w/o leading zero                2
        "MM"    "00"        month with leading zero               02
        "MMM"               short month name (abbreviation)       Feb
        "MMMM"              full month name                       Febuary
        "MMMM*"             full month name                       Febuary
       
        "y"     "0"         two digit year (year % 100) w/o leading zero           0
        "yy"    "00"        two digit year (year % 100) with leading zero          00
        "yyy"   "D3"        year                                  2000
        "yyyy"  "D4"        year                                  2000
        "yyyyy" "D5"        year                                  2000
        ...

        "z"     "+0;-0"     timezone offset w/o leading zero      -8
        "zz"    "+00;-00"   timezone offset with leading zero     -08
        "zzz"   "+00;-00" for hour offset, "00" for minute offset   full timezone offset   -08:00
        "zzz*"  "+00;-00" for hour offset, "00" for minute offset   full timezone offset   -08:00

        "g*"                the current era name                  A.D.

        ":"                 time separator                        :
        "/"                 date separator                        /
        "'"                 quoted string                         'ABC' will insert ABC into the formatted string.
        '"'                 quoted string                         "ABC" will insert ABC into the formatted string.
        "%"                 used to quote a single pattern characters      E.g.The format character "%y" is to print two digit year.
        "\"                 escaped character                     E.g. '\d' insert the character 'd' into the format string.
        other characters    insert the character into the format string. 

    Pre-defined format characters: 
        (U) to indicate Universal time is used.
        (G) to indicate Gregorian calendar is used.
    
        Format              Description                             Real format                             Example
        =========           =================================       ======================                  =======================
        "d"                 short date                              culture-specific                        10/31/1999
        "D"                 long data                               culture-specific                        Sunday, October 31, 1999
        "f"                 full date (long date + short time)      culture-specific                        Sunday, October 31, 1999 2:00 AM
        "F"                 full date (long date + long time)       culture-specific                        Sunday, October 31, 1999 2:00:00 AM
        "g"                 general date (short date + short time)  culture-specific                        10/31/1999 2:00 AM
        "G"                 general date (short date + long time)   culture-specific                        10/31/1999 2:00:00 AM
        "m"/"M"             Month/Day date                          culture-specific                        October 31
(G)     "r"/"R"             RFC 1123 date,                          "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'"   Sun, 31 Oct 1999 10:00:00 GMT
(G)     "s"                 Sortable format, based on ISO 8601.     "yyyy-MM-dd'T'HH:mm:ss"                 1999-10-31T02:00:00
                                                                    ('T' for local time)
        "t"                 short time                              culture-specific                        2:00 AM
        "T"                 long time                               culture-specific                        2:00:00 AM
(G)     "u"                 Universal time with sortable format,    "yyyy'-'MM'-'dd HH':'mm':'ss'Z'"        1999-10-31 10:00:00Z
                            based on ISO 8601.
(U)     "U"                 Universal time with full                culture-specific                        Sunday, October 31, 1999 10:00:00 AM
                            (long date + long time) format
                            "y"/"Y"             Year/Month day                          culture-specific                        October, 1999

    */    

    //This class contains only static members and does not require the serializable attribute.    
    internal 
    class DateTimeFormat {
        
        internal const int MaxSecondsFractionDigits = 7;
        
        internal static char[] allStandardFormats = 
        {
            'd', 'D', 'f', 'F', 'g', 'G', 
            'm', 'M', 'r', 'R', 's', 't', 
            'T', 'u', 'U', 'y', 'Y',
        };
    
        private const int DEFAULT_ALL_DATETIMES_SIZE = 132; 

        private unsafe static void FormatDigits(StringBuilder outputBuffer, int digits, int repeat) {
            // Limit the use of this function to be two-digits, so that we have the same behavior
            // as RTM bits.
            if (repeat > 2)
            {
                repeat = 2;
            }
            char* buffer = stackalloc char[16];
            char* p = buffer + 16;
            int n = digits;
            do {
                *--p = (char)(n % 10 + '0');
                n /= 10;
            } while ((n != 0)&&(p > buffer));
            
            int length = (int) (buffer + 16 - p);

            //If the repeat count is greater than 0, we're trying
            //to emulate the "00" format, so we have to prepend
            //a zero if the string only has one character.
            while ((length < repeat) && (p > buffer)) {
                *--p='0';
                length++;
            }
            outputBuffer.Append(p, length);
        }

        private unsafe static void HebrewFormatDigits(StringBuilder outputBuffer, int digits) {
            outputBuffer.Append(HebrewCalendar.NumberToHebrewLetter(digits));
        }

        static int ParseRepeatPattern(String format, int pos, char patternChar)
        {
            int len = format.Length;
            int index = pos + 1;
            while ((index < len) && (format[index] == patternChar)) 
            {
               index++;
            }    
            return (index - pos);
        }
        
        private static String FormatDayOfWeek(int dayOfWeek, int repeat, DateTimeFormatInfo dtfi)
        {
            BCLDebug.Assert(dayOfWeek >= 0 && dayOfWeek <= 6, "dayOfWeek >= 0 && dayOfWeek <= 6");
            if (repeat == 3)
            {            
                return (dtfi.GetAbbreviatedDayName((DayOfWeek)dayOfWeek));
            }
            // Call dtfi.GetDayName() here, instead of accessing DayNames property, because we don't
            // want a clone of DayNames, which will hurt perf.
            return (dtfi.GetDayName((DayOfWeek)dayOfWeek));
        }
    
        private static String FormatMonth(int month, int repeatCount, DateTimeFormatInfo dtfi)
        {
            BCLDebug.Assert(month >=1 && month <= 12, "month >=1 && month <= 12");
            if (repeatCount == 3)
            {
                return (dtfi.GetAbbreviatedMonthName(month));
            }
            // Call GetMonthName() here, instead of accessing MonthNames property, because we don't
            // want a clone of MonthNames, which will hurt perf.
            return (dtfi.GetMonthName(month));
        }

        //
        //  FormatHebrewMonthName
        //
        //  Action: Return the Hebrew month name for the specified DateTime.
        //  Returns: The month name string for the specified DateTime.
        //  Arguments: 
        //        time   the time to format
        //        month  The month is the value of HebrewCalendar.GetMonth(time).         
        //        repeat Return abbreviated month name if repeat=3, or full month name if repeat=4
        //        dtfi    The DateTimeFormatInfo which uses the Hebrew calendars as its calendar.
        //  Exceptions: None.
        // 
        
        /* Note:
            If DTFI is using Hebrew calendar, GetMonthName()/GetAbbreviatedMonthName() will return month names like this:            
            1   Hebrew 1st Month
            2   Hebrew 2nd Month
            ..  ...
            6   Hebrew 6th Month
            7   Hebrew 6th Month II (used only in a leap year)
            8   Hebrew 7th Month
            9   Hebrew 8th Month
            10  Hebrew 9th Month
            11  Hebrew 10th Month
            12  Hebrew 11th Month
            13  Hebrew 12th Month

            Therefore, if we are in a regular year, we have to increment the month name if moth is greater or eqaul to 7.            
        */
        private static String FormatHebrewMonthName(DateTime time, int month, int repeatCount, DateTimeFormatInfo dtfi)
        {
            BCLDebug.Assert(repeatCount != 3 || repeatCount != 4, "repeateCount should be 3 or 4");
            if (dtfi.Calendar.IsLeapYear(dtfi.Calendar.GetYear(time))) {
                // This month is in a leap year
                return (dtfi.internalGetMonthName(month, MonthNameStyles.LeapYear, (repeatCount == 3)));
            }
            // This is in a regular year.
            if (month >= 7) {
                month++;
            }
            if (repeatCount == 3) {
                return (dtfi.GetAbbreviatedMonthName(month));
            }
            return (dtfi.GetMonthName(month));
        }
    
        //
        // The pos should point to a quote character. This method will
        // get the string encloed by the quote character.
        //
        internal static int ParseQuoteString(String format, int pos, StringBuilder result)
        {
            //
            // NOTE yslin: pos will be the index of the quote character in the 'format' string.
            //
            int formatLen = format.Length;
            int beginPos = pos;
            char quoteChar = format[pos++]; // Get the character used to quote the following string.
    
            bool foundQuote = false;
            while (pos < formatLen)
            {
                char ch = format[pos++];        
                if (ch == quoteChar)
                {
                    foundQuote = true;
                    break;
                }
                else if (ch == '\\') {
                    // The following are used to support escaped character.
                    // Escaped character is also supported in the quoted string.
                    // Therefore, someone can use a format like "'minute:' mm\"" to display:
                    //  minute: 45"
                    // because the second double quote is escaped.
                    if (pos < formatLen) {
                        result.Append(format[pos++]);
                    } else {
                            //
                            // This means that '\' is at the end of the formatting string.
                            //
                            throw new FormatException(Environment.GetResourceString("Format_InvalidString"));
                    }                    
                } else {
                    result.Append(ch);
                }
            }
            
            if (!foundQuote)
            {
                // Here we can't find the matching quote.
                throw new FormatException(String.Format(Environment.GetResourceString("Format_BadQuote"), quoteChar));
            }
            
            //
            // Return the character count including the begin/end quote characters and enclosed string.
            //
            return (pos - beginPos);
        }
    
        //
        // Get the next character at the index of 'pos' in the 'format' string.
        // Return value of -1 means 'pos' is already at the end of the 'format' string.
        // Otherwise, return value is the int value of the next character.
        //
        private static int ParseNextChar(String format, int pos)
        {
            if (pos >= format.Length - 1)
            {
                return (-1);
            }
            return ((int)format[pos+1]);
        }

        //
        //  IsUseGenitiveForm
        //
        //  Actions: Check the format to see if we should use genitive month in the formatting.
        //      Starting at the position (index) in the (format) string, look back and look ahread to
        //      see if there is "d" or "dd".  In the case like "d MMMM" or "MMMM dd", we can use 
        //      genitive form.  Genitive form is not used if there is more than two "d".
        //  Arguments:
        //      format      The format string to be scanned.
        //      index       Where we should start the scanning.  This is generally where "M" starts.
        //      tokenLen    The len of the current pattern character.  This indicates how many "M" that we have.
        //      patternToMatch  The pattern that we want to search. This generally uses "d"
        //
        private static bool IsUseGenitiveForm(String format, int index, int tokenLen, char patternToMatch) {
            int i;
            int repeat = 0;
            //
            // Look back to see if we can find "d" or "ddd"
            //
            
            // Find first "d".
            for (i = index - 1; i >= 0 && format[i] != patternToMatch; i--) {  /*Do nothing here */ };
            
            if (i >= 0) {
                // Find a "d", so look back to see how many "d" that we can find.
                while (--i >= 0 && format[i] == patternToMatch) {
                    repeat++;
                }
                //
                // repeat == 0 means that we have one (patternToMatch)
                // repeat == 1 means that we have two (patternToMatch)
                //
                if (repeat <= 1) {
                    return (true);
                }
                // Note that we can't just stop here.  We may find "ddd" while looking back, and we have to look
                // ahead to see if there is "d" or "dd".
            }

            //
            // If we can't find "d" or "dd" by looking back, try look ahead.
            //

            // Find first "d"
            for (i = index + tokenLen; i < format.Length && format[i] != patternToMatch; i++) { /* Do nothing here */ };

            if (i < format.Length) {
                repeat = 0;
                // Find a "d", so contine the walk to see how may "d" that we can find.
                while (++i < format.Length && format[i] == patternToMatch) {
                    repeat++;
                }
                //
                // repeat == 0 means that we have one (patternToMatch)
                // repeat == 1 means that we have two (patternToMatch)
                //
                if (repeat <= 1) {
                    return (true);
                }
            }
            return (false);
        }

        //
        //  FormatCustomized
        //
        //  Actions: Format the DateTime instance using the specified format.
        // 
        private static String FormatCustomized(DateTime dateTime, String format, DateTimeFormatInfo dtfi) {
            Calendar cal = dtfi.Calendar;
            StringBuilder result = new StringBuilder();
            // This is a flag to indicate if we are format the dates using Hebrew calendar.

            bool isHebrewCalendar = (cal.ID == Calendar.CAL_HEBREW);
            // This is a flag to indicate if we are formating hour/minute/second only.
            bool bTimeOnly = true;
                        
            int i = 0;
            int tokenLen, hour12;
            
            while (i < format.Length) {
                char ch = format[i];
                int nextChar;
                switch (ch) {
                    case 'g':
                        tokenLen = ParseRepeatPattern(format, i, ch);
                        result.Append(dtfi.GetEraName(cal.GetEra(dateTime)));
                        break;
                    case 'h':
                        tokenLen = ParseRepeatPattern(format, i, ch);
                        hour12 = dateTime.Hour % 12;
                        if (hour12 == 0)
                        {
                            hour12 = 12;
                        }
                        FormatDigits(result, hour12, tokenLen);
                        break;
                    case 'H':
                        tokenLen = ParseRepeatPattern(format, i, ch);
                        FormatDigits(result, dateTime.Hour, tokenLen);
                        break;
                    case 'm':
                        tokenLen = ParseRepeatPattern(format, i, ch);
                        FormatDigits(result, dateTime.Minute, tokenLen);
                        break;
                    case 's':
                        tokenLen = ParseRepeatPattern(format, i, ch);
                        FormatDigits(result, dateTime.Second, tokenLen);
                        break;
                    case 'f':
                        tokenLen = ParseRepeatPattern(format, i, ch);
                        if (tokenLen <= MaxSecondsFractionDigits) {
                            long fraction = (dateTime.Ticks % Calendar.TicksPerSecond);
                            fraction = fraction / (long)Math.Pow(10, 7 - tokenLen);
                            result.Append(((int)fraction).ToString((new String('0', tokenLen))));
                        } else {
                            throw new FormatException(Environment.GetResourceString("Format_InvalidString"));
                        }
                        break;
                    case 't':
                        tokenLen = ParseRepeatPattern(format, i, ch);
                        if (tokenLen == 1)
                        {
                            if (dateTime.Hour < 12)
                            {
                                if (dtfi.AMDesignator.Length >= 1)
                                {
                                    result.Append(dtfi.AMDesignator[0]);
                                }
                            }
                            else
                            {
                                if (dtfi.PMDesignator.Length >= 1)
                                {
                                    result.Append(dtfi.PMDesignator[0]);
                                }
                            }
                            
                        }
                        else
                        {
                            result.Append((dateTime.Hour < 12 ? dtfi.AMDesignator : dtfi.PMDesignator));
                        }
                        break;
                    case 'd':
                        //
                        // tokenLen == 1 : Day of month as digits with no leading zero.
                        // tokenLen == 2 : Day of month as digits with leading zero for single-digit months.
                        // tokenLen == 3 : Day of week as a three-leter abbreviation.
                        // tokenLen >= 4 : Day of week as its full name.
                        //
                        tokenLen = ParseRepeatPattern(format, i, ch);
                        if (tokenLen <= 2)
                        {
                            int day = cal.GetDayOfMonth(dateTime);
                            if (isHebrewCalendar) {
                                // For Hebrew calendar, we need to convert numbers to Hebrew text for yyyy, MM, and dd values.
                                HebrewFormatDigits(result, day);
                            } else {
                                FormatDigits(result, day, tokenLen);
                            }
                        } 
                        else
                        {
                            int dayOfWeek = (int)cal.GetDayOfWeek(dateTime);
                            result.Append(FormatDayOfWeek(dayOfWeek, tokenLen, dtfi));
                        }
                        bTimeOnly = false;
                        break;
                    case 'M':
                        // 
                        // tokenLen == 1 : Month as digits with no leading zero.
                        // tokenLen == 2 : Month as digits with leading zero for single-digit months.
                        // tokenLen == 3 : Month as a three-letter abbreviation.
                        // tokenLen >= 4 : Month as its full name.
                        //
                        tokenLen = ParseRepeatPattern(format, i, ch);
                        int month = cal.GetMonth(dateTime);
                        if (tokenLen <= 2)
                        {
                            if (isHebrewCalendar) {
                                // For Hebrew calendar, we need to convert numbers to Hebrew text for yyyy, MM, and dd values.
                                HebrewFormatDigits(result, month);
                            } else {                        
                                FormatDigits(result, month, tokenLen);
                            }
                        } 
                        else {
                            if (isHebrewCalendar) {
                                result.Append(FormatHebrewMonthName(dateTime, month, tokenLen, dtfi));
                            } else {
                                if ((dtfi.FormatFlags & DateTimeFormatFlags.UseGenitiveMonth) != 0 && tokenLen >= 4) {
                                    result.Append(
                                        dtfi.internalGetMonthName(
                                            month, 
                                            IsUseGenitiveForm(format, i, tokenLen, 'd')? MonthNameStyles.Genitive : MonthNameStyles.Regular, 
                                            false));
                                } else {
                                    result.Append(FormatMonth(month, tokenLen, dtfi));
                                }
                            }
                        }
                        bTimeOnly = false;
                        break;
                    case 'y':
                        int year = cal.GetYear(dateTime);
                        tokenLen = ParseRepeatPattern(format, i, ch);
                        switch (cal.ID) {
                            // Add a special case for Japanese and Taiwan.  
                            // For Japanese calendar, always use two digit (with leading 0)
                            // For Taiwan calendar, do not truncate the year to only two 
                            // digits. If year 125, then output 125 and not 25.
                            case (Calendar.CAL_JAPAN):
                                FormatDigits(result, year, tokenLen <= 2 ? 2 : tokenLen);
                                break;
                            case (Calendar.CAL_TAIWAN):
                                if (tokenLen <= 2) {
                                    FormatDigits(result, year, 2);   
                                 } else {
                                    result.Append(year.ToString("D" + tokenLen));
                                 }
                                break;
                            case (Calendar.CAL_HEBREW):
                                HebrewFormatDigits(result, year);
                                break;
                            default:
                                if (tokenLen <= 2) {
                                    FormatDigits(result, year % 100, tokenLen);
                                } else {
                                    String fmtPattern = "D" + tokenLen;
                                    result.Append(year.ToString(fmtPattern));
                                }
                                break;
                        }
                        bTimeOnly = false;
                        break;
                    case 'z':
                        //
                        // Output the offset of the timezone according to the system timezone setting.
                        //
                        tokenLen = ParseRepeatPattern(format, i, ch);
                        TimeSpan offset;
                        if (bTimeOnly && dateTime.Ticks < Calendar.TicksPerDay) {
                            offset = TimeZone.CurrentTimeZone.GetUtcOffset(DateTime.Now);
                        } else {
                            offset = TimeZone.CurrentTimeZone.GetUtcOffset(dateTime);
                        }
    
                        switch (tokenLen)
                        {
                            case 1:
                                result.Append((offset.Hours).ToString("+0;-0"));
                                break;
                            case 2:
                                result.Append((offset.Hours).ToString("+00;-00"));
                                break;
                            default:
                                if (offset.Hours > 0) {
                                    result.Append(String.Format("+{0:00}:{1:00}", offset.Hours, offset.Minutes));
                                } else {
                                    // When the offset is negative, note that the offset.Minute is also negative.
                                    // So use should use -offset.Minute to get the postive value.
                                    result.Append(String.Format("-{0:00}:{1:00}", -offset.Hours, -offset.Minutes));
                                }
                                break;                        
                        }
                        break;
                    case ':':
                        result.Append(dtfi.TimeSeparator);
                        tokenLen = 1;
                        break;
                    case '/':
                        result.Append(dtfi.DateSeparator);
                        tokenLen = 1;
                        break;
                    case '\'':
                    case '\"':
                        StringBuilder enquotedString = new StringBuilder();
                        tokenLen = ParseQuoteString(format, i, enquotedString); 
                        result.Append(enquotedString);
                        break;
                    case '%':
                        // Optional format character.
                        // For example, format string "%d" will print day of month 
                        // without leading zero.  Most of the cases, "%" can be ignored.
                        nextChar = ParseNextChar(format, i);
                        // nextChar will be -1 if we already reach the end of the format string.
                        // Besides, we will not allow "%%" appear in the pattern.
                        if (nextChar >= 0 && nextChar != (int)'%') {
                            result.Append(FormatCustomized(dateTime, ((char)nextChar).ToString(), dtfi));
                            tokenLen = 2;
                        }
                        else
                        {
                            //
                            // This means that '%' is at the end of the format string or
                            // "%%" appears in the format string.
                            //
                            throw new FormatException(Environment.GetResourceString("Format_InvalidString"));
                        }
                        break;
                    case '\\':
                        // Escaped character.  Can be used to insert character into the format string.
                        // For exmple, "\d" will insert the character 'd' into the string.
                        //
                        // NOTENOTE yslin: we can remove this format character if we enforce the enforced quote 
                        // character rule.
                        // That is, we ask everyone to use single quote or double quote to insert characters,
                        // then we can remove this character.
                        //
                        nextChar = ParseNextChar(format, i);
                        if (nextChar >= 0)
                        {
                            result.Append(((char)nextChar));
                            tokenLen = 2;
                        } 
                        else
                        {
                            //
                            // This means that '\' is at the end of the formatting string.
                            //
                            throw new FormatException(Environment.GetResourceString("Format_InvalidString"));
                        }
                        break;
                    default:
                        // NOTENOTE yslin: we can remove this rule if we enforce the enforced quote 
                        // character rule.
                        // That is, if we ask everyone to use single quote or double quote to insert characters,
                        // then we can remove this default block.
                        result.Append(ch);
                        tokenLen = 1;
                        break;
                }
                i += tokenLen;
            }
            return (result.ToString());
        }
    
        internal static String GetRealFormat(String format, DateTimeFormatInfo dtfi)
        {
            String realFormat = null;
            
            switch (format[0])
            {
                case 'd':       // Short Date
                    realFormat = dtfi.ShortDatePattern;
                    break;
                case 'D':       // Long Date
                    realFormat = dtfi.LongDatePattern;
                    break;
                case 'f':       // Full (long date + short time)
                    realFormat = dtfi.LongDatePattern + " " + dtfi.ShortTimePattern;
                    break;
                case 'F':       // Full (long date + long time)
                    realFormat = dtfi.FullDateTimePattern;
                    break;
                case 'g':       // General (short date + short time)
                    realFormat = dtfi.GeneralShortTimePattern;
                    break;
                case 'G':       // General (short date + long time)
                    realFormat = dtfi.GeneralLongTimePattern;
                    break;
                case 'm':
                case 'M':       // Month/Day Date
                    realFormat = dtfi.MonthDayPattern;
                    break;
                case 'r':
                case 'R':       // RFC 1123 Standard                    
                    realFormat = dtfi.RFC1123Pattern;
                    break;
                case 's':       // Sortable without Time Zone Info
                    realFormat = dtfi.SortableDateTimePattern;
                    break;
                case 't':       // Short Time
                    realFormat = dtfi.ShortTimePattern;
                    break;
                case 'T':       // Long Time
                    realFormat = dtfi.LongTimePattern;
                    break;
                case 'u':       // Universal with Sortable format
                    realFormat = dtfi.UniversalSortableDateTimePattern;
                    break;
                case 'U':       // Universal with Full (long date + long time) format
                    realFormat = dtfi.FullDateTimePattern;
                    break;
                case 'y':
                case 'Y':       // Year/Month Date
                    realFormat = dtfi.YearMonthPattern;
                    break;
                default:
                    throw new FormatException(Environment.GetResourceString("Format_InvalidString"));
            }
            return (realFormat);
        }    

        // Expand a pre-defined format string (like "D" for long date) to the real format that
        // we are going to use in the date time parsing.
        // This method also convert the dateTime if necessary (e.g. when the format is in Universal time),
        // and change dtfi if necessary (e.g. when the format should use invariant culture).
        //
        private static String ExpandPredefinedFormat(String format, ref DateTime dateTime, ref DateTimeFormatInfo dtfi) {
            switch (format[0]) {
                case 'r':
                case 'R':       // RFC 1123 Standard                    
//                    dateTime = dateTime.ToUniversalTime();                        
                    dtfi = DateTimeFormatInfo.InvariantInfo;
                    break;
                case 's':       // Sortable without Time Zone Info                
                    dtfi = DateTimeFormatInfo.InvariantInfo;
                    break;                    
                case 'u':       // Universal time in sortable format.
//                    dateTime = dateTime.ToUniversalTime();                        
                    // Universal time is always in Greogrian calendar.
                    dtfi = DateTimeFormatInfo.InvariantInfo;
                    break;
                case 'U':       // Universal time in culture dependent format.
                    // Universal time is always in Greogrian calendar.
                    //
                    // A beta 2 DCR enables us to set the Calendar in DTFI directly.  Make use of this in here
                    // to change the Calendar to be Gregorian Calendar.
                    //
                    dtfi = (DateTimeFormatInfo)dtfi.Clone();
                    if (dtfi.Calendar.GetType() != typeof(GregorianCalendar)) {
                        dtfi.Calendar = GregorianCalendar.GetDefaultInstance();
                    }
                    dateTime = dateTime.ToUniversalTime();
                    break;
            }
            format = GetRealFormat(format, dtfi);
            return (format);
        }
        
        internal static String Format(DateTime dateTime, String format, DateTimeFormatInfo dtfi)
        {            
            if (format==null || format.Length==0) {
                format = "G";            
                if (dateTime.Ticks < Calendar.TicksPerDay) {
                    // BUG 86635
                    // If the time is less than 1 day, consider it as time of day.
                    // Just print out the short time format.
                    //
                    // This is a workaround for VB, since they use ticks less then one day to be 
                    // time of day.  In cultures which use calendar other than Gregorian calendar, these
                    // alternative calendar may not support ticks less than a day.
                    // For example, Japanese calendar only supports date after 1868/9/8.
                    // This will pose a problem when people in VB get the time of day, and use it
                    // to call ToString(), which will use the general format (short date + long time).
                    // Since Japanese calendar does not support Gregorian year 0001, an exception will be
                    // thrown when we try to get the Japanese year for Gregorian year 0001.
                    // Therefore, the workaround allows them to call ToString() for time of day from a DateTime by
                    // formatting as ISO 8601 format.
                    switch (dtfi.Calendar.ID) {
                        case Calendar.CAL_JAPAN: 
                        case Calendar.CAL_TAIWAN:
                        case Calendar.CAL_HIJRI:
                        case Calendar.CAL_HEBREW:
                        case Calendar.CAL_JULIAN:
                            format = "s";
                            break;                        
                    }
                }
            }            

            if (format.Length == 1) {
                format = ExpandPredefinedFormat(format, ref dateTime, ref dtfi);
            } 
            
            return (FormatCustomized(dateTime, format, dtfi));
        }
    
        internal static String[] GetAllDateTimes(DateTime dateTime, char format, DateTimeFormatInfo dtfi)
        {
            String [] allFormats    = null;
            String [] results       = null;
            
            switch (format)
            {
                case 'd':
                case 'D':                            
                case 'f':
                case 'F':
                case 'g':
                case 'G':
                case 'm':
                case 'M':
                case 't':
                case 'T':                
                case 'y':
                case 'Y':
                    allFormats = dtfi.GetAllDateTimePatterns(format);
                    results = new String[allFormats.Length];
                    for (int i = 0; i < allFormats.Length; i++)
                    {
                        results[i] = Format(dateTime, allFormats[i], dtfi);
                    }
                    break;
                case 'U':
                    DateTime universalTime = dateTime.ToUniversalTime();
                    allFormats = dtfi.GetAllDateTimePatterns(format);
                    results = new String[allFormats.Length];
                    for (int i = 0; i < allFormats.Length; i++)
                    {
                        results[i] = Format(universalTime, allFormats[i], dtfi);
                    }
                    break;                
                //
                // The following ones are special cases because these patterns are read-only in
                // DateTimeFormatInfo.
                //
                case 'r':
                case 'R':
                case 's':
                case 'u':            
                    results = new String[] {Format(dateTime, new String(new char[] {format}), dtfi)};
                    break;            
                default:
                    throw new FormatException(Environment.GetResourceString("Format_InvalidString"));
                
            }
            return (results);
        }
    
        internal static String[] GetAllDateTimes(DateTime dateTime, DateTimeFormatInfo dtfi)
        {
            ArrayList results = new ArrayList(DEFAULT_ALL_DATETIMES_SIZE);
            
            for (int i = 0; i < allStandardFormats.Length; i++)
            {
                String[] strings = GetAllDateTimes(dateTime, allStandardFormats[i], dtfi);
                for (int j = 0; j < strings.Length; j++)
                {
                    results.Add(strings[j]);
                }
            }
            String[] value = new String[results.Count];
            results.CopyTo(0, value, 0, results.Count);
            return (value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\culturetypes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// The enumeration constants used in CultureInfo.GetCultures().
//
namespace System.Globalization {    

    /// <include file='doc\CultureTypes.uex' path='docs/doc[@for="CultureTypes"]/*' />
    [Flags, Serializable]
    public enum CultureTypes {
        /// <include file='doc\CultureTypes.uex' path='docs/doc[@for="CultureTypes.NeutralCultures"]/*' />
        NeutralCultures = 0x0001,   // Get all neutral cultures.  Neutral cultures are cultures like "en", "de", "zh", etc.
        /// <include file='doc\CultureTypes.uex' path='docs/doc[@for="CultureTypes.SpecificCultures"]/*' />
        SpecificCultures = 0x0002,              // Get all non-netural cultuers.  Examples are "en-us", "zh-tw", etc.
        /// <include file='doc\CultureTypes.uex' path='docs/doc[@for="CultureTypes.InstalledWin32Cultures"]/*' />
        InstalledWin32Cultures = 0x0004,        // Get all Win32 installed cultures in the system.
        /// <include file='doc\CultureTypes.uex' path='docs/doc[@for="CultureTypes.AllCultures"]/*' />
        AllCultures = NeutralCultures | SpecificCultures | InstalledWin32Cultures,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\characterinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Class:    CharacterInfo
//
//  Author:   Julie Bennett (JulieB)
//
//  Purpose:  This class implements a set of methods for retrieving
//            character type information.  Character type information is
//            independent of culture and region.
//
//  Date:     August 12, 1998
//
////////////////////////////////////////////////////////////////////////////

namespace System.Globalization {
    
    //This class has only static members and therefore doesn't need to be serialized.
    
    using System;
	using System.Runtime.CompilerServices;

	// Only statics, does not need to be marked with the serializable attribute
    internal class CharacterInfo : System.Object
    {
        //--------------------------------------------------------------------//
        //                        Internal Information                        //
        //--------------------------------------------------------------------//
    
        //
        // Native methods to access the Unicode category data tables in charinfo.nlp.
        // 
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void nativeInitTable();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern byte* nativeGetCategoryDataTable();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern ushort* nativeGetCategoryLevel2Offset();
        
        //
        // Native methods to access the Unicode numeric data tables in charinfo.nlp.
        // 
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern byte* nativeGetNumericDataTable();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern ushort* nativeGetNumericLevel2Offset();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern double* nativeGetNumericFloatData();
    
        internal const char  HIGH_SURROGATE_START  = '\ud800';
        internal const char  HIGH_SURROGATE_END    = '\udbff';
        internal const char  LOW_SURROGATE_START   = '\udc00';
        internal const char  LOW_SURROGATE_END     = '\udfff';

        unsafe static byte* m_pDataTable;
        unsafe static ushort* m_pLevel2WordOffset;

        unsafe static byte* m_pNumericDataTable = null;
        unsafe static ushort* m_pNumericLevel2WordOffset = null;
        unsafe static double* m_pNumericFloatData = null;
        
        //We need to allocate the underlying table that provides us with the information that we
        //use.  We allocate this once in the class initializer and then we don't need to worry 
        //about it again.  
        //
        //with AppDomains active, the static initializer is no longer good enough to ensure that only one
        //thread is ever in the native code at a given time.  For Beta1, we'll lock on the type
        //of CharacterInfo because type objects are bled across AppDomains.
        //@Consider[YSLin, JRoxe]: Investigate putting this synchronization in native code.
        unsafe static CharacterInfo() {
            lock(typeof(CharacterInfo)) {
                //NativeInitTable checks if an instance of the table has already been allocated, so
                //this initializer is idempotent once we guarantee that threads are only in here
                //one at a time.
                nativeInitTable();
                m_pDataTable = nativeGetCategoryDataTable();
                m_pLevel2WordOffset = nativeGetCategoryLevel2Offset();            
            }
        }
    

        private CharacterInfo() {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_Constructor"));
        }

        ////////////////////////////////////////////////////////////////////////
        //
        //  IsLetter
        //
        //  Determines if the given character is an alphabetic character.
        //
        ////////////////////////////////////////////////////////////////////////
    
        public static bool IsLetter(char ch) {
            UnicodeCategory uc = GetUnicodeCategory(ch);
            return (uc == UnicodeCategory.UppercaseLetter 
                 || uc == UnicodeCategory.LowercaseLetter 
                 || uc == UnicodeCategory.TitlecaseLetter 
                 || uc == UnicodeCategory.ModifierLetter 
                 || uc == UnicodeCategory.OtherLetter);
        }

     
         ////////////////////////////////////////////////////////////////////////
        //
        //  IsLower
        //
        //  Determines if the given character is a lower case character.
        //
        ////////////////////////////////////////////////////////////////////////
    
        public static bool IsLower(char c)
        {
            return (GetUnicodeCategory(c) == UnicodeCategory.LowercaseLetter);
        }    

          
        /*=================================IsMark==========================
        **Action: Returns true if and only if the character c has one of the properties NonSpacingMark, SpacingCombiningMark, 
        ** or EnclosingMark. Marks usually modify one or more other 
        **Returns:
        **Arguments:
        **Exceptions:
        ============================================================================*/

        public static bool IsMark(char ch) {
            UnicodeCategory uc = GetUnicodeCategory(ch);
            return (uc == UnicodeCategory.NonSpacingMark 
                || uc == UnicodeCategory.SpacingCombiningMark 
                || uc == UnicodeCategory.EnclosingMark);
        }

        /*=================================IsNumber==========================
        **Action: Returns true if and only if the character c has one of the properties DecimalDigitNumber, 
        ** LetterNumber, or OtherNumber. Use the GetNumericValue method to determine the numeric value.
        **Returns:
        **Arguments:
        **Exceptions:
        **Note: GetNuemricValue is not yet implemented.        
        ============================================================================*/
        public static bool IsNumber(char ch) {
            UnicodeCategory uc = GetUnicodeCategory(ch);
            return (uc == UnicodeCategory.DecimalDigitNumber 
                || uc == UnicodeCategory.LetterNumber 
                || uc == UnicodeCategory.OtherNumber);
        }

        /*=================================IsDigit==========================
        **Action: Returns true if and only if the character c has the property DecimalDigitNumber. 
        ** Use the GetNumericValue method to determine the numeric value.
        **Returns:
        **Arguments:
        **Exceptions:
        **Note: GetNuemricValue is not yet implemented.
        ============================================================================*/

        public static bool IsDigit(char ch) {
            UnicodeCategory uc = GetUnicodeCategory(ch);
            return (uc == UnicodeCategory.DecimalDigitNumber);        
        }   

        /*=================================IsSeparator==========================
        **Action: Returns true if and only if the character c has one of the properties SpaceSeparator, LineSeparator 
        **or ParagraphSeparator.
        **Returns:
        **Arguments:
        **Exceptions:
        ============================================================================*/
        public static bool IsSeparator(char ch) {
            UnicodeCategory uc = GetUnicodeCategory(ch);
            return (uc == UnicodeCategory.SpaceSeparator || uc == UnicodeCategory.LineSeparator || uc == UnicodeCategory.ParagraphSeparator);
        }

        /*=================================IsControl==========================
        **Action: Returns true if and only if the character c has the property Control.
        **Returns:
        **Arguments:
        **Exceptions:
        ============================================================================*/

        public static bool IsControl(char ch) {
            return (GetUnicodeCategory(ch) == UnicodeCategory.Control);
        }

        /*=================================IsSurrogate==========================
        **Action: Returns true if and only if the character c has the property PrivateUse.
        **Returns:
        **Arguments:
        **Exceptions:
        ============================================================================*/

        public static bool IsSurrogate(char ch) {
            return (GetUnicodeCategory(ch) == UnicodeCategory.Surrogate);
        }
            
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  IsPrivateUse
        //
        //  Determines if the given character is a private use character.  The
        //  private use characters are in the range 0xe000 - 0xf8ff.
        //
        ////////////////////////////////////////////////////////////////////////
    
        internal static bool IsPrivateUse(char ch)
        {
            return (GetUnicodeCategory(ch) == UnicodeCategory.PrivateUse);
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  IsPunctuation
        //
        //  Determines if the given character is a punctuation character.
        //
        ////////////////////////////////////////////////////////////////////////
    
        public static bool IsPunctuation(char ch)
        {
            UnicodeCategory uc = GetUnicodeCategory(ch);
            switch (uc) {
                case UnicodeCategory.ConnectorPunctuation:
                case UnicodeCategory.DashPunctuation:
                case UnicodeCategory.OpenPunctuation:
                case UnicodeCategory.ClosePunctuation:
                case UnicodeCategory.InitialQuotePunctuation:
                case UnicodeCategory.FinalQuotePunctuation:
                case UnicodeCategory.OtherPunctuation:
                    return (true);
            }
            return (false);
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  IsSymbol
        //
        //  Determines if the given character is a symbol character.
        //
        ////////////////////////////////////////////////////////////////////////
    
        public static bool IsSymbol(char ch)
        {
            UnicodeCategory uc = GetUnicodeCategory(ch);
            return (uc == UnicodeCategory.MathSymbol 
                || uc == UnicodeCategory.CurrencySymbol 
                || uc == UnicodeCategory.ModifierSymbol 
                || uc == UnicodeCategory.OtherSymbol);
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  IsTitleCase
        //
        //  Determines if the given character is a title case character.
        //  The title case characters are:
        //      \u01c5  (Dz with Caron)
        //      \u01c8  (Lj)
        //      \u01cb  (Nj)
        //      \u01f2  (Dz)
        //  A title case character is a concept that is useful for only 4
        //  Unicode characters.  This has to do with the mapping of some
        //  Cyrillic/Serbian characters to the Latin alphabet.  For example,
        //  the Cyrillic character LJ looks just like 'L' and 'J' in the Latin
        //  alphabet.  However, when LJ is used in a book title, the
        //  capitalized form is 'Lj' instead of 'LJ'.
        //
        //  These 4 characters are the only ones in Unicode that have a
        //  character type of both Upper and Lower case.
        //
        ////////////////////////////////////////////////////////////////////////
    
        internal static bool IsTitleCase(char c)
        {
            return (GetUnicodeCategory(c) == UnicodeCategory.TitlecaseLetter);
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  IsUpper
        //
        //  Determines if the given character is an upper case character.
        //
        ////////////////////////////////////////////////////////////////////////
    
        public static bool IsUpper(char c)
        {
            return (GetUnicodeCategory(c) == UnicodeCategory.UppercaseLetter);
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  WhiteSpaceChars
        //
        ////////////////////////////////////////////////////////////////////////
    
        internal static readonly char [] WhitespaceChars =
            { '\x9', '\xA', '\xB', '\xC', '\xD', '\x20', '\xA0',
              '\x2000', '\x2001', '\x2002', '\x2003', '\x2004', '\x2005',
              '\x2006', '\x2007', '\x2008', '\x2009', '\x200A', '\x200B',
              '\x3000', '\xFEFF' };
    
        // BUGBUG YSLin: Leave this for now because System.Char still has this funciton.
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  IsWhiteSpace
        //
        //  Determines if the given character is a white space character.
        //
        ////////////////////////////////////////////////////////////////////////
    
        public static bool IsWhiteSpace(char c)
        {
            // NOTENOTE YSLin:
            // There are characters which belong to UnicodeCategory.Control but are considered as white spaces.
            // We use code point comparisons for these characters here as a temporary fix.
            // The compiler should be smart enough to do a range comparison to optimize this (U+0009 ~ U+000d).
            // Also provide a shortcut here for the space character (U+0020)
            switch (c) {
                case ' ':
                case '\x0009' :
                case '\x000a' :
                case '\x000b' :
                case '\x000c' :
                case '\x000d' :
                case '\x0085' :
                    return (true);
            }

            // In Unicode 3.0, U+2028 is the only character which is under the category "LineSeparator".  
            // And U+2029 is th eonly character which is under the category "ParagraphSeparator".
            switch ((int)GetUnicodeCategory(c)) {
                case ((int)UnicodeCategory.SpaceSeparator):
                case ((int)UnicodeCategory.LineSeparator):
                case ((int)UnicodeCategory.ParagraphSeparator):
                    return (true);
            }
            
            return (false);               
        }
         
        //
        // This exists so that I don't have to mark GetNumericValue as being unsafe.
        // The transition from safe to unsafe is something that we don't want untrusted code
        // to have to do.
        //
        internal unsafe static double InternalGetNumericValue(char ch)
        {
            //
            // If we haven't get the unsafe pointers to the numeric table before, do it now.
            //            
            if (m_pNumericDataTable == null) {
                m_pNumericLevel2WordOffset = nativeGetNumericLevel2Offset();
                m_pNumericFloatData = nativeGetNumericFloatData();
                m_pNumericDataTable = nativeGetNumericDataTable();
            }
            // Get the level 2 item from the highest 8 bit (8 - 15) of ch.
            byte index1 = m_pNumericDataTable[ch >> 8];
            // Get the level 2 WORD offset from the 4 - 7 bit of ch.  This provides the base offset of the level 3 table.
            // The offset is referred to an float item in m_pNumericFloatData.
            // Note that & has the lower precedence than addition, so don't forget the parathesis.            
            ushort offset = m_pNumericLevel2WordOffset[(index1 << 4) + ((ch >> 4) & 0x000f)];
            // Get the result from the 0 -3 bit of ch.
            return (m_pNumericFloatData[offset + (ch & 0x000f)]);
        }
        
        /*=================================GetNumericValue==========================
        **Action: Returns the numeric value associated with the character c. If the character is a fraction, 
        ** the return value will not be an integer. If the character does not have a numeric value, the return value is -1.
        **Returns: 
        **  the numeric value for the specified Unicode character.  If the character does not have a numeric value, the return value is -1.
        **Arguments:
        **      ch  a Unicode character
        **Exceptions:
        **      None
        ============================================================================*/

        public static double GetNumericValue(char ch) {
            return (InternalGetNumericValue(ch));
        }            
 
        //
        // This exists so that I don't have to mark GetUnicodeCategory as being unsafe.
        // The transition from safe to unsafe is something that we don't want untrusted code
        // to have to do.
        //
        internal unsafe static UnicodeCategory InternalGetUnicodeCategory(char ch) {
            // Get the level 2 item from the highest 8 bit (8 - 15) of ch.
            byte index1 = m_pDataTable[ch >> 8];
            // Get the level 2 WORD offset from the 4 - 7 bit of ch.  This provides the base offset of the level 3 table.
            // Note that & has the lower precedence than addition, so don't forget the parathesis.            
            ushort offset = m_pLevel2WordOffset[(index1 << 4) + ((ch >> 4) & 0x000f)];
            // Get the result from the 0 -3 bit of ch.
            byte result = m_pDataTable[offset + (ch & 0x000f)];
            return ((UnicodeCategory)result);
        }


        /*=================================GetUnicodeCategory==========================
        **Action: Returns the Unicode Category property for the character c.
        **Returns:
        **  an value in UnicodeCategory enum
        **Arguments:
        **  ch  a Unicode character
        **Exceptions:
        **  None
        ============================================================================*/
        
        public static UnicodeCategory GetUnicodeCategory(char ch) {
            return InternalGetUnicodeCategory(ch);
        }

        /*=================================IsCombiningCharacter==========================
        **Action: Returns if the specified character is a combining character.
        **Returns:
        **  TRUE if ch is a combining character.
        **Arguments:
        **  ch  a Unicode character
        **Exceptions:
        **  None
        **Notes:
        **  Used by StringInfo.ParseCombiningCharacter.
        ============================================================================*/
        internal static bool IsCombiningCharacter(char ch) {
            UnicodeCategory uc = CharacterInfo.GetUnicodeCategory(ch);
            return (
                uc == UnicodeCategory.NonSpacingMark || 
                uc == UnicodeCategory.SpacingCombiningMark ||
                uc == UnicodeCategory.EnclosingMark
            );
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\cultureinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Class:    CultureInfo
//
//  Author:   Julie Bennett (JulieB)
//
//  Purpose:  This class represents the software preferences of a particular
//            culture or community.  It includes information such as the
//            language, writing system, and a calendar used by the culture
//            as well as methods for common operations such as printing
//            dates and sorting strings.
//
//  Date:     March 31, 1999
//
////////////////////////////////////////////////////////////////////////////

namespace System.Globalization {    
    using System;
    using System.Threading;
    using System.Runtime.CompilerServices;
    
    /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo"]/*' />
    [Serializable] public class CultureInfo : ICloneable, IFormatProvider {

        //
        // Special culture IDs
        //
        internal const int InvariantCultureID = 0x007f;
        internal const int zh_CHT_CultureID = 0x7c04;
        
        //--------------------------------------------------------------------//
        //                        Internal Information                        //
        //--------------------------------------------------------------------//
    
        // This is the string used to construct CultureInfo.
        // It is in the format of ISO639 (2 letter language name) plus dash plus
        // ISO 3166 (2 letter region name).  The language name is in lowercase and region name
        // are in uppercase.
        internal String m_name = null;
    
        //
        // This points to a record in the Culture Data Table.  That record contains several fields
        // There are two kinds of fields.  One is 16-bit integer data and another one is string data.
        // These fields contains information about a particular culture.
        // You can think of m_dataItem as a handle that can be used to call the following metdhos:
        //      CultureTable.GetInt32Value()
        //      CultureTable.GetStringValue()
        //      CultureTable.GetMultipleStringValues()
        //
        // By calling these methods, you can get information about a culture.
        internal int m_dataItem;

        //
        // This indicates that if we need to check for user-override values for this CultureInfo instance.
        // For the user default culture of the system, user can choose to override some of the values
        // associated with that culture.  For example, the default short-date format for en-US is
        // "M/d/yyyy", however, one may change it to "dd/MM/yyyy" from the Regional Option in
        // the control panel.
        // So when a CultureInfo is created, one can specify if the create CultureInfo should check
        // for user-override values, or should always get the default values.
        //
        internal bool m_useUserOverride;

        //
        // This is the culture ID used in the NLS+ world.  The concept of cultureID is similar
        // to the concept of LCID in Win32.  However, NLS+ support "neutral" culture 
        // which Win32 doesn't support.
        //
        // The format of culture ID (32 bits) is:
        // 
        // 31 - 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
        // +-----+ +---------+ +---------------+ +-----------------+
        //    |         |           |            Primary language ID (10 bits)
        //    |         |           +----------- Sublanguage ID (6 its)
        //    |         +----------------------- Sort ID (4 bits)
        //    +--------------------------------- Reserved (12 bits)
        //
        // Primary language ID and sublanguage ID can be zero to specify 'neutral' language.
        // For example, cultureID 0x(0000)0009 is the English neutral culture.
        // cultureID 0x(0000)0000 means the invariant culture (or called neutral culture).
        //
        internal int cultureID;

        //Get the current user default culture.  This one is almost always used, so we create it by default.
        internal static CultureInfo m_userDefaultCulture   = null;
        
        //
        // All of the following will be created on demand.
        //
        
        //The Invariant culture;
        internal static CultureInfo m_InvariantCultureInfo = null; 
        
        //The culture used in the user interface. This is mostly used to load correct localized resources.
        internal static CultureInfo m_userDefaultUICulture = null;

        //This is the UI culture used to install the OS.
        internal static CultureInfo m_InstalledUICultureInfo = null;
        internal bool m_isReadOnly=false;        

        internal CompareInfo compareInfo = null;
        internal TextInfo textInfo = null;
        internal NumberFormatInfo numInfo = null;
        internal DateTimeFormatInfo dateTimeInfo = null;
        internal Calendar calendar = null;
            
        //
        //  Helper Methods.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern bool IsInstalledLCID(int LCID);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int nativeGetUserDefaultLCID();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int nativeGetUserDefaultUILanguage();
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int nativeGetSystemDefaultUILanguage();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int nativeGetThreadLocale();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern bool nativeSetThreadLocale(int LCID);

        internal const int SPANISH_TRADITIONAL_SORT = 0x040a;
        internal const int SPANISH_INTERNATIONAL_SORT = 0x0c0a;

        static CultureInfo() {
            CultureInfo temp = new CultureInfo(nativeGetUserDefaultLCID());
            temp.m_isReadOnly = true;
            m_userDefaultCulture = temp;
        }

        ////////////////////////////////////////////////////////////////////////
        //
        //  CultureInfo Constructors
        //
        ////////////////////////////////////////////////////////////////////////
        
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.CultureInfo"]/*' />
        public CultureInfo(String name) : this(name, true) {
        }
        
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.CultureInfo1"]/*' />
        public CultureInfo(String name, bool useUserOverride) {
            if (name==null) {
                throw new ArgumentNullException("name",
                    Environment.GetResourceString("ArgumentNull_String"));
                
            }
    
            this.m_dataItem = CultureTable.GetDataItemFromName(name);
            if (m_dataItem < 0) {
                throw new ArgumentException(
                    String.Format(Environment.GetResourceString("Argument_InvalidCultureName"), name), "name");
            }
            this.m_useUserOverride = useUserOverride;
            
            this.cultureID = CultureTable.GetDefaultInt32Value(m_dataItem, CultureTable.ILANGUAGE);
        }
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.CultureInfo2"]/*' />
        public CultureInfo(int culture) : this(culture, true) {
        }

        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.CultureInfo3"]/*' />
        public CultureInfo(int culture, bool useUserOverride) {
            if (culture < 0) {
                throw new ArgumentOutOfRangeException("culture", 
                    Environment.GetResourceString("ArgumentOutOfRange_NeedPosNum"));
            }

            if (culture==SPANISH_TRADITIONAL_SORT) {
                // HACKHACK
                // We are nuking 0x040a (Spanish Traditional sort) in NLS+.  
                // So if you create 0x040a, it's just like 0x0c0a (Spanish International sort).
                // For a table setup reason, we can not really remove the data item for 0x040a in culture.nlp.
                // As a workaround, what we do is to make the data for 0x040a to be exactly the same as 0x0c0a.
                // Unfortunately, the culture name is the only exception.  
                // So in the table, we still have "es-ES-Ts" in there which we can not make it "es-ES".
                // Again, this is for table setup reason.  So if we are creating
                // CultureInfo using 0x040a, hardcode culture name to be "es-ES" here so that we won't
                // get "es-ES-Ts" in the table.
                m_name = "es-ES";
            }
            m_dataItem = CultureTable.GetDataItemFromCultureID(GetLangID(culture));            

            if (m_dataItem < 0) {
                throw new ArgumentException(
                    String.Format(Environment.GetResourceString("Argument_CultureNotSupported"), culture), "culture");
            }
            this.m_useUserOverride = useUserOverride;            

            int sortID;
            if ((sortID = GetSortID(culture))!= 0) {
                //
                // Check if the sort ID is valid.
                //
                if (!CultureTable.IsValidSortID(m_dataItem, sortID)) {
                    throw new ArgumentException(
                        String.Format(Environment.GetResourceString("Argument_CultureNotSupported"), culture), "culture");            
                }
            }
            this.cultureID = culture;
        }

        private const int NEUTRAL_SPANISH_CULTURE = 0x0A; //This is the lcid for neutral spanish.
        private const int INTERNATIONAL_SPANISH_CULTURE = 0x0C0A;  //This is the LCID for international spanish.

        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.CreateSpecificCulture"]/*' />
        public static CultureInfo CreateSpecificCulture(String name) {
            CultureInfo culture = new CultureInfo(name);

            //In the most common case, they've given us a specific culture, so we'll just return that.
            if (!(culture.IsNeutralCulture)) {
                return culture;
            }
            
            int lcid = culture.LCID;
            //If we have the Chinese locale, we have no way of producing a 
            //specific culture without encountering significant geopolitical
            //issues.  Based on that, we have no choice but to bail.
            if ((lcid & 0x3FF)==0x04) {
                throw new ArgumentException(Environment.GetResourceString("Argument_NoSpecificCulture"));
            }

            //I've made this a switch statement because I believe that the number fo exceptions which we're going
            //to have is going to grow.
            switch(lcid) {
            case NEUTRAL_SPANISH_CULTURE:
                return new CultureInfo(INTERNATIONAL_SPANISH_CULTURE);
            }

            //This is the algorithm that windows uses for determing the "first"
            //culture associated with a neutral language.  The low-order 18 bits
            //of an LCID are consumed with the language ID, so this is essentially
            //a 1 in the culture id field.
            lcid |= 0x0400;
                
            return new CultureInfo(lcid);
        }

        internal static bool VerifyCultureName(CultureInfo culture, bool throwException) {
            BCLDebug.Assert(culture!=null, "[CultureInfo.VerifyCultureName]culture!=null");

            //If we have an instance of one of our CultureInfos, the user can't have changed the
            //name and we know that all names are valid in files.
            if (culture.GetType()==typeof(CultureInfo)) {
                return true;
            }
            
            String name = culture.Name;
            
            for (int i=0; i<name.Length; i++) {
                char c = name[i];
                if (Char.IsLetterOrDigit(c) || c=='-' || c=='_') {
                    continue;
                }
                if (throwException) {
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidResourceCultureName", name));
                }
                return false;
            }
            return true;
        }

        //--------------------------------------------------------------------//
        //                        Misc static functions                       //
        //--------------------------------------------------------------------//
    
        internal static int GetPrimaryLangID(int culture)
        {
            return (culture & 0x03ff);            
        }
    
        internal static int GetSubLangID(int culture)
        {
            return ((culture >> 10) & 0x3f);
        }
    
        internal static int GetLangID(int culture)
        {
            return (culture & 0xffff);
        }
    
        internal static int MakeLangID(int primaryLangID, int subLangID)
        {
            BCLDebug.Assert(primaryLangID >= 0 && primaryLangID < 1024, "CultureInfo.makeLangID(): primaryLangID >= 0 && primaryLangID < 1024");
            BCLDebug.Assert(subLangID >= 0 && subLangID < 64, "CultureInfo.makeLangID(): subLangID >= 0 && subLangID < 64");
            return ((subLangID << 10)| primaryLangID);
        }
    
        internal static int GetSortID(int lcid)   
        {
            return ((lcid >> 16) & 0xf);
        }
            
        ////////////////////////////////////////////////////////////////////////
        //
        //  CurrentCulture
        //
        //  This instance provides methods based on the current user settings.
        //  These settings are volatile and may change over the lifetime of the
        //  thread.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.CurrentCulture"]/*' />
        public static CultureInfo CurrentCulture
        {
            get {
                return Thread.CurrentThread.CurrentCulture;
            }
        }

        //
        // This is the equivalence of the Win32 GetUserDefaultLCID()
        //
        internal static CultureInfo UserDefaultCulture {
            get {
                return (m_userDefaultCulture);
            }
        }
    
        //
        //  This is the equivalence of the Win32 GetUserDefaultUILanguage()
        //
    
        internal static CultureInfo UserDefaultUICulture {
            get {
            	CultureInfo temp = m_userDefaultUICulture;
                if (temp == null) {
                    temp = new CultureInfo(nativeGetUserDefaultUILanguage()); ;
                    temp.m_isReadOnly = true;
                    m_userDefaultUICulture = temp;
                }
                return (temp);    
            }
        }
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.CurrentUICulture"]/*' />
        public static CultureInfo CurrentUICulture {
            get {
                return Thread.CurrentThread.CurrentUICulture;
            }
        }

        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.InstalledUICulture"]/*' />
        //
        // This is the equivalence of the Win32 GetSystemDefaultUILanguage()
        //
        public static CultureInfo InstalledUICulture {
            get {
                if (m_InstalledUICultureInfo == null) {
                    CultureInfo temp = new CultureInfo(nativeGetSystemDefaultUILanguage());
                    temp.m_isReadOnly = true;
                    m_InstalledUICultureInfo = temp;
                }
                return (m_InstalledUICultureInfo);
            }
        }
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  InvariantCulture
        //
        //  This instance provides methods, for example for casing and sorting,
        //  that are independent of the system and current user settings.  It
        //  should be used only by processes such as some system services that
        //  require such invariant results (eg. file systems).  In general,
        //  the results are not linguistically correct and do not match any
        //  culture info.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.InvariantCulture"]/*' />
        public static CultureInfo InvariantCulture {
            get {
                if (m_InvariantCultureInfo == null) {
                    CultureInfo temp = new CultureInfo(InvariantCultureID, false);
                    temp.m_isReadOnly = true;
                    m_InvariantCultureInfo = temp;
                }
                return (m_InvariantCultureInfo);
            }
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  Parent
        //
        //  Return the parent CultureInfo for the current instance.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.Parent"]/*' />
        public virtual CultureInfo Parent {
            get {
                int parentCulture = CultureTable.GetDefaultInt32Value(m_dataItem, CultureTable.IPARENT);
                if (parentCulture == InvariantCultureID) {
                    return (InvariantCulture);
                }
                return (new CultureInfo(parentCulture, m_useUserOverride));
            }
        }
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  LCID
        //
        //  Returns a properly formed culture identifier for the current
        //  culture info.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.LCID"]/*' />
        public virtual int LCID {
            get {
                return (this.cultureID);
            }
        }
            
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.GetCultures"]/*' />
        public static CultureInfo[] GetCultures(CultureTypes types) {
            return (CultureTable.GetCultures(types));
        }
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  Name
        //
        //  Returns the full name of the CultureInfo. The name is in format like
        //  "en-US"
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.Name"]/*' />
        public virtual String Name {
            get {
                if (m_name==null) {
                    m_name = CultureTable.GetDefaultStringValue(m_dataItem, CultureTable.SNAME);
                }
                return m_name;    
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //
        //  DisplayName
        //
        //  Returns the full name of the CultureInfo in the localized language.
        //  For example, if the localized language of the runtime is Spanish and the CultureInfo is
        //  US English, "Ingles (Estados Unidos)" will be returned.
        //
        ////////////////////////////////////////////////////////////////////////
        
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.DisplayName"]/*' />
        public virtual String DisplayName {
            get {
                return (Environment.GetResourceString("Globalization.ci_"+Name));
            }
        }
        
        ////////////////////////////////////////////////////////////////////////
        //
        //  GetNativeName
        //
        //  Returns the full name of the CultureInfo in the native language.
        //  For example, if the CultureInfo is US English, "English
        //  (United States)" will be returned.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.NativeName"]/*' />
        public virtual String NativeName {
            get {
                return (CultureTable.GetDefaultStringValue(m_dataItem, CultureTable.SNATIVEDISPLAYNAME));
            }
        }
        
        ////////////////////////////////////////////////////////////////////////
        //
        //  GetEnglishName
        //
        //  Returns the full name of the CultureInfo in English.
        //  For example, if the CultureInfo is US English, "English
        //  (United States)" will be returned.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.EnglishName"]/*' />
        public virtual String EnglishName {
            get {
                return (CultureTable.GetDefaultStringValue(m_dataItem, CultureTable.SENGDISPLAYNAME));
            }
        }
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.TwoLetterISOLanguageName"]/*' />
        public virtual String TwoLetterISOLanguageName {
            get {
                return (CultureTable.GetDefaultStringValue(m_dataItem, CultureTable.SISO639LANGNAME));        
            }
        }
        
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.ThreeLetterISOLanguageName"]/*' />
        public virtual String ThreeLetterISOLanguageName {
            get {
                return (CultureTable.GetDefaultStringValue(m_dataItem, CultureTable.SISO639LANGNAME2));        
            }
        }
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  GetAbbreviatedName
        //
        //  Returns the abbreviated name for the current instance.  The
        //  abbreviated form is usually based on the ISO 639 standard, for
        //  example the two letter abbreviation for English is "en".
        //
        ////////////////////////////////////////////////////////////////////////
    
       /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.ThreeLetterWindowsLanguageName"]/*' />
       public virtual String ThreeLetterWindowsLanguageName {
            get {
                return (CultureTable.GetDefaultStringValue(m_dataItem, CultureTable.SABBREVLANGNAME));
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //
        //  CompareInfo               Read-Only Property
        //
        //  Gets the CompareInfo for this culture.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.CompareInfo"]/*' />
        public virtual CompareInfo CompareInfo {
            get {
                if (compareInfo==null) {
                    compareInfo = CompareInfo.GetCompareInfo(cultureID);
                }                            
                return (compareInfo);
            }
        }
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  TextInfo
        //
        //  Gets the TextInfo for this culture.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.TextInfo"]/*' />
        public virtual TextInfo TextInfo {
            get {            
                if (textInfo==null) {
                    textInfo = new TextInfo(cultureID, m_dataItem, m_useUserOverride);
                }
                return (textInfo);
            }
        } 
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  Equals
        //
        //  Implements Object.Equals().  Returns a boolean indicating whether
        //  or not object refers to the same CultureInfo as the current instance.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.Equals"]/*' />
        public override bool Equals(Object value) {
            //
            //  See if the object name is the same as the culture info object.
            //
            if ((value != null) && (value is CultureInfo)) {
                CultureInfo culture = (CultureInfo)value;
    
                //
                //  See if the member variables are equal.  If so, then
                //  return true.
                //
                if (this.cultureID == culture.cultureID) {
                    return (true);
                }
            }
    
            //
            //  Objects are not the same, so return false.
            //
            return (false);
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  GetHashCode
        //
        //  Implements Object.GetHashCode().  Returns the hash code for the
        //  CultureInfo.  The hash code is guaranteed to be the same for CultureInfo A
        //  and B where A.Equals(B) is true.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.GetHashCode"]/*' />
        public override int GetHashCode() {
            return (this.LCID);
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  ToString
        //
        //  Implements Object.ToString().  Returns the name of the CultureInfo,
        //  eg. "English (United States)".
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.ToString"]/*' />
        public override String ToString() {
            return (Name);
        }
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.GetFormat"]/*' />
        public virtual Object GetFormat(Type formatType) {
            if (formatType == typeof(NumberFormatInfo)) {
                return (NumberFormat);
            }
            if (formatType == typeof(DateTimeFormatInfo)) {
                return (DateTimeFormat);
            }
            return (null);
        }        
        
        private static readonly char[] groupSeparator = new char[] {';'};

        /*=================================ParseGroupString==========================
        **Action: The number grouping information is stored as string.  The group numbers
        **        are separated by comma.  The function split the numbers and return
        **        the result as an int array.
        **Returns: An array of int for the number grouping information.
        **Arguments: a number grouping string.
        **Exceptions: None.
        ============================================================================*/
        
        internal static int[] ParseGroupString(String groupStr) {
            BCLDebug.Assert(groupStr != null, "groupStr should not be null. There is data error in culture.nlp.");
            String[] groupDigits = groupStr.Split(groupSeparator);

            BCLDebug.Assert(groupDigits.Length > 0, "There is data error in culture.nlp.");
            int[] result = new int[groupDigits.Length];

            try {
                for (int i=0; i < groupDigits.Length; i++) {
                    result[i] = Int32.Parse(groupDigits[i], NumberStyles.None, NumberFormatInfo.InvariantInfo);
                }
            } catch (Exception) {
                BCLDebug.Assert(true, "There is data error in culture.nlp.");
            }
            return (result);
        }
    
        internal static void CheckNeutral(CultureInfo culture) {
            if (culture.IsNeutralCulture) {
                    throw new NotSupportedException(
                                                    Environment.GetResourceString("Argument_CultureInvalidFormat", 
                                                    culture.Name));
            }
        }

        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.IsNeutralCulture"]/*' />
        public virtual bool IsNeutralCulture {
            get {
                return (cultureID!=InvariantCultureID && CultureTable.IsNeutralCulture(cultureID));
            }
        }
        
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.NumberFormat"]/*' />
        public virtual NumberFormatInfo NumberFormat {
            get {
                CultureInfo.CheckNeutral(this);
                if (numInfo == null) {
                    NumberFormatInfo temp = new NumberFormatInfo(m_dataItem, m_useUserOverride);
                    temp.isReadOnly = m_isReadOnly;
                    numInfo = temp;
                }
                return (numInfo);
            }
            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("value",
                        Environment.GetResourceString("ArgumentNull_Obj"));                    
                }
                numInfo = value;
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // GetDateTimeFormatInfo
        // 
        // Create a DateTimeFormatInfo, and fill in the properties according to
        // the CultureID.
        //
        ////////////////////////////////////////////////////////////////////////
        
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.DateTimeFormat"]/*' />
        public virtual DateTimeFormatInfo DateTimeFormat {
            get {
                CultureInfo.CheckNeutral(this);
                if (dateTimeInfo == null) { 
                    lock(this) {
                        if (dateTimeInfo == null) {
                            // Change the calendar of DTFI to the specified calendar of this CultureInfo.
                            DateTimeFormatInfo temp = new DateTimeFormatInfo(GetLangID(cultureID), m_dataItem, m_useUserOverride, this.Calendar);
                            temp.m_isReadOnly = m_isReadOnly;
                            dateTimeInfo = temp;
                        }
                    }
                }
                return (dateTimeInfo);
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("value",
                        Environment.GetResourceString("ArgumentNull_Obj"));                    
                }                
                dateTimeInfo = value;
            }                            
        }


        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.ClearCachedData"]/*' />
        public void ClearCachedData() {
            lock(typeof(CultureInfo)) {
                m_userDefaultUICulture = null;
                CultureInfo temp = new CultureInfo(nativeGetUserDefaultLCID());
                temp.m_isReadOnly = true;
                m_userDefaultCulture = temp;

                RegionInfo.m_currentRegionInfo = null;                
                
                TimeZone.ResetTimeZone();
            }
        }

        /*=================================GetCalendarInstance==========================
        **Action: Map a Win32 CALID to an instance of supported calendar.
        **Returns: An instance of calendar.
        **Arguments: calType    The Win32 CALID
        **Exceptions:
        **      Shouldn't throw exception since the calType value is from our data table or from Win32 registry.
        **      If we are in trouble (like getting a weird value from Win32 registry), just return the GregorianCalendar.
        ============================================================================*/
        internal Calendar GetCalendarInstance(int calType) {
            if (calType==Calendar.CAL_GREGORIAN) {
                return (GregorianCalendar.GetDefaultInstance());
            }
            return GetCalendarInstanceRare(calType);
        }
        
        //This function exists as a hack to prevent us from loading all of the non-gregorian
        //calendars unless they're required.  
        internal Calendar GetCalendarInstanceRare(int calType) {
            BCLDebug.Assert(calType!=Calendar.CAL_GREGORIAN, "calType!=Calendar.CAL_GREGORIAN");

            switch (calType) {
                case Calendar.CAL_GREGORIAN_US:               // Gregorian (U.S.) calendar
                case Calendar.CAL_GREGORIAN_ME_FRENCH:        // Gregorian Middle East French calendar
                case Calendar.CAL_GREGORIAN_ARABIC:           // Gregorian Arabic calendar
                case Calendar.CAL_GREGORIAN_XLIT_ENGLISH:     // Gregorian Transliterated English calendar
                case Calendar.CAL_GREGORIAN_XLIT_FRENCH:      // Gregorian Transliterated French calendar
                    return (new GregorianCalendar((GregorianCalendarTypes)calType));
                case Calendar.CAL_TAIWAN:                     // Taiwan Era calendar
                    return (TaiwanCalendar.GetDefaultInstance());
                case Calendar.CAL_JAPAN:                      // Japanese Emperor Era calendar
                    return (JapaneseCalendar.GetDefaultInstance());
                case Calendar.CAL_KOREA:                      // Korean Tangun Era calendar
                    return (KoreanCalendar.GetDefaultInstance());
                case Calendar.CAL_HIJRI:                      // Hijri (Arabic Lunar) calendar
                    return (HijriCalendar.GetDefaultInstance());
                case Calendar.CAL_THAI:                       // Thai calendar
                    return (ThaiBuddhistCalendar.GetDefaultInstance());
                case Calendar.CAL_HEBREW:                     // Hebrew (Lunar) calendar            
                    return (HebrewCalendar.GetDefaultInstance());
            }
            return (GregorianCalendar.GetDefaultInstance());
        }
        

        /*=================================Calendar==========================
        **Action: Return/set the calendar used by this culture.
        **Returns:
        **Arguments:
        **Exceptions:
        **  ArgumentNull_Obj if the set value is null.
        ============================================================================*/
        
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.Calendar"]/*' />
        public virtual Calendar Calendar {
            get {
                if (calendar == null) {
                    lock(this) {
                        if (calendar == null) {
                            // Get the default calendar for this culture.  Note that the value can be
                            // from registry if this is a user default culture.
                            int calType = CultureTable.GetInt32Value(m_dataItem, CultureTable.ICALENDARTYPE, m_useUserOverride);
                            calendar = GetCalendarInstance(calType);
                        }
                    }
                }
                return (calendar);
            }
        }

        /*=================================OptionCalendars==========================
        **Action: Return an array of the optional calendar for this culture.
        **Returns: an array of Calendar.
        **Arguments:
        **Exceptions:
        ============================================================================*/

        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.OptionalCalendars"]/*' />
        public virtual Calendar[] OptionalCalendars {
            get {
                //
                // This property always returns a new copy of the calendar array.
                //
                int[] calID = ParseGroupString(CultureTable.GetDefaultStringValue(m_dataItem, CultureTable.NLPIOPTIONCALENDAR));
                Calendar [] cals = new Calendar[calID.Length];
                for (int i = 0; i < cals.Length; i++) {
                    cals[i] = GetCalendarInstance(calID[i]);
                }
                return (cals);
            }
        }        

        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.UseUserOverride"]/*' />
        public bool UseUserOverride { 
            get {
                return (m_useUserOverride);
            }
        }        
    
        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.Clone"]/*' />
        public virtual Object Clone()
        {
            CultureInfo ci = (CultureInfo)MemberwiseClone();
            //If this is exactly our type, we can make certain optimizations so that we don't allocate NumberFormatInfo or DTFI unless
            //they've already been allocated.  If this is a derived type, we'll take a more generic codepath.
            if (ci.GetType()==typeof(CultureInfo)) {
                if (dateTimeInfo != null) {
                    ci.dateTimeInfo = (DateTimeFormatInfo)dateTimeInfo.Clone();
                }
                if (numInfo != null) {
                    ci.numInfo = (NumberFormatInfo)numInfo.Clone();
                }
                ci.m_isReadOnly = false;
            } else {
                ci.m_isReadOnly = false;
                ci.DateTimeFormat = (DateTimeFormatInfo)this.DateTimeFormat.Clone();
                ci.NumberFormat   = (NumberFormatInfo)this.NumberFormat.Clone();
            }
            return (ci);
        }        

        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.ReadOnly"]/*' />        
        public static CultureInfo ReadOnly(CultureInfo ci) {
            if (ci == null) {
                throw new ArgumentNullException("ci");
            }
            if (ci.IsReadOnly) {
                return (ci);
            }
            CultureInfo info = (CultureInfo)(ci.MemberwiseClone());

            //If this is exactly our type, we can make certain optimizations so that we don't allocate NumberFormatInfo or DTFI unless
            //they've already been allocated.  If this is a derived type, we'll take a more generic codepath.
            if (ci.GetType()==typeof(CultureInfo)) {
                if (ci.dateTimeInfo != null) {
                    info.dateTimeInfo = DateTimeFormatInfo.ReadOnly(ci.dateTimeInfo);
                }
                if (ci.numInfo != null) {
                    info.numInfo = NumberFormatInfo.ReadOnly(ci.numInfo);
                }
            } else {
                info.DateTimeFormat = DateTimeFormatInfo.ReadOnly(ci.DateTimeFormat);
                info.NumberFormat = NumberFormatInfo.ReadOnly(ci.NumberFormat);
            }
            // Don't set the read-only flag too early.
            // We should set the read-only flag here.  Otherwise, info.DateTimeFormat will not be able to set.
            info.m_isReadOnly = true;
            
            return (info);
        }

        /// <include file='doc\CultureInfo.uex' path='docs/doc[@for="CultureInfo.IsReadOnly"]/*' />
        public bool IsReadOnly {
            get {
                return (m_isReadOnly);
            }
        }

        private void VerifyWritable() {
            if (m_isReadOnly) {
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ReadOnly"));
            }
        }        
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\culturetable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
    using System.Runtime.Remoting;
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    /*=============================================================================
     *
     * Data table for CultureInfo classes.  Used by System.Globalization.CultureInfo.
     *
     ==============================================================================*/
    // Only statics, does not need to be marked with the serializable attribute
    internal class CultureTable {
        //
        // This is the mask used to check if the flags for GetCultures() is valid.
        //
        private const CultureTypes CultureTypesMask = ~(CultureTypes.NeutralCultures | CultureTypes.SpecificCultures | CultureTypes.InstalledWin32Cultures);

        //
        // The list of WORD fields:
        //
        internal const int IDIGITS                  = 0;
        internal const int INEGNUMBER               = 1;
        internal const int ICURRDIGITS              = 2;
        internal const int ICURRENCY                = 3;
        internal const int INEGCURR                 = 4;
        internal const int ICALENDARTYPE            = 5;
        internal const int IFIRSTDAYOFWEEK          = 6;
        internal const int IFIRSTWEEKOFYEAR         = 7;
        internal const int ILANGUAGE                = 8;
        internal const int WIN32LANGID              = 9;
        internal const int INEGATIVEPERCENT         = 10;
        internal const int IPOSITIVEPERCENT         = 11;
        internal const int IDEFAULTANSICODEPAGE     = 12;
        internal const int IDEFAULTOEMCODEPAGE      = 13;
        internal const int IDEFAULTMACCODEPAGE      = 14;
        internal const int IDEFAULTEBCDICCODEPAGE   = 15;
        internal const int IPARENT                  = 16;
        internal const int IREGIONITEM              = 17;
        internal const int IALTSORTID               = 18;
        // The DateTime formatting/parsing flag for this calendar. It indcates things like if genitive form or leap year month is used.
        internal const int IFORMATFLAGS             = 19;

        //
        // The list of string fields
        //

        internal const int SLIST                = 0;
        internal const int SDECIMAL             = 1;
        internal const int STHOUSAND            = 2;
        internal const int SGROUPING            = 3;
        internal const int SCURRENCY            = 4;
        internal const int SMONDECIMALSEP       = 5;
        internal const int SMONTHOUSANDSEP      = 6;
        internal const int SMONGROUPING         = 7;
        internal const int SPOSITIVESIGN        = 8;
        internal const int SNEGATIVESIGN        = 9;
        internal const int STIMEFORMAT          = 10;
        internal const int STIME                = 11;
        internal const int S1159                = 12;
        internal const int S2359                = 13;
        internal const int SSHORTDATE           = 14;
        internal const int SDATE                = 15;
        internal const int SLONGDATE            = 16;
        internal const int SNAME                = 17;
        internal const int SENGDISPLAYNAME      = 18;
        internal const int SABBREVLANGNAME      = 19;
        internal const int SISO639LANGNAME      = 20;
        internal const int SISO639LANGNAME2     = 21;
        internal const int SNATIVEDISPLAYNAME   = 22;
        internal const int SPERCENT             = 23;
        internal const int SNAN                 = 24;
        internal const int SPOSINFINITY         = 25;
        internal const int SNEGINFINITY         = 26;
        internal const int SSHORTTIME           = 27;
        internal const int SYEARMONTH           = 28;
        internal const int SMONTHDAY            = 29;
        internal const int SDAYNAME1            = 30;
        internal const int SDAYNAME2            = 31;
        internal const int SDAYNAME3            = 32;
        internal const int SDAYNAME4            = 33;
        internal const int SDAYNAME5            = 34;
        internal const int SDAYNAME6            = 35;
        internal const int SDAYNAME7            = 36;
        internal const int SABBREVDAYNAME1      = 37;
        internal const int SABBREVDAYNAME2      = 38;
        internal const int SABBREVDAYNAME3      = 39;
        internal const int SABBREVDAYNAME4      = 40;
        internal const int SABBREVDAYNAME5      = 41;
        internal const int SABBREVDAYNAME6      = 42;
        internal const int SABBREVDAYNAME7      = 43;
        internal const int SMONTHNAME1          = 44;
        internal const int SMONTHNAME2          = 45;
        internal const int SMONTHNAME3          = 46;
        internal const int SMONTHNAME4          = 47;
        internal const int SMONTHNAME5          = 48;
        internal const int SMONTHNAME6          = 49;
        internal const int SMONTHNAME7          = 50;
        internal const int SMONTHNAME8          = 51;
        internal const int SMONTHNAME9          = 52;
        internal const int SMONTHNAME10         = 53;
        internal const int SMONTHNAME11         = 54;
        internal const int SMONTHNAME12         = 55;
        internal const int SMONTHNAME13         = 56;
        internal const int SABBREVMONTHNAME1    = 57;
        internal const int SABBREVMONTHNAME2    = 58;
        internal const int SABBREVMONTHNAME3    = 59;
        internal const int SABBREVMONTHNAME4    = 60;
        internal const int SABBREVMONTHNAME5    = 61;
        internal const int SABBREVMONTHNAME6    = 62;
        internal const int SABBREVMONTHNAME7    = 63;
        internal const int SABBREVMONTHNAME8    = 64;
        internal const int SABBREVMONTHNAME9    = 65;
        internal const int SABBREVMONTHNAME10   = 66;
        internal const int SABBREVMONTHNAME11   = 67;
        internal const int SABBREVMONTHNAME12   = 68;
        internal const int SABBREVMONTHNAME13   = 69;
        // Supported calendars for a culture.  The value is a string with Win32 CALID values separated by semicolon.
        // E.g. "1;6"
        internal const int NLPIOPTIONCALENDAR   = 70;
        internal const int SADERA               = 71;   // The localized name for the A.D. Era
        internal const int SDATEWORDS           = 72;
        internal const int SSABBREVADREA        = 73;   // The abbreviated localized name for the A.D. Era
        internal const int SANSICURRENCYSYMBOL  = 74;
        // Multiple strings for the genitive form of the month names.
        internal const int SMONTHGENITIVENAME   = 75;
        // Multiple strings for the genitive form of the month names in abbreviated form.
        internal const int SABBREVMONTHGENITIVENAME  = 76;
        
        unsafe static CultureTable() {
            lock(typeof(CultureTable)) {
                nativeInitCultureInfoTable();
                m_headerPtr = nativeGetHeader();
                m_itemPtr   = nativeGetNameOffsetTable();
            }
            BCLDebug.Assert(m_headerPtr != null, "CultureTable::m_headerPtr was null - CultureTable init failed.");
            BCLDebug.Assert(m_itemPtr != null, "CultureTable::m_itemPtr was null - CultureTable init failed.");
            hashByName = new Hashtable();
        }

        unsafe internal static CultureInfoHeader*  m_headerPtr;
        unsafe internal static NameOffsetItem*     m_itemPtr;

        // Hashtable for indexing name to get nDataItem.
        internal static Hashtable hashByName;

        /*=================================GetDataItemFromName============================
        **Action:   Given a culture name, return a index which points to a data item in
        **          the Culture Data Table
        **Returns:  the data item index. Or -1 if the culture name is invalid.
        **Arguments:
        **      name culture name
        **Exceptions:
        ==============================================================================*/

        unsafe internal static int GetDataItemFromName(String name) {
            BCLDebug.Assert(name!=null,"CultureTable.GetDataItemFromName(): name!=null");
            name = name.ToLower(CultureInfo.InvariantCulture);

            Object dataItem;
            if ((dataItem = hashByName[name]) != null) {
                return (Int32)dataItem;
            }
            for (int i = 0; i < m_headerPtr->numCultures; i++) {
                char* itemName = nativeGetStringPoolStr(m_itemPtr[i].strOffset);
                if (String.nativeCompareOrdinal(name, new String(itemName), true) == 0) {                    
                    hashByName[name] = (int)m_itemPtr[i].dataItemIndex;
                    // YSLin: m_itemPtr[i].dateItemIndex is the record number for
                    // the information of a culture. It was there before, but it is not used.
                    // Now we begin to use it.
                    // The trick that we play to remove es-ES-Ts is to put a duplicate entry 
                    // in the name offset table for es-ES, so that es-ES-Ts is not in the name offset table
                    // Therefore, es-ES-Ts becomes an invalid name.  
                    // However, the data item for es-ES-Ts is still there.  It is just that
                    // you can not find it by calling GetDataItemFromName.
                    return (m_itemPtr[i].dataItemIndex);
                } 
            }
            return (-1);
        }

        /*=================================GetDataItemFromCultureID============================
        **Action:   Given a culture ID, return a index which points to a data item in
        **          the Culture Data Table
        **Returns:  the data item index.  Or -1 if the culture ID is invalid.
        **Arguments:
        **      cultureID
        **Exceptions: None.
        ==============================================================================*/

        internal static int GetDataItemFromCultureID(int cultureID)
        {
            return (nativeGetDataItemFromCultureID(cultureID));

        }

        internal static bool IsNeutralCulture(int cultureID) {
            return (
                CultureInfo.GetSubLangID(cultureID) == 0
                || cultureID == CultureInfo.zh_CHT_CultureID
                || cultureID == CultureInfo.InvariantCultureID);
        }
        
        unsafe internal static CultureInfo[] GetCultures(CultureTypes types) {
            if ((types <= 0) || (types > CultureTypes.AllCultures)) {
                throw new ArgumentOutOfRangeException(
                    "types", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                    CultureTypes.NeutralCultures, CultureTypes.AllCultures));                    
            }
            
            bool isAddInstalled = (types == CultureTypes.InstalledWin32Cultures);
            bool isAddNeutral = ((types & CultureTypes.NeutralCultures) != 0);
            bool isAddSpecific = ((types & CultureTypes.SpecificCultures) != 0);
            
            ArrayList cultures = new ArrayList();
            for (int i = 0; i < m_headerPtr->numCultures; i++) {
                int cultureID = GetDefaultInt32Value(i, ILANGUAGE);

                // YSLin: Unfortunately, data for 0x040a can not be removed from culture.nlp, 
                // since doing so will break the code to retrieve the data item by culture ID.
                // So we still need to special case 0x040a here.
                switch (cultureID) {
                    case CultureInfo.SPANISH_TRADITIONAL_SORT:
                        // Exclude this culture.  It is not supported in NLS+ anymore.
                        break;
                    default:
                        bool isAdd = false;

                        if (IsNeutralCulture(cultureID)) {
                            // This is a generic (generic) culture.
                            if (isAddNeutral) {
                                isAdd = true;
                            }
                        } else {
                            // This is a specific culture.
                            if (isAddSpecific) {
                                isAdd = true;
                            } else if (isAddInstalled) {
                                if (CultureInfo.IsInstalledLCID(cultureID)) {
                                    isAdd = true;
                                }
                            }
                        }
                        
                        if (isAdd) {
                            cultures.Add(new CultureInfo(cultureID));
                        }
                        break;
                }
            }
            CultureInfo[] result = new CultureInfo[cultures.Count];
            cultures.CopyTo(result, 0);
            return (result);
        }

        internal static bool IsValidSortID(int dataItem, int sortID) {
            BCLDebug.Assert(sortID >= 0 && sortID <= 0xffff, "sortID is invalid");    // SortID is 16-bit positive integer.
            return (
                sortID == 0 ||
                CultureTable.GetDefaultInt32Value(dataItem, CultureTable.IALTSORTID) == sortID
            );
        }

        
        //
        // Return the data item in the Culture Data Table for the specified culture ID.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int nativeGetDataItemFromCultureID(int cultureID);

        //
        // Return a Int32 field value for the specified data item in the Culture Data Table.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int GetInt32Value(int cultureDataItem, int field, bool useUserOverride);

        //
        // Return a String field value for the specified data item in the Culture Data Table.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String GetStringValue(int cultureDataItem, int field, bool useUserOverride);

        //
        // Return a Int32 field value for the specified data item in the Culture Data Table.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int GetDefaultInt32Value(int cultureDataItem, int field);

        //
        // Return a String field value for the specified data item in the Culture Data Table.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String GetDefaultStringValue(int cultureDataItem, int field);

        //
        // Return multiple String fields values for the specified data item in the Culture Data Table.
        // This field has several string values.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String[] GetMultipleStringValues(int cultureDataItem, int field, bool useUserOverride);

        //
        // This function will go to native side and open/mapping the necessary
        // data file.  All of the information about cultures is stored in that data file.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void nativeInitCultureInfoTable();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern char* nativeGetStringPoolStr(int offset);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern CultureInfoHeader* nativeGetHeader();
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern NameOffsetItem* nativeGetNameOffsetTable();
        }       

    /*=============================================================================
    *
    * The native struct of a record in the Culture ID Offset Table.
    * Every instance of this class will be mapped to a memory address in the native side.
    * The memory address is memory mapped from culture.nlp.
    *
    * Every primary language will have its corresponding IDOffset record.  From the data
    * in IDOffset, we can get the index which points to a record in Culture Data Table for
    * a given culture ID.
    *
    * Used by GetDataItem(int cultureID) to retrieve the InternalDataItem for a given
    * culture ID.
    ==============================================================================*/

    [StructLayout(LayoutKind.Sequential)]
    internal struct IDOffset {
        // Index which points to a record in Culture Data Table (InternalDataItem*) for a primary language.
        internal ushort dataItemIndex;
        // The number of sub-languges for this primary language.
        internal ushort subLangCount;

        //
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
            dataItemIndex = 0;  
            subLangCount = 0;
        }
#endif
    }

    /*=============================================================================
    **
    ** The native struct of a record in the Culture Name Offset Table.
    ** Every instance of this class will be mapped to a memory address in the native side.
    ** The memory address is memory mapped from culture.nlp.
    **
    ** Every culture name will have its corresponding NameOffset record.  From the data
    ** in NameOffset, we can get the index which points to a record in the Cutlure Data Table
    ** for a given culture name.
    **
    ** Used by GetDataItem(String name) to retrieve the InteralDataItem for a given
    ** culture name.
    ==============================================================================*/

    [StructLayout(LayoutKind.Sequential)]
    internal struct NameOffsetItem {
        internal ushort strOffset;      // Offset (in words) to a string in the String Pool Table.
        internal ushort dataItemIndex;  // Index to a record in Culture Data Table.

        //
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
            strOffset = 0;  
            dataItemIndex = 0;
        }
#endif
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct CultureInfoHeader {
        internal uint   version;        // version

        // BUGBUG YSLin: complier doesn't allow me to use the following.  So use a hack for now.
        //ushort    hashID[8];      // 128 bit hash ID
        internal ushort  hashID0;
        internal ushort  hashID1;
        internal ushort  hashID2;
        internal ushort  hashID3;
        internal ushort  hashID4;
        internal ushort  hashID5;
        internal ushort  hashID6;
        internal ushort  hashID7;
        
        internal ushort numCultures;    // Number of cultures
        internal ushort maxPrimaryLang; // Max number of primary language
        internal ushort numWordFields;  // Number of internal ushort value fields.
        internal ushort numStrFields;   // Number of string value fields.
        internal ushort numWordRegistry;    // Number of registry entries for internal ushort values.
        internal ushort numStringRegistry;  // Number of registry entries for String values.
        internal uint   wordRegistryOffset; // Offset (in bytes) to ushort Registry Offset     Table.
        internal uint   stringRegistryOffset;   // Offset (in bytes) to String Registry     Offset Table.
        internal uint   IDTableOffset;      // Offset (in bytes) to Culture ID Offset Table.
        internal uint   nameTableOffset;    // Offset (in bytes) to Name Offset Table.
        internal uint   dataTableOffset;    // Offset (in bytes) to Culture Data Table.
        internal uint   stringPoolOffset;   // Offset (in bytes) to String Pool Table.

        //
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
            version = 0;
            hashID0 = 0;
            hashID1 = 0;
            hashID2 = 0; 
            hashID3 = 0;
            hashID4 = 0;
            hashID5 = 0;
            hashID6 = 0;
            hashID7 = 0;
        
            numCultures = 0;  
            maxPrimaryLang = 0;
            numWordFields = 0;
            numStrFields = 0;
            numWordRegistry = 0;
            numStringRegistry = 0;
            wordRegistryOffset = 0;
            stringRegistryOffset = 0;
            IDTableOffset = 0;
            nameTableOffset = 0;
            dataTableOffset = 0;
            stringPoolOffset = 0;
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\calendartable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
    using System.Runtime.Remoting;
    using System;
	using System.Runtime.CompilerServices;
    
    /*=============================================================================
     *
     * Calendar Data table for DateTimeFormatInfo classes.  Used by System.Globalization.DateTimeFormatInfo.
     *
     ==============================================================================*/

    internal class CalendarTable {
        // Only statics, class does not need to be serializable

        //
        // The list of WORD fields:
        //
        internal const int SCALENDAR            = 0;
        internal const int ITWODIGITYEARMAX     = 1;
        internal const int ICURRENTERA          = 2;
        // The DateTime formatting/parsing flag for this calendar. It indcates things like if genitive form or leap year month is used.
        internal const int IFORMATFLAGS         = 3;


        //
        // The list of string fields
        //
        internal const int SNAME                = 0;
        internal const int SSHORTDATE           = 1;
        internal const int SYEARMONTH           = 2;
        internal const int SLONGDATE            = 3;
        internal const int SERANAMES            = 4;
        internal const int SDAYNAME1            = 5;
        internal const int SDAYNAME2            = 6;
        internal const int SDAYNAME3            = 7;
        internal const int SDAYNAME4            = 8;
        internal const int SDAYNAME5            = 9;
        internal const int SDAYNAME6            = 10;
        internal const int SDAYNAME7            = 11;
        internal const int SABBREVDAYNAME1      = 12;
        internal const int SABBREVDAYNAME2      = 13;
        internal const int SABBREVDAYNAME3      = 14;
        internal const int SABBREVDAYNAME4      = 15;
        internal const int SABBREVDAYNAME5      = 16;
        internal const int SABBREVDAYNAME6      = 17;
        internal const int SABBREVDAYNAME7      = 18;
        internal const int SMONTHNAME1          = 19;
        internal const int SMONTHNAME2          = 20;
        internal const int SMONTHNAME3          = 21;
        internal const int SMONTHNAME4          = 22;
        internal const int SMONTHNAME5          = 23;
        internal const int SMONTHNAME6          = 24;
        internal const int SMONTHNAME7          = 25;
        internal const int SMONTHNAME8          = 26;
        internal const int SMONTHNAME9          = 27;
        internal const int SMONTHNAME10         = 28;
        internal const int SMONTHNAME11         = 29;
        internal const int SMONTHNAME12         = 30;
        internal const int SMONTHNAME13         = 31;
        internal const int SABBREVMONTHNAME1    = 32;
        internal const int SABBREVMONTHNAME2    = 33;
        internal const int SABBREVMONTHNAME3    = 34;
        internal const int SABBREVMONTHNAME4    = 35;
        internal const int SABBREVMONTHNAME5    = 36;
        internal const int SABBREVMONTHNAME6    = 37;
        internal const int SABBREVMONTHNAME7    = 38;
        internal const int SABBREVMONTHNAME8    = 39;
        internal const int SABBREVMONTHNAME9    = 40;
        internal const int SABBREVMONTHNAME10   = 41;
        internal const int SABBREVMONTHNAME11   = 42;
        internal const int SABBREVMONTHNAME12   = 43;
        internal const int SABBREVMONTHNAME13   = 44;
        internal const int SMONTHDAY            = 45;
        internal const int SERARANGES           = 46;
        internal const int SABBREVERANAMES      = 47;
        internal const int SABBREVENGERANAMES   = 48;
        // Multiple strings for the month names in a leap year.
        internal const int SLEAPYEARMONTHNAMES  = 49;
        


        // The following are not used for now, but may be used when we want to port
        // GetInt32Value()/GetStringValue() to the managed side.        
        //unsafe internal static CalendarInfoHeader*  m_headerPtr;
        
        unsafe static CalendarTable() {
            //with AppDomains active, the static initializer is no longer good enough to ensure that only one
            //thread is ever in nativeInitCalendarTable at a given time.  For Beta1, we'll lock on the type
            //of CalendarTable because type objects are bled across AppDomains.
            //@TODO[YSLin, JRoxe]: Investigate putting this synchronization in native code.
            lock (typeof(CalendarTable)) {
                nativeInitCalendarTable();
            }
        }

        //
        // Return a Int16 field value for the specified data item in the Culture Data Table.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int GetInt32Value(int calendarID, int field, bool useUserOverride);

        //
        // Return a String field value for the specified data item in the Culture Data Table.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String GetStringValue(int calendarID, int field, bool useUserOverride);

        //
        // Return multiple String fields values for the specified data item in the Culture Data Table.
        // This field has several string values.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String[] GetMultipleStringValues(int calendarID, int field, bool useUserOverride);

        //
        // This function will go to native side and open/mapping the necessary
        // data file.  All of the information about cultures is stored in that data file.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void nativeInitCalendarTable();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String nativeGetEraName(int culture, int calID);

        // The following are not used for now, but may be used when we want to port
        // GetInt32Value()/GetStringValue() to the managed side.
        
        //[MethodImplAttribute(MethodImplOptions.InternalCall)]
        //private static extern CultureInfoHeader* nativeGetHeader();

        //[MethodImplAttribute(MethodImplOptions.InternalCall)]
        //private static extern char* nativeGetStringPoolStr(int offset);        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\datetimeformatinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
    using System;
    using System.Threading;
    using System.Collections;

    //
    // Flags used to indicate different styles of month names.
    // This is an internal flag used by internalGetMonthName().
    // Use flag here in case that we need to provide a combination of these styles
    // (such as month name of a leap year in genitive form.  Not likely for now, 
    // but would like to keep the option open).
    //

    [Flags]
    internal enum MonthNameStyles {
        Regular     = 0x00000000,
        Genitive    = 0x00000001,
        LeapYear    = 0x00000002,
    }

    //
    // Flags used to indicate special rule used in parsing/formatting
    // for a specific DateTimeFormatInfo instance.
    // This is an internal flag.
    //
    // This flag is different from MonthNameStyles because this flag
    // can be expanded to accomodate parsing behaviors like CJK month names
    // or alternative month names, etc.
    
    [Flags]
    internal enum DateTimeFormatFlags {
        None                	= 0x00000000,
        UseGenitiveMonth    	= 0x00000001,
        UseLeapYearMonth    	= 0x00000002,
        UseSpacesInMonthNames	= 0x00000004,	// Has spaces or non-breaking space in the month names.
        NotInitialized      	= -1,
    }
    
    /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo"]/*' />
    [Serializable] public sealed class DateTimeFormatInfo : ICloneable, IFormatProvider {
        // cache for the invarinat culture.
        // invariantInfo is constant irrespective of your current culture.
        private static DateTimeFormatInfo invariantInfo;

        // an index which points to a record in Culture Data Table.
        internal int nDataItem = 0;
        internal bool m_useUserOverride;
        // Flag to indicate if the specified calendar for this DTFI is the 
        // default calendar stored in the culture.nlp.
        internal bool m_isDefaultCalendar;
        internal int CultureID;

        // Flags to indicate if we want to retreive the information from calendar data table (calendar.nlp) or from culture data table (culture.nlp).
        // If the flag is ture, we will retrieve the data from calendar data table (calendar.nlp).
        // If the flag is false, we will retrieve the data from culture data table (culture.nlp) or from the control panel settings.
        // The follwoing set of information both exist in culture.nlp and calendar.nlp.
        //
        //  LongDatePattern
        //  ShortDatePattern
        //  YearMonthPattern
        //
        // This flag is needed so that we can support the following scenario:
        //      CultureInfo ci = new CultureInfo("ja-jp");  // Japanese.  The default calendar for it is GregorianCalendar.
        //      ci.Calendar = new JapaneseCalendar();   // Assign the calendar to be Japanese now.
        //      String str = DateTimeFormatInfo.GetInstance(ci).LongDatePattern;
        //
        //      The new behavior will return "gg y'\x5e74'M'\x6708'd'\x65e5'".. This is the right pattern for Japanese calendar. 
        //      Previous, it returned "yyyy'\x5e74'M'\x6708'd'\x65e5'". This is wrong because it is the format for Gregorain.
        //
        // The default value is false, so we will get information from culture for the invariant culture.
        //
        // The value is decided when DateTimeFormatInfo is created in CultureInfo.GetDateTimeFormatInfo()
        // The logic is like this:
        //      If the specified culture is the user default culture in the system, we have to look at the calendar setting in the control panel.
        //          If the calendar is the same as the calendar setting in the control panel, we have to take the date patterns/month names/day names
        //             from the control panel.  By doing this, we can get the user overridden values in the control panel.
        //          Otherwise, we should get the date patterns/month names/day names from the calendar.nlp if the calendar is not Gregorian localized.
        //      If the specified culture is NOT the user default culture in the system,
        //          Check if the calendar is Gregorian localized?
        //          If yes, we use the date patterns/month names/day names from culture.nlp.
        //          Otherwise, use the date patterns/month names/day names from calendar.nlp.
        internal bool bUseCalendarInfo = false;

        //
        // Caches for various properties.
        //
        internal String amDesignator     = null;
        internal String pmDesignator     = null;
        internal String dateSeparator    = null;
        internal String longTimePattern  = null;
        internal String shortTimePattern = null;
        internal String generalShortTimePattern = null;
        internal String generalLongTimePattern  = null;
        internal String timeSeparator    = null;
        internal String monthDayPattern  = null;
        internal String[] allShortTimePatterns   = null;
        internal String[] allLongTimePatterns    = null;

        //
        // The following are constant values.
        //
        internal const String rfc1123Pattern   = "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'";
        // The sortable pattern is based on ISO 8601.
        internal const String sortableDateTimePattern = "yyyy'-'MM'-'dd'T'HH':'mm':'ss";
        internal const String universalSortableDateTimePattern = "yyyy'-'MM'-'dd HH':'mm':'ss'Z'";

        //
        // The following are affected by calendar settings.
        // 
        internal Calendar calendar  = null;

        internal int firstDayOfWeek      = -1;
        internal int calendarWeekRule     = -1;

        internal String fullDateTimePattern  = null;

        internal String longDatePattern  = null;

        internal String shortDatePattern = null;

        internal String yearMonthPattern = null;

        internal String[] abbreviatedDayNames    = null;
        internal String[] dayNames               = null;
        internal String[] abbreviatedMonthNames  = null;
        internal String[] monthNames             = null;
        // Cache the genitive month names that we retrieve from the data table.
        internal String[] genitiveMonthNames     = null;
        // Cache the abbreviated genitive month names that we retrieve from the data table.
        // internal String[] abbrevGenitiveMonthNames = null;
        // Cache the month names of a leap year that we retrieve from the data table.
        internal String[] leapYearMonthNames     = null;

        internal String[] allShortDatePatterns   = null;
        internal String[] allLongDatePatterns    = null;

        // Cache the era names for this DateTimeFormatInfo instance.
        internal String[] m_eraNames = null;
        internal String[] m_abbrevEraNames = null;
        internal String[] m_abbrevEnglishEraNames = null;

        internal String[] m_dateWords = null;

        internal int[] optionalCalendars = null;

        private const int DEFAULT_ALL_DATETIMES_SIZE = 132;

        internal bool m_isReadOnly=false;       
        // This flag gives hints about if formatting/parsing should perform special code path for things like
        // genitive form or leap year month names.
        internal DateTimeFormatFlags formatFlags = DateTimeFormatFlags.NotInitialized;

        ////////////////////////////////////////////////////////////////////////////
        //
        // Create an array of string which contains the abbreviated day names.
        //
        ////////////////////////////////////////////////////////////////////////////

        private String[] GetAbbreviatedDayOfWeekNames()
        {
            if (abbreviatedDayNames == null)
            {
                lock(this) {
                    if (abbreviatedDayNames == null) {                                
                        String[] temp = new String[7];
                        //
                        // The loop is based on the fact that CultureTable.SDAYNAMEx/CalendarTable.SDAYNAMEx are increased by one.
                        //
                        for (int i = 0; i <= 6; i++) {
                            temp[i] = GetMonthDayStringFromTable(CalendarTable.SABBREVDAYNAME1 + i, CultureTable.SABBREVDAYNAME1 + i);
                        }
                        abbreviatedDayNames = temp;
                    }
                }
            }
            return (abbreviatedDayNames);
        }

        ////////////////////////////////////////////////////////////////////////////
        //
        // Create an array of string which contains the day names.
        //
        ////////////////////////////////////////////////////////////////////////////

        private String[] GetDayOfWeekNames()
        {
            if (dayNames == null) {
                lock(this) {
                    if (dayNames == null) {
                        String[] temp = new String[7];

                        //
                        // The loop is based on the fact that CultureTable.SDAYNAMEx/CalendarTable.SDAYNAMEx are increased by one.
                        //
                        for (int i = 0; i <= 6; i++) {
                            temp[i] = GetMonthDayStringFromTable(CalendarTable.SDAYNAME1 + i, CultureTable.SDAYNAME1 + i);
                        }

                        dayNames = temp;
                    }
                }
            }
            return (dayNames);
        }
        
        ////////////////////////////////////////////////////////////////////////////
        //
        // Create an array of string which contains the abbreviated month names.
        //
        ////////////////////////////////////////////////////////////////////////////

        private String[] GetAbbreviatedMonthNames()
        {
            if (abbreviatedMonthNames == null) {
                lock(this) {
                    if (abbreviatedMonthNames == null) {
                        String[] temp = new String[13]; 

                        //
                        // The loop is based on the fact that CultureTable.SMONTHNAMEx are increased by one.
                        //
                        for (int i = 0; i <= 12; i++) {
                            temp[i] = GetMonthDayStringFromTable(CalendarTable.SABBREVMONTHNAME1 + i, CultureTable.SABBREVMONTHNAME1 + i);   
                        }

                        abbreviatedMonthNames = temp;
                    }                        
                }
            }
            return (abbreviatedMonthNames);
        }


        ////////////////////////////////////////////////////////////////////////////
        //
        // Create an array of string which contains the month names.
        //
        // @param lctype: the value of CultureTable.SDAYNAME1 or CultureTable.SABBREVDAYNAME1
        //
        ////////////////////////////////////////////////////////////////////////////

        private String[] GetMonthNames()
        {
            if (monthNames == null)
            {
                lock (this)
                {
                    if (monthNames == null)
                    {
                        String[] temp = new String[13]; 

                        //
                        // The loop is based on the fact that CultureTable.SMONTHNAMEx are increased by one.
                        //
                        for (int i = 0; i <= 12; i++)
                        {
                            temp[i] = GetMonthDayStringFromTable(CalendarTable.SMONTHNAME1 + i, CultureTable.SMONTHNAME1 + i);
                        }

                        monthNames = temp;
                     }
                }                                            
            }
            return (monthNames);
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.DateTimeFormatInfo"]/*' />
        public DateTimeFormatInfo() {
            //
            // Invariant DateTimeFormatInfo doens't have user-overriden values, so we pass false in useUserOverride.
            //
            this.nDataItem = CultureTable.GetDataItemFromCultureID(CultureInfo.InvariantCultureID);
            this.m_useUserOverride = false;
            // In Invariant culture, the default calendar store in culture.nlp is Gregorian localized.
            // And the date/time pattern for invariant culture stored in 
            this.m_isDefaultCalendar = true;
            // We don't have to call the setter of Calendar property here because the Calendar getter
            // will return Gregorian localized calendar by default.
            this.CultureID = CultureInfo.InvariantCultureID;
        }

        internal DateTimeFormatInfo(int cultureID, int dataItem, bool useUserOverride, Calendar cal) {
            this.CultureID = cultureID;
            this.nDataItem = dataItem;
            this.m_useUserOverride = useUserOverride;
            // m_isDefaultCalendar is set in the setter of Calendar below.
            this.Calendar = cal;
        }

        // Returns a default DateTimeFormatInfo that will be universally
        // supported and constant irrespective of the current culture.
        // Used by FromString methods.
        //
        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.InvariantInfo"]/*' />
        public static DateTimeFormatInfo InvariantInfo {
            get {
                if (invariantInfo == null)
                {
                    DateTimeFormatInfo temp = ReadOnly(new DateTimeFormatInfo());
                    invariantInfo = temp;
                }
                return (invariantInfo);
            }
        }

        // Returns the current culture's DateTimeFormatInfo.  Used by Parse methods.
        //
        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.CurrentInfo"]/*' />
        public static DateTimeFormatInfo CurrentInfo {
            get {
                System.Globalization.CultureInfo tempCulture = Thread.CurrentThread.CurrentCulture;
                return (DateTimeFormatInfo)tempCulture.GetFormat(typeof(DateTimeFormatInfo));
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.GetInstance"]/*' />
        public static DateTimeFormatInfo GetInstance(IFormatProvider provider)
        {
            if (provider != null)
            {
                Object service = provider.GetFormat(typeof(DateTimeFormatInfo));
                if (service != null) return (DateTimeFormatInfo)service;
            }
            return (CurrentInfo);
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.GetFormat"]/*' />
        public  Object GetFormat(Type formatType)
        {
            return (formatType == typeof(DateTimeFormatInfo)? this: null);
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.Clone"]/*' />
        public  Object Clone()
        {
            DateTimeFormatInfo n = (DateTimeFormatInfo)MemberwiseClone();
            n.m_isReadOnly = false;
            return n;
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.AMDesignator"]/*' />
        public  String AMDesignator
         {
            get
            {
                if (amDesignator == null)
                {
                    amDesignator = CultureTable.GetStringValue(nDataItem, CultureTable.S1159, m_useUserOverride);
                }
                return (amDesignator);
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("AMDesignator",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                amDesignator = value;
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.Calendar"]/*' />
        public  Calendar Calendar {
            get {
                if (calendar == null) {
                    calendar = GregorianCalendar.GetDefaultInstance();
                }
                return (calendar);
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("Calendar",
                        Environment.GetResourceString("ArgumentNull_Obj"));
                }
                if (value == calendar) {
                    return;
                }
                
                for (int i = 0; i < OptionalCalendars.Length; i++) {
                    if (OptionalCalendars[i] == value.ID) {
                        int cultureID = CultureTable.GetDefaultInt32Value(nDataItem, CultureTable.ILANGUAGE); 
                        //
                        // Get the current Win32 user culture.
                        //
                        CultureInfo userDefaultCulture = CultureInfo.UserDefaultCulture;
                        m_isDefaultCalendar = (value.ID == Calendar.CAL_GREGORIAN);
                        /*
                            When m_useUserOverride is TURE, we should follow the following table
                            to retrieve date/time patterns.

                            CurrentCulture:     Is the culture which creates the DTFI the current user default culture 
                                                specified in the control panel?
                            CurrentCalendar:    Is the specified calendar the current calendar specified in the control panel?
                            n/r: not relavent, don't care.
                            
                            Case    CurrentCulture? CurrentCalendar?    GregorianLocalized? Get Data from
                            ----    --------------- ----------------    ------------------- --------------------------
                            1       Y               Y                   n/r                 registry & culture.nlp (for user-overridable data)
                            2       n/r             n/r                 Y                   culture.nlp
                            3       n/r             n/r                 N                   CALENDAR.nlp*                            
                        */
                        
                        lock(this) {
                             if (m_useUserOverride && 
                                 userDefaultCulture.LCID == cultureID &&    // CurrentCulture
                                 userDefaultCulture.Calendar.ID == value.ID) {  // Current calendar
                                //
                                // [Case 1]
                                // 
                                // If user overriden values are allowed, and the culture is the user default culture 
                                // and the specified calendar matches the calendar setting in the control panel, 
                                // use data from registry by setting bUseCalendarInfo to be false.
                                //
                                bUseCalendarInfo = false;
                            } else {
                                if (m_isDefaultCalendar) {
                                    // [Case 2]
                                    bUseCalendarInfo = false;
                                } else {
                                    // [Case 3]
                                    bUseCalendarInfo = true;
                                }
                            } 

                            calendar = value;
                            if (calendar != null) {
                                // If this is the first time calendar is set, just assign
                                // the value to calendar.  We don't have to clean up
                                // related fields.
                                // Otherewise, clean related properties which are affected by the calendar setting,
                                // so that they will be refreshed when they are accessed next time.
                                //
                                firstDayOfWeek      = -1;
                                calendarWeekRule     = -1;

                                fullDateTimePattern  = null;
                                generalShortTimePattern = null;
                                generalLongTimePattern = null;

                                longDatePattern  = shortDatePattern = yearMonthPattern = null;
                                monthDayPattern = null;

                                dayNames               = null;
                                abbreviatedDayNames    = null;
                                monthNames             = null;
                                abbreviatedMonthNames  = null;

                                allShortDatePatterns   = null;
                                allLongDatePatterns    = null;

                                m_eraNames = null;
                                formatFlags = DateTimeFormatFlags.NotInitialized;
                            }
                        }
                        return;
                    }                                                
                }                    
                // The assigned calendar is not a valid calendar for this culture.
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidCalendar"));   
            } 
        }

        internal int[] OptionalCalendars {
            get {
                if (optionalCalendars == null) {
                    optionalCalendars = CultureInfo.ParseGroupString(CultureTable.GetDefaultStringValue(nDataItem, CultureTable.NLPIOPTIONCALENDAR));
                }
                return (optionalCalendars);
            }
            
            set {
                VerifyWritable();
                optionalCalendars = value;
            }
        }

        /*=================================GetEra==========================
        **Action: Get the era value by parsing the name of the era.
        **Returns: The era value for the specified era name.
        **      -1 if the name of the era is not valid or not supported.
        **Arguments: eraName    the name of the era.
        **Exceptions: None.
        ============================================================================*/
        
        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.GetEra"]/*' />
        public  int GetEra(String eraName) {
            if (eraName == null)
                throw new ArgumentNullException("eraName");
            
            // NOTENTOE YSLin:
            // The following is based on the assumption that the era value is starting from 1, and has a
            // serial values.
            // If that ever changes, the code has to be changed.

            // The calls to String.Compare should use the current culture for the string comparisons, but the
            // invariant culture when comparing against the english names.
            for (int i = 0; i < EraNames.Length; i++) {
                // Compare the era name in a case-insensitive way.
                if (m_eraNames[i].Length > 0) {
                    if (String.Compare(eraName, m_eraNames[i], true, CultureInfo.CurrentCulture)==0) {
                        return (i+1);
                    }
                }
            }
            for (int i = 0; i < AbbreviatedEraNames.Length; i++) {
                if (String.Compare(eraName, m_abbrevEraNames[i], true, CultureInfo.CurrentCulture)==0) {
                    return (i+1);
                }
            }
            for (int i = 0; i < AbbreviatedEnglishEraNames.Length; i++) {            
                if (String.Compare(eraName, m_abbrevEnglishEraNames[i], true, CultureInfo.InvariantCulture)==0) {
                    return (i+1);
                }
            }
            return (-1);
        }

        internal String[] EraNames {
            get {
                if (m_eraNames == null) {
                    if (Calendar.ID == Calendar.CAL_GREGORIAN) {
                        // If the calendar is Gregorian localized calendar,
                        // grab the localized name from culture.nlp.
                        m_eraNames = new String[1] {
                            CultureTable.GetStringValue(nDataItem, CultureTable.SADERA, false)
                        };
                    } else if (Calendar.ID != Calendar.CAL_TAIWAN) {                
                        // Use Calendar property so that we initialized the calendar when necessary.
                        m_eraNames = CalendarTable.GetMultipleStringValues(Calendar.ID, CalendarTable.SERANAMES, false);
                    } else {
                        // Special case for Taiwan calendar.                    
                        // 0x0404 is the locale ID for Taiwan.
                        m_eraNames = new String[] {CalendarTable.nativeGetEraName(0x0404, Calendar.ID)};
                    }
                }
                return (m_eraNames);
            }
        }

        /*=================================GetEraName==========================
        **Action: Get the name of the era for the specified era value.
        **Returns: The name of the specified era.
        **Arguments:
        **      era the era value.
        **Exceptions:
        **      ArguementException if the era valie is invalid.
        ============================================================================*/

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.GetEraName"]/*' />
        public  String GetEraName(int era) {
            if (era == Calendar.CurrentEra) {
                era = Calendar.CurrentEraValue;
            }

            // NOTENTOE YSLin:
            // The following is based on the assumption that the era value is starting from 1, and has a
            // serial values.
            // If that ever changes, the code has to be changed.
            if ((--era) < EraNames.Length && (era >= 0)) {
                return (m_eraNames[era]);
            }
            throw new ArgumentOutOfRangeException(Environment.GetResourceString("Argument_InvalidEraValue"));
        }
        
        internal String[] AbbreviatedEraNames {
            get {
                if (m_abbrevEraNames == null) {
                    if (Calendar.ID == Calendar.CAL_TAIWAN) {
                        String twnEra = GetEraName(1);
                        if (twnEra.Length > 0) {
                            // Special case for Taiwan because of geo-political issue.
                            m_abbrevEraNames = new String[] {twnEra.Substring(2, 2)};
                        } else {
                            m_abbrevEraNames = new String[0];
                        }
                    } else {
                        if (Calendar.ID == Calendar.CAL_GREGORIAN) {
                            // If the calendar is Gregorian localized calendar,
                            // grab the localized name from culture.nlp.
                            m_abbrevEraNames = new String[1] {
                                CultureTable.GetStringValue(nDataItem, CultureTable.SSABBREVADREA, false)
                            };                            
                        } else { 
                            m_abbrevEraNames = CalendarTable.GetMultipleStringValues(Calendar.ID, CalendarTable.SABBREVERANAMES, false);
                        }
                    }
                }
                return (m_abbrevEraNames);
            }
        }
        
        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.GetAbbreviatedEraName"]/*' />
        public String GetAbbreviatedEraName(int era) {
            if (AbbreviatedEraNames.Length == 0) {
                // If abbreviation era name is not used in this culture,
                // return the full era name.
                return (GetEraName(era));
            } 
            if (era == Calendar.CurrentEra) {
                era = Calendar.CurrentEraValue;
            }
            if ((--era) < m_abbrevEraNames.Length && (era >= 0)) {
                return (m_abbrevEraNames[era]);
            }
            throw new ArgumentOutOfRangeException(Environment.GetResourceString("Argument_InvalidEraValue"));
        }

        internal String[] AbbreviatedEnglishEraNames {
            get {
                if (m_abbrevEnglishEraNames == null) {
                    m_abbrevEnglishEraNames = CalendarTable.GetMultipleStringValues(Calendar.ID, CalendarTable.SABBREVENGERANAMES, false);
                }
                return (m_abbrevEnglishEraNames);
            }
        }
        
        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.DateSeparator"]/*' />
        public  String DateSeparator
        {
            get
            {
                if (dateSeparator == null)
                {
                    dateSeparator = CultureTable.GetStringValue(nDataItem, CultureTable.SDATE, m_useUserOverride);
                }
                return (dateSeparator);
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("DateSeparator",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                dateSeparator = value;
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.FirstDayOfWeek"]/*' />
        public  DayOfWeek FirstDayOfWeek
         {
            get
            {
                if (firstDayOfWeek == -1)
                {
                    firstDayOfWeek = CultureTable.GetDefaultInt32Value(nDataItem, CultureTable.IFIRSTDAYOFWEEK);
                }
                return ((DayOfWeek)firstDayOfWeek);
            }

            set {
                VerifyWritable();
                if (value >= DayOfWeek.Sunday && value <= DayOfWeek.Saturday) {
                firstDayOfWeek = (int)value;
                } else {
                    throw new ArgumentOutOfRangeException(
                        "value", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                        DayOfWeek.Sunday, DayOfWeek.Saturday));
                }
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.CalendarWeekRule"]/*' />
        public  CalendarWeekRule CalendarWeekRule
         {
            get
            {
                if (this.calendarWeekRule == -1)
                {
                    this.calendarWeekRule = CultureTable.GetDefaultInt32Value(nDataItem, CultureTable.IFIRSTWEEKOFYEAR);
                }
                return ((CalendarWeekRule)this.calendarWeekRule);
            }

            set {
                VerifyWritable();
                if (value >= CalendarWeekRule.FirstDay && value <= CalendarWeekRule.FirstFourDayWeek) {
                calendarWeekRule = (int)value;
                } else {
                    throw new ArgumentOutOfRangeException(
                        "value", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                        CalendarWeekRule.FirstDay, CalendarWeekRule.FirstFourDayWeek));
                }
            }
        }


        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.FullDateTimePattern"]/*' />
        public  String FullDateTimePattern
         {
            get
            {
                if (fullDateTimePattern == null)
                {
                    fullDateTimePattern = LongDatePattern + " " + LongTimePattern;
                }
                return (fullDateTimePattern);
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("FullDateTimePattern",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                fullDateTimePattern = value;
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.LongDatePattern"]/*' />
        public  String LongDatePattern
         {
            get {
                if (longDatePattern == null) {
                    longDatePattern = GetStringFromCalendarTable(CalendarTable.SLONGDATE, CultureTable.SLONGDATE);
                }
                return (longDatePattern);
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("LongDatePattern",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                longDatePattern = value;
                // Clean up cached values that will be affected by this property.
                fullDateTimePattern = null;
            }
        }
        
        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.LongTimePattern"]/*' />
        public  String LongTimePattern {
            get {
                if (longTimePattern == null) {
                    longTimePattern = CultureTable.GetStringValue(nDataItem, CultureTable.STIMEFORMAT, m_useUserOverride);
                }
                return (longTimePattern);
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("LongTimePattern",
                        Environment.GetResourceString("ArgumentNull_String"));
                }

                longTimePattern = value;
                // Clean up cached values that will be affected by this property.
                fullDateTimePattern = null;     // Full date = long date + long Time
                generalLongTimePattern = null;  // General long date = short date + long Time                
            }

        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.MonthDayPattern"]/*' />
        public  String MonthDayPattern
        {
            get {
                if (monthDayPattern == null) {
                    monthDayPattern = GetMonthDayStringFromTable(CalendarTable.SMONTHDAY, CultureTable.SMONTHDAY);
                }
                return (monthDayPattern);
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("MonthDayPattern",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                monthDayPattern = value;
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.PMDesignator"]/*' />
        public  String PMDesignator
        {
            get
            {
                if (pmDesignator == null)
                {
                    pmDesignator = CultureTable.GetStringValue(nDataItem, CultureTable.S2359, m_useUserOverride);
                }
                return (pmDesignator);
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("PMDesignator",
                        Environment.GetResourceString("ArgumentNull_String"));
                }

                pmDesignator = value;
            }

        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.RFC1123Pattern"]/*' />
        public  String RFC1123Pattern
         {
            get
            {
                return (rfc1123Pattern);
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.ShortDatePattern"]/*' />
        public  String ShortDatePattern
         {
            get
            {
                if (shortDatePattern == null)
                {
                    shortDatePattern = GetStringFromCalendarTable(CalendarTable.SSHORTDATE, CultureTable.SSHORTDATE);
                }
                return (shortDatePattern);
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("ShortDatePattern",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                shortDatePattern = value;
                // Clean up cached values that will be affected by this property.
                generalLongTimePattern = null;
                generalShortTimePattern = null;
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.ShortTimePattern"]/*' />
        public  String ShortTimePattern
         {
            get
            {
                if (shortTimePattern == null)
                {
                    shortTimePattern = CultureTable.GetStringValue(nDataItem, CultureTable.SSHORTTIME, m_useUserOverride);
                }
                return (shortTimePattern);
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("ShortTimePattern",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                shortTimePattern = value;
                // Clean up cached values that will be affected by this property.
                generalShortTimePattern = null; // General short date = short date + short time.
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.SortableDateTimePattern"]/*' />
        public  String SortableDateTimePattern {
            get {
                return (sortableDateTimePattern);
            }
        }

        /*=================================GeneralShortTimePattern=====================
        **Property: Return the pattern for 'g' general format: shortDate + short time
        **Note: This is used by DateTimeFormat.cool to get the pattern for 'g'
        **      We put this internal property here so that we can avoid doing the
        **      concatation every time somebody asks for the general format.
        ==============================================================================*/

        internal String GeneralShortTimePattern {
            get {
                if (generalShortTimePattern == null) {
                    generalShortTimePattern = ShortDatePattern + " " + ShortTimePattern;
                }
                return (generalShortTimePattern);
            }
        }

        /*=================================GeneralLongTimePattern=====================
        **Property: Return the pattern for 'g' general format: shortDate + Long time
        **Note: This is used by DateTimeFormat.cool to get the pattern for 'g'
        **      We put this internal property here so that we can avoid doing the
        **      concatation every time somebody asks for the general format.
        ==============================================================================*/

        internal String GeneralLongTimePattern {
            get {
                if (generalLongTimePattern == null) {
                    generalLongTimePattern = ShortDatePattern + " " + LongTimePattern;
                }
                return (generalLongTimePattern);
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.TimeSeparator"]/*' />
        public  String TimeSeparator
         {
            get
            {
                if (timeSeparator == null)
                {
                    timeSeparator = CultureTable.GetStringValue(nDataItem, CultureTable.STIME, m_useUserOverride);
                }
                return (timeSeparator);
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("TimeSeparator",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                timeSeparator = value;
            }

        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.UniversalSortableDateTimePattern"]/*' />
        public  String UniversalSortableDateTimePattern
         {
            get
            {
                return (universalSortableDateTimePattern);
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.YearMonthPattern"]/*' />
        public String YearMonthPattern {
            get {
                if (yearMonthPattern == null) {
                    yearMonthPattern = GetMonthDayStringFromTable(CalendarTable.SYEARMONTH, CultureTable.SYEARMONTH);
                }
                return (yearMonthPattern);
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("YearMonthPattern",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                yearMonthPattern = value;
            }
        }


        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.AbbreviatedDayNames"]/*' />
        public  String[] AbbreviatedDayNames
         {
            get
            {
                return ((String[])GetAbbreviatedDayOfWeekNames().Clone());
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("AbbreviatedDayNames");
                }
                if (value.Length != 7)
                {
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidArrayLength"), 7));
                }
                abbreviatedDayNames = value;
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.DayNames"]/*' />
        public  String[] DayNames
         {
            get
            {
                return ((String[])GetDayOfWeekNames().Clone());
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("DayNames");
                }
                if (value.Length != 7)
                {
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidArrayLength"), 7));
                }
                dayNames = value;
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.AbbreviatedMonthNames"]/*' />
        public  String[] AbbreviatedMonthNames {
            get {
                return ((String[])GetAbbreviatedMonthNames().Clone());
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("AbbreviatedMonthNames");
                }
                if (value.Length != 13)
                {
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidArrayLength"), 13));
                }
                abbreviatedMonthNames = value;
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.MonthNames"]/*' />
        public  String[] MonthNames
         {
            get
            {
                return ((String[])GetMonthNames().Clone());
            }

            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("MonthNames");
                }
                if (value.Length != 13)
                {
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidArrayLength"), 13));
                }
                monthNames = value;
                CheckMonthNameSpaces();
            }
        }

        // Whitespaces that we allow in the month names.
        // U+00a0 is non-breaking space.
        static char[] MonthSpaces = {' ', '\u00a0'};

        //
        // Check if whitespaces exists in month names and set the formatFlags appropriately. 
        //
        void CheckMonthNameSpaces()
        {
            formatFlags = FormatFlags;  // Make sure that formatFlags is initiailized.
            // Clean up the month-space flag.
            formatFlags &= ~(DateTimeFormatFlags.UseSpacesInMonthNames);
            for (int i = 0; i < monthNames.Length; i++)
            {
                if (monthNames[i] != null && monthNames[i].IndexOfAny(MonthSpaces) >= 0)
                {
                    formatFlags |= DateTimeFormatFlags.UseSpacesInMonthNames;
                    break;
                }
            }
        }

        internal bool HasSpacesInMonthNames {
            get {
                return (FormatFlags & DateTimeFormatFlags.UseSpacesInMonthNames) != 0;
            }
        }

        //
        //  internalGetMonthName
        //
        // Actions: Return the month name using the specified MonthNameStyles in either abbreviated form
        //      or full form.      
        // Arguments:
        //      month
        //      style           To indicate a form like regular/genitive/month name in a leap year.
        //      abbreviated     When true, return abbreviated form.  Otherwise, return a full form.
        //  Exceptions:
        //      ArgumentOutOfRangeException When month name is invalid.
        //
        internal String internalGetMonthName(int month, MonthNameStyles style, bool abbreviated) {
            //
            // Right now, style is mutual exclusive, but I make the style to be flag so that
            // maybe we can combine flag if there is such a need.
            //
            String[] monthNames = null;
            switch (style) {
                case MonthNameStyles.Genitive:
                    monthNames = internalGetGenitiveMonthNames(abbreviated);
                    break;
                case MonthNameStyles.LeapYear:
                    monthNames = internalGetLeapYearMonthNames(/*abbreviated*/);
                    break;
                default:
                    monthNames = (abbreviated ? GetAbbreviatedMonthNames(): GetMonthNames());
                    break;
            }
            // The month range is from 1 ~ monthNames.Length
            if ((month < 1) || (month > monthNames.Length)) {
                throw new ArgumentOutOfRangeException(
                    "month", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                    1, monthNames.Length));                
            }
            return (monthNames[month-1]);
        }

        //
        //  internalGetGenitiveMonthNames
        //
        //  Action: Retrieve the array which contains the month names in genitive form.
        //      If this culture does not use the gentive form, the normal month name is returned.
        //  Arguments:
        //      abbreviated     When true, return abbreviated form.  Otherwise, return a full form.
        //
        internal String[] internalGetGenitiveMonthNames(bool abbreviated) {
            // Currently, there is no genitive month name in abbreviated form.   Return the regular abbreviated form.
            if (abbreviated) {
                return (GetAbbreviatedMonthNames());
            }
            
            if (genitiveMonthNames == null) {
                if (m_isDefaultCalendar) {
                    // Only Gregorian localized calendar can have genitive form.
                    String[] temp = CultureTable.GetMultipleStringValues(nDataItem, CultureTable.SMONTHGENITIVENAME, false);
                    if (temp.Length > 0) {
                        // Genitive form exists.
                        genitiveMonthNames = temp;
                    } else {
                        // Genitive form does not exist.  Use the regular month names.
                        genitiveMonthNames = GetMonthNames();
                    }
                } else {
                    genitiveMonthNames = GetMonthNames();
                }
            }
            return (genitiveMonthNames);
        }

        //
        //  internalGetLeapYearMonthNames
        //
        //  Actions: Retrieve the month names used in a leap year.
        //      If this culture does not have different month names in a leap year, the normal month name is returned.
        //  Agruments: None. (can use abbreviated later if needed)
        //
        internal String[] internalGetLeapYearMonthNames(/*bool abbreviated*/) {
            if (leapYearMonthNames == null) {
                if (m_isDefaultCalendar) {
                    //
                    // If this is a Gregorian localized calendar, there is no differences between the month names in a regular year
                    // and those in a leap year.  Just return the regular month names.
                    //
                    leapYearMonthNames = GetMonthNames();
                 } else {
                    String[] temp = CalendarTable.GetMultipleStringValues(Calendar.ID, CalendarTable.SLEAPYEARMONTHNAMES, false);
                    if (temp.Length > 0) {
                        leapYearMonthNames = temp;
                    } else {
                        leapYearMonthNames = GetMonthNames();
                    }
                }
            }
            return (leapYearMonthNames);
        }
        
        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.GetAbbreviatedDayName"]/*' />
        public  String GetAbbreviatedDayName(DayOfWeek dayofweek)
        {

            if ((int)dayofweek < 0 || (int)dayofweek > 6) {
                throw new ArgumentOutOfRangeException(
                    "dayofweek", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                    DayOfWeek.Sunday, DayOfWeek.Saturday));
            }
            //
            // Don't call the public property AbbreviatedDayNames here since a clone is needed in that
            // property, so it will be slower.  Instead, use GetAbbreviatedDayOfWeekNames() directly.
            //
            return (GetAbbreviatedDayOfWeekNames()[(int)dayofweek]);
        }


        /*
        BUGBUG yslin: TBI.  Uncomment corresponding method in ReadOnlyAdapter
        public String GetAbbreviatedDayName(int dayofweek, boolean useGenitive)
        {
            return (null);
        }

        */

        internal  String[] GetCombinedPatterns(String[] patterns1, String[] patterns2, String connectString)
        {
            String[] result = new String[patterns1.Length * patterns2.Length];
            for (int i = 0; i < patterns1.Length; i++)
            {
                for (int j = 0; j < patterns2.Length; j++)
                {
                    result[i*patterns2.Length + j] = patterns1[i] + connectString + patterns2[j];
                }
            }
            return (result);
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.GetAllDateTimePatterns"]/*' />
        public  String[] GetAllDateTimePatterns()
        {
            ArrayList results = new ArrayList(DEFAULT_ALL_DATETIMES_SIZE);

            for (int i = 0; i < DateTimeFormat.allStandardFormats.Length; i++)
            {
                String[] strings = GetAllDateTimePatterns(DateTimeFormat.allStandardFormats[i]);
                for (int j = 0; j < strings.Length; j++)
                {
                    results.Add(strings[j]);
                }
            }
            String[] value = new String[results.Count];
            results.CopyTo(0, value, 0, results.Count);
            return (value);
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.GetAllDateTimePatterns1"]/*' />
        public  String[] GetAllDateTimePatterns(char format)
        {
            String [] result = null;

            switch (format)
            {
                case 'd':
                    result = AllShortDatePatterns;
                    break;
                case 'D':
                    result = AllLongDatePatterns;
                    break;
                case 'f':
                    result = GetCombinedPatterns(AllLongDatePatterns, AllShortTimePatterns, " ");
                    break;
                case 'F':
                    result = GetCombinedPatterns(AllLongDatePatterns, AllLongTimePatterns, " ");
                    break;
                case 'g':
                    result = GetCombinedPatterns(AllShortDatePatterns, AllShortTimePatterns, " ");
                    break;
                case 'G':
                    result = GetCombinedPatterns(AllShortDatePatterns, AllLongTimePatterns, " ");
                    break;
                case 'm':
                case 'M':
                    result = new String[] {MonthDayPattern};
                    break;
                case 'r':
                case 'R':
                    result = new String[] {rfc1123Pattern};
                    break;
                case 's':
                    result = new String[] {sortableDateTimePattern};
                    break;
                case 't':
                    result = AllShortTimePatterns;
                    break;
                case 'T':
                    result = AllLongTimePatterns;
                    break;
                case 'u':
                    result = new String[] {UniversalSortableDateTimePattern};
                    break;
                case 'U':
                    result = GetCombinedPatterns(AllLongDatePatterns, AllLongTimePatterns, " ");
                    break;
                case 'y':
                case 'Y':
                    result = new String[] {YearMonthPattern};
                    break;
                default:
                    throw new ArgumentException(Environment.GetResourceString("Argument_BadFormatSpecifier"));
            }
            return (result);
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.GetDayName"]/*' />
        public  String GetDayName(DayOfWeek dayofweek)
        {
            if ((int)dayofweek < 0 || (int)dayofweek > 6) {
                throw new ArgumentOutOfRangeException(
                    "dayofweek", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                    DayOfWeek.Sunday, DayOfWeek.Saturday));
            }

            return (GetDayOfWeekNames()[(int)dayofweek]);
        }


        /*
        BUGBUG yslin: TBI. Uncomment corresponding method in ReadOnlyAdapter
        public String GetDayName(int dayofweek, boolean useGenitive)
        {
            return (null);
        }

        */

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.GetAbbreviatedMonthName"]/*' />
        public  String GetAbbreviatedMonthName(int month)
        {
            if (month < 1 || month > 13) {
                throw new ArgumentOutOfRangeException(
                    "month", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                    1, 13));
            }
            return (GetAbbreviatedMonthNames()[month-1]);
        }


        /*
        BUGBUG yslin: TBI. // Uncomment corresponding method in ReadOnlyAdapter when implemented.
        public String GetAbbreviatedMonthName(int month, boolean useGenitive)
        {
            return (null);
        }

        */


        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.GetMonthName"]/*' />
        public  String GetMonthName(int month)
        {
            if (month < 1 || month > 13) {
                throw new ArgumentOutOfRangeException(
                    "month", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                    1, 13));
            }
            return (GetMonthNames()[month-1]);
        }


        /*
        BUGBUG yslin: TBI. // Uncomment corresponding method in ReadOnlyAdapter when implemented.
        public String GetMonthName(int month, boolean useGenitive)
        {
            return (null);
        }

        */

        internal  String[] AllShortDatePatterns
         {
            get
            {
                if (allShortDatePatterns == null)
                {
                    lock (typeof(DateTimeFormatInfo))
                    {
                        if (bUseCalendarInfo) {
                            allShortDatePatterns = CalendarTable.GetMultipleStringValues(Calendar.ID, CalendarTable.SSHORTDATE, false);
                            // In the data table, some calendars store null for long date pattern.
                            // This means that we have to use the default format of the user culture for that calendar.
                            // So, get the pattern from culture.
                            if (allShortDatePatterns== null) {
                                allShortDatePatterns= CultureTable.GetMultipleStringValues(nDataItem, CultureTable.SSHORTDATE, false);
                            }                            
                        } else {
                            allShortDatePatterns = CultureTable.GetMultipleStringValues(nDataItem, CultureTable.SSHORTDATE, false);
                        }
                    }
                }
                return (allShortDatePatterns);
            }
        }

        internal  String[] AllLongDatePatterns
        {
            get
            {
                if (allLongDatePatterns == null)
                {
                    lock (typeof(DateTimeFormatInfo))
                    {
                        if (bUseCalendarInfo) {
                            allLongDatePatterns = CalendarTable.GetMultipleStringValues(Calendar.ID, CalendarTable.SLONGDATE, false);
                            // In the data table, some calendars store null for long date pattern.
                            // This means that we have to use the default format of the user culture for that calendar.
                            // So, get the pattern from culture.
                            if (allLongDatePatterns== null) {
                                allLongDatePatterns= CultureTable.GetMultipleStringValues(nDataItem, CultureTable.SLONGDATE, false);
                            }                            
                        } else {
                            allLongDatePatterns = CultureTable.GetMultipleStringValues(nDataItem, CultureTable.SLONGDATE, false);
                        }
                    }
                }
                return (allLongDatePatterns);
            }
        }

        internal  String[] AllShortTimePatterns
        {
            get
            {
                if (allShortTimePatterns == null)
                {
                    allShortTimePatterns = CultureTable.GetMultipleStringValues(nDataItem, CultureTable.SSHORTTIME, false);
                }
                return (allShortTimePatterns);
            }
        }

        internal  String[] AllLongTimePatterns
        {
            get
            {
                if (allLongTimePatterns == null)
                {
                    allLongTimePatterns       = CultureTable.GetMultipleStringValues(nDataItem, CultureTable.STIMEFORMAT, false);
                }
                return (allLongTimePatterns);
            }
        }

        //
        // The known word used in date pattern for this culture.  E.g. Spanish cultures often
        // have 'de' in their long date pattern.
        // This is used by DateTime.Parse() to decide if a word should be ignored or not.
        //
        internal String[] DateWords {
            get {
                if (m_dateWords == null) {
                    m_dateWords = CultureTable.GetMultipleStringValues(nDataItem, CultureTable.SDATEWORDS, false);
                }
                return (m_dateWords);
            }
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.ReadOnly"]/*' />
        public static DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi) {
            if (dtfi == null) {
                throw new ArgumentNullException("dtfi");
            }
            if (dtfi.IsReadOnly) {
                return (dtfi);
            }
            DateTimeFormatInfo info = (DateTimeFormatInfo)(dtfi.MemberwiseClone());
            info.m_isReadOnly = true;
            return (info);
        }

        /// <include file='doc\DateTimeFormatInfo.uex' path='docs/doc[@for="DateTimeFormatInfo.IsReadOnly"]/*' />
        public  bool IsReadOnly {
            get {
                return (m_isReadOnly);
            }
        }

        private String GetStringFromCalendarTable(int calField, int cultureField) {
            String result;
            if (bUseCalendarInfo) {
                result = CalendarTable.GetStringValue(Calendar.ID, calField, false);
                // In the data table, some calendars store null for long date pattern.
                // This means that we have to use the default format of the user culture for that calendar.
                // So, get the pattern from culture.
                if (result.Length == 0) {
                    result = CultureTable.GetDefaultStringValue(nDataItem, cultureField);
                }
            } else {
                result = CultureTable.GetStringValue(nDataItem, cultureField, m_useUserOverride);
            }
            return (result);
        }

        //
        // This is used to retrieve non-user-overridable information.
        //
        private String GetMonthDayStringFromTable(int calField, int cultureField) {
            String result;
            if (m_isDefaultCalendar) {
                result = CultureTable.GetStringValue(nDataItem, cultureField, m_useUserOverride);
            } else {
                result = CalendarTable.GetStringValue(Calendar.ID, calField, false);
                if (result.Length == 0) {
                    result = CultureTable.GetDefaultStringValue(nDataItem, cultureField);
                }                
            }
            return (result);
        }

        private void VerifyWritable() {
            if (m_isReadOnly) {
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ReadOnly"));
            }
        } 

        //
        // Actions: Return the internal flag used in formatting and parsing.
        //  The flag can be used to indicate things like if genitive forms is used in this DTFi, or if leap year gets different month names.
        //
        internal DateTimeFormatFlags FormatFlags {
            get {
                if (formatFlags == DateTimeFormatFlags.NotInitialized) {
                    if (m_isDefaultCalendar) {
                        formatFlags = (DateTimeFormatFlags)CultureTable.GetDefaultInt32Value(nDataItem, CultureTable.IFORMATFLAGS);
                    } else {
                        formatFlags = (DateTimeFormatFlags)CalendarTable.GetInt32Value(Calendar.ID, CalendarTable.IFORMATFLAGS, false);
                    }
                }
                return (formatFlags);
            }
        }
    }   // class DateTimeFormatInfo
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\defaultlcidmap.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Class:    DefaultLCIDMap
//
//  Author:   YSLin, JRoxe
//
//  Purpose:  Extracts this table from NLSDataTable so that we don't have to
//            load that to get some of the default information which we need
//            to create a CultureInfo.
//
//  Date:     May 11, 1999
//
////////////////////////////////////////////////////////////////////////////

namespace System.Globalization {
    
    //This (non-public) class has only static data and does not need to be
    //serializable.
    
	using System;
    internal class DefaultLCIDMap {
    
        private static int[] _defaultLCID =
        {
            /* primary LANGID */ /* default LCID for the primary LANGID */
            /* 00 */ 0x0409,           // Arabic - Saudi Arabia
            /* 01 */ 0x0401,           // Arabic - Saudi Arabia
            /* 02 */ 0x0402,           // Bulgarian - Bulgaria
            /* 03 */ 0x0403,           // Catalan - Spain
            /* 04 */ 0x0804,           // Chinese - PRC
            /* 05 */ 0x0405,           // Czech - Czech Republic
            /* 06 */ 0x0406,           // Danish - Denmark
            /* 07 */ 0x0407,           // German - Germany
            /* 08 */ 0x0408,           // Greek - Greece
            /* 09 */ 0x0409,           // English - United States
            /* 0a */ 0x040a,           // Spanish - Spain (Traditional S
            /* 0b */ 0x040b,           // Finnish - Finland
            /* 0c */ 0x040c,           // French - France
            /* 0d */ 0x040d,           // Hebrew - Israel
            /* 0e */ 0x040e,           // Hungarian - Hungary
            /* 0f */ 0x040f,           // Icelandic - Iceland
            /* 10 */ 0x0410,           // Italian - Italy
            /* 11 */ 0x0411,           // Japanese - Japan
            /* 12 */ 0x0412,           // Korean(Extended Wansung) - Kor
            /* 13 */ 0x0413,           // Dutch - Netherlands
            /* 14 */ 0x0414,           // Norwegian - Norway (Bokml)
            /* 15 */ 0x0415,           // Polish - Poland
            /* 16 */ 0x0416,           // Portuguese - Brazil
            /* 17 */ -1,               // N/A
            /* 18 */ 0x0418,           // Romanian - Romania
            /* 19 */ 0x0419,           // Russian - Russia
            /* 1a */ 0x041a,           // Croatian - Croatia
            /* 1b */ 0x041b,           // Slovak - Slovakia
            /* 1c */ 0x041c,           // Albanian - Albania
            /* 1d */ 0x041d,           // Swedish - Sweden
            /* 1e */ 0x041e,           // Thai - Thailand
            /* 1f */ 0x041f,           // Turkish - Turkey
            /* 20 */ 0x0420,           // Urdu - Pakistan
            /* 21 */ 0x0421,           // Indonesian - Indonesia
            /* 22 */ 0x0422,           // Ukrainian - Ukraine
            /* 23 */ 0x0423,           // Belarusian - Belarus
            /* 24 */ 0x0424,           // Slovenian - Slovenia
            /* 25 */ 0x0425,           // Estonian - Estonia
            /* 26 */ 0x0426,           // Latvian - Latvia
            /* 27 */ 0x0427,           // Lithuanian - Lithuania
            /* 28 */ -1,               // N/A
            /* 29 */ 0x0429,           // Farsi - Iran
            /* 2a */ 0x042a,           // Vietnamese - Viet Nam
            /* 2b */ 0x042b,           // Armenian - Armenia
            /* 2c */ 0x042c,           // Azeri - Azerbaijan (Latin)
            /* 2d */ 0x042d,           // Basque - Spain
            /* 2e */ -1,               // N/A        
            /* 2f */ 0x042f,           // Macedonian - Macedonia
            /* 30 */ -1,               // N/A        
            /* 31 */ -1,               // N/A        
            /* 32 */ -1,               // N/A        
            /* 33 */ -1,               // N/A        
            /* 34 */ -1,               // N/A        
            /* 35 */ -1,               // N/A        
            /* 36 */ 0x0436,           // Afrikaans - South Africa
            /* 37 */ 0x0437,           // Georgian - Georgia
            /* 38 */ 0x0438,           // Faroese - Faroe Islands
            /* 39 */ 0x0439,           // Hindi - India
            /* 3a */ -1,               // N/A        
            /* 3b */ -1,               // N/A        
            /* 3c */ -1,               // N/A        
            /* 3d */ -1,               // N/A        
            /* 3e */ 0x043e,           // Malay - Malaysia
            /* 3f */ 0x043f,           // Kazakh - Kazakstan
            /* 40 */ -1,               // N/A        
            /* 41 */ 0x0441,           // Swahili - Kenya
            /* 42 */ -1,               // N/A        
            /* 43 */ 0x0443,           // Uzbek - Uzbekistan (Latin)
            /* 44 */ 0x0444,           // Tatar - Tatarstan
            /* 45 */ 0x0445,           // Bengali - India
            /* 46 */ 0x0446,           // Punjabi - India
            /* 47 */ 0x0447,           // Gujarati - India
            /* 48 */ 0x0448,           // Oriya - India
            /* 49 */ 0x0449,           // Tamil - India
            /* 4a */ 0x044a,           // Telugu - India
            /* 4b */ 0x044b,           // Kannada - India
            /* 4c */ 0x044c,           // Malayalam - India
            /* 4d */ 0x044d,           // Assamese - India
            /* 4e */ 0x044e,           // Marathi - India
            /* 4f */ 0x044f,           // Sanskrit - India
            /* 50 */ -1,               // N/A        
            /* 51 */ -1,               // N/A        
            /* 52 */ -1,               // N/A        
            /* 53 */ -1,               // N/A        
            /* 54 */ -1,               // N/A        
            /* 55 */ -1,               // N/A        
            /* 56 */ -1,               // N/A
            /* 57 */ 0x0457,           // Konkani - India
            /* 58 */ -1,               // N/A
            /* 59 */ -1,               // N/A
            /* 5a */ -1,               // N/A
            /* 5b */ -1,               // N/A
            /* 5c */ -1,               // N/A
            /* 5d */ -1,               // N/A
            /* 5e */ -1,               // N/A
            /* 5f */ -1,               // N/A
            /* 60 */ -1,               // N/A
            /* 61 */ 0x0861,           // Nepali - India
        };
    
        ////////////////////////////////////////////////////////////////////////
        //
        // Given a primary LANGID, get a default LCID.
        //
        // If return value is 0, it means that that primary language is invalid.
        // 
        ////////////////////////////////////////////////////////////////////////
        
        internal static int GetDefaultLCID(int primaryLanguage)
        {
            if (primaryLanguage >= _defaultLCID.Length)
            {
                return -1;
            }
            return (_defaultLCID[primaryLanguage]);
        }
    
    
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\daylighttime.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
   
	using System;
    // This class represents a starting/ending time for a period of daylight saving time.
    /// <include file='doc\DaylightTime.uex' path='docs/doc[@for="DaylightTime"]/*' />
    [Serializable]
    public class DaylightTime
    {
    	internal DateTime m_start;
    	internal DateTime m_end;
    	internal TimeSpan m_delta;

        private DaylightTime() {
        }

    	/// <include file='doc\DaylightTime.uex' path='docs/doc[@for="DaylightTime.DaylightTime"]/*' />
    	public DaylightTime(DateTime start, DateTime end, TimeSpan delta) {
            m_start = start;
            m_end = end;
            m_delta = delta;
        }    

    	// The start date of a daylight saving period.
    	/// <include file='doc\DaylightTime.uex' path='docs/doc[@for="DaylightTime.Start"]/*' />
        public DateTime Start {
            get {
                return m_start;
            }
        }

    	// The end date of a daylight saving period.
    	/// <include file='doc\DaylightTime.uex' path='docs/doc[@for="DaylightTime.End"]/*' />
        public DateTime End {
            get {
                return m_end;
            }
        }

    	// Delta to stardard offset in ticks.
    	/// <include file='doc\DaylightTime.uex' path='docs/doc[@for="DaylightTime.Delta"]/*' />
        public TimeSpan Delta {
            get {
                return m_delta;
            }
        }
    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\datetimestyles.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Enum:  DateTimeStyles.cool
**
** Author: Yung-Shin Lin (YSLin)
**
** Purpose: Contains valid formats for DateTime recognized by
** the DateTime class' parsing code.
**
** Date:  November 25, 1999
**
===========================================================*/
namespace System.Globalization {

    /// <include file='doc\DateTimeStyles.uex' path='docs/doc[@for="DateTimeStyles"]/*' />
    [Flags, Serializable] 
    public enum DateTimeStyles {
        // Bit flag indicating that leading whitespace is allowed. Character values
        // 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, and 0x0020 are considered to be
        // whitespace.

        /// <include file='doc\DateTimeStyles.uex' path='docs/doc[@for="DateTimeStyles.None"]/*' />
        None                  = 0x00000000,
        /// <include file='doc\DateTimeStyles.uex' path='docs/doc[@for="DateTimeStyles.AllowLeadingWhite"]/*' />
        AllowLeadingWhite     = 0x00000001, 
        /// <include file='doc\DateTimeStyles.uex' path='docs/doc[@for="DateTimeStyles.AllowTrailingWhite"]/*' />
        AllowTrailingWhite    = 0x00000002, //Bitflag indicating trailing whitespace is allowed.
        /// <include file='doc\DateTimeStyles.uex' path='docs/doc[@for="DateTimeStyles.AllowInnerWhite"]/*' />
        AllowInnerWhite       = 0x00000004,
        /// <include file='doc\DateTimeStyles.uex' path='docs/doc[@for="DateTimeStyles.AllowWhiteSpaces"]/*' />
        AllowWhiteSpaces      = AllowLeadingWhite | AllowInnerWhite | AllowTrailingWhite,    
        // When parsing a date/time string, if all year/month/day are missing, set the default date
        // to 0001/1/1, instead of the current year/month/day.
        /// <include file='doc\DateTimeStyles.uex' path='docs/doc[@for="DateTimeStyles.NoCurrentDateDefault"]/*' />
        NoCurrentDateDefault  = 0x00000008,
        // When parsing a date/time string, if a timezone specifier ("GMT","Z","+xxxx", "-xxxx" exists), we will
        // ajdust the parsed time based to GMT.
        /// <include file='doc\DateTimeStyles.uex' path='docs/doc[@for="DateTimeStyles.AdjustToUniversal"]/*' />
        AdjustToUniversal     = 0x00000010,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\encodingdataitem.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
	using System.Text;
	using System.Runtime.Remoting;
	using System;
    
    //
    // Data item for EncodingTable.  Along with EncodingTable, they are used by 
    // System.Text.Encoding.
    // 
    // This class stores a pointer to the internal data and the index into that data
    // where our required information is found.  We load the code page, flags and uiFamilyCodePage
    // immediately because they don't require creating an object.  Creating any of the string
    // names is delayed until somebody actually asks for them and the names are then cached.
    
    [Serializable()]
    internal class CodePageDataItem
    {
        internal int  m_dataIndex;
        internal int    m_codePage;
        internal int    m_uiFamilyCodePage;
        internal String  m_webName;
        internal String m_headerName;	
        internal String m_bodyName;
        internal String m_description;
        internal uint   m_flags;
    
        unsafe internal CodePageDataItem(int dataIndex)	{
            m_dataIndex = dataIndex;
            m_codePage = EncodingTable.codePageDataPtr[dataIndex].codePage;
            m_uiFamilyCodePage = EncodingTable.codePageDataPtr[dataIndex].uiFamilyCodePage;
            m_webName=null;
            m_headerName=null;
            m_bodyName=null;
            m_description=null;
            m_flags = EncodingTable.codePageDataPtr[dataIndex].flags;
        }
    
        virtual unsafe public String WebName {
            get {
                if (m_webName==null) {
                    m_webName = new String(EncodingTable.codePageDataPtr[m_dataIndex].webName);
                }
                return m_webName;
            }
        }
    
        public virtual int CodePage {
            get {
                return m_codePage;
            }
        }
    
        public virtual int UIFamilyCodePage {
            get {
                return m_uiFamilyCodePage;
            }
        }
    
        virtual unsafe public String HeaderName {
            get {
                if (m_headerName==null) {
                    m_headerName = new String(EncodingTable.codePageDataPtr[m_dataIndex].headerName);
                }
                return m_headerName;
            }
        }
    
        virtual unsafe public String BodyName {
            get {
                if (m_bodyName==null) {
                    m_bodyName = new String(EncodingTable.codePageDataPtr[m_dataIndex].bodyName);
                }
                return m_bodyName;
            }
        }    

        virtual unsafe public uint Flags {
            get {
                return (m_flags);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\encodingtable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
	using System.Text;
	using System.Runtime.InteropServices;
	using System;
	using System.Collections;
	using System.Runtime.CompilerServices;
    //
    // Data table for encoding classes.  Used by System.Text.Encoding.
    // This class contains two hashtables to allow System.Text.Encoding
    // to retrieve the data item either by codepage value or by webName.
    //
    
	// Only statics, does not need to be marked with the serializable attribute
    internal class EncodingTable
    {
    
        //This number is the size of the table in native.  The value is retrieved by
        //calling the native GetNumEncodingItems().
        private static int lastEncodingItem = 0;
        //
        // This points to a native data table which maps an encoding name to the correct code page.        
        //
        unsafe internal static InternalEncodingDataItem *encodingDataPtr;
        //
        // This points to a native data table which stores the properties for the code page, and
        // the table is indexed by code page.
        //
        unsafe internal static InternalCodePageDataItem *codePageDataPtr;
        //
        // This caches the mapping of an encoding name to a code page.
        //
        internal static Hashtable hashByName;
        //
        // THe caches the data item which is indexed by the code page value.
        //
        internal static Hashtable hashByCodePage;
        
        //Initialize the class by getting a pointer to the table and setting up the hash
        //tables.
        static unsafe EncodingTable() {
            lock (typeof(EncodingTable)) {
                lastEncodingItem = GetNumEncodingItems() - 1;
                encodingDataPtr = GetEncodingData();
                codePageDataPtr = GetCodePageData();
            }
            hashByName = new Hashtable();
            hashByCodePage = new Hashtable();
        }
    
        // Find the data item by binary searching the table that we have in native.
        // nativeCompareOrdinalWC is an internal-only function.
        unsafe private static int internalGetCodePageFromName(String name) {
            int left  = 0;
            int right = lastEncodingItem;
            int index;
            int result;
    
            //Binary search the array until we have only a couple of elements left and then
            //just walk those elements.
            while ((right - left)>3) {
                index = ((right - left)/2) + left;
                
				bool success;
                result = String.nativeCompareOrdinalWC(name, encodingDataPtr[index].webName, true, out success);
    
                if (result == 0) {
                    //We found the item, return the associated codepage.
                    return (encodingDataPtr[index].codePage);
                } else if (result<0) {
                    //The name that we're looking for is less than our current index.
                    right = index;
                } else {
                    //The name that we're looking for is greater than our current index
                    left = index;
                }
            }
    
            //Walk the remaining elements (it'll be 3 or fewer).
            for (; left<=right; left++) {
				bool success;
                if (String.nativeCompareOrdinalWC(name, encodingDataPtr[left].webName, true,out success)==0) {
                    return (encodingDataPtr[left].codePage);
                }
            }
            // The encoding name is not valid.
            throw new ArgumentException(
                String.Format(Environment.GetResourceString("Argument_EncodingNotSupported"), name), "name");
        }
    
        /*=================================GetCodePageFromName==========================
        **Action: Given a encoding name, return the correct code page number for this encoding.
        **Returns: The code page for the encoding.
        **Arguments:
        **  name    the name of the encoding
        **Exceptions:
        **  ArgumentNullException if name is null.
        **  internalGetCodePageFromName will throw ArgumentException if name is not a valid encoding name.
        ============================================================================*/
        
        internal static int GetCodePageFromName(String name)
        {   
            if (name==null) {
                throw new ArgumentNullException("name");
            }

            Object codePageObj;

            //
            // The name is case-insensitive, but ToLower isn't free.  Check for
            // the code page in the given capitalization first.
            //
            codePageObj = hashByName[name];
            if (codePageObj!=null) {
                return ((int)codePageObj);
            }

            name = name.ToLower(CultureInfo.InvariantCulture);           
            
            //Look up the item in the hashtable.
            codePageObj = hashByName[name];
            
            //If we found it, return it.
            if (codePageObj!=null) {
                return ((int)codePageObj);
            }
            
            //Okay, we didn't find it in the hash table, try looking it up in the 
            //unmanaged data.
            int codePage = internalGetCodePageFromName(name);
            
            hashByName[name]=codePage;
            return (codePage);
        }
    
        unsafe internal static CodePageDataItem GetCodePageDataItem(int codepage) {
            CodePageDataItem dataItem;
            
            //Look up the item in the hashtable.
            dataItem = (CodePageDataItem)hashByCodePage[codepage];
            
            //If we found it, return it.
            if (dataItem!=null) {
                return (dataItem);
            }
    
            //If we didn't find it, try looking it up now.
            //If we find it, add it to the hashtable.
            //This is a stupid linear search, but we probably won't be doing it very often.
            //
            //BUGBUG YSLin: once the native data is sorted by code page, we should make this a binary search.
            //
            int i = 0;
            int data;
            while ((data = codePageDataPtr[i].codePage) != 0) {
                if (data==codepage) {
                    dataItem = new CodePageDataItem(i);
                    hashByCodePage[codepage]=dataItem;
                    return (dataItem);
                }
                i++;
            }
            //Nope, we didn't find it.
            return (null);
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern InternalEncodingDataItem *GetEncodingData();
        //
        // Return the number of encoding data items.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int GetNumEncodingItems();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern InternalCodePageDataItem* GetCodePageData();
        
    }
    
    /*=================================InternalEncodingDataItem==========================
    **Action: This is used to map a encoding name to a correct code page number. By doing this,
    ** we can get the properties of this encoding via the InternalCodePageDataItem.
    **
    ** We use this structure to access native data exposed by the native side.
    ============================================================================*/
    
    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]
    internal unsafe struct InternalEncodingDataItem {
        internal char *webName;
        internal int   codePage;

        //
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        unsafe private void DontTouchThis() {
            webName = webName;	 
            codePage = 0;
        }
#endif
    }

    /*=================================InternalCodePageDataItem==========================
    **Action: This is used to access the properties related to a code page.
    ** We use this structure to access native data exposed by the native side.
    ============================================================================*/
    
    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]
    internal unsafe struct InternalCodePageDataItem {
        internal int   codePage;
        internal int   uiFamilyCodePage;
        internal char *webName;
        internal char *headerName;
        internal char *bodyName;
        internal uint  flags;

        //
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        unsafe private void DontTouchThis() {
            codePage = 0;
            uiFamilyCodePage = 0;
            webName = webName;
            headerName = headerName;
            bodyName = bodyName;
            flags = 0;
        }
#endif
    }
            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\compareinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Class:    CompareInfo
//
//  Author:   Julie Bennett (JulieB)
//
//  Purpose:  This class implements a set of methods for comparing
//            strings.
//
//  Date:     August 12, 1998
//
////////////////////////////////////////////////////////////////////////////

namespace System.Globalization {
    
    //
    // NOTE NOTE NOTE
    //
    // We're dependent on the SortingTable getting created when an instance of the
    // class is initialized (through a call to InitializeCompareInfo).  When in 
    // native, we assume that the table has already been allocated.  If we decide
    // to delay-allocate any of the tables (as we may do for US English), we should
    // modify SortingTable::Get.  
    //
    // NOTE NOTE NOTE
    // System.Globalization.SortKey also uses the SortingTables.  Currently the only
    // way to get a SortKey is to call through CompareInfo, which means that the table
    // has already been initialized.  If this invariant changes, SortKey's constructor
    // needs to call InitializedSortingTable (which can safely be called multiple times
    // for the same locale.)
    //
    
    using System;
    using System.Collections;
    using System.Reflection;
    using System.Runtime.Serialization;
	using System.Runtime.CompilerServices;

    //
    //  Options can be used during string comparison.
    //
    //  Native implementation (COMNlsInfo.cpp & SortingTable.cpp) relies on the values of these,
    //  If you change the values below, be sure to change the values in native part as well.
    //

    /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareOptions"]/*' />
    [Flags,Serializable]
    public enum CompareOptions
    {
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareOptions.None"]/*' />
        None = 0x00000000,
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareOptions.IgnoreCase"]/*' />
        IgnoreCase      = 0x00000001,
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareOptions.IgnoreNonSpace"]/*' />
        IgnoreNonSpace  = 0x00000002,
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareOptions.IgnoreSymbols"]/*' />
        IgnoreSymbols   = 0x00000004,
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareOptions.IgnoreKanaType"]/*' />
        IgnoreKanaType  = 0x00000008, // ignore kanatype
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareOptions.IgnoreWidth"]/*' />
        IgnoreWidth     = 0x00000010, // ignore width

        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareOptions.StringSort"]/*' />
        StringSort      = 0x20000000, // use string sort method
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareOptions.Ordinal"]/*' />
        Ordinal         = 0x40000000,   // This flag can not be used with other flags.
        // StopOnNull      = 0x10000000,
        // Note YSLin: StopOnNull is defined in SortingTable.h, but we didn't enable this option here.
        // I just put here so that we won't use the value for other flags accidentally.            
    }    

    /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo"]/*' />
    [Serializable()] public class CompareInfo : IDeserializationCallback
    {

        private const int ValidMaskOffFlags = ~((int)CompareOptions.IgnoreCase | (int)CompareOptions.IgnoreSymbols | (int)CompareOptions.IgnoreNonSpace | (int)CompareOptions.IgnoreWidth | (int)CompareOptions.IgnoreKanaType);
        
        /*=================================GetCompareInfo==========================
        **Action: Get the CompareInfo constructed from the data table in the specified assembly for the specified culture.
        **       The purpose of this method is to provide versioning for CompareInfo tables.
        **       If you pass Assembly which contains different sorting table, you will sort your strings using the data
        **       in the assembly.
        **Returns: The CompareInfo for the specified culture.
        **Arguments: 
        **   culture     the ID of the culture
        **   assembly   the assembly which contains the sorting table.
        **Exceptions:
        **  ArugmentNullException when the assembly is null
        **  ArgumentException if culture is invalid.
        ============================================================================*/

        /* Note: The design goal here is that we can still provide version even when the underlying algorithm for CompareInfo
             is totally changed in the future.
             In the case that the algorithm for CompareInfo is changed, we can use this method to
             provide the old algorithm for the old tables.  The idea is to change the implementation for GetCompareInfo() 
             to something like:
               1. Check the ID of the assembly.
               2. If the assembly needs old code, create an instance of the old CompareInfo class. The name of CompareInfo
                  will be like CompareInfoVersion1 and extends from CompareInfo.
               3. Otherwise, create an instance of the current CompareInfo.
             The CompareInfo ctor always provides the implementation for the current data table.
        */        
        
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.GetCompareInfo"]/*' />
        public static CompareInfo GetCompareInfo(int culture, Assembly assembly) {
            // Parameter checking.
            if (assembly == null) {
                throw new ArgumentNullException("assembly");
            }
            if (assembly!=typeof(Object).Module.Assembly) {
                throw new ArgumentException(Environment.GetResourceString("Argument_OnlyMscorlib"));
            }

            // culture is verified to see if it is valid when CompareInfo is constructed.

            GlobalizationAssembly ga = GlobalizationAssembly.GetGlobalizationAssembly(assembly);
            Object compInfo = ga.compareInfoCache[culture];
            if (compInfo == null) {
                lock (typeof(GlobalizationAssembly)) {
                    //
                    // Re-check again to make sure that no one has created the CompareInfo for the culture yet before the current
                    // thread enters this sync block.
                    //
                    if ((compInfo = ga.compareInfoCache[culture]) == null) {
                        compInfo = new CompareInfo(ga, culture);
                        ga.compareInfoCache[culture] = compInfo;
                    }
                }
            }

            return ((CompareInfo)compInfo);
        }
        
        /*=================================GetCompareInfo==========================
        **Action: Get the CompareInfo constructed from the data table in the specified assembly for the specified culture.
        **       The purpose of this method is to provide version for CompareInfo tables.
        **Returns: The CompareInfo for the specified culture.
        **Arguments: 
        **   name    the name of the culture
        **   assembly   the assembly which contains the sorting table.
        **Exceptions:
        **  ArugmentNullException when the assembly is null
        **  ArgumentException if name is invalid.
        ============================================================================*/
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.GetCompareInfo1"]/*' />
        public static CompareInfo GetCompareInfo(String name, Assembly assembly) {
            if (name == null || assembly == null) {
                throw new ArgumentNullException(name == null ? "name" : "assembly");
            }

            if (assembly!=typeof(Object).Module.Assembly) {
                throw new ArgumentException(Environment.GetResourceString("Argument_OnlyMscorlib"));
            }

            int dataItem = CultureTable.GetDataItemFromName(name);
            if (dataItem == -1) {
                throw new ArgumentException(
                    String.Format(Environment.GetResourceString("Argument_InvalidCultureName"), name), "name");
            }
            
            int culture = CultureTable.GetDefaultInt32Value(dataItem, CultureTable.WIN32LANGID);
            
            return (GetCompareInfo(culture, assembly));            
        }
        
        /*=================================GetCompareInfo==========================
        **Action: Get the CompareInfo for the specified culture.
        ** This method is provided for ease of integration with NLS-based software.
        **Returns: The CompareInfo for the specified culture.
        **Arguments: 
        **   culture    the ID of the culture.
        **Exceptions:
        **  ArgumentException if culture is invalid.        
        **Notes:
        **  We optimize in the default case.  We don't go thru the GlobalizationAssembly hashtable.
        **  Instead, we access the m_defaultInstance directly.
        ============================================================================*/
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.GetCompareInfo2"]/*' />
        public static CompareInfo GetCompareInfo(int culture) {
            // culture is verified to see if it is valid when CompareInfo is constructed.
            Object compInfo = GlobalizationAssembly.m_defaultInstance.compareInfoCache[culture];
            if (compInfo == null) {
                lock (typeof(GlobalizationAssembly)) {
                    //
                    // Re-check again to make sure that no one has created the CompareInfo for the culture yet before the current
                    // thread enters this sync block.
                    //
                    if ((compInfo = GlobalizationAssembly.m_defaultInstance.compareInfoCache[culture]) == null) {
                        compInfo = new CompareInfo(GlobalizationAssembly.m_defaultInstance, culture);
                        GlobalizationAssembly.m_defaultInstance.compareInfoCache[culture] = compInfo;
                    }
                }
            }
            return ((CompareInfo)compInfo);
        }

        /*=================================GetCompareInfo==========================
        **Action: Get the CompareInfo for the specified culture.
        **Returns: The CompareInfo for the specified culture.
        **Arguments: 
        **   name    the name of the culture.
        **Exceptions:
        **  ArgumentException if name is invalid.
        ============================================================================*/
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.GetCompareInfo3"]/*' />
        public static CompareInfo GetCompareInfo(String name) {
            if (name == null) {
                throw new ArgumentNullException("name");
            }

            int dataItem = CultureTable.GetDataItemFromName(name);
            if (dataItem == -1) {
                throw new ArgumentException( 
                    String.Format(Environment.GetResourceString("Argument_InvalidCultureName"), name), "name");
            }
            
            int culture = CultureTable.GetDefaultInt32Value(dataItem, CultureTable.WIN32LANGID);
            
            return (GetCompareInfo(culture));
        }

        //
        // pSortingTable is a 32-bit pointer value pointing to a native C++ SortingTable object.
        //
        [NonSerialized]unsafe private void* pSortingTable;
        internal int win32LCID;             // mapped sort culture id of this instance    
        internal int culture;               // the culture ID used to create this instance.
        
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  CompareInfo Constructor
        //
        //
        ////////////////////////////////////////////////////////////////////////


        // Constructs an instance that most closely corresponds to the NLS locale 
        // identifier.  
        internal unsafe CompareInfo(GlobalizationAssembly ga, int culture) {
            if (culture < 0) {
                throw new ArgumentOutOfRangeException("culture", Environment.GetResourceString("ArgumentOutOfRange_NeedPosNum"));
            }

            // NOTENOTE YSLin: In the future, move all the culture validation to the native code InitializeCompareInfo, since we make three
            // native calls below, which are expansive.
            
            //
            // Verify that this is a valid culture.
            //
            int dataItem = CultureTable.GetDataItemFromCultureID(CultureInfo.GetLangID(culture));
            if (dataItem == -1) {
                throw new ArgumentException(
                    String.Format(Environment.GetResourceString("Argument_CultureNotSupported"), culture), "culture");            
            }

            // We do the following because the native C++ SortingTable is based on the 
            // WIN32 LCID.  It doesn't work for neutral cultures liek 0x0009.  So we convert culture
            // to a Win32 LCID here.

            // Note that we have to get Sort ID from culture.  This will affect the result of string comparison.
            this.win32LCID = CultureTable.GetDefaultInt32Value(dataItem, CultureTable.WIN32LANGID);

            int sortID = CultureInfo.GetSortID(culture);
            if (sortID != 0) {
                // Need to verify if the Sort ID is valid.
                if (!CultureTable.IsValidSortID(dataItem, sortID)) {
                    throw new ArgumentException(
                        String.Format(Environment.GetResourceString("Argument_CultureNotSupported"), culture), "culture");            
                }
                // This is an alterinative sort LCID.  Hey man, don't forget to take your SORTID with you.
                win32LCID |= sortID << 16;
            }

            // TODO: InitializeCompareInfo should use ga instead of getting the default instance.

            // Call to the native side to create/get the corresponding native C++ SortingTable for this culture.
            // The returned value is a 32-bit pointer to the native C++ SortingTable instance.  
            // We cache this pointer so that we can call methods of the SortingTable directly.
            pSortingTable = InitializeCompareInfo(GlobalizationAssembly.m_defaultInstance.pNativeGlobalizationAssembly, win32LCID);
            // Since win32LCID can be different from the passed-in culture in the case of neutral cultures, store the culture ID in a different place.
            this.culture = culture;

        }    
        
        ////////////////////////////////////////////////////////////////////////
        //
        //  Compare
        //
        //  Compares the two strings with the given options.  Returns 0 if the
        //  two strings are equal, a number less than 0 if string1 is less
        //  than string2, and a number greater than 0 if string1 is greater
        //  than string2.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.Compare"]/*' />
        public virtual int Compare(String string1, String string2)
        {
            return (Compare(string1, string2, CompareOptions.None));
        }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.Compare1"]/*' />
        public unsafe virtual int Compare(String string1, String string2, CompareOptions options){
                return (Compare(pSortingTable, win32LCID, string1, string2, options));
            }

        // This native method will check the parameters and throw appropriate exceptions if necessary.
        // COMNlsInfo::Compare
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern int Compare(void* pSortingTable, int win32LCID, String string1, String string2, CompareOptions options);
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  Compare
        //
        //  Compares the specified regions of the two strings with the given
        //  options.  A length of -1 means to go to the end of the string.
        //  Returns 0 if the two strings are equal, a number less than 0 if
        //  string1 is less than string2, and a number greater than 0 if
        //  string1 is greater than string2.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.Compare2"]/*' />
        public unsafe virtual int Compare(String string1, int offset1, int length1, String string2, int offset2, int length2)
        {
                return (CompareRegion(pSortingTable, win32LCID, string1, offset1, length1, string2, offset2, length2, 0));
            }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.Compare3"]/*' />
        public unsafe virtual int Compare(String string1, int offset1, String string2, int offset2, CompareOptions options)
        {
                return (CompareRegion(pSortingTable, win32LCID, string1, offset1, -1, string2, offset2, -1, options));
            }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.Compare4"]/*' />
        public unsafe virtual int Compare(String string1, int offset1, String string2, int offset2)
        {
                return (CompareRegion(pSortingTable, win32LCID, string1, offset1, -1, string2, offset2, -1, 0));
            }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.Compare5"]/*' />
        public unsafe virtual int Compare(String string1, int offset1, int length1, String string2, int offset2, int length2, CompareOptions options) {
            if (length1 < 0 || length2 < 0) {
                throw new ArgumentOutOfRangeException((length1 < 0) ? "length1" : "length2", Environment.GetResourceString("ArgumentOutOfRange_NeedPosNum"));
            }
                return (CompareRegion(pSortingTable, win32LCID, string1, offset1, length1, string2, offset2, length2, options));
        }

        // This native method will check the parameters and throw appropriate exceptions if necessary.
        // Native method: COMNlsInfo::CompareRegion
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern int CompareRegion(void* pSortingTable, int win32LCID, String string1, int offset1, int length1, String string2, int offset2, int length2, CompareOptions options);
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  IsPrefix
        //
        //  Determines whether prefix is a prefix of string.  If prefix equals
        //  String.Empty, true is returned.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IsPrefix"]/*' />
        public unsafe virtual bool IsPrefix(String source, String prefix, CompareOptions options)
        {
            if (source == null || prefix == null) {
                throw new ArgumentNullException((source == null ? "source" : "prefix"),
                    Environment.GetResourceString("ArgumentNull_String"));
            }
            int prefixLen = prefix.Length;
    
            if (prefixLen == 0)
            {
                return (true);
            }    
            if (((int)options & ValidMaskOffFlags) != 0 && (options != CompareOptions.Ordinal)) {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidFlag"), "options"); 
            }
            return (nativeIsPrefix(pSortingTable, win32LCID, source, prefix, options));
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern bool nativeIsPrefix(void* pSortingTable, int win32LCID, String source, String prefix, CompareOptions options);
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IsPrefix1"]/*' />
        public virtual bool IsPrefix(String source, String prefix)
        {
            return (IsPrefix(source, prefix, 0));
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  IsSuffix
        //
        //  Determines whether suffix is a suffix of string.  If suffix equals
        //  String.Empty, true is returned.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IsSuffix"]/*' />
        public unsafe virtual bool IsSuffix(String source, String suffix, CompareOptions options)
        {
            if (source == null || suffix == null) {
                throw new ArgumentNullException((source == null ? "source" : "suffix"),
                    Environment.GetResourceString("ArgumentNull_String"));
            }
            int suffixLen = suffix.Length;
    
            if (suffixLen == 0)
            {
                return (true);
            }

            if (((int)options & ValidMaskOffFlags) != 0 && (options != CompareOptions.Ordinal)) {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidFlag"), "options"); 
            }
            return (nativeIsSuffix(pSortingTable, win32LCID, source, suffix, options));        
        }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IsSuffix1"]/*' />
        public virtual bool IsSuffix(String source, String suffix)
        {
            return (IsSuffix(source, suffix, 0));
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern bool nativeIsSuffix(void* pSortingTable, int win32LCID, String source, String prefix, CompareOptions options);
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  IndexOf
        //
        //  Returns the first index where value is found in string.  The
        //  search starts from startIndex and ends at endIndex.  If endIndex
        //  is -1, then it will go to the end of the string.  Returns -1 if
        //  the specified value is not found.  If value equals String.Empty,
        //  startIndex is returned.  Throws IndexOutOfRange if startIndex or
        //  endIndex is less than zero or greater than the length of string.
        //  Throws ArgumentException if value is null.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IndexOf"]/*' />
        public unsafe virtual int IndexOf(String source, char value)
        {
                return (IndexOfChar(pSortingTable, win32LCID, source, value, 0, -1, 0));
        }

        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IndexOf1"]/*' />
        public unsafe virtual int IndexOf(String source, String value)
        {
                return (IndexOfString(pSortingTable, win32LCID, source, value, 0, -1, 0));
            }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IndexOf2"]/*' />
        public unsafe virtual int IndexOf(String source, char value, CompareOptions options)
        {
                return (IndexOfChar(pSortingTable, win32LCID, source, value, 0, -1, (int)options));
            }
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IndexOf3"]/*' />
        public unsafe virtual int IndexOf(String source, String value, CompareOptions options)
        {
                return (IndexOfString(pSortingTable, win32LCID, source, value, 0, -1, (int)options));
            }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IndexOf4"]/*' />
        public unsafe virtual int IndexOf(String source, char value, int startIndex)
        {
			// Keep these checks the same way as in unmanaged code had. This is work around the weird -1 support.
			if (source == null)
				throw new ArgumentNullException("source");
			if (startIndex > source.Length) 
				throw new ArgumentOutOfRangeException("startIndex",Environment.GetResourceString("ArgumentOutOfRange_Index"));
            return (IndexOfChar(pSortingTable, win32LCID, source, value, startIndex, source.Length - startIndex, 0));
        }

        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IndexOf10"]/*' />
        public unsafe virtual int IndexOf(String source, char value, int startIndex, CompareOptions options)
        {
            return (IndexOfChar(pSortingTable, win32LCID, source, value, startIndex, -1, (int)options));
        }
    

        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IndexOf5"]/*' />
        public unsafe virtual int IndexOf(String source, char value, int startIndex, int count)
        {
            if (count<0) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            return (IndexOfChar(pSortingTable, win32LCID, source, value, startIndex, count, 0));
        }

        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IndexOf6"]/*' />
        public unsafe virtual int IndexOf(String source, String value, int startIndex)
        {
			// Keep these checks the same way as in unmanaged code had. This is work around the weird -1 support.
			if (source == null)
				throw new ArgumentNullException("source");
			if (startIndex > source.Length) 
				throw new ArgumentOutOfRangeException("startIndex",Environment.GetResourceString("ArgumentOutOfRange_Index"));
            return (IndexOfString(pSortingTable, win32LCID, source, value, startIndex, source.Length - startIndex, 0));
        }

        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IndexOf11"]/*' />
        public unsafe virtual int IndexOf(String source, String value, int startIndex, CompareOptions options)
        {
            return (IndexOfString(pSortingTable, win32LCID, source, value, startIndex, -1, (int)options));
        }

        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IndexOf7"]/*' />
        public unsafe virtual int IndexOf(String source, String value, int startIndex, int count)
        {
            if (count<0) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            return (IndexOfString(pSortingTable, win32LCID, source, value, startIndex, count, 0));
        }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IndexOf8"]/*' />
        public unsafe virtual int IndexOf(String source, char value, int startIndex, int count, CompareOptions options) {
            if (count<0) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }
            return IndexOfChar(pSortingTable, win32LCID, source, value, startIndex, count, (int)options);
        }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.IndexOf9"]/*' />
        public unsafe virtual int IndexOf(String source, String value, int startIndex, int count, CompareOptions options) {
            if (count<0) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Index"));
            }        
            return IndexOfString(pSortingTable, win32LCID, source, value, startIndex, count, (int)options);
        }
    

        // This native method will check the parameters and throw appropriate exceptions if necessary.
        // Native method: COMNlsInfo::IndexOfChar
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern int IndexOfChar(void* pSortingTable, int win32LCID, String source, char value, int startIndex, int count, int options);
        
        // This native method will check the parameters and throw appropriate exceptions if necessary.
        // Native method: COMNlsInfo::IndexOfString
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern int IndexOfString(void* pSortingTable, int win32LCID, String source, String value, int startIndex, int count, int options);
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  LastIndexOf
        //
        //  Returns the last index where value is found in string.  The
        //  search starts from startIndex and ends at endIndex.  If endIndex
        //  is -1, then it will go to the end of the string.  Returns -1 if
        //  the specified value is not found.  If value equals String.Empty,
        //  endIndex is returned.  Throws IndexOutOfRange if startIndex or
        //  endIndex is less than zero or greater than the length of string.
        //  Throws ArgumentException if value is null.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.LastIndexOf"]/*' />
        public unsafe virtual int LastIndexOf(String source, char value)
        {
            if (source==null) {
                throw new ArgumentNullException("source");
            }
            return (LastIndexOfChar(pSortingTable, win32LCID, source, value, source.Length - 1, source.Length, 0));
        }
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.LastIndexOf1"]/*' />
        public unsafe virtual int LastIndexOf(String source, String value)
        {
            if (source==null) {
                throw new ArgumentNullException("source");
            }
            return (LastIndexOfString(pSortingTable, win32LCID, source, value, source.Length - 1, source.Length, 0));
        }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.LastIndexOf2"]/*' />
        public unsafe virtual int LastIndexOf(String source, char value, CompareOptions options)
        {
            if (source==null) {
                throw new ArgumentNullException("source");
            }
            return (LastIndexOfChar(pSortingTable, win32LCID, source, value, source.Length - 1, source.Length, (int)options));
        }
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.LastIndexOf3"]/*' />
        public unsafe virtual int LastIndexOf(String source, String value, CompareOptions options)
        {
            if (source==null) {
                throw new ArgumentNullException("source");
            }
            return (LastIndexOfString(pSortingTable, win32LCID, source, value, source.Length - 1, source.Length, (int)options));
        }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.LastIndexOf4"]/*' />
        public unsafe virtual int LastIndexOf(String source, char value, int startIndex) {
            return (LastIndexOfChar(pSortingTable, win32LCID, source, value, startIndex, startIndex + 1, 0));
        }

        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.LastIndexOf11"]/*' />
        public unsafe virtual int LastIndexOf(String source, char value, int startIndex, CompareOptions options) {
            return (LastIndexOfChar(pSortingTable, win32LCID, source, value, startIndex, -1, (int)options));
        }
        
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.LastIndexOf5"]/*' />
        public unsafe virtual int LastIndexOf(String source, char value, int startIndex, int count)
        {
            if (count<0) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Count"));
            }
            return (LastIndexOfChar(pSortingTable, win32LCID, source, value, startIndex, count, 0));
         }


        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.LastIndexOf6"]/*' />
        public unsafe virtual int LastIndexOf(String source, String value, int startIndex)
        {
            return (LastIndexOfString(pSortingTable, win32LCID, source, value, startIndex, startIndex+1, 0));
        }

        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.LastIndexOf10"]/*' />
        public unsafe virtual int LastIndexOf(String source, String value, int startIndex, CompareOptions options)
        {
            return (LastIndexOfString(pSortingTable, win32LCID, source, value, startIndex, -1, (int)options));
        }

        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.LastIndexOf7"]/*' />
        public unsafe virtual int LastIndexOf(String source, String value, int startIndex, int count)
        {
            if (count<0) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Count"));
            }
            return (LastIndexOfString(pSortingTable, win32LCID, source, value, startIndex, count, 0));
        }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.LastIndexOf8"]/*' />
        public unsafe virtual int LastIndexOf(String source, char value, int startIndex, int count, CompareOptions options)
        {
            if (count<0) {
                throw new ArgumentOutOfRangeException("endIndex", Environment.GetResourceString("ArgumentOutOfRange_Count"));
            }

            return (LastIndexOfChar(pSortingTable, win32LCID, source, value, startIndex, count, (int)options));
          }
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.LastIndexOf9"]/*' />
        public unsafe virtual int LastIndexOf(String source, String value, int startIndex, int count, CompareOptions options) 
        {
            if (count<0) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Count"));
            }
            return (LastIndexOfString(pSortingTable, win32LCID, source, value, startIndex, count, (int)options));
        }

    
        // This native method will check the parameters and throw appropriate exceptions if necessary.
        // Native method: COMNlsInfo::LastIndexOfChar
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe internal static extern int LastIndexOfChar(void* pSortingTable, int win32LCID, String source, char value, int startIndex, int count, int options);
        
        // This native method will check the parameters and throw appropriate exceptions if necessary.
        // Native method: COMNlsInfo::LastIndexOfString
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe internal static extern int LastIndexOfString(void* pSortingTable, int win32LCID, String source, String value, int startIndex, int count, int options);
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  GetSortKey
        //
        //  Gets the SortKey for the given string with the given options.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.GetSortKey"]/*' />
        public unsafe virtual SortKey GetSortKey(String source, CompareOptions options)
        {
            // SortKey() will check the parameters and throw appropriate exceptions if necessary.            
            return (new SortKey(pSortingTable, win32LCID, source, options)); 
        }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.GetSortKey1"]/*' />
        public unsafe virtual SortKey GetSortKey(String source)
        {
            return (new SortKey(pSortingTable, win32LCID, source, CompareOptions.None));
        }

        ////////////////////////////////////////////////////////////////////////
        //
        //  Equals
        //
        //  Implements Object.Equals().  Returns a boolean indicating whether
        //  or not object refers to the same CompareInfo as the current
        //  instance.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.Equals"]/*' />
        public override bool Equals(Object value)
        {
            //
            //  See if the object name is the same as the CompareInfo object.
            //
            if ((value != null) && (value is CompareInfo))
            {
                CompareInfo Info = (CompareInfo)value;
    
                //
                //  See if the member variables are equal.  If so, then
                //  return true.
                //
                if (this.win32LCID == Info.win32LCID)
                {
                    return (true);
                }
            }
    
            //
            //  Objects are not the same, so return false.
            //
            return (false);
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  GetHashCode
        //
        //  Implements Object.GetHashCode().  Returns the hash code for the
        //  CompareInfo.  The hash code is guaranteed to be the same for
        //  CompareInfo A and B where A.Equals(B) is true.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return (this.win32LCID);
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  ToString
        //
        //  Implements Object.ToString().  Returns a string describing the
        //  CompareInfo.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.ToString"]/*' />
        public override String ToString()
        {
            return ("CompareInfo - " + culture);
        }
    
        /// <include file='doc\CompareInfo.uex' path='docs/doc[@for="CompareInfo.LCID"]/*' />
        public int LCID
        {
            get
            {
                return (culture);
            }
        }

        // This is a thin wrapper for InitializeNativeCompareInfo() to provide the necessary
        // synchronization.

        /*=================================InitializeCompareInfo==========================
        **Action: Create/Get a native C++ SortingTable pointer using the specified assembly and Win32 LCID.
        **Returns: a 32-bit pointer value to native C++ SrotingTable instance.
        **Arguments:
        **      pNativeGlobalizationAssembly    the 32-bit pointer value to a native C++ NLSAssembly instance.
        **      win32LCID       the Win32 LCID.
        **Exceptions: 
        **      None.
        ============================================================================*/
        
        unsafe private static void* InitializeCompareInfo(void* pNativeGlobalizationAssembly, int win32LCID) {
            void* pSortingTable = null;
            lock(typeof(CompareInfo)) {
                pSortingTable = InitializeNativeCompareInfo(pNativeGlobalizationAssembly, win32LCID);
            }
            BCLDebug.Assert(pSortingTable != null, "pSortingTable != null");
            return (pSortingTable);
        }

        unsafe void IDeserializationCallback.OnDeserialization(Object sender) {
            if (pSortingTable==null){
                pSortingTable = InitializeCompareInfo(GlobalizationAssembly.m_defaultInstance.pNativeGlobalizationAssembly, win32LCID);
            }
        }

        // This method requires synchonization because class global data member is used
        // in the native side.
        // Native method: COMNlsInfo::InitializeNativeCompareInfo
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private static extern void* InitializeNativeCompareInfo(void* pNativeGlobalizationAssembly, int win32LCID);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\gregoriancalendarhelper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
    using System.Threading;
    using System;
    /*=================================EraInfo==========================
    **
    ** This is the structure to store information about an era.
    **
    ============================================================================*/

    [Serializable]
    internal class EraInfo {
        internal int era;       // The value of the era.
        internal long ticks;    // The time in ticks when the era starts
        internal int yearOffset;    // The offset to Gregorian year when the era starts.
                                    // Gregorian Year = Era Year + yearOffset
                                    // Era Year = Gregorian Year - yearOffset
        internal int minEraYear;        // Min year value in this era. Generally, this value is 1, but this may
                                        // be affected by the DateTime.MinValue;
        internal int maxEraYear;       // Max year value in this era. (== the year length of the era + 1)

        internal EraInfo(int era, long ticks, int yearOffset, int minEraYear, int maxEraYear) {
            this.era = era;
            this.ticks = ticks;
            this.yearOffset = yearOffset;
            this.minEraYear = minEraYear;
            this.maxEraYear = maxEraYear;
        }
    }                

    // 
    // This class implements the Gregorian calendar. In 1582, Pope Gregory XIII made 
    // minor changes to the solar Julian or "Old Style" calendar to make it more 
    // accurate. Thus the calendar became known as the Gregorian or "New Style" 
    // calendar, and adopted in Catholic countries such as Spain and France. Later 
    // the Gregorian calendar became popular throughout Western Europe because it 
    // was accurate and convenient for international trade. Scandinavian countries 
    // adopted it in 1700, Great Britain in 1752, the American colonies in 1752 and 
    // India in 1757. China adopted the same calendar in 1911, Russia in 1918, and 
    // some Eastern European countries as late as 1940.
    // 
    // This calendar recognizes two era values:
    // 0 CurrentEra (AD) 
    // 1 BeforeCurrentEra (BC) 
    [Serializable] internal class GregorianCalendarHelper {

        // 1 tick = 100ns = 10E-7 second
        // Number of ticks per time unit
        internal const long TicksPerMillisecond   = 10000;
        internal const long TicksPerSecond        = TicksPerMillisecond * 1000;
        internal const long TicksPerMinute        = TicksPerSecond * 60;
        internal const long TicksPerHour          = TicksPerMinute * 60;
        internal const long TicksPerDay           = TicksPerHour * 24;
    
        // Number of milliseconds per time unit
        internal const int MillisPerSecond        = 1000;
        internal const int MillisPerMinute        = MillisPerSecond * 60;
        internal const int MillisPerHour          = MillisPerMinute * 60;
        internal const int MillisPerDay           = MillisPerHour * 24;    

        // Number of days in a non-leap year
        internal const int DaysPerYear            = 365;
        // Number of days in 4 years
        internal const int DaysPer4Years          = DaysPerYear * 4 + 1;
        // Number of days in 100 years
        internal const int DaysPer100Years        = DaysPer4Years * 25 - 1;
        // Number of days in 400 years
        internal const int DaysPer400Years        = DaysPer100Years * 4 + 1;
    
        // Number of days from 1/1/0001 to 1/1/10000
        internal const int DaysTo10000            = DaysPer400Years * 25 - 366;    

        internal const long MaxMillis             = (long)DaysTo10000 * MillisPerDay;

        internal const int DatePartYear = 0;
        internal const int DatePartDayOfYear = 1;
        internal const int DatePartMonth = 2;
        internal const int DatePartDay = 3;    

        //
        // This is the max Gregorian year can be represented by DateTime class.  The limitation
        // is derived from DateTime class.
        // 
        internal int MaxYear {
            get {
                return (m_maxYear);
            }
        }

        internal static readonly int[] DaysToMonth365 = 
        {
            0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
        };
        
        internal static readonly int[] DaysToMonth366 = 
        {
            0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366
        };
        
        internal int m_maxYear = 9999;
        internal int m_minYear;
        internal Calendar m_Cal;
        internal EraInfo[] m_EraInfo;    
        internal int[] m_eras = null;
        internal DateTime m_minDate;

        /*=================================InitEraInfo==========================
        **Action: Get the era range information from calendar.nlp.
        **Returns: An array of EraInfo, which contains the information about an era.
        **Arguments:
        **      calID     the Calendar ID defined in Calendar.cs
        ============================================================================*/
        internal static EraInfo[] InitEraInfo(int calID) {
            //
            // Initialize era information.
            //

            /*
            Japaense era info example:
            eraInfo[0] = new EraInfo(4, new DateTime(1989, 1, 8).Ticks, 1988, 1, GregorianCalendar.MaxYear - 1988);    // Heisei. Most recent
            eraInfo[1] = new EraInfo(3, new DateTime(1926, 12, 25).Ticks, 1925, 1, 1989 - 1925);  // Showa
            eraInfo[2] = new EraInfo(2, new DateTime(1912, 7, 30).Ticks, 1911, 1, 1926 - 1911);   // Taisho
            eraInfo[3] = new EraInfo(1, new DateTime(1868, 9, 8).Ticks, 1867, 1, 1912 - 1867);    // Meiji            
            */
            String[] eraRanges = CalendarTable.GetMultipleStringValues(calID, CalendarTable.SERARANGES, false);
            EraInfo [] eraInfo = new EraInfo[eraRanges.Length];
            int maxEraYear = GregorianCalendar.MaxYear;
            for (int i = 0; i < eraRanges.Length; i++) {
                //
                // The eraRange string is in the form of "4;1989;1;8;1988;1".
                // num[0] is the era value.
                // num[1] is the year when the era starts.
                // num[2] is the month when the era starts.
                // num[3] is the day when the era starts.
                // num[4] is the offset to Gregorian year (1988).
                // num[5] is the minimum era year for this era.
                //
                String[] numStrs = eraRanges[i].Split(new char[] {';'});
                int[] nums = new int[6];
                for (int j = 0; j < 6; j++) {
                    nums[j] = Int32.Parse(numStrs[j], CultureInfo.InvariantCulture);
                }
                eraInfo[i] = new EraInfo(nums[0], new DateTime(nums[1], nums[2], nums[3]).Ticks, nums[4], nums[5], maxEraYear - nums[4]);
                maxEraYear= nums[1];
            }
            return (eraInfo);
        }
        
        // Construct an instance of gregorian calendar.
        internal GregorianCalendarHelper(Calendar cal, EraInfo[] eraInfo) {
            m_Cal = cal;
            m_EraInfo = eraInfo;            
            m_minDate = new DateTime(m_EraInfo[m_EraInfo.Length - 1].ticks);
            m_maxYear = m_EraInfo[0].maxEraYear;
            m_minYear = m_EraInfo[0].minEraYear;;
        }
        
        /*=================================GetGregorianYear==========================
        **Action: Get the Gregorian year value for the specified year in an era.
        **Returns: The Gregorian year value.
        **Arguments:
        **      year    the year value in Japanese calendar
        **      era     the Japanese emperor era value.
        **Exceptions:
        **      ArgumentOutOfRangeException if year value is invalid or era value is invalid.
        ============================================================================*/

        internal int GetGregorianYear(int year, int era) {
            if (year < 0) {
                throw new ArgumentOutOfRangeException("year",
                    Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum")); 
            }            
            if (era == Calendar.CurrentEra) {
                era = m_Cal.CurrentEraValue;
            }
            for (int i = 0; i < m_EraInfo.Length; i++) {
                if (era == m_EraInfo[i].era) {
                    if (year < m_EraInfo[i].minEraYear || year > m_EraInfo[i].maxEraYear) {
                        throw new ArgumentOutOfRangeException("year", 
                            String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                                m_EraInfo[i].minEraYear, m_EraInfo[i].maxEraYear));
                    }
                    return (m_EraInfo[i].yearOffset + year);
                }
            }
            throw new ArgumentOutOfRangeException(Environment.GetResourceString("Argument_InvalidEraValue"));
        }

        // Returns a given date part of this DateTime. This method is used
        // to compute the year, day-of-year, month, or day part.
        internal virtual int GetDatePart(long ticks, int part) 
        {
            CheckTicksRange(ticks);
            // n = number of days since 1/1/0001
            int n = (int)(ticks / TicksPerDay);
            // y400 = number of whole 400-year periods since 1/1/0001
            int y400 = n / DaysPer400Years;
            // n = day number within 400-year period
            n -= y400 * DaysPer400Years;
            // y100 = number of whole 100-year periods within 400-year period
            int y100 = n / DaysPer100Years;
            // Last 100-year period has an extra day, so decrement result if 4
            if (y100 == 4) y100 = 3;        
            // n = day number within 100-year period
            n -= y100 * DaysPer100Years;
            // y4 = number of whole 4-year periods within 100-year period
            int y4 = n / DaysPer4Years;
            // n = day number within 4-year period
            n -= y4 * DaysPer4Years;
            // y1 = number of whole years within 4-year period
            int y1 = n / DaysPerYear;
            // Last year has an extra day, so decrement result if 4
            if (y1 == 4) y1 = 3;        
            // If year was requested, compute and return it
            if (part == DatePartYear) 
            {
                return (y400 * 400 + y100 * 100 + y4 * 4 + y1 + 1);
            }
            // n = day number within year
            n -= y1 * DaysPerYear;
            // If day-of-year was requested, return it
            if (part == DatePartDayOfYear) 
            {
                return (n + 1);
            }
            // Leap year calculation looks different from IsLeapYear since y1, y4,
            // and y100 are relative to year 1, not year 0
            bool leapYear = (y1 == 3 && (y4 != 24 || y100 == 3));
            int[] days = leapYear? DaysToMonth366: DaysToMonth365;
            // All months have less than 32 days, so n >> 5 is a good conservative
            // estimate for the month
            int m = n >> 5 + 1;
            // m = 1-based month number
            while (n >= days[m]) m++;
            // If month was requested, return it
            if (part == DatePartMonth) return (m);
            // Return 1-based day-of-month
            return (n - days[m - 1] + 1);
        }

        /*=================================GetAbsoluteDate==========================
        **Action: Gets the absolute date for the given Gregorian date.  The absolute date means
        **       the number of days from January 1st, 1 A.D.
        **Returns:  the absolute date
        **Arguments:
        **      year    the Gregorian year
        **      month   the Gregorian month
        **      day     the day
        **Exceptions:
        **      ArgumentOutOfRangException  if year, month, day value is valid.
        **Note:
        **      This is an internal method used by DateToTicks() and the calculations of Hijri and Hebrew calendars.
        **      Number of Days in Prior Years (both common and leap years) +
        **      Number of Days in Prior Months of Current Year +
        **      Number of Days in Current Month
        **
        ============================================================================*/

        internal static long GetAbsoluteDate(int year, int month, int day) {
            if (year >= 1 && year <= 9999 && month >= 1 && month <= 12) 
            {
                int[] days = ((year % 4 == 0 && (year % 100 != 0 || year % 400 == 0))) ? DaysToMonth366: DaysToMonth365;
                if (day >= 1 && (day <= days[month] - days[month - 1])) {
                    int y = year - 1;
                    int absoluteDate = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;
                    return (absoluteDate);
                }
            }
            throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_BadYearMonthDay"));
        }        

        // Returns the tick count corresponding to the given year, month, and day.
        // Will check the if the parameters are valid.
        internal virtual long DateToTicks(int year, int month, int day) {
            return (GetAbsoluteDate(year, month,  day)* TicksPerDay);
        }

        internal void CheckTicksRange(long ticks) {
            if (ticks < m_minDate.Ticks) {
                throw new ArgumentOutOfRangeException("time", 
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_CalendarRange"), 
                            m_minDate,DateTime.MaxValue));
            }
        }

        // Returns the DateTime resulting from adding the given number of
        // months to the specified DateTime. The result is computed by incrementing
        // (or decrementing) the year and month parts of the specified DateTime by
        // value months, and, if required, adjusting the day part of the
        // resulting date downwards to the last day of the resulting month in the
        // resulting year. The time-of-day part of the result is the same as the
        // time-of-day part of the specified DateTime.
        //
        // In more precise terms, considering the specified DateTime to be of the
        // form y / m / d + t, where y is the
        // year, m is the month, d is the day, and t is the
        // time-of-day, the result is y1 / m1 / d1 + t,
        // where y1 and m1 are computed by adding value months
        // to y and m, and d1 is the largest value less than
        // or equal to d that denotes a valid day in month m1 of year
        // y1.
        //
        public DateTime AddMonths(DateTime time, int months) 
        {
            CheckTicksRange(time.Ticks);
            if (months < -120000 || months > 120000) {
                throw new ArgumentOutOfRangeException(
                    "months", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    -120000, 120000));
            }
            int y = GetDatePart(time.Ticks, DatePartYear);
            int m = GetDatePart(time.Ticks, DatePartMonth);
            int d = GetDatePart(time.Ticks, DatePartDay);
            int i = m - 1 + months;
            if (i >= 0) 
            {
                m = i % 12 + 1;
                y = y + i / 12;
            }
            else 
            {
                m = 12 + (i + 1) % 12;
                y = y + (i - 11) / 12;
            }
            int[] daysArray = (y % 4 == 0 && (y % 100 != 0 || y % 400 == 0)) ? DaysToMonth366: DaysToMonth365;
            int days = (daysArray[m] - daysArray[m - 1]); 
            
            if (d > days) 
            {
                d = days;
            }
            return (new DateTime(DateToTicks(y, m, d) + time.Ticks % TicksPerDay));
        }
            
        // Returns the DateTime resulting from adding the given number of
        // years to the specified DateTime. The result is computed by incrementing
        // (or decrementing) the year part of the specified DateTime by value
        // years. If the month and day of the specified DateTime is 2/29, and if the
        // resulting year is not a leap year, the month and day of the resulting
        // DateTime becomes 2/28. Otherwise, the month, day, and time-of-day
        // parts of the result are the same as those of the specified DateTime.
        //
        public DateTime AddYears(DateTime time, int years) 
        {
            return (AddMonths(time, years * 12));
        }
    
        // Returns the day-of-month part of the specified DateTime. The returned
        // value is an integer between 1 and 31.
        //
        public int GetDayOfMonth(DateTime time)
        {
            return (GetDatePart(time.Ticks, DatePartDay));
        }
    
        // Returns the day-of-week part of the specified DateTime. The returned value
        // is an integer between 0 and 6, where 0 indicates Sunday, 1 indicates
        // Monday, 2 indicates Tuesday, 3 indicates Wednesday, 4 indicates
        // Thursday, 5 indicates Friday, and 6 indicates Saturday.
        //
        public DayOfWeek GetDayOfWeek(DateTime time) 
        {
            CheckTicksRange(time.Ticks);
            return ((DayOfWeek)((time.Ticks / TicksPerDay + 1) % 7));
        }
    
        // Returns the day-of-year part of the specified DateTime. The returned value
        // is an integer between 1 and 366.
        //
        public int GetDayOfYear(DateTime time)
        {
            return (GetDatePart(time.Ticks, DatePartDayOfYear));
        }

        // Returns the number of days in the month given by the year and
        // month arguments.
        //
        public int GetDaysInMonth(int year, int month, int era) {
            //
            // Convert year/era value to Gregorain year value.
            //
            year = GetGregorianYear(year, era);
            if (month < 1 || month > 12) {
                throw new ArgumentOutOfRangeException("month", Environment.GetResourceString("ArgumentOutOfRange_Month"));
            }
            int[] days = ((year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) ? DaysToMonth366: DaysToMonth365);
            return (days[month] - days[month - 1]);        
        }
    
        // Returns the number of days in the year given by the year argument for the current era.
        //

        public int GetDaysInYear(int year, int era)
        {
            //
            // Convert year/era value to Gregorain year value.
            //
            year = GetGregorianYear(year, era);
            return ((year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) ? 366:365);
        }
    
        // Returns the era for the specified DateTime value.
        public int GetEra(DateTime time)
        {
            long ticks = time.Ticks;
            // The assumption here is that m_EraInfo is listed in reverse order.
            for (int i = 0; i < m_EraInfo.Length; i++) {
                if (ticks >= m_EraInfo[i].ticks) {
                    return (m_EraInfo[i].era);
                }
            }
            throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_Era"));
        }


        public int[] Eras {
            get {
                if (m_eras == null) {
                    m_eras = new int[m_EraInfo.Length];
                    for (int i = 0; i < m_EraInfo.Length; i++) {
                        m_eras[i] = m_EraInfo[i].era;
                    }
                }
                return ((int[])m_eras.Clone());
            }
        }
            
        // Returns the month part of the specified DateTime. The returned value is an
        // integer between 1 and 12.
        //
        public int GetMonth(DateTime time) 
        {
            return (GetDatePart(time.Ticks, DatePartMonth));
        }
    
        // Returns the number of months in the specified year and era.
        public int GetMonthsInYear(int year, int era)
        {
            year = GetGregorianYear(year, era);
            return (12);
        }
                
        // Returns the year part of the specified DateTime. The returned value is an
        // integer between 1 and 9999.
        //
        public int GetYear(DateTime time) 
        {
            long ticks = time.Ticks;
            int year = GetDatePart(ticks, DatePartYear);
            for (int i = 0; i < m_EraInfo.Length; i++) {
                if (ticks >= m_EraInfo[i].ticks) {
                    return (year - m_EraInfo[i].yearOffset);
                }
            }
            throw new ArgumentException(Environment.GetResourceString("Argument_NoEra"));
        }    
    
        // Checks whether a given day in the specified era is a leap day. This method returns true if
        // the date is a leap day, or false if not.
        //
        public bool IsLeapDay(int year, int month, int day, int era)
        {
            // year/month/era checking is done in GetDaysInMonth()
            if (day < 1 || day > GetDaysInMonth(year, month, era)) {
                throw new ArgumentOutOfRangeException("day", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    1, GetDaysInMonth(year, month, era)));                
            }
            if (!IsLeapYear(year, era)) {
                return (false);
            }
            if (month == 2 && day == 29) {
                return (true);
            }
            return (false);            
        }
    
        // Checks whether a given month in the specified era is a leap month. This method returns true if
        // month is a leap month, or false if not.
        //
        public bool IsLeapMonth(int year, int month, int era)
        {
            year = GetGregorianYear(year, era);
            if (month < 1 || month > 12) {
                throw new ArgumentOutOfRangeException("month", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    1, 12));                
            }            
            return (false);        
        }
    
        // Checks whether a given year in the specified era is a leap year. This method returns true if
        // year is a leap year, or false if not.
        //
        public bool IsLeapYear(int year, int era) {
            year = GetGregorianYear(year, era);
            return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));
        }
    
        // Returns the date and time converted to a DateTime value.  Throws an exception if the n-tuple is invalid.
        //
        public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) {
            year = GetGregorianYear(year, era);
            return (new DateTime(year, month, day, hour, minute, second, millisecond));
        }

        public int ToFourDigitYear(int year, int twoDigitYearMax) {
            if (year < 0) {
                throw new ArgumentOutOfRangeException("year",
                    Environment.GetResourceString("ArgumentOutOfRange_NeedPosNum"));                
            }
            if (year < 100) {
                int y = year % 100;
                return ((twoDigitYearMax/100 - ( y > twoDigitYearMax % 100 ? 1 : 0))*100 + y);
            }
            if (year < m_minYear || year > m_maxYear) {
                throw new ArgumentOutOfRangeException("year",
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), m_minYear, m_maxYear));
            }
            // If the year value is above 100, just return the year value.  Don't have to do
            // the TwoDigitYearMax comparison.
            return (year);
        }
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\datetimeparse.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Class:    DateTimeParse
//
//  Author:   Yung-Shin Lin (YSLin)
//
//  Purpose:  This class is called by DateTime to parse a date/time string.
//
//  Date:     July 8, 1999
//
////////////////////////////////////////////////////////////////////////////

//#define YSLIN_DEBUG

namespace System {
    using System;
    using System.Text;
    using System.Globalization;
    using System.Threading;
    using System.Collections;

    ////////////////////////////////////////////////////////////////////////
    /*
     NOTENOTE yslin:

     Most of the code is ported from OLEAUT Bstrdate.cpp (file:\\vue\oleaut\ole2auto\oa97).
     However, the state machine are modified to deal with more cultures.

     There are some nasty cases in the parsing of date/time:

     0x438    fo  (country:Faroe Islands, languge:Faroese)
        LOCALE_STIME=[.]
        LOCALE_STIMEFOR=[HH.mm.ss]
        LOCALE_SDATE=[-]
        LOCALE_SSHORTDATE=[dd-MM-yyyy]
        LOCALE_SLONGDATE=[d. MMMM yyyy]

        The time separator is ".", However, it also has a "." in the long date format.

     0x437: (country:Georgia, languge:Georgian)
        Short date: dd.MM.yy
        Long date:  yyyy ???? dd MM, dddd

        The order in long date is YDM, which is different from the common ones: YMD/MDY/DMY.

     0x0404: (country:Taiwan, languge:Chinese)
        LOCALE_STIMEFORMAT=[tt hh:mm:ss]

        When general date is used, the pattern is "yyyy/M/d tt hh:mm:ss". Note that the "tt" is after "yyyy/M/d".
        And this is different from most cultures.

     0x0437: (country:Georgia, languge:Georgian)
        Short date: dd.MM.yy
        Long date:  yyyy ???? dd MM, dddd

     0x0456:        

     */
    ////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////
    /*
     BUGBUG yslin:
     TODO yslin:
        * Support of era in China/Taiwan/Japan.
     */
    ////////////////////////////////////////////////////////////////////////
    //This class contains only static members and does not require the serializable attribute.
    
    internal 
    class DateTimeParse {
        private static String alternativeDateSeparator = "-";
        private static DateTimeFormatInfo invariantInfo = DateTimeFormatInfo.InvariantInfo;

        //
        // This is used to cache the lower-cased month names of the invariant culture.
        //
        private static String[] invariantMonthNames = null;
        private static String[] invariantAbbrevMonthNames = null;

        //
        // This is used to cache the lower-cased day names of the invariant culture.
        //
        private static String[] invariantDayNames = null;
        private static String[] invariantAbbrevDayNames = null;

        private static String invariantAMDesignator = invariantInfo.AMDesignator;
        private static String invariantPMDesignator = invariantInfo.PMDesignator;

        private static DateTimeFormatInfo m_jajpDTFI = null;
        private static DateTimeFormatInfo m_zhtwDTFI = null;

        internal static DateTime ParseExact(String s, String format, DateTimeFormatInfo dtfi, DateTimeStyles style) {
            if (s == null || format == null) {
                throw new ArgumentNullException((s == null ? "s" : "format"),
                    Environment.GetResourceString("ArgumentNull_String"));
            }

            if (s.Length == 0) {
                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
            }
            
            if (format.Length == 0) {
                throw new FormatException(Environment.GetResourceString("Format_BadFormatSpecifier"));
            }
            
            if (dtfi == null)
            {
                dtfi = DateTimeFormatInfo.CurrentInfo;
            }

            DateTime result;
            if (DoStrictParse(s, format, style, dtfi, true, out result)) {
                return (result);
            }
            //
            // This is just used to keep compiler happy.
            // This is because DoStrictParse() alwyas does either:
            //      1. Return true or
            //      2. Throw exceptions if there is error in parsing.
            // So we will never get here.
            //
            return (new DateTime());
        }

        internal static bool ParseExactMultiple(String s, String[] formats, 
                                                DateTimeFormatInfo dtfi, DateTimeStyles style, out DateTime result) {
            if (s == null || formats == null) {
                throw new ArgumentNullException((s == null ? "s" : "formats"),
                    Environment.GetResourceString("ArgumentNull_String"));
            }

            if (s.Length == 0) {
                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
            }

            if (formats.Length == 0) {
                throw new FormatException(Environment.GetResourceString("Format_BadFormatSpecifier"));
            }

            if (dtfi == null) {
                dtfi = DateTimeFormatInfo.CurrentInfo;
            }

            //
            // Do a loop through the provided formats and see if we can parse succesfully in 
            // one of the formats.
            //
            for (int i = 0; i < formats.Length; i++) {
                if (formats[i] == null || formats[i].Length == 0) {
                    throw new FormatException(Environment.GetResourceString("Format_BadFormatSpecifier"));
                }
                if (DoStrictParse(s, formats[i], style, dtfi, false, out result)) {
                    return (true);
                } 
            }
            result = new DateTime(0);
            return (false);
        }

        ////////////////////////////////////////////////////////////////////////////
        //
        // separator types
        //
        ////////////////////////////////////////////////////////////////////////////

        private const int SEP_Unk        = 0;    // Unknown separator.
        private const int SEP_End        = 1;    // The end of the parsing string.
        private const int SEP_Space      = 2;    // Whitespace (including comma).
        private const int SEP_Am         = 3;    // AM timemark.
        private const int SEP_Pm         = 4;    // PM timemark.
        private const int SEP_Date       = 5;    // date separator.
        private const int SEP_Time       = 6;    // time separator.
        private const int SEP_YearSuff   = 7;    // Chinese/Japanese/Korean year suffix.
        private const int SEP_MonthSuff  = 8;    // Chinese/Japanese/Korean month suffix.
        private const int SEP_DaySuff    = 9;    // Chinese/Japanese/Korean day suffix.
        private const int SEP_HourSuff   = 10;   // Chinese/Japanese/Korean hour suffix.
        private const int SEP_MinuteSuff = 11;   // Chinese/Japanese/Korean minute suffix.
        private const int SEP_SecondSuff = 12;   // Chinese/Japanese/Korean second suffix.
        private const int SEP_LocalTimeMark = 13;   // 'T'
        private const int SEP_Max        = 14;

        #if YSLIN_DEBUG
        private static readonly String [] separatorNames =
        {
            "SEP_Unk","SEP_End","SEP_Space","SEP_Am","SEP_Pm",
            "SEP_Date","SEP_Time","SEP_YearSuff","SEP_MonthSuff","SEP_DaySuff","SEP_HourSuff",
            "SEP_MinuteSuff","SEP_SecondSuff","Sep_LocalTimeMark", "SEP_Max",
        };
        #endif

        ////////////////////////////////////////////////////////////////////////////
        // Date Token Types (DTT_*)
        //
        // Following is the set of tokens that can be generated from a date
        // string. Notice that the legal set of trailing separators have been
        // folded in with the date number, and month name tokens. This set
        // of tokens is chosen to reduce the number of date parse states.
        //
        ////////////////////////////////////////////////////////////////////////////

        private const int DTT_End        = 0;    // '\0'
        private const int DTT_NumEnd     = 1;    // Num[ ]*[\0]
        private const int DTT_NumAmpm    = 2;    // Num[ ]+AmPm
        private const int DTT_NumSpace   = 3;    // Num[ ]+^[Dsep|Tsep|'0\']
        private const int DTT_NumDatesep = 4;    // Num[ ]*Dsep
        private const int DTT_NumTimesep = 5;    // Num[ ]*Tsep
        private const int DTT_MonthEnd   = 6;    // Month[ ]*'\0'
        private const int DTT_MonthSpace = 7;    // Month[ ]+^[Dsep|Tsep|'\0']
        private const int DTT_MonthDatesep=8;    // Month[ ]*Dsep
        private const int DTT_NumDatesuff= 9;    // Month[ ]*DSuff
        private const int DTT_NumTimesuff= 10;   // Month[ ]*TSuff
        private const int DTT_DayOfWeek  = 11;   // Day of week name
        private const int DTT_YearSpace	= 12;   // Year+^[Dsep|Tsep|'0\']
        private const int DTT_YearDateSep= 13;  // Year+Dsep
        private const int DTT_YearEnd    = 14;  // Year+['\0']
        private const int DTT_TimeZone   = 15;  // timezone name
        private const int DTT_Era       = 16;  // era name
        private const int DTT_NumUTCTimeMark = 17;      // Num + 'Z'
        // When you add a new token which will be in the
        // state table, add it after DTT_NumLocalTimeMark.
        private const int DTT_Unk        = 18;   // unknown
        private const int DTT_NumLocalTimeMark = 19;    // Num + 'T'
        private const int DTT_Max        = 20;   // marker

        #if YSLIN_DEBUG
        private static String[] tokenNames =
        {
            "DTT_End","DTT_NumEnd","DTT_NumAmpm","DTT_NumSpace","DTT_NumDatesep",
            "DTT_NumTimesep","DTT_MonthEnd","DTT_MonthSpace","DTT_MonthDatesep","DTT_NumDatesuff",
            "DTT_NumTimesuff","DTT_DayOfWeek", "DTT_YearSpace", "DTT_YearDateSep", "DTT_YearEnd",
            "DTT_TimeZone", "DTT_Era",
            "DTT_Unk", "DTT_NumLocalTimeMark", "DTT_Max",
        };
        #endif

        private const int TM_AM      = 0;
        private const int TM_PM      = 1;

        //
        // Year/Month/Day suffixes
        //
        private const String CJKYearSuff             = "\u5e74";
        private const String CJKMonthSuff            = "\u6708";
        private const String CJKDaySuff              = "\u65e5";

        private const String KoreanYearSuff          = "\ub144";
        private const String KoreanMonthSuff         = "\uc6d4";
        private const String KoreanDaySuff           = "\uc77c";

        private const String KoreanHourSuff          = "\uc2dc";
        private const String KoreanMinuteSuff        = "\ubd84";
        private const String KoreanSecondSuff        = "\ucd08";

        private const String CJKHourSuff             = "\u6642";
        private const String ChineseHourSuff         = "\u65f6";

        private const String CJKMinuteSuff           = "\u5206";
        private const String CJKSecondSuff           = "\u79d2";

        private const String LocalTimeMark           = "T";

        ////////////////////////////////////////////////////////////////////////////
        //
        // DateTime parsing state enumeration (DS_*)
        //
        ////////////////////////////////////////////////////////////////////////////

        private const int DS_BEGIN   = 0;
        private const int DS_N       = 1;        // have one number
        private const int DS_NN      = 2;        // have two numbers

        // The following are known to be part of a date

        private const int DS_D_Nd    = 3;        // date string: have number followed by date separator
        private const int DS_D_NN    = 4;        // date string: have two numbers
        private const int DS_D_NNd   = 5;        // date string: have two numbers followed by date separator

        private const int DS_D_M     = 6;        // date string: have a month
        private const int DS_D_MN    = 7;        // date string: have a month and a number
        private const int DS_D_NM    = 8;        // date string: have a number and a month
        private const int DS_D_MNd   = 9;        // date string: have a month and number followed by date separator
        private const int DS_D_NDS   = 10;       // date string: have one number followed a date suffix.

        private const int DS_D_Y	    = 11;		// date string: have a year.
        private const int DS_D_YN	= 12;		// date string: have a year and a number
        private const int DS_D_YM	= 13;		// date string: have a year and a month

        private const int DS_D_S     = 14;       // have numbers followed by a date suffix.
        private const int DS_T_S     = 15;       // have numbers followed by a time suffix.

        // The following are known to be part of a time

        private const int DS_T_Nt    = 16;      	// have num followed by time separator
        private const int DS_T_NNt   = 17;       // have two numbers followed by time separator


        private const int DS_ERROR   = 18;

        // The following are terminal states. These all have an action
        // associated with them; and transition back to DS_BEGIN.

        private const int DS_DX_NN   = 19;       // day from two numbers
        private const int DS_DX_NNN  = 20;       // day from three numbers
        private const int DS_DX_MN   = 21;       // day from month and one number
        private const int DS_DX_NM   = 22;       // day from month and one number
        private const int DS_DX_MNN  = 23;       // day from month and two numbers
        private const int DS_DX_DS   = 24;       // a set of date suffixed numbers.

        private const int DS_DX_DSN  = 25;       // day from date suffixes and one number.
        private const int DS_DX_NDS  = 26;       // day from one number and date suffixes .
        private const int DS_DX_NNDS = 27;       // day from one number and date suffixes .

        private const int DS_DX_YNN = 28;       // date string: have a year and two number
        private const int DS_DX_YMN = 29;       // date string: have a year, a month, and a number.
        private const int DS_DX_YN  = 30;       // date string: have a year and one number
        private const int DS_DX_YM  = 31;       // date string: have a year, a month.

        private const int DS_TX_N    = 32;       // time from one number (must have ampm)
        private const int DS_TX_NN   = 33;       // time from two numbers
        private const int DS_TX_NNN  = 34;       // time from three numbers
        private const int DS_TX_TS   = 35;       // a set of time suffixed numbers.

        private const int DS_DX_NNY  = 36;

        private const int DS_MAX     = 37;       // marker: end of enum

        ////////////////////////////////////////////////////////////////////////////
        //
        // NOTE: The following state machine table is dependent on the order of the
        // DS_ and DTT_ enumerations.
        //
        // For each non terminal state, the following table defines the next state
        // for each given date token type.
        //
        ////////////////////////////////////////////////////////////////////////////

//           DTT_End   DTT_NumEnd  DTT_NumAmPm DTT_NumSpace
//                                                        DTT_NumDaySep
//                                                                    DTT_NumTimesep
//                                                                               DTT_MonthEnd DTT_MonthSpace
//                                                                                                        DTT_MonthDSep
//                                                                                                                    DTT_NumDateSuff
//                                                                                                                                DTT_NumTimeSuff DTT_DayOfWeek
//                                                                                                                                                              DTT_YearSpace
//                                                                                                                                                                         DTT_YearDateSep
//                                                                                                                                                                                      DTT_YearEnd,
//                                                                                                                                                                                                  DTT_TimeZone
//                                                                                                                                                                                                             DTT_Era      DTT_UTCTimeMark
private static int[][] dateParsingStates = {
// DS_BEGIN                                                                             // DS_BEGIN
new int[] { DS_BEGIN, DS_ERROR,   DS_TX_N,    DS_N,       DS_D_Nd,    DS_T_Nt,    DS_ERROR,   DS_D_M,     DS_D_M,     DS_D_S,     DS_T_S,         DS_BEGIN,     DS_D_Y,     DS_D_Y,     DS_ERROR,   DS_BEGIN,  DS_BEGIN,    DS_ERROR},

// DS_N                                                                                 // DS_N
new int[] { DS_ERROR, DS_DX_NN,   DS_ERROR,   DS_NN,      DS_D_NNd,   DS_ERROR,   DS_DX_NM,   DS_D_NM,    DS_D_MNd,   DS_D_NDS,   DS_ERROR,       DS_N,         DS_D_YN,    DS_D_YN,    DS_DX_YN,   DS_N,      DS_N,        DS_ERROR}, 

// DS_NN                                                                                // DS_NN
new int[] { DS_DX_NN, DS_DX_NNN,  DS_TX_N,    DS_DX_NNN,  DS_ERROR,   DS_T_Nt,    DS_DX_MNN,  DS_DX_MNN,  DS_ERROR,   DS_ERROR,   DS_T_S,         DS_NN,        DS_DX_NNY,  DS_ERROR,	DS_DX_NNY,  DS_NN,     DS_NN,       DS_ERROR},

// DS_D_Nd                                                                              // DS_D_Nd
//new int[] { DS_ERROR, DS_DX_NN,   DS_ERROR,   DS_D_NN,    DS_D_NNd,   DS_ERROR,   DS_DX_MN,   DS_D_MN,    DS_D_MNd,   DS_ERROR,   DS_ERROR,       DS_D_Nd, 	DS_D_YN,	DS_D_YN, 	DS_DX_YN,   DS_ERROR,      DS_D_Nd,     DS_ERROR},
new int[] { DS_ERROR, DS_DX_NN,   DS_ERROR,   DS_D_NN,    DS_D_NNd,   DS_ERROR,   DS_DX_NM,   DS_D_MN,    DS_D_MNd,   DS_ERROR,   DS_ERROR,       DS_D_Nd, 	DS_D_YN,	DS_D_YN, 	DS_DX_YN,   DS_ERROR,      DS_D_Nd,     DS_ERROR},

// DS_D_NN                                                                              // DS_D_NN
new int[] { DS_DX_NN, DS_DX_NNN,  DS_TX_N,    DS_DX_NNN,  DS_ERROR,   DS_T_Nt,    DS_DX_MNN,  DS_DX_MNN,  DS_ERROR,   DS_DX_DS,   DS_T_S,         DS_D_NN,     DS_DX_NNY,   DS_ERROR,   DS_DX_NNY,  DS_ERROR,  DS_D_NN,     DS_ERROR},

// DS_D_NNd                                                                             // DS_D_NNd
new int[] { DS_ERROR, DS_DX_NNN,  DS_DX_NNN,  DS_DX_NNN,  DS_DX_NNN,  DS_ERROR,   DS_DX_MNN,  DS_DX_MNN,  DS_ERROR,   DS_DX_DS,   DS_ERROR,       DS_D_NNd,     DS_DX_NNY,  DS_ERROR,   DS_DX_NNY,  DS_ERROR,  DS_D_NNd,    DS_ERROR},

// DS_D_M                                                                               // DS_D_M
new int[] { DS_ERROR, DS_DX_MN,   DS_ERROR,   DS_D_MN,    DS_D_MNd,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,       DS_D_M,       DS_D_YM,    DS_D_YM,    DS_DX_YM,   DS_ERROR,   DS_D_M,     DS_ERROR},

// DS_D_MN                                                                              // DS_D_MN
new int[] { DS_DX_MN, DS_DX_MNN,  DS_DX_MNN,  DS_DX_MNN,  DS_DX_MNN,  DS_T_Nt,    DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_DX_DS,   DS_T_S,         DS_D_MN,      DS_DX_YMN,  DS_DX_YMN,  DS_DX_YMN,  DS_ERROR,  DS_D_MN,     DS_ERROR},

// DS_D_NM                                                                              // DS_D_NM
new int[] { DS_DX_NM, DS_DX_MNN,  DS_DX_MNN,  DS_DX_MNN,  DS_ERROR,   DS_T_Nt,    DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_DX_DS,   DS_T_S,         DS_D_NM,      DS_DX_YMN,	DS_ERROR,	DS_DX_YMN,  DS_ERROR,   DS_D_NM,    DS_ERROR},

// DS_D_MNd                                                                             // DS_D_MNd
//new int[] { DS_ERROR, DS_DX_MNN,  DS_ERROR,   DS_DX_MNN,  DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,       DS_D_MNd, 	DS_DX_YMN,	DS_ERROR,	DS_DX_YMN,  DS_ERROR,   DS_D_MNd,   DS_ERROR},
new int[] { DS_DX_MN, DS_DX_MNN,  DS_ERROR,   DS_DX_MNN,  DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,       DS_D_MNd, 	DS_DX_YMN,	DS_ERROR,	DS_DX_YMN,  DS_ERROR,   DS_D_MNd,   DS_ERROR},

// DS_D_NDS,                                                                            // DS_D_NDS,
new int[] { DS_DX_NDS,DS_DX_NNDS, DS_DX_NNDS, DS_DX_NNDS, DS_ERROR,   DS_T_Nt,    DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_D_NDS,   DS_T_S,         DS_D_NDS, 	DS_ERROR,	DS_ERROR,	DS_ERROR,   DS_ERROR,   DS_D_NDS,   DS_ERROR},

// DS_D_Y                                                                               // DS_D_Y
new int[] { DS_ERROR, DS_ERROR,   DS_ERROR,   DS_D_YN,    DS_D_YN,    DS_ERROR,   DS_DX_YM,   DS_D_YM,    DS_D_YM,    DS_D_YM,    DS_ERROR,       DS_D_Y, 	DS_ERROR,	DS_ERROR,	DS_ERROR,   DS_ERROR,       DS_D_Y,     DS_ERROR},

// DS_D_YN                                                                              // DS_D_YN
new int[] { DS_ERROR, DS_DX_YNN,  DS_DX_YNN,  DS_DX_YNN,  DS_DX_YNN,  DS_ERROR,   DS_DX_YMN,  DS_DX_YMN,  DS_ERROR,   DS_ERROR,   DS_ERROR,       DS_D_YN,  	DS_ERROR,	DS_ERROR,	DS_ERROR,   DS_ERROR,   DS_D_YN,    DS_ERROR},

// DS_D_YM                                                                              // DS_D_YM
new int[] { DS_DX_YM, DS_DX_YMN,  DS_DX_YMN,  DS_DX_YMN,  DS_DX_YMN,  DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,       DS_D_YM,      DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_D_YM,    DS_ERROR},

// DS_D_S                                                                               // DS_D_S
new int[] { DS_DX_DS, DS_DX_DSN,  DS_TX_N,    DS_T_Nt,    DS_ERROR,   DS_T_Nt,    DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_D_S,     DS_T_S,         DS_D_S,  	DS_ERROR,	DS_ERROR,	DS_ERROR,   DS_ERROR,       DS_D_S,     DS_ERROR},

// DS_T_S                                                                               // DS_T_S
new int[] { DS_TX_TS, DS_TX_TS,   DS_TX_TS,   DS_T_Nt,    DS_D_Nd,    DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_D_S,     DS_T_S,         DS_T_S,  	DS_ERROR,	DS_ERROR,	DS_ERROR,   DS_T_S,         DS_T_S,     DS_ERROR},

// DS_T_Nt                                                                              // DS_T_Nt
//new int[] { DS_ERROR, DS_TX_NN,   DS_TX_NN,   DS_TX_NN,   DS_ERROR,   DS_T_NNt,   DS_ERROR,   DS_D_NM,    DS_ERROR,   DS_ERROR,   DS_T_S,         DS_ERROR, 	DS_ERROR,	DS_ERROR,	DS_ERROR,   DS_T_Nt,    DS_T_Nt,    DS_TX_NN},
new int[] { DS_ERROR, DS_TX_NN,   DS_TX_NN,   DS_TX_NN,   DS_ERROR,   DS_T_NNt,   DS_DX_NM,   DS_D_NM,    DS_ERROR,   DS_ERROR,   DS_T_S,         DS_ERROR, 	DS_ERROR,	DS_ERROR,	DS_ERROR,   DS_T_Nt,    DS_T_Nt,    DS_TX_NN},

// DS_T_NNt                                                                             // DS_T_NNt
new int[] { DS_ERROR, DS_TX_NNN,  DS_TX_NNN,  DS_TX_NNN,  DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_ERROR,   DS_T_S,         DS_T_NNt,  	DS_ERROR,	DS_ERROR,	DS_ERROR,   DS_T_NNt,   DS_T_NNt,   DS_TX_NNN},

};
//          End       NumEnd      NumAmPm     NumSpace    NumDaySep   NumTimesep  MonthEnd    MonthSpace  MonthDSep   NumDateSuff NumTimeSuff     DayOfWeek   YearSpace YearDateSep YearEnd

        #if YSLIN_DEBUG
        private static readonly String[] dateParsingStateNames =
        {
            "DS_BEGIN", "DS_N",     "DS_NN",
            "DS_D_Nd",  "DS_D_NN",
            "DS_D_NNd", "DS_D_M",   "DS_D_MN",  "DS_D_NM",  "DS_D_MNd",     "DS_D_NDS",
            "DS_D_Y", "DS_D_YN", "DS_D_YM",
            "DS_D_S",   "DS_T_S",
            "DS_T_Nt",  "DS_T_NNt", "DS_ERROR",
            "DS_DX_NN", "DS_DX_NNN","DS_DX_MN", "DS_DX_NM", "DS_DX_MNN",
            "DS_DX_DS",
            "DS_DX_DSN",    "DS_DX_NDS",    "DS_DX_NNDS",
            "DS_DX_YNN", "DS_DX_YMN", "DS_DX_YN", "DS_DX_YM",
            "DS_TX_N",  "DS_TX_NN", "DS_TX_NNN","DS_TX_TS",
            "DS_DX_NNY",
            "DS_MAX",
        };
        #endif

        private const String GMTName = "GMT";
        private const String ZuluName = "Z";

        //
        // Search from the index of str at str.Index to see if the target string exists in the str.
        //
        // @param allowPartialMatch If true, the method will not check if the matching string
        //        is in a word boundary, and will skip to the word boundary.
        //        For example, it will return true for matching "January" in "Januaryfoo".
        //        If false, the matching word must be in a word boundary. So it will return
        //        false for matching "January" in "Januaryfoo".
        //
        private static bool MatchWord(__DTString str, String target, bool allowPartialMatch)
        {
            int length = target.Length;
            if (length > (str.Value.Length - str.Index)) {
                return false;
            }
            if (CultureInfo.CurrentCulture.CompareInfo.Compare(str.Value, 
                                                               str.Index,
                                                               length,
                                                               target, 
                                                               0,
                                                               length,
                                                               CompareOptions.IgnoreCase)!=0) {
                return (false);
            }

            int nextCharIndex = str.Index + target.Length;

            if (allowPartialMatch)
            {
                //
                // Skip the remaining part of the word.
                //
                // This is to ignore special cases like:
                //    a few cultures has suffix after MMMM, like "fi" and "eu".
                while (nextCharIndex < str.Value.Length)
                {
                    if (!Char.IsLetter(str.Value[nextCharIndex]))
                    {
                        break;
                    }
                    nextCharIndex++;
                }
            } else {
                if (nextCharIndex < str.Value.Length) {
                    char nextCh = str.Value[nextCharIndex];
                    if (Char.IsLetter(nextCh) || nextCh == '\x00a1') {
                        // The '\x00a1' is a very unfortunate hack, since
                        // gl-ES (0x0456) used '\x00a1' in their day of week names.
                        // And '\x00a1' is a puctuation.  This breaks our
                        // assumption that there is no non-letter characters
                        // following a day/month name.  
                        return (false);
            }
                }
            }
            str.Index = nextCharIndex;

            return (true);
        }

        //
        // Starting at str.Index, check the type of the separator.
        //
        // @return The value like SEP_Unk, SEP_End, etc.
        //
        private static int GetSeparator(__DTString str, DateTimeRawInfo raw, DateTimeFormatInfo dtfi) {
            int separator = SEP_Space;  // Assume the separator is a space. And try to find a better one.

            //
            // Check if we found any white spaces.
            //
            if (!str.SkipWhiteSpaceComma()) {
                //
                // SkipWhiteSpaceComma() will return true when end of string is reached.
                //

                //
                // Return the separator as SEP_End.
                //
                return (SEP_End);
            }

            if (Char.IsLetter(str.GetChar())) {
                //
                // This is a beginning of a word.
                //
                if (raw.timeMark == -1)
                {
                    //
                    // Check if this is an AM time mark.
                    //
                    int timeMark;
                    if ((timeMark = GetTimeMark(str, dtfi)) != -1)
                    {
                        raw.timeMark = timeMark;;
                        return (timeMark == TM_AM ? SEP_Am: SEP_Pm);
                    }
                }
                if (MatchWord(str, LocalTimeMark, false)) {
                    separator = SEP_LocalTimeMark;
                } else if (MatchWord(str, CJKYearSuff, false) || MatchWord(str, KoreanYearSuff, false)) {
                    // TODO[YSLin]: Only check suffix when culture is CJK.
                    separator = SEP_YearSuff;
                }
                else if (MatchWord(str, CJKMonthSuff, false) || MatchWord(str, KoreanMonthSuff, false)) 
                {
                    separator = SEP_MonthSuff;
                }
                else if (MatchWord(str, CJKDaySuff, false) || MatchWord(str, KoreanDaySuff, false)) 
                {
                    separator = SEP_DaySuff;
                }
                else if (MatchWord(str, CJKHourSuff, false) || MatchWord(str, ChineseHourSuff, false)) 
                {
                    separator = SEP_HourSuff;
                }
                else if (MatchWord(str, CJKMinuteSuff, false)) 
                {
                    separator = SEP_MinuteSuff;
                }
                else if (MatchWord(str, CJKSecondSuff, false)) 
                {
                    separator = SEP_SecondSuff;
                }
                else if (dtfi.CultureID == 0x0412) {
                    // Specific check for Korean time suffices
                    if (MatchWord(str, KoreanHourSuff, false)) {
                        separator = SEP_HourSuff;
                    }
                    else if (MatchWord(str, KoreanMinuteSuff, false)) {
                        separator = SEP_MinuteSuff;
                    }
                    else if (MatchWord(str, KoreanSecondSuff, false)) {
                        separator = SEP_SecondSuff;
                    }                
                }
            } else {
                //
                // Not a letter. Check if this is a date separator.
                //
                if ((MatchWord(str, dtfi.DateSeparator, false)) ||
                    (MatchWord(str, invariantInfo.DateSeparator, false)) ||
                    (MatchWord(str, alternativeDateSeparator, false)))
                {
                    //
                    // NOTENOTE yslin: alternativeDateSeparator is a special case because some cultures
                    //  (e.g. the invariant culture) use "/". However, in RFC format, we use "-" as the
                    // date separator.  Therefore, we should check for it.
                    //
                    separator = SEP_Date;
                }
                //
                // Check if this is a time separator.
                //
                else if ((MatchWord(str, dtfi.TimeSeparator, false)) ||
                         (MatchWord(str, invariantInfo.TimeSeparator, false)))
                {
                    separator = SEP_Time;
                } else if (dtfi.CultureID == 0x041c) {
                    // Special case for sq-AL (0x041c)
                    // Its time pattern is "h:mm:ss.tt"
                    if (str.GetChar() == '.') {
                        if (raw.timeMark == -1)
                        {
                            //
                            // Check if this is an AM time mark.
                            //
                            int timeMark;
                            str.Index++;
                            if ((timeMark = GetTimeMark(str, dtfi)) != -1)
                            {
                                raw.timeMark = timeMark;;
                                return (timeMark == TM_AM ? SEP_Am: SEP_Pm);
                            }
                            str.Index--;
                        }                        
                    }
                }
            }
                            
#if YSLIN_DEBUG
            Console.WriteLine("    Separator = " + separatorNames[separator]);
#endif
            return (separator);
        }

#if YSLIN_DEBUG
    static String  GetUnicodeString(String str) {
        StringBuilder buffer = new StringBuilder();
        for (int i = 0; i < str.Length; i++) {
            if (str[i] < 0x20) {
                buffer.Append("\\x" + ((int)str[i]).ToString("x4"));
            } else if (str[i] < 0x7f) {
                buffer.Append(str[i]);
            } else {
                buffer.Append("\\x" + ((int)str[i]).ToString("x4"));
            }
        }
        return (buffer.ToString());
    }
#endif
        //
        //  Actions: Check the word at the current index to see if it matches a month name.
        //      This is used by DateTime.Parse() to try to match a month name.
        //  Returns: -1 if a match is not found. Otherwise, a value from 1 to 12 is returned.
        //
        private static int GetMonthNumber(__DTString str, DateTimeFormatInfo dtfi)
        {
         
            //
            // Check the month name specified in dtfi.
            //
            int i;

            int monthInYear = (dtfi.GetMonthName(13).Length == 0 ? 12 : 13);
            int maxLen = 0;
            int result = -1;
            int index;
            String word = str.PeekCurrentWord();
            // Postfixes are allowed for Finnish, Basque and Galecian
            bool allowPostfix = (dtfi.CultureID == 0x40b || dtfi.CultureID == 0x42d || dtfi.CultureID == 0x456);

            //
            // We have to match the month name with the longest length, 
            // since there are cultures which have more than one month names
            // with the same prefix.
            //
            for (i = 1; i <= monthInYear; i++) {
                String monthName = dtfi.GetMonthName(i);

                //@ToDo[YSLin]: Fix this to not allocate as much garbage.
                if ((index = str.CompareInfo.IndexOf(
                    word, monthName, CompareOptions.IgnoreCase)) >= 0) {
                    // Many culture have prefixes before month names. Only a couple have postfixes
                    // REVIEW: This should be formalized into DateTimeFormat info so that only 
                    // exact matches are allowed.
                    bool match = ((index + monthName.Length) == word.Length);
                    if (!match) {
                        if (index == 0 && allowPostfix) {
                            match = true;
                        }
                    }
                    if (match) {
                        result = i;
                        maxLen = index + monthName.Length;
                        continue;
                    }
                } 
                if ( dtfi.HasSpacesInMonthNames
                        ? str.MatchSpecifiedWords(monthName, true)
                        : str.StartsWith(monthName, true)) {
                    // The condition allows us to get the month name for cultures
                    // which has spaces in their month names.
                    // E.g. 
                    if (monthName.Length > maxLen) {
                        result = i;
                        maxLen = monthName.Length;
                    }
                }
            }

            if ((dtfi.FormatFlags & DateTimeFormatFlags.UseGenitiveMonth) != 0) {
                // If this DTFI uses genitive form, search it to see if we can find a longer match.
                int tempResult = str.MatchLongestWords(dtfi.internalGetGenitiveMonthNames(false), ref maxLen);
                if (tempResult >= 0) {                    
                    // The result from MatchLongestWords is 0 ~ length of word array - 1.
                    // So we increment the result by one to become the month value.                
                    str.Index += maxLen;
                    return (tempResult+1);
                }
            }
            
            if (result > -1) {
                #if YSLIN_DEBUG
                Console.WriteLine("    Month = [" + str.Value.Substring(str.Index, maxLen) + "] = " + result);                    
                #endif
                str.Index += maxLen;
                return (result);
            }
            
            for (i = 1; i <= monthInYear; i++)
            {
                if (MatchWord(str, dtfi.GetAbbreviatedMonthName(i), false))
                {
                    return (i);
                }
            }

            //
            // Check the month name in the invariant culture.
            //
            for (i = 1; i <= 12; i++)
            {
                if (MatchWord(str, invariantInfo.GetMonthName(i), false))
                {
                    return (i);
                }
            }

            for (i = 1; i <= 12; i++)
            {
                if (MatchWord(str, invariantInfo.GetAbbreviatedMonthName(i), false))
                {
                    return (i);
                }
            }

            return (-1);
        }

        //
        // Check the word at the current index to see if it matches a day of week name.
        // @return -1 if a match is not found.  Otherwise, a value from 0 to 6 is returned.
        //
        private static int GetDayOfWeekNumber(__DTString str, DateTimeFormatInfo dtfi) {
            //
            // Check the month name specified in dtfi.
            //

            DayOfWeek i;
            
            int maxLen = 0;
            int result = -1;
            //
            // We have to match the day name with the longest length, 
            // since there are cultures which have more than one day of week names
            // with the same prefix.
            //
            int endIndex = str.FindEndOfCurrentWord();
            String dayName=null;
            for (i = DayOfWeek.Sunday; i <= DayOfWeek.Saturday; i++) {
                dayName = dtfi.GetDayName(i);
                if (str.MatchSpecifiedWord(dayName, endIndex)) {
                    if (dayName.Length > maxLen) {
                        result = (int)i;
                        maxLen = dayName.Length;
                    }
                }
                }

            if (result > -1) {
                #if YSLIN_DEBUG
                Console.WriteLine("    Month = [" + GetUnicodeString(str.Value.Substring(str.Index, maxLen)) + "] = " + result);                    
                #endif
                str.Index = endIndex;
                return (result);
            }

            for (i = DayOfWeek.Sunday; i <= DayOfWeek.Saturday; i++)
            {
                if (MatchWord(str, dtfi.GetAbbreviatedDayName(i), false))
                {
                    return ((int)i);
                }
            }

            //
            // Check the month name in the invariant culture.
            //
            for (i = DayOfWeek.Sunday; i <= DayOfWeek.Saturday; i++)
            {
                if (MatchWord(str, invariantInfo.GetDayName(i), false))
                {
                    return ((int)i);
                }
            }

            for (i = DayOfWeek.Sunday; i <= DayOfWeek.Saturday; i++)
            {
                if (MatchWord(str, invariantInfo.GetAbbreviatedDayName(i), false))
                {
                    return ((int)i);
                }
            }

            return (-1);
        }

        //
        // Check the word at the current index to see if it matches GMT name or Zulu name.
        //
        private static bool GetTimeZoneName(__DTString str)
        {
            //
            // TODO yslin: When we support more timezone, change this to return an instance of TimeZone.
            //
            if (MatchWord(str, GMTName, false)) {
                return (true);
            }
            
            if (MatchWord(str, ZuluName, false)) {
                return (true);
            }

            return (false);
        }

        //
        // Create a Japanese DTFI which uses JapaneseCalendar.  This is used to parse
        // date string with Japanese era name correctly even when the supplied DTFI
        // does not use Japanese calendar.
        // The created instance is stored in global m_jajpDTFI.
        //
        private static void GetJapaneseCalendarDTFI() {
            // Check Calendar.ID specifically to avoid a lock here.
            if (m_jajpDTFI == null || m_jajpDTFI.Calendar.ID != Calendar.CAL_JAPAN) {
                m_jajpDTFI = new CultureInfo("ja-JP", false).DateTimeFormat;
                m_jajpDTFI.Calendar = JapaneseCalendar.GetDefaultInstance();
            }
        }

        //
        // Create a Taiwan DTFI which uses TaiwanCalendar.  This is used to parse
        // date string with era name correctly even when the supplied DTFI
        // does not use Taiwan calendar.
        // The created instance is stored in global m_zhtwDTFI.
        //
        private static void GetTaiwanCalendarDTFI() {
            // Check Calendar.ID specifically to avoid a lock here.
            if (m_zhtwDTFI == null || m_zhtwDTFI.Calendar.ID != Calendar.CAL_TAIWAN) {
                m_zhtwDTFI = new CultureInfo("zh-TW", false).DateTimeFormat;
                m_zhtwDTFI.Calendar = TaiwanCalendar.GetDefaultInstance();
            }
        }
        
        private static int GetEra(__DTString str, DateTimeResult result, ref DateTimeFormatInfo dtfi) {
            int[] eras = dtfi.Calendar.Eras;

            if (eras != null) {
                String word = str.PeekCurrentWord();
                int era;
                if ((era = dtfi.GetEra(word)) > 0) {
                    str.Index += word.Length;
                    return (era);
                }
                
                switch (dtfi.CultureID) {
                    case 0x0411:                    
                        // 0x0411 is the culture ID for Japanese.
                        if (dtfi.Calendar.ID != Calendar.CAL_JAPAN) {
                            // If the calendar for dtfi is Japanese, we have already
                            // done the check above. No need to re-check again.
                            GetJapaneseCalendarDTFI();                            
                            if ((era = m_jajpDTFI.GetEra(word)) > 0) {
                                str.Index += word.Length;
                                result.calendar = JapaneseCalendar.GetDefaultInstance();
                                dtfi = m_jajpDTFI;
                                return (era);
                            }
                        } 
                        break;
                   case 0x0404:
                        // 0x0404 is the culture ID for Taiwan.
                        if (dtfi.Calendar.ID != Calendar.CAL_TAIWAN) {
                            GetTaiwanCalendarDTFI();                            
                            if ((era = m_zhtwDTFI.GetEra(word)) > 0) {
                                str.Index += word.Length;
                                result.calendar = TaiwanCalendar.GetDefaultInstance();
                                dtfi = m_zhtwDTFI;
                                return (era);
                            }
                        } 
                        break;
                        
                }
            }
            return (-1);
        }

        private static int GetTimeMark(__DTString str, DateTimeFormatInfo dtfi) {
            if (((dtfi.AMDesignator.Length > 0) && MatchWord(str, dtfi.AMDesignator, false)) || MatchWord(str, invariantAMDesignator, false))
            {
                return (TM_AM);
            }
            else if (((dtfi.PMDesignator.Length > 0) && MatchWord(str, dtfi.PMDesignator, false)) || MatchWord(str, invariantPMDesignator, false))
            {
                //
                // Check if this is an PM time mark.
                //
                return (TM_PM);
            }
            return (-1);
        }
        
        internal static bool IsDigit(char ch) {
            //
            // BUGBUG [YSLIN]: Should we use CharacterInfo.IsDecimalDigit() here so that
            // our code work for full-width chars as well?
            // How do we map full-width char        
            return (ch >= '0' && ch <= '9');
        }
        

        /*=================================ParseFraction==========================
        **Action: Starting at the str.Index, if the current character is a digit, parse the remaining
        **      numbers as fraction.  For example, if the sub-string starting at str.Index is "123", then
        **      the method will return 0.123
        **Returns:      The fraction number.
        **Arguments:
        **      str the parsing string
        **Exceptions:
        ============================================================================*/
        
        private static double ParseFraction(__DTString str) {
            double result = 0;
            double decimalBase = 0.1;
            char ch;
            while (str.Index <= str.len-1 && IsDigit(ch = str.Value[str.Index])) {
                result += (ch - '0') * decimalBase;
                decimalBase *= 0.1;
                str.Index++;
            }
            return (result);
        }

        /*=================================ParseTimeZone==========================
        **Action: Parse the timezone offset in the following format:
        **          "+8", "+08", "+0800", "+0800"
        **        This method is used by DateTime.Parse().
        **Returns:      The TimeZone offset.
        **Arguments:
        **      str the parsing string
        **Exceptions:
        **      FormatException if invalid timezone format is found.
        ============================================================================*/

        private static TimeSpan ParseTimeZone(__DTString str, char offsetChar) {
            // The hour/minute offset for timezone.
            int hourOffset = 0;
            int minuteOffset = 0;
            
            if (str.GetNextDigit()) {
                // Get the first digit, Try if we can parse timezone in the form of "+8".
                hourOffset = str.GetDigit();
                if (str.GetNextDigit()) {
                    // Parsing "+18"
                    hourOffset *= 10;
                    hourOffset += str.GetDigit();
                    if (str.GetNext()) {
                        char ch;
                        if (Char.IsDigit(ch = str.GetChar())) {
                            // Parsing "+1800"

                            // Put the char back, since we already get the char in the previous GetNext() call.
                            str.Index--;
                            if (ParseDigits(str, 2, true, out minuteOffset)) {
                                // ParseDigits() does not advance the char for us, so do it here.
                                str.Index++;
                            } else {
                                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
                            }
                        } else if (ch == ':') {   
                            // Parsing "+18:00"
                            if (ParseDigits(str, 2, true, out minuteOffset)) {
                                str.Index++;
                            } else {
                                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
                            }
                        } else {
                            // Not a digit, not a colon, put this char back.
                            str.Index--;
                        }
                    }
                }
                // The next char is not a digit, so we get the timezone in the form of "+8".
            } else {
                // Invalid timezone: No numbers after +/-.
                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
            }
            TimeSpan timezoneOffset = new TimeSpan(hourOffset, minuteOffset, 0);
            if (offsetChar == '-') {
                timezoneOffset = timezoneOffset.Negate();
            }
            return (timezoneOffset);
        }
        
        //
        // This is the lexer. Check the character at the current index, and put the found token in dtok and
        // some raw date/time information in raw.
        // @param str the string to be lex'ed.
        //
        private static void Lex(
            int dps, __DTString str, DateTimeToken dtok, DateTimeRawInfo raw, DateTimeResult result, ref DateTimeFormatInfo dtfi) {
            
            int sep;
            dtok.dtt = DTT_Unk;     // Assume the token is unkown.

            //
            // Skip any white spaces.
            //
            if (!str.SkipWhiteSpaceComma()) {
                //
                // SkipWhiteSpaceComma() will return true when end of string is reached.
                //
                dtok.dtt = DTT_End;
                return;
            }

            char ch = str.GetChar();
            if (Char.IsLetter(ch))
            {
                //
                // This is a letter.
                //

                int month, dayOfWeek, era, timeMark;

                //
                // Check if this is a beginning of a month name.
                // And check if this is a day of week name.
                //
                if (raw.month == -1 && (month = GetMonthNumber(str, dtfi)) >= 1)
                {
                    //
                    // This is a month name
                    //
                    switch(sep=GetSeparator(str, raw, dtfi))
                    {
                        case SEP_End:
                            dtok.dtt = DTT_MonthEnd;
                            break;
                        case SEP_Space:
                            dtok.dtt = DTT_MonthSpace;
                            break;
                        case SEP_Date:
                            dtok.dtt = DTT_MonthDatesep;
                            break;
                        default:
                            //Invalid separator after month name
                            throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
                    }
                    raw.month = month;
                }
                else if (raw.dayOfWeek == -1 && (dayOfWeek = GetDayOfWeekNumber(str, dtfi)) >= 0)
                {
                    //
                    // This is a day of week name.
                    //
                    raw.dayOfWeek = dayOfWeek;
                    dtok.dtt = DTT_DayOfWeek;
                    //
                    // Discard the separator.
                    //
                    GetSeparator(str, raw, dtfi);
                }
                else if (GetTimeZoneName(str))
                {
                    //
                    // This is a timezone designator
                    //
                    // NOTENOTE yslin: for now, we only support "GMT" and "Z" (for Zulu time).
                    //
                    dtok.dtt = DTT_TimeZone;
                    result.timeZoneUsed = true;
                    result.timeZoneOffset = new TimeSpan(0);
                } else if ((raw.era == -1) && ((era = GetEra(str, result, ref dtfi)) != -1)) {
                    raw.era = era;
                    result.era = era;
                    dtok.dtt = DTT_Era;
                } else if (raw.timeMark == -1 && (timeMark = GetTimeMark(str, dtfi)) != -1) {
                    raw.timeMark = timeMark;
                    GetSeparator(str, raw, dtfi);
                } else {
                    //
                    // Not a month name, not a day of week name. Check if this is one of the
                    // known date words. This is used to deal case like Spanish cultures, which
                    // uses 'de' in their Date string.
                    // 
                    //                    
                    if (!str.MatchWords(dtfi.DateWords)) {
                        throw new FormatException(
                            String.Format(Environment.GetResourceString("Format_UnknowDateTimeWord"), str.Index));
                    }                    
                    GetSeparator(str, raw, dtfi);                    
                }
            } else if (Char.IsDigit(ch)) {
                if (raw.numCount == 3) {
                    throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
                }
                #if YSLIN_DEBUG
                    Console.WriteLine("[" + ch + "]");
                #endif
                //
                // This is a digit.
                //
                int number = ch - '0';

                int digitCount = 1;

                //
                // Collect other digits.
                //
                while (str.GetNextDigit())
                {
                    #if YSLIN_DEBUG
                        Console.WriteLine("[" + str.GetDigit() + "]");
                    #endif
                    number = number * 10 + str.GetDigit();
                    digitCount++;
                }

                // If the previous parsing state is DS_T_NNt (like 12:01), and we got another number,
                // so we will have a terminal state DS_TX_NNN (like 12:01:02).
                // If the previous parsing state is DS_T_Nt (like 12:), and we got another number,
                // so we will have a terminal state DS_TX_NN (like 12:01:02).
                //
                // Look ahead to see if the following character is a decimal point or timezone offset.
                // This enables us to parse time in the forms of:
                //  "11:22:33.1234" or "11:22:33-08".
                if (dps == DS_T_NNt || dps == DS_T_Nt) {
                    char nextCh;
                    if ((str.Index < str.len - 1)) {
                        nextCh = str.Value[str.Index];
                        switch (nextCh) {                        
                            case '.':
                                if (dps == DS_T_NNt) {
                                    // Yes, advance to the next character.
                                    str.Index++;
                                    // Collect the second fraction.
                                    raw.fraction = ParseFraction(str);
                                }
                                break;
                            case '+':
                            case '-':
                                if (result.timeZoneUsed) {
                                    // Should not have two timezone offsets.
                                    throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
                                }
                                result.timeZoneUsed = true;
                                result.timeZoneOffset = ParseTimeZone(str, nextCh);
                                break;
                        }
                    }
                }
                
                if (number >= 0)
                {
                    dtok.num = number;
#if YSLIN_DEBUG
                    Console.WriteLine("  number = [" + number + "]");
#endif
                    if (digitCount >= 3)
                    {
                        if (raw.year == -1)
                        {
                            raw.year = number;
                            //
                            // If we have number which has 3 or more digits (like "001" or "0001"),
                            // we assume this number is a year. Save the currnet raw.numCount in
                            // raw.year.
                            //
                            switch (sep = GetSeparator(str, raw, dtfi))
                            {
                                case SEP_End:
                                    dtok.dtt     = DTT_YearEnd;
                                    break;
                                case SEP_Am:
                                case SEP_Pm:
                                case SEP_Space:
                                    dtok.dtt    = DTT_YearSpace;
                                    break;
                                case SEP_Date:
                                    dtok.dtt     = DTT_YearDateSep;
                                    break;
                                case SEP_YearSuff:
                                case SEP_MonthSuff:
                                case SEP_DaySuff:
                                    dtok.dtt    = DTT_NumDatesuff;
                                    dtok.suffix = sep;
                                    break;
                                case SEP_HourSuff:
                                case SEP_MinuteSuff:
                                case SEP_SecondSuff:
                                    dtok.dtt    = DTT_NumTimesuff;
                                    dtok.suffix = sep;
                                    break;
                                default:
                                    // Invalid separator after number number.
                                    throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
                            }
                            //
                            // Found the token already. Let's bail.
                            //
                            return;
                        }
                        throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
                    }
                } else
                {
                    //
                    // number is overflowed.
                    //
                    throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
                }

                switch (sep = GetSeparator(str, raw, dtfi))
                {
                    //
                    // Note here we check if the numCount is less than three.
                    // When we have more than three numbers, it will be caught as error in the state machine.
                    //
                    case SEP_End:
                        dtok.dtt = DTT_NumEnd;
                        raw.num[raw.numCount++] = dtok.num;
                        break;
                    case SEP_Am:
                    case SEP_Pm:
                        dtok.dtt = DTT_NumAmpm;
                        raw.num[raw.numCount++] = dtok.num;
                        break;
                    case SEP_Space:
                        dtok.dtt = DTT_NumSpace;
                        raw.num[raw.numCount++] = dtok.num;
                        break;
                    case SEP_Date:
                        dtok.dtt = DTT_NumDatesep;
                        raw.num[raw.numCount++] = dtok.num;
                        break;
                    case SEP_Time:
                        if (!result.timeZoneUsed) {
                            dtok.dtt = DTT_NumTimesep;
                            raw.num[raw.numCount++] = dtok.num;
                        } else {
                            // If we already got timezone, there should be no
                            // time separator again.
                            throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
                        }
                        break;
                    case SEP_YearSuff:
                        dtok.num = dtfi.Calendar.ToFourDigitYear(number);
                        dtok.dtt    = DTT_NumDatesuff;
                        dtok.suffix = sep;
                        break;
                    case SEP_MonthSuff:
                    case SEP_DaySuff:
                        dtok.dtt    = DTT_NumDatesuff;
                        dtok.suffix = sep;
                        break;
                    case SEP_HourSuff:
                    case SEP_MinuteSuff:
                    case SEP_SecondSuff:
                        dtok.dtt    = DTT_NumTimesuff;
                        dtok.suffix = sep;
                        break;
                    case SEP_LocalTimeMark:
                        dtok.dtt = DTT_NumLocalTimeMark;
                        raw.num[raw.numCount++] = dtok.num;
                        break;
                    default:
                        // Invalid separator after number number.
                        throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
                }
            }
            else
            {
                //
                // Not a letter, not a digit. Just ignore it.
                //
                str.Index++;
            }
            return;
        }

        private const int ORDER_YMD = 0;     // The order of date is Year/Month/Day.
        private const int ORDER_MDY = 1;     // The order of date is Month/Day/Year.
        private const int ORDER_DMY = 2;     // The order of date is Day/Month/Year.
        private const int ORDER_YDM = 3;     // The order of date is Year/Day/Month
        private const int ORDER_YM  = 4;     // Year/Month order.
        private const int ORDER_MY  = 5;     // Month/Year order.
        private const int ORDER_MD  = 6;     // Month/Day order.
        private const int ORDER_DM  = 7;     // Day/Month order.

        //
        // Decide the year/month/day order from the datePattern.
        //
        // @return 0: YMD, 1: MDY, 2:DMY, otherwise -1.
        //
        private static int GetYearMonthDayOrder(String datePattern, DateTimeFormatInfo dtfi)
        {
            int yearOrder   = -1;
            int monthOrder  = -1;
            int dayOrder    = -1;
            int orderCount  =  0;

            bool inQuote = false;

            for (int i = 0; i < datePattern.Length && orderCount < 3; i++)
            {
                char ch = datePattern[i];
                if (ch == '\'' || ch == '"')
                {
                    inQuote = !inQuote;
                }

                if (!inQuote)
                {
                    if (ch == 'y')
                    {
                        yearOrder = orderCount++;

                        //
                        // Skip all year pattern charaters.
                        //
                        for(; i+1 < datePattern.Length && datePattern[i+1] == 'y'; i++)
                        {
                            // Do nothing here.
                        }
                    }
                    else if (ch == 'M')
                    {
                        monthOrder = orderCount++;
                        //
                        // Skip all month pattern characters.
                        //
                        for(; i+1 < datePattern.Length && datePattern[i+1] == 'M'; i++)
                        {
                            // Do nothing here.
                        }
                    }
                    else if (ch == 'd')
                    {

                        int patternCount = 1;
                        //
                        // Skip all day pattern characters.
                        //
                        for(; i+1 < datePattern.Length && datePattern[i+1] == 'd'; i++)
                        {
                            patternCount++;
                        }
                        //
                        // Make sure this is not "ddd" or "dddd", which means day of week.
                        //
                        if (patternCount <= 2)
                        {
                            dayOrder = orderCount++;
                        }
                    }
                }
            }

            if (yearOrder == 0 && monthOrder == 1 && dayOrder == 2)
            {
                return (ORDER_YMD);
            }
            if (monthOrder == 0 && dayOrder == 1 && yearOrder == 2)
            {
                return (ORDER_MDY);
            }
            if (dayOrder == 0 && monthOrder == 1 && yearOrder == 2)
            {
                return (ORDER_DMY);
            }
            if (yearOrder == 0 && dayOrder == 1 && monthOrder == 2)
            {
                return (ORDER_YDM);
            }
            throw new FormatException(String.Format(Environment.GetResourceString("Format_BadDatePattern"), datePattern));
        }

        //
        // Decide the year/month order from the pattern.
        //
        // @return 0: YM, 1: MY, otherwise -1.
        //
        private static int GetYearMonthOrder(String pattern, DateTimeFormatInfo dtfi)
        {
            int yearOrder   = -1;
            int monthOrder  = -1;
            int orderCount  =  0;

            bool inQuote = false;
            for (int i = 0; i < pattern.Length && orderCount < 2; i++)
            {
                char ch = pattern[i];
                if (ch == '\'' || ch == '"')
                {
                    inQuote = !inQuote;
                }

                if (!inQuote)
                {
                    if (ch == 'y')
                    {
                        yearOrder = orderCount++;

                        //
                        // Skip all year pattern charaters.
                        //
                        for(; i+1 < pattern.Length && pattern[i+1] == 'y'; i++)
                        {
                        }
                    }
                    else if (ch == 'M')
                    {
                        monthOrder = orderCount++;
                        //
                        // Skip all month pattern characters.
                        //
                        for(; i+1 < pattern.Length && pattern[i+1] == 'M'; i++)
                        {
                        }
                    }
                }
            }

            if (yearOrder == 0 && monthOrder == 1)
            {
                return (ORDER_YM);
            }
            if (monthOrder == 0 && yearOrder == 1)
            {
                return (ORDER_MY);
            }
            throw new FormatException(String.Format(Environment.GetResourceString("Format_BadDatePattern"), pattern));
        }

        //
        // Decide the month/day order from the pattern.
        //
        // @return 0: MD, 1: DM, otherwise -1.
        //
        private static int GetMonthDayOrder(String pattern, DateTimeFormatInfo dtfi)
        {
            int monthOrder  = -1;
            int dayOrder    = -1;
            int orderCount  =  0;

            bool inQuote = false;
            for (int i = 0; i < pattern.Length && orderCount < 2; i++)
            {
                char ch = pattern[i];
                if (ch == '\'' || ch == '"')
                {
                    inQuote = !inQuote;
                }

                if (!inQuote)
                {
                    if (ch == 'd')
                    {
                        int patternCount = 1;
                        //
                        // Skip all day pattern charaters.
                        //
                        for(; i+1 < pattern.Length && pattern[i+1] == 'd'; i++)
                        {
                            patternCount++;
                        }

                        //
                        // Make sure this is not "ddd" or "dddd", which means day of week.
                        //
                        if (patternCount <= 2)
                        {
                            dayOrder = orderCount++;
                        }

                    }
                    else if (ch == 'M')
                    {
                        monthOrder = orderCount++;
                        //
                        // Skip all month pattern characters.
                        //
                        for(; i+1 < pattern.Length && pattern[i+1] == 'M'; i++)
                        {
                        }
                    }
                }
            }

            if (monthOrder == 0 && dayOrder == 1)
            {
                return (ORDER_MD);
            }
            if (dayOrder == 0 && monthOrder == 1)
            {
                return (ORDER_DM);
            }
            throw new FormatException(String.Format(Environment.GetResourceString("Format_BadDatePattern"), pattern));
        }


        private static bool IsValidMonth(DateTimeResult result, int year, int month)
        {
            return (month >= 1 && month <= result.calendar.GetMonthsInYear(year));
        }

        //
        // NOTENOTE: This funciton assumes that year/month is correct. So call IsValidMonth before calling this.
        //
        private static bool IsValidDay(DateTimeResult result, int year, int month, int day)
        {
            return (day >= 1 && day <= result.calendar.GetDaysInMonth(year, month));
        }

        //
        // Adjust the two-digit year if necessary.
        //
        private static int AdjustYear(DateTimeResult result, int year)
        {
            if (year < 100)
            {
                year = result.calendar.ToFourDigitYear(year);
            }
            return (year);
        }

        private static bool SetDateYMD(DateTimeResult result, int year, int month, int day)
        {
            // Note, longer term these checks should be done at the end of the parse. This current
            // way of checking creates order dependence with parsing the era name.
            if (IsValidMonth(result, year, month) && 
                            (day >= 1 && day <= result.calendar.GetDaysInMonth(year, month, result.era)))
            {
                result.SetDate(year, month, day);                           // YMD
                return (true);
            }
            return (false);
        }

        private static bool SetDateMDY(DateTimeResult result, int month, int day, int year)
        {
            return (SetDateYMD(result, year, month, day));
        }

        private static bool SetDateDMY(DateTimeResult result, int day, int month, int year)
        {
            return (SetDateYMD(result, year, month, day));
        }

        private static bool SetDateYDM(DateTimeResult result, int year, int day, int month)
        {
            return (SetDateYMD(result, year, month, day));
        }

        // Processing teriminal case: DS_DX_NN
        private static void GetDayOfNN(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi) {
            int n1 = raw.num[0];
            int n2 = raw.num[1];

            int year = result.calendar.GetYear(DateTime.Now);

            int order = GetMonthDayOrder(dtfi.MonthDayPattern, dtfi);

            if (order == ORDER_MD)
            {
                if (SetDateYMD(result, year, n1, n2))                           // MD
                {
                    return;
                }
            } else {
                // ORDER_DM
                if (SetDateYMD(result, year, n2, n1))                           // DM
                {
                    return;
                }
            }
            throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
        }

        // Processing teriminal case: DS_DX_NNN
        private static void GetDayOfNNN(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi)
        {
            int n1 = raw.num[0];
            int n2 = raw.num[1];;
            int n3 = raw.num[2];

            int order = GetYearMonthDayOrder(dtfi.ShortDatePattern, dtfi);

            if (order == ORDER_YMD) {
                if (SetDateYMD(result, AdjustYear(result, n1), n2, n3))         // YMD
                {
                    return;
                }
            } else if (order == ORDER_MDY) {
                if (SetDateMDY(result, n1, n2, AdjustYear(result, n3)))         // MDY
                {
                    return;
                }
            } else if (order == ORDER_DMY) {
                if (SetDateDMY(result, n1, n2, AdjustYear(result, n3)))         // DMY
                {
                    return;
                }
            } else if (order == ORDER_YDM) {
                if (SetDateYDM(result, AdjustYear(result, n1), n2, n3))         // YDM
                {
                    return;
                }
            }
            throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
        }

        private static void GetDayOfMN(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi)
        {
            int currentYear = result.calendar.GetYear(DateTime.Now);
            result.Month = raw.month;

            //
            // NOTENOTE yslin: in the case of invariant culture,
            // we will have an ambiguous situation when we have a string "June 11".
            // It could be 11-06-01 or CurrentYear-06-11.
            // In here, we favor CurrentYear-06-11 by checking the month/day first.
            //
            int monthDayOrder = GetMonthDayOrder(dtfi.MonthDayPattern, dtfi);
            if (monthDayOrder == ORDER_MD)
            {
                if (SetDateYMD(result, currentYear, raw.month, raw.num[0]))
                {
                    return;
                }
            } else if (monthDayOrder == ORDER_DM) {
                if (SetDateYMD(result, currentYear, raw.month, raw.num[0]))
                {
                    return;
                }
            }

            int yearMonthOrder = GetYearMonthOrder(dtfi.YearMonthPattern, dtfi);
            if (yearMonthOrder == ORDER_MY)
            {
                if (IsValidMonth(result, raw.num[0], raw.month))
                {
                    result.Year = raw.num[0];
                    result.Day  = 1;
                    return;
                }
            }

            if (IsValidDay(result, currentYear, result.Month, raw.num[0]))
            {
                result.Year = currentYear;
                result.Day = raw.num[0];
                return;
            }

            if (IsValidDay(result, raw.num[0], result.Month, 1))
            {
                result.Year = raw.num[0];
                result.Day  = 1;
            }
            throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));

        }

        private static void GetDayOfNM(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi)
        {
            int currentYear = result.calendar.GetYear(DateTime.Now);

            result.Month = raw.month;

            // Check month/day first before checking year/month.
            // The logic here is that people often uses 4 digit for years, which will be captured by GetDayOfYM().
            // Therefore, we assume a number followed by a month is generally a month/day.
            int monthDayOrder = GetMonthDayOrder(dtfi.MonthDayPattern, dtfi);
            if (monthDayOrder == ORDER_DM)
            {
                result.Year = currentYear;
                if (IsValidDay(result, result.Year, raw.month, raw.num[0]))
                {
                    result.Day  = raw.num[0];
                    return;
                }
            }
            int yearMonthOrder = GetYearMonthOrder(dtfi.YearMonthPattern, dtfi);
            if (yearMonthOrder == ORDER_YM)
            {
                if (IsValidMonth(result, raw.num[0], raw.month))
                {
                    result.Year = raw.num[0];
                    result.Day  = 1;
                    return;
                }
            }

            //
            // NOTENOTE yslin: in the case of invariant culture,
            // we will have an ambiguous situation when we have a string "June 11".
            // It is ambiguous because the month day pattern is "MMMM dd",
            // and year month pattern is "MMMM, yyyy".
            // Therefore, It could be 11-06-01 or CurrentYear-06-11.
            // In here, we favor CurrentYear-06-11 by checking the month/day first.
            //
            if (IsValidDay(result, currentYear, result.Month, raw.num[0]))
            {
                result.Year = currentYear;
                result.Day = raw.num[0];
                return;
            }

            if (IsValidDay(result, raw.num[0], result.Month, 1))
            {
                result.Year = raw.num[0];
                result.Day  = 1;
            }
            throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
        }

        private static void GetDayOfMNN(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi)
        {
            int n1 = raw.num[0];
            int n2 = raw.num[1];

            int order = GetYearMonthDayOrder(dtfi.ShortDatePattern, dtfi);
            int year;

            if (order == ORDER_MDY)
            {
                if (IsValidDay(result, year = AdjustYear(result, n2), raw.month, n1))
                {
                    result.SetDate(year, raw.month, n1);      // MDY
                    return;
                }
                else if (IsValidDay(result, year = AdjustYear(result, n1), raw.month, n2))
                {
                    result.SetDate(year, raw.month, n2);      // YMD
                    return;
                }
            }
            else if (order == ORDER_YMD)
            {
                if (IsValidDay(result, year = AdjustYear(result, n1), raw.month, n2))
                {
                    result.SetDate(year, raw.month, n2);      // YMD
                    return;
                }
                else if (IsValidDay(result, year = AdjustYear(result, n2), raw.month, n1))
                {
                    result.SetDate(year, raw.month, n1);      // DMY
                    return;
                }
            }
            else if (order == ORDER_DMY)
            {
                if (IsValidDay(result, year = AdjustYear(result, n2), raw.month, n1))
                {
                    result.SetDate(year, raw.month, n1);      // DMY
                    return;
                }
                else if (IsValidDay(result, year = AdjustYear(result, n1), raw.month, n2))
                {
                    result.SetDate(year, raw.month, n2);      // YMD
                    return;
                }
            }

            throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
        }

        private static void GetDayOfYNN(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi) {
            int n1 = raw.num[0];
            int n2 = raw.num[1];

            if (dtfi.CultureID == 0x0437) {
                // 0x0437 = Georgian - Georgia (ka-GE)
                // Very special case for ka-GE: 
                //  Its short date patten is "dd.MM.yyyy" (ORDER_DMY).
                //  However, its long date pattern is "yyyy '\x10ec\x10da\x10d8\x10e1' dd MM, dddd" (ORDER_YDM)
                int order = GetYearMonthDayOrder(dtfi.LongDatePattern, dtfi);

                if (order == ORDER_YDM) {
                    if (SetDateYMD(result, raw.year, n2, n1)) {
                        return; // Year + DM
                    }                
                } else {
                    if (SetDateYMD(result, raw.year, n1, n2)) {
                        return; // Year + MD
                    }
                }
            } else {
                //  Otherwise, assume it is year/month/day.
                if (SetDateYMD(result, raw.year, n1, n2)) {
                    return; // Year + MD
                }
            }
            throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
        }

        private static void GetDayOfNNY(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi) {
            int n1 = raw.num[0];
            int n2 = raw.num[1];

            int order = GetYearMonthDayOrder(dtfi.ShortDatePattern, dtfi);

            if (order == ORDER_MDY || order == ORDER_YMD) {
                if (SetDateYMD(result, raw.year, n1, n2)) {
                    return; // MD + Year
                }
            } else {
                if (SetDateYMD(result, raw.year, n2, n1)) {
                    return; // DM + Year
                }
            }
            throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
        }
        

        private static void GetDayOfYMN(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi) {
            if (SetDateYMD(result, raw.year, raw.month, raw.num[0])) {
                return;
            }
            throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
        }

        private static void GetDayOfYN(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi)
        {
            if (SetDateYMD(result, raw.year, raw.num[0], 1))
            {
                return;
            }
            throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
        }

        private static void GetDayOfYM(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi)
        {
            if (SetDateYMD(result, raw.year, raw.month, 1))
            {
                return;
            }
            throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
        }

        private static void AdjustTimeMark(DateTimeFormatInfo dtfi, DateTimeRawInfo raw) {
            // Specail case for culture which uses AM as empty string.  
            // E.g. af-ZA (0x0436)
            //    S1159                  \x0000
            //    S2359                  nm
            // In this case, if we are parsing a string like "2005/09/14 12:23", we will assume this is in AM.

            if (raw.timeMark == -1) {
                if (dtfi.AMDesignator != null && dtfi.PMDesignator != null) {
                    if (dtfi.AMDesignator.Length == 0 && dtfi.PMDesignator.Length != 0) {
                        raw.timeMark = TM_AM;
                    }
                    if (dtfi.PMDesignator.Length == 0 && dtfi.AMDesignator.Length != 0) {
                        raw.timeMark = TM_PM;
                    }
                } 
            }
        }
        
        //
        // Adjust hour according to the time mark.
        //
        private static int AdjustHour(int hour, int timeMark)
        {
            if (hour < 0 || hour > 12)
            {
                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
            }

            if (timeMark == TM_AM)
            {
                hour = (hour == 12) ? 0 : hour;
            }
            else
            {
                hour = (hour == 12) ? 12 : hour + 12;
            }
            return (hour);
        }

        private static void GetTimeOfN(DateTimeFormatInfo dtfi, DateTimeResult result, DateTimeRawInfo raw)
        {
            //
            // In this case, we need a time mark. Check if so.
            //
            if (raw.timeMark == -1)
            {
                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
            }
            AdjustTimeMark(dtfi, raw);
            result.Hour = AdjustHour(raw.num[0], raw.timeMark);
        }

        private static void GetTimeOfNN(DateTimeFormatInfo dtfi, DateTimeResult result, DateTimeRawInfo raw)
        {
            if (raw.numCount < 2)
            {
                throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_InternalState));
            }
            AdjustTimeMark(dtfi, raw);
            result.Hour     = (raw.timeMark == - 1) ? raw.num[0] : AdjustHour(raw.num[0], raw.timeMark);
            result.Minute   = raw.num[1];
        }

        private static void GetTimeOfNNN(DateTimeFormatInfo dtfi, DateTimeResult result, DateTimeRawInfo raw)
        {
            if (raw.numCount < 3)
            {
                throw new InvalidOperationException(Environment.GetResourceString(ResId.InvalidOperation_InternalState));
            }
            AdjustTimeMark(dtfi, raw);
            result.Hour     =  (raw.timeMark == - 1) ? raw.num[0] : AdjustHour(raw.num[0], raw.timeMark);
            result.Minute   = raw.num[1];
            result.Second   = raw.num[2];
        }

        //
        // Processing terminal state: A Date suffix followed by one number.
        //
        private static void GetDateOfDSN(DateTimeResult result, DateTimeRawInfo raw)
        {
            if (raw.numCount != 1 || result.Day != -1)
            {
                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
            }
            result.Day = raw.num[0];
        }

        private static void GetDateOfNDS(DateTimeResult result, DateTimeRawInfo raw)
        {
            if (result.Month == -1)
            {
                //Should have a month suffix
                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
            }
            if (result.Year != -1)
            {
                // Aleady has a year suffix
                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
            }
            result.Year = raw.num[0];
            result.Day = 1;
        }

        private static void GetDateOfNNDS(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi)
        {
            int order = GetYearMonthDayOrder(dtfi.ShortDatePattern, dtfi);

            switch (order)
            {
                case ORDER_YMD:
                    break;
                case ORDER_MDY:
                    break;
                case ORDER_DMY:
                    if (result.Day == -1 && result.Year == -1)
                    {
                        if (IsValidDay(result, raw.num[1], result.Month, raw.num[0]))
                        {
                            result.Year = raw.num[1];
                            result.Day  = raw.num[0];
                        }
                    }
                    break;
            }
        }

        //
        // A date suffix is found, use this method to put the number into the result.
        //
        private static void ProcessDateTimeSuffix(DateTimeResult result, DateTimeRawInfo raw, DateTimeToken dtok)
        {
            switch (dtok.suffix)
            {
                case SEP_YearSuff:
                    result.Year = raw.year = dtok.num;
                    break;
                case SEP_MonthSuff:
                    result.Month= raw.month = dtok.num;
                    break;
                case SEP_DaySuff:
                    result.Day  = dtok.num;
                    break;
                case SEP_HourSuff:
                    result.Hour = dtok.num;
                    break;
                case SEP_MinuteSuff:
                    result.Minute = dtok.num;
                    break;
                case SEP_SecondSuff:
                    result.Second = dtok.num;
                    break;
            }
        }

        //
        // A terminal state has been reached, call the appropriate function to fill in the parsing result.
        // @return ture if the state is a terminal state.
        //
        private static void ProcessTerminaltState(int dps, DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi)
        {
#if YSLIN_DEBUG
            Console.WriteLine(">> Terminal state is reached.  The information that we have right now:");
            Console.WriteLine("   dps = " + dps);
            Console.WriteLine("   DateTimeRawInfo:");
            Console.WriteLine("      numCount = " + raw.numCount);
            for (int i = 0; i < raw.num.Length; i++) {
                Console.WriteLine("      num[" + i + "] = " + raw.num[i]);
            }
            Console.WriteLine("      month = " + raw.month);
            Console.WriteLine("      year = " + raw.year);
            Console.WriteLine("      dayOfWeek = " + raw.dayOfWeek);
            Console.WriteLine("      era = " + raw.era);
            Console.WriteLine("      timeMark = " + raw.timeMark);
            Console.WriteLine("      fraction = " + raw.fraction);
#endif
        
            switch (dps)
            {
                case DS_DX_NN:
                    GetDayOfNN(result, raw, dtfi);
                    break;
                case DS_DX_NNN:
                    GetDayOfNNN(result, raw, dtfi);
                    break;
                case DS_DX_MN:
                    GetDayOfMN(result, raw, dtfi);
                    break;
                case DS_DX_NM:
                    GetDayOfNM(result, raw, dtfi);
                    break;
                case DS_DX_MNN:
                    GetDayOfMNN(result, raw, dtfi);
                    break;
                case DS_DX_DS:
                    // The result has got the correct value. No need to process.
                    break;
                case DS_DX_YNN:
                    GetDayOfYNN(result, raw, dtfi);
                    break;
                case DS_DX_NNY:
                    GetDayOfNNY(result, raw, dtfi);
                    break;
                case DS_DX_YMN:
                    GetDayOfYMN(result, raw, dtfi);
                    break;
                case DS_DX_YN:
                    GetDayOfYN(result, raw, dtfi);
                    break;
                case DS_DX_YM:
                    GetDayOfYM(result, raw, dtfi);
                    break;
                case DS_TX_N:
                    GetTimeOfN(dtfi, result, raw);
                    break;
                case DS_TX_NN:
                    GetTimeOfNN(dtfi, result, raw);
                    break;
                case DS_TX_NNN:
                    GetTimeOfNNN(dtfi, result, raw);
                    break;
                case DS_TX_TS:
                    // The result has got the correct value. Only the time mark needs to be checked.
                    if (raw.timeMark != - 1) {
                        result.Hour = AdjustHour(result.Hour, raw.timeMark);
                    }
                    break;
                case DS_DX_DSN:
                    GetDateOfDSN(result, raw);
                    break;
                case DS_DX_NDS:
                    GetDateOfNDS(result, raw);
                    break;
                case DS_DX_NNDS:
                    GetDateOfNNDS(result, raw, dtfi);
                    break;
            }

            if (dps > DS_ERROR)
            {
                //
                // We have reached a terminal state. Reset the raw num count.
                //
                raw.numCount = 0;
            }
            return;
        }

        //
        // This is the real method to do the parsing work.
        //
        internal static DateTime Parse(String s, DateTimeFormatInfo dtfi, DateTimeStyles styles) {
            if (s == null) {
                throw new ArgumentNullException("s",
                    Environment.GetResourceString("ArgumentNull_String"));
            }
            if (s.Length == 0) {
                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
            }            
            if (dtfi == null) {
                dtfi = DateTimeFormatInfo.CurrentInfo;
            }
        
            DateTime time;
            //
            // First try the predefined format.
            //
            //@ToDo[YSlin]: We need a more efficient way of doing this.
//              if (ParseExactMultiple(
//                  s, predefinedFormats, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.AllowWhiteSpaces, out time)) {
//                  return (time);
//              } 
        
            int dps             = DS_BEGIN;     // Date Parsing State.
            bool reachTerminalState = false;

            DateTimeResult result = new DateTimeResult();       // The buffer to store the parsing result.
            DateTimeToken   dtok    = new DateTimeToken();      // The buffer to store the parsing token.
            DateTimeRawInfo raw     = new DateTimeRawInfo();    // The buffer to store temporary parsing information.
            result.calendar = dtfi.Calendar;
            result.era = Calendar.CurrentEra;

            //
            // The string to be parsed. Use a __DTString wrapper so that we can trace the index which
            // indicates the begining of next token.
            //
            __DTString str = new __DTString(s);

            str.GetNext();

            //
            // The following loop will break out when we reach the end of the str.
            //
            do {
                //
                // Call the lexer to get the next token.
                //
                // If we find a era in Lex(), the era value will be in raw.era.
                Lex(dps, str, dtok, raw, result, ref dtfi);

                //
                // If the token is not unknown, process it.
                // Otherwise, just discard it.
                //
                if (dtok.dtt != DTT_Unk)
                {
                    //
                    // Check if we got any CJK Date/Time suffix.
                    // Since the Date/Time suffix tells us the number belongs to year/month/day/hour/minute/second,
                    // store the number in the appropriate field in the result.
                    //
                    if (dtok.suffix != SEP_Unk)
                    {
                        ProcessDateTimeSuffix(result, raw, dtok);
                        dtok.suffix = SEP_Unk;  // Reset suffix to SEP_Unk;
                    }

                    #if YSLIN_DEBUG
                    Console.WriteLine("dtt = " + dtok.dtt);
                    Console.WriteLine("dtok.dtt = " + tokenNames[dtok.dtt]);
                    Console.WriteLine("dps = " + dateParsingStateNames[dps]);
                    #endif

                    if (dps == DS_D_YN && dtok.dtt == DTT_NumLocalTimeMark) {
                            // Consider this as ISO 8601 format:
                            // "yyyy-MM-dd'T'HH:mm:ss"                 1999-10-31T02:00:00
                            return (ParseISO8601(raw, str, styles));
                    }

                    //
                    // Advance to the next state, and continue
                    //
                    dps = dateParsingStates[dps][dtok.dtt];
                    #if YSLIN_DEBUG
                    Console.WriteLine("=> Next dps = " + dateParsingStateNames[dps]);
                    #endif

                    if (dps == DS_ERROR)
                    {
                        BCLDebug.Trace("NLS", "DateTimeParse.DoParse(): dps is DS_ERROR");
                        throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
                    }
                    else if (dps > DS_ERROR)
                    {
                        ProcessTerminaltState(dps, result, raw, dtfi);
                        reachTerminalState = true;

                        //
                        // If we have reached a terminal state, start over from DS_BEGIN again.
                        // For example, when we parsed "1999-12-23 13:30", we will reach a terminal state at "1999-12-23",
                        // and we start over so we can continue to parse "12:30".
                        //
                        dps = DS_BEGIN;
                    }
                }
            } while (dtok.dtt != DTT_End && dtok.dtt != DTT_NumEnd && dtok.dtt != DTT_MonthEnd);

            if (!reachTerminalState) {
                BCLDebug.Trace("NLS", "DateTimeParse.DoParse(): terminal state is not reached");
                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
            }

            // Check if the parased string only contains hour/minute/second values.
            bool bTimeOnly = (result.Year == -1 && result.Month == -1 && result.Day == -1);
            
            //
            // Check if any year/month/day is missing in the parsing string.
            // If yes, get the default value from today's date.
            //
            CheckDefaultDateTime(result, ref result.calendar, styles);

            try {
                time = result.calendar.ToDateTime(result.Year, result.Month, result.Day, 
                    result.Hour, result.Minute, result.Second, 0, result.era);
                if (raw.fraction > 0) {
                    time = time.AddTicks((long)Math.Round(raw.fraction * Calendar.TicksPerSecond));
                }
            } catch (Exception)
            {
                BCLDebug.Trace("NLS", "DateTimeParse.DoParse(): time is bad");
                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));
            } 

            //
            // NOTENOTE YSLin:
            // We have to check day of week before we adjust to the time zone.
            // Otherwise, the value of day of week may change after adjustting to the time zone.
            //
            if (raw.dayOfWeek != -1) {
                //
                // Check if day of week is correct.
                //
                if (raw.dayOfWeek != (int)result.calendar.GetDayOfWeek(time)) {
                    BCLDebug.Trace("NLS", "DateTimeParse.DoParse(): day of week is not correct");
                    throw new FormatException(Environment.GetResourceString("Format_BadDayOfWeek"));
                }
            }

            if (result.timeZoneUsed) {
                time = AdjustTimeZone(time, result.timeZoneOffset, styles, bTimeOnly);
            }
            
            return (time);
        }

        private static DateTime AdjustTimeZone(DateTime time, TimeSpan timeZoneOffset, DateTimeStyles sytles, bool bTimeOnly) {
            if ((sytles & DateTimeStyles.AdjustToUniversal) != 0) {
                return (AdjustTimeZoneToUniversal(time, timeZoneOffset));
            }

            return (AdjustTimeZoneToLocal(time, timeZoneOffset, bTimeOnly));
        }

        //
        // Adjust the specified time to universal time based on the supplied timezone.
        // E.g. when parsing "2001/06/08 14:00-07:00", 
        // the time is 2001/06/08 14:00, and timeZoneOffset = -07:00.
        // The result will be "2001/06/08 21:00"
        //
        private static DateTime AdjustTimeZoneToUniversal(DateTime time, TimeSpan timeZoneOffset) {
            long resultTicks = time.Ticks;
            resultTicks -= timeZoneOffset.Ticks;
            if (resultTicks < 0) {
                resultTicks += Calendar.TicksPerDay;
            }
            
            if (resultTicks < 0) {
                throw new FormatException(Environment.GetResourceString("Format_DateOutOfRange"));
            }
            return (new DateTime(resultTicks));
        }

        //
        // Adjust the specified time to universal time based on the supplied timezone,
        // and then convert to local time.
        // E.g. when parsing "2001/06/08 14:00-04:00", and local timezone is GMT-7.
        // the time is 2001/06/08 14:00, and timeZoneOffset = -05:00.
        // The result will be "2001/06/08 11:00"
        //
        private static DateTime AdjustTimeZoneToLocal(DateTime time, TimeSpan timeZoneOffset, bool bTimeOnly) { 
            long resultTicks = time.Ticks;
            // Convert to local ticks
            if (resultTicks < Calendar.TicksPerDay) {
                //
                // This is time of day.
                //
                
                // Adjust timezone.
                resultTicks -= timeZoneOffset.Ticks;
                // If the time is time of day, use the current timezone offset.
                resultTicks += TimeZone.CurrentTimeZone.GetUtcOffset(bTimeOnly ? DateTime.Now: time).Ticks;
                
                if (resultTicks < 0) {
                    resultTicks += Calendar.TicksPerDay;
                }
            } else {
                // Adjust timezone to GMT.
                resultTicks -= timeZoneOffset.Ticks;
                if (resultTicks > DateTime.MaxValue.Ticks) {
                    // If the result ticks is greater than DateTime.MaxValue, we can not create a DateTime from this ticks.
                    // In this case, keep using the old code.
                    // This code path is used to get around bug 78411.
                    resultTicks += TimeZone.CurrentTimeZone.GetUtcOffset(time).Ticks;                
                } else {
                    // Convert the GMT time to local time.
                    return (new DateTime(resultTicks).ToLocalTime());
                }                
            }
            if (resultTicks < 0) {
                throw new FormatException(Environment.GetResourceString("Format_DateOutOfRange"));
            }
            return (new DateTime(resultTicks));        
        }
        
        //
        // Parse the ISO8601 format string found during Parse();
        // 
        //
        private static DateTime ParseISO8601(DateTimeRawInfo raw, __DTString str, DateTimeStyles styles) {
            if (raw.year < 0 || raw.num[0] < 0 || raw.num[1] < 0) {
            }
            str.Index--;
            int hour, minute, second;
            bool timeZoneUsed = false;
            TimeSpan timeZoneOffset = new TimeSpan();
            DateTime time = new DateTime(0);
            double partSecond = 0;
            
            str.SkipWhiteSpaces();            
            ParseDigits(str, 2, true, out hour);
            str.SkipWhiteSpaces();
            if (str.Match(':')) {
                str.SkipWhiteSpaces();
                ParseDigits(str, 2, true, out minute);    
                str.SkipWhiteSpaces();
                if (str.Match(':')) {
                    str.SkipWhiteSpaces();
                    ParseDigits(str, 2, true, out second);    
                    str.SkipWhiteSpaces();
                    
                    if (str.GetNext()) {
                        char ch = str.GetChar();
                        bool keepLooking = true;
                        if (ch == '.') {
                            str.Index++;  //ParseFraction requires us to advance to the next character.
                            partSecond = ParseFraction(str); 
                            if (str.Index < str.len) {
                                ch = str.Value[str.Index];
                            }
                            else {
                                keepLooking = false;
                            }
                        }
                        if (keepLooking) {                        
                            if (ch == '+' || ch == '-') {
                                timeZoneUsed = true;
                                timeZoneOffset = ParseTimeZone(str, str.GetChar());
                            } else if (ch == 'Z' || ch == 'z') {
                                timeZoneUsed = true;
                            } else {
                                throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));            
                            }
                        }
                    }
                    
                    time =new DateTime(raw.year, raw.num[0], raw.num[1], hour, minute, second);
                    time = time.AddTicks((long)Math.Round(partSecond * Calendar.TicksPerSecond));
                    if (timeZoneUsed) {
                        time = AdjustTimeZone(time, timeZoneOffset, styles, false);
                    }
                    
                    return time;
                }
            }
            throw new FormatException(Environment.GetResourceString("Format_BadDateTime"));            
        }
        
        /*=================================ParseDigits==================================
        **Action: Parse the number string in __DTString that are formatted using
        **        the following patterns:
        **        "0", "00", and "000..0"
        **Returns: the integer value
        **Arguments:    str: a __DTString.  The parsing will start from the
        **              next character after str.Index.
        **Exceptions: FormatException if error in parsing number.
        ==============================================================================*/
        
        private static bool ParseDigits(__DTString str, int digitLen, bool isThrowExp, out int result) {
            result = 0;
            if (!str.GetNextDigit()) {
                return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
            }
            result = str.GetDigit();

            if (digitLen == 1) {
                // When digitLen == 1, we should able to parse number like "9" and "19".  However,
                // we won't go beyond two digits.
                //
                // So let's look ahead one character to see if it is a digit.  If yes, add it to result.
                if (str.GetNextDigit()) {
                    result = result * 10 + str.GetDigit();
                } else {
                    // Not a digit, let's roll back the Index.
                    str.Index--;
                }
            } else if (digitLen == 2) {
                if (!str.GetNextDigit()) {
                    return (ParseFormatError(isThrowExp, "Format_BadDateTime"));    
                }
                result = result * 10 + str.GetDigit();
            } else {
                for (int i = 1; i < digitLen; i++) {
                    if (!str.GetNextDigit()) {
                        return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
                    }
                    result = result * 10 + str.GetDigit();
                }
            }

            return (true);
        }

        /*=================================ParseFractionExact==================================
        **Action: Parse the number string in __DTString that are formatted using
        **        the following patterns:
        **        "0", "00", and "000..0"
        **Returns: the fraction value
        **Arguments:    str: a __DTString.  The parsing will start from the
        **              next character after str.Index.
        **Exceptions: FormatException if error in parsing number.
        ==============================================================================*/
        
        private static bool ParseFractionExact(__DTString str, int digitLen, bool isThrowExp, ref double result) {
            if (!str.GetNextDigit()) {
                return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
            }
            result = str.GetDigit();

            for (int i = 1; i < digitLen; i++) {
                if (!str.GetNextDigit()) {
                    return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
                }
                result = result * 10 + str.GetDigit();
            }

            result = ((double)result / Math.Pow(10, digitLen));
            return (true);
        }

        /*=================================ParseSign==================================
        **Action: Parse a positive or a negative sign.
        **Returns:      true if postive sign.  flase if negative sign.
        **Arguments:    str: a __DTString.  The parsing will start from the
        **              next character after str.Index.
        **Exceptions:   FormatException if end of string is encountered or a sign
        **              symbol is not found.
        ==============================================================================*/

        private static bool ParseSign(__DTString str, bool isThrowExp, ref bool result) {
            if (!str.GetNext()) {
                // A sign symbol ('+' or '-') is expected. However, end of string is encountered.
                return (ParseFormatError(isThrowExp, "Format_BadDateTime"));    
            }
            char ch = str.GetChar();
            if (ch == '+') {
                result = true;
                return (true);
            } else if (ch == '-') {
                result = false;
                return (true);
            }
            // A sign symbol ('+' or '-') is expected.
            return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
        }

        /*=================================ParseTimeZoneOffset==================================
        **Action: Parse the string formatted using "z", "zz", "zzz" in DateTime.Format().
        **Returns: the TimeSpan for the parsed timezone offset.
        **Arguments:    str: a __DTString.  The parsing will start from the
        **              next character after str.Index.
        **              len: the repeated number of the "z"
        **Exceptions: FormatException if errors in parsing.
        ==============================================================================*/

        private static bool ParseTimeZoneOffset(__DTString str, int len, bool isThrowExp, ref TimeSpan result) {
            bool isPositive = true;
            int hourOffset;
            int minuteOffset = 0;

            switch (len) {
                case 1:
                case 2:
                    if (!ParseSign(str, isThrowExp, ref isPositive)) {
                        return (false);
                    }
                    if (!ParseDigits(str, len, isThrowExp, out hourOffset)) {
                        return (false);
                    }
                    break;
                default:
                    if (!ParseSign(str, isThrowExp, ref isPositive)) {
                        return (false);
                    }
                    
                    if (!ParseDigits(str, 2, isThrowExp, out hourOffset)) {
                        return (false);
                    }   
                    // ':' is optional.
                    if (str.Match(":")) {
                        // Found ':'
                        if (!ParseDigits(str, 2, isThrowExp, out minuteOffset)) {
                            return (false);
                        }
                    } else {
                        // Since we can not match ':', put the char back.
                        str.Index--;
                        if (!ParseDigits(str, 2, isThrowExp, out minuteOffset)) {
                            return (false);
                        } 
                    }
                    break;
            }
            result = (new TimeSpan(hourOffset, minuteOffset, 0));
            if (!isPositive) {
                result = result.Negate();
            }
            return (true);
        }

        /*=================================MatchAbbreviatedMonthName==================================
        **Action: Parse the abbreviated month name from string starting at str.Index.
        **Returns: A value from 1 to 12 for the first month to the twelveth month.
        **Arguments:    str: a __DTString.  The parsing will start from the
        **              next character after str.Index.
        **Exceptions: FormatException if an abbreviated month name can not be found.
        ==============================================================================*/

        private static bool MatchAbbreviatedMonthName(__DTString str, DateTimeFormatInfo dtfi, bool isThrowExp, ref int result) {
            int maxMatchStrLen = 0;
            result = -1;
            if (str.GetNext()) {
                //
                // Scan the month names (note that some calendars has 13 months) and find
                // the matching month name which has the max string length.
                // We need to do this because some cultures (e.g. "cs-CZ") which have
                // abbreviated month names with the same prefix.
                //            
                int monthsInYear = (dtfi.GetMonthName(13).Length == 0 ? 12: 13);
                for (int i = 1; i <= monthsInYear; i++) {
                    String searchStr = dtfi.GetAbbreviatedMonthName(i);
                    if (str.MatchSpecifiedWord(searchStr)) {
                        int matchStrLen = searchStr.Length;
                        if (matchStrLen > maxMatchStrLen) {
                            maxMatchStrLen = matchStrLen;
                            result = i;
                        }
                    }
                }

            }
            if (result > 0) {
                str.Index += (maxMatchStrLen - 1);
                return (true);
            }
            return (ParseFormatError(isThrowExp, "Format_BadDateTime"));            
        }

        /*=================================MatchMonthName==================================
        **Action: Parse the month name from string starting at str.Index.
        **Returns: A value from 1 to 12 indicating the first month to the twelveth month.
        **Arguments:    str: a __DTString.  The parsing will start from the
        **              next character after str.Index.
        **Exceptions: FormatException if a month name can not be found.
        ==============================================================================*/

        private static bool MatchMonthName(__DTString str, DateTimeFormatInfo dtfi, bool isThrowExp, ref int result) {
            int maxMatchStrLen = 0;
            result = -1;
            if (str.GetNext()) {
                //
                // Scan the month names (note that some calendars has 13 months) and find
                // the matching month name which has the max string length.
                // We need to do this because some cultures (e.g. "vi-VN") which have
                // month names with the same prefix.
                //
                int monthsInYear = (dtfi.GetMonthName(13).Length == 0 ? 12: 13);
                for (int i = 1; i <= monthsInYear; i++) {
                    String searchStr = dtfi.GetMonthName(i);
                    if ( dtfi.HasSpacesInMonthNames
                            ? str.MatchSpecifiedWords(searchStr, false)
                            : str.MatchSpecifiedWord(searchStr)) {
                        int matchStrLen = searchStr.Length;
                        if (matchStrLen > maxMatchStrLen) {
                            maxMatchStrLen = matchStrLen;
                            result = i;
                        }
                    }
                }

                // Search genitive form.
                if ((dtfi.FormatFlags & DateTimeFormatFlags.UseGenitiveMonth) != 0) {
                    int tempResult = str.MatchLongestWords(dtfi.internalGetGenitiveMonthNames(false), ref maxMatchStrLen);
                    // We found a longer match in the genitive month name.  Use this as the result.
                    // The result from MatchLongestWords is 0 ~ length of word array.
                    // So we increment the result by one to become the month value.                    
                    if (tempResult >= 0) {
                        result = tempResult + 1;
                    }
                }


            }

            if (result > 0) {
                str.Index += (maxMatchStrLen - 1);
                return (true);
            }
            return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
        }

        /*=================================MatchAbbreviatedDayName==================================
        **Action: Parse the abbreviated day of week name from string starting at str.Index.
        **Returns: A value from 0 to 6 indicating Sunday to Saturday.
        **Arguments:    str: a __DTString.  The parsing will start from the
        **              next character after str.Index.
        **Exceptions: FormatException if a abbreviated day of week name can not be found.
        ==============================================================================*/

        private static bool MatchAbbreviatedDayName(__DTString str, DateTimeFormatInfo dtfi, bool isThrowExp, ref int result) {
            if (str.GetNext()) {
                for (DayOfWeek i = DayOfWeek.Sunday; i <= DayOfWeek.Saturday; i++) {
                    String searchStr = dtfi.GetAbbreviatedDayName(i);
                    if (str.MatchSpecifiedWord(searchStr)) {
                        str.Index += (searchStr.Length - 1);
                        result = (int)i;
                        return (true);
                    }
                }
            }
            return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
        }

        /*=================================MatchDayName==================================
        **Action: Parse the day of week name from string starting at str.Index.
        **Returns: A value from 0 to 6 indicating Sunday to Saturday.
        **Arguments:    str: a __DTString.  The parsing will start from the
        **              next character after str.Index.
        **Exceptions: FormatException if a day of week name can not be found.
        ==============================================================================*/

        private static bool MatchDayName(__DTString str, DateTimeFormatInfo dtfi, bool isThrowExp, ref int result) {
            // Turkish (tr-TR) got day names with the same prefix.
            int maxMatchStrLen = 0;
            result = -1;
            if (str.GetNext()) {
                for (DayOfWeek i = DayOfWeek.Sunday; i <= DayOfWeek.Saturday; i++) {
                    String searchStr = dtfi.GetDayName(i);
                    if (str.MatchSpecifiedWord(searchStr)) {
                        int matchStrLen = (searchStr.Length - 1);
                        if (matchStrLen > maxMatchStrLen) {
                            maxMatchStrLen = matchStrLen;
                            result = (int)i;
                        }
                    }                    
                }
            }
            if (result >= 0) {
                str.Index += maxMatchStrLen;
                return (true);
            }            
            return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
        }

        /*=================================MatchEraName==================================
        **Action: Parse era name from string starting at str.Index.
        **Returns: An era value. 
        **Arguments:    str: a __DTString.  The parsing will start from the
        **              next character after str.Index.
        **Exceptions: FormatException if an era name can not be found.
        ==============================================================================*/

        private static bool MatchEraName(__DTString str, DateTimeFormatInfo dtfi, bool isThrowExp, ref int result) {
            if (str.GetNext()) {
                int[] eras = dtfi.Calendar.Eras;

                if (eras != null) {
                    for (int i = 0; i <= eras.Length; i++) {
                        String searchStr = dtfi.GetEraName(eras[i]);
                        if (str.MatchSpecifiedWord(searchStr)) {
                            str.Index += (searchStr.Length - 1);
                            result = eras[i];
                            return (true);
                        }
                        searchStr = dtfi.GetAbbreviatedEraName(eras[i]);
                        if (str.MatchSpecifiedWord(searchStr)) {
                            str.Index += (searchStr.Length - 1);
                            result = eras[i];
                            return (true);
                        }
                    }
                }
            }
            return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
        }

        /*=================================MatchTimeMark==================================
        **Action: Parse the time mark (AM/PM) from string starting at str.Index.
        **Returns: TM_AM or TM_PM.
        **Arguments:    str: a __DTString.  The parsing will start from the
        **              next character after str.Index.
        **Exceptions: FormatException if a time mark can not be found.
        ==============================================================================*/

        private static bool MatchTimeMark(__DTString str, DateTimeFormatInfo dtfi, bool isThrowExp, ref int result) {
            result = -1;
            // In some cultures have empty strings in AM/PM mark. E.g. af-ZA (0x0436), the AM mark is "", and PM mark is "nm".
            if (dtfi.AMDesignator.Length == 0) {
                result = TM_AM;
            }
            if (dtfi.PMDesignator.Length == 0) {
                result = TM_PM;
            }
            
            if (str.GetNext()) {
                String searchStr = dtfi.AMDesignator;
                if (searchStr.Length > 0) {
                    if (str.MatchSpecifiedWord(searchStr)) {
                        // Found an AM timemark with length > 0.
                        str.Index += (searchStr.Length - 1);
                        result = TM_AM;
                        return (true);
                    }
                }
                searchStr = dtfi.PMDesignator;
                if (searchStr.Length > 0) {
                    if (str.MatchSpecifiedWord(searchStr)) {
                        // Found a PM timemark with length > 0.
                        str.Index += (searchStr.Length - 1);
                        result = TM_PM;
                        return (true);
                    }
                }
                // If we can not match the time mark strings with length > 0, 
                // just return the 
                return (true);
            } 
            if (result != -1) {
                // If one of the AM/PM marks is empty string, return the result.                
                return (true);
            }            
            return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
        }

        /*=================================MatchAbbreviatedTimeMark==================================
        **Action: Parse the abbreviated time mark (AM/PM) from string starting at str.Index.
        **Returns: TM_AM or TM_PM.
        **Arguments:    str: a __DTString.  The parsing will start from the
        **              next character after str.Index.
        **Exceptions: FormatException if a abbreviated time mark can not be found.
        ==============================================================================*/

        private static bool MatchAbbreviatedTimeMark(__DTString str, DateTimeFormatInfo dtfi, bool isThrowExp, ref int result) {
            // NOTENOTE yslin: the assumption here is that abbreviated time mark is the first
            // character of the AM/PM designator.  If this invariant changes, we have to
            // change the code below.
            if (str.GetNext())
            {
                if (str.GetChar() == dtfi.AMDesignator[0]) {
                    result = TM_AM;
                    return (true);
                }
                if (str.GetChar() == dtfi.PMDesignator[0]) {                
                    result = TM_PM;
                    return (true);
                }
            }
            return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
        }

        /*=================================CheckNewValue==================================
        **Action: Check if currentValue is initialized.  If not, return the newValue.
        **        If yes, check if the current value is equal to newValue.  Throw ArgumentException
        **        if they are not equal.  This is used to check the case like "d" and "dd" are both
        **        used to format a string.
        **Returns: the correct value for currentValue.
        **Arguments:
        **Exceptions:
        ==============================================================================*/

        private static bool CheckNewValue(ref int currentValue, int newValue, char patternChar, bool isThrowExp) {
            if (currentValue == -1) {
                currentValue = newValue;
                return (true);
            } else {
                if (newValue != currentValue) {
                    BCLDebug.Trace("NLS", "DateTimeParse.CheckNewValue() : ", patternChar, " is repeated");
                    if (isThrowExp) {
                        throw new ArgumentException(
                            String.Format(Environment.GetResourceString("Format_RepeatDateTimePattern"), patternChar), "format");
                    }
                    return (false);
                }
            }
            return (true);
        }

        private static void CheckDefaultDateTime(DateTimeResult result, ref Calendar cal, DateTimeStyles styles) {
#if YSLIN_DEBUG
            Console.WriteLine(">> CheckDefaultDateTime");
            Console.WriteLine("   result.Year = " + result.Year);
            Console.WriteLine("   result.Month = " + result.Month);
            Console.WriteLine("   result.Day = " + result.Day);
#endif            
            
            if ((result.Year == -1) || (result.Month == -1) || (result.Day == -1)) {
                /*
                The following table describes the behaviors of getting the default value
                when a certain year/month/day values are missing.

                An "X" means that the value exists.  And "--" means that value is missing.

                Year    Month   Day =>  ResultYear  ResultMonth     ResultDay       Note

                X       X       X       Parsed year Parsed month    Parsed day
                X       X       --      Parsed Year Parsed month    First day       If we have year and month, assume the first day of that month.
                X       --      X       Parsed year First month     Parsed day      If the month is missing, assume first month of that year.
                X       --      --      Parsed year First month     First day       If we have only the year, assume the first day of that year.

                --      X       X       CurrentYear Parsed month    Parsed day      If the year is missing, assume the current year.
                --      X       --      CurrentYear Parsed month    First day       If we have only a month value, assume the current year and current day.
                --      --      X       CurrentYear First month     Parsed day      If we have only a day value, assume current year and first month.
                --      --      --      CurrentYear Current month   Current day     So this means that if the date string only contains time, you will get current date.
                    
                */

                DateTime now = DateTime.Now;
                if (result.Month == -1 && result.Day == -1) {                    
                    if (result.Year == -1) {
                        if ((styles & DateTimeStyles.NoCurrentDateDefault) != 0) {
                            // If there is no year/month/day values, and NoCurrentDateDefault flag is used,
                            // set the year/month/day value to the beginning year/month/day of DateTime().
                            // Note we should be using Gregorian for the year/month/day.
                            cal = GregorianCalendar.GetDefaultInstance();
                            result.Year = result.Month = result.Day = 1;
                        } else {
                            // Year/Month/Day are all missing.  
                            result.Year = cal.GetYear(now);                    
                            result.Month = cal.GetMonth(now);
                            result.Day = cal.GetDayOfMonth(now);
                        }
                    } else {
                        // Month/Day are both missing.
                        result.Month = 1;
                        result.Day = 1;
                    }                    
                } else {
                    if (result.Year == -1) {
                        result.Year = cal.GetYear(now);
                    }
                    if (result.Month == -1) {
                        result.Month = 1;
                    }
                    if (result.Day == -1) {
                        result.Day = 1;
                    }
                }                
            }
            // Set Hour/Minute/Second to zero if these value are not in str.
            if (result.Hour   == -1) result.Hour = 0;
            if (result.Minute == -1) result.Minute = 0;
            if (result.Second == -1) result.Second = 0;
            if (result.era == -1) result.era = Calendar.CurrentEra;
        }

        // Expand a pre-defined format string (like "D" for long date) to the real format that
        // we are going to use in the date time parsing.
        // This method also set the dtfi according/parseInfo to some special pre-defined
        // formats.
        //
        private static String ExpandPredefinedFormat(String format, ref DateTimeFormatInfo dtfi, ParsingInfo parseInfo) {
            //
            // Check the format to see if we need to override the dtfi to be InvariantInfo,
            // and see if we need to set up the userUniversalTime flag.
            //
            switch (format[0]) {
                case 'r':
                case 'R':       // RFC 1123 Standard.  (in Universal time)
                    parseInfo.calendar = GregorianCalendar.GetDefaultInstance();                    
                    dtfi = DateTimeFormatInfo.InvariantInfo;                    
                    break;
                case 's':       // Sortable format (in local time)                
                    dtfi = DateTimeFormatInfo.InvariantInfo;
                    parseInfo.calendar = GregorianCalendar.GetDefaultInstance();
                    break;
                case 'u':       // Universal time format in sortable format.
                    parseInfo.calendar = GregorianCalendar.GetDefaultInstance();                    
                    dtfi = DateTimeFormatInfo.InvariantInfo;                    
                    break;
                case 'U':       // Universal time format with culture-dependent format.                        
                    parseInfo.calendar = GregorianCalendar.GetDefaultInstance();
                    parseInfo.fUseUniversalTime = true;
                    if (dtfi.Calendar.GetType() != typeof(GregorianCalendar)) {
                        dtfi = (DateTimeFormatInfo)dtfi.Clone();
                        dtfi.Calendar = GregorianCalendar.GetDefaultInstance();
                    }
                    break;
            } 

            //
            // Expand the pre-defined format character to the real format from DateTimeFormatInfo.
            //
            return (DateTimeFormat.GetRealFormat(format, dtfi));            
        }
            
        // Given a specified format character, parse and update the parsing result.
        //
        private static bool ParseByFormat(
            __DTString str, 
            __DTString format, 
            ParsingInfo parseInfo, 
            DateTimeFormatInfo dtfi,
            bool isThrowExp,
            DateTimeResult result) {
            
            int tokenLen = 0;
            int tempYear = 0, tempMonth = 0, tempDay = 0, tempDayOfWeek = 0, tempHour = 0, tempMinute = 0, tempSecond = 0;
            double tempFraction = 0;
            int tempTimeMark = 0;
            
            char ch = format.GetChar();
            
            switch (ch) {
                case 'y':
                    tokenLen = format.GetRepeatCount();
                    if (tokenLen <= 2) {
                        parseInfo.fUseTwoDigitYear = true;
                    }
                    if (!ParseDigits(str, tokenLen, isThrowExp, out tempYear)) {
                        return (false);
                    }                    
                    if (!CheckNewValue(ref result.Year, tempYear, ch, isThrowExp)) {
                        return (false);
                    }
                    break;
                case 'M':
                    tokenLen = format.GetRepeatCount();
                    if (tokenLen <= 2) {
                        if (!ParseDigits(str, tokenLen, isThrowExp, out tempMonth)) {
                            return (false);
                        }
                    } else {
                        if (tokenLen == 3) {
                            if (!MatchAbbreviatedMonthName(str, dtfi, isThrowExp, ref tempMonth)) {
                                return (false);
                            }
                        } else {
                            if (!MatchMonthName(str, dtfi, isThrowExp, ref tempMonth)) {
                                return (false);
                            }
                        }
                    }
                    if (!CheckNewValue(ref result.Month, tempMonth, ch, isThrowExp)) {
                        return (false);
                    }
                    break;
                case 'd':
                    // Day & Day of week
                    tokenLen = format.GetRepeatCount();
                    if (tokenLen <= 2) {
                        // "d" & "dd"
                        if (!ParseDigits(str, tokenLen, isThrowExp, out tempDay)) {
                            return (false);
                        }
                        if (!CheckNewValue(ref result.Day, tempDay, ch, isThrowExp)) {
                            return (false);
                        }
                    } else {
                        if (tokenLen == 3) {
                            // "ddd"
                            if (!MatchAbbreviatedDayName(str, dtfi, isThrowExp, ref tempDayOfWeek)) {
                                return (false);
                            }
                        } else {
                            // "dddd*"
                            if (!MatchDayName(str, dtfi, isThrowExp, ref tempDayOfWeek)) {
                                return (false);
                            }
                        }
                        if (!CheckNewValue(ref parseInfo.dayOfWeek, tempDayOfWeek, ch, isThrowExp)) {
                            return (false);
                        }
                    }
                    break;
                case 'g':
                    tokenLen = format.GetRepeatCount();
                    // Put the era value in result.era.
                    if (!MatchEraName(str, dtfi, isThrowExp, ref result.era)) {
                        return (false);
                    }
                    break;
                case 'h':
                    parseInfo.fUseHour12 = true;
                    tokenLen = format.GetRepeatCount();
                    if (!ParseDigits(str, (tokenLen < 2? 1 : 2), isThrowExp, out tempHour)) {
                        return (false);
                    }
                    if (!CheckNewValue(ref result.Hour, tempHour, ch, isThrowExp)) {
                        return (false);
                    }
                    break;
                case 'H':
                    tokenLen = format.GetRepeatCount();
                    if (!ParseDigits(str, (tokenLen < 2? 1 : 2), isThrowExp, out tempHour)) {
                        return (false);
                    }
                    if (!CheckNewValue(ref result.Hour, tempHour, ch, isThrowExp)) {
                        return (false);
                    }
                    break;
                case 'm':
                    tokenLen = format.GetRepeatCount();
                    if (!ParseDigits(str, (tokenLen < 2? 1 : 2), isThrowExp, out tempMinute)) {
                        return (false);
                    }
                    if (!CheckNewValue(ref result.Minute, tempMinute, ch, isThrowExp)) {
                        return (false);
                    }
                    break;
                case 's':
                    tokenLen = format.GetRepeatCount();
                    if (!ParseDigits(str, (tokenLen < 2? 1 : 2), isThrowExp, out tempSecond)) {
                        return (false);
                    }
                    if (!CheckNewValue(ref result.Second, tempSecond, ch, isThrowExp)) {
                        return (false);
                    }
                    break;
                case 'f':
                    tokenLen = format.GetRepeatCount();
                    if (tokenLen <= DateTimeFormat.MaxSecondsFractionDigits) {
                        if (!ParseFractionExact(str, tokenLen, isThrowExp, ref tempFraction)) {
                            return (false);
                        }
                        if (result.fraction < 0) {
                            result.fraction = tempFraction;
                        } else {
                            if (tempFraction != result.fraction) {
                                if (isThrowExp) {
                                    throw new ArgumentException(
                                        String.Format(Environment.GetResourceString("Format_RepeatDateTimePattern"), ch), "str");
                                } else {
                                    return (false);
                                }
                            }                                        
                        }
                    } else {
                        return ParseFormatError(isThrowExp, "Format_BadDateTime");
                    }
                    break;
                case 't':
                    // AM/PM designator
                    tokenLen = format.GetRepeatCount();
                    if (tokenLen == 1) {
                        if (!MatchAbbreviatedTimeMark(str, dtfi, isThrowExp, ref tempTimeMark)) {
                            return (false);
                        }
                    } else {                        
                        if (!MatchTimeMark(str, dtfi, isThrowExp, ref tempTimeMark)) {
                            return (false);
                        }
                    }

                    if (!CheckNewValue(ref parseInfo.timeMark, tempTimeMark, ch, isThrowExp)) {
                        return (false);
                    }
                    break;
                case 'z':
                    // timezone offset
                    if (parseInfo.fUseTimeZone) {
                        throw new ArgumentException(Environment.GetResourceString("Argument_TwoTimeZoneSpecifiers"), "str");
                    }
                    parseInfo.fUseTimeZone = true;
                    tokenLen = format.GetRepeatCount();
                    if (!ParseTimeZoneOffset(str, tokenLen, isThrowExp, ref parseInfo.timeZoneOffset)) {
                        return (false);
                    }                    
                    break;
                case 'Z':
                    if (parseInfo.fUseTimeZone) {
                        throw new ArgumentException(Environment.GetResourceString("Argument_TwoTimeZoneSpecifiers"), "str");
                    }
                    parseInfo.fUseTimeZone = true;
                    parseInfo.timeZoneOffset = new TimeSpan(0);

                    str.Index++;
                    if (!GetTimeZoneName(str)) {
                        BCLDebug.Trace("NLS", "DateTimeParse.DoStrictParse(): 'Z' or 'GMT' are expected");
                        return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
                    }
                    break;
                case ':':
                    if (!str.Match(dtfi.TimeSeparator)) {
                        // A time separator is expected.
                        BCLDebug.Trace("NLS", "DateTimeParse.DoStrictParse(): ':' is expected");
                        return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
                    }
                    break;
                case '/':
                    if (!str.Match(dtfi.DateSeparator)) {
                        // A date separator is expected.
                        BCLDebug.Trace("NLS", "DateTimeParse.DoStrictParse(): date separator is expected");
                        return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
                    }
                    break;
                case '\"':
                case '\'':
                    StringBuilder enquotedString = new StringBuilder();
                    try {
                        // Use ParseQuoteString so that we can handle escape characters within the quoted string.
                        tokenLen = DateTimeFormat.ParseQuoteString(format.Value, format.Index, enquotedString); 
                    } catch (Exception) {
                        if (isThrowExp) { 
                            throw new FormatException(String.Format(Environment.GetResourceString("Format_BadQuote"), ch));
                        } else {
                            return (false);
                        }
                    }
                    format.Index += tokenLen - 1;                    
                    
                    // Some cultures uses space in the quoted string.  E.g. Spanish has long date format as:
                    // "dddd, dd' de 'MMMM' de 'yyyy".  When inner spaces flag is set, we should skip whitespaces if there is space
                    // in the quoted string.
                    String quotedStr = enquotedString.ToString();
                    for (int i = 0; i < quotedStr.Length; i++) {
                        if (quotedStr[i] == ' ' && parseInfo.fAllowInnerWhite) {
                            str.SkipWhiteSpaces();
                        } else if (!str.Match(quotedStr[i])) {
                            // Can not find the matching quoted string.
                            BCLDebug.Trace("NLS", "DateTimeParse.DoStrictParse():Quote string doesn't match");
                            return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
                        }
                    }
                    break;
                case '%':
                    // Skip this so we can get to the next pattern character.
                    // Used in case like "%d", "%y"

                    // Make sure the next character is not a '%' again.
                    if (format.Index >= format.Value.Length - 1 || format.Value[format.Index + 1] == '%') {
                        BCLDebug.Trace("NLS", "DateTimeParse.DoStrictParse():%% is not permitted");
                        return (ParseFormatError(isThrowExp, "Format_BadFormatSpecifier"));
                    }
                    break;
                case '\\':
                    // Escape character. For example, "\d".
                    // Get the next character in format, and see if we can
                    // find a match in str.
                    if (format.GetNext()) {
                        if (!str.Match(format.GetChar())) {
                            // Can not find a match for the escaped character.
                            BCLDebug.Trace("NLS", "DateTimeParse.DoStrictParse(): Can not find a match for the escaped character");
                            return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
                        }
                    } else {
                        BCLDebug.Trace("NLS", "DateTimeParse.DoStrictParse(): \\ is at the end of the format string");
                        return (ParseFormatError(isThrowExp, "Format_BadFormatSpecifier"));
                    }
                    break;
                default:
                    if (ch == ' ') {
                        if (parseInfo.fAllowInnerWhite) {
                            // Skip whitespaces if AllowInnerWhite.
                            // Do nothing here.
                        } else {
                            if (!str.Match(ch)) {
                                // If the space does not match, and trailing space is allowed, we do
                                // one more step to see if the next format character can lead to
                                // successful parsing.
                                // This is used to deal with special case that a empty string can match
                                // a specific pattern.
                                // The example here is af-ZA, which has a time format like "hh:mm:ss tt".  However,
                                // its AM symbol is "" (empty string).  If fAllowTrailingWhite is used, and time is in 
                                // the AM, we will trim the whitespaces at the end, which will lead to a failure
                                // when we are trying to match the space before "tt".                                
                                if (parseInfo.fAllowTrailingWhite) {
                                    if (format.GetNext()) {
                                        if (ParseByFormat(str, format, parseInfo, dtfi, isThrowExp, result)) {
                                            return (true);
                                        }
                                    }
                                }
                                return (ParseFormatError(isThrowExp, "Format_BadDateTime")); 
                            }
                            // Found a macth.
                        }
                    } else {
                        if (format.MatchSpecifiedWord(GMTName)) {
                            format.Index += (GMTName.Length - 1);
                            // Found GMT string in format.  This means the DateTime string
                            // is in GMT timezone.
                            parseInfo.fUseTimeZone = true;
                            if (!str.Match(GMTName)) {
                                BCLDebug.Trace("NLS", "DateTimeParse.DoStrictParse(): GMT in format, but not in str");
                                return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
                            }
                        } else if (!str.Match(ch)) {
                            // ch is expected.
                            BCLDebug.Trace ("NLS", "DateTimeParse.DoStrictParse(): '", ch, "' is expected");
                            return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
                        }
                    }
                    break;
            } // switch
            return (true);
        }

        // A very small utility method to either return false or throw format exception according to the flag.
        private static bool ParseFormatError(bool isThrowException, String resourceID)
        {
            if (isThrowException)
            {
                throw new FormatException(Environment.GetResourceString(resourceID));
            }
            return (false);
        }
        
        /*=================================DoStrictParse==================================
        **Action: Do DateTime parsing using the format in formatParam.
        **Returns: The parsed DateTime.
        **Arguments:
        **Exceptions:
        **
        **Notes:
        **  When the following general formats are used, InvariantInfo is used in dtfi:
        **      'r', 'R', 's'.
        **  When the following general formats are used, the time is assumed to be in Universal time.
        **
        **Limitations:
        **  Only GregarianCalendar is supported for now.
        **  Only support GMT timezone.
        ==============================================================================*/

        private static bool DoStrictParse(
            String s, 
            String formatParam, 
            DateTimeStyles styles, 
            DateTimeFormatInfo dtfi, 
            bool isThrowExp,
            out DateTime returnValue) {

            bool bTimeOnly = false;
            returnValue = new DateTime();
            ParsingInfo parseInfo = new ParsingInfo();

            parseInfo.calendar = dtfi.Calendar;
            parseInfo.fAllowInnerWhite = ((styles & DateTimeStyles.AllowInnerWhite) != 0);
            parseInfo.fAllowTrailingWhite = ((styles & DateTimeStyles.AllowTrailingWhite) != 0);

            if (formatParam.Length == 1) {
                formatParam = ExpandPredefinedFormat(formatParam, ref dtfi, parseInfo);
            }

            DateTimeResult result = new DateTimeResult();

            // Reset these values to negative one so that we could throw exception
            // if we have parsed every item twice.
            result.Hour = result.Minute = result.Second = -1;

            __DTString format = new __DTString(formatParam);
            __DTString str = new __DTString(s);

            if (parseInfo.fAllowTrailingWhite) {
                // Trim trailing spaces if AllowTrailingWhite.
                format.TrimTail();
                format.RemoveTrailingInQuoteSpaces();
                str.TrimTail();
            }

            if ((styles & DateTimeStyles.AllowLeadingWhite) != 0) {
                format.SkipWhiteSpaces();
                format.RemoveLeadingInQuoteSpaces();
                str.SkipWhiteSpaces();
            }

            //
            // Scan every character in format and match the pattern in str.
            //
            while (format.GetNext()) {
                // We trim inner spaces here, so that we will not eat trailing spaces when
                // AllowTrailingWhite is not used.
                if (parseInfo.fAllowInnerWhite) {
                    str.SkipWhiteSpaces();
                }
                if (!ParseByFormat(str, format, parseInfo, dtfi, isThrowExp, result) &&
                   !isThrowExp) {
                   return (false);
                }
            }
            if (str.Index < str.Value.Length - 1) {
                // There are still remaining character in str.
                BCLDebug.Trace("NLS", "DateTimeParse.DoStrictParse(): Still characters in str, str.Index = ", str.Index);
                return (ParseFormatError(isThrowExp, "Format_BadDateTime"));                
            }

            if (parseInfo.fUseTwoDigitYear) {
                // A two digit year value is expected. Check if the parsed year value is valid.
                if (result.Year >= 100) {
                    BCLDebug.Trace("NLS", "DateTimeParse.DoStrictParse(): Invalid value for two-digit year");
                    return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
                }
                result.Year = parseInfo.calendar.ToFourDigitYear(result.Year);
            }

            if (parseInfo.fUseHour12) {
                if (parseInfo.timeMark == -1) {
                    // hh is used, but no AM/PM designator is specified.
                    // Assume the time is AM.  
                    // Don't throw exceptions in here becasue it is very confusing for people.
                    // I always got confused myself when I use "hh:mm:ss" to parse a time string,
                    // and ParseExact() throws on me (because I didn't use the 24-hour clock 'HH').
                    parseInfo.timeMark = TM_AM;
                    BCLDebug.Trace("NLS", "DateTimeParse.DoStrictParse(): hh is used, but no AM/PM designator is specified.");
                }
                if (result.Hour > 12) {
                    // AM/PM is used, but the value for HH is too big.
                    BCLDebug.Trace("NLS", "DateTimeParse.DoStrictParse(): AM/PM is used, but the value for HH is too big.");
                    return (ParseFormatError(isThrowExp, "Format_BadDateTime"));
                }
                if (parseInfo.timeMark == TM_AM) {
                    if (result.Hour == 12) {
                        result.Hour = 0;
                    }
                } else {
                    result.Hour = (result.Hour == 12) ? 12 : result.Hour + 12;
                }
            }

            // Check if the parased string only contains hour/minute/second values.
            bTimeOnly = (result.Year == -1 && result.Month == -1 && result.Day == -1);
            CheckDefaultDateTime(result, ref parseInfo.calendar, styles);
            try {
                returnValue = parseInfo.calendar.ToDateTime(result.Year, result.Month, result.Day, 
                    result.Hour, result.Minute, result.Second, 0, result.era);
                if (result.fraction > 0) {
                    returnValue = returnValue.AddTicks((long)Math.Round(result.fraction * Calendar.TicksPerSecond));
            }
            } catch (ArgumentOutOfRangeException) {
                return (ParseFormatError(isThrowExp, "Format_DateOutOfRange"));
            } catch (Exception exp) {
                if (isThrowExp) {
                    throw exp;
                } else {
                    return (false);
                }
            }

            //
            // NOTENOTE YSLin:
            // We have to check day of week before we adjust to the time zone.
            // It is because the value of day of week may change after adjusting
            // to the time zone.
            //
            if (parseInfo.dayOfWeek != -1) {
                //
                // Check if day of week is correct.
                //
                if (parseInfo.dayOfWeek != (int)parseInfo.calendar.GetDayOfWeek(returnValue)) {
                    BCLDebug.Trace("NLS", "DateTimeParse.DoStrictParse(): day of week is not correct");
                    return (ParseFormatError(isThrowExp, "Format_BadDayOfWeek"));
                }
            }
            if (parseInfo.fUseTimeZone) {
                if ((styles & DateTimeStyles.AdjustToUniversal) != 0) {
                    returnValue = AdjustTimeZoneToUniversal(returnValue, parseInfo.timeZoneOffset);
                } else {
                    returnValue = AdjustTimeZoneToLocal(returnValue, parseInfo.timeZoneOffset, bTimeOnly);
                }
            } else if (parseInfo.fUseUniversalTime) {
                try {
                    returnValue = returnValue.ToLocalTime();
                } catch (ArgumentOutOfRangeException) {
                    return (ParseFormatError(isThrowExp, "Format_DateOutOfRange"));
                }
            }
            return (true);
        }


 		// This method should never be called.  Its sole purpose is to shut up the compiler
		//	because it warns about private fields that are never used.  Most of these fields
		//	are used in unmanaged code.
#if _DEBUG
		internal String[] NeverCallThis()
		{
			BCLDebug.Assert(false,"NeverCallThis");
			String[] i = invariantMonthNames;
			i = invariantAbbrevMonthNames;
			i = invariantDayNames;
			return invariantAbbrevDayNames;
        }
#endif
   }

    //
    // This is a string parsing helper which wraps a String object.
    // It has a Index property which tracks
    // the current parsing pointer of the string.
    //
	[Serializable()]
    internal 
    class __DTString
    {
        //
        // Value propery: stores the real string to be parsed.
        //
        internal String Value;

        //
        // Index property: points to the character that we are currently parsing.
        //
        internal int Index = -1;

        // The length of Value string.
        internal int len = 0;

        private CompareInfo m_info;

        internal __DTString()
        {
            Value = "";
        }

        internal __DTString(String str)
        {
            Value = str;
            len = Value.Length;
            m_info = Thread.CurrentThread.CurrentCulture.CompareInfo;
        }

        internal CompareInfo CompareInfo {
            get {
                return m_info;
            }
        }

        //
        // Advance the Index.  
        // Return true if Index is NOT at the end of the string.
        //
        // Typical usage:
        // while (str.GetNext())
        // {
        //     char ch = str.GetChar()
        // }
        internal bool GetNext() {
            Index++;
            return (Index < len);
        }

        //
        // Return the word starting from the current index.
        // Index will not be updated.
        //
        internal int FindEndOfCurrentWord() {
            int i = Index;
            while (i < len) {
                if (Value[i] == ' ' || Value[i] == ',' || Value[i] == '\'' || Char.IsDigit(Value[i])) {
                    break;
                }
                i++;
            }
            return i;
        }

        internal String PeekCurrentWord() {
            int endIndex = FindEndOfCurrentWord();
            return Value.Substring(Index, (endIndex - Index));
        }

        internal bool MatchSpecifiedWord(String target) {
            return MatchSpecifiedWord(target, target.Length + Index);
        }
        
        internal bool MatchSpecifiedWord(String target, int endIndex) {
            int count = endIndex - Index;

            if (count != target.Length) {
                return false;
            }

            if (Index + count > len) {
                return false;
            }

            return (m_info.Compare(Value, Index, count, target, 0, count, CompareOptions.IgnoreCase)==0);
        }

        internal bool StartsWith(String target, bool checkWordBoundary) {
            if (target.Length > (Value.Length - Index)) {
                return false;
            }

            if (m_info.Compare(Value, Index, target.Length, target, 0, target.Length, CompareOptions.IgnoreCase)!=0) {
                return (false);
            }

            if (checkWordBoundary) {
                int nextCharIndex = Index + target.Length;
                if (nextCharIndex < Value.Length) {
                    if (Char.IsLetter(Value[nextCharIndex])) {
                        return (false);
                    }
                }
            }
            return (true);
        }

        private static Char[] WhiteSpaceChecks = new Char[] { ' ', '\u00A0' };

        internal bool MatchSpecifiedWords(String target, bool checkWordBoundary) {
            int valueRemaining = Value.Length - Index;
            if (target.Length > valueRemaining) {
                return false;
            }
            if (m_info.Compare(Value, Index, target.Length, target, 0, target.Length, CompareOptions.IgnoreCase) !=0) {
                // Check word by word
                int position = 0;
                int wsIndex = target.IndexOfAny(WhiteSpaceChecks, position);
                if (wsIndex == -1) {
                    return false;
                }
                do {                                        
                    if (!Char.IsWhiteSpace(Value[Index + wsIndex])) {
                        return false;
                    }
                    int segmentLength = wsIndex - position;
                    if (segmentLength > 0 && m_info.Compare(Value, Index + position, segmentLength, target, position, segmentLength, CompareOptions.IgnoreCase) !=0) {
                        return false;
                    }
                    position = wsIndex + 1;
                } while ((wsIndex = target.IndexOfAny(WhiteSpaceChecks, position)) >= 0);
                // now check the last segment;
                if (position < target.Length) {
                    int segmentLength = target.Length - position;
                    if (m_info.Compare(Value, Index + position, segmentLength, target, position, segmentLength, CompareOptions.IgnoreCase) !=0) {
                        return false;
                    }
                }
            }

            if (checkWordBoundary) {
                int nextCharIndex = Index + target.Length;
                if (nextCharIndex < Value.Length) {
                    if (Char.IsLetter(Value[nextCharIndex])) {
                        return (false);
                    }
                }
            }
            return (true);
        }
        
        //
        // Check to see if the string starting from Index is a prefix of 
        // str. 
        // If a match is found, true value is returned and Index is updated to the next character to be parsed.
        // Otherwise, Index is unchanged.
        //
        internal bool Match(String str) {
            if (++Index >= len) {
                return (false);
            }

            if (str.Length > (Value.Length - Index)) {
                return false;
            }
            
            if (m_info.Compare(Value, Index, str.Length, str, 0, str.Length, CompareOptions.Ordinal)==0) {
                // Update the Index to the end of the matching string.
                // So the following GetNext()/Match() opeartion will get
                // the next character to be parsed.
                Index += (str.Length - 1);
                return (true);
            }
            return (false);
        }

        internal bool Match(char ch) {
            if (++Index >= len) {
                return (false);
            }
            if (Value[Index] == ch) {
                return (true);
            }
            return (false);
        }

        //
        // Trying to match an array of words.
        // Return true when one of the word in the array matching with substring
        // starting from the current index.
        // If the words array is null, also return true, assuming that there is a match.
        //
        internal bool MatchWords(String[] words) {
            if (words == null) {
                return (true);
            }

            if (Index >= len) {
                return (false);
            }
            for (int i = 0; i < words.Length; i++) {
                if (words[i].Length <= (Value.Length - Index)) {
                    if (m_info.Compare(
                        Value, Index, words[i].Length, words[i], 0, words[i].Length, CompareOptions.IgnoreCase)==0) {
                        Index += words[i].Length;
                        return (true);
                    }
                }
            }
            return (false);
        }

        //
        //  Actions: From the current position, try matching the longest word in the specified string array.
        //      E.g. words[] = {"AB", "ABC", "ABCD"}, if the current position points to a substring like "ABC DEF",
        //          MatchLongestWords(words, ref MaxMatchStrLen) will return 1 (the index), and maxMatchLen will be 3.
        //  Returns:
        //      The index that contains the longest word to match
        //  Arguments:
        //      words   The string array that contains words to search.
        //      maxMatchStrLen  [in/out] the initailized maximum length.  This parameter can be used to
        //          find the longest match in two string arrays.
        //
        internal int MatchLongestWords(String[] words, ref int maxMatchStrLen) {
            int result = -1;
            for (int i = 0; i < words.Length; i++) {
                String word = words[i];
                if (MatchSpecifiedWords(word, false)) { 
                    if (word.Length > maxMatchStrLen) {
                        maxMatchStrLen = word.Length;
                        result = i;
                    }
                }
            }
        
            return (result);
        }

        //
        // Get the number of repeat character after the current character.
        // For a string "hh:mm:ss" at Index of 3. GetRepeatCount() = 2, and Index
        // will point to the second ':'.
        //
        internal int GetRepeatCount() {
            char repeatChar = Value[Index];
            int pos = Index + 1;
            while ((pos < len) && (Value[pos] == repeatChar)) {
                pos++;
            }
            int repeatCount = (pos - Index);
            // Update the Index to the end of the repeated characters.
            // So the following GetNext() opeartion will get
            // the next character to be parsed.
            Index = pos - 1;
            return (repeatCount);
        }

        // Return false when end of string is encountered or a non-digit character is found.
        internal bool GetNextDigit() {
            if (++Index >= len) {
                return (false);
            }
            return (DateTimeParse.IsDigit(Value[Index]));
        }

        // Return null when end of string is encountered or a matching quote character is not found.
        // Throws FormatException if the matching quote character can not be found.
        internal String GetQuotedString(char quoteChar) {
            // When we enter this method, Index points to the first quote character.
            int oldPos = ++Index;
            while ((Index < len) && (Value[Index] != quoteChar)) {
                Index++;
            }
            if (Index == len) {
                // If we move past len, it means a matching quote character is not found.
                // 'ABC'    'ABC
                // 01234    0123
                return (null);
            }
            // When we leave this method, Index points to the matching quote character.
            return (Value.Substring(oldPos, Index - oldPos));
        }
        
        //
        // Get the current character.
        //
        internal char GetChar() {
            BCLDebug.Assert(Index >= 0 && Index < len, "Index >= 0 && Index < len");
            return (Value[Index]);
        }

        //
        // Convert the current character to a digit, and return it.
        //
        internal int GetDigit() {
            BCLDebug.Assert(Index >= 0 && Index < len, "Index >= 0 && Index < len");
            BCLDebug.Assert(DateTimeParse.IsDigit(Value[Index]), "IsDigit(Value[Index])");
            return (Value[Index] - '0');
        }

        //
        // Enjoy eating white spaces.
        //
        // @return false if end of string is encountered.
        //
        internal void SkipWhiteSpaces()
        {    	
            // Look ahead to see if the next character
            // is a whitespace.
            while (Index+1 < len)
            {
                char ch = Value[Index+1];
                if (!Char.IsWhiteSpace(ch)) {
                    return;
                }
                Index++;
            }
            return;
        }    

        //
        // Enjoy eating white spaces and commas.
        //
        // @return false if end of string is encountered.
        //
        internal bool SkipWhiteSpaceComma()
        {
            char ch;

            if (Index >= len) {
                return (false);
            }
            
            if (!Char.IsWhiteSpace(ch=Value[Index]) && ch!=',')
            {
                return (true);
            } 
            
            while (++Index < len)
            {
                ch = Value[Index];
                if (!Char.IsWhiteSpace(ch) && ch != ',')
                {
                    return (true);
                }
                // Nothing here.
            }
            return (false);
        }

        internal void TrimTail() {
            int i = len - 1;
            while (i >= 0 && Char.IsWhiteSpace(Value[i])) {
                i--;
            }
            Value = Value.Substring(0, i + 1);
            len = Value.Length;
        }

        // Trim the trailing spaces within a quoted string.
        // Call this after TrimTail() is done.
        internal void RemoveTrailingInQuoteSpaces() {
            int i = len - 1;
            if (i <= 1) {
                return;
            }
            char ch = Value[i];
            // Check if the last character is a quote.
            if (ch == '\'' || ch == '\"') {
                if (Char.IsWhiteSpace(Value[i-1])) {
                    i--;
                    while (i >= 1 && Char.IsWhiteSpace(Value[i-1])) {
                        i--;
                    }
                    Value = Value.Remove(i, Value.Length - 1 - i);
                    len = Value.Length;
                }
            }
        }

        // Trim the leading spaces within a quoted string.
        // Call this after the leading spaces before quoted string are trimmed.
        internal void RemoveLeadingInQuoteSpaces() {
            if (len <= 2) {
                return;
            }
            int i = 0;
            char ch = Value[i];
            // Check if the last character is a quote.
            if (ch == '\'' || ch == '\"') {
                while ((i + 1) < len && Char.IsWhiteSpace(Value[i+1])) {
                    i++;
                }
                if (i != 0) {
                    Value = Value.Remove(1, i);
                    len = Value.Length;
                }
            }
        }
        
    }

    //
    // The buffer to store the parsing token.
    //
    [Serializable()]
    internal 
    class DateTimeToken {
        internal int dtt;    // Store the token
        internal int suffix; // Store the CJK Year/Month/Day suffix (if any)
        internal int num;    // Store the number that we are parsing (if any)
    }

    //
    // The buffer to store temporary parsing information.
    //
    [Serializable()]
    internal 
    class DateTimeRawInfo {
        internal int[] num;
        internal int numCount   = 0;
        internal int month      = -1;
        internal int year       = -1;
        internal int dayOfWeek  = -1;
        internal int era        = -1;
        internal int timeMark   = -1;  // Value could be -1, TM_AM or TM_PM.
        internal double fraction = -1;
        //
        // TODO yslin: when we support more timezone names, change this to be
        // type of TimeZone.
        //
        internal bool timeZone = false;


        internal DateTimeRawInfo()
        {
            num = new int[] {-1, -1, -1};
        }
    }

    //
    // This will store the result of the parsing.  And it will be eventually
    // used to construct a DateTime instance.
    //
    [Serializable()]
    internal 
    class DateTimeResult
    {
        internal int Year    = -1;
        internal int Month   = -1;
        internal int Day     = -1;
        //
        // Set time defualt to 00:00:00.
        //
        internal int Hour    = 0;
        internal int Minute  = 0;
        internal int Second = 0;
        internal double fraction = -1;
        
        internal int era = -1;

        internal bool timeZoneUsed = false;
        internal TimeSpan timeZoneOffset;

        internal Calendar calendar;

        internal DateTimeResult()
        {
        }

        internal virtual void SetDate(int year, int month, int day)
        {
            Year = year;
            Month = month;
            Day = day;
        }
    }

    [Serializable]
    internal class ParsingInfo {
        internal Calendar calendar;
        internal int dayOfWeek = -1;
        internal int timeMark = -1;
        internal TimeSpan timeZoneOffset = new TimeSpan();

        internal bool fUseUniversalTime = false;
        internal bool fUseHour12 = false;
        internal bool fUseTwoDigitYear = false;
        internal bool fUseTimeZone = false;
        internal bool fAllowInnerWhite = false;        
        internal bool fAllowTrailingWhite = false;

        internal ParsingInfo() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\hebrewcalendar.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
    using System;
    using System.Text;

    ////////////////////////////////////////////////////////////////////////////
    //
    //  Notes about HebrewCalendar (The conversion from Gregorian to Hebrew is 
    //  stolen from DateTime.c in NLS)
    //
    //  Rules for the Hebrew calendar:
    //    - The Hebrew calendar is both a Lunar (months) and Solar (years)
    //        calendar, but allows for a week of seven days.
    //    - Days begin at sunset.
    //    - Leap Years occur in the 3, 6, 8, 11, 14, 17, & 19th years of a
    //        19-year cycle.  Year = leap iff ((7y+1) mod 19 < 7).
    //    - There are 12 months in a common year and 13 months in a leap year.
    //    - In a common year, the 6th month, Adar, has 29 days.  In a leap
    //        year, the 6th month, Adar I, has 30 days and the leap month,
    //        Adar II, has 29 days.
    //    - Common years have 353-355 days.  Leap years have 383-385 days.
    //    - The Hebrew new year (Rosh HaShanah) begins on the 1st of Tishri,
    //        the 7th month in the list below.
    //        - The new year may not begin on Sunday, Wednesday, or Friday.
    //        - If the new year would fall on a Tuesday and the conjunction of
    //            the following year were at midday or later, the new year is
    //            delayed until Thursday.
    //        - If the new year would fall on a Monday after a leap year, the
    //            new year is delayed until Tuesday.
    //    - The length of the 8th and 9th months vary from year to year,
    //        depending on the overall length of the year.
    //        - The length of a year is determined by the dates of the new
    //            years (Tishri 1) preceding and following the year in question.
    //        - The 2th month is long (30 days) if the year has 355 or 385 days.
    //        - The 3th month is short (29 days) if the year has 353 or 383 days.
    //    - The Hebrew months are:
    //        1.  Tishri        (30 days)            
    //        2.  Heshvan       (29 or 30 days)      
    //        3.  Kislev        (29 or 30 days)      
    //        4.  Teveth        (29 days)            
    //        5.  Shevat        (30 days)            
    //        6.  Adar I        (30 days)            
    //        7.  Adar {II}     (29 days, this only exists if that year is a leap year)
    //        8.  Nisan         (30 days)  
    //        9.  Iyyar         (29 days)  
    //        10. Sivan         (30 days)  
    //        11. Tammuz        (29 days)  
    //        12. Av            (30 days)      
    //        13. Elul          (29 days)
    //  NOTENOTE YSLin:
    //      04-28-2000  I removed the code porting from intldate.cpp.  These
    //                  code are not in use anymore, so they are bogus.
    ////////////////////////////////////////////////////////////////////////////
     /*
     **  Calendar support range:
     **      Calendar    Minimum     Maximum
     **      ==========  ==========  ==========
     **      Gregorian   1600/??/??  2239/??/??
     **      Hebrew      5343/??/??  6000/??/??
     */

// Includes CHebrew implemetation;i.e All the code necessary for converting 
// Gregorian to Hebrew Lunar from 1600 to 2239.
// Code is ported and modified from intldate project (intldate.c)

    /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar"]/*' />
    [Serializable]
    public class HebrewCalendar : Calendar {

        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.HebrewEra"]/*' />
        public static readonly int HebrewEra = 1;
        
        internal const int DatePartYear = 0;
        internal const int DatePartDayOfYear = 1;
        internal const int DatePartMonth = 2;
        internal const int DatePartDay = 3;
        internal const int DatePartDayOfWeek = 4;

        // The number of days for Gregorian 1600/1/1 since 0001/1/1 A.D.  This equals to GregorianCalendar.GetAbsoluteDate(1600, 1, 1).
        internal const long Absolute1600 = (365 * 1600L) + (1600/4) - (1600/100) + (1600/400);

        // @TODO YSLin: Consider moving this table to the native side.
        //
        //  Hebrew Translation Table.
        //
        //  This table is used to get the following Hebrew calendar information for a
        //  given Gregorian year:
        //      1. The day of the Hebrew month corresponding to Gregorian January 1st 
        //         for a given Gregorian year.
        //      2. The month of the Hebrew month corresponding to Gregorian January 1st 
        //         for a given Gregorian year.
        //         The information is not directly in the table.  Instead, the info is decoded 
        //          by special values (numbers above 29 and below 1).
        //      3. The type of the Hebrew year for a given Gregorian year.
        //
        
        /*
            More notes:
            
            This table includes 2 numbers for each year.
            The offset into the table determines the year. (offset 0 is Gregorian year 1500)
            1st number determines the day of the Hebrew month coresponeds to January 1st.
            2nd number determines the type of the Hebrew year. (the type determines how
             many days are there in the year.)

             normal years : 1 = 353 days   2 = 354 days   3 = 355 days.
             Leap years   : 4 = 383        5   384        6 = 385 days.

             A 99 means the year is not supported for translation.
             for convenience the table was defined for 750 year,
             but only 640 years are supported. (from 1600 to 2239)
             the years before 1582 (starting of Georgian calander)
             and after 2239, are filled with 99.

             Greogrian January 1st falls usually in Tevet (4th month). Tevet has always 29 days.
             That's why, there no nead to specify the lunar month in the table.
             There are exceptions, these are coded by giving numbers above 29 and below 1.
             Actual decoding is takenig place whenever fetching information from the table.
             The function for decoding is in GetLunarMonthDay().

             Example:
                The data for 2000 - 2005 A.D. is:
                
                    23,6,6,1,17,2,27,6,7,3,         // 2000 - 2004                

                For year 2000, we know it has a Hebrew year type 6, which means it has 385 days.
                And 1/1/2000 A.D. is Hebrew year 5760, 23rd day of 4th month.
        */
     
        //
        //  Jewish Era in use today is dated from the supposed year of the
        //  Creation with its beginning in 3761 B.C.
        //
                
        // The Hebrew year of Gregorian 1st year AD.
        // 0001/01/01 AD is Hebrew 3760/01/01
        private const int HebrewYearOf1AD = 3760;

        // The first Gregorian year in m_HebrewTable.
        private const int FirstGregorianTableYear = 1583;   // == Hebrew Year 5343
        // The last Gregorian year in m_HebrewTable.
        private const int LastGregorianTableYear = 2240;    // == Hebrew Year 6000
        private const int TABLESIZE = (LastGregorianTableYear-FirstGregorianTableYear);

        private const int m_minHebrewYear = HebrewYearOf1AD + FirstGregorianTableYear;   // == 5343
        private const int m_maxHebrewYear = HebrewYearOf1AD + LastGregorianTableYear;    // == 6000
        
        private static readonly int[] m_HebrewTable = {
            7,3,17,3,         // 1583-1584  (Hebrew year: 5343 - 5344)
            0,4,11,2,21,6,1,3,13,2,             // 1585-1589
            25,4,5,3,16,2,27,6,9,1,             // 1590-1594
            20,2,0,6,11,3,23,4,4,2,             // 1595-1599
            14,3,27,4,8,2,18,3,28,6,            // 1600
            11,1,22,5,2,3,12,3,25,4,      // 1605
            6,2,16,3,26,6,8,2,20,1,      // 1610
            0,6,11,2,24,4,4,3,15,2,      // 1615
            25,6,8,1,19,2,29,6,9,3,      // 1620
            22,4,3,2,13,3,25,4,6,3,      // 1625
            17,2,27,6,7,3,19,2,31,4,      // 1630
            11,3,23,4,5,2,15,3,25,6,      // 1635
            6,2,19,1,29,6,10,2,22,4,      // 1640
            3,3,14,2,24,6,6,1,17,3,      // 1645
            28,5,8,3,20,1,32,5,12,3,      // 1650
            22,6,4,1,16,2,26,6,6,3,      // 1655
            17,2,0,4,10,3,22,4,3,2,      // 1660
            14,3,24,6,5,2,17,1,28,6,      // 1665
            9,2,19,3,31,4,13,2,23,6,      // 1670
            3,3,15,1,27,5,7,3,17,3,      // 1675
            29,4,11,2,21,6,3,1,14,2,      // 1680
            25,6,5,3,16,2,28,4,9,3,      // 1685
            20,2,0,6,12,1,23,6,4,2,      // 1690
            14,3,26,4,8,2,18,3,0,4,      // 1695
            10,3,21,5,1,3,13,1,24,5,      // 1700
            5,3,15,3,27,4,8,2,19,3,      // 1705
            29,6,10,2,22,4,3,3,14,2,      // 1710
            26,4,6,3,18,2,28,6,10,1,      // 1715
            20,6,2,2,12,3,24,4,5,2,      // 1720
            16,3,28,4,8,3,19,2,0,6,      // 1725
            12,1,23,5,3,3,14,3,26,4,      // 1730
            7,2,17,3,28,6,9,2,21,4,      // 1735
            1,3,13,2,25,4,5,3,16,2,      // 1740
            27,6,9,1,19,3,0,5,11,3,      // 1745
            23,4,4,2,14,3,25,6,7,1,      // 1750
            18,2,28,6,9,3,21,4,2,2,      // 1755
            12,3,25,4,6,2,16,3,26,6,      // 1760
            8,2,20,1,0,6,11,2,22,6,      // 1765
            4,1,15,2,25,6,6,3,18,1,      // 1770
            29,5,9,3,22,4,2,3,13,2,      // 1775
            23,6,4,3,15,2,27,4,7,3,      // 1780
            19,2,31,4,11,3,21,6,3,2,      // 1785
            15,1,25,6,6,2,17,3,29,4,      // 1790
            10,2,20,6,3,1,13,3,24,5,      // 1795
            4,3,16,1,27,5,7,3,17,3,      // 1800
            0,4,11,2,21,6,1,3,13,2,      // 1805
            25,4,5,3,16,2,29,4,9,3,      // 1810
            19,6,30,2,13,1,23,6,4,2,      // 1815
            14,3,27,4,8,2,18,3,0,4,      // 1820
            11,3,22,5,2,3,14,1,26,5,      // 1825
            6,3,16,3,28,4,10,2,20,6,      // 1830
            30,3,11,2,24,4,4,3,15,2,      // 1835
            25,6,8,1,19,2,29,6,9,3,      // 1840
            22,4,3,2,13,3,25,4,7,2,      // 1845
            17,3,27,6,9,1,21,5,1,3,      // 1850
            11,3,23,4,5,2,15,3,25,6,      // 1855
            6,2,19,1,29,6,10,2,22,4,      // 1860
            3,3,14,2,24,6,6,1,18,2,      // 1865
            28,6,8,3,20,4,2,2,12,3,      // 1870
            24,4,4,3,16,2,26,6,6,3,      // 1875
            17,2,0,4,10,3,22,4,3,2,      // 1880
            14,3,24,6,5,2,17,1,28,6,      // 1885
            9,2,21,4,1,3,13,2,23,6,      // 1890
            5,1,15,3,27,5,7,3,19,1,      // 1895
            0,5,10,3,22,4,2,3,13,2,      // 1900
            24,6,4,3,15,2,27,4,8,3,      // 1905
            20,4,1,2,11,3,22,6,3,2,      // 1910
            15,1,25,6,7,2,17,3,29,4,      // 1915
            10,2,21,6,1,3,13,1,24,5,      // 1920
            5,3,15,3,27,4,8,2,19,6,      // 1925
            1,1,12,2,22,6,3,3,14,2,      // 1930
            26,4,6,3,18,2,28,6,10,1,      // 1935
            20,6,2,2,12,3,24,4,5,2,      // 1940
            16,3,28,4,9,2,19,6,30,3,      // 1945
            12,1,23,5,3,3,14,3,26,4,      // 1950
            7,2,17,3,28,6,9,2,21,4,      // 1955
            1,3,13,2,25,4,5,3,16,2,      // 1960
            27,6,9,1,19,6,30,2,11,3,      // 1965
            23,4,4,2,14,3,27,4,7,3,      // 1970
            18,2,28,6,11,1,22,5,2,3,      // 1975
            12,3,25,4,6,2,16,3,26,6,      // 1980
            8,2,20,4,30,3,11,2,24,4,      // 1985
            4,3,15,2,25,6,8,1,18,3,      // 1990
            29,5,9,3,22,4,3,2,13,3,      // 1995
            23,6,6,1,17,2,27,6,7,3,         // 2000 - 2004
            20,4,1,2,11,3,23,4,5,2,         // 2005 - 2009
            15,3,25,6,6,2,19,1,29,6,        // 2010
            10,2,20,6,3,1,14,2,24,6,      // 2015
            4,3,17,1,28,5,8,3,20,4,      // 2020
            1,3,12,2,22,6,2,3,14,2,      // 2025
            26,4,6,3,17,2,0,4,10,3,      // 2030
            20,6,1,2,14,1,24,6,5,2,      // 2035
            15,3,28,4,9,2,19,6,1,1,      // 2040
            12,3,23,5,3,3,15,1,27,5,      // 2045
            7,3,17,3,29,4,11,2,21,6,      // 2050
            1,3,12,2,25,4,5,3,16,2,      // 2055
            28,4,9,3,19,6,30,2,12,1,      // 2060
            23,6,4,2,14,3,26,4,8,2,      // 2065
            18,3,0,4,10,3,22,5,2,3,      // 2070
            14,1,25,5,6,3,16,3,28,4,      // 2075
            9,2,20,6,30,3,11,2,23,4,      // 2080
            4,3,15,2,27,4,7,3,19,2,      // 2085
            29,6,11,1,21,6,3,2,13,3,      // 2090
            25,4,6,2,17,3,27,6,9,1,      // 2095
            20,5,30,3,10,3,22,4,3,2,      // 2100
            14,3,24,6,5,2,17,1,28,6,      // 2105
            9,2,21,4,1,3,13,2,23,6,      // 2110
            5,1,16,2,27,6,7,3,19,4,      // 2115
            30,2,11,3,23,4,3,3,14,2,      // 2120
            25,6,5,3,16,2,28,4,9,3,      // 2125
            21,4,2,2,12,3,23,6,4,2,      // 2130
            16,1,26,6,8,2,20,4,30,3,      // 2135
            11,2,22,6,4,1,14,3,25,5,      // 2140
            6,3,18,1,29,5,9,3,22,4,      // 2145
            2,3,13,2,23,6,4,3,15,2,      // 2150
            27,4,7,3,20,4,1,2,11,3,      // 2155
            21,6,3,2,15,1,25,6,6,2,      // 2160
            17,3,29,4,10,2,20,6,3,1,      // 2165
            13,3,24,5,4,3,17,1,28,5,      // 2170
            8,3,18,6,1,1,12,2,22,6,      // 2175
            2,3,14,2,26,4,6,3,17,2,      // 2180
            28,6,10,1,20,6,1,2,12,3,    // 2185
            24,4,5,2,15,3,28,4,9,2,     // 2190
            19,6,33,3,12,1,23,5,3,3,    // 2195
            13,3,25,4,6,2,16,3,26,6,    // 2200
            8,2,20,4,30,3,11,2,24,4,    // 2205
            4,3,15,2,25,6,8,1,18,6,     // 2210
            33,2,9,3,22,4,3,2,13,3,     // 2215
            25,4,6,3,17,2,27,6,9,1,     // 2220
            21,5,1,3,11,3,23,4,5,2,     // 2225
            15,3,25,6,6,2,19,4,33,3,    // 2230
            10,2,22,4,3,3,14,2,24,6,    // 2235            
            6,1    // 2240 (Hebrew year: 6000)
        };

        //
        //  The lunar calendar has 6 different variations of month lengths
        //  within a year.
        //
        private static readonly int[,] m_lunarMonthLen = {
            {0,00,00,00,00,00,00,00,00,00,00,00,00,0},
            {0,30,29,29,29,30,29,30,29,30,29,30,29,0},     // 3 common year variations
            {0,30,29,30,29,30,29,30,29,30,29,30,29,0},
            {0,30,30,30,29,30,29,30,29,30,29,30,29,0},
            {0,30,29,29,29,30,30,29,30,29,30,29,30,29},    // 3 leap year variations
            {0,30,29,30,29,30,30,29,30,29,30,29,30,29},
            {0,30,30,30,29,30,30,29,30,29,30,29,30,29}
        };

        internal static Calendar m_defaultInstance = null;

        /*=================================GetDefaultInstance==========================
        **Action: Internal method to provide a default intance of HebrewCalendar.  Used by NLS+ implementation
        **       and other calendars.
        **Returns:
        **Arguments:
        **Exceptions:
        ============================================================================*/

        internal static Calendar GetDefaultInstance() {
            if (m_defaultInstance == null) {
                m_defaultInstance = new HebrewCalendar();
            }
            return (m_defaultInstance);
        }


        // Construct an instance of gregorian calendar.
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.HebrewCalendar"]/*' />
        public HebrewCalendar() {
        }

        internal override int ID {
            get {
                return (CAL_HEBREW);
            }
        }

        
        /*=================================CheckHebrewYearValue==========================
        **Action: Check if the Hebrew year value is supported in this class.
        **Returns:  None.
        **Arguments: y  Hebrew year value
        **          ear Hebrew era value
        **Exceptions: ArgumentOutOfRange_Range if the year value is not supported.
        **Note:
        **  We use a table for the Hebrew calendar calculation, so the year supported is limited.
        ============================================================================*/

        private void CheckHebrewYearValue(int y, int era, String varName) {
            if (era == Calendar.CurrentEra || era == HebrewEra) {
                if (y > m_maxHebrewYear || y < m_minHebrewYear) {
                    throw new ArgumentOutOfRangeException(
                        varName, String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                        m_minHebrewYear, m_maxHebrewYear));
                }        
            } else {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidEraValue"), "era");
            }
        }

        /*=================================CheckHebrewMonthValue==========================
        **Action: Check if the Hebrew month value is valid.
        **Returns:  None.
        **Arguments: year  Hebrew year value
        **          month Hebrew month value
        **Exceptions: ArgumentOutOfRange_Range if the month value is not valid.
        **Note:
        **  Call CheckHebrewYearValue() before calling this to verify the year value is supported.
        ============================================================================*/

        private void CheckHebrewMonthValue(int year, int month, int era) {
            int monthsInYear = GetMonthsInYear(year, era);
            if (month < 1 || month > monthsInYear) {
                throw new ArgumentOutOfRangeException(
                    "month", 
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    1, monthsInYear));
            }
        }
        
        /*=================================CheckHebrewDayValue==========================
        **Action: Check if the Hebrew day value is valid.
        **Returns:  None.
        **Arguments: year  Hebrew year value
        **          month Hebrew month value
        **          day     Hebrew day value.
        **Exceptions: ArgumentOutOfRange_Range if the day value is not valid.
        **Note:
        **  Call CheckHebrewYearValue()/CheckHebrewMonthValue() before calling this to verify the year/month values are valid.
        ============================================================================*/

        private void CheckHebrewDayValue(int year, int month, int day, int era) {
            int daysInMonth = GetDaysInMonth(year, month, era);
            if (day < 1 || day > daysInMonth) {
                throw new ArgumentOutOfRangeException(
                    "day", 
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    1, daysInMonth));
            }
        }
        
        ////////////////////////////////////////////////////////////////////////////
        //
        //  IsValidGregorianDateForHebrew
        //
        //  Checks to be sure the given Gregorian date is valid.  This validation
        //  requires that the year be between 1600 and 2239.  If it is, it
        //  returns TRUE.  Otherwise, it returns false.
        //
        //  Param: Year/Month/Day  The date in Gregorian calendar.
        //
        //  12-04-96    JulieB    Created.
        ////////////////////////////////////////////////////////////////////////////

        bool IsValidGregorianDateForHebrew(int Year, int Month, int Day) {
            //
            //  Make sure the Year is between 1600 and 2239.
            //
            //  The limitation is because that we only carry m_Hebrew table in
            //  this range.
            if ((Year < 1600) || (Year > 2239)) {
                return (false);
            }

            //
            //  Make sure the Month is between 1 and 12.
            //
            if ((Month < 1) || (Month > 12)) {
                return (false);
            }

            //
            //  Make sure the Day is within the correct range for the given Month.
            //
            if ((Day < 1) || (Day > GregorianCalendar.GetDefaultInstance().GetDaysInYear(Year, CurrentEra))) {
                return (false);
            }
            //
            //  Return success.
            //
            return (true);
            
        }

        internal int GetResult(__DateBuffer result, int part) {
            switch (part) {
                case DatePartYear:
                    return (result.year);
                case DatePartMonth:
                    return (result.month);
                case DatePartDay:
                    return (result.day);
            }
            
            throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_DateTimeParsing"));
        }

        /*=================================GetLunarMonthDay==========================
        **Action: Using the Hebrew table (m_HebrewTable) to get the Hebrew month/day value for Gregorian January 1st 
        ** in a given Gregorian year. 
        ** Greogrian January 1st falls usually in Tevet (4th month). Tevet has always 29 days.
        **     That's why, there no nead to specify the lunar month in the table.  There are exceptions, and these 
        **     are coded by giving numbers above 29 and below 1.
        **     Actual decoding is takenig place in the switch statement below.
        **Returns:
        **     The Hebrew year type. The value is from 1 to 6.
        **     normal years : 1 = 353 days   2 = 354 days   3 = 355 days.
        **     Leap years   : 4 = 383        5   384        6 = 385 days.        
        **Arguments:
        **      gregorianYear   The year value in Gregorian calendar.  The value should be between 1500 and 2239.
        **      lunarDate       Object to take the result of the Hebrew year/month/day.
        **Exceptions:
        ============================================================================*/

        internal int GetLunarMonthDay(int gregorianYear, __DateBuffer lunarDate) {
            //
            //  Get the offset into the m_lunarMonthLen array and the lunar day
            //  for January 1st.
            //
            int index = gregorianYear - FirstGregorianTableYear;
            if (index < 0 || index > TABLESIZE) {
                throw new ArgumentOutOfRangeException("gregorianYear");
            }

            index *= 2;
            lunarDate.day      = m_HebrewTable[index];

            // Get the type of the year. The value is from 1 to 6
            int LunarYearType = m_HebrewTable[index + 1];

            //
            //  Get the Lunar Month.
            //
            switch (lunarDate.day) {
                case ( 0 ) :                   // 1/1 is on Shvat 1
                    lunarDate.month = 5;
                    lunarDate.day = 1;
                    break;
                case ( 30 ) :                  // 1/1 is on Kislev 30
                    lunarDate.month = 3;
                    break;
                case ( 31 ) :                  // 1/1 is on Shvat 2
                    lunarDate.month = 5;
                    lunarDate.day = 2;
                    break;
                case ( 32 ) :                  // 1/1 is on Shvat 3
                    lunarDate.month = 5;
                    lunarDate.day = 3;
                    break;
                case ( 33 ) :                  // 1/1 is on Kislev 29
                    lunarDate.month = 3;
                    lunarDate.day = 29;
                    break;
                default :                      // 1/1 is on Tevet (This is the general case)
                    lunarDate.month = 4;
                    break;
            }
            return (LunarYearType);
        }

        // Returns a given date part of this DateTime. This method is used
        // to compute the year, day-of-year, month, or day part.
         
        //  NOTE YSLin:
        //      The calculation of Hebrew calendar is based on absoulte date in Gregorian calendar.
         
        internal virtual int GetDatePart(long ticks, int part) {
            // The Gregorian year, month, day value for ticks.
            int gregorianYear, gregorianMonth, gregorianDay;             
            int hebrewYearType;                // lunar year type
            long AbsoluteDate;                // absolute date - absolute date 1/1/1600
            
            DateTime time = new DateTime(ticks);

            //
            //  Save the Gregorian date values.
            //
            gregorianYear = time.Year;
            gregorianMonth = time.Month;
            gregorianDay = time.Day;

            //
            //  Make sure we have a valid Gregorian date that will fit into our
            //  Hebrew conversion limits.
            //
            if (!IsValidGregorianDateForHebrew(gregorianYear, gregorianMonth, gregorianDay)) {
                throw new ArgumentException(
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_CalendarRange"), 
                                  FirstGregorianTableYear, 
                                  LastGregorianTableYear));
            }

            __DateBuffer lunarDate = new __DateBuffer();    // lunar month and day for Jan 1

            // From the table looking-up value of m_HebrewTable[index] (stored in lunarDate.day), we get the the
            // lunar month and lunar day where the Gregorian date 1/1 falls.
            lunarDate.year = gregorianYear + HebrewYearOf1AD;
            hebrewYearType = GetLunarMonthDay(gregorianYear, lunarDate);

            // This is the buffer used to store the result Hebrew date.
            __DateBuffer result = new __DateBuffer();
            
            //
            //  Store the values for the start of the new year - 1/1.
            //
            result.year  = lunarDate.year;
            result.month = lunarDate.month;
            result.day   = lunarDate.day;

            //
            //  Get the absolute date from 1/1/1600.
            //            
            AbsoluteDate = GregorianCalendar.GetAbsoluteDate(gregorianYear, gregorianMonth, gregorianDay);

            //
            //  If the requested date was 1/1, then we're done.
            //
            if ((gregorianMonth == 1) && (gregorianDay == 1)) {
                return (GetResult(result, part));
            }

            //
            //  Calculate the number of days between 1/1 and the requested date.
            //
            long NumDays;                      // number of days since 1/1
            NumDays = AbsoluteDate - GregorianCalendar.GetAbsoluteDate(gregorianYear, 1, 1);

            //
            //  If the requested date is within the current lunar month, then
            //  we're done.
            //
            if ((NumDays + (long)lunarDate.day) <= (long)(m_lunarMonthLen[hebrewYearType, lunarDate.month])) {
                result.day += (int)NumDays;
                return (GetResult(result, part));
            }

            //
            //  Adjust for the current partial month.
            //
            result.month++;
            result.day = 1;

            //
            //  Adjust the Lunar Month and Year (if necessary) based on the number
            //  of days between 1/1 and the requested date.
            //
            //  Assumes Jan 1 can never translate to the last Lunar month, which
            //  is true.
            //
            NumDays -= (long)(m_lunarMonthLen[hebrewYearType, lunarDate.month] - lunarDate.day);
            BCLDebug.Assert(NumDays >= 1, "NumDays >= 1");

            // If NumDays is 1, then we are done.  Otherwise, find the correct Hebrew month
            // and day.
            if (NumDays > 1) {
                //
                //  See if we're on the correct Lunar month.
                //
                while (NumDays > (long)(m_lunarMonthLen[hebrewYearType, result.month])) {
                    //
                    //  Adjust the number of days and move to the next month.
                    //
                    NumDays -= (long)(m_lunarMonthLen[hebrewYearType, result.month++]);

                    //
                    //  See if we need to adjust the Year.
                    //  Must handle both 12 and 13 month years.
                    //
                    if ((result.month > 13) || (m_lunarMonthLen[hebrewYearType, result.month] == 0)) {
                        //
                        //  Adjust the Year.
                        //
                        result.year++;
                        hebrewYearType = m_HebrewTable[(gregorianYear + 1 - FirstGregorianTableYear) * 2 + 1];

                        //
                        //  Adjust the Month.
                        //
                        result.month = 1;
                    }
                }
                //
                //  Found the right Lunar month.
                //
                result.day += (int)(NumDays - 1);
            }                
            return (GetResult(result, part));
        }

        // Returns the DateTime resulting from adding the given number of
        // months to the specified DateTime. The result is computed by incrementing
        // (or decrementing) the year and month parts of the specified DateTime by
        // value months, and, if required, adjusting the day part of the
        // resulting date downwards to the last day of the resulting month in the
        // resulting year. The time-of-day part of the result is the same as the
        // time-of-day part of the specified DateTime.
        //
        // In more precise terms, considering the specified DateTime to be of the
        // form y / m / d + t, where y is the
        // year, m is the month, d is the day, and t is the
        // time-of-day, the result is y1 / m1 / d1 + t,
        // where y1 and m1 are computed by adding value months
        // to y and m, and d1 is the largest value less than
        // or equal to d that denotes a valid day in month m1 of year
        // y1.
        //
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.AddMonths"]/*' />
        public override DateTime AddMonths(DateTime time, int months) {
            try {
                int y = GetDatePart(time.Ticks, DatePartYear);
                int m = GetDatePart(time.Ticks, DatePartMonth);
                int d = GetDatePart(time.Ticks, DatePartDay);


                int monthsInYear;
                int i;
                if (months >= 0) {
                    i = m + months;
                    while (i > (monthsInYear = GetMonthsInYear(y, CurrentEra))) {
                        y++;
                        i -= monthsInYear;
                    }
                } else {
                    if ((i = m + months) <= 0) {
                        months = -months;
                        months -= m;
                        y--;
                        
                        while (months > (monthsInYear = GetMonthsInYear(y, CurrentEra))) {
                            y--;
                            months -= monthsInYear;
                        }
                        monthsInYear = GetMonthsInYear(y, CurrentEra);
                        i = monthsInYear - months;
                    }                 
                }

                int days = GetDaysInMonth(y, i);
                if (d > days) {
                    d = days;
                }
                return (new DateTime(ToDateTime(y, i, d, 0, 0, 0, 0).Ticks + (time.Ticks % TicksPerDay)));
            } catch (Exception) {
                // If exception is throw in the calls above, we are out of the supported range of this calendar.
                throw new ArgumentOutOfRangeException(
                    "months", String.Format(Environment.GetResourceString("ArgumentOutOfRange_AddValue")));
            }
        }

        // Returns the DateTime resulting from adding the given number of
        // years to the specified DateTime. The result is computed by incrementing
        // (or decrementing) the year part of the specified DateTime by value
        // years. If the month and day of the specified DateTime is 2/29, and if the
        // resulting year is not a leap year, the month and day of the resulting
        // DateTime becomes 2/28. Otherwise, the month, day, and time-of-day
        // parts of the result are the same as those of the specified DateTime.
        //
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.AddYears"]/*' />
        public override DateTime AddYears(DateTime time, int years) {
            int y = GetDatePart(time.Ticks, DatePartYear);
            int m = GetDatePart(time.Ticks, DatePartMonth);
            int d = GetDatePart(time.Ticks, DatePartDay);

            y += years;
            CheckHebrewYearValue(y, Calendar.CurrentEra, "years");
            
            int months = GetMonthsInYear(y, CurrentEra);
            if (m > months) {
                m = months;
            }
            
            int days = GetDaysInMonth(y, m);
            if (d > days) {
                d = days;
            }

            return (new DateTime(ToDateTime(y, m, d, 0, 0, 0, 0).Ticks + (time.Ticks % TicksPerDay)));
        }

        // Returns the day-of-month part of the specified DateTime. The returned
        // value is an integer between 1 and 31.
        //
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.GetDayOfMonth"]/*' />
        public override int GetDayOfMonth(DateTime time) {
            return (GetDatePart(time.Ticks, DatePartDay));
        }

        // Returns the day-of-week part of the specified DateTime. The returned value
        // is an integer between 0 and 6, where 0 indicates Sunday, 1 indicates
        // Monday, 2 indicates Tuesday, 3 indicates Wednesday, 4 indicates
        // Thursday, 5 indicates Friday, and 6 indicates Saturday.
        //
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.GetDayOfWeek"]/*' />
        public override DayOfWeek GetDayOfWeek(DateTime time) {
            // If we calculate back, the Hebrew day of week for Gregorian 0001/1/1 is Monday (1).
            // Therfore, the fomula is:
            return ((DayOfWeek)((int)(time.Ticks / TicksPerDay + 1) % 7));
        }

        internal int GetHebrewYearType(int year, int era) {
            CheckHebrewYearValue(year, era, "year");
            if (era == CurrentEra || era == HebrewEra) {
                // The m_HebrewTable is indexed by Gregorian year and starts from FirstGregorianYear.
                // So we need to convert year (Hebrew year value) to Gregorian Year below.
                return (m_HebrewTable[(year - HebrewYearOf1AD - FirstGregorianTableYear) * 2 + 1]);
            }
            throw new ArgumentException(Environment.GetResourceString("Argument_InvalidEraValue"));
        }

        // Returns the day-of-year part of the specified DateTime. The returned value
        // is an integer between 1 and 366.
        //
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.GetDayOfYear"]/*' />
        public override int GetDayOfYear(DateTime time) {
            // Get Hebrew year value of the specified time.
            int year = GetYear(time);
            DateTime beginOfYearDate = ToDateTime(year, 1, 1, 0, 0, 0, 0, CurrentEra);
            return ((int)((time.Ticks - beginOfYearDate.Ticks) / TicksPerDay) + 1);
        }

        // Returns the number of days in the month given by the year and
        // month arguments.
        //
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.GetDaysInMonth"]/*' />
        public override int GetDaysInMonth(int year, int month, int era) {
            if (era == CurrentEra || era == HebrewEra) {                
                int hebrewYearType = GetHebrewYearType(year, era);
                CheckHebrewMonthValue(year, month, era);

                BCLDebug.Assert(hebrewYearType>= 1 && hebrewYearType <= 6, 
                    "hebrewYearType should be from  1 to 6, but now hebrewYearType = " + hebrewYearType + " for hebrew year " + year);
                int monthDays = m_lunarMonthLen[hebrewYearType, month];
                if (monthDays == 0) {
                    throw new ArgumentOutOfRangeException("month", Environment.GetResourceString("ArgumentOutOfRange_Month"));
                }
                return (monthDays);
            }
            throw new ArgumentException(Environment.GetResourceString("Argument_InvalidEraValue"));
        }
        
        // Returns the number of days in the year given by the year argument for the current era.
        //
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.GetDaysInYear"]/*' />
        public override int GetDaysInYear(int year, int era) {
            if (era == CurrentEra || era == HebrewEra) {
                // normal years : 1 = 353 days   2 = 354 days   3 = 355 days.
                // Leap years   : 4 = 383        5   384        6 = 385 days.
                
                // LunarYearType is from 1 to 6
                int LunarYearType = GetHebrewYearType(year, era);
                if (LunarYearType < 4) {
                    // common year: LunarYearType = 1, 2, 3
                    return (352 + LunarYearType);
                }
                return (382 + (LunarYearType - 3));
            }
            throw new ArgumentException(Environment.GetResourceString("Argument_InvalidEraValue"));
        }

        // Returns the era for the specified DateTime value.
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.GetEra"]/*' />
        public override int GetEra(DateTime time) {
            
            return (HebrewEra);
        }

        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.Eras"]/*' />
        public override int[] Eras {
            get {
                return (new int[] {HebrewEra});
            }
        }

        // Returns the month part of the specified DateTime. The returned value is an
        // integer between 1 and 12.
        //
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.GetMonth"]/*' />
        public override int GetMonth(DateTime time) {
            return (GetDatePart(time.Ticks, DatePartMonth));
        }

        // Returns the number of months in the specified year and era.
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.GetMonthsInYear"]/*' />
        public override int GetMonthsInYear(int year, int era) {
            return (IsLeapYear(year, era) ? 13 : 12);
        }

        // Returns the year part of the specified DateTime. The returned value is an
        // integer between 1 and 9999.
        //
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.GetYear"]/*' />
        public override int GetYear(DateTime time) {
            return (GetDatePart(time.Ticks, DatePartYear));
        }

        // Checks whether a given day in the specified era is a leap day. This method returns true if
        // the date is a leap day, or false if not.
        //
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.IsLeapDay"]/*' />
        public override bool IsLeapDay(int year, int month, int day, int era) {            
            if (IsLeapMonth(year, month, era)) {
                // Every day in a leap month is a leap day.
                CheckHebrewDayValue(year, month, day, era);
                return (true);
            } else if (IsLeapYear(year, Calendar.CurrentEra)) {
                // There is an additional day in the 6th month in the leap year (the extra day is the 30th day in the 6th month),
                // so we should return true for 6/30 if that's in a leap year.
                if (month == 6 && day == 30) {
                    return (true);
                }
            }
            CheckHebrewDayValue(year, month, day, era);
            return (false);
        }

        // Checks whether a given month in the specified era is a leap month. This method returns true if
        // month is a leap month, or false if not.
        //
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.IsLeapMonth"]/*' />
        public override bool IsLeapMonth(int year, int month, int era) {
            // Year/era values are checked in IsLeapYear().
            bool isLeapYear = IsLeapYear(year, era);
            CheckHebrewMonthValue(year, month, era);
            // The 7th month in a leap year is a leap month.
            if (isLeapYear) {
                if (month == 7) {
                    return (true);
                }
            }
            return (false);
        }

        // Checks whether a given year in the specified era is a leap year. This method returns true if
        // year is a leap year, or false if not.
        //
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.IsLeapYear"]/*' />
        public override bool IsLeapYear(int year, int era) {
           CheckHebrewYearValue(year, era, "year");     
           return (((7 * year + 1) % 19) < 7);
        }

        // (month1, day1) - (month2, day2)
        int GetDayDifference(int lunarYearType, int month1, int day1, int month2, int day2) {
            if (month1 == month2) {
                return (day1 - day2);
            }

            // Make sure that (month1, day1) < (month2, day2)
            bool swap = (month1 > month2);
            if (swap) {
                // (month1, day1) < (month2, day2).  Swap the values.
                // The result will be a negative number.
                int tempMonth, tempDay;
                tempMonth = month1; tempDay = day1;
                month1 = month2; day1 = day2;
                month2 = tempMonth; day2 = tempDay;
            }

            // Get the number of days from (month1,day1) to (month1, end of month1)
            int days = m_lunarMonthLen[lunarYearType, month1] - day1;

            // Move to next month.
            month1++;

            // Add up the days.
            while (month1 < month2) {
                days += m_lunarMonthLen[lunarYearType, month1++];
            }
            days += day2;

            return (swap ? days : -days);
        }
        
        /*=================================HebrewToGregorian==========================
        **Action: Convert Hebrew date to Gregorian date.
        **Returns:
        **Arguments:
        **Exceptions:
        **  The algorithm is like this:
        **      The hebrew year has an offset to the Gregorian year, so we can guess the Gregorian year for
        **      the specified Hebrew year.  That is, GreogrianYear = HebrewYear - FirstHebrewYearOf1AD.
        **
        **      From the Gregorian year and m_HebrewTable, we can get the Hebrew month/day value 
        **      of the Gregorian date January 1st.  Let's call this month/day value [hebrewDateForJan1]
        **
        **      If the requested Hebrew month/day is less than [hebrewDateForJan1], we know the result
        **      Gregorian date falls in previous year.  So we decrease the Gregorian year value, and
        **      retrieve the Hebrew month/day value of the Gregorian date january 1st again.
        **
        **      Now, we get the answer of the Gregorian year.
        **
        **      The next step is to get the number of days between the requested Hebrew month/day
        **      and [hebrewDateForJan1].  When we get that, we can create the DateTime by adding/subtracting
        **      the ticks value of the number of days.
        **
        ============================================================================*/

        
        DateTime HebrewToGregorian(int hebrewYear, int hebrewMonth, int hebrewDay, int hour, int minute, int second, int millisecond) {
            // Get the rough Gregorian year for the specified hebrewYear.
            //
            int gregorianYear = hebrewYear - HebrewYearOf1AD;
            
            __DateBuffer hebrewDateOfJan1 = new __DateBuffer(); // year value is unused.
            int lunarYearType = GetLunarMonthDay(gregorianYear, hebrewDateOfJan1);

            if ((hebrewMonth == hebrewDateOfJan1.month) && (hebrewDay == hebrewDateOfJan1.day)) {
                return (new DateTime(gregorianYear, 1, 1, hour, minute, second, millisecond));
            }

            int days = GetDayDifference(lunarYearType, hebrewMonth, hebrewDay, hebrewDateOfJan1.month, hebrewDateOfJan1.day);

            DateTime gregorianNewYear = new DateTime(gregorianYear, 1, 1);
            return (new DateTime(gregorianNewYear.Ticks + days * TicksPerDay 
                + TimeToTicks(hour, minute, second, millisecond)));
        }

        // Returns the date and time converted to a DateTime value.  Throws an exception if the n-tuple is invalid.
        //
        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.ToDateTime"]/*' />
        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) {
            CheckHebrewYearValue(year, era, "year");
            CheckHebrewMonthValue(year, month, era);
            CheckHebrewDayValue(year, month, day, era);
            
            return (HebrewToGregorian(year, month, day, hour, minute, second, millisecond));
        }

        private const String TwoDigitYearMaxSubKey = "Control Panel\\International\\Calendars\\TwoDigitYearMax";
        private const int DEFAULT_TWO_DIGIT_YEAR_MAX = 5790;

        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.TwoDigitYearMax"]/*' />
        public override int TwoDigitYearMax {
            get {
                if (twoDigitYearMax == -1) {
                    twoDigitYearMax = GetSystemTwoDigitYearSetting(ID, DEFAULT_TWO_DIGIT_YEAR_MAX);
                }
                return (twoDigitYearMax);
            }

            set {
                CheckHebrewYearValue(value, HebrewEra, "value");
                twoDigitYearMax = value;
            }
        }

        /// <include file='doc\HebrewCalendar.uex' path='docs/doc[@for="HebrewCalendar.ToFourDigitYear"]/*' />
        public override int ToFourDigitYear(int year) {
            if (year < 100) {
                return (base.ToFourDigitYear(year));                           
            }
            if (year > m_maxHebrewYear || year < m_minHebrewYear) {
                throw new ArgumentOutOfRangeException("year",
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), m_minHebrewYear, m_maxHebrewYear));
            }
            return (year);
        }            

        ////////////////////////////////////////////////////////////////////////////
        //
        //  NumberToHebrewLetter
        //
        //  Converts the given number to Hebrew letters according to the numeric
        //  value of each Hebrew letter.  Basically, this converts the lunar year
        //  and the lunar month to letters.
        //
        //  The character of a year is described by three letters of the Hebrew
        //  alphabet, the first and third giving, respectively, the days of the
        //  weeks on which the New Year occurs and Passover begins, while the
        //  second is the initial of the Hebrew word for defective, normal, or
        //  complete.
        //
        //  Defective Year : Both Heshvan and Kislev are defective (353 or 383 days)
        //  Normal Year    : Heshvan is defective, Kislev is full  (354 or 384 days)
        //  Complete Year  : Both Heshvan and Kislev are full      (355 or 385 days)
        //
        //  12-04-96    JulieB    Created.
        ////////////////////////////////////////////////////////////////////////////

        // NOTENOTE YSLin: No one use this yet.  But I think we will need it in the future.        
        internal static String NumberToHebrewLetter(int Number) {
            char cTens = '\x0';
            char cUnits;               // tens and units chars
            int Hundreds, Tens;              // hundreds and tens values
            StringBuilder szHebrew = new StringBuilder();


            //
            //  Adjust the number if greater than 5000.
            //
            if (Number > 5000) {
                Number -= 5000;
            }

            //
            //  Get the Hundreds.
            //
            Hundreds = Number / 100;

            if (Hundreds > 0) {
                Number -= Hundreds * 100;
                // \x05e7 = 100
                // \x05e8 = 200
                // \x05e9 = 300
                // \x05ea = 400
                // If the number is greater than 400, use the multiples of 400.
                for (int i = 0; i < (Hundreds / 4) ; i++) {
                    szHebrew.Append('\x05ea');
                }

                int remains = Hundreds % 4;
                if (remains > 0) {
                    szHebrew.Append((char)((int)'\x05e6' + remains));
                }
            }

            //
            //  Get the Tens.
            //
            Tens = Number / 10;
            Number %= 10;

            switch (Tens) {
                case ( 0 ) :
                    cTens = '\x0';
                    break;
                case ( 1 ) :
                    cTens = '\x05d9';          // Hebrew Letter Yod
                    break;
                case ( 2 ) :
                    cTens = '\x05db';          // Hebrew Letter Kaf
                    break;
                case ( 3 ) :
                    cTens = '\x05dc';          // Hebrew Letter Lamed
                    break;
                case ( 4 ) :
                    cTens = '\x05de';          // Hebrew Letter Mem
                    break;
                case ( 5 ) :
                    cTens = '\x05e0';          // Hebrew Letter Nun
                    break;
                case ( 6 ) :
                    cTens = '\x05e1';          // Hebrew Letter Samekh
                    break;
                case ( 7 ) :
                    cTens = '\x05e2';          // Hebrew Letter Ayin
                    break;
                case ( 8 ) :
                    cTens = '\x05e4';          // Hebrew Letter Pe
                    break;
                case ( 9 ) :
                    cTens = '\x05e6';          // Hebrew Letter Tsadi
                    break;
            }

            //
            //  Get the Units.
            //
            cUnits = (char)(Number > 0 ? ((int)'\x05d0' + Number - 1) : 0);

            if ((cUnits == '\x05d4') &&            // Hebrew Letter He  (5)
                (cTens == '\x05d9')) {              // Hebrew Letter Yod (10)
                cUnits = '\x05d5';                 // Hebrew Letter Vav (6)
                cTens  = '\x05d8';                 // Hebrew Letter Tet (9)
            }

            if ((cUnits == '\x05d5') &&            // Hebrew Letter Vav (6)
                (cTens == '\x05d9')) {               // Hebrew Letter Yod (10)
                cUnits = '\x05d6';                 // Hebrew Letter Zayin (7)
                cTens  = '\x05d8';                 // Hebrew Letter Tet (9)
            }

            //
            //  Copy the appropriate info to the given buffer.
            //

            if (cTens != '\x0') {
                szHebrew.Append(cTens);
            }

            if (cUnits != '\x0') {
                szHebrew.Append(cUnits);
            }

            if (szHebrew.Length > 1) {
                szHebrew.Insert(szHebrew.Length - 1, '"');
            } else {
                szHebrew.Append('\'');
            }

            //
            //  Return success.
            //
            return (szHebrew.ToString());
        }
        
        internal class __DateBuffer {
            internal int year;
            internal int month;
            internal int day;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\globalizationassembly.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
    using System;
    using System.Reflection;
    using System.Collections;
	using System.Runtime.CompilerServices;
    
    /*=================================GlobalizationAssembly==========================
    **
    ** This class manages the assemblies used in the NLS+ classes.
    ** Assembly contains the data tables used by NLS+ classes.  An aseembly will carry a version
    ** of all the NLS+ data tables.  The default assembly is provided by 
    ** Assembly.GetAssembly(typeof(GlobalizationAssembly)).
    **
    ** We use assembly to support versioning of NLS+ data tables.  Take CompareInfo for example. 
    ** In CompareInfo.GetCompareInfo(int culture, Assembly),
    ** you can pass an assembly which contains the different NLS+ data tables.  By doing this, the constructed CompareInfo
    ** will read the sorting tables from the specified Assembly, instead of from the default assembly shipped with the runtime.
    **
    ** For every assembly used, we will create one corresponding GlobalizationAssembly.  
    ** Within the GlobalizationAssembly, we will hold the following information:
    **      1. the 32-bit pointer value pointing to the corresponding native C++ NativeGlobalizationAssembly object for it.  This pointer
    **        is needed when we create SortingTable.  See CompareInfo ctor for an example.
    **      2. the caches for different type of objects. For instances, we will have caches for CompareInfo, CultureInfo, RegionInfo, etc.
    **         The idea is to create one instance of CompareInfo for a specific culture.
    ** 
    ** For only, only CompareInfo versioning is supported.  However, this class can be expanded to support the versioning of 
    ** CultureInfo, RegionInfo, etc.
    **
    ============================================================================*/

    internal class GlobalizationAssembly {
        // ----------------------------------------------------------------------------------------------------
        //
        // Static data members and static methods.
        //
        // ----------------------------------------------------------------------------------------------------
    
        //
        // Hash to store Globalization assembly.
        //
        private static Hashtable m_assemblyHash = new Hashtable(4);

        //
        // The pointer to the default C++ native NativeGlobalizationAssembly object for the class library.
        // We use default native NativeGlobalizationAssembly to access NLS+ data table shipped with the runtime.
        //
        // Classes like CompareInfo will access this data member directly when the default assembly is used.
        //
        internal static GlobalizationAssembly m_defaultInstance;

        static GlobalizationAssembly() {
            lock (typeof(GlobalizationAssembly)) {
                if (m_defaultInstance==null) {
                    // Initialize the default GlobalizationAseembly for the default assembly.
                    m_defaultInstance = GetGlobalizationAssembly(Assembly.GetAssembly(typeof(GlobalizationAssembly)));
                }
            }
        }       

        /*=================================GetGlobalizationAssembly==========================
        **Action: Return the GlobalizationAssembly instance for the specified assembly.
        **  Every assembly should have one and only one instance of GlobalizationAssembly.
        **Returns: An instance of GlobalizationAssembly.
        **Arguments:
        **Exceptions:
        ============================================================================*/
        unsafe internal static GlobalizationAssembly GetGlobalizationAssembly(Assembly assembly) {
            GlobalizationAssembly ga;
            
            if ((ga = (GlobalizationAssembly)m_assemblyHash[assembly]) == null) {            
                lock (typeof(GlobalizationAssembly)) {
                    if ((ga = (GlobalizationAssembly)m_assemblyHash[assembly]) == null) {
                        // This assembly is not used before, create a corresponding native NativeGlobalizationAssembly object for it.
                        ga = new GlobalizationAssembly();
                        ga.pNativeGlobalizationAssembly = nativeCreateGlobalizationAssembly(assembly);
                        m_assemblyHash[assembly] = ga;
                    }
                }
            }
            return (ga);
        }

        // This method requires synchonization because class global data member is used
        // in the native side.      
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void* nativeCreateGlobalizationAssembly(Assembly assembly);        
        

        // ----------------------------------------------------------------------------------------------------
        //
        // Instance data members and instance methods.
        //
        // ----------------------------------------------------------------------------------------------------

        // This is the cache to store CompareInfo for a particular culture.
        // The key is culture, and the content is an instance of CompareInfo.
        internal Hashtable compareInfoCache;
        // We will have more caches here for CultureInfo, RegionInfo, etc. if we want to versioning in 
        // these classes.

        // The pointer to C++ native NativeGlobalizationAssembly
        unsafe internal void* pNativeGlobalizationAssembly;
        
        internal GlobalizationAssembly() {
            // Create cache for CompareInfo instances.
            compareInfoCache = new Hashtable(4);
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\gregoriancalendar.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
    //
    // N.B.:
    // A lot of this code is stolen directly from DateTime.  If you update that class,
    // update this one as well.
    // However, we still need these duplicated code because we will add era support
    // in this class.
    // @Consider: Check if DateTime should use the code here so we will not have duplicated code.
    //
    //

    // NOTE YSLin:
    // This class is also used as a base class by other Gregorian-based classes.
    // Therefore, methods like IsLeapYear(int year, int era) are often overriden by other classes.
    // Be sure NOT to call public virtual methods (like IsLeapYear()) in the implementation of this class.  
    // Otherwise, you may end up calling the overriden version in the child class.

    using System.Threading;
    using System;

    /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendarTypes"]/*' />
    [Serializable]
    public enum GregorianCalendarTypes {
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendarTypes.Localized"]/*' />
        Localized = Calendar.CAL_GREGORIAN,
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendarTypes.USEnglish"]/*' />
        USEnglish = Calendar.CAL_GREGORIAN_US,
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendarTypes.MiddleEastFrench"]/*' />
        MiddleEastFrench = Calendar.CAL_GREGORIAN_ME_FRENCH,
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendarTypes.Arabic"]/*' />
        Arabic = Calendar.CAL_GREGORIAN_ARABIC,
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendarTypes.TransliteratedEnglish"]/*' />
        TransliteratedEnglish = Calendar.CAL_GREGORIAN_XLIT_ENGLISH,
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendarTypes.TransliteratedFrench"]/*' />
        TransliteratedFrench = Calendar.CAL_GREGORIAN_XLIT_FRENCH,
    }

    // 
    // This class implements the Gregorian calendar. In 1582, Pope Gregory XIII made 
    // minor changes to the solar Julian or "Old Style" calendar to make it more 
    // accurate. Thus the calendar became known as the Gregorian or "New Style" 
    // calendar, and adopted in Catholic countries such as Spain and France. Later 
    // the Gregorian calendar became popular throughout Western Europe because it 
    // was accurate and convenient for international trade. Scandinavian countries 
    // adopted it in 1700, Great Britain in 1752, the American colonies in 1752 and 
    // India in 1757. China adopted the same calendar in 1911, Russia in 1918, and 
    // some Eastern European countries as late as 1940.
    // 
    // This calendar recognizes two era values:
    // 0 CurrentEra (AD) 
    // 1 BeforeCurrentEra (BC) 
    /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar"]/*' />
    [Serializable()] public class GregorianCalendar : Calendar
    {
        /*
            A.D. = anno Domini (after the birth of Jesus Christ)
         */
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.ADEra"]/*' />
        public const int ADEra = 1;

        
        internal const int DatePartYear = 0;
        internal const int DatePartDayOfYear = 1;
        internal const int DatePartMonth = 2;
        internal const int DatePartDay = 3;    

        //
        // This is the max Gregorian year can be represented by DateTime class.  The limitation
        // is derived from DateTime class.
        // 
        internal const int MaxYear = 9999;

        internal GregorianCalendarTypes m_type;
        
        internal static readonly int[] DaysToMonth365 = 
        {
            0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
        };
        
        internal static readonly int[] DaysToMonth366 = 
        {
            0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366
        };

        internal static Calendar m_defaultInstance = null;

        /*=================================GetDefaultInstance==========================
        **Action: Internal method to provide a default intance of GregorianCalendar.  Used by NLS+ implementation
        **       and other calendars.
        **Returns:
        **Arguments:
        **Exceptions:
        ============================================================================*/

        internal static Calendar GetDefaultInstance() {
            if (m_defaultInstance == null) {
                m_defaultInstance = new GregorianCalendar();
            }
            return (m_defaultInstance);
        }
    
        // Construct an instance of gregorian calendar.
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.GregorianCalendar"]/*' />
        public GregorianCalendar() :
            this(GregorianCalendarTypes.Localized) {
        }

        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.GregorianCalendar1"]/*' />
        public GregorianCalendar(GregorianCalendarTypes type) {
            this.m_type = type;
        }

        // BUGBUG YSLin:
        // So there is a bug here.  This makes other calendar derived from Gregorian get this as well, but
        // this is not what we want.  How do I solve this?  Can I hide this in other derived classes?
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.CalendarType"]/*' />
        public virtual GregorianCalendarTypes CalendarType {
            get {
                return (m_type);
            }

            set {
                m_type = value;
            }
        }
        
        internal override int ID {
            get {
                // By returning different ID for different variations of GregorianCalendar, 
                // we can support the Transliterated Gregorian calendar.
                // DateTimeFormatInfo will use this ID to get formatting information about
                // the calendar.
                return ((int)m_type);
            }
        }

    
        // Returns a given date part of this DateTime. This method is used
        // to compute the year, day-of-year, month, or day part.
        internal virtual int GetDatePart(long ticks, int part) 
        {
            // n = number of days since 1/1/0001
            int n = (int)(ticks / TicksPerDay);
            // y400 = number of whole 400-year periods since 1/1/0001
            int y400 = n / DaysPer400Years;
            // n = day number within 400-year period
            n -= y400 * DaysPer400Years;
            // y100 = number of whole 100-year periods within 400-year period
            int y100 = n / DaysPer100Years;
            // Last 100-year period has an extra day, so decrement result if 4
            if (y100 == 4) y100 = 3;        
            // n = day number within 100-year period
            n -= y100 * DaysPer100Years;
            // y4 = number of whole 4-year periods within 100-year period
            int y4 = n / DaysPer4Years;
            // n = day number within 4-year period
            n -= y4 * DaysPer4Years;
            // y1 = number of whole years within 4-year period
            int y1 = n / DaysPerYear;
            // Last year has an extra day, so decrement result if 4
            if (y1 == 4) y1 = 3;        
            // If year was requested, compute and return it
            if (part == DatePartYear) 
            {
                return (y400 * 400 + y100 * 100 + y4 * 4 + y1 + 1);
            }
            // n = day number within year
            n -= y1 * DaysPerYear;
            // If day-of-year was requested, return it
            if (part == DatePartDayOfYear) 
            {
                return (n + 1);
            }
            // Leap year calculation looks different from IsLeapYear since y1, y4,
            // and y100 are relative to year 1, not year 0
            bool leapYear = (y1 == 3 && (y4 != 24 || y100 == 3));
            int[] days = leapYear? DaysToMonth366: DaysToMonth365;
            // All months have less than 32 days, so n >> 5 is a good conservative
            // estimate for the month
            int m = n >> 5 + 1;
            // m = 1-based month number
            while (n >= days[m]) m++;
            // If month was requested, return it
            if (part == DatePartMonth) return (m);
            // Return 1-based day-of-month
            return (n - days[m - 1] + 1);
        }

        /*=================================GetAbsoluteDate==========================
        **Action: Gets the absolute date for the given Gregorian date.  The absolute date means
        **       the number of days from January 1st, 1 A.D.
        **Returns:  the absolute date
        **Arguments:
        **      year    the Gregorian year
        **      month   the Gregorian month
        **      day     the day
        **Exceptions:
        **      ArgumentOutOfRangException  if year, month, day value is valid.
        **Note:
        **      This is an internal method used by DateToTicks() and the calculations of Hijri and Hebrew calendars.
        **      Number of Days in Prior Years (both common and leap years) +
        **      Number of Days in Prior Months of Current Year +
        **      Number of Days in Current Month
        **
        ============================================================================*/

        internal static long GetAbsoluteDate(int year, int month, int day) {
            if (year >= 1 && year <= MaxYear && month >= 1 && month <= 12) 
            {
                int[] days = ((year % 4 == 0 && (year % 100 != 0 || year % 400 == 0))) ? DaysToMonth366: DaysToMonth365;
                if (day >= 1 && (day <= days[month] - days[month - 1])) {
                    int y = year - 1;
                    int absoluteDate = y * 365 + y / 4 - y / 100 + y / 400 + days[month - 1] + day - 1;
                    return (absoluteDate);
                }
            }
            throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_BadYearMonthDay"));
        }        

        // Returns the tick count corresponding to the given year, month, and day.
        // Will check the if the parameters are valid.
        internal virtual long DateToTicks(int year, int month, int day) {
            return (GetAbsoluteDate(year, month,  day)* TicksPerDay);
        }
            
        // Returns the DateTime resulting from adding the given number of
        // months to the specified DateTime. The result is computed by incrementing
        // (or decrementing) the year and month parts of the specified DateTime by
        // value months, and, if required, adjusting the day part of the
        // resulting date downwards to the last day of the resulting month in the
        // resulting year. The time-of-day part of the result is the same as the
        // time-of-day part of the specified DateTime.
        //
        // In more precise terms, considering the specified DateTime to be of the
        // form y / m / d + t, where y is the
        // year, m is the month, d is the day, and t is the
        // time-of-day, the result is y1 / m1 / d1 + t,
        // where y1 and m1 are computed by adding value months
        // to y and m, and d1 is the largest value less than
        // or equal to d that denotes a valid day in month m1 of year
        // y1.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.AddMonths"]/*' />
        public override DateTime AddMonths(DateTime time, int months) 
        {
            if (months < -120000 || months > 120000) {
                throw new ArgumentOutOfRangeException(
                    "months", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    -120000, 120000));
            }
            int y = GetDatePart(time.Ticks, DatePartYear);
            int m = GetDatePart(time.Ticks, DatePartMonth);
            int d = GetDatePart(time.Ticks, DatePartDay);
            int i = m - 1 + months;
            if (i >= 0) 
            {
                m = i % 12 + 1;
                y = y + i / 12;
            }
            else 
            {
                m = 12 + (i + 1) % 12;
                y = y + (i - 11) / 12;
            }
            int[] daysArray = (y % 4 == 0 && (y % 100 != 0 || y % 400 == 0)) ? DaysToMonth366: DaysToMonth365;
            int days = (daysArray[m] - daysArray[m - 1]); 
            
            if (d > days) 
            {
                d = days;
            }
            return (new DateTime(DateToTicks(y, m, d) + time.Ticks % TicksPerDay));
        }
    
        // Returns the DateTime resulting from adding a number of
        // weeks to the specified DateTime. The
        // value argument is permitted to be negative.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.AddWeeks"]/*' />
        public override DateTime AddWeeks(DateTime time, int weeks)
        {
            return (AddDays(time, weeks * 7));
        }
        
        // Returns the DateTime resulting from adding the given number of
        // years to the specified DateTime. The result is computed by incrementing
        // (or decrementing) the year part of the specified DateTime by value
        // years. If the month and day of the specified DateTime is 2/29, and if the
        // resulting year is not a leap year, the month and day of the resulting
        // DateTime becomes 2/28. Otherwise, the month, day, and time-of-day
        // parts of the result are the same as those of the specified DateTime.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.AddYears"]/*' />
        public override DateTime AddYears(DateTime time, int years) 
        {
            return (AddMonths(time, years * 12));
        }
    
        // Returns the day-of-month part of the specified DateTime. The returned
        // value is an integer between 1 and 31.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.GetDayOfMonth"]/*' />
        public override int GetDayOfMonth(DateTime time)
        {
            return (GetDatePart(time.Ticks, DatePartDay));
        }
    
        // Returns the day-of-week part of the specified DateTime. The returned value
        // is an integer between 0 and 6, where 0 indicates Sunday, 1 indicates
        // Monday, 2 indicates Tuesday, 3 indicates Wednesday, 4 indicates
        // Thursday, 5 indicates Friday, and 6 indicates Saturday.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.GetDayOfWeek"]/*' />
        public override DayOfWeek GetDayOfWeek(DateTime time) 
        {
            return ((DayOfWeek)((int)(time.Ticks / TicksPerDay + 1) % 7));
        }
    
        // Returns the day-of-year part of the specified DateTime. The returned value
        // is an integer between 1 and 366.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.GetDayOfYear"]/*' />
        public override int GetDayOfYear(DateTime time)
        {
            return (GetDatePart(time.Ticks, DatePartDayOfYear));
        }

        // Returns the number of days in the month given by the year and
        // month arguments.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.GetDaysInMonth"]/*' />
        public override int GetDaysInMonth(int year, int month, int era) {
            if (era == CurrentEra || era == ADEra) {
                if (month < 1 || month > 12) {
                    throw new ArgumentOutOfRangeException("month", Environment.GetResourceString("ArgumentOutOfRange_Month"));
                }
                int[] days = ((year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) ? DaysToMonth366: DaysToMonth365);
                return (days[month] - days[month - 1]);        
            }
            throw new ArgumentException(Environment.GetResourceString("Argument_InvalidEraValue"));
        }
    
        // Returns the number of days in the year given by the year argument for the current era.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.GetDaysInYear"]/*' />
        public override int GetDaysInYear(int year, int era)
        {
            if (era == CurrentEra || era == ADEra) {
                if (year >= 1 && year <= MaxYear) {
                    return ((year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) ? 366:365);
                }
                throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    1, MaxYear));
            }
            throw new ArgumentException(Environment.GetResourceString("Argument_InvalidEraValue"));
        }
    
        // Returns the era for the specified DateTime value.
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.GetEra"]/*' />
        public override int GetEra(DateTime time)
        {
            return (ADEra);
        }

        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.Eras"]/*' />
        public override int[] Eras {
            get {
                return (new int[] {ADEra} );
            }
        }

            
        // Returns the month part of the specified DateTime. The returned value is an
        // integer between 1 and 12.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.GetMonth"]/*' />
        public override int GetMonth(DateTime time) 
        {
    		return (GetDatePart(time.Ticks, DatePartMonth));
        }
    
        // Returns the number of months in the specified year and era.
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.GetMonthsInYear"]/*' />
        public override int GetMonthsInYear(int year, int era)
        {
            if (era == CurrentEra || era == ADEra) {
                if (year >= 1 && year <= MaxYear)    
                {
                    return (12);
                }
                throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    1, MaxYear));
            }
            throw new ArgumentException(Environment.GetResourceString("Argument_InvalidEraValue"));
        }
                
        // Returns the year part of the specified DateTime. The returned value is an
        // integer between 1 and 9999.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.GetYear"]/*' />
        public override int GetYear(DateTime time) 
        {
            return (GetDatePart(time.Ticks, DatePartYear));
        }    
    
        // Checks whether a given day in the specified era is a leap day. This method returns true if
        // the date is a leap day, or false if not.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.IsLeapDay"]/*' />
        public override bool IsLeapDay(int year, int month, int day, int era)
        {
            if (era != CurrentEra && era != ADEra) {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidEraValue"));
            }
            if (year < 1 || year > MaxYear) {
                throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 1, MaxYear));
            }            
            
            if (month < 1 || month > 12) {
                throw new ArgumentOutOfRangeException("month", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    1, 12));                
            }
            if (day < 1 || day > GetDaysInMonth(year, month)) {
                throw new ArgumentOutOfRangeException("day", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    1, GetDaysInMonth(year, month)));                
            }
            if (!IsLeapYear(year)) {
                return (false);
            }
            if (month == 2 && day == 29) {
                return (true);
            }
            return (false);
        }
    
        // Checks whether a given month in the specified era is a leap month. This method returns true if
        // month is a leap month, or false if not.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.IsLeapMonth"]/*' />
        public override bool IsLeapMonth(int year, int month, int era)
        {
            if (era != CurrentEra && era != ADEra) {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidEraValue"));
            }            
            if (year < 1 || year > MaxYear) {
                throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 1, MaxYear));
            }                        
            if (month < 1 || month > 12) {
                throw new ArgumentOutOfRangeException("month", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    1, 12));                
            }
            return (false);

        }    
    
        // Checks whether a given year in the specified era is a leap year. This method returns true if
        // year is a leap year, or false if not.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.IsLeapYear"]/*' />
        public override bool IsLeapYear(int year, int era) {
            if (era == CurrentEra || era == ADEra) {
                if (year >= 1 && year <= MaxYear) {
                    return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));
                }
                throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    1, MaxYear));
            }
            throw new ArgumentException(Environment.GetResourceString("Argument_InvalidEraValue"));
        }
    
        // Returns the date and time converted to a DateTime value.  Throws an exception if the n-tuple is invalid.
        //
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.ToDateTime"]/*' />
        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
        {
            if (era == CurrentEra || era == ADEra) {
                return new DateTime(year, month, day, hour, minute, second, millisecond);
            }
            throw new ArgumentException(Environment.GetResourceString("Argument_InvalidEraValue"));
        }

        private const int DEFAULT_TWO_DIGIT_YEAR_MAX = 2029;            
        
        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.TwoDigitYearMax"]/*' />
        public override int TwoDigitYearMax
        {
            get {
                if (twoDigitYearMax == -1) {
                    twoDigitYearMax = GetSystemTwoDigitYearSetting(ID, DEFAULT_TWO_DIGIT_YEAR_MAX);
                }
                return (twoDigitYearMax);
            }

            set {
                if (value < 100 || value > MaxYear) {
                    throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    100, MaxYear));

                }
                twoDigitYearMax = value;
            }
        }

        /// <include file='doc\GregorianCalendar.uex' path='docs/doc[@for="GregorianCalendar.ToFourDigitYear"]/*' />
        public override int ToFourDigitYear(int year) {
            if (year > MaxYear) {
                throw new ArgumentOutOfRangeException("year",
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 1, MaxYear)); 
            }
            return (base.ToFourDigitYear(year));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\hijricalendar.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {

    using System;

    ////////////////////////////////////////////////////////////////////////////
    //
    //  Notes about HijriCalendar (stolen from DateTime.c in NLS)
    //
    //  Rules for the Hijri calendar:
    //    - The Hijri calendar is a strictly Lunar calendar.
    //    - Days begin at sunset.
    //    - Islamic Year 1 (Muharram 1, 1 A.H.) is equivalent to absolute date
    //        227015 (Friday, July 16, 622 C.E. - Julian).
    //    - Leap Years occur in the 2, 5, 7, 10, 13, 16, 18, 21, 24, 26, & 29th
    //        years of a 30-year cycle.  Year = leap iff ((11y+14) mod 30 < 11).
    //    - There are 12 months which contain alternately 30 and 29 days.
    //    - The 12th month, Dhu al-Hijjah, contains 30 days instead of 29 days
    //        in a leap year.
    //    - Common years have 354 days.  Leap years have 355 days.
    //    - There are 10,631 days in a 30-year cycle.
    //    - The Islamic months are:
    //        1.  Muharram   (30 days)     7.  Rajab          (30 days)
    //        2.  Safar      (29 days)     8.  Sha'ban        (29 days)
    //        3.  Rabi I     (30 days)     9.  Ramadan        (30 days)
    //        4.  Rabi II    (29 days)     10. Shawwal        (29 days)
    //        5.  Jumada I   (30 days)     11. Dhu al-Qada    (30 days)
    //        6.  Jumada II  (29 days)     12. Dhu al-Hijjah  (29 days) {30}
    //
    //  NOTENOTE YSLin:
    //      The calculation of the HijriCalendar is based on the absolute date.  And the 
    //      absolute date means the number of days from January 1st, 1 A.D.
    //      Therefore, we do not support the days before the January 1st, 1 A.D.
    //
    ////////////////////////////////////////////////////////////////////////////
     /*
     **  Calendar support range:
     **      Calendar    Minimum     Maximum
     **      ==========  ==========  ==========
     **      Gregorian   0622/07/08   9999/12/31
     **      Hijri       0001/01/01   9666/04/03
     */
    /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar"]/*' />
    [Serializable]
    public class HijriCalendar : Calendar {

        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.HijriEra"]/*' />
        public static readonly int HijriEra = 1;
        
        internal const int DatePartYear = 0;
        internal const int DatePartDayOfYear = 1;
        internal const int DatePartMonth = 2;
        internal const int DatePartDay = 3;

        internal const int MinAdvancedHijri = -2;
        internal const int MaxAdvancedHijri = 2;

        internal static int[] HijriMonthDays = {0,30,59,89,118,148,177,207,236,266,295,325,355};

        internal static Calendar m_defaultInstance = null;

        private static String m_InternationalRegKey = "Control Panel\\International";
        private static String m_HijriAdvanceRegKeyEntry = "AddHijriDate";

        private int m_HijriAdvance = Int32.MinValue;

        // DateTime.MaxValue = Hijri calendar (year:9666, month: 4, day: 3).
        internal const int MaxCalendarYear = 9666;        
        internal const int MaxCalendarMonth = 4;
        internal const int MaxCalendarDay = 3;
        // Hijri calendar (year: 1, month: 1, day:1 ) = Gregorian (year: 622, month: 7, day: 18)
        // This is the minimal Gregorian date that we support in the HijriCalendar.
        internal static DateTime minDate = new DateTime(622, 7, 18);
        internal static DateTime maxDate = DateTime.MaxValue;

        /*=================================GetDefaultInstance==========================
        **Action: Internal method to provide a default intance of HijriCalendar.  Used by NLS+ implementation
        **       and other calendars.
        **Returns:
        **Arguments:
        **Exceptions:
        ============================================================================*/

        internal static Calendar GetDefaultInstance() {
            if (m_defaultInstance == null) {
                m_defaultInstance = new HijriCalendar();
            }
            return (m_defaultInstance);
        }

        // Construct an instance of Hijri calendar.
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.HijriCalendar"]/*' />
        public HijriCalendar() {
        }

        internal override int ID {
            get {
                return (CAL_HIJRI);
            }
        }

        /*=================================GetAbsoluteDateHijri==========================
        **Action: Gets the Absolute date for the given Hijri date.  The absolute date means
        **       the number of days from January 1st, 1 A.D.
        **Returns:
        **Arguments:
        **Exceptions:
        ============================================================================*/

        long GetAbsoluteDateHijri(int y, int m, int d) {
            return (long)(DaysUpToHijriYear(y) + HijriMonthDays[m-1] + d);
        }

        /*=================================DaysUpToHijriYear==========================
        **Action: Gets the total number of days (absolute date) up to the given Hijri Year.
        **       The absolute date means the number of days from January 1st, 1 A.D.
        **Returns: Gets the total number of days (absolute date) up to the given Hijri Year.
        **Arguments: HijriYear year value in Hijri calendar.
        **Exceptions: None
        **Notes:
        **  12-04-96    JulieB    Created.
        ============================================================================*/

        long DaysUpToHijriYear(int HijriYear) {
            long NumDays;           // number of absolute days
            int NumYear30;         // number of years up to current 30 year cycle
            int NumYearsLeft;      // number of years into 30 year cycle

            //
            //  Compute the number of years up to the current 30 year cycle.
            //
            NumYear30 = ((HijriYear - 1) / 30) * 30;

            //
            //  Compute the number of years left.  This is the number of years
            //  into the 30 year cycle for the given year.
            //
            NumYearsLeft = HijriYear - NumYear30 - 1;

            //
            //  Compute the number of absolute days up to the given year.
            //
            NumDays = ((NumYear30 * 10631L) / 30L) + 227013L;
            while (NumYearsLeft > 0) {
                // Common year is 354 days, and leap year is 355 days.
                NumDays += 354 + (IsLeapYear(NumYearsLeft, CurrentEra) ? 1: 0);
                NumYearsLeft--;
            }

            //
            //  Return the number of absolute days.
            //
            return (NumDays);
        }

        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.HijriAdjustment"]/*' />
        public int HijriAdjustment {
            get {
                if (m_HijriAdvance == Int32.MinValue) {
                    // Never been set before.  Use the system value from registry.
                    m_HijriAdvance = GetAdvanceHijriDate();
                }
                return (m_HijriAdvance);
            }

            set {
                // NOTENOTE YSLin: Check the value of Min/MaxAdavncedHijri with Arabic speakers to see if the assumption is good.
                if (value < MinAdvancedHijri || value > MaxAdvancedHijri) {
                    throw new ArgumentOutOfRangeException("HijriAdjustment", 
                        String.Format(Environment.GetResourceString("ArgumentOutOfRange_Bounds_Lower_Upper"), 
                                MinAdvancedHijri, MaxAdvancedHijri));
                }
                m_HijriAdvance = value;
            }
        }
        

        /*=================================GetAdvanceHijriDate==========================
        **Action: Gets the AddHijriDate value from the registry.
        **Returns:
        **Arguments:    None.
        **Exceptions: 
        **Note:
        **  The HijriCalendar has a user-overidable calculation.  That is, use can set a value from the control
        **  panel, so that the calculation of the Hijri Calendar can move ahead or backwards from -2 to +2 days.
        **
        **  The valid string values in the registry are:
        **      "AddHijriDate-2"  =>  Add -2 days to the current calculated Hijri date.
        **      "AddHijriDate"    =>  Add -1 day to the current calculated Hijri date.
        **      ""              =>  Add 0 day to the current calculated Hijri date.
        **      "AddHijriDate+1"  =>  Add +1 days to the current calculated Hijri date.
        **      "AddHijriDate+2"  =>  Add +2 days to the current calculated Hijri date.
        ============================================================================*/
        
        int GetAdvanceHijriDate() {
            int hijriAdvance = 0;
            Microsoft.Win32.RegistryKey key = null;

            try {
                // Open in read-only mode.
                // Use InternalOpenSubKey so that we avoid the security check.
                key = Microsoft.Win32.Registry.CurrentUser.InternalOpenSubKey(m_InternationalRegKey, false);
            } catch (Exception) {
                //If this fails for any reason, we'll just return 0.
                return (0);
            }

            if (key != null) {
                Object value = key.InternalGetValue(m_HijriAdvanceRegKeyEntry, null, false);
                key.Close();
                if (value == null) {
                    return (0);
                }
                String str = value.ToString();
                if (String.Compare(str, 0, m_HijriAdvanceRegKeyEntry, 0, m_HijriAdvanceRegKeyEntry.Length, true, CultureInfo.InvariantCulture) == 0) {
                    if (str.Length == m_HijriAdvanceRegKeyEntry.Length)
                        hijriAdvance = -1;
                    else {
                        str = str.Substring(m_HijriAdvanceRegKeyEntry.Length);
                        try {
                            int advance = Int32.Parse(str.ToString(), CultureInfo.InvariantCulture);
                            if ((advance >= MinAdvancedHijri) && (advance <= MaxAdvancedHijri)) {
                                hijriAdvance = advance;
                            }                        
                        }
                        catch (Exception) {
                        }
                    }
                }
            }
            return (hijriAdvance);
        }

        internal void CheckTicksRange(long ticks) {
            if (ticks < minDate.Ticks || ticks > maxDate.Ticks) {
                throw new ArgumentOutOfRangeException("time", 
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_CalendarRange"), 
                            minDate, maxDate));
            }
        }

        internal void CheckEraRange(int era) {
            if (era != CurrentEra && era != HijriEra) {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidEraValue"), "era");            
            }        
        }
        
        internal void CheckYearRange(int year, int era) {
            CheckEraRange(era);
            if (year < 1 || year > MaxCalendarYear) {
                throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    1, MaxCalendarYear));
            }
        }
        
        internal void CheckYearMonthRange(int year, int month, int era) {
            CheckYearRange(year, era);
            if (year == MaxCalendarYear) {
                if (month > MaxCalendarMonth) {
                    throw new ArgumentOutOfRangeException("month", 
                        String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                            1, MaxCalendarMonth));
                }
            }
            if (month < 1 || month > 12) {
                throw new ArgumentOutOfRangeException("month", Environment.GetResourceString("ArgumentOutOfRange_Month"));
            }
        }
        
        /*=================================GetDatePart==========================
        **Action: Returns a given date part of this <i>DateTime</i>. This method is used
        **       to compute the year, day-of-year, month, or day part.
        **Returns:
        **Arguments:
        **Exceptions:  ArgumentException if part is incorrect.
        **Notes:
        **      First, we get the absolute date (the number of days from January 1st, 1 A.C) for the given ticks.
        **      Use the formula (((AbsoluteDate - 227013) * 30) / 10631) + 1, we can a rough value for the Hijri year.
        **      In order to get the exact Hijri year, we compare the exact absolute date for HijriYear and (HijriYear + 1).
        **      From here, we can get the correct Hijri year.
        ============================================================================*/

        internal virtual int GetDatePart(long ticks, int part) {
            int HijriYear;                   // Hijri year
            int HijriMonth;                  // Hijri month
            int HijriDay;                    // Hijri day
            long NumDays;                 // The calculation buffer in number of days.

            CheckTicksRange(ticks);

            //
            //  Get the absolute date.  The absolute date is the number of days from January 1st, 1 A.D.
            //  1/1/0001 is absolute date 1.
            //
            NumDays = ticks / GregorianCalendar.TicksPerDay + 1;

            //
            //  See how much we need to backup or advance
            //
            NumDays += HijriAdjustment;

            //
            //  Calculate the appromixate Hijri Year from this magic formula.
            //
            HijriYear = (int)(((NumDays - 227013) * 30) / 10631) + 1;

            long daysToHijriYear = DaysUpToHijriYear(HijriYear);            // The absoulte date for HijriYear            
            long daysOfHijriYear = GetDaysInYear(HijriYear, CurrentEra);    // The number of days for (HijriYear+1) year.
            
            if (NumDays < daysToHijriYear) {
                daysToHijriYear -= daysOfHijriYear;
                HijriYear--;
            } else if (NumDays == daysToHijriYear) {
                HijriYear--;
                daysToHijriYear -= GetDaysInYear(HijriYear, CurrentEra);
            } else {               
                if (NumDays > daysToHijriYear + daysOfHijriYear) {
                    daysToHijriYear += daysOfHijriYear;
                    HijriYear++;
                }
            }
            if (part == DatePartYear) {
                return (HijriYear);
            }
            
            //
            //  Calculate the Hijri Month.
            //

            HijriMonth = 1;
            NumDays -= daysToHijriYear;
            
            if (part == DatePartDayOfYear) {
                return ((int)NumDays);
            }

            while ((HijriMonth <= 12) && (NumDays > HijriMonthDays[HijriMonth - 1])) {
                HijriMonth++;
            } 
            HijriMonth--;

            if (part == DatePartMonth) {
                return (HijriMonth);
            }

            //
            //  Calculate the Hijri Day.
            //
            HijriDay = (int)(NumDays - HijriMonthDays[HijriMonth - 1]);

            if (part == DatePartDay) {
                return (HijriDay);
            }
            // Incorrect part value.
            throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_DateTimeParsing"));
        }

        // Returns the DateTime resulting from adding the given number of
        // months to the specified DateTime. The result is computed by incrementing
        // (or decrementing) the year and month parts of the specified DateTime by
        // value months, and, if required, adjusting the day part of the
        // resulting date downwards to the last day of the resulting month in the
        // resulting year. The time-of-day part of the result is the same as the
        // time-of-day part of the specified DateTime.
        //
        // In more precise terms, considering the specified DateTime to be of the
        // form y / m / d + t, where y is the
        // year, m is the month, d is the day, and t is the
        // time-of-day, the result is y1 / m1 / d1 + t,
        // where y1 and m1 are computed by adding value months
        // to y and m, and d1 is the largest value less than
        // or equal to d that denotes a valid day in month m1 of year
        // y1.
        //
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.AddMonths"]/*' />
        public override DateTime AddMonths(DateTime time, int months) {
            if (months < -120000 || months > 120000) {
                throw new ArgumentOutOfRangeException(
                    "months", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                    -120000, 120000));
            }
            // Get the date in Hijri calendar.
            int y = GetDatePart(time.Ticks, DatePartYear);
            int m = GetDatePart(time.Ticks, DatePartMonth);
            int d = GetDatePart(time.Ticks, DatePartDay);
            int i = m - 1 + months;
            if (i >= 0) {
                m = i % 12 + 1;
                y = y + i / 12;
            } else {
                m = 12 + (i + 1) % 12;
                y = y + (i - 11) / 12;
            }
            int days = GetDaysInMonth(y, m);
            if (d > days) {
                d = days;
            }
            return (new DateTime((GetAbsoluteDateHijri(y, m, d) - 1)* TicksPerDay + time.Ticks % TicksPerDay));
        }

        // Returns the DateTime resulting from adding the given number of
        // years to the specified DateTime. The result is computed by incrementing
        // (or decrementing) the year part of the specified DateTime by value
        // years. If the month and day of the specified DateTime is 2/29, and if the
        // resulting year is not a leap year, the month and day of the resulting
        // DateTime becomes 2/28. Otherwise, the month, day, and time-of-day
        // parts of the result are the same as those of the specified DateTime.
        //
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.AddYears"]/*' />
        public override DateTime AddYears(DateTime time, int years) {
            return (AddMonths(time, years * 12));
        }

        // Returns the day-of-month part of the specified DateTime. The returned
        // value is an integer between 1 and 31.
        //
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.GetDayOfMonth"]/*' />
        public override int GetDayOfMonth(DateTime time) {
            return (GetDatePart(time.Ticks, DatePartDay));
        }

        // Returns the day-of-week part of the specified DateTime. The returned value
        // is an integer between 0 and 6, where 0 indicates Sunday, 1 indicates
        // Monday, 2 indicates Tuesday, 3 indicates Wednesday, 4 indicates
        // Thursday, 5 indicates Friday, and 6 indicates Saturday.
        //
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.GetDayOfWeek"]/*' />
        public override DayOfWeek GetDayOfWeek(DateTime time) {
            // BUGBUG YSLin: Is this correct? We are assuming that HijriCalendar
            // is using the same day of week rule as Gregorian.
            return ((DayOfWeek)((int)(time.Ticks / TicksPerDay + 1) % 7));
        }

        // Returns the day-of-year part of the specified DateTime. The returned value
        // is an integer between 1 and 366.
        //
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.GetDayOfYear"]/*' />
        public override int GetDayOfYear(DateTime time) {
            return (GetDatePart(time.Ticks, DatePartDayOfYear));
        }

        // Returns the number of days in the month given by the year and
        // month arguments.
        //
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.GetDaysInMonth"]/*' />
        public override int GetDaysInMonth(int year, int month, int era) {
            CheckYearMonthRange(year, month, era);
            if (month == 12) {
                // For the 12th month, leap year has 30 days, and common year has 29 days.
                return (IsLeapYear(year, CurrentEra) ? 30 : 29);
            }
            // Other months contain 30 and 29 days alternatively.  The 1st month has 30 days.
            return (((month % 2) == 1) ? 30 : 29); 
        }

        // Returns the number of days in the year given by the year argument for the current era.
        //
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.GetDaysInYear"]/*' />
        public override int GetDaysInYear(int year, int era) {
            CheckYearRange(year, era);
            // Common years have 354 days.  Leap years have 355 days.
            return (IsLeapYear(year, CurrentEra) ? 355: 354);
        }

        // Returns the era for the specified DateTime value.
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.GetEra"]/*' />
        public override int GetEra(DateTime time) {
            CheckTicksRange(time.Ticks);
            return (HijriEra);
        }

        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.Eras"]/*' />
        public override int[] Eras {
            get {
                return (new int[] {HijriEra});
            }
        }

        // Returns the month part of the specified DateTime. The returned value is an
        // integer between 1 and 12.
        //
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.GetMonth"]/*' />
        public override int GetMonth(DateTime time) {
            return (GetDatePart(time.Ticks, DatePartMonth));
        }

        // Returns the number of months in the specified year and era.
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.GetMonthsInYear"]/*' />
        public override int GetMonthsInYear(int year, int era) {
            CheckYearRange(year, era);
            return (12);
        }

        // Returns the year part of the specified DateTime. The returned value is an
        // integer between 1 and MaxCalendarYear.
        //
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.GetYear"]/*' />
        public override int GetYear(DateTime time) {
            return (GetDatePart(time.Ticks, DatePartYear));
        }

        // Checks whether a given day in the specified era is a leap day. This method returns true if
        // the date is a leap day, or false if not.
        //
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.IsLeapDay"]/*' />
        public override bool IsLeapDay(int year, int month, int day, int era) {
            // The year/month/era value checking is done in GetDaysInMonth().
            int daysInMonth = GetDaysInMonth(year, month, era);
            if (day < 1 || day > daysInMonth) {
                throw new ArgumentOutOfRangeException("day", 
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_Day"), daysInMonth, month));
            }
            return (IsLeapYear(year, era) && month == 12 && day == 30);
        }

        // Checks whether a given month in the specified era is a leap month. This method returns true if
        // month is a leap month, or false if not.
        //
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.IsLeapMonth"]/*' />
        public override bool IsLeapMonth(int year, int month, int era) {
            CheckYearMonthRange(year, month, era);
            return (false);
        }

        // Checks whether a given year in the specified era is a leap year. This method returns true if
        // year is a leap year, or false if not.
        //
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.IsLeapYear"]/*' />
        public override bool IsLeapYear(int year, int era) {
            CheckYearRange(year, era);
            return ((((year * 11) + 14) % 30) < 11);
        }
        
        // Returns the date and time converted to a DateTime value.  Throws an exception if the n-tuple is invalid.
        //
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.ToDateTime"]/*' />
        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) {
            // The year/month/era checking is done in GetDaysInMonth().
            int daysInMonth = GetDaysInMonth(year, month, era);            
            if (day < 1 || day > daysInMonth) {
                BCLDebug.Log("year = " + year + ", month = " + month + ", day = " + day);
                throw new ArgumentOutOfRangeException("day", 
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_Day"), daysInMonth, month));
            }
            
            long lDate = GetAbsoluteDateHijri(year, month, day) - 1 - HijriAdjustment;

            if (lDate >= 0) {
                return (new DateTime(lDate * GregorianCalendar.TicksPerDay + TimeToTicks(hour, minute, second, millisecond)));
            } else {
                throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_BadYearMonthDay"));
            }
        }

        private const String TwoDigitYearMaxSubKey = "Control Panel\\International\\Calendars\\TwoDigitYearMax";
        private const int DEFAULT_TWO_DIGIT_YEAR_MAX = 1451;

        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.TwoDigitYearMax"]/*' />
        public override int TwoDigitYearMax {
            get {
                if (twoDigitYearMax == -1) {
                    twoDigitYearMax = GetSystemTwoDigitYearSetting(ID, DEFAULT_TWO_DIGIT_YEAR_MAX);                
                }
                return (twoDigitYearMax);
            }
            
            set {
                if (value < 100 || value > MaxCalendarYear) {
                    throw new ArgumentOutOfRangeException("value", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    100, MaxCalendarYear));

                }                
                twoDigitYearMax = value;
            }
        }
        
        /// <include file='doc\HijriCalendar.uex' path='docs/doc[@for="HijriCalendar.ToFourDigitYear"]/*' />
        public override int ToFourDigitYear(int year) {
            if (year < 100) {
                return (base.ToFourDigitYear(year));
            }
            if (year > MaxCalendarYear) {
                throw new ArgumentOutOfRangeException("year",
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 1, MaxCalendarYear));
            }
            return (year);
        }            
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\japanesecalendar.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {

    using System;

    /*=================================JapaneseCalendar==========================
    **
    ** JapaneseCalendar is based on Gregorian calendar.  The month and day values are the same as
    ** Gregorian calendar.  However, the year value is an offset to the Gregorian
    ** year based on the era.
    **
    ** This system is adopted by Emperor Meiji in 1868. The year value is counted based on the reign of an emperor,
    ** and the era begins on the day an emperor ascends the throne and continues until his death.
    ** The era changes at 12:00AM.
    **
    ** For example, the current era is Heisei.  It started on 1989/1/8 A.D.  Therefore, Gregorian year 1989 is also Heisei 1st.
    ** 1989/1/8 A.D. is also Heisei 1st 1/8.
    ** 
    ** Any date in the year during which era is changed can be reckoned in either era.  For example,
    ** 1989/1/1 can be 1/1 Heisei 1st year or 1/1 Showa 64th year.
    **
    ** Note:
    **  The DateTime can be represented by the JapaneseCalendar are limited to two factors:
    **      1. The min value and max value of DateTime class.
    **      2. The available era information.
    **
    **  Calendar support range:
    **      Calendar    Minimum     Maximum
    **      ==========  ==========  ==========
    **      Gregorian   1869/09/08  9999/12/31
    **      Japanese    Meiji 01/01 Heisei 8011/12/31
    ============================================================================*/
    
    /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar"]/*' />
    [Serializable] public class JapaneseCalendar : Calendar {
        // m_EraInfo must be listed in reverse chronological order.  The most recent era
        // should be the first element.
        // That is, m_EraInfo[0] contains the most recent era.
        static internal EraInfo[] m_EraInfo;
        // The era value of the current era.

        static JapaneseCalendar() {
            m_EraInfo = GregorianCalendarHelper.InitEraInfo(Calendar.CAL_JAPAN);
        }

        internal static Calendar m_defaultInstance = null;
        internal GregorianCalendarHelper helper;

        /*=================================GetDefaultInstance==========================
        **Action: Internal method to provide a default intance of JapaneseCalendar.  Used by NLS+ implementation
        **       and other calendars.
        **Returns:
        **Arguments:
        **Exceptions:
        ============================================================================*/

        internal static Calendar GetDefaultInstance() {
            if (m_defaultInstance == null) {
                m_defaultInstance = new JapaneseCalendar();
            }
            return (m_defaultInstance);
        }
        
        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.JapaneseCalendar"]/*' />
        public JapaneseCalendar() {
            helper = new GregorianCalendarHelper(this, m_EraInfo);
        }

        internal override int ID {
            get {
                return (CAL_JAPAN);
            }
        }

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.AddMonths"]/*' />
        public override DateTime AddMonths(DateTime time, int months) {
            return (helper.AddMonths(time, months));
        }

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.AddYears"]/*' />
        public override DateTime AddYears(DateTime time, int years) {
            return (helper.AddYears(time, years));
        }
        
        /*=================================GetDaysInMonth==========================
        **Action: Returns the number of days in the month given by the year and month arguments. 
        **Returns: The number of days in the given month. 
        **Arguments: 
        **      year The year in Japanese calendar.
        **      month The month
        **      era     The Japanese era value.
        **Exceptions 
        **  ArgumentException  If month is less than 1 or greater * than 12.
        ============================================================================*/
        
        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.GetDaysInMonth"]/*' />
        public override int GetDaysInMonth(int year, int month, int era) {
            return (helper.GetDaysInMonth(year, month, era));
        }

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.GetDaysInYear"]/*' />
        public override int GetDaysInYear(int year, int era) {
            return (helper.GetDaysInYear(year, era));
        }

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.GetDayOfMonth"]/*' />
        public override int GetDayOfMonth(DateTime time) {
            return (helper.GetDayOfMonth(time));
        }

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.GetDayOfWeek"]/*' />
        public override DayOfWeek GetDayOfWeek(DateTime time)  {
            return (helper.GetDayOfWeek(time));
        }

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.GetDayOfYear"]/*' />
        public override int GetDayOfYear(DateTime time)
        {
            return (helper.GetDayOfYear(time));
        }

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.GetMonthsInYear"]/*' />
        public override int GetMonthsInYear(int year, int era) {
            return (helper.GetMonthsInYear(year, era));
        }
        
        /*=================================GetEra==========================
        **Action: Get the era value of the specified time.
        **Returns: The era value for the specified time.
        **Arguments:
        **      time the specified date time.
        **Exceptions: ArgumentOutOfRangeException if time is out of the valid era ranges.
        ============================================================================*/

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.GetEra"]/*' />
        public override int GetEra(DateTime time) {
            return (helper.GetEra(time));
        }

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.GetMonth"]/*' />
        public override int GetMonth(DateTime time) {
            return (helper.GetMonth(time));
            }

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.GetYear"]/*' />
        public override int GetYear(DateTime time) {
            return (helper.GetYear(time));
        }

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.IsLeapDay"]/*' />
        public override bool IsLeapDay(int year, int month, int day, int era)
        {
            return (helper.IsLeapDay(year, month, day, era));
        }

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.IsLeapYear"]/*' />
        public override bool IsLeapYear(int year, int era) {
            return (helper.IsLeapYear(year, era));
        }            

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.IsLeapMonth"]/*' />
        public override bool IsLeapMonth(int year, int month, int era) {
            return (helper.IsLeapMonth(year, month, era));
        }
        
        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.ToDateTime"]/*' />
        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) {
            return (helper.ToDateTime(year, month, day, hour, minute, second, millisecond, era));
        }

        // For Japanese calendar, four digit year is not used.  Few emperors will live for more than one hundred years.
        // Therefore, for any two digit number, we just return the original number.
        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.ToFourDigitYear"]/*' />
        public override int ToFourDigitYear(int year) {
            if (year <= 0) {
                throw new ArgumentOutOfRangeException("year",
                    Environment.GetResourceString("ArgumentOutOfRange_NeedPosNum"));                
            }
            if (year > helper.MaxYear) {
                throw new ArgumentOutOfRangeException("year",
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 1, helper.MaxYear));
            }
            return (year);
        }            

        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.Eras"]/*' />
        public override int[] Eras {
            get {
                return (helper.Eras);
            }
        }       

        private const int DEFAULT_TWO_DIGIT_YEAR_MAX = 99;            
        
        /// <include file='doc\JapaneseCalendar.uex' path='docs/doc[@for="JapaneseCalendar.TwoDigitYearMax"]/*' />
        public override int TwoDigitYearMax {
            get {
                if (twoDigitYearMax == -1) {
                    twoDigitYearMax = GetSystemTwoDigitYearSetting(ID, DEFAULT_TWO_DIGIT_YEAR_MAX);
                }
                return (twoDigitYearMax);
            }

            set {
                if (value < 100 || value > helper.MaxYear) {
                    throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    100, helper.MaxYear));
                }
                twoDigitYearMax = value;
            }
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\nlsdataitem.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#if _USE_NLS_PLUS_TABLE
// When NLS+ tables are used, we don't need these data.
#else
namespace System.Globalization {
    
    //N.B.:  This is only visible internally.
	using System;
    [Serializable()]
    internal class NLSDataItem
    {	
        internal String  name;
        internal int     CultureID;                  // Culture ID used in NLS+ world.  See CultureInfo.cool for comments.
        internal int     Win32LangID;                // The Win32 LangID used to call Win32 NLS API.  See CultureInfo.cool for comments.
        internal String  LangNameTwoLetter;          // ISO639-1 language name. For example, the name for English is "en".
        internal String  LangNameThreeLetter;        // ISO639-2 language name. For example, the name for English is "eng".
        internal String  RegionName;                 // Two-letter ISO3166 Region name in lowercase.  For example, the name for US is "us".
        internal String  RegionNameTwoLetter;        // Two-letter ISO3166 Region name.  For example, the name for US is "US".
        internal String  RegionNameThreeLetter;      // Three-letter ISO3166 Region name.  For example, the name for US is "USA".
        internal int     percentNegativePattern;     // The negative percent pattern.  This is a int which spceifies one style in
                                            // negPercentFormats in VM\COMNumber.cpp
        internal int     percentPositivePattern;     // The negative percent pattern.  This is a int which spceifies one style in
                                            // posPercentFormats in VM\COMNumber.cpp
        internal String  percentSymbol;              // The percent symbol
        
        internal NLSDataItem(String name, int CultureID, int Win32LangID, String ISO639_1, String ISO639_2, String regionName, String ISO3166_1, String ISO3166_2,
            int percentNegativePattern, int percentPositivePattern, String percentSymbol)
        {
            this.name = name;
            this.CultureID = CultureID;
            this.Win32LangID = Win32LangID;
            this.LangNameTwoLetter = ISO639_1;
            this.LangNameThreeLetter = ISO639_2;
            this.RegionName = regionName;
            this.RegionNameTwoLetter = ISO3166_1;
            this.RegionNameThreeLetter = ISO3166_2;
            this.percentNegativePattern = percentNegativePattern;
            this.percentPositivePattern = percentPositivePattern;
            this.percentSymbol = percentSymbol;
        }
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\nlsdatatable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Class:    NLSDataTable
//
//  Author:   Yung-Shin Bala Lin (YSLin)
//
//  Purpose:  This class provides tables needed by CultureInfo and RegionInfo.
//            The table includes the data tables, hash tables, and collision
//            tables. The tables are generated by NLSTableBuilder.
//
//  Date:     April 15, 1999
//
////////////////////////////////////////////////////////////////////////////

#if _USE_NLS_PLUS_TABLE
// When NLS+ tables are used, we don't need these data.
#else
namespace System.Globalization {

    //All of these classes contain only static data and don't need to be serialized.
	using System;
    internal class NLSDataTable
    {
        internal static NLSDataItem[] _dataTable =
        {
            //               name     LCID WinLcid 639-1 639-2 regName 3166-13166-2 -%  % %sym
            new NLSDataItem( "\x0000", 0x0000, 0x0409, "en", "eng", null, "US", "USA", 0, 0, "%" ),

            new NLSDataItem( "ar"    , 0x0001, 0x0401, "ar", "ara", null, "SA", "SAU", 0, 0, "%" ),

            new NLSDataItem( "ar-sa" , 0x0401, 0x0401, "ar", "ara", "sa", "SA", "SAU", 0, 0, "%" ),

            new NLSDataItem( "ar-iq" , 0x0801, 0x0801, "ar", "ara", "iq", "IQ", "IRQ", 0, 0, "%" ),

            new NLSDataItem( "ar-eg" , 0x0c01, 0x0c01, "ar", "ara", "eg", "EG", "EGY", 0, 0, "%" ),

            new NLSDataItem( "ar-ly" , 0x1001, 0x1001, "ar", "ara", "ly", "LY", "LBY", 0, 0, "%" ),

            new NLSDataItem( "ar-dz" , 0x1401, 0x1401, "ar", "ara", "dz", "DZ", "DZA", 0, 0, "%" ),

            new NLSDataItem( "ar-ma" , 0x1801, 0x1801, "ar", "ara", "ma", "MA", "MAR", 0, 0, "%" ),

            new NLSDataItem( "ar-tn" , 0x1c01, 0x1c01, "ar", "ara", "tn", "TN", "TUN", 0, 0, "%" ),

            new NLSDataItem( "ar-om" , 0x2001, 0x2001, "ar", "ara", "om", "OM", "OMN", 0, 0, "%" ),

            new NLSDataItem( "ar-ye" , 0x2401, 0x2401, "ar", "ara", "ye", "YE", "YEM", 0, 0, "%" ),

            new NLSDataItem( "ar-sy" , 0x2801, 0x2801, "ar", "ara", "sy", "SY", "SYR", 0, 0, "%" ),

            new NLSDataItem( "ar-jo" , 0x2c01, 0x2c01, "ar", "ara", "jo", "JO", "JOR", 0, 0, "%" ),

            new NLSDataItem( "ar-lb" , 0x3001, 0x3001, "ar", "ara", "lb", "LB", "LBN", 0, 0, "%" ),

            new NLSDataItem( "ar-kw" , 0x3401, 0x3401, "ar", "ara", "kw", "KW", "KWT", 0, 0, "%" ),

            new NLSDataItem( "ar-ae" , 0x3801, 0x3801, "ar", "ara", "ae", "AE", "ARE", 0, 0, "%" ),

            new NLSDataItem( "ar-bh" , 0x3c01, 0x3c01, "ar", "ara", "bh", "BH", "BHR", 0, 0, "%" ),

            new NLSDataItem( "ar-qa" , 0x4001, 0x4001, "ar", "ara", "qa", "QA", "QAT", 0, 0, "%" ),

            new NLSDataItem( "bg"    , 0x0002, 0x0402, "bg", "bul", null, "BG", "BGR", 0, 0, "%" ),

            new NLSDataItem( "bg-bg" , 0x0402, 0x0402, "bg", "bul", "bg", "BG", "BGR", 0, 0, "%" ),

            new NLSDataItem( "ca"    , 0x0003, 0x0403, "ca", "cat", null, "ES", "ESP", 0, 0, "%" ),

            new NLSDataItem( "ca-es" , 0x0403, 0x0403, "ca", "cat", "es", "ES", "ESP", 0, 0, "%" ),

            new NLSDataItem( "zh"    , 0x0004, 0x0804, "zh", "zho", null, "TW", "TWN", 0, 0, "%" ),

            new NLSDataItem( "zh-tw" , 0x0404, 0x0404, "zh", "zho", "tw", "TW", "TWN", 0, 0, "%" ),

            new NLSDataItem( "zh-cn" , 0x0804, 0x0804, "zh", "zho", "cn", "CN", "CHN", 0, 0, "%" ),

            new NLSDataItem( "zh-hk" , 0x0c04, 0x0c04, "zh", "zho", "hk", "HK", "HKG", 0, 0, "%" ),

            new NLSDataItem( "zh-sg" , 0x1004, 0x1004, "zh", "zho", "sg", "SG", "SGP", 0, 0, "%" ),

            new NLSDataItem( "zh-mo" , 0x1404, 0x1404, "zh", "zho", "mo", "MO", "MCO", 0, 0, "%" ),

            new NLSDataItem( "cs"    , 0x0005, 0x0405, "cs", "ces", null, "CZ", "CZE", 0, 0, "%" ),

            new NLSDataItem( "cs-cz" , 0x0405, 0x0405, "cs", "ces", "cz", "CZ", "CZE", 0, 0, "%" ),

            new NLSDataItem( "da"    , 0x0006, 0x0406, "da", "dan", null, "DK", "DNK", 0, 0, "%" ),

            new NLSDataItem( "da-dk" , 0x0406, 0x0406, "da", "dan", "dk", "DK", "DNK", 0, 0, "%" ),

            new NLSDataItem( "de"    , 0x0007, 0x0407, "de", "deu", null, "DE", "DEU", 0, 0, "%" ),

            new NLSDataItem( "de-de" , 0x0407, 0x0407, "de", "deu", "de", "DE", "DEU", 0, 0, "%" ),

            new NLSDataItem( "de-ch" , 0x0807, 0x0807, "de", "deu", "ch", "CH", "CHE", 1, 1, "%" ),

            new NLSDataItem( "de-at" , 0x0c07, 0x0c07, "de", "deu", "at", "AT", "AUT", 0, 0, "%" ),

            new NLSDataItem( "de-lu" , 0x1007, 0x1007, "de", "deu", "lu", "LU", "LUX", 0, 0, "%" ),

            new NLSDataItem( "de-li" , 0x1407, 0x1407, "de", "deu", "li", "LI", "LIE", 0, 0, "%" ),

            new NLSDataItem( "el"    , 0x0008, 0x0408, "el", "ell", null, "GR", "GRC", 0, 0, "%" ),

            new NLSDataItem( "el-gr" , 0x0408, 0x0408, "el", "ell", "gr", "GR", "GRC", 0, 0, "%" ),

            new NLSDataItem( "en"    , 0x0009, 0x0409, "en", "eng", null, "US", "USA", 0, 0, "%" ),

            new NLSDataItem( "en-us" , 0x0409, 0x0409, "en", "eng", "us", "US", "USA", 0, 0, "%" ),

            new NLSDataItem( "en-gb" , 0x0809, 0x0809, "en", "eng", "gb", "GB", "GBR", 0, 0, "%" ),

            new NLSDataItem( "en-au" , 0x0c09, 0x0c09, "en", "eng", "au", "AU", "AUS", 0, 0, "%" ),

            new NLSDataItem( "en-ca" , 0x1009, 0x1009, "en", "eng", "ca", "CA", "CAN", 0, 0, "%" ),

            new NLSDataItem( "en-nz" , 0x1409, 0x1409, "en", "eng", "nz", "NZ", "NZL", 0, 0, "%" ),

            new NLSDataItem( "en-ie" , 0x1809, 0x1809, "en", "eng", "ie", "IE", "IRL", 0, 0, "%" ),

            new NLSDataItem( "en-za" , 0x1c09, 0x1c09, "en", "eng", "za", "ZA", "ZAF", 1, 1, "%" ),

            new NLSDataItem( "en-jm" , 0x2009, 0x2009, "en", "eng", "jm", "JM", "JAM", 0, 0, "%" ),

            new NLSDataItem( "en-cb" , 0x2409, 0x2409, "en", "eng", "cb", "CB", "CAR", 0, 0, "%" ),

            new NLSDataItem( "en-bz" , 0x2809, 0x2809, "en", "eng", "bz", "BZ", "BLZ", 0, 0, "%" ),

            new NLSDataItem( "en-tt" , 0x2c09, 0x2c09, "en", "eng", "tt", "TT", "TTO", 0, 0, "%" ),

            new NLSDataItem( "en-zw" , 0x3009, 0x3009, "en", "eng", "zw", "ZW", "ZWE", 0, 0, "%" ),

            new NLSDataItem( "en-ph" , 0x3409, 0x3409, "en", "eng", "ph", "PH", "PHL", 0, 0, "%" ),

            new NLSDataItem( "es"    , 0x000a, 0x040a, "es", "spa", null, "ES", "ESP", 0, 0, "%" ),

            new NLSDataItem( "es-es" , 0x040a, 0x040a, "es", "spa", null, "ES", "ESP", 0, 0, "%" ),

            new NLSDataItem( "es-mx" , 0x080a, 0x080a, "es", "spa", "mx", "MX", "MEX", 0, 0, "%" ),

            new NLSDataItem( "es-es2", 0x0c0a, 0x0c0a, "es", "spa", null, "ES", "ESP", 0, 0, "%" ),

            new NLSDataItem( "es-gt" , 0x100a, 0x100a, "es", "spa", "gt", "GT", "GTM", 0, 0, "%" ),

            new NLSDataItem( "es-cr" , 0x140a, 0x140a, "es", "spa", "cr", "CR", "CRI", 0, 0, "%" ),

            new NLSDataItem( "es-pa" , 0x180a, 0x180a, "es", "spa", "pa", "PA", "PAN", 0, 0, "%" ),

            new NLSDataItem( "es-do" , 0x1c0a, 0x1c0a, "es", "spa", "do", "DO", "DOM", 0, 0, "%" ),

            new NLSDataItem( "es-ve" , 0x200a, 0x200a, "es", "spa", "ve", "VE", "VEN", 0, 0, "%" ),

            new NLSDataItem( "es-co" , 0x240a, 0x240a, "es", "spa", "co", "CO", "COL", 0, 0, "%" ),

            new NLSDataItem( "es-pe" , 0x280a, 0x280a, "es", "spa", "pe", "PE", "PER", 0, 0, "%" ),

            new NLSDataItem( "es-ar" , 0x2c0a, 0x2c0a, "es", "spa", "ar", "AR", "ARG", 0, 0, "%" ),

            new NLSDataItem( "es-ec" , 0x300a, 0x300a, "es", "spa", "ec", "EC", "ECU", 0, 0, "%" ),

            new NLSDataItem( "es-cl" , 0x340a, 0x340a, "es", "spa", "cl", "CL", "CHL", 0, 0, "%" ),

            new NLSDataItem( "es-uy" , 0x380a, 0x380a, "es", "spa", "uy", "UY", "URY", 0, 0, "%" ),

            new NLSDataItem( "es-py" , 0x3c0a, 0x3c0a, "es", "spa", "py", "PY", "PRY", 0, 0, "%" ),

            new NLSDataItem( "es-bo" , 0x400a, 0x400a, "es", "spa", "bo", "BO", "BOL", 0, 0, "%" ),

            new NLSDataItem( "es-sv" , 0x440a, 0x440a, "es", "spa", "sv", "SV", "SLV", 0, 0, "%" ),

            new NLSDataItem( "es-hn" , 0x480a, 0x480a, "es", "spa", "hn", "HN", "HND", 0, 0, "%" ),

            new NLSDataItem( "es-ni" , 0x4c0a, 0x4c0a, "es", "spa", "ni", "NI", "NIC", 0, 0, "%" ),

            new NLSDataItem( "es-pr" , 0x500a, 0x500a, "es", "spa", "pr", "PR", "PRI", 0, 0, "%" ),

            new NLSDataItem( "fi"    , 0x000b, 0x040b, "fi", "fin", null, "FI", "FIN", 0, 0, "%" ),

            new NLSDataItem( "fi-fi" , 0x040b, 0x040b, "fi", "fin", "fi", "FI", "FIN", 0, 0, "%" ),

            new NLSDataItem( "fr"    , 0x000c, 0x040c, "fr", "fra", null, "FR", "FRA", 0, 0, "%" ),

            new NLSDataItem( "fr-fr" , 0x040c, 0x040c, "fr", "fra", "fr", "FR", "FRA", 0, 0, "%" ),

            new NLSDataItem( "fr-be" , 0x080c, 0x080c, "fr", "fra", "be", "BE", "BEL", 0, 0, "%" ),

            new NLSDataItem( "fr-ca" , 0x0c0c, 0x0c0c, "fr", "fra", null, "CA", "CAN", 0, 0, "%" ),

            new NLSDataItem( "fr-ch" , 0x100c, 0x100c, "fr", "fra", null, "CH", "CHE", 1, 1, "%" ),

            new NLSDataItem( "fr-lu" , 0x140c, 0x140c, "fr", "fra", null, "LU", "LUX", 0, 0, "%" ),

            new NLSDataItem( "fr-mc" , 0x180c, 0x180c, "fr", "fra", "mc", "MC", "MCO", 0, 0, "%" ),

            new NLSDataItem( "he"    , 0x000d, 0x040d, "iw", "iku", null, "IL", "ISR", 0, 0, "%" ),

            new NLSDataItem( "he-il" , 0x040d, 0x040d, "iw", "iku", "il", "IL", "ISR", 1, 1, "%" ),

            new NLSDataItem( "hu"    , 0x000e, 0x040e, "hu", "hun", null, "HU", "HUN", 0, 0, "%" ),

            new NLSDataItem( "hu-hu" , 0x040e, 0x040e, "hu", "hun", "hu", "HU", "HUN", 0, 0, "%" ),

            new NLSDataItem( "is"    , 0x000f, 0x040f, "is", "isl", null, "IS", "ISL", 0, 0, "%" ),

            new NLSDataItem( "is-is" , 0x040f, 0x040f, "is", "isl", "is", "IS", "ISL", 1, 1, "%" ),

            new NLSDataItem( "it"    , 0x0010, 0x0410, "it", "ita", null, "IT", "ITA", 0, 0, "%" ),

            new NLSDataItem( "it-it" , 0x0410, 0x0410, "it", "ita", "it", "IT", "ITA", 0, 0, "%" ),

            new NLSDataItem( "it-ch" , 0x0810, 0x0810, "it", "ita", null, "CH", "CHE", 1, 1, "%" ),

            new NLSDataItem( "ja"    , 0x0011, 0x0411, "ja", "jpn", null, "JP", "JPN", 0, 0, "%" ),

            new NLSDataItem( "ja-jp" , 0x0411, 0x0411, "ja", "jpn", "jp", "JP", "JPN", 0, 0, "%" ),

            new NLSDataItem( "ko"    , 0x0012, 0x0412, "ko", "kor", null, "KR", "KOR", 0, 0, "%" ),

            new NLSDataItem( "ko-kr" , 0x0412, 0x0412, "ko", "kor", "kr", "KR", "KOR", 0, 0, "%" ),

            new NLSDataItem( "nl"    , 0x0013, 0x0413, "nl", "nld", null, "NL", "NLD", 0, 0, "%" ),

            new NLSDataItem( "nl-nl" , 0x0413, 0x0413, "nl", "nld", "nl", "NL", "NLD", 0, 0, "%" ),

            new NLSDataItem( "nl-be" , 0x0813, 0x0813, "nl", "nld", null, "BE", "BEL", 0, 0, "%" ),

            new NLSDataItem( "no"    , 0x0014, 0x0414, "no", "nor", null, "NO", "NOR", 0, 0, "%" ),

            new NLSDataItem( "no-no" , 0x0414, 0x0414, "no", "nor", "no", "NO", "NOR", 0, 0, "%" ),

            new NLSDataItem( "no-bok", 0x0814, 0x0814, "no", "nor", null, "NO", "NOR", 0, 0, "%" ),

            new NLSDataItem( "pl"    , 0x0015, 0x0415, "pl", "pol", null, "PL", "POL", 0, 0, "%" ),

            new NLSDataItem( "pl-pl" , 0x0415, 0x0415, "pl", "pol", "pl", "PL", "POL", 0, 0, "%" ),

            new NLSDataItem( "pt"    , 0x0016, 0x0416, "pt", "por", null, "BR", "BRA", 0, 0, "%" ),

            new NLSDataItem( "pt-br" , 0x0416, 0x0416, "pt", "por", "br", "BR", "BRA", 1, 1, "%" ),

            new NLSDataItem( "pt-pt" , 0x0816, 0x0816, "pt", "por", "pt", "PT", "PRT", 0, 0, "%" ),

            new NLSDataItem( "ro"    , 0x0018, 0x0418, "ro", "ron", null, "RO", "ROM", 0, 0, "%" ),

            new NLSDataItem( "ro-ro" , 0x0418, 0x0418, "ro", "ron", "ro", "RO", "ROM", 0, 0, "%" ),

            new NLSDataItem( "ru"    , 0x0019, 0x0419, "ru", "rus", null, "RU", "RUS", 0, 0, "%" ),

            new NLSDataItem( "ru-ru" , 0x0419, 0x0419, "ru", "rus", "ru", "RU", "RUS", 0, 0, "%" ),

            new NLSDataItem( "hr"    , 0x001a, 0x041a, "hr", "hrv", null, "HR", "HRV", 0, 0, "%" ),

            new NLSDataItem( "hr-hr" , 0x041a, 0x041a, "hr", "hrv", "hr", "HR", "HRV", 0, 0, "%" ),

            new NLSDataItem( "sr"    , 0x081a, 0x081a, "sr", "srp", "sp", "SP", "SPB", 0, 0, "%" ),

            new NLSDataItem( "sr-sp" , 0x0c1a, 0x0c1a, "sr", "srp", null, "SP", "SPB", 0, 0, "%" ),

            new NLSDataItem( "sk"    , 0x001b, 0x041b, "sk", "slk", null, "SK", "SVK", 0, 0, "%" ),

            new NLSDataItem( "sk-sk" , 0x041b, 0x041b, "sk", "slk", "sk", "SK", "SVK", 0, 0, "%" ),

            new NLSDataItem( "sq"    , 0x001c, 0x041c, "sq", "sqi", null, "AL", "ALB", 0, 0, "%" ),

            new NLSDataItem( "sq-al" , 0x041c, 0x041c, "sq", "sqi", "al", "AL", "ALB", 0, 0, "%" ),

            new NLSDataItem( "sv"    , 0x001d, 0x041d, "sv", "swe", null, "SE", "SWE", 0, 0, "%" ),

            new NLSDataItem( "sv-se" , 0x041d, 0x041d, "sv", "swe", "se", "SE", "SWE", 0, 0, "%" ),

            new NLSDataItem( "sv-fi" , 0x081d, 0x081d, "sv", "swe", null, "FI", "FIN", 0, 0, "%" ),

            new NLSDataItem( "th"    , 0x001e, 0x041e, "th", "tha", null, "TH", "THA", 0, 0, "%" ),

            new NLSDataItem( "th-th" , 0x041e, 0x041e, "th", "tha", "th", "TH", "THA", 0, 0, "%" ),

            new NLSDataItem( "tr"    , 0x001f, 0x041f, "tr", "tgl", null, "TR", "TUR", 0, 0, "%" ),

            new NLSDataItem( "tr-tr" , 0x041f, 0x041f, "tr", "tgl", "tr", "TR", "TUR", 2, 2, "%" ),

            new NLSDataItem( "ur"    , 0x0020, 0x0420, "ur", "urd", null, "PK", "PAK", 0, 0, "%" ),

            new NLSDataItem( "ur-pk" , 0x0420, 0x0420, "ur", "urd", "pk", "PK", "PAK", 0, 0, "%" ),

            new NLSDataItem( "id"    , 0x0021, 0x0421, "id", "ina", null, "ID", "IDN", 0, 0, "%" ),

            new NLSDataItem( "id-id" , 0x0421, 0x0421, "id", "ina", "id", "ID", "IDN", 0, 0, "%" ),

            new NLSDataItem( "uk"    , 0x0022, 0x0422, "uk", "ukr", null, "UA", "UKR", 0, 0, "%" ),

            new NLSDataItem( "uk-ua" , 0x0422, 0x0422, "uk", "ukr", "ua", "UA", "UKR", 0, 0, "%" ),

            new NLSDataItem( "be"    , 0x0023, 0x0423, "be", "bel", null, "BY", "BLR", 0, 0, "%" ),

            new NLSDataItem( "be-by" , 0x0423, 0x0423, "be", "bel", "by", "BY", "BLR", 0, 0, "%" ),

            new NLSDataItem( "sl"    , 0x0024, 0x0424, "sl", "slv", null, "SI", "SVN", 0, 0, "%" ),

            new NLSDataItem( "sl-si" , 0x0424, 0x0424, "sl", "slv", "si", "SI", "SVN", 0, 0, "%" ),

            new NLSDataItem( "et"    , 0x0025, 0x0425, "et", "est", null, "EE", "EST", 0, 0, "%" ),

            new NLSDataItem( "et-ee" , 0x0425, 0x0425, "et", "est", "ee", "EE", "EST", 0, 0, "%" ),

            new NLSDataItem( "lv"    , 0x0026, 0x0426, "lv", "lav", null, "LV", "LVA", 0, 0, "%" ),

            new NLSDataItem( "lv-lv" , 0x0426, 0x0426, "lv", "lav", "lv", "LV", "LVA", 0, 0, "%" ),

            new NLSDataItem( "lt"    , 0x0027, 0x0427, "lt", "lit", null, "LT", "LTU", 0, 0, "%" ),

            new NLSDataItem( "lt-lt" , 0x0427, 0x0427, "lt", "lit", "lt", "LT", "LTU", 0, 0, "%" ),

            new NLSDataItem( "fa"    , 0x0029, 0x0429, "fa", "fas", null, "IR", "IRN", 0, 0, "%" ),

            new NLSDataItem( "fa-ir" , 0x0429, 0x0429, "fa", "fas", "ir", "IR", "IRN", 0, 0, "%" ),

            new NLSDataItem( "vi"    , 0x002a, 0x042a, "vi", "vie", null, "VN", "VNM", 0, 0, "%" ),

            new NLSDataItem( "vi-vn" , 0x042a, 0x042a, "vi", "vie", "vn", "VN", "VNM", 0, 0, "%" ),

            new NLSDataItem( "hy"    , 0x002b, 0x042b, "hy", "hye", null, "am", "ARM", 0, 0, "%" ),

            new NLSDataItem( "hy-am" , 0x042b, 0x042b, "hy", "hye", "am", "am", "ARM", 0, 0, "%" ),

            new NLSDataItem( "az"    , 0x002c, 0x042c, "az", "aze", null, "AZ", "AZE", 0, 0, "%" ),

            new NLSDataItem( "az-az" , 0x042c, 0x042c, "az", "aze", "az", "AZ", "AZE", 0, 0, "%" ),

            new NLSDataItem( "az-az2", 0x082c, 0x082c, "az", "aze", null, "AZ", "AZE", 0, 0, "%" ),

            new NLSDataItem( "eu"    , 0x002d, 0x042d, "eu", "eus", null, "ES", "ESP", 0, 0, "%" ),

            new NLSDataItem( "eu-es" , 0x042d, 0x042d, "eu", "eus", null, "ES", "ESP", 0, 0, "%" ),

            new NLSDataItem( "mk"    , 0x002f, 0x042f, "mk", "mkd", null, "MK", "MKD", 0, 0, "%" ),

            new NLSDataItem( "mk-mk" , 0x042f, 0x042f, "mk", "mkd", "mk", "MK", "MKD", 0, 0, "%" ),

            new NLSDataItem( "af"    , 0x0036, 0x0436, "af", "afr", null, "ZA", "ZAF", 0, 0, "%" ),

            new NLSDataItem( "af-za" , 0x0436, 0x0436, "af", "afr", null, "ZA", "ZAF", 1, 1, "%" ),

            new NLSDataItem( "ka"    , 0x0037, 0x0437, "ka", "kat", null, "GE", "GEO", 0, 0, "%" ),

            new NLSDataItem( "ka-ge" , 0x0437, 0x0437, "ka", "kat", "ge", "GE", "GEO", 0, 0, "%" ),

            new NLSDataItem( "fo"    , 0x0038, 0x0438, "fo", "fao", null, "FO", "FRO", 0, 0, "%" ),

            new NLSDataItem( "fo-fo" , 0x0438, 0x0438, "fo", "fao", "fo", "FO", "FRO", 0, 0, "%" ),

            new NLSDataItem( "hi"    , 0x0039, 0x0439, "hi", "hin", null, "IN", "IND", 0, 0, "%" ),

            new NLSDataItem( "hi-in" , 0x0439, 0x0439, "hi", "hin", "in", "IN", "IND", 0, 0, "%" ),

            new NLSDataItem( "ms"    , 0x003e, 0x043e, "ms", "msa", null, "MY", "MYS", 0, 0, "%" ),

            new NLSDataItem( "ms-my" , 0x043e, 0x043e, "ms", "msa", "my", "MY", "MYS", 0, 0, "%" ),

            new NLSDataItem( "ms-br" , 0x083e, 0x083e, "ms", "msa", "bn", "BN", "BRN", 0, 0, "%" ),

            new NLSDataItem( "kk"    , 0x003f, 0x043f, "kk", "kaz", null, "KZ", "KAZ", 0, 0, "%" ),

            new NLSDataItem( "kk-kz" , 0x043f, 0x043f, "kk", "kaz", "kz", "KZ", "KAZ", 0, 0, "%" ),

            new NLSDataItem( "sw"    , 0x0041, 0x0441, "sw", "swa", null, "KE", "KEN", 0, 0, "%" ),

            new NLSDataItem( "sw-ke" , 0x0441, 0x0441, "sw", "swa", "ke", "KE", "KEN", 0, 0, "%" ),

            new NLSDataItem( "uz"    , 0x0043, 0x0443, "uz", "uzb", null, "UZ", "UZB", 0, 0, "%" ),

            new NLSDataItem( "uz-uz" , 0x0443, 0x0443, "uz", "uzb", "uz", "UZ", "UZB", 0, 0, "%" ),

            new NLSDataItem( "uz-uz2", 0x0843, 0x0843, "uz", "uzb", null, "UZ", "UZS", 0, 0, "%" ),

            new NLSDataItem( "tt"    , 0x0044, 0x0444, "tt", "tat", null, "TA", "TAT", 0, 0, "%" ),

            new NLSDataItem( "tt-ta" , 0x0444, 0x0444, "tt", "tat", "ta", "TA", "TAT", 0, 0, "%" ),

            new NLSDataItem( "ta"    , 0x0049, 0x0449, "ta", "tam", null, "IN", "IND", 0, 0, "%" ),

            new NLSDataItem( "ta-in" , 0x0449, 0x0449, "ta", "tam", null, "IN", "IND", 0, 0, "%" ),

            new NLSDataItem( "mr"    , 0x004e, 0x044e, "mr", "mar", null, "IN", "IND", 0, 0, "%" ),

            new NLSDataItem( "mr-in" , 0x044e, 0x044e, "mr", "mar", null, "IN", "IND", 0, 0, "%" ),

            new NLSDataItem( "sa"    , 0x004f, 0x044f, "sa", "san", null, "IN", "IND", 0, 0, "%" ),

            new NLSDataItem( "sa-in" , 0x044f, 0x044f, "sa", "san", null, "IN", "IND", 0, 0, "%" ),

            new NLSDataItem( "hi2"   , 0x0057, 0x0457, "hi", "hin", null, "IN", "IND", 0, 0, "%" ),

            new NLSDataItem( "hi-kok", 0x0457, 0x0457, "hi", "hin", null, "IN", "IND", 0, 0, "%" ),
        };

        ////////////////////////////////////////////////////////////////////////
        //
        // Get a NLSDataItem in NLSDataTable._dataTable by given a culture name.
        //
        ////////////////////////////////////////////////////////////////////////

        internal static int GetDataFromCultureName(String name)
        {

            BCLDebug.Assert(name!=null,"name!=null");

            for (int i = 0; i < _dataTable.Length; i++) {
                if (name.Equals(_dataTable[i].name)) {
                    return (i);
                }
            }

            return (-1);
        }


        ////////////////////////////////////////////////////////////////////////
        //
        // Get a NLSDataItem in NLSDataTable._dataTable by given a LCID.
        //
        ////////////////////////////////////////////////////////////////////////

        internal static int GetDataFromCultureID(int culture)
        {
            for (int i = 0; i < _dataTable.Length; i++) {
                if (culture == _dataTable[i].CultureID) {
                    return (i);
                }
            }

            return (-1);
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // Get a NLSDataItem in NLSDataTable._dataTable by given a LCID.
        //
        ////////////////////////////////////////////////////////////////////////

        internal static int GetDataFromRegionID(int region)
        {
            for (int i = 0; i < _dataTable.Length; i++) {
                if (region == _dataTable[i].CultureID) {
                    if (_dataTable[i].RegionName != null) {
                        return (i);
                    } else {
                        return (-1);
                    }
                }
            }

            return (-1);
        }
        
        ////////////////////////////////////////////////////////////////////////
        //
        // Given a region name in the format of "us", get the NLSDataItem for that
        // region.
        //
        ////////////////////////////////////////////////////////////////////////

        internal static int GetDataFromRegionName(String name)
        {
            int len = _dataTable.Length;
            for (int i = 0; i < len; i++)
            {
                if (name.Equals(_dataTable[i].RegionName))
                {
                    return (i);
                }
            }
            
            return (-1);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\juliancalendar.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
    
    using System;
    // 
    // This class implements the Julian calendar. In 48 B.C. Julius Caesar ordered a calendar reform, and this calendar
    // is called Julian calendar. It consisted of a solar year of twelve months and of 365 days with an extra day 
    // every fourth year.
    //
    //  Calendar support range:
    //      Calendar    Minimum     Maximum
    //      ==========  ==========  ==========
    //      Gregorian   0001/01/01   9999/12/31
    //      Julian      0001/01/03   9999/10/19
    /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar"]/*' />
    [Serializable]
    public class JulianCalendar : Calendar {

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.JulianEra"]/*' />
        public static readonly int JulianEra = 1;

        internal const int DatePartYear = 0;
        internal const int DatePartDayOfYear = 1;
        internal const int DatePartMonth = 2;
        internal const int DatePartDay = 3;    

        // Number of days in a non-leap year
        private const int JulianDaysPerYear      = 365;
        // Number of days in 4 years
        private const int JulianDaysPer4Years    = JulianDaysPerYear * 4 + 1;
        
        internal static Calendar m_defaultInstance = null;

        internal static readonly int[] DaysToMonth365 = 
        {
            0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
        };
        
        internal static readonly int[] DaysToMonth366 = 
        {
            0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366
        };

        // Gregorian Calendar 9999/12/31 = Julian Calendar 9999/10/19
        internal int MaxYear = 9999;

        /*=================================GetDefaultInstance==========================
        **Action: Internal method to provide a default intance of JulianCalendar.  Used by NLS+ implementation
        **       and other calendars.
        **Returns:
        **Arguments:
        **Exceptions:
        ============================================================================*/

        internal static Calendar GetDefaultInstance() {
            if (m_defaultInstance == null) {
                m_defaultInstance = new JulianCalendar();
            }
            return (m_defaultInstance);
        }
        
        // Construct an instance of gregorian calendar.
        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.JulianCalendar"]/*' />
        public JulianCalendar() {
            // There is no system setting of TwoDigitYear max, so set the value here.
            twoDigitYearMax = 2029;
        }

        internal override int ID {
            get {
                return (CAL_JULIAN);
            }
        }
        
        internal void CheckYearEraRange(int year, int era) {
            if (era != CurrentEra && era != JulianEra) {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidEraValue"));            
            }
            if (year <= 0 || year > MaxYear) {
                throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                    1, MaxYear));            
            }
        }

        internal void CheckMonthRange(int month) {
            if (month < 1 || month > 12) {
                throw new ArgumentOutOfRangeException("month", Environment.GetResourceString("ArgumentOutOfRange_Month"));
            }
        }

        /*=================================GetDefaultInstance==========================
        **Action: Check for if the day value is valid.
        **Returns:
        **Arguments:
        **Exceptions:
        **Notes:
        **  Before calling this method, call CheckYearEraRange()/CheckMonthRange() to make
        **  sure year/month values are correct.
        ============================================================================*/
        
        internal void CheckDayRange(int year, int month, int day) {
            if (year == 1 && month == 1)
            {
                // The mimimum supported Julia date is Julian 0001/01/03.
                if (day < 3) {
                    throw new ArgumentOutOfRangeException(
                        Environment.GetResourceString("ArgumentOutOfRange_BadYearMonthDay"));
                }
            }
            bool isLeapYear = (year % 4) == 0;
            int[] days = isLeapYear ? DaysToMonth366 : DaysToMonth365;
            int monthDays = days[month] - days[month - 1];
            if (day < 1 || day > monthDays) {
                throw new ArgumentOutOfRangeException("day", 
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    1, monthDays));  
            }
        }
        
        
        // Returns a given date part of this DateTime. This method is used
        // to compute the year, day-of-year, month, or day part.
        internal int GetDatePart(long ticks, int part) 
        {
            // Gregorian 1/1/0001 is Julian 1/3/0001. Remember DateTime(0) is refered to Gregorian 1/1/0001.
            // The following line convert Gregorian ticks to Julian ticks.
            long julianTicks = ticks + TicksPerDay * 2;
            // n = number of days since 1/1/0001
            int n = (int)(julianTicks / TicksPerDay);
            // y4 = number of whole 4-year periods within 100-year period
            int y4 = n / JulianDaysPer4Years;
            // n = day number within 4-year period
            n -= y4 * JulianDaysPer4Years;
            // y1 = number of whole years within 4-year period
            int y1 = n / JulianDaysPerYear;
            // Last year has an extra day, so decrement result if 4
            if (y1 == 4) y1 = 3;        
            // If year was requested, compute and return it
            if (part == DatePartYear) 
            {
                return (y4 * 4 + y1 + 1);
            }
            // n = day number within year
            n -= y1 * JulianDaysPerYear;
            // If day-of-year was requested, return it
            if (part == DatePartDayOfYear) 
            {
                return (n + 1);
            }
            // Leap year calculation looks different from IsLeapYear since y1, y4,
            // and y100 are relative to year 1, not year 0
            bool leapYear = (y1 == 3);
            int[] days = leapYear? DaysToMonth366: DaysToMonth365;
            // All months have less than 32 days, so n >> 5 is a good conservative
            // estimate for the month
            int m = n >> 5 + 1;
            // m = 1-based month number
            while (n >= days[m]) m++;
            // If month was requested, return it
            if (part == DatePartMonth) return (m);
            // Return 1-based day-of-month
            return (n - days[m - 1] + 1);
        }        

        // Returns the tick count corresponding to the given year, month, and day.
        internal long DateToTicks(int year, int month, int day) 
        {
            int[] days = (year % 4 == 0)? DaysToMonth366: DaysToMonth365;
            int y = year - 1;
            int n = y * 365 + y / 4 + days[month - 1] + day - 1;
            // Gregorian 1/1/0001 is Julian 1/3/0001. n * TicksPerDay is the ticks in JulianCalendar.
            // Therefore, we subtract two days in the following to convert the ticks in JulianCalendar
            // to ticks in Gregorian calendar.
            return ((n - 2) * TicksPerDay);
        }
        
        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.AddMonths"]/*' />
        public override DateTime AddMonths(DateTime time, int months) 
        {
            if (months < -120000 || months > 120000) {
                throw new ArgumentOutOfRangeException(
                    "months", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    -120000, 120000));
            }
            int y = GetDatePart(time.Ticks, DatePartYear);
            int m = GetDatePart(time.Ticks, DatePartMonth);
            int d = GetDatePart(time.Ticks, DatePartDay);
            int i = m - 1 + months;
            if (i >= 0) {
                m = i % 12 + 1;
                y = y + i / 12;
            }
            else {
                m = 12 + (i + 1) % 12;
                y = y + (i - 11) / 12;
            }
            int[] daysArray = (y % 4 == 0 && (y % 100 != 0 || y % 400 == 0)) ? DaysToMonth366: DaysToMonth365;
            int days = (daysArray[m] - daysArray[m - 1]); 
            
            if (d > days) {
                d = days;
            }
            return (new DateTime(DateToTicks(y, m, d) + time.Ticks % TicksPerDay));
        }        

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.AddYears"]/*' />
        public override DateTime AddYears(DateTime time, int years) {
            return (AddMonths(time, years * 12));
        }

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.GetDayOfMonth"]/*' />
        public override int GetDayOfMonth(DateTime time) {
            return (GetDatePart(time.Ticks, DatePartDay));
        }

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.GetDayOfWeek"]/*' />
        public override DayOfWeek GetDayOfWeek(DateTime time) {
            return ((DayOfWeek)((int)(time.Ticks / TicksPerDay + 1) % 7));
        }

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.GetDayOfYear"]/*' />
        public override int GetDayOfYear(DateTime time) {
            return (GetDatePart(time.Ticks, DatePartDayOfYear));
        }

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.GetDaysInMonth"]/*' />
        public override int GetDaysInMonth(int year, int month, int era) {
            CheckYearEraRange(year, era);
            CheckMonthRange(month);
            int[] days = (year % 4 == 0) ? DaysToMonth366: DaysToMonth365;
            return (days[month] - days[month - 1]);        
        }

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.GetDaysInYear"]/*' />
        public override int GetDaysInYear(int year, int era) {
            // Year/Era range is done in IsLeapYear().
            return (IsLeapYear(year) ? 366:365);
        }

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.GetEra"]/*' />
        public override int GetEra(DateTime time)
        {
            return (JulianEra);
        }

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.GetMonth"]/*' />
        public override int GetMonth(DateTime time) 
        {
            return (GetDatePart(time.Ticks, DatePartMonth));
        }

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.Eras"]/*' />
        public override int[] Eras {
            get {
                return (new int[] {JulianEra});
            }
        }

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.GetMonthsInYear"]/*' />
        public override int GetMonthsInYear(int year, int era)
        {
            CheckYearEraRange(year, era);
            return (12);
        }    

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.GetYear"]/*' />
        public override int GetYear(DateTime time) 
        {
            return (GetDatePart(time.Ticks, DatePartYear));
        }    

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.IsLeapDay"]/*' />
        public override bool IsLeapDay(int year, int month, int day, int era)
        {
            CheckMonthRange(month);
            // Year/Era range check is done in IsLeapYear().
            if (IsLeapYear(year, era)) {
                CheckDayRange(year, month, day);
                return (month == 2 && day == 29);
            }
            CheckDayRange(year, month, day);
            return (false);
        }

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.IsLeapMonth"]/*' />
        public override bool IsLeapMonth(int year, int month, int era)
        {
            CheckYearEraRange(year, era);
            CheckMonthRange(month);
            return (false);            
        }    
    
        // Checks whether a given year in the specified era is a leap year. This method returns true if
        // year is a leap year, or false if not.
        //
        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.IsLeapYear"]/*' />
        public override bool IsLeapYear(int year, int era)
        {
            CheckYearEraRange(year, era);
            return (year % 4 == 0);
        }

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.ToDateTime"]/*' />
        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
        {
            CheckYearEraRange(year, era);
            CheckMonthRange(month);
            CheckDayRange(year, month, day);
            if (millisecond < 0 || millisecond >= MillisPerSecond) {
                throw new ArgumentOutOfRangeException("millisecond", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 0, MillisPerSecond - 1));
            }            
            
            if (hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >=0 && second < 60)
            {
                return new DateTime(DateToTicks(year, month, day) + (new TimeSpan(0, hour, minute, second, millisecond)).Ticks);
            } else
            {
                throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_BadHourMinuteSecond"));
            }
        }        

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.TwoDigitYearMax"]/*' />
        public override int TwoDigitYearMax {
            get {                
                return (twoDigitYearMax);
            }

            set {
                if (value < 100 || value > MaxYear) {
                    throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    100, MaxYear));

                }
                twoDigitYearMax = value;
            }
        } 

        /// <include file='doc\JulianCalendar.uex' path='docs/doc[@for="JulianCalendar.ToFourDigitYear"]/*' />
        public override int ToFourDigitYear(int year) {
            if (year > MaxYear) {
                throw new ArgumentOutOfRangeException("year",
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_Bounds_Lower_Upper"), 1, MaxYear)); 
            }
            return (base.ToFourDigitYear(year));
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\koreancalendar.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {

    using System;

    /*=================================KoreanCalendar==========================
    **
    ** Korean calendar is based on the Gregorian calendar.  And the year is an offset to Gregorian calendar.
    ** That is,
    **      Korean year = Gregorian year + 2333.  So 2000/01/01 A.D. is Korean 4333/01/01
    **
    ** 0001/1/1 A.D. is Korean year 2334.
    **
    **  Calendar support range:
    **      Calendar    Minimum     Maximum
    **      ==========  ==========  ==========
    **      Gregorian   0001/01/01   9999/12/31
    **      Korean      2334/01/01  12332/12/31        
    ============================================================================*/
    
    /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar"]/*' />
    [Serializable] public class KoreanCalendar: Calendar {    
        //
        // The era value for the current era.
        //
        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.KoreanEra"]/*' />
        public const int KoreanEra = 1;

        internal static EraInfo[] m_EraInfo;

        internal static Calendar m_defaultInstance = null;

        internal GregorianCalendarHelper helper;     

        /*=================================GetDefaultInstance==========================
        **Action: Internal method to provide a default intance of KoreanCalendar.  Used by NLS+ implementation
        **       and other calendars.
        **Returns:
        **Arguments:
        **Exceptions:
        ============================================================================*/

        internal static Calendar GetDefaultInstance() {
            if (m_defaultInstance == null) {
                m_defaultInstance = new KoreanCalendar();
            }
            return (m_defaultInstance);
        }
        
        static KoreanCalendar() {
            m_EraInfo = new EraInfo[1];
            // Since
            //    Gregorian Year = Era Year + yearOffset
            // Gregorian Year 1 is Korean year 2334, so that
            //    1 = 2334 + yearOffset
            //  So yearOffset = -2333
            // Gregorian year 2001 is Korean year 4334.
            
            //m_EraInfo[0] = new EraInfo(1, new DateTime(1, 1, 1).Ticks, -2333, 2334, GregorianCalendar.MaxYear + 2333);
            m_EraInfo = GregorianCalendarHelper.InitEraInfo(Calendar.CAL_KOREA);
        }
        
        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.KoreanCalendar1"]/*' />
        public KoreanCalendar() {
            helper = new GregorianCalendarHelper(this, m_EraInfo);            
        }

        internal override int ID {
            get {
                return (CAL_KOREA);
            }
        }

        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.AddMonths"]/*' />
        public override DateTime AddMonths(DateTime time, int months) {
            return (helper.AddMonths(time, months));
        }

        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.AddYears"]/*' />
        public override DateTime AddYears(DateTime time, int years) {
            return (helper.AddYears(time, years));
        }
        
        /*=================================GetDaysInMonth==========================
        **Action: Returns the number of days in the month given by the year and month arguments. 
        **Returns: The number of days in the given month. 
        **Arguments: 
        **      year The year in Korean calendar.
        **      month The month
        **      era     The Japanese era value.
        **Exceptions 
        **  ArgumentException  If month is less than 1 or greater * than 12.
        ============================================================================*/
        
        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.GetDaysInMonth"]/*' />
        public override int GetDaysInMonth(int year, int month, int era) {
            return (helper.GetDaysInMonth(year, month, era));
        }

        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.GetDaysInYear"]/*' />
        public override int GetDaysInYear(int year, int era) {
            return (helper.GetDaysInYear(year, era));
        }

        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.GetDayOfMonth"]/*' />
        public override int GetDayOfMonth(DateTime time) {
            return (helper.GetDayOfMonth(time));
        }

        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.GetDayOfWeek"]/*' />
        public override DayOfWeek GetDayOfWeek(DateTime time)  {
            return (helper.GetDayOfWeek(time));
        }

        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.GetDayOfYear"]/*' />
        public override int GetDayOfYear(DateTime time)
        {
            return (helper.GetDayOfYear(time));
        }

        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.GetMonthsInYear"]/*' />
        public override int GetMonthsInYear(int year, int era) {
            return (helper.GetMonthsInYear(year, era));
        }

        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.GetEra"]/*' />
        public override int GetEra(DateTime time) {
            return (helper.GetEra(time));
        }
        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.GetMonth"]/*' />
        public override int GetMonth(DateTime time) {
            return (helper.GetMonth(time));
        }
        
        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.GetYear"]/*' />
        public override int GetYear(DateTime time) {
            return (helper.GetYear(time));
        }

        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.IsLeapDay"]/*' />
        public override bool IsLeapDay(int year, int month, int day, int era)
        {
            return (helper.IsLeapDay(year, month, day, era));
        }

        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.IsLeapYear"]/*' />
        public override bool IsLeapYear(int year, int era) {
            return (helper.IsLeapYear(year, era));
        }

        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.IsLeapMonth"]/*' />
        public override bool IsLeapMonth(int year, int month, int era) {
            return (helper.IsLeapMonth(year, month, era));
        }
        
        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.ToDateTime"]/*' />
        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) {
            return (helper.ToDateTime(year, month, day, hour, minute, second, millisecond, era));
        }    

        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.Eras"]/*' />
        public override int[] Eras {
            get {
                return (helper.Eras);
            }
        }

        private const int DEFAULT_TWO_DIGIT_YEAR_MAX = 4362;            
        
        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.TwoDigitYearMax"]/*' />
        public override int TwoDigitYearMax {
            get {
                if (twoDigitYearMax == -1) {
                    twoDigitYearMax = GetSystemTwoDigitYearSetting(ID, DEFAULT_TWO_DIGIT_YEAR_MAX);
                }
                return (twoDigitYearMax);
            }

            set {
                if (value < 100 || value > helper.MaxYear) {
                    throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    100, helper.MaxYear));

                }
                twoDigitYearMax = value;
            }
        }

        /// <include file='doc\KoreanCalendar.uex' path='docs/doc[@for="KoreanCalendar.ToFourDigitYear"]/*' />
        public override int ToFourDigitYear(int year) {
            return (helper.ToFourDigitYear(year, this.TwoDigitYearMax));
        }        
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\numberstyles.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Enum:  NumberStyles.cool
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Contains valid formats for Numbers recognized by
** the Number class' parsing code.
**
** Date:  August 9, 1999
**
===========================================================*/
namespace System.Globalization {
    
	using System;
	/// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles"]/*' />
    [Flags,Serializable] 
	public enum NumberStyles {
        // Bit flag indicating that leading whitespace is allowed. Character values
        // 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, and 0x0020 are considered to be
        // whitespace.
    
    	/// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.None"]/*' />
    	None				  = 0x00000000, 
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.AllowLeadingWhite"]/*' />
        AllowLeadingWhite     = 0x00000001, 
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.AllowTrailingWhite"]/*' />
        AllowTrailingWhite    = 0x00000002, //Bitflag indicating trailing whitespace is allowed.
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.AllowLeadingSign"]/*' />
        AllowLeadingSign      = 0x00000004, //Can the number start with a sign char.  
                                            //Specified by NumberFormatInfo.PositiveSign and NumberFormatInfo.NegativeSign
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.AllowTrailingSign"]/*' />
        AllowTrailingSign     = 0x00000008, //Allow the number to end with a sign char
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.AllowParentheses"]/*' />
        AllowParentheses      = 0x00000010, //Allow the number to be enclosed in parens
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.AllowDecimalPoint"]/*' />
        AllowDecimalPoint     = 0x00000020, //Allow a decimal point
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.AllowThousands"]/*' />
        AllowThousands        = 0x00000040, //Allow thousands separators (more properly, allow group separators)
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.AllowExponent"]/*' />
        AllowExponent         = 0x00000080, //Allow an exponent
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.AllowCurrencySymbol"]/*' />
        AllowCurrencySymbol   = 0x00000100, //Allow a currency symbol.
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.AllowHexSpecifier"]/*' />
		AllowHexSpecifier	  = 0x00000200, //Allow specifiying hexadecimal.
        //Common uses.  These represent some of the most common combinations of these flags.
    
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.Integer"]/*' />
        Integer  = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign,
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.HexNumber"]/*' />
		HexNumber = AllowLeadingWhite | AllowTrailingWhite | AllowHexSpecifier,
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.Number"]/*' />
        Number   = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowTrailingSign |
                   AllowDecimalPoint | AllowThousands,
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.Float"]/*' />
        Float    = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | 
                   AllowDecimalPoint | AllowExponent,
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.Currency"]/*' />
        Currency = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowTrailingSign |
                   AllowParentheses  | AllowDecimalPoint | AllowThousands | AllowCurrencySymbol,
        /// <include file='doc\NumberStyles.uex' path='docs/doc[@for="NumberStyles.Any"]/*' />
        Any      = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowTrailingSign |
                   AllowParentheses  | AllowDecimalPoint | AllowThousands | AllowCurrencySymbol | AllowExponent,
             
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\namelcidinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Class:    NameLCIDInfo
//
//  Author:   Julie Bennett (JulieB)
//
//  Purpose:  Package private class used to map string to an appropriate LCID.
//
//  Date:     March 31, 1999
//
////////////////////////////////////////////////////////////////////////////

namespace System.Globalization {
    
	using System;
    [Serializable()]
    internal struct NameLCIDInfo
    {
        internal String name;
        internal int    LCID;
        internal NameLCIDInfo(String name, int LCID)
        {
            this.name = name;
            this.LCID = LCID;
        }
        
        public override int GetHashCode() {
            return name.GetHashCode() ^ LCID;
        }
    
    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\regioninfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

////////////////////////////////////////////////////////////////////////////
//
//  Class:    RegionInfo
//
//  Author:   Julie Bennett (JulieB)
//
//  Purpose:  This class represents settings specified by de jure or
//            de facto standards for a particular country or region.  In
//            contrast to CultureInfo, the RegionInfo does not represent
//            preferences of the user and does not depend on the user's
//            language or culture.
//
//  Date:     March 31, 1999
//
////////////////////////////////////////////////////////////////////////////

namespace System.Globalization {
    
	using System;
    /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo"]/*' />
    [Serializable] public class RegionInfo
    {
        //--------------------------------------------------------------------//
        //                        Internal Information                        //
        //--------------------------------------------------------------------//

        //
        //  Variables.
        //
        internal String m_name;
        
        internal int m_dataItem;

        internal static RegionInfo m_currentRegionInfo;

                
        ////////////////////////////////////////////////////////////////////////
        //
        //  RegionInfo Constructors
        //
        ////////////////////////////////////////////////////////////////////////
    
        internal RegionInfo()        
            : this(CultureInfo.nativeGetUserDefaultLCID()) {
        }
    
        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.RegionInfo"]/*' />
        public RegionInfo(String name) {
            if (name==null) {
                throw new ArgumentNullException("name");
            }
            this.m_name = name.ToUpper(CultureInfo.InvariantCulture);

            this.m_dataItem = RegionTable.GetDataItemFromName(this.m_name);
            if (m_dataItem < 0) {
                throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidRegionName"), name), "name");
            }
        }
      
        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.RegionInfo1"]/*' />
        public RegionInfo(int culture) {
            // Get the culture data item.
            int cultureItem = CultureTable.GetDataItemFromCultureID(CultureInfo.GetLangID(culture));
            if (cultureItem < 0) {
                // Not a valid culture ID.
                throw new ArgumentException(Environment.GetResourceString("Argument_CultureNotSupported", culture), "culture");
            }

            if (culture == 0x7F) { //The InvariantCulture has no matching region
                throw new ArgumentException(Environment.GetResourceString("Argument_NoRegionInvariantCulture"));
            }
                
            //
            // From this culture data item, get the region data item.
            // We do this because several culture ID may map to the same region.
            // For example, 0x1009 (English (Canada)) and 0x0c0c (French (Canada)) all map to
            // the same region "CA" (Canada).
            //
            m_dataItem = CultureTable.GetDefaultInt32Value(cultureItem, CultureTable.IREGIONITEM);
            if (m_dataItem == 0xffff) {
                throw new ArgumentException(Environment.GetResourceString("Argument_CultureIsNeutral", culture), "culture");
            }            
        }
        
        ////////////////////////////////////////////////////////////////////////
        //
        //  GetCurrentRegion
        //
        //  This instance provides methods based on the current user settings.
        //  These settings are volatile and may change over the lifetime of the
        //  thread.
        //
        ////////////////////////////////////////////////////////////////////////

        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.CurrentRegion"]/*' />
        public static RegionInfo CurrentRegion {
            get {
                RegionInfo temp = m_currentRegionInfo;
                if (temp == null) {
                    temp = new RegionInfo();
                    m_currentRegionInfo = temp;
                }
                return (temp);
            }
        }
            
        ////////////////////////////////////////////////////////////////////////
        //
        //  GetName
        //
        //  Returns the name of the region in the UI language.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.Name"]/*' />
        public virtual String Name {
            get {
                if (m_name == null) {
                    m_name = RegionTable.GetStringValue(m_dataItem, RegionTable.SNAME, false);
                }
                return (m_name);
            }
        }
        
        ////////////////////////////////////////////////////////////////////////
        //
        //  GetEnglishName
        //
        //  Returns the name of the region in English.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.EnglishName"]/*' />
        public virtual String EnglishName
        {
            get
            {
                return (RegionTable.GetStringValue(m_dataItem, RegionTable.SENGCOUNTRY, false));
            }
        }
        
        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.DisplayName"]/*' />
        public virtual String DisplayName {
            get {
                return (Environment.GetResourceString("Globalization.ri_"+Name));
            }
        }
        
        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.TwoLetterISORegionName"]/*' />
        public virtual String TwoLetterISORegionName
        {
            get
            {
                return (RegionTable.GetStringValue(m_dataItem, RegionTable.SISO3166CTRYNAME, false));
            }
        }
    
        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.ThreeLetterISORegionName"]/*' />
        public virtual String ThreeLetterISORegionName
        {
            get
            {
                return (RegionTable.GetStringValue(m_dataItem, RegionTable.SISO3166CTRYNAME2, false));
            }
        }
        
        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.IsMetric"]/*' />
        public virtual bool IsMetric {
            get {
                int value = RegionTable.GetInt32Value(m_dataItem, RegionTable.IMEASURE, false);
                return (value==0);
            }
        }
        
        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.ThreeLetterWindowsRegionName"]/*' />
        public virtual String ThreeLetterWindowsRegionName
        {
            get
            {
                return (RegionTable.GetStringValue(m_dataItem, RegionTable.SABBREVCTRYNAME, false));
            }
        }
    
        /*================================ CurrencySymbol =============================
        **Property: CurrencySymbol
        **Exceptions: None
        ==============================================================================*/
        
        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.CurrencySymbol"]/*' />
        public virtual String CurrencySymbol {
            get {
                return (RegionTable.GetStringValue(m_dataItem, RegionTable.SCURRENCY, false));
            }
        }

        /*================================ ISOCurrencySymbol ==========================
        **Property: Three characters of the international monetary symbol specified in ISO 4217.
        **Exceptions: None
        ==============================================================================*/

        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.ISOCurrencySymbol"]/*' />
        public virtual String ISOCurrencySymbol {
            get {
                return (RegionTable.GetStringValue(m_dataItem, RegionTable.SINTLSYMBOL, false));
            }
        }
        
        ////////////////////////////////////////////////////////////////////////
        //
        //  Equals
        //
        //  Implements Object.Equals().  Returns a boolean indicating whether
        //  or not object refers to the same CultureInfo as the current instance.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.Equals"]/*' />
        public override bool Equals(Object value)
        {
            //
            //  See if the object name is the same as the culture object.
            //
            if ((value != null) && (value is RegionInfo))
            {
                RegionInfo region = (RegionInfo)value;
    
                //
                //  See if the member variables are equal.  If so, then
                //  return true.
                //
                if (this.m_dataItem == region.m_dataItem)
                {
                    return (true);
                }
            }
    
            //
            //  Objects are not the same, so return false.
            //
            return (false);
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  GetHashCode
        //
        //  Implements Object.GetHashCode().  Returns the hash code for the
        //  CultureInfo.  The hash code is guaranteed to be the same for RegionInfo
        //  A and B where A.Equals(B) is true.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return (m_dataItem);
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  ToString
        //
        //  Implements Object.ToString().  Returns the name of the Region,
        //  eg. "United States".
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\RegionInfo.uex' path='docs/doc[@for="RegionInfo.ToString"]/*' />
        public override String ToString()
        {
            return (Name);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\sortkey.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Class:    SortKey
//
//  Author:   Julie Bennett (JulieB)
//
//  Purpose:  This class implements a set of methods for retrieving
//            sort key information.
//
//  Date:     August 12, 1998
//
////////////////////////////////////////////////////////////////////////////

namespace System.Globalization {
    
    using System;
	using System.Runtime.CompilerServices;

    /// <include file='doc\SortKey.uex' path='docs/doc[@for="SortKey"]/*' />
    [Serializable] public class SortKey
    {
        //--------------------------------------------------------------------//
        //                        Internal Information                        //
        //--------------------------------------------------------------------//
    
        //
        //  Variables.
        //
        internal int win32LCID;           // 32-bit Win32 locale ID.  It may contain a 4-bit sort ID.
        internal CompareOptions options;               // options
        internal String m_String;         // original string
        internal byte[] m_KeyData;        // sortkey data
    
        //
        //  Helper Methods.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        unsafe private extern byte[] nativeCreateSortKey(void* pSortingFile, String pString, int dwFlags, int win32LCID);
    
    
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  SortKey Constructor
        //
        //  Implements CultureInfo.CompareInfo.GetSortKey().
        //  Package access only.
        //
        ////////////////////////////////////////////////////////////////////////
    
        unsafe internal SortKey(void* pSortingFile, int win32LCID, String str, CompareOptions options)
        {
            if (str==null) {
                throw new ArgumentNullException("str");
            }
    
            //This takes the sort id from CompareInfo, so we should be able to skip initializing it.
            this.win32LCID = win32LCID;
    
            this.options = options;
            m_String = str;
    
            //We need an initialized SortTable here, but since we're getting this as an instance 
            //method off of a CompareInfo, we're guaranteed that that already happened.
            m_KeyData = nativeCreateSortKey(pSortingFile, str, (int)options, win32LCID);
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  GetOriginalString
        //
        //  Returns the original string used to create the current instance
        //  of SortKey.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\SortKey.uex' path='docs/doc[@for="SortKey.OriginalString"]/*' />
        public virtual String OriginalString
        {
            get {
                return (m_String);
            }
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  GetKeyData
        //
        //  Returns a byte array representing the current instance of the
        //  sort key.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\SortKey.uex' path='docs/doc[@for="SortKey.KeyData"]/*' />
        public virtual byte[] KeyData
        {
            get {
                return (byte[])(m_KeyData.Clone());
            }
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  Compare
        //
        //  Compares the two sort keys.  Returns 0 if the two sort keys are
        //  equal, a number less than 0 if sortkey1 is less than sortkey2,
        //  and a number greater than 0 if sortkey1 is greater than sortkey2.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\SortKey.uex' path='docs/doc[@for="SortKey.Compare"]/*' />
        public static int Compare(SortKey sortkey1, SortKey sortkey2) {
    
            if (sortkey1==null || sortkey2==null) {
                throw new ArgumentNullException((sortkey1==null ? "sortkey1": "sortkey2"));
            }
    
            byte[] key1Data = sortkey1.m_KeyData;
            byte[] key2Data = sortkey2.m_KeyData;
    
            BCLDebug.Assert(key1Data!=null, "key1Data!=null");
            BCLDebug.Assert(key2Data!=null, "key2Data!=null");

            if (key1Data.Length == 0) {
                if (key2Data.Length == 0) {
                    return (0);
                }
                return (-1);
            }
            if (key2Data.Length == 0) {
                return (1);
            }
    
            int compLen = (key1Data.Length<key2Data.Length)?key1Data.Length:key2Data.Length;

            for (int i=0; i<compLen; i++) {
                if (key1Data[i]>key2Data[i]) {
                    return (1);
                }
                if (key1Data[i]<key2Data[i]) {
                    return (-1);
                }
            }
    
            return 0;
    
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  Equals
        //
        //  Implements Object.Equals().  Returns a boolean indicating whether
        //  or not object refers to the same SortKey as the current instance.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\SortKey.uex' path='docs/doc[@for="SortKey.Equals"]/*' />
        public override bool Equals(Object value)
        {
            //
            //  See if the object name is the same as the SortKey object.
            //
            if ((value != null) && (value is SortKey))
            {
                SortKey Key = (SortKey)value;
    
                //
                //  See if the member variables are equal.  If so, then
                //  return true.
                //
                if ((this.win32LCID == Key.win32LCID) &&
                    (this.options == Key.options) &&
                    (String.CompareOrdinal(this.m_String,Key.m_String) == 0))
                {
                    return (true);
                }
            }
    
            //
            //  Objects are not the same, so return false.
            //
            return (false);
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  GetHashCode
        //
        //  Implements Object.GetHashCode().  Returns the hash code for the
        //  SortKey.  The hash code is guaranteed to be the same for
        //  SortKey A and B where A.Equals(B) is true.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\SortKey.uex' path='docs/doc[@for="SortKey.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return (win32LCID + (int)options + m_String.GetHashCode());
        }
    
    
        ////////////////////////////////////////////////////////////////////////
        //
        //  ToString
        //
        //  Implements Object.ToString().  Returns a string describing the
        //  SortKey.
        //
        ////////////////////////////////////////////////////////////////////////
    
        /// <include file='doc\SortKey.uex' path='docs/doc[@for="SortKey.ToString"]/*' />
        public override String ToString()
        {
            return ("SortKey - " + win32LCID + ", " + options + ", " + m_String);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\stringinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Class:    StringInfo
//
//  Author:   Yung-Shin Bala Lin (YSLin)
//
//  Purpose:  This class defines behaviors specific to a writing system.
//            A writing system is the collection of scripts and
//            orthographic rules required to represent a language as text.
//
//  Date:     March 31, 1999
//
////////////////////////////////////////////////////////////////////////////

namespace System.Globalization {
  
    using System;

    /// <include file='doc\StringInfo.uex' path='docs/doc[@for="StringInfo"]/*' />
    [Serializable]
    public class StringInfo  {

        //
        // BUGBUG[YSLin]:
        // This implementation of IsHighSurrogate and IsLowSurrogate duplicate obsoleted functionality on
        // CharacterInfo.  Adding it here helps to remove some warnings.  Remove it when the functionality is
        // no longer needed.
        //
        internal static bool IsHighSurrogate(char c)
        {
            return ((c >= CharacterInfo.HIGH_SURROGATE_START) && (c <= CharacterInfo.HIGH_SURROGATE_END));
        }    
        internal static bool IsLowSurrogate(char c)
        {
            return ((c >= CharacterInfo.LOW_SURROGATE_START) && (c <= CharacterInfo.LOW_SURROGATE_END));
        }
    
        internal static bool IsSurrogate(char c) {
            return ((c >= CharacterInfo.HIGH_SURROGATE_START) && (c <= CharacterInfo.LOW_SURROGATE_END));
        }
    
    	/// <include file='doc\StringInfo.uex' path='docs/doc[@for="StringInfo.GetNextTextElement"]/*' />
    	public static String GetNextTextElement(String str)
    	{
    	    return (GetNextTextElement(str, 0));
    	}

        internal static int GetNextTextElementLen(String str, int index, int endIndex)
        {
    	    if (index <= endIndex - 1)
    	    {
        	    //
        	    // Check the next character first, so we can avoid checking the first character
        	    // in general cases.
        	    //
        	    char nextCh = str[index+1];
        	    if (IsLowSurrogate(nextCh))
        	    {
        	        //
        	        // The next character is a low surrogate.  Check if the current character
        	        // is a high surrogate.
        	        //
        	        if (IsHighSurrogate(str[index]))
        	        {
        	            // Yes. A surrogate pair (high-surrogate + low-surrogate) is found. 
        	            // Check if the next character is a nonspacing character.
        	            int i;
                        for (i = index + 2; i <= endIndex && CharacterInfo.IsCombiningCharacter(str[i]); i++)
            	        {
                            // Do nothing here.
            	        }
        	            return (i - index);
        	        }
        	        //
        	        // No. Just return the current low-surrogate chracter.
        	        //
        	        
        	        // NOTENOTE yslin:
        	        // In the current implementation, if we have a str like this: 
        	        // A B <LS>
        	        // <LS> is low surrogate character.
        	        // We will return A,B,<LS> as text elements.
        	        return (1);
        	    }
                
                if (CharacterInfo.IsCombiningCharacter(nextCh))
        	    {
        	        //
        	        // The next character is a non-spacing character.
        	        // If the current character is NOT a nonspacing chracter, gather all the 
        	        // following characters which are non-spacing characters.
        	        //
        	        char ch = str[index];
                    UnicodeCategory uc = CharacterInfo.GetUnicodeCategory(ch);
        	        //
        	        // Make sure the current character is not a nonspacing character and is not a surrogate chracter.
        	        //
                    if (!CharacterInfo.IsCombiningCharacter(ch) && !IsSurrogate(ch) && (uc != UnicodeCategory.Format) && (uc != UnicodeCategory.Control))
        	        {
        	            int i;
                        for (i = index + 2; i <= endIndex && CharacterInfo.IsCombiningCharacter(str[i]); i++)
            	        {
                            // Do nothing here.
            	        }
            	        return (i - index);
            	    }
        	    }
        	}
        	return (1);
        }
        
        // Returns the str containing the next text element in str starting at 
        // index index.  If index is not supplied, then it will start at the beginning 
        // of str.  It recognizes a base character plus one or more combining 
        // characters or a properly formed surrogate pair as a text element.  See also 
        // the ParseCombiningCharacters() and the ParseSurrogates() methods.
    	/// <include file='doc\StringInfo.uex' path='docs/doc[@for="StringInfo.GetNextTextElement1"]/*' />
        public static String GetNextTextElement(String str, int index) {
    	    //
    	    // Validate parameters.
    	    //
            if (str==null) {
                throw new ArgumentNullException("str");
            }
    	
    	    int len = str.Length;
            if (len == 0) {
                return (str);
            }
            if (index < 0 || index >= len) {
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
    	    }

    		return (str.Substring(index, GetNextTextElementLen(str, index, len - 1)));
    	}

        /// <include file='doc\StringInfo.uex' path='docs/doc[@for="StringInfo.GetTextElementEnumerator"]/*' />
        public static TextElementEnumerator GetTextElementEnumerator(String str)
        {
            return (GetTextElementEnumerator(str, 0));
        }
        
        /// <include file='doc\StringInfo.uex' path='docs/doc[@for="StringInfo.GetTextElementEnumerator1"]/*' />
        public static TextElementEnumerator GetTextElementEnumerator(String str, int index)
        {
    	    //
    	    // Validate parameters.
    	    //
            if (str==null) 
            {
                throw new ArgumentNullException("str");
            }
    	
    	    int len = str.Length;
    	    if (index < 0 || (index >= len && index!=0))
    	    {
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_Index"));
    	    }

            return (new TextElementEnumerator(str, index, str.Length - 1));
        }

        /*
         * Returns the indices of each base character or properly formed surrogate pair 
         * within the str.  It recognizes a base character plus one or more combining 
         * characters or a properly formed surrogate pair as a text element and returns 
         * the index of the base character or high surrogate.  Each index is the 
         * beginning of a text element within a str.  The length of each element is 
         * easily computed as the difference between successive indices.  The length of 
         * the array will always be less than or equal to the length of the str.  For 
         * example, given the str \u4f00\u302a\ud800\udc00\u4f01, this method would 
         * return the indices: 0, 2, 4.
         */

        /// <include file='doc\StringInfo.uex' path='docs/doc[@for="StringInfo.ParseCombiningCharacters"]/*' />
        public static int[] ParseCombiningCharacters(String str)
        {
            if (str == null)
            {
                throw new ArgumentNullException("str");
            }
            
            int len = str.Length;
            if (len == 0)
            {
                return (null);
            }
            int[] result = new int[len];
            int resultCount = 0;

            int i = 0;
            while (i < len) { 
                    result[resultCount++] = i;
                i += GetNextTextElementLen(str, i, len - 1);                                
            }

            if (resultCount < len)
            {
                int[] returnArray = new int[resultCount];
                Array.Copy(result, returnArray, resultCount);
                return (returnArray);
            }
            return (result);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\numberformatinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
    using System.Text;
    using System;
    // 
    // Property  Default  Description
    // PositiveSign  '+'  Character used to indicate positive
    // values.
    // NegativeSign  '-'  Character used to indicate negative
    // values.
    // NumberDecimalSeparator  '.'  The character used as the
    // decimal separator.
    // NumberGroupSeparator  ','  The character used to
    // separate groups of digits to the left of the decimal point.
    // NumberDecimalDigits  2  The default number of decimal
    // places.
    // NumberGroupSizes  3  The number of digits in each
    // group to the left of the decimal point.
    // NaNSymbol  "NaN"  The string used to represent NaN
    // values.
    // PositiveInfinitySymbol  "Infinity"  The string used to
    // represent positive infinities.
    // NegativeInfinitySymbol  "-Infinity"  The string used
    // to represent negative infinities.
    // 
    //
    // 
    // Property  Default  Description
    // CurrencyDecimalSeparator  '.'  The character used as
    // the decimal separator.
    // CurrencyGroupSeparator  ','  The character used to
    // separate groups of digits to the left of the decimal point.
    // CurrencyDecimalDigits  2  The default number of
    // decimal places.
    // CurrencyGroupSizes  3  The number of digits in each
    // group to the left of the decimal point.
    // CurrencyPositivePattern  0  The format of positive
    // values.
    // CurrencyNegativePattern  0  The format of negative
    // values.
    // CurrencySymbol  "$"  String used as local monetary
    // symbol.
    // 
    /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo"]/*' />
    [Serializable] sealed public class NumberFormatInfo : ICloneable, IFormatProvider {
        // invariantInfo is constant irrespective of your current culture.
        private static NumberFormatInfo invariantInfo;

        // READTHIS READTHIS READTHIS
        // This class has an exact mapping onto a native structure defined in COMNumber.cpp
        // DO NOT UPDATE THIS WITHOUT UPDATING THAT STRUCTURE. IF YOU ADD BOOL, ADD THEM AT THE END.
        // ALSO MAKE SURE TO UPDATE mscorlib.h in the VM directory to check field offsets.
        // READTHIS READTHIS READTHIS
        internal int[] numberGroupSizes = new int[] {3};
        internal int[] currencyGroupSizes = new int[] {3};
        internal int[] percentGroupSizes = new int[] {3};
        internal String positiveSign = "+";
        internal String negativeSign = "-";
        internal String numberDecimalSeparator = ".";
        internal String numberGroupSeparator = ",";
        internal String currencyGroupSeparator = ",";
        internal String currencyDecimalSeparator = ".";
        internal String currencySymbol = "\x00a4";  // U+00a4 is the symbol for International Monetary Fund.
        // The alternative currency symbol used in Win9x ANSI codepage, that can not roundtrip between ANSI and Unicode.
        // Currently, only ja-JP and ko-KR has non-null values (which is U+005c, backslash)
        internal String ansiCurrencySymbol = null;  
        internal String nanSymbol = "NaN";
        internal String positiveInfinitySymbol = "Infinity";
        internal String negativeInfinitySymbol = "-Infinity";
        internal String percentDecimalSeparator = ".";
        internal String percentGroupSeparator = ",";
        internal String percentSymbol = "%";
        internal String perMilleSymbol = "\u2030";

        // an index which points to a record in Culture Data Table.
        internal int m_dataItem = 0;

        internal int numberDecimalDigits = 2;
        internal int currencyDecimalDigits = 2;
        internal int currencyPositivePattern = 0;
        internal int currencyNegativePattern = 0;
        internal int numberNegativePattern = 1;
        internal int percentPositivePattern = 0;
        internal int percentNegativePattern = 0;
        internal int percentDecimalDigits = 2;
        internal bool isReadOnly=false;
        internal bool m_useUserOverride;

	    // Check if NumberFormatInfo was not set up ambiguously for parsing as number and currency
	    // eg. if the NumberDecimalSeparator and the NumberGroupSeparator were the same. This check
	    // used to live in the managed code in NumberFormatInfo but it made it difficult to change the
	    // values in managed code for the currency case since we had
	    //   NDS != NGS, NDS != CGS, CDS != NGS, CDS != CGS to be true to parse and user were not 
	    // easily able to switch these for certain european cultures.
        internal bool validForParseAsNumber = true;
        internal bool validForParseAsCurrency = true;


        /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.NumberFormatInfo"]/*' />
        public NumberFormatInfo() : this(0, false) {
        }

        private void VerifyDecimalSeparator(String decSep, String propertyName) {
            if (decSep==null) {
                throw new ArgumentNullException(propertyName,
                        Environment.GetResourceString("ArgumentNull_String"));
            }

            if (decSep.Length==0) {
                throw new ArgumentException(Environment.GetResourceString("Argument_EmptyDecGroupString"));
            }
 
        }

        private void VerifyGroupSeparator(String groupSep, String propertyName) {
            if (groupSep==null) {
                throw new ArgumentNullException(propertyName,
                        Environment.GetResourceString("ArgumentNull_String"));
            }

//              if (groupSep.Length==0) {
//                  throw new ArgumentException(Environment.GetResourceString("Argument_EmptyDecGroupString"));
//              }

        }

        // Update these flags, so that we can throw while parsing
        private void UpdateValidParsingState() {
            if (numberDecimalSeparator != numberGroupSeparator) {
                validForParseAsNumber = true;
            } else {
                validForParseAsNumber = false;
            }

            if ((numberDecimalSeparator != numberGroupSeparator) &&
                (numberDecimalSeparator != currencyGroupSeparator) &&
                (currencyDecimalSeparator != numberGroupSeparator) &&
                (currencyDecimalSeparator != currencyGroupSeparator)) {
                validForParseAsCurrency = true;
            } else {
                validForParseAsCurrency = false;
            }
        }


        internal NumberFormatInfo(int dataItem, bool useUserOverride) {
            this.m_dataItem = dataItem;
            this.m_useUserOverride = useUserOverride;

            if (this.m_dataItem != 0) {
                //
                // BUGBUG YSLin: Make all of these initialization into native, because they have become
                // very expensive.  Every GetInt32Value is a native call.
                // E.g. CultureTable.GetNumberFormatInfo(numInfo).
                //

                /*
                We don't have information for the following four.  All cultures use
                the same value set in the ctor of NumberFormatInfo.
                PercentGroupSize
                PercentDecimalDigits
                PercentGroupSeparator
                PerMilleSymbol
                */

                // We directly use fields here since these data is coming from data table or Win32, so we
                // don't need to verify their values.
                
                this.percentDecimalDigits    = this.numberDecimalDigits     = CultureTable.GetInt32Value(m_dataItem, CultureTable.IDIGITS, m_useUserOverride);
                this.numberNegativePattern   = CultureTable.GetInt32Value(m_dataItem, CultureTable.INEGNUMBER, m_useUserOverride);
                this.currencyDecimalDigits   = CultureTable.GetInt32Value(m_dataItem, CultureTable.ICURRDIGITS, m_useUserOverride);
                this.currencyPositivePattern = CultureTable.GetInt32Value(m_dataItem, CultureTable.ICURRENCY, m_useUserOverride);
                this.currencyNegativePattern = CultureTable.GetInt32Value(m_dataItem, CultureTable.INEGCURR, m_useUserOverride);   
                this.percentNegativePattern  = CultureTable.GetInt32Value(m_dataItem, CultureTable.INEGATIVEPERCENT, m_useUserOverride);
                this.percentPositivePattern  = CultureTable.GetInt32Value(m_dataItem, CultureTable.IPOSITIVEPERCENT, m_useUserOverride);                
                this.negativeSign            = CultureTable.GetStringValue(m_dataItem, CultureTable.SNEGATIVESIGN, m_useUserOverride); 
                this.percentSymbol           = CultureTable.GetStringValue(m_dataItem, CultureTable.SPERCENT, m_useUserOverride);
                
                this.percentDecimalSeparator = this.numberDecimalSeparator  = CultureTable.GetStringValue(m_dataItem, CultureTable.SDECIMAL, m_useUserOverride);
                this.percentGroupSizes       = this.numberGroupSizes        = CultureInfo.ParseGroupString(CultureTable.GetStringValue(m_dataItem, CultureTable.SGROUPING, m_useUserOverride)); 
                this.percentGroupSeparator   = this.numberGroupSeparator    = CultureTable.GetStringValue(m_dataItem, CultureTable.STHOUSAND, m_useUserOverride);
                this.positiveSign            = CultureTable.GetStringValue(m_dataItem, CultureTable.SPOSITIVESIGN, m_useUserOverride);
                this.currencyDecimalSeparator= CultureTable.GetStringValue(m_dataItem, CultureTable.SMONDECIMALSEP, m_useUserOverride);

                //Special case for Italian.  The currency decimal separator in the control panel is the empty string. When the user
                //specifies C4 as the currency format, this results in the number apparently getting multiplied by 10000 because the
                //decimal point doesn't show up.  We'll just hack this here because our default currency format will never use this.
                if (currencyDecimalSeparator.Length==0) { 
                    this.currencyDecimalSeparator= CultureTable.GetStringValue(m_dataItem, CultureTable.SMONDECIMALSEP, false);
                }

                this.currencyGroupSizes      = CultureInfo.ParseGroupString(CultureTable.GetStringValue(m_dataItem, CultureTable.SMONGROUPING, m_useUserOverride));
                this.currencyGroupSeparator  = CultureTable.GetStringValue(m_dataItem, CultureTable.SMONTHOUSANDSEP, m_useUserOverride);
                this.currencySymbol          = CultureTable.GetStringValue(m_dataItem, CultureTable.SCURRENCY, m_useUserOverride); 
                this.ansiCurrencySymbol      = CultureTable.GetStringValue(m_dataItem, CultureTable.SANSICURRENCYSYMBOL, false); 
                if (this.ansiCurrencySymbol.Length == 0)
                   this.ansiCurrencySymbol = null; 
                this.negativeInfinitySymbol  = CultureTable.GetStringValue(m_dataItem, CultureTable.SNEGINFINITY, m_useUserOverride);
                this.positiveInfinitySymbol  = CultureTable.GetStringValue(m_dataItem, CultureTable.SPOSINFINITY, m_useUserOverride);
                this.nanSymbol               = CultureTable.GetStringValue(m_dataItem, CultureTable.SNAN, m_useUserOverride); 

            }                
        }

        private void VerifyWritable() {
            if (isReadOnly) {
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ReadOnly"));
            }
        }

        // Returns a default NumberFormatInfo that will be universally
        // supported and constant irrespective of the current culture.
        // Used by FromString methods.
        //
        /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.InvariantInfo"]/*' />
        public static NumberFormatInfo InvariantInfo {
            get {
                if (invariantInfo == null) {
                    // Lazy create the invariant info. This cannot be done in a .cctor because exceptions can
                    // be thrown out of a .cctor stack that will need this.
                    invariantInfo = ReadOnly(new NumberFormatInfo());
                }
                return invariantInfo;
            }
        }


        /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.GetInstance"]/*' />
        public static NumberFormatInfo GetInstance(IFormatProvider formatProvider) {
            if (formatProvider != null) {
                Object service = formatProvider.GetFormat(typeof(NumberFormatInfo));
                if (service != null) return (NumberFormatInfo)service;
            }
            return CurrentInfo;
        }


        /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.Clone"]/*' />
        public Object Clone() {
            NumberFormatInfo n = (NumberFormatInfo)MemberwiseClone();
            n.isReadOnly = false;
            return n;
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.CurrencyDecimalDigits"]/*' />
         public int CurrencyDecimalDigits {
            get { return currencyDecimalDigits; }
            set {
                VerifyWritable();
                if (value < 0 || value > 99) {
                    throw new ArgumentOutOfRangeException(
                        "CurrencyDecimalDigits", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                        0, 99));
                }
                currencyDecimalDigits = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.CurrencyDecimalSeparator"]/*' />
         public String CurrencyDecimalSeparator {
            get { return currencyDecimalSeparator; }
            set {
                VerifyWritable();
                VerifyDecimalSeparator(value, "CurrencyDecimalSeparator");
                currencyDecimalSeparator = value;
                UpdateValidParsingState();
            }
        }

		/// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.IsReadOnly"]/*' />
		public bool IsReadOnly {
            get {
                return isReadOnly;
            }
        }
        
		//
        // Check the values of the groupSize array.
        //
        // Every element in the groupSize array should be between 1 and 9
        // excpet the last element could be zero.
        //
        internal void CheckGroupSize(String propName, int[] groupSize)
        {
            if (groupSize == null) {
                throw new ArgumentNullException(propName,
                    Environment.GetResourceString("ArgumentNull_Obj"));
            }
            
            for (int i = 0; i < groupSize.Length; i++)
            {
                if (groupSize[i] < 1)
                {
                    if (i == groupSize.Length - 1 && groupSize[i] == 0)
                        return;
                    throw new ArgumentException(propName, Environment.GetResourceString("Argument_InvalidGroupSize"));
                }
                else if (groupSize[i] > 9)
                {
                    throw new ArgumentException(propName, Environment.GetResourceString("Argument_InvalidGroupSize"));
                }
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.CurrencyGroupSizes"]/*' />
         public int[] CurrencyGroupSizes {
            get {
                return ((int[])currencyGroupSizes.Clone());
            }
            set {
                VerifyWritable();
                CheckGroupSize("CurrencyGroupSizes", value);
                currencyGroupSizes = value;
            }

        }


         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.NumberGroupSizes"]/*' />
         public int[] NumberGroupSizes {
            get {
                return ((int[])numberGroupSizes.Clone());
            }
            set {
                VerifyWritable();
                CheckGroupSize("NumberGroupSizes", value);
                numberGroupSizes = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.PercentGroupSizes"]/*' />
         public int[] PercentGroupSizes {
            get {
                return ((int[])percentGroupSizes.Clone());
            }
            set {
                VerifyWritable();
                CheckGroupSize("PercentGroupSizes", value);
                percentGroupSizes = value;
            }

        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.CurrencyGroupSeparator"]/*' />
         public String CurrencyGroupSeparator {
            get { return currencyGroupSeparator; }
            set {
                VerifyWritable();
                VerifyGroupSeparator(value, "CurrencyGroupSeparator");
                currencyGroupSeparator = value;
                UpdateValidParsingState();
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.CurrencySymbol"]/*' />
         public String CurrencySymbol {
            get { return currencySymbol; }
            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("CurrencySymbol",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                currencySymbol = value;
            }
        }

        // Returns the current culture's NumberFormatInfo.  Used by Parse methods.
        //
        /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.CurrentInfo"]/*' />
        public static NumberFormatInfo CurrentInfo {
            get {
                System.Globalization.CultureInfo tempCulture = System.Threading.Thread.CurrentThread.CurrentCulture;
                return ((NumberFormatInfo)tempCulture.GetFormat(typeof(NumberFormatInfo)));
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.NaNSymbol"]/*' />
         public String NaNSymbol {
            get { 
                return nanSymbol; 
            }
            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("NaNSymbol",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                nanSymbol = value;
            }
        }


         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.CurrencyNegativePattern"]/*' />
         public int CurrencyNegativePattern {
            get { return currencyNegativePattern; }
            set {
                VerifyWritable();
                if (value < 0 || value > 15) {
                    throw new ArgumentOutOfRangeException(
                        "CurrencyNegativePattern", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                        0, 15));
                }
                currencyNegativePattern = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.NumberNegativePattern"]/*' />
         public int NumberNegativePattern {
            get { return numberNegativePattern; }
            set {
                //
                // NOTENOTE: the range of value should correspond to negNumberFormats[] in vm\COMNumber.cpp.
                //
                VerifyWritable();
                if (value < 0 || value > 4) {
                    throw new ArgumentOutOfRangeException(
                        "NumberNegativePattern", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                        0, 4));
                }
                numberNegativePattern = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.PercentPositivePattern"]/*' />
         public int PercentPositivePattern {
            get { return percentPositivePattern; }
            set {
                //
                // NOTENOTE: the range of value should correspond to posPercentFormats[] in vm\COMNumber.cpp.
                //
                VerifyWritable();
                if (value < 0 || value > 2) {
                    throw new ArgumentOutOfRangeException(
                        "PercentPositivePattern", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                        0, 2));
                }
                percentPositivePattern = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.PercentNegativePattern"]/*' />
         public int PercentNegativePattern {
            get { return percentNegativePattern; }
            set {
                //
                // NOTENOTE: the range of value should correspond to posPercentFormats[] in vm\COMNumber.cpp.
                //
                VerifyWritable();
                if (value < 0 || value > 2) {
                    throw new ArgumentOutOfRangeException(
                        "PercentNegativePattern", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                        0, 2));
                }
                percentNegativePattern = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.NegativeInfinitySymbol"]/*' />
         public String NegativeInfinitySymbol {
            get { 
                return negativeInfinitySymbol; 
            }
            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("NegativeInfinitySymbol",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                negativeInfinitySymbol = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.NegativeSign"]/*' />
         public String NegativeSign {
            get { return negativeSign; }
            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("NegativeSign",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                negativeSign = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.NumberDecimalDigits"]/*' />
         public int NumberDecimalDigits {
            get { return numberDecimalDigits; }
            set {
                VerifyWritable();
                if (value < 0 || value > 99) {
                    throw new ArgumentOutOfRangeException(
                        "NumberDecimalDigits", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                        0, 99));
                }
                numberDecimalDigits = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.NumberDecimalSeparator"]/*' />
         public String NumberDecimalSeparator {
            get { return numberDecimalSeparator; }
            set {
                VerifyWritable();
                VerifyDecimalSeparator(value, "NumberDecimalSeparator");
                numberDecimalSeparator = value;
                UpdateValidParsingState();
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.NumberGroupSeparator"]/*' />
         public String NumberGroupSeparator {
            get { return numberGroupSeparator; }
            set {
                VerifyWritable();
                VerifyGroupSeparator(value, "NumberGroupSeparator");
                numberGroupSeparator = value;
                UpdateValidParsingState();
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.CurrencyPositivePattern"]/*' />
         public int CurrencyPositivePattern {
            get { return currencyPositivePattern; }
            set {
                VerifyWritable();
                if (value < 0 || value > 3) {
                    throw new ArgumentOutOfRangeException(
                        "CurrencyPositivePattern", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                        0, 3));
                }
                currencyPositivePattern = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.PositiveInfinitySymbol"]/*' />
         public String PositiveInfinitySymbol {
            get { 
                return positiveInfinitySymbol; 
            }
            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("PositiveInfinitySymbol",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                positiveInfinitySymbol = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.PositiveSign"]/*' />
         public String PositiveSign {
            get { return positiveSign; }
            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("PositiveSign",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                positiveSign = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.PercentDecimalDigits"]/*' />
         public int PercentDecimalDigits {
            get { return percentDecimalDigits; }
            set {
                VerifyWritable();
                if (value < 0 || value > 99) {
                    throw new ArgumentOutOfRangeException(
                        "PercentDecimalDigits", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"),
                        0, 99));
                }
                percentDecimalDigits = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.PercentDecimalSeparator"]/*' />
         public String PercentDecimalSeparator {
            get { return percentDecimalSeparator; }
            set {
                VerifyWritable();
                VerifyDecimalSeparator(value, "PercentDecimalSeparator");
                percentDecimalSeparator = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.PercentGroupSeparator"]/*' />
         public String PercentGroupSeparator {
            get { return percentGroupSeparator; }
            set {
                VerifyWritable();
                VerifyGroupSeparator(value, "PercentGroupSeparator");
                percentGroupSeparator = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.PercentSymbol"]/*' />
         public String PercentSymbol {
            get { 
                return percentSymbol; 
            }
            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("PercentSymbol",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                percentSymbol = value;
            }
        }

         /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.PerMilleSymbol"]/*' />
         public String PerMilleSymbol {
            get { return perMilleSymbol; }
            set {
                VerifyWritable();
                if (value == null) {
                    throw new ArgumentNullException("PerMilleSymbol",
                        Environment.GetResourceString("ArgumentNull_String"));
                }
                perMilleSymbol = value;
            }
        }

        /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.GetFormat"]/*' />
        public Object GetFormat(Type formatType) {
            return formatType == typeof(NumberFormatInfo)? this: null;
        }

       /// <include file='doc\NumberFormatInfo.uex' path='docs/doc[@for="NumberFormatInfo.ReadOnly"]/*' />
       public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi) {
            if (nfi == null) {
                throw new ArgumentNullException("nfi");
            }
            if (nfi.IsReadOnly) {
                return (nfi);
            }            
            NumberFormatInfo info = (NumberFormatInfo)(nfi.MemberwiseClone());
            info.isReadOnly = true;
            return info;
        }

        internal static void ValidateParseStyle(NumberStyles style) {
            if ((style & NumberStyles.AllowHexSpecifier) != 0) { // Check for hex number
                if ((style & ~NumberStyles.HexNumber) != 0)
                    throw new ArgumentException(Environment.GetResourceString("Arg_InvalidHexStyle"));
            }
        }

        internal String AnsiCurrencySymbol {
            get {
                return (ansiCurrencySymbol);
            }
        }
    } // NumberFormatInfo
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\regiontable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {
    using System.Runtime.Remoting;
    using System;
    using System.Collections;
    using System.Runtime.CompilerServices;
    /*=============================================================================
     *
     * Data table for CultureInfo classes.  Used by System.Globalization.CultureInfo.
     *
     ==============================================================================*/
    internal class RegionTable {
    // Only statics, class does not need to be serializable

        //
        // The list of WORD fields:
        //

        internal const int ICOUNTRY = 0;
        internal const int IMEASURE = 1;
        internal const int ILANGUAGE = 2;
        internal const int IPAPERSIZE = 3;
        
        //
        // The list of string fields
        //

        internal const int SCURRENCY            = 0;
        internal const int SNAME                = 1;
        internal const int SENGCOUNTRY          = 2;
        internal const int SABBREVCTRYNAME      = 3;
        internal const int SISO3166CTRYNAME     = 4;
        internal const int SISO3166CTRYNAME2    = 5;
        internal const int SINTLSYMBOL          = 6;

        unsafe static RegionTable() {
            lock (typeof(RegionTable)) {
                nativeInitRegionInfoTable();
                m_headerPtr = nativeGetHeader();
                m_itemPtr   = nativeGetNameOffsetTable();
            }
            hashByName = new Hashtable();
        }

        unsafe internal static CultureInfoHeader*  m_headerPtr;
        unsafe internal static NameOffsetItem*     m_itemPtr;

        // Hashtable for indexing name to get nDataItem.
        internal static Hashtable hashByName;

        /*=================================GetDataItemFromName============================
        **Action:   Given a culture name, return a index which points to a data item in
        **          the Culture Data Table
        **Returns:  the data item index
        **Arguments:
        **      name culture name
        **Exceptions:
        ==============================================================================*/

        unsafe internal static int GetDataItemFromName(String name) {
            BCLDebug.Assert(name!=null,"RegionTable.GetDataItemFromName(): name!=null");
            BCLDebug.Assert(hashByName!=null,"RegionTable.GetDataItemFromname(): hashByName!=null");

            Object dataItem;
            if ((dataItem = hashByName[name]) != null) {
                return (Int32)dataItem;
            }
            // BUGBUG YSLin: Sort items by name in the culture.nlp so that we can change the following code
            // to binary search.
            //
            // BUGBUG YSLin: To do: pass header from native side to get the total number of cultures.
            //
            for (int i = 0; i < m_headerPtr->numCultures; i++) {
                char* itemName = nativeGetStringPoolStr(m_itemPtr[i].strOffset);
				bool success;
                if (String.nativeCompareOrdinalWC(name, itemName, true, out success) == 0) {
                    hashByName[name] = i;
                    return (i);
                }
            }
            return (-1);

        }


        internal static int GetDataItemFromRegionID(int cultureID)
        {
            return (nativeGetDataItemFromRegionID(cultureID));
        }

        //
        // Return the data item in the Culture Data Table for the specified culture ID.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int nativeGetDataItemFromRegionID(int cultureID);

        //
        // Return a Int16 field value for the specified data item in the Culture Data Table.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int GetInt32Value(int cultureDataItem, int field, bool useUserOverride);

        //
        // Return a String field value for the specified data item in the Culture Data Table.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String GetStringValue(int cultureDataItem, int field, bool useUserOverride);

        //
        // Return multiple String fields values for the specified data item in the Culture Data Table.
        // This field has several string values.
        //
        //[MethodImplAttribute(MethodImplOptions.InternalCall)]
        //internal static extern String[] GetMultipleStringValue(int cultureDataItem, int field);

        //
        // This function will go to native side and open/mapping the necessary
        // data file.  All of the information about cultures is stored in that data file.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void nativeInitRegionInfoTable();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern CultureInfoHeader* nativeGetHeader();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern char* nativeGetStringPoolStr(int offset);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern NameOffsetItem* nativeGetNameOffsetTable();

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\textelementenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Class:    TextElementEnumerator
//
//  Author:   Yung-Shin Bala Lin (YSLin)
//
//  Purpose:  
//
//  Date:     March 31, 1999
//
////////////////////////////////////////////////////////////////////////////

namespace System.Globalization {
    using System.Collections;

    //
    // This is public because GetTextElement() is public.
    //
    /// <include file='doc\TextElementEnumerator.uex' path='docs/doc[@for="TextElementEnumerator"]/*' />
    [Serializable]
    public class TextElementEnumerator: IEnumerator
    {
        private String str;
        private int index;
        private int startIndex;
        private int endIndex;
        private int nextTextElementLen;

        internal TextElementEnumerator(String str, int startIndex, int endIndex)
        {
            this.str = str;

            this.startIndex = startIndex;
            this.index = startIndex;
            this.endIndex = endIndex;
        }

        /// <include file='doc\TextElementEnumerator.uex' path='docs/doc[@for="TextElementEnumerator.MoveNext"]/*' />
        public bool MoveNext()
        {
            if (index > endIndex)
            {
                return (false);
            }
            nextTextElementLen = StringInfo.GetNextTextElementLen(str, index, endIndex);
            index += nextTextElementLen;
            return (true);
        }

        //
        // Get the current text element.
        //
        /// <include file='doc\TextElementEnumerator.uex' path='docs/doc[@for="TextElementEnumerator.Current"]/*' />
        public Object Current {
            get {
                return (GetTextElement());
            }
        }

        //
        // Get the current text element.
        //
        /// <include file='doc\TextElementEnumerator.uex' path='docs/doc[@for="TextElementEnumerator.GetTextElement"]/*' />
        public String GetTextElement()
        {
            if (index == startIndex) 
            {
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumNotStarted"));
            }
            return (str.Substring(index - nextTextElementLen, nextTextElementLen));
        }
        
        //
        // Get the starting index of the current text element.
        //
        /// <include file='doc\TextElementEnumerator.uex' path='docs/doc[@for="TextElementEnumerator.ElementIndex"]/*' />
        public int ElementIndex
        {
            get
            {
                if (index == startIndex) 
                {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumNotStarted"));
                }
                return (index - nextTextElementLen);
            }
        }

        /// <include file='doc\TextElementEnumerator.uex' path='docs/doc[@for="TextElementEnumerator.Reset"]/*' />
        public void Reset()
        {
            index = startIndex;
            nextTextElementLen = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\textinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////
//
//  Class:    TextInfo
//
//  Author:   Julie Bennett (JulieB)
//
//  Purpose:  This Class defines behaviors specific to a writing system.
//            A writing system is the collection of scripts and
//            orthographic rules required to represent a language as text.
//
//  Date:     March 31, 1999
//
////////////////////////////////////////////////////////////////////////////

namespace System.Globalization {
    using System.Text;
    using System;
    using System.Runtime.Serialization;
    using System.Runtime.CompilerServices;

    /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo"]/*' />
    [Serializable]
    public unsafe class TextInfo : IDeserializationCallback
    {
        //--------------------------------------------------------------------//
        //                        Internal Information                        //
        //--------------------------------------------------------------------//


        //
        //  Variables.
        //

        internal int m_nDataItem;
        internal bool m_useUserOverride;

        //
        // Basically, this is the language ID (LANGID) used to call Win32 NLS APIs except that
        // the value can be zero for the invariant culture.
        // The reason for this data member to exist is that Win32 APIs
        // doesn't take all of the culture IDs supported in NLS+.
        // For example, NLS+ support culture IDs like 0x0000, 0x0009.
        // However, these are not valid locale IDs in Win32.  Therefore,
        // we use a table to map a culutre ID like 
        // 0x0009 to 0x0409.
        //

        // m_win32LangID should be either 0 or a supported language ID.  See TextInfo(m_win32LangID)
        // for comments.
        internal int m_win32LangID;    

        //
        // m_pNativeTextInfo is a 32-bit pointer value pointing to a native C++ NativeTextInfo object.
        // The C++ NativeTextInfo is providing the implemenation of uppercasing/lowercasing.
        //        
        [NonSerialized]internal void *m_pNativeTextInfo;
        internal static void* m_pDefaultCasingTable;
        //
        //  Flags.
        //

        static TextInfo() {
            //with AppDomains active, the static initializer is no longer good enough to ensure that only one
            //thread is ever in AllocateDefaultCasingTable at a given time.  For Beta1, we'll lock on the type
            //of TextInfo because type objects are bled across AppDomains.
            //@Consider[YSLin, JRoxe]: Investigate putting this synchronization in native code.
            if (m_pDefaultCasingTable == null) {
                lock (typeof(TextInfo)) {
                    //We check if the table is already allocated in native, so we only need to synchronize
                    //access in managed.
                    if (m_pDefaultCasingTable == null) {
                        m_pDefaultCasingTable = AllocateDefaultCasingTable();
                    }
                }
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //
        //  TextInfo Constructors
        //
        //  Implements CultureInfo.TextInfo.
        //
        ////////////////////////////////////////////////////////////////////////

        internal TextInfo(int cultureID, int nDataItem, bool useUserOverride) {
            m_nDataItem = nDataItem;
            m_useUserOverride = useUserOverride;
            
            m_win32LangID = CultureTable.GetDefaultInt32Value(m_nDataItem, CultureTable.WIN32LANGID);

            BCLDebug.Assert(CultureInfo.GetSortID(m_win32LangID) == 0, 
                "CultureInfo.GetSortID(m_win32LangID) == 0");
            lock(typeof(TextInfo)) {
                // Calling this method need syncronization since shared
                // data is used in the native side.
                m_pNativeTextInfo = InternalAllocateCasingTable(m_win32LangID); 
            }                
        }



        ////////////////////////////////////////////////////////////////////////
        //
        //  CodePage
        //
        //  Returns the number of the code page used by this writing system.
        //  The type parameter can be any of the following values:
        //      ANSICodePage
        //      OEMCodePage
        //      MACCodePage
        //
        ////////////////////////////////////////////////////////////////////////

        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.ANSICodePage"]/*' />
        public virtual int ANSICodePage {
            get {
                return (CultureTable.GetDefaultInt32Value(m_nDataItem, CultureTable.IDEFAULTANSICODEPAGE));
            }
        }


        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.OEMCodePage"]/*' />
        public virtual int OEMCodePage {
            get {
                return (CultureTable.GetDefaultInt32Value(m_nDataItem, CultureTable.IDEFAULTOEMCODEPAGE));
            }
        }

        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.MacCodePage"]/*' />
        public virtual int MacCodePage {
            get {
                return (CultureTable.GetDefaultInt32Value(m_nDataItem, CultureTable.IDEFAULTMACCODEPAGE));
            }
        }

        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.EBCDICCodePage"]/*' />
        public virtual int EBCDICCodePage {
            get {
                return (CultureTable.GetDefaultInt32Value(m_nDataItem, CultureTable.IDEFAULTEBCDICCODEPAGE));
            }
        }


        ////////////////////////////////////////////////////////////////////////
        //
        //  ListSeparator
        //
        //  Returns the string used to separate items in a list.
        //
        ////////////////////////////////////////////////////////////////////////

        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.ListSeparator"]/*' />
        public virtual String ListSeparator {
            get {
                return (CultureTable.GetStringValue(m_nDataItem, CultureTable.SLIST, m_useUserOverride));
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern char   nativeChangeCaseChar(int win32LangID, void *pNativeTextInfo, char ch, bool isToUpper);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String nativeChangeCaseString(int win32LangID, void*pNativeTextInfo, String str, bool isToUpper);
        
        ////////////////////////////////////////////////////////////////////////
        //
        //  ToLower
        //
        //  Converts the character or string to lower case.  Certain locales
        //  have different casing semantics from the file systems in Win32.
        //
        ////////////////////////////////////////////////////////////////////////
        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.ToLower"]/*' />
        public virtual char   ToLower(char c) {
            return (nativeChangeCaseChar(m_win32LangID, m_pNativeTextInfo, c, false));
        }
        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.ToLower1"]/*' />
        public virtual String ToLower(String str) {
            if (str == null) {
                throw new ArgumentNullException("str");
            }
            return (nativeChangeCaseString(m_win32LangID, m_pNativeTextInfo, str, false));
        }
        
        ////////////////////////////////////////////////////////////////////////
        //
        //  ToUpper
        //
        //  Converts the character or string to upper case.  Certain locales
        //  have different casing semantics from the file systems in Win32.
        //
        ////////////////////////////////////////////////////////////////////////
        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.ToUpper"]/*' />
        public virtual char   ToUpper(char c) {
            return (nativeChangeCaseChar(m_win32LangID, m_pNativeTextInfo, c, true));
        }
        
        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.ToUpper1"]/*' />
        public virtual String ToUpper(String str) {
            if (str == null) {
                throw new ArgumentNullException("str");
            }
            return (nativeChangeCaseString(m_win32LangID, m_pNativeTextInfo, str, true));
        }

        ////////////////////////////////////////////////////////////////////////
        //
        //  Equals
        //
        //  Implements Object.Equals().  Returns a boolean indicating whether
        //  or not object refers to the same CultureInfo as the current instance.
        //
        ////////////////////////////////////////////////////////////////////////

        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.Equals"]/*' />
        public override bool Equals(Object obj)
        {
            //
            //  See if the object name is the same as the TextInfo object.
            //
            if ((obj != null) && (obj is TextInfo))
                {
                    TextInfo textInfo = (TextInfo)obj;

                    //
                    //  See if the member variables are equal.  If so, then
                    //  return true.
                    //
                    if (this.m_win32LangID == textInfo.m_win32LangID)
                        {
                            return (true);
                        }
                }

            //
            //  Objects are not the same, so return false.
            //
            return (false);
        }


        ////////////////////////////////////////////////////////////////////////
        //
        //  GetHashCode
        //
        //  Implements Object.GetHashCode().  Returns the hash code for the
        //  CultureInfo.  The hash code is guaranteed to be the same for CultureInfo A
        //  and B where A.Equals(B) is true.
        //
        ////////////////////////////////////////////////////////////////////////

        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return (this.m_win32LangID);
        }


        ////////////////////////////////////////////////////////////////////////
        //
        //  ToString
        //
        //  Implements Object.ToString().  Returns a string describing the
        //  TextInfo.
        //
        ////////////////////////////////////////////////////////////////////////

        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.ToString"]/*' />
        public override String ToString()
        {
            return ("TextInfo - " + this.m_win32LangID);
        }

        // Returns the mapping of the specified string to title case.  Note that the 
        // returned string may differ in length from the input string.
        // Generally, the first character of every word in str is uppercased.
        // For titlecase characters, they are uppercased in a specail way.
        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.ToTitleCase"]/*' />
        public String ToTitleCase(String str) {
            if (str==null) {
                throw new ArgumentNullException("str");
            }

            int i;
            int last = str.Length - 1;
            StringBuilder result = new StringBuilder();
            String lowercaseData = null;
            
            for (i = 0; i <= last; i++) {
                char ch = str[i];
                UnicodeCategory charType;
                if (CharacterInfo.IsLetter(ch))
                {
                    // Do the uppercasing for the first character of the word.
                    // There are titlecase characters that need to be special treated.
                    result.Append(nativeGetTitleCaseChar(m_pNativeTextInfo, ch));

                    //
                    // Convert the characters until the end of the this word
                    // to lowercase.
                    //
                    i++;
                    int lowercaseStart = i;                    

                    //
                    // Use hasLowerCase flag to prevent from lowercasing acronyms (like "URT", "USA", etc)
                    // This is in line with Word 2000 behavior of titilecasing.
                    //
                    bool hasLowerCase = (CharacterInfo.GetUnicodeCategory(ch) == UnicodeCategory.LowercaseLetter);
                    while (i <= last) {
                        if (IsLetterCategory(charType = CharacterInfo.GetUnicodeCategory(str[i]))) {
                            if (charType == UnicodeCategory.LowercaseLetter) {
                                hasLowerCase = true;
                            }
                            i++;
                        } else if (str[i] == '\'') {
                            // Special case for APOSTROPHE.  It should be considered part of the word.  E.g. "can't".
                            i++;
                            if (hasLowerCase) {
                                if (lowercaseData==null) {
                                    lowercaseData = this.ToLower(str);
                                }
                                result.Append(lowercaseData, lowercaseStart, i - lowercaseStart);
                            } else {
                                result.Append(str, lowercaseStart, i - lowercaseStart);
                            }                        
                            lowercaseStart = i;
                            hasLowerCase = true;
                        } else {
                            break;
                        }                        
                    }

                    int count = i - lowercaseStart;
                    
                    if (count>0) {
                        if (hasLowerCase) {
                            if (lowercaseData==null) {
                                lowercaseData = this.ToLower(str);
                            }
                            result.Append(lowercaseData, lowercaseStart, count);
                        } else {
                            result.Append(str, lowercaseStart, count);
                        }                        
                    }                    

                    if (i <= last) {                        
                        // Add the non-letter character.
                        result.Append(str[i]);
                    }
                } else {
                    //
                    // Whitespaces, just append them.
                    //
                    result.Append(ch);
                }
            }
            return (result.ToString());
        }            

        private bool IsLetterCategory(UnicodeCategory uc) {
            return (uc == UnicodeCategory.UppercaseLetter 
                 || uc == UnicodeCategory.LowercaseLetter 
                 || uc == UnicodeCategory.TitlecaseLetter 
                 || uc == UnicodeCategory.ModifierLetter 
                 || uc == UnicodeCategory.OtherLetter);            
        }

        /// <include file='doc\TextInfo.uex' path='docs/doc[@for="TextInfo.IDeserializationCallback.OnDeserialization"]/*' />
        /// <internalonly/>
        void IDeserializationCallback.OnDeserialization(Object sender) {
            if (m_pNativeTextInfo==null) {
                lock(typeof(TextInfo)) {
                    // Calling this method need syncronization since shared
                    // data is used in the native side.
                    if (m_pNativeTextInfo==null) {
                        m_pNativeTextInfo = InternalAllocateCasingTable(m_win32LangID); 
                    }
                }        
            }        
        }

        //This method requires synchronization and should only be called from the Class Initializer.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void* AllocateDefaultCasingTable();


        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void* InternalAllocateCasingTable(int win32LangID);

        //
        // Get case-insensitive hash code for the specified string.
        //
        // NOTENOTE: this is an internal function.  The caller should verify the string
        // is not null before calling this.  Currenlty, CaseInsensitiveHashCodeProvider
        // does that.
        //
        internal int GetCaseInsensitiveHashCode(String str) {            
            if (m_pNativeTextInfo==null) {
                lock(typeof(TextInfo)) {
                    if (m_pNativeTextInfo == null) { 
                        m_pNativeTextInfo = InternalAllocateCasingTable(m_win32LangID); 
                    }
                }
            }

            // BUG 112165
            // NOTENOTE YSLin
            // This is the temporaray fix that we want to do for GDR/Everett, so that we won't introduce
            // a dependency on mscorlib.dll and mscorwks.dll, which the real fix needs.
            // By doing this hack, we will do uppercase twice for Turkish/Azeri, so it is slower
            // in these two cultures.  The benefit is that we only have to do the fix in the managed side.
            switch (m_win32LangID) {
                case 0x041f:    // Turkish
                case 0x042c:    // Azeri
                    // Uppercase the specified characters.
                    str = nativeChangeCaseString(m_win32LangID, m_pNativeTextInfo, str, true);
                    break;
            }
            return (nativeGetCaseInsHash(str, m_pNativeTextInfo));

            // This is the real fix that we wish to do in Whidbey.
            // We will exam the m_wing32LangID and the high-char state in the native side to decide if we can do "fast hashing".
            //return nativeGetCaseInsHash(m_win32LangID, str, m_pNativeTextInfo);
        }

        internal static int GetDefaultCaseInsensitiveHashCode(String str) {
            return nativeGetCaseInsHash(str, m_pDefaultCasingTable);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern int nativeGetCaseInsHash(String str, void* pNativeTextInfo);
        // private static extern int nativeGetCaseInsHash(int win32LangID, String str, void* pNativeTextInfo);
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern char nativeGetTitleCaseChar(void*pNativeTextInfo, char ch);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\taiwancalendar.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {

    using System;

    /*=================================TaiwanCalendar==========================
    **
    ** Taiwan calendar is based on the Gregorian calendar.  And the year is an offset to Gregorian calendar.
    ** That is,
    **      Taiwan year = Gregorian year - 1911.  So 1912/01/01 A.D. is Taiwan 1/01/01
    **
    **  Calendar support range:
    **      Calendar    Minimum     Maximum
    **      ==========  ==========  ==========
    **      Gregorian   1912/01/01  9999/12/31
    **      Taiwan      01/01/01    8088/12/31
    ============================================================================*/
    
    /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar"]/*' />
    [Serializable] public class TaiwanCalendar: Calendar {
        //
        // The era value for the current era.
        //

        internal static EraInfo[] m_EraInfo;
        
        internal static Calendar m_defaultInstance = null;
        
        internal GregorianCalendarHelper helper;        

        /*=================================GetDefaultInstance==========================
        **Action: Internal method to provide a default intance of TaiwanCalendar.  Used by NLS+ implementation
        **       and other calendars.
        **Returns:
        **Arguments:
        **Exceptions:
        ============================================================================*/

        internal static Calendar GetDefaultInstance() {
            if (m_defaultInstance == null) {
                m_defaultInstance = new TaiwanCalendar();
            }
            return (m_defaultInstance);
        }

        static TaiwanCalendar() {
            // Since
            //    Gregorian Year = Era Year + yearOffset
            // When Gregorian Year 1912 is year 1, so that
            //    1912 = 1 + yearOffset
            //  So yearOffset = 1911
            //m_EraInfo[0] = new EraInfo(1, new DateTime(1912, 1, 1).Ticks, 1911, 1, GregorianCalendar.MaxYear - 1911);
            m_EraInfo = GregorianCalendarHelper.InitEraInfo(Calendar.CAL_TAIWAN);            
        }
        
        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.TaiwanCalendar"]/*' />
        public TaiwanCalendar() {
            helper = new GregorianCalendarHelper(this, m_EraInfo);
        }

        internal override int ID {
            get {
                return (CAL_TAIWAN);
            }
        }

        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.AddMonths"]/*' />
        public override DateTime AddMonths(DateTime time, int months) {
            return (helper.AddMonths(time, months));
        }

        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.AddYears"]/*' />
        public override DateTime AddYears(DateTime time, int years) {
            return (helper.AddYears(time, years));
        }
        
        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.GetDaysInMonth"]/*' />
        public override int GetDaysInMonth(int year, int month, int era) {
            return (helper.GetDaysInMonth(year, month, era));
        }

        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.GetDaysInYear"]/*' />
        public override int GetDaysInYear(int year, int era) {
            return (helper.GetDaysInYear(year, era));
        }

        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.GetDayOfMonth"]/*' />
        public override int GetDayOfMonth(DateTime time) {
            return (helper.GetDayOfMonth(time));
        }

        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.GetDayOfWeek"]/*' />
        public override DayOfWeek GetDayOfWeek(DateTime time)  {
            return (helper.GetDayOfWeek(time));
        }

        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.GetDayOfYear"]/*' />
        public override int GetDayOfYear(DateTime time)
        {
            return (helper.GetDayOfYear(time));
        }

        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.GetMonthsInYear"]/*' />
        public override int GetMonthsInYear(int year, int era) {
            return (helper.GetMonthsInYear(year, era));
        }
        
        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.GetEra"]/*' />
        public override int GetEra(DateTime time) {
            return (helper.GetEra(time));
        }
        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.GetMonth"]/*' />
        public override int GetMonth(DateTime time) {
            return (helper.GetMonth(time));
        }
        
        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.GetYear"]/*' />
        public override int GetYear(DateTime time) {
            return (helper.GetYear(time));
        } 

        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.IsLeapDay"]/*' />
        public override bool IsLeapDay(int year, int month, int day, int era)
        {
            return (helper.IsLeapDay(year, month, day, era));
        }

        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.IsLeapYear"]/*' />
        public override bool IsLeapYear(int year, int era) {
            return (helper.IsLeapYear(year, era));
        }

        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.IsLeapMonth"]/*' />
        public override bool IsLeapMonth(int year, int month, int era) {
            return (helper.IsLeapMonth(year, month, era));
        }                

        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.ToDateTime"]/*' />
        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) {
            return (helper.ToDateTime(year, month, day, hour, minute, second, millisecond, era));
        }
        
        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.Eras"]/*' />
        public override int[] Eras {
            get {
                return (helper.Eras);
            }
        }

        private const int DEFAULT_TWO_DIGIT_YEAR_MAX = 99;            
        
        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.TwoDigitYearMax"]/*' />
        public override int TwoDigitYearMax {
            get {
                if (twoDigitYearMax == -1) {
                    twoDigitYearMax = GetSystemTwoDigitYearSetting(ID, DEFAULT_TWO_DIGIT_YEAR_MAX);
                }
                return (twoDigitYearMax);
            }

            set {
                if (value < 100 || value > helper.MaxYear) {
                    throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    100, helper.MaxYear));

                }
                twoDigitYearMax = value;
            }
        }

        // For Taiwan calendar, four digit year is not used.
        // Therefore, for any two digit number, we just return the original number.
        /// <include file='doc\TaiwanCalendar.uex' path='docs/doc[@for="TaiwanCalendar.ToFourDigitYear"]/*' />
        public override int ToFourDigitYear(int year) {
            if (year <= 0) {
                throw new ArgumentOutOfRangeException("year",
                    Environment.GetResourceString("ArgumentOutOfRange_NeedPosNum"));                
            }
            if (year > helper.MaxYear) {
                throw new ArgumentOutOfRangeException("year",
                    String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 1, helper.MaxYear));
            }
            return (year);
        } 
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\unicodecategory.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: UnicodeCategory
**
** Author: Jay Roxe
**
** Purpose: 
**
** Date: 
**
============================================================*/
namespace System.Globalization {
    /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory"]/*' />
    [Serializable]
    public enum UnicodeCategory {
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.UppercaseLetter"]/*' />
        UppercaseLetter = 0,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.LowercaseLetter"]/*' />
        LowercaseLetter = 1,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.TitlecaseLetter"]/*' />
        TitlecaseLetter = 2,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.ModifierLetter"]/*' />
        ModifierLetter = 3,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.OtherLetter"]/*' />
        OtherLetter = 4,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.NonSpacingMark"]/*' />
        NonSpacingMark = 5,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.SpacingCombiningMark"]/*' />
        SpacingCombiningMark = 6,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.EnclosingMark"]/*' />
        EnclosingMark = 7,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.DecimalDigitNumber"]/*' />
        DecimalDigitNumber = 8,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.LetterNumber"]/*' />
        LetterNumber = 9,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.OtherNumber"]/*' />
        OtherNumber = 10,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.SpaceSeparator"]/*' />
        SpaceSeparator = 11,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.LineSeparator"]/*' />
        LineSeparator = 12,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.ParagraphSeparator"]/*' />
        ParagraphSeparator = 13,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.Control"]/*' />
        Control = 14,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.Format"]/*' />
        Format = 15,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.Surrogate"]/*' />
        Surrogate = 16,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.PrivateUse"]/*' />
        PrivateUse = 17,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.ConnectorPunctuation"]/*' />
        ConnectorPunctuation = 18,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.DashPunctuation"]/*' />
        DashPunctuation = 19,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.OpenPunctuation"]/*' />
        OpenPunctuation = 20,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.ClosePunctuation"]/*' />
        ClosePunctuation = 21,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.InitialQuotePunctuation"]/*' />
        InitialQuotePunctuation = 22,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.FinalQuotePunctuation"]/*' />
        FinalQuotePunctuation = 23,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.OtherPunctuation"]/*' />
        OtherPunctuation = 24,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.MathSymbol"]/*' />
        MathSymbol = 25,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.CurrencySymbol"]/*' />
        CurrencySymbol = 26,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.ModifierSymbol"]/*' />
        ModifierSymbol = 27,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.OtherSymbol"]/*' />
        OtherSymbol = 28,
        /// <include file='doc\UnicodeCategory.uex' path='docs/doc[@for="UnicodeCategory.OtherNotAssigned"]/*' />
        OtherNotAssigned = 29,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\thaibuddhistcalendar.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Globalization {

    using System;

    /*=================================ThaiBuddhistCalendar==========================
    **
    ** ThaiBuddhistCalendar is based on Gregorian calendar.  Its year value has 
    ** an offset to the Gregorain calendar.
    **
    **  Calendar support range:
    **      Calendar    Minimum     Maximum
    **      ==========  ==========  ==========
    **      Gregorian   0001/01/01   9999/12/31
    **      Thai        0544/01/01  10542/12/31    
    ============================================================================*/
    
    /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar"]/*' />
    [Serializable] public class ThaiBuddhistCalendar: Calendar {

        static internal EraInfo[] m_EraInfo;
        //
        // The era value for the current era.
        //
        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.ThaiBuddhistEra"]/*' />
        public const int ThaiBuddhistEra = 1;
                
        internal static Calendar m_defaultInstance = null;

        internal GregorianCalendarHelper helper;        

        /*=================================GetDefaultInstance==========================
        **Action: Internal method to provide a default intance of ThaiBuddhistCalendar.  Used by NLS+ implementation
        **       and other calendars.
        **Returns:
        **Arguments:
        **Exceptions:
        ============================================================================*/

        internal static Calendar GetDefaultInstance() {
            if (m_defaultInstance == null) {
                m_defaultInstance = new ThaiBuddhistCalendar();
            }
            return (m_defaultInstance);
        }

        static ThaiBuddhistCalendar() {
            // Since
            //    Gregorian Year = Era Year + yearOffset
            // When Gregorian Year 1 is Thai Buddhist year 544, so that
            //    1 = 544 + yearOffset
            //  So yearOffset = -543
            // Gregorian Year 2001 is Thai Buddhist Year 2544.            
            //m_EraInfo[0] = new EraInfo(1, new DateTime(1, 1, 1).Ticks, -543, 544, GregorianCalendar.MaxYear + 543);
            m_EraInfo = GregorianCalendarHelper.InitEraInfo(Calendar.CAL_THAI);
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.ThaiBuddhistCalendar"]/*' />
        public ThaiBuddhistCalendar() {
            helper = new GregorianCalendarHelper(this, m_EraInfo);
        }

        internal override int ID {
            get {
                return (CAL_THAI);
            }
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.AddMonths"]/*' />
        public override DateTime AddMonths(DateTime time, int months) {
            return (helper.AddMonths(time, months));
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.AddYears"]/*' />
        public override DateTime AddYears(DateTime time, int years) {
            return (helper.AddYears(time, years));
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.GetDaysInMonth"]/*' />
        public override int GetDaysInMonth(int year, int month, int era) {
            return (helper.GetDaysInMonth(year, month, era));
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.GetDaysInYear"]/*' />
        public override int GetDaysInYear(int year, int era) {
            return (helper.GetDaysInYear(year, era));
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.GetDayOfMonth"]/*' />
        public override int GetDayOfMonth(DateTime time) {
            return (helper.GetDayOfMonth(time));
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.GetDayOfWeek"]/*' />
        public override DayOfWeek GetDayOfWeek(DateTime time)  {
            return (helper.GetDayOfWeek(time));
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.GetDayOfYear"]/*' />
        public override int GetDayOfYear(DateTime time)
        {
            return (helper.GetDayOfYear(time));
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.GetMonthsInYear"]/*' />
        public override int GetMonthsInYear(int year, int era) {
            return (helper.GetMonthsInYear(year, era));
        }
        
        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.GetEra"]/*' />
        public override int GetEra(DateTime time) {
            return (helper.GetEra(time));
        }
        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.GetMonth"]/*' />
        public override int GetMonth(DateTime time) {
            return (helper.GetMonth(time));
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.GetYear"]/*' />
        public override int GetYear(DateTime time) {
            return (helper.GetYear(time));
        } 

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.IsLeapDay"]/*' />
        public override bool IsLeapDay(int year, int month, int day, int era)
        {
            return (helper.IsLeapDay(year, month, day, era));
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.IsLeapYear"]/*' />
        public override bool IsLeapYear(int year, int era) {
            return (helper.IsLeapYear(year, era));
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.IsLeapMonth"]/*' />
        public override bool IsLeapMonth(int year, int month, int era) {
            return (helper.IsLeapMonth(year, month, era));
        }                

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.ToDateTime"]/*' />
        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era) {
            return (helper.ToDateTime(year, month, day, hour, minute, second, millisecond, era));
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.Eras"]/*' />
        public override int[] Eras {
            get {
                return (helper.Eras);
            }
        }

        private const int DEFAULT_TWO_DIGIT_YEAR_MAX = 2572;            
        
        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.TwoDigitYearMax"]/*' />
        public override int TwoDigitYearMax
        {
            get
            {
                if (twoDigitYearMax == -1) {
                    twoDigitYearMax = GetSystemTwoDigitYearSetting(ID, DEFAULT_TWO_DIGIT_YEAR_MAX);
                }
                return (twoDigitYearMax);
            }

            set {
                if (value < 100 || value > helper.MaxYear) {
                    throw new ArgumentOutOfRangeException("year", String.Format(Environment.GetResourceString("ArgumentOutOfRange_Range"), 
                    100, helper.MaxYear));

                }
                twoDigitYearMax = value;
            }
        }

        /// <include file='doc\ThaiBuddhistCalendar.uex' path='docs/doc[@for="ThaiBuddhistCalendar.ToFourDigitYear"]/*' />
        public override int ToFourDigitYear(int year) {
            return (helper.ToFourDigitYear(year, this.TwoDigitYearMax));
        }        
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\tables\tools\encodingtable\fromurt.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __FROMURT_H
#define __FROMURT_H

struct CodePageDataItem {
    int    codePage;
    int    uiFamilyCodePage;
    WCHAR  webName[64];
    WCHAR  headerName[64];
    WCHAR  bodyName[64];
    WCHAR  description[256];
    DWORD  dwFlags;
};

extern BOOL CaseInsensitiveCompHelper(WCHAR *strAChars, WCHAR *strBChars, INT32 aLength, INT32 bLength, INT32 *result);
extern CodePageDataItem ExtraCodePageData[];
extern int g_nExtraCodePageDataItems;

extern CodePageDataItem g_ReplacedCodePageData[];
extern int g_nReplacedCodePageDataItems;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\tables\tools\encodingtable\frommlang.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <objbase.h>
#include <mlang.h>
#include "FromMLang.h"

// --------------------------------------------------------------
// KEEP THIS TABLE IN SYNC WITH MLANG!!!
// KEEP THIS TABLE IN SYNC WITH MLANG!!!
// KEEP THIS TABLE IN SYNC WITH MLANG!!!
//
// NOTENOTE YSLin:
//   This table is from mimedb.cpp from MLang.
//   There is no interface exposed to get this data structre.  So
//   we have to copy/paste it in here.
// --------------------------------------------------------------


// Table pre-sorted by charset for binary search !!!
MIMECHARSET MimeCharSet[] =
{
//  { Charset, CodePage, InternetEncoding, Flags }
    { L"_autodetect", 50932, 50932, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"_autodetect_all", 50001, 50001, MIMECONTF_MIME_LATEST},
    { L"_autodetect_kr", 50949, 50949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"_iso-2022-jp$ESC", 932, 50221, MIMECONTF_MIME_IE4 },
    { L"_iso-2022-jp$SIO", 932, 50222, MIMECONTF_MIME_IE4 },
    { L"437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"ANSI_X3.4-1968", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ANSI_X3.4-1968", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"ANSI_X3.4-1986", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ANSI_X3.4-1986", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"arabic", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"arabic", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ascii", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ascii", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"ASMO-708", 1256, 708, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"Big5", 950, 950, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"Big5-HKSCS", 950, 950, MIMECONTF_MIME_LATEST},
    { L"CCSID00858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"CCSID00924", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"CCSID01140", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"CCSID01141", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"CCSID01142", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"CCSID01143", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"CCSID01144", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"CCSID01145", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"CCSID01146", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"CCSID01147", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"CCSID01148", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"CCSID01149", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"chinese", 936, 936, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"cn-big5", 950, 950, MIMECONTF_MIME_LATEST},
    { L"CN-GB", 936, 936, MIMECONTF_MIME_LATEST },
    { L"CP00858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"CP00924", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"CP01140", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"CP01141", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"CP01142", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"CP01143", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"CP01144", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"CP01145", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"CP01146", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"CP01147", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"CP01148", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"CP01149", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"cp037", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"cp1025", 1251, 21025, MIMECONTF_MIME_LATEST },
    { L"CP1026", 1254, 1026, MIMECONTF_MIME_LATEST },
    { L"cp1256", 1256, 1256, MIMECONTF_MIME_LATEST },
    { L"cp20001", 1252, 20001, MIMECONTF_MIME_LATEST },
    { L"cp20003", 1252, 20003, MIMECONTF_MIME_LATEST },
    { L"cp20004", 1252, 20004, MIMECONTF_MIME_LATEST },
    { L"cp20005", 1252, 20005, MIMECONTF_MIME_LATEST },
    { L"cp20261", 1252, 20261, MIMECONTF_MIME_LATEST },
    { L"cp20269", 1252, 20269, MIMECONTF_MIME_LATEST },
    { L"cp20936", 1252, 20936, MIMECONTF_MIME_LATEST },
    { L"cp20949", 1252, 20949, MIMECONTF_MIME_LATEST },
    { L"cp21027", 1252, 21027, MIMECONTF_MIME_LATEST },
    { L"CP273", 1252, 20273, MIMECONTF_MIME_LATEST },
    { L"CP278", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"CP280", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"CP284", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"CP285", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"cp290", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"cp297", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"cp367", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"cp367", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"cp420", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"cp423", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"cp424", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"cp437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"CP500", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"cp50227", 1252, 50227, MIMECONTF_MIME_LATEST },
    { L"cp50229", 1252, 50229, MIMECONTF_MIME_LATEST },    
    { L"cp819", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"cp819", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"cp850", 1252, 850, MIMECONTF_MIME_LATEST },
    { L"cp852", 1250, 852, MIMECONTF_MIME_LATEST},
    { L"cp852", 852, 852, MIMECONTF_MIME_IE4 },
    { L"cp855", 1250, 855, MIMECONTF_MIME_LATEST },
    { L"cp857", 1254, 857, MIMECONTF_MIME_LATEST },
    { L"cp858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"cp860", 1252, 860, MIMECONTF_MIME_LATEST },
    { L"cp861", 1252, 861, MIMECONTF_MIME_LATEST },
    { L"cp862", 1255, 862, MIMECONTF_MIME_LATEST },
    { L"cp863", 1252, 863, MIMECONTF_MIME_LATEST },
    { L"cp864", 1256, 864, MIMECONTF_MIME_LATEST },
    { L"cp865", 1252, 865, MIMECONTF_MIME_LATEST },
    { L"cp866", 1251, 866, MIMECONTF_MIME_LATEST },
    { L"cp866", 866, 866, MIMECONTF_MIME_IE4 },
    { L"cp869", 1253, 869, MIMECONTF_MIME_LATEST },
    { L"CP870", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"CP871", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"cp875", 1253, 875, MIMECONTF_MIME_LATEST },
    { L"cp880", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"CP905", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"cp930", 932, 50930, MIMECONTF_MIME_LATEST },
    { L"cp933", 949, 50933, MIMECONTF_MIME_LATEST },
    { L"cp935", 936, 50935, MIMECONTF_MIME_LATEST },
    { L"cp937", 950, 50937, MIMECONTF_MIME_LATEST },
    { L"cp939", 932, 50939, MIMECONTF_MIME_LATEST },
    { L"csASCII", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"csASCII", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"csbig5", 950, 950, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"csEUCKR", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"csEUCPkdFmtJapanese", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csGB2312", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csGB231280", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csIBM037", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"csIBM1026", 1254, 1026, MIMECONTF_MIME_LATEST },
    { L"csIBM273", 1252, 20273, MIMECONTF_MIME_LATEST },
    { L"csIBM277", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"csIBM278", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"csIBM280", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"csIBM284", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"csIBM285", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"csIBM290", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"csIBM297", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"csIBM420", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"csIBM423", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"csIBM424", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"csIBM500", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"csIBM870", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"csIBM871", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"csIBM880", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"csIBM905", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"csIBMThai", 874, 20838, MIMECONTF_MIME_LATEST },
    { L"csISO2022JP", 932, 50221, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISO2022KR", 949, 50225, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISO58GB231280", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatin1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"csISOLatin2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatin3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"csISOLatin4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatin5", 1254, 28599, MIMECONTF_MIME_LATEST },
    { L"csISOLatin5", 1251, 28595, MIMECONTF_MIME_IE4},
    { L"csISOLatin9", 1252, 28605, MIMECONTF_MIME_LATEST },
    { L"csISOLatinArabic", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"csISOLatinArabic", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"csISOLatinCyrillic", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatinGreek", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatinHebrew", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csKOI8R", 1251, 20866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csKSC56011987", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csPC8CodePage437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"csShiftJIS", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csUnicode11UTF7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csWindows31J", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"cyrillic", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"DIN_66003", 1252, 20106, MIMECONTF_MIME_LATEST},
    { L"DOS-720", 1256, 720, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"DOS-862", 1255, 862, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"DOS-874", 874, 874, MIMECONTF_MIME_LATEST},
    { L"ebcdic-cp-ar1", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-be", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-ca", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-ch", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-CP-DK", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-es", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-fi", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-fr", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-gb", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-gr", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-he", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-is", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-it", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-nl", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-CP-NO", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-roece", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-se", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-tr", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-us", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-wt", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-yu", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-Cyrillic", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"ebcdic-de-273+euro", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"ebcdic-dk-277+euro", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"ebcdic-es-284+euro", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"ebcdic-fi-278+euro", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"ebcdic-fr-297+euro", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"ebcdic-gb-285+euro", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"ebcdic-international-500+euro", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"ebcdic-is-871+euro", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"ebcdic-it-280+euro", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-JP-kana", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"ebcdic-Latin9--euro", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"ebcdic-no-277+euro", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"ebcdic-se-278+euro", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"ebcdic-us-37+euro", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"ECMA-114", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"ECMA-114", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ECMA-118", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ELOT_928", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"euc-cn", 936, 51936, MIMECONTF_MIME_LATEST},
    { L"euc-jp", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"euc-kr", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"euc-kr", 949, 949, MIMECONTF_MIME_IE4 },
    { L"Extended_UNIX_Code_Packed_Format_for_Japanese", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"gb18030", 54936, 54936, MIMECONTF_MIME_LATEST },
    { L"GB_2312-80", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"GB2312", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"GB2312-80", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"GB231280", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"GBK", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"German", 1252, 20106, MIMECONTF_MIME_LATEST},
    { L"greek", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"greek8", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"hebrew", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"hz-gb-2312", 936, 52936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"IBM00858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"IBM00924", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"IBM01047", 1252, 1047, MIMECONTF_MIME_LATEST },
    { L"IBM01140", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"IBM01141", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"IBM01142", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"IBM01143", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"IBM01144", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"IBM01145", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"IBM01146", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"IBM01147", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"IBM01148", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"IBM01149", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"IBM037", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"IBM1026", 1254, 1026, MIMECONTF_MIME_LATEST },
    { L"IBM273", 1252, 20273, MIMECONTF_MIME_LATEST },
    { L"IBM277", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"IBM278", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"IBM280", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"IBM284", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"IBM285", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"IBM290", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"IBM297", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"IBM367", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"IBM367", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"IBM420", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"IBM423", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"IBM424", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"IBM437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"IBM500", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"ibm737", 1252, 737, MIMECONTF_MIME_LATEST},
    { L"ibm775", 1257, 775, MIMECONTF_MIME_LATEST},
    { L"ibm819", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"ibm819", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"IBM850", 1252, 850, MIMECONTF_MIME_LATEST },
    { L"IBM852", 1250, 852, MIMECONTF_MIME_LATEST },
    { L"IBM852", 852, 852, MIMECONTF_MIME_IE4 },
    { L"IBM855", 1250, 855, MIMECONTF_MIME_LATEST },
    { L"IBM857", 1254, 857, MIMECONTF_MIME_LATEST },
    { L"IBM860", 1252, 860, MIMECONTF_MIME_LATEST },
    { L"IBM861", 1252, 861, MIMECONTF_MIME_LATEST },
    { L"IBM862", 1255, 862, MIMECONTF_MIME_LATEST },
    { L"IBM863", 1252, 863, MIMECONTF_MIME_LATEST },
    { L"IBM864", 1256, 864, MIMECONTF_MIME_LATEST },
    { L"IBM865", 1252, 865, MIMECONTF_MIME_LATEST },
    { L"IBM866", 1251, 866, MIMECONTF_MIME_LATEST },
    { L"IBM866", 866, 866, MIMECONTF_MIME_IE4 },
    { L"IBM869", 1253, 869, MIMECONTF_MIME_LATEST },
    { L"IBM870", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"IBM871", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"IBM880", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"IBM905", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"IBM-Thai", 874, 20838, MIMECONTF_MIME_LATEST },
    { L"irv", 1252, 20105, MIMECONTF_MIME_LATEST},
    { L"ISO-10646-UCS-2", 1200, 1200, MIMECONTF_MIME_LATEST},
    { L"ISO_646.irv:1991", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ISO_646.irv:1991", 1252, 1252,  MIMECONTF_MIME_IE4},
    { L"iso_8859-1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"iso_8859-1", 1252, 1252,  MIMECONTF_MIME_IE4 },
    { L"iso_8859-1:1987", 1252, 28591, MIMECONTF_MIME_LATEST },
    { L"iso_8859-1:1987", 1252, 1252, MIMECONTF_MIME_IE4 },
    { L"ISO_8859-15", 1252, 28605, MIMECONTF_MIME_LATEST},
    { L"iso_8859-2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso_8859-2:1987", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-3:1988", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-4:1988", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-5", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-5:1988", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-6", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-6", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ISO_8859-6:1987", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-6:1987", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ISO_8859-7",  1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-7:1987",  1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-8", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-8:1988", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-8-I", 1255, 1255, MIMECONTF_MIME_IE4 },
    { L"ISO_8859-9", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-9", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"ISO_8859-9:1989", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-9:1989", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"iso-2022-jp", 932, 50220, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-2022-jpeuc", 932, 51932, MIMECONTF_MIME_LATEST},
    { L"iso-2022-kr", 949, 50225, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-2022-kr-7", 949, 50225, MIMECONTF_MIME_LATEST},
    { L"iso-2022-kr-7bit", 949, 50225, MIMECONTF_MIME_LATEST},
    { L"iso-2022-kr-8", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"iso-2022-kr-8bit", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"ISO646-US", 1252, 20127, MIMECONTF_MIME_LATEST },
    { L"ISO646-US", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"iso8859-1", 1252, 28591, MIMECONTF_MIME_LATEST },
    { L"iso8859-1", 1252, 1252, MIMECONTF_MIME_IE4 },
    { L"iso-8859-1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"iso-8859-1", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"iso-8859-11", 874, 874, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-13", 1257, 28603, MIMECONTF_MIME_LATEST},
    { L"iso-8859-15", 1252, 28605, MIMECONTF_MIME_LATEST},
    { L"iso8859-2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-8859-2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-3", 1254, 28593, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-5", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-6", 1256, 28596, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-7", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-8", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"ISO-8859-8 Visual", 1255, 28598, MIMECONTF_MIME_LATEST},
    { L"ISO-8859-8 Visual", 1255, 1255, MIMECONTF_MIME_IE4},
    { L"iso-8859-8-i", 1255, 38598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-9", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"iso-8859-9", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"iso-ir-100", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"iso-ir-100", 1252, 1252, MIMECONTF_MIME_IE4 },
    { L"iso-ir-101", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-109", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"iso-ir-110", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-126",  1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-127", 1256, 28596, MIMECONTF_MIME_LATEST },
    { L"iso-ir-127", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"iso-ir-138", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-144", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-148", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"iso-ir-148", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"iso-ir-149", 949, 949, MIMECONTF_MIME_LATEST},
    { L"iso-ir-58", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-6", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"iso-ir-6", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"Johab", 1361, 1361, MIMECONTF_MIME_LATEST},
    { L"koi", 1251, 20866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"koi8", 1251, 20866, MIMECONTF_MIME_LATEST},
    { L"koi8r", 1251, 20866, MIMECONTF_MIME_LATEST},
    { L"koi8-r", 1251, 20866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"koi8-ru", 1251, 21866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"koi8-u", 1251, 21866, MIMECONTF_MIME_LATEST},
    { L"korean", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ks_c_5601", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ks_c_5601_1987", 949, 949, MIMECONTF_MIME_LATEST},
    { L"ks_c_5601-1987", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"ks_c_5601-1989", 949, 949, MIMECONTF_MIME_LATEST},
    { L"KSC_5601", 949, 949, MIMECONTF_MIME_LATEST},
    { L"KSC5601", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ks-c5601", 949, 949, MIMECONTF_MIME_LATEST},
    { L"ks-c-5601", 949, 949, MIMECONTF_MIME_LATEST},
    { L"l1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"l2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"l3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"l4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"l5", 1254, 28599, MIMECONTF_MIME_LATEST },
    { L"l5", 1251, 28595, MIMECONTF_MIME_IE4 },
    { L"l9", 1252, 28605, MIMECONTF_MIME_LATEST },
    { L"latin1", 1252, 28591, MIMECONTF_MIME_LATEST },
    { L"latin1", 1252, 1252,  MIMECONTF_MIME_IE4 },
    { L"latin2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"latin3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"latin4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"latin5", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"latin5", 1254, 1254, MIMECONTF_MIME_IE4},
    { L"latin9", 1252, 28605, MIMECONTF_MIME_LATEST},
    { L"logical", 1255, 28598, MIMECONTF_MIME_LATEST},
    { L"logical", 1255, 1255, MIMECONTF_MIME_IE4},
    { L"macintosh", 1252, 10000, MIMECONTF_MIME_LATEST},
    { L"ms_Kanji", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"Norwegian", 1252, 20108, MIMECONTF_MIME_LATEST},
    { L"NS_4551-1", 1252, 20108, MIMECONTF_MIME_LATEST},
    { L"PC-Multilingual-850+euro", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"SEN_850200_B", 1252, 20107, MIMECONTF_MIME_LATEST},
    { L"shift_jis", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"shift-jis", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"sjis", 932, 932, MIMECONTF_MIME_LATEST},
    { L"Swedish", 1252, 20107, MIMECONTF_MIME_LATEST},
    { L"TIS-620", 874, 874, MIMECONTF_MIME_LATEST},
    { L"ucs-2", 1200, 1200, MIMECONTF_MIME_LATEST},
    { L"unicode", 1200, 1200, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"unicode-1-1-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"unicode-1-1-utf-8", 1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"unicode-2-0-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST},
    { L"unicode-2-0-utf-8",1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"unicodeFFFE", 1200, 1201, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"us", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"us", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"us-ascii", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"us-ascii", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"utf-16", 1200, 1200, MIMECONTF_MIME_LATEST },
    { L"UTF-16BE", 1200, 1201, MIMECONTF_MIME_LATEST },
    { L"UTF-16LE", 1200, 1200, MIMECONTF_MIME_LATEST },
    { L"utf-7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"utf-8", 1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"visual", 1255, 28598, MIMECONTF_MIME_LATEST},
    { L"visual", 1255, 1255, MIMECONTF_MIME_IE4 },
    { L"windows-1250", 1250, 1250, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1251", 1251, 1251, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1252", 1252, 1252, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1253", 1253, 1253, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"Windows-1254", 1254, 1254, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1255", 1255, 1255, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1256", 1256, 1256, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1257", 1257, 1257, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1258", 1258, 1258, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-20932-2000", 932, 20932, MIMECONTF_MIME_LATEST },
    { L"windows-874", 874, 874, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-ansi", 1252, 1252, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-Chinese-CNS", 950, 20000, MIMECONTF_MIME_LATEST},
    { L"x-Chinese-Eten", 950, 20002, MIMECONTF_MIME_LATEST},
    { L"x-cp1250", 1250, 1250, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-cp1251", 1251, 1251, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"X-EBCDIC-JapaneseAndUSCanada", 932, 50931, MIMECONTF_MIME_LATEST },
    { L"X-EBCDIC-KoreanExtended", 949, 20833, MIMECONTF_MIME_LATEST },
    { L"x-euc", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-euc-cn", 936, 51936, MIMECONTF_MIME_LATEST},
    { L"x-euc-jp", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-Europa", 1252, 29001, MIMECONTF_MIME_LATEST},
    { L"x-IA5", 1252, 20105, MIMECONTF_MIME_LATEST},
    { L"x-IA5-German", 1252, 20106, MIMECONTF_MIME_LATEST},
    { L"x-IA5-Norwegian", 1252, 20108, MIMECONTF_MIME_LATEST},
    { L"x-IA5-Swedish", 1252, 20107, MIMECONTF_MIME_LATEST},
    { L"x-iscii-as", 57006, 57006, MIMECONTF_MIME_LATEST},
    { L"x-iscii-be", 57003, 57003, MIMECONTF_MIME_LATEST},
    { L"x-iscii-de", 57002, 57002, MIMECONTF_MIME_LATEST},
    { L"x-iscii-gu", 57010, 57010, MIMECONTF_MIME_LATEST},
    { L"x-iscii-ka", 57008, 57008, MIMECONTF_MIME_LATEST},
    { L"x-iscii-ma", 57009, 57009, MIMECONTF_MIME_LATEST},
    { L"x-iscii-or", 57007, 57007, MIMECONTF_MIME_LATEST},
    { L"x-iscii-pa", 57011, 57011, MIMECONTF_MIME_LATEST},
    { L"x-iscii-ta", 57004, 57004, MIMECONTF_MIME_LATEST},
    { L"x-iscii-te", 57005, 57005, MIMECONTF_MIME_LATEST},
    { L"x-mac-arabic", 1256, 10004, MIMECONTF_MIME_LATEST},
    { L"x-mac-ce", 1250, 10029, MIMECONTF_MIME_LATEST},
    { L"x-mac-chinesesimp", 936, 10008, MIMECONTF_MIME_LATEST},
    { L"x-mac-chinesetrad", 950, 10002, MIMECONTF_MIME_LATEST},
    { L"x-mac-croatian", 1250, 10082, MIMECONTF_MIME_LATEST}, 
    { L"x-mac-cyrillic", 1251, 10007, MIMECONTF_MIME_LATEST},
    { L"x-mac-greek", 1253, 10006, MIMECONTF_MIME_LATEST},
    { L"x-mac-hebrew", 1255, 10005, MIMECONTF_MIME_LATEST},
    { L"x-mac-icelandic", 1252, 10079, MIMECONTF_MIME_LATEST},
    { L"x-mac-japanese", 932, 10001, MIMECONTF_MIME_LATEST},
    { L"x-mac-korean", 949, 10003, MIMECONTF_MIME_LATEST},
    { L"x-mac-romanian", 1250, 10010, MIMECONTF_MIME_LATEST},
    { L"x-mac-thai", 874, 10021, MIMECONTF_MIME_LATEST},
    { L"x-mac-turkish", 1254, 10081, MIMECONTF_MIME_LATEST},
    { L"x-mac-ukrainian", 1251, 10017, MIMECONTF_MIME_LATEST},
    { L"x-ms-cp932", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-sjis", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-unicode-1-1-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST},
    { L"x-unicode-1-1-utf-8", 1200, 65001, MIMECONTF_MIME_LATEST},
    { L"x-unicode-2-0-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"x-unicode-2-0-utf-8", 1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"x-user-defined", 50000, 50000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"x-x-big5", 950, 950, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},

//  { Charset, CodePage, InternetEncoding, Flags }
};

const int g_nMIMECharsets = sizeof(MimeCharSet)/sizeof(MIMECHARSET);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\tables\tools\encodingtable\frommlang.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __FROMMLANG_H
#define __FROMMLANG_H

typedef struct tagMIMEREGCHARSET
{
    LPCWSTR szCharset;
    UINT uiCodePage;
    UINT uiInternetEncoding;
    DWORD   dwFlags;
}   MIMECHARSET;

//
// Forward declaration
//
extern MIMECHARSET MimeCharSet[];
extern const int g_nMIMECharsets;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\tables\tools\encodingtable\fromurt.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include <objbase.h>
#include <mlang.h>
#include "FromURT.h"

//
// These are extra CodePageDataItems for which MLang doesn't contain information.
//
//


CodePageDataItem ExtraCodePageData[1];
/*
{
    { 20932, 932, L"windows-20932-2000", L"windows-20932-2000", L"windows-20932-2000", L"Japanese EUC:ASCii,Halfwidth Katakana,JIS X 0208-1990 & 0212-1990", MIMECONTF_MIME_LATEST },
    { 54936, 936, L"gb18030", L"gb18030", L"gb18030", L"GB 18030-2000 Simplified Chinese", MIMECONTF_MIME_LATEST},
};
*/

//int g_nExtraCodePageDataItems = sizeof(ExtraCodePageData)/sizeof(ExtraCodePageData[0]);
int g_nExtraCodePageDataItems = 0;


//
// Although MLang contains the following codepage, we replace MLang information with the
// information below.
//
CodePageDataItem g_ReplacedCodePageData[] =
{
    { 1200,  1200, L"utf-16", L"utf-16", L"utf-16", L"Unicode", MIMECONTF_MIME_LATEST | MIMECONTF_SAVABLE_BROWSER },
};

int g_nReplacedCodePageDataItems = sizeof(g_ReplacedCodePageData)/sizeof(g_ReplacedCodePageData[0]);

//
// The code here is from COMString.cpp.
//
BOOL CaseInsensitiveCompHelper(WCHAR *strAChars, WCHAR *strBChars, INT32 aLength, INT32 bLength, INT32 *result) 
{
    WCHAR charA;
    WCHAR charB;
    WCHAR *strAStart;
        
    strAStart = strAChars;

    *result = 0;

    //setup the pointers so that we can always increment them.
    //We never access these pointers at the negative offset.
    strAChars--;
    strBChars--;

    do {
        strAChars++; strBChars++;

        charA = *strAChars;
        charB = *strBChars;
            
        //Case-insensitive comparison on chars greater than 0x80 
        //requires a locale-aware casing operation and we're not going there.
        if (charA>=0x80 || charB>=0x80) {
            return FALSE;
        }
          
        //Do the right thing if they differ in case only.
        //We depend on the fact that the uppercase and lowercase letters in the
        //range which we care about (A-Z,a-z) differ only by the 0x20 bit. 
        //The check below takes the xor of the two characters and determines if this bit
        //is only set on one of them.
        //If they're different cases, we know that we need to execute only
        //one of the conditions within block.
        if ((charA^charB)&0x20) {
            if (charA>='A' && charA<='Z') {
                charA |=0x20;
            } else if (charB>='A' && charB<='Z') {
                charB |=0x20;
            }
        }
    } while (charA==charB && charA!=0);
        
    //Return the (case-insensitive) difference between them.
    if (charA!=charB) {
        *result = (int)(charA-charB);
        return TRUE;
    }

    //The length of b was unknown because it was just a pointer to a null-terminated string.
    //If we get here, we know that both A and B are pointing at a null.  However, A can have
    //an embedded null.  Check the number of characters that we've walked in A against the 
    //expected length.
    if (bLength==-1) {
        if ((strAChars - strAStart)!=aLength) {
            *result = 1;
            return TRUE;
        }
        *result=0;
        return TRUE;
    }

    *result = (aLength - bLength);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\globalization\tables\tools\encodingtable\genencodingcpp.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// GenEncodingCpp.cpp
//
// Generate the EncodingDate.cpp in the URT source.
//
// FromMLang.cpp contains data which maps an encoding name into a specific codepage.
// To add extra encoding name -> codepage mapping, add them in the end of
// MimeCharSet.


#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <mlang.h>
#include "FromMLang.h"
#include "FromURT.h"

const CLSID CLSID_CMultiLanguage = {0x275c23e2,0x3747,0x11d0,{0x9f,0xea,0x00,0xaa,0x00,0x3f,0x86,0x46}};
const IID IID_IMultiLanguage2 = {0xDCCFC164,0x2B38,0x11d2,{0xb7,0xec,0x00,0xc0,0x4f,0x8f,0x5d,0x9a}};

FILE* m_ResourceFile;
CHAR m_szResourceFileName[] = "EncodingResource.txt";

FILE* m_EncodingCPP;
CHAR m_szCPPFileName[] = "EncodingData.cpp";

IMultiLanguage2* m_pIMultiLanguage2;
IEnumCodePage*  m_pIEnumCodePages;

UINT m_nCodePageItems;
CodePageDataItem* m_pCodePageDataItems;


BOOL InitGlobals()
{
    if (CoCreateInstance(
        CLSID_CMultiLanguage, 
        NULL, 
        CLSCTX_INPROC_SERVER, 
        IID_IMultiLanguage2, 
        (LPVOID*)&m_pIMultiLanguage2) != S_OK) 
    {
        printf("Failed in getting IMultiLanguage2 from MLang.\n");
        return(FALSE);
    }

    if (FAILED(m_pIMultiLanguage2->EnumCodePages(MIMECONTF_MIME_LATEST, 0x0409, &m_pIEnumCodePages))) 
    {
        printf("Failed in getting IEnumCodePages from MLang.\n");
        return(FALSE);
    }

    if (!(m_EncodingCPP = fopen(m_szCPPFileName, "w"))) 
    {
        printf("Failed in create %s.\n", m_szCPPFileName);
        return (FALSE);
    }

    if (!(m_ResourceFile = fopen(m_szResourceFileName, "w"))) 
    {
        printf("Failed in create %s.\n", m_szResourceFileName);
        return (FALSE);
    }
    
    return (TRUE);
}

int GetCodePageItem(int nCodePage) 
{
    for (UINT i = 0; i < m_nCodePageItems; i++) 
    {
        if (nCodePage == m_pCodePageDataItems[i].codePage) {
            return (i);
        }
    }
    printf("WARNING: data for codepage %d can not be found.\n", nCodePage);
    return (-1);
}
void GenerateHeader()
{
    fprintf(m_EncodingCPP, "#include \"common.h\"\n");
    fprintf(m_EncodingCPP, "#include <mlang.h>\n");    
    fprintf(m_EncodingCPP, "#include \"COMNlsInfo.h\"\n\n");
}

//
// Generate EncodingDataTable, which maps an encoding name into a specific
// codepage.
//
void GenerateEncodingDataTable()
{
    int i;
    fprintf(m_EncodingCPP, "//\n");
    fprintf(m_EncodingCPP, "// Encoding data tables\n");
    fprintf(m_EncodingCPP, "//\n\n");
    
    fprintf(m_EncodingCPP, "//\n");
    fprintf(m_EncodingCPP, "// Index an encoding name into an codepage in CodePageDataTable.\n");
    fprintf(m_EncodingCPP, "//\n");
    fprintf(m_EncodingCPP, "const EncodingDataItem COMNlsInfo::EncodingDataTable[] = {\n");
    
    fprintf(m_EncodingCPP, "// Total Items: %d\n", g_nMIMECharsets);
    fprintf(m_EncodingCPP, "// encoding name, codepage.\n");
    for (i = 0; i < g_nMIMECharsets; i++) 
    {
        if (MimeCharSet[i].dwFlags & MIMECONTF_MIME_LATEST) 
        {
            int codePage = MimeCharSet[i].uiInternetEncoding;
            int nItem = GetCodePageItem(codePage);
            if (nItem == -1)
            {
                fwprintf(m_EncodingCPP, L"// ");
            }
            fwprintf(m_EncodingCPP, L"{L\"%s\", %d}, \n", 
                MimeCharSet[i].szCharset, codePage);
        }
    }
    fprintf(m_EncodingCPP, "};\n\n");
    fwprintf(m_EncodingCPP, L"const COMNlsInfo::m_nEncodingDataTableItems = \n");
    fwprintf(m_EncodingCPP, L"    sizeof(COMNlsInfo::EncodingDataTable)/sizeof(EncodingDataItem);\n\n");
    
}

void GenerateCodePageDataTable()
{
    int i;
    //
    // Generate CodePageDataTable.
    //
    fprintf(m_EncodingCPP, "//\n");
    fprintf(m_EncodingCPP, "// Information about codepages.\n");
    fprintf(m_EncodingCPP, "//\n");
    
    fprintf(m_EncodingCPP, "const CodePageDataItem COMNlsInfo::CodePageDataTable[] = {\n");
    fprintf(m_EncodingCPP, "// Total Items: %d\n", m_nCodePageItems);
    fprintf(m_EncodingCPP, "// code page, family code page, web name, header name, body name, flags\n");

    fprintf(m_EncodingCPP, "\n\n");
    for (i = 0; i < (int)m_nCodePageItems; i++) 
    {
        fwprintf(m_EncodingCPP, L"{ %5d, %5d, L\"%s\", L\"%s\", L\"%s\", ", 
            m_pCodePageDataItems[i].codePage, 
            m_pCodePageDataItems[i].uiFamilyCodePage,
            m_pCodePageDataItems[i].webName,
            m_pCodePageDataItems[i].headerName,
            m_pCodePageDataItems[i].bodyName
        );
        DWORD dwFlags = m_pCodePageDataItems[i].dwFlags;
        if (dwFlags & MIMECONTF_MAILNEWS) 
        {
            fwprintf(m_EncodingCPP, L"MIMECONTF_MAILNEWS | ");
        }
        if (dwFlags & MIMECONTF_BROWSER) 
        {
            fwprintf(m_EncodingCPP, L"MIMECONTF_BROWSER | ");
        }
        if (dwFlags & MIMECONTF_SAVABLE_MAILNEWS) 
        {
            fwprintf(m_EncodingCPP, L"MIMECONTF_SAVABLE_MAILNEWS | ");
        }
        if (dwFlags & MIMECONTF_SAVABLE_BROWSER) 
        {
            fwprintf(m_EncodingCPP, L"MIMECONTF_SAVABLE_BROWSER | ");
        }
        fwprintf(m_EncodingCPP, L"0");
        fwprintf(m_EncodingCPP, L"}, // \"%s\"\n", m_pCodePageDataItems[i].description);
        
    }
    fwprintf(m_EncodingCPP, L"// End of data.\n");
    fwprintf(m_EncodingCPP, L"{ 0, 0, NULL, NULL, NULL, 0 },\n");
    
    fwprintf(m_EncodingCPP, L"};\n\n");
    fwprintf(m_EncodingCPP, L"const COMNlsInfo::m_nCodePageTableItems = \n");
    fwprintf(m_EncodingCPP, L"    sizeof(COMNlsInfo::CodePageDataTable)/sizeof(CodePageDataItem);\n\n");
}

void GenerateResourceTxt()
{
    fwprintf(m_ResourceFile, L"; Encoding names:\n");
    fwprintf(m_ResourceFile, L";\n");
    fwprintf(m_ResourceFile, L";Total items: %d\n", m_nCodePageItems);
    fwprintf(m_ResourceFile, L";\n");

    for (UINT i = 0; i < m_nCodePageItems; i++) 
    {
        fwprintf(m_ResourceFile, L"Globalization.cp_%d = %s\n", m_pCodePageDataItems[i].codePage, m_pCodePageDataItems[i].description);
    }
}
int __cdecl StringOrdinalCompare(const void *arg1, const void *arg2);
int __cdecl SortCodePage(const void *arg1, const void *arg2);

//
// Retrieve codepage info by calling MLang.
//
BOOL CollectCodePageInfo()
{
    if (FAILED(m_pIMultiLanguage2->GetNumberOfCodePageInfo(&m_nCodePageItems))) 
    {
        printf("Error in calling GetNumberOfCodePageInfo()\n");
        return (FALSE);
    }
    
    m_pCodePageDataItems = new CodePageDataItem[m_nCodePageItems+g_nExtraCodePageDataItems];
    if (!m_pCodePageDataItems) 
    {
        return (FALSE);
    }
    MIMECPINFO cpInfo;
    ULONG nCPInfoFetched;

    int i = 0;
    while (m_pIEnumCodePages->Next(1, &cpInfo, &nCPInfoFetched) == S_OK) 
    {
        if (wcsstr(cpInfo.wszWebCharset, L"detect") == 0 && wcsstr(cpInfo.wszHeaderCharset, L"detect") == 0) 
        {
            m_pCodePageDataItems[i].codePage = cpInfo.uiCodePage;
            m_pCodePageDataItems[i].uiFamilyCodePage = cpInfo.uiFamilyCodePage;
            wcscpy(m_pCodePageDataItems[i].webName, cpInfo.wszWebCharset);
            wcscpy(m_pCodePageDataItems[i].headerName, cpInfo.wszHeaderCharset);
            wcscpy(m_pCodePageDataItems[i].bodyName, cpInfo.wszBodyCharset);
            wcscpy(m_pCodePageDataItems[i].description, cpInfo.wszDescription);
            m_pCodePageDataItems[i].dwFlags = cpInfo.dwFlags;
            i++;
        } else 
        {
            // Exclude autodetect codepages.
            wprintf(L"NOTE: codepage %d \"%s\" is excluded.\n", cpInfo.uiCodePage, cpInfo.wszDescription); 
        }
    }
    
    // Update the code page item number;
    m_nCodePageItems = i;

    return (TRUE);
}

BOOL ReplaceCodePageInfo()
{
    int i;
    UINT j;
    //
    // For some of the CodePageDataItem, URT uses different data.
    // The following loops replace the MLang version with URT version.
    //
    for (i = 0; i < g_nReplacedCodePageDataItems; i++) 
    {
        for (j = 0; j < m_nCodePageItems; j++) 
        {
            if (g_ReplacedCodePageData[i].codePage == m_pCodePageDataItems[j].codePage)
            {
                m_pCodePageDataItems[j].codePage = g_ReplacedCodePageData[i].codePage;
                wcscpy(m_pCodePageDataItems[j].webName, g_ReplacedCodePageData[i].webName);
                wcscpy(m_pCodePageDataItems[j].headerName, g_ReplacedCodePageData[i].headerName);
                wcscpy(m_pCodePageDataItems[j].bodyName, g_ReplacedCodePageData[i].bodyName);
                wcscpy(m_pCodePageDataItems[j].description, g_ReplacedCodePageData[i].description);
                m_pCodePageDataItems[j].dwFlags = g_ReplacedCodePageData[i].dwFlags;

                printf("NOTE: Codepage %d data is replaced with URT data.\n", g_ReplacedCodePageData[i].codePage);
            }
        }
    }

    return (TRUE);
}

BOOL AddExtraCodePageInfo()
{
    //
    // Add extra CodePageDataItems which are not contained in MLang.
    //
    for (int i = 0; i < g_nExtraCodePageDataItems; i++) 
    {
        m_pCodePageDataItems[m_nCodePageItems].codePage = ExtraCodePageData[i].codePage;
        m_pCodePageDataItems[m_nCodePageItems].uiFamilyCodePage = ExtraCodePageData[i].uiFamilyCodePage;
        wcscpy(m_pCodePageDataItems[m_nCodePageItems].webName, ExtraCodePageData[i].webName);
        wcscpy(m_pCodePageDataItems[m_nCodePageItems].headerName, ExtraCodePageData[i].headerName);
        wcscpy(m_pCodePageDataItems[m_nCodePageItems].bodyName, ExtraCodePageData[i].bodyName);
        wcscpy(m_pCodePageDataItems[m_nCodePageItems].description, ExtraCodePageData[i].description);
        m_pCodePageDataItems[m_nCodePageItems].dwFlags = ExtraCodePageData[i].dwFlags;
        m_nCodePageItems++;
    }

    return (TRUE);
}

int __cdecl main(int argc, char* argv[])
{
    int i;
    UINT j;
    
    CoInitialize(NULL);
    if (!InitGlobals()) 
    {
        exit(1);
    }

    //
    // Sort MimeCharSet table using ordinal string sorting.
    //
    qsort((void*)MimeCharSet, g_nMIMECharsets, sizeof(MIMECHARSET), StringOrdinalCompare);

    if (!CollectCodePageInfo())
    {
        goto exit;
    }

    ReplaceCodePageInfo();
    AddExtraCodePageInfo();
    //
    // Sort m_pCodePageDataItems by codePage
    //
    qsort((void*)m_pCodePageDataItems, m_nCodePageItems, sizeof(CodePageDataItem), SortCodePage);

    GenerateHeader();
    GenerateEncodingDataTable();
    GenerateCodePageDataTable();
    GenerateResourceTxt();

    delete [] m_pCodePageDataItems;

    printf("\n\n%s is genereated correctly.\n", m_szCPPFileName);
    printf("%s is genereated correctly.\n", m_szResourceFileName);
    
exit:    
    m_pIEnumCodePages->Release();
    m_pIMultiLanguage2->Release();
    fclose(m_ResourceFile);
    CoUninitialize();
    return 0;
}

int __cdecl StringOrdinalCompare(const void *arg1, const void *arg2)
{
    MIMECHARSET* pMimeCharSet1 = (MIMECHARSET*)arg1;
    MIMECHARSET* pMimeCharSet2 = (MIMECHARSET*)arg2;
    //wprintf(L"[%s]", pMimeCharSet1->szCharset);
    int result;
    if (!CaseInsensitiveCompHelper(
        (WCHAR*)pMimeCharSet1->szCharset, (WCHAR*)pMimeCharSet2->szCharset,
        wcslen(pMimeCharSet1->szCharset),wcslen(pMimeCharSet2->szCharset),
        &result))
    {
        printf("FAILED in CaseInsensitiveCompHelper()\n");
        exit(1);
    }
    return (result);            
}

int __cdecl SortCodePage(const void *arg1, const void *arg2)
{
    CodePageDataItem* pItem1 = (CodePageDataItem*)arg1;
    CodePageDataItem* pItem2 = (CodePageDataItem*)arg2;

    return (pItem1->codePage - pItem2->codePage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\binarywriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  BinaryWriter
**
** Author: Brian Grunkemeyer (BrianGru)
**         Original implementation by Craig Sinclair (CraigSi)
**
** Purpose: Provides a way to write primitives types in 
** binary from a Stream, while also supporting writing Strings
** in a particular encoding.
**
** Date:   March 7, 2000
**
===========================================================*/
using System;
using System.Text;

namespace System.IO {
    // This abstract base class represents a writer that can write
    // primitives to an arbitrary stream. A subclass can override methods to
    // give unique encodings.
    //
    /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter"]/*' />
	[Serializable]
    public class BinaryWriter : IDisposable
    {
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Null"]/*' />
        public static readonly BinaryWriter Null = new BinaryWriter();
        
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.OutStream"]/*' />
        protected Stream OutStream;
        private byte[] _buffer;    // temp space for writing primitives to.
        private Encoding _encoding;
        private Encoder _encoder;
        private char[] _tmpOneCharBuffer = new char[1];

        // Perf optimization stuff
        private byte[] _largeByteBuffer;  // temp space for writing chars.
        private int _maxChars;   // max # of chars we can put in _largeByteBuffer
        // Size should be around the max number of chars/string * Encoding's max bytes/char
        private const int LargeByteBufferSize = 256;  

        // Protected default constructor that sets the output stream
        // to a null stream (a bit bucket).
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.BinaryWriter"]/*' />
        protected BinaryWriter()
        {
            OutStream = Stream.Null;
            _buffer = new byte[16];
            _encoding = new UTF8Encoding(false, true);
            _encoder = _encoding.GetEncoder();
        }
    
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.BinaryWriter1"]/*' />
        public BinaryWriter(Stream output) : this(output, new UTF8Encoding(false, true))
        {
        }

        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.BinaryWriter2"]/*' />
        public BinaryWriter(Stream output, Encoding encoding)
        {
            if (output==null)
                throw new ArgumentNullException("output");
            if (encoding==null)
                throw new ArgumentNullException("encoding");
            if (!output.CanWrite)
                throw new ArgumentException(Environment.GetResourceString("Argument_StreamNotWritable"));
    
            OutStream = output;
            _buffer = new byte[16];
            _encoding = encoding;
            _encoder = _encoding.GetEncoder();
        }
    
        // Closes this writer and releases any system resources associated with the
        // writer. Following a call to Close, any operations on the writer
        // may raise exceptions. 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Close"]/*' />
        public virtual void Close() 
        {
            Dispose(true);
        }

        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Dispose"]/*' />
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
                OutStream.Close();
        }

        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose()
        {
            Dispose(true);
        }
    
        /*
         * Returns the stream associate with the writer. It flushes all pending
         * writes before returning. All subclasses should override Flush to
         * ensure that all buffered data is sent to the stream.
         */
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.BaseStream"]/*' />
        public virtual Stream BaseStream {
            get {
                Flush();
                return OutStream;
            }
        }
    
        // Clears all buffers for this writer and causes any buffered data to be
        // written to the underlying device. 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Flush"]/*' />
        public virtual void Flush() 
        {
            OutStream.Flush();
        }
    
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Seek"]/*' />
        public virtual long Seek(int offset, SeekOrigin origin)
        {
            return OutStream.Seek(offset, origin);
        }
        
        // Writes a boolean to this stream. A single byte is written to the stream
        // with the value 0 representing false or the value 1 representing true.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write"]/*' />
        public virtual void Write(bool value) {
            _buffer[0] = (byte) (value ? 1 : 0);
            OutStream.Write(_buffer, 0, 1);
        }
        
        // Writes a byte to this stream. The current position of the stream is
        // advanced by one.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write1"]/*' />
        public virtual void Write(byte value) 
        {
            OutStream.WriteByte(value);
        }
        
        // Writes a signed byte to this stream. The current position of the stream 
        // is advanced by one.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write2"]/*' />
        [CLSCompliant(false)]
        public virtual void Write(sbyte value) 
        {
            OutStream.WriteByte((byte) value);
        }

        // Writes a byte array to this stream.
        // 
        // This default implementation calls the Write(Object, int, int)
        // method to write the byte array.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write3"]/*' />
        public virtual void Write(byte[] buffer) {
            if (buffer == null)
                throw new ArgumentNullException("buffer");
            OutStream.Write(buffer, 0, buffer.Length);
        }
        
        // Writes a section of a byte array to this stream.
        //
        // This default implementation calls the Write(Object, int, int)
        // method to write the byte array.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write4"]/*' />
        public virtual void Write(byte[] buffer, int index, int count) {
            OutStream.Write(buffer, index, count);
        }
        
        
        // Writes a character to this stream. The current position of the stream is
        // advanced by two.
        // Note this method cannot handle surrogates properly in UTF-8.
        //
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write5"]/*' />
        public virtual void Write(char ch) {
            BCLDebug.Assert(_encoding.GetMaxByteCount(1) <= 8, "_encoding.GetMaxByteCount(1) <= 8)");
            _tmpOneCharBuffer[0] = ch;
            int numBytes = _encoding.GetBytes(_tmpOneCharBuffer, 0, 1, _buffer, 0);
            OutStream.Write(_buffer, 0, numBytes);
        }
        
        // Writes a character array to this stream.
        // 
        // This default implementation calls the Write(Object, int, int)
        // method to write the character array.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write6"]/*' />
        public virtual void Write(char[] chars) 
        {
            if (chars == null)
                throw new ArgumentNullException("chars");

            byte[] bytes = _encoding.GetBytes(chars, 0, chars.Length);
            OutStream.Write(bytes, 0, bytes.Length);
        }
        
        // Writes a section of a character array to this stream.
        //
        // This default implementation calls the Write(Object, int, int)
        // method to write the character array.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write7"]/*' />
        public virtual void Write(char[] chars, int index, int count) 
        {
            byte[] bytes = _encoding.GetBytes(chars, index, count);
            OutStream.Write(bytes, 0, bytes.Length);
        }
    
    
        // Writes a double to this stream. The current position of the stream is
        // advanced by eight.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write8"]/*' />
        public unsafe virtual void Write(double value)
        {
            fixed(byte* b = _buffer)
                *((double*)b) = value;
            OutStream.Write(_buffer, 0, 8);
        }

        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write9"]/*' />
        public virtual void Write(decimal value)
        {
            Decimal.GetBytes(value,_buffer);
            OutStream.Write(_buffer, 0, 16);
        }
    
        // Writes a two-byte signed integer to this stream. The current position of
        // the stream is advanced by two.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write10"]/*' />
        public virtual void Write(short value)
        {
            _buffer[0] = (byte) value;
            _buffer[1] = (byte) (value >> 8);
            OutStream.Write(_buffer, 0, 2);
        }

        // Writes a two-byte unsigned integer to this stream. The current position
        // of the stream is advanced by two.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write11"]/*' />
        [CLSCompliant(false)]
        public virtual void Write(ushort value)
        {
            _buffer[0] = (byte) value;
            _buffer[1] = (byte) (value >> 8);
            OutStream.Write(_buffer, 0, 2);
        }
    
        // Writes a four-byte signed integer to this stream. The current position
        // of the stream is advanced by four.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write12"]/*' />
        public virtual void Write(int value)
        {
            _buffer[0] = (byte) value;
            _buffer[1] = (byte) (value >> 8);
            _buffer[2] = (byte) (value >> 16);
            _buffer[3] = (byte) (value >> 24);
            OutStream.Write(_buffer, 0, 4);
        }

        // Writes a four-byte unsigned integer to this stream. The current position
        // of the stream is advanced by four.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write13"]/*' />
        [CLSCompliant(false)]
        public virtual void Write(uint value)
        {
            _buffer[0] = (byte) value;
            _buffer[1] = (byte) (value >> 8);
            _buffer[2] = (byte) (value >> 16);
            _buffer[3] = (byte) (value >> 24);
            OutStream.Write(_buffer, 0, 4);
        }
    
        // Writes an eight-byte signed integer to this stream. The current position
        // of the stream is advanced by eight.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write14"]/*' />
        public virtual void Write(long value)
        {
            _buffer[0] = (byte) value;
            _buffer[1] = (byte) (value >> 8);
            _buffer[2] = (byte) (value >> 16);
            _buffer[3] = (byte) (value >> 24);
            _buffer[4] = (byte) (value >> 32);
            _buffer[5] = (byte) (value >> 40);
            _buffer[6] = (byte) (value >> 48);
            _buffer[7] = (byte) (value >> 56);
            OutStream.Write(_buffer, 0, 8);
        }

        // Writes an eight-byte unsigned integer to this stream. The current 
        // position of the stream is advanced by eight.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write15"]/*' />
        [CLSCompliant(false)]
        public virtual void Write(ulong value)
        {
            _buffer[0] = (byte) value;
            _buffer[1] = (byte) (value >> 8);
            _buffer[2] = (byte) (value >> 16);
            _buffer[3] = (byte) (value >> 24);
            _buffer[4] = (byte) (value >> 32);
            _buffer[5] = (byte) (value >> 40);
            _buffer[6] = (byte) (value >> 48);
            _buffer[7] = (byte) (value >> 56);
            OutStream.Write(_buffer, 0, 8);
        }
    
        // Writes a float to this stream. The current position of the stream is
        // advanced by four.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write16"]/*' />
        public unsafe virtual void Write(float value)
        {
            fixed(byte* b = _buffer)
                *((float*)b) = value;
            OutStream.Write(_buffer, 0, 4);
        }
    
    
        // Writes a length-prefixed string to this stream in the BinaryWriter's
        // current Encoding. This method first writes the length of the string as 
        // a four-byte unsigned integer, and then writes that many characters 
        // to the stream.
        // 
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write17"]/*' />
        public virtual void Write(String value) 
        {
            if (value==null)
                throw new ArgumentNullException("value");

            int len = _encoding.GetByteCount(value);
            Write7BitEncodedInt(len);

            if (_largeByteBuffer == null) {
                _largeByteBuffer = new byte[LargeByteBufferSize];
                _maxChars = LargeByteBufferSize / _encoding.GetMaxByteCount(1);
            }

            if (len <= LargeByteBufferSize) {
                //BCLDebug.Assert(len == _encoding.GetBytes(chars, 0, chars.Length, _largeByteBuffer, 0), "encoding's GetByteCount & GetBytes gave different answers!  encoding type: "+_encoding.GetType().Name);
                _encoding.GetBytes(value, 0, value.Length, _largeByteBuffer, 0);
                OutStream.Write(_largeByteBuffer, 0, len);
            }
            else {
                // Use an Encoder to write out the string correctly (handling
                // surrogates crossing buffer boundaries properly).  Must
                // convert String to char[] though - we should fix this later.
                char[] chars = value.ToCharArray();
                int charStart = 0;
                int numLeft = value.Length;
#if _DEBUG
                int totalBytes = 0;
#endif
                while (numLeft > 0) {
                    // Figure out how many chars to process this round.
                    int charCount = (numLeft > _maxChars) ? _maxChars : numLeft;
                    int byteLen = _encoder.GetBytes(chars, charStart, charCount, _largeByteBuffer, 0, charCount == numLeft);
                    OutStream.Write(_largeByteBuffer, 0, byteLen);
                    charStart += charCount;
                    numLeft -= charCount;
#if _DEBUG
                    totalBytes += byteLen;
#endif
                }
#if _DEBUG
                BCLDebug.Assert(totalBytes == len, "BinaryWriter::Write(String) - Didn't write out all the bytes!");
#endif
            }
        }
        
        /// <include file='doc\BinaryWriter.uex' path='docs/doc[@for="BinaryWriter.Write7BitEncodedInt"]/*' />
        protected void Write7BitEncodedInt(int value) {
    		// Write out an int 7 bits at a time.  The high bit of the byte,
    		// when on, tells reader to continue reading more bytes.
            uint v = (uint) value;   // support negative numbers
            while (value >= 0x80) {
                Write((byte) (value | 0x80));
                value >>= 7;
            }
            Write((byte)value);
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\bufferedstream.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  BufferedStream
**
** Author: Brian Grunkemeyer (BrianGru)
**         Original design by Anders Hejlsberg (AndersH)
**
** Purpose: A composable Stream that buffers reads & writes 
** to the underlying stream.
**
** Date:  February 19, 2000
**
===========================================================*/
using System;
using System.Runtime.InteropServices;

namespace System.IO {
    // Implementation notes:
    // This is a somewhat complex but efficient implementation.  The biggest
    // design goal here is to prevent the buffer from getting in the way and slowing
    // down IO accesses when it isn't needed.  If you always read & write for sizes
    // greater than the internal buffer size, then this class may not even allocate
    // the internal buffer.  Secondly, it buffers reads & writes in a shared buffer.
    // (If you maintained two buffers separately, one operation would always trash
    // the other buffer anyways, so we might as well use one buffer.)  The 
    // assumption here is you will almost always be doing a series of reads or 
    // writes, but rarely alternate between the two of them on the same stream.
    //
    // This code is based on Anders' original implementation of his adaptive 
    // buffering code.  I had some ideas to make the pathological case better 
    // here, but the pathological cases for the new code would have avoided 
    // memcpy's by introducing more disk writes (which are 3 orders of magnitude 
    // slower). I've made some optimizations, fixed several bugs, and
    // tried documenting this code.  -- BrianGru, 5/30/2000
    //
    // Possible future perf optimization:
    // When we have more time to look at buffering perf, consider the following
    // scenario for improving writing (and reading):
    // Consider a 4K buffer and three write requests, one for 3K, one for 2K, then
    // another for 3K in that order.  In the current implementation, we will copy
    // the first 3K into our buffer, copy the first 1K of the 2K second write into
    // our buffer, write that 4K to disk, write the remaining 1K from the second
    // write to the disk, then copy the following 3K buffer to our internal buffer.
    // If we then closed the file, we would have to write the remaining 3K to disk.
    // We could possibly avoid a disk write by buffering the second half of the 2K
    // write.  This may be a perf optimization, but there is a threshold where we
    // won't be winning anything (in fact, we'd be taking an extra memcpy).  If we
    // have buffered data plus data to write that is bigger than 2x our buffer size,
    // we're better off writing our buffered data to disk then our given byte[] to
    // avoid a call to memcpy.  But for cases when we have less data, it might be 
    // better to copy any spilled over data into our internal buffer.  Consider
    // implementing this and looking at perf results on many random sized writes.
    // Also, this should apply to Read trivially.   -- BrianGru, 5/30/2000
    //
    // Class Invariants:
    // The class has one buffer, shared for reading & writing.  It can only be
    // used for one or the other at any point in time - not both.  The following
    // should be true:
    //   0 <= _readPos <= _readLen < _bufferSize
    //   0 <= _writePos < _bufferSize
    //   _readPos == _readLen && _readPos > 0 implies the read buffer is valid, 
    //     but we're at the end of the buffer.
    //   _readPos == _readLen == 0 means the read buffer contains garbage.
    //   Either _writePos can be greater than 0, or _readLen & _readPos can be
    //     greater than zero, but neither can be greater than zero at the same time.
    //
    //                                   -- Brian Grunkemeyer, 3/11/2002
    /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream"]/*' />
    public sealed class BufferedStream : Stream {
        private Stream _s;         // Underlying stream.  Close sets _s to null.
        private byte[] _buffer;    // Shared read/write buffer.  Alloc on first use.
        private int _readPos;      // Read pointer within shared buffer.
        private int _readLen;      // Number of bytes read in buffer from _s.
        private int _writePos;     // Write pointer within shared buffer.
        private int _bufferSize;   // Length of internal buffer, if it's allocated.


        private const int _DefaultBufferSize = 4096;

        private BufferedStream() {}

        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.BufferedStream"]/*' />
        public BufferedStream(Stream stream) : this(stream, _DefaultBufferSize)
        {
        }

        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.BufferedStream1"]/*' />
        public BufferedStream(Stream stream, int bufferSize)
        {
            if (stream==null)
                throw new ArgumentNullException("stream");
            if (bufferSize <= 0)
                throw new ArgumentOutOfRangeException("bufferSize", String.Format(Environment.GetResourceString("ArgumentOutOfRange_MustBePositive"), "bufferSize"));
            BCLDebug.Perf(!(stream is FileStream), "FileStream is buffered - don't wrap it in a BufferedStream");
            BCLDebug.Perf(!(stream is MemoryStream), "MemoryStream shouldn't be wrapped in a BufferedStream!");

            _s = stream;
            _bufferSize = bufferSize;
            // Allocate _buffer on its first use - it will not be used if all reads
            // & writes are greater than or equal to buffer size.
            if (!_s.CanRead && !_s.CanWrite) __Error.StreamIsClosed();
        }

        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.CanRead"]/*' />
        public override bool CanRead {
            get { return _s != null && _s.CanRead; }
        }

        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.CanWrite"]/*' />
        public override bool CanWrite {
            get { return _s != null && _s.CanWrite; }
        }

        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.CanSeek"]/*' />
        public override bool CanSeek {
            get { return _s != null && _s.CanSeek; }
        }

        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.Length"]/*' />
        public override long Length {
            get {
                if (_s==null) __Error.StreamIsClosed();
                if (_writePos > 0) FlushWrite();
                return _s.Length;
            }
        }

        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.Position"]/*' />
        public override long Position {
            get {
                if (_s==null) __Error.StreamIsClosed();
                if (!_s.CanSeek) __Error.SeekNotSupported();
                //              return _s.Seek(0, SeekOrigin.Current) + (_readPos + _writePos - _readLen);
                return _s.Position + (_readPos - _readLen + _writePos);
            }
            set {
                if (value < 0) throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                if (_s==null) __Error.StreamIsClosed();
                if (!_s.CanSeek) __Error.SeekNotSupported();
                if (_writePos > 0) FlushWrite();
                _readPos = 0;
                _readLen = 0;
                _s.Seek(value, SeekOrigin.Begin);
            }
        }

        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.Close"]/*' />
        public override void Close() {
            if (_s != null) {
                Flush();
                _s.Close();
            }
            _s = null;
            _buffer = null;
        }

        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.Flush"]/*' />
        public override void Flush() {
            if (_s==null) __Error.StreamIsClosed();
            if (_writePos > 0) {
                FlushWrite();
            }
            else if (_readPos < _readLen && _s.CanSeek) {
                FlushRead();
            }
        }

        // Reading is done by blocks from the file, but someone could read
        // 1 byte from the buffer then write.  At that point, the OS's file
        // pointer is out of sync with the stream's position.  All write 
        // functions should call this function to preserve the position in the file.
        private void FlushRead() {
            BCLDebug.Assert(_writePos == 0, "BufferedStream: Write buffer must be empty in FlushRead!");
            if (_readPos - _readLen != 0)
                _s.Seek(_readPos - _readLen, SeekOrigin.Current);
            _readPos = 0;
            _readLen = 0;
        }
    
        // Writes are buffered.  Anytime the buffer fills up 
        // (_writePos + delta > _bufferSize) or the buffer switches to reading
        // and there is dirty data (_writePos > 0), this function must be called.
        private void FlushWrite() {
            BCLDebug.Assert(_readPos == 0 && _readLen == 0, "BufferedStream: Read buffer must be empty in FlushWrite!");
            _s.Write(_buffer, 0, _writePos);
            _writePos = 0;
            _s.Flush();
        }

        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.Read"]/*' />
        public override int Read([In, Out] byte[] array, int offset, int count) {
            if (array==null)
                throw new ArgumentNullException("array", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (offset < 0)
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (array.Length - offset < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            
            if (_s==null) __Error.StreamIsClosed();

            int n = _readLen - _readPos;
            // if the read buffer is empty, read into either user's array or our
            // buffer, depending on number of bytes user asked for and buffer size.
            if (n == 0) {
                if (!_s.CanRead) __Error.ReadNotSupported();
                if (_writePos > 0) FlushWrite();
                if (count >= _bufferSize) {
                    n = _s.Read(array, offset, count);
                    // Throw away read buffer.
                    _readPos = 0;
                    _readLen = 0;
                    return n;
                }
                if (_buffer == null) _buffer = new byte[_bufferSize];
                n = _s.Read(_buffer, 0, _bufferSize);
                if (n == 0) return 0;
                _readPos = 0;
                _readLen = n;
            }
            // Now copy min of count or numBytesAvailable (ie, near EOF) to array.
            if (n > count) n = count;
            Buffer.InternalBlockCopy(_buffer, _readPos, array, offset, n);
            _readPos += n;
            // If we hit the end of the buffer and didn't have enough bytes, we must
            // read some more from the underlying stream.
            if (n < count) {
                int moreBytesRead = _s.Read(array, offset + n, count - n);
                n += moreBytesRead;
                _readPos = 0;
                _readLen = 0;
            }
            return n;
        }

        // Reads a byte from the underlying stream.  Returns the byte cast to an int
        // or -1 if reading from the end of the stream.
        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.ReadByte"]/*' />
        public override int ReadByte() {
            if (_s==null) __Error.StreamIsClosed();
            if (_readLen==0 && !_s.CanRead) __Error.ReadNotSupported();
            if (_readPos == _readLen) {
                if (_writePos > 0) FlushWrite();
                if (_buffer == null) _buffer = new byte[_bufferSize];
                _readLen = _s.Read(_buffer, 0, _bufferSize);
                _readPos = 0;
            }
            if (_readPos == _readLen) return -1;

            return _buffer[_readPos++];
        }

        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.Write"]/*' />
        public override void Write(byte[] array, int offset, int count) {
            if (array==null)
                throw new ArgumentNullException("array", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (offset < 0)
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (array.Length - offset < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            if (_s==null) __Error.StreamIsClosed();
            if (_writePos==0) {
                // Ensure we can write to the stream, and ready buffer for writing.
                if (!_s.CanWrite) __Error.WriteNotSupported();
                if (_readPos < _readLen)
                    FlushRead();
                else {
                    _readPos = 0;
                    _readLen = 0;
                }
            }

            // If our buffer has data in it, copy data from the user's array into
            // the buffer, and if we can fit it all there, return.  Otherwise, write
            // the buffer to disk and copy any remaining data into our buffer.
            // The assumption here is memcpy is cheaper than disk (or net) IO.
            // (10 milliseconds to disk vs. ~20-30 microseconds for a 4K memcpy)
            // So the extra copying will reduce the total number of writes, in 
            // non-pathological cases (ie, write 1 byte, then write for the buffer 
            // size repeatedly)
            if (_writePos > 0) {
                int numBytes = _bufferSize - _writePos;   // space left in buffer
                if (numBytes > 0) {
                    if (numBytes > count)
                        numBytes = count;
                    Buffer.InternalBlockCopy(array, offset, _buffer, _writePos, numBytes);
                    _writePos += numBytes;
                    if (count==numBytes) return;
                    offset += numBytes;
                    count -= numBytes;
                }
                // Reset our buffer.  We essentially want to call FlushWrite
                // without calling Flush on the underlying Stream.
                _s.Write(_buffer, 0, _writePos);
                _writePos = 0;
            }
            // If the buffer would slow writes down, avoid buffer completely.
            if (count >= _bufferSize) {
                BCLDebug.Assert(_writePos == 0, "BufferedStream cannot have buffered data to write here!  Your stream will be corrupted.");
                _s.Write(array, offset, count);
                return;
            } 
            else if (count == 0)
				return;  // Don't allocate a buffer then call memcpy for 0 bytes.
            if (_buffer==null) _buffer = new byte[_bufferSize];
            // Copy remaining bytes into buffer, to write at a later date.
            Buffer.InternalBlockCopy(array, offset, _buffer, 0, count);
            _writePos = count;
        }

        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.WriteByte"]/*' />
        public override void WriteByte(byte value) {
            if (_s==null) __Error.StreamIsClosed();
            if (_writePos==0) {
                if (!_s.CanWrite) __Error.WriteNotSupported();
                if (_readPos < _readLen) 
                    FlushRead();
                else {
                    _readPos = 0;
                    _readLen = 0;
                }
                if (_buffer==null) _buffer = new byte[_bufferSize];
            }
            if (_writePos == _bufferSize)
                FlushWrite();

            _buffer[_writePos++] = value;
        }


        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.Seek"]/*' />
        public override long Seek(long offset, SeekOrigin origin)
        {
            if (_s==null) __Error.StreamIsClosed();
            if (!_s.CanSeek) __Error.SeekNotSupported();
            // If we've got bytes in our buffer to write, write them out.
            // If we've read in and consumed some bytes, we'll have to adjust
            // our seek positions ONLY IF we're seeking relative to the current
            // position in the stream.
            BCLDebug.Assert(_readPos <= _readLen, "_readPos <= _readLen");
            if (_writePos > 0) {
                FlushWrite();
            }
            else if (origin == SeekOrigin.Current) {
                // Don't call FlushRead here, which would have caused an infinite
                // loop.  Simply adjust the seek origin.  This isn't necessary
                // if we're seeking relative to the beginning or end of the stream.
                BCLDebug.Assert(_readLen - _readPos >= 0, "_readLen ("+_readLen+") - _readPos ("+_readPos+") >= 0");
                offset -= (_readLen - _readPos);
            }
            /*
            _readPos = 0;
            _readLen = 0;
            return _s.Seek(offset, origin);
            */
            long oldPos = _s.Position + (_readPos - _readLen);
            long pos = _s.Seek(offset, origin);

            // We now must update the read buffer.  We can in some cases simply
            // update _readPos within the buffer, copy around the buffer so our 
            // Position property is still correct, and avoid having to do more 
            // reads from the disk.  Otherwise, discard the buffer's contents.
            if (_readLen > 0) {
                // We can optimize the following condition:
                // oldPos - _readPos <= pos < oldPos + _readLen - _readPos
                if (oldPos == pos) {
                    if (_readPos > 0) {
                        //Console.WriteLine("Seek: seeked for 0, adjusting buffer back by: "+_readPos+"  _readLen: "+_readLen);
                        Buffer.InternalBlockCopy(_buffer, _readPos, _buffer, 0, _readLen - _readPos);
                        _readLen -= _readPos;
                        _readPos = 0;
                    }
                    // If we still have buffered data, we must update the stream's 
                    // position so our Position property is correct.
                    if (_readLen > 0)
                        _s.Seek(_readLen, SeekOrigin.Current);
                }
                else if (oldPos - _readPos < pos && pos < oldPos + _readLen - _readPos) {
                    int diff = (int)(pos - oldPos);
                    //Console.WriteLine("Seek: diff was "+diff+", readpos was "+_readPos+"  adjusting buffer - shrinking by "+ (_readPos + diff));
                    Buffer.InternalBlockCopy(_buffer, _readPos+diff, _buffer, 0, _readLen - (_readPos + diff));
                    _readLen -= (_readPos + diff);
                    _readPos = 0;
                    if (_readLen > 0)
                        _s.Seek(_readLen, SeekOrigin.Current);
                }
                else {
                    // Lose the read buffer.
                    _readPos = 0;
                    _readLen = 0;
                }
                BCLDebug.Assert(_readLen >= 0 && _readPos <= _readLen, "_readLen should be nonnegative, and _readPos should be less than or equal _readLen");
                BCLDebug.Assert(pos == Position, "Seek optimization: pos != Position!  Buffer math was mangled.");
            }
            return pos;
        }

        /// <include file='doc\BufferedStream.uex' path='docs/doc[@for="BufferedStream.SetLength"]/*' />
        public override void SetLength(long value) {
            if (value < 0) throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_NegFileSize"));
            if (_s==null) __Error.StreamIsClosed();
            if (!_s.CanSeek) __Error.SeekNotSupported();
            if (!_s.CanWrite) __Error.WriteNotSupported();
            if (_writePos > 0) {
                FlushWrite();
            }
            else if (_readPos < _readLen) {
                FlushRead();
            }
            _s.SetLength(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\directory.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Directory
**
** Author: Rajesh Chandrashekaran(rajeshc)
**
** Purpose: Exposes routines for enumerating through a 
** directory.
**
** Date:  March 5, 2000
**		  April 11,2000
**
===========================================================*/

using System;
using System.Collections;
using System.Security;
using System.Security.Permissions;
using Microsoft.Win32;
using System.Text;
using System.Runtime.InteropServices;
using System.Globalization;

namespace System.IO {
    /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory"]/*' />
    public sealed class Directory {
        private Directory()
        {
        }

		/// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetParent"]/*' />
		public static DirectoryInfo GetParent(String path)
		{
			if (path==null)
                throw new ArgumentNullException("path");

            if (path.Length==0)
                throw new ArgumentException(Environment.GetResourceString("Argument_PathEmpty"), "path");

            String fullPath = Path.GetFullPathInternal(path);
			        
		    String s = Path.GetDirectoryName(fullPath);
            if (s==null)
                 return null;
            return new DirectoryInfo(s);
        }

	
        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.CreateDirectory"]/*' />
        public static DirectoryInfo CreateDirectory(String path) {
            if (path==null)
                throw new ArgumentNullException("path");
            if (path.Length == 0)
    			throw new ArgumentException(Environment.GetResourceString("Argument_PathEmpty"));
			
            String fullPath = Path.GetFullPathInternal(path);

			// You need read access to the directory to be returned back and write access to all the directories 
			// that you need to create. If we fail any security checks we will not create any directories at all.
			// We attempt to create direcories only after all the security checks have passed. This is avoid doing
			// a demand at every level.
			String demandDir; 
            if (fullPath.EndsWith('\\' ))
                demandDir = fullPath + ".";
            else
                demandDir = fullPath + "\\.";
			new FileIOPermission(FileIOPermissionAccess.Read, new String[] { demandDir }, false, false ).Demand();
			InternalCreateDirectory(fullPath,path);

            return new DirectoryInfo(fullPath, false);
        }

        internal static void InternalCreateDirectory(String fullPath, String path) {
            int length = fullPath.Length;

            // We need to trim the trailing slash or the code will try to create 2 directories of the same name.
            if (length >= 2 && Path.IsDirectorySeparator(fullPath[length - 1]))
                length--;
            int i = Path.GetRootLength(fullPath);

            // For UNC paths that are only // or /// 
            if (length == 2 && Path.IsDirectorySeparator(fullPath[1]))
				throw new IOException(String.Format(Environment.GetResourceString("IO.IO_CannotCreateDirectory"),path));

            ArrayList list = new ArrayList();
				 
            while (i < length) {
                i++;
                while (i < length && fullPath[i] != Path.DirectorySeparatorChar && fullPath[i] != Path.AltDirectorySeparatorChar) i++;
                String dir = fullPath.Substring(0, i);
                	
                if (!InternalExists(dir)) { // Create only the ones missing
                    list.Add(dir);
                }
            }

            if (list.Count != 0)
            {
                String [] securityList = (String[])list.ToArray(typeof(String));
                for (int j = 0 ; j < securityList.Length; j++)
					securityList[j] += "\\."; // leafs will never has a slash at the end

                // Security check for all directories not present only.
                new FileIOPermission(FileIOPermissionAccess.Write, securityList, false, false ).Demand();
            }
    		

            // We need this check to mask OS differences
            // Handle CreateDirectory("X:\\") when X: doesn't exist. Similarly for n/w paths.
            String root = InternalGetDirectoryRoot(fullPath);
            if (!InternalExists(root)) {
                // Extract the root from the passed in path again for security.
                __Error.WinIOError(Win32Native.ERROR_PATH_NOT_FOUND, InternalGetDirectoryRoot(path));
            }

            bool r = true;
            int firstError = 0;
            // If all the security checks succeeded create all the directories
            for (int j = 0; j < list.Count; j++)
            {
                String name = (String)list[j];
                if (name.Length > Path.MAX_DIRECTORY_PATH)
                    throw new PathTooLongException(Environment.GetResourceString("IO.PathTooLong"));
                r = Win32Native.CreateDirectory(name, 0);
                if (!r && (firstError == 0)) {
                    int currentError = Marshal.GetLastWin32Error();
                    if (currentError != Win32Native.ERROR_PATH_EXISTS)
                        firstError = currentError;
                }
            }

            if (!r && (firstError != 0)) {
                __Error.WinIOError(firstError, path);
            }
        }
      
       
        // Tests if the given path refers to an existing DirectoryInfo on disk.
    	// 
    	// Your application must have Read permission to the directory's
    	// contents.
        //
        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.Exists"]/*' />
        public static bool Exists(String path) {
    		try
            {	if (path==null)
                    return false;
			    if (path.Length==0)
                    return false;

    			// Get fully qualified file name ending in \* for security check
			
    			String fullPath = Path.GetFullPathInternal(path);
				
				String demandPath;
                if (fullPath.EndsWith( "\\" ))
                    demandPath = fullPath + ".";
                else
                    demandPath = fullPath + "\\.";

				new FileIOPermission(FileIOPermissionAccess.Read, new String[] { demandPath }, false, false ).Demand();


				return InternalExists(fullPath);
			}
			catch(ArgumentException) {}			
            catch(NotSupportedException) {}	// To deal with the fact that security can now throw this on :
            catch(SecurityException) {}
            catch(IOException) {}
            catch(UnauthorizedAccessException) 
			{
				BCLDebug.Assert(false,"Ignore this assert and send a repro to rajeshc. This assert was tracking purposes only.");
			}
			return false;
        }

        // Determine whether path describes an existing directory
        // on disk, avoiding security checks.
        internal static bool InternalExists(String path) {
            Win32Native.WIN32_FILE_ATTRIBUTE_DATA data = new Win32Native.WIN32_FILE_ATTRIBUTE_DATA();
            int dataInitialised = File.FillAttributeInfo(path,ref data,false);
            if (dataInitialised != 0)
                return false;
				
            return data.fileAttributes != -1 && (data.fileAttributes & Win32Native.FILE_ATTRIBUTE_DIRECTORY) != 0;
        }

        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.SetCreationTime"]/*' />
        public static void SetCreationTime(String path,DateTime creationTime)
        {
            SetCreationTimeUtc(path, creationTime.ToUniversalTime());
        }

        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.SetCreationTimeUtc"]/*' />
        public static void SetCreationTimeUtc(String path,DateTime creationTimeUtc)
        {
            if ((Environment.OSInfo & Environment.OSName.WinNT) == Environment.OSName.WinNT)
            {
                IntPtr handle = Directory.OpenHandle(path);
                bool r = Win32Native.SetFileTime(handle,  new long[] {creationTimeUtc.ToFileTimeUtc()}, null, null);
                if (!r)
                {
                    int errorCode = Marshal.GetLastWin32Error();
                    Win32Native.CloseHandle(handle);
                    __Error.WinIOError(errorCode, path);
                }
                Win32Native.CloseHandle(handle);
            }
        }

        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetCreationTime"]/*' />
        public static DateTime GetCreationTime(String path)
        {
            return File.GetCreationTime(path);
        }

        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetCreationTimeUtc"]/*' />
        public static DateTime GetCreationTimeUtc(String path)
        {
            return File.GetCreationTimeUtc(path);
        }

        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.SetLastWriteTime"]/*' />
        public static void SetLastWriteTime(String path,DateTime lastWriteTime)
        {
            SetLastWriteTimeUtc(path, lastWriteTime.ToUniversalTime());
        }

        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.SetLastWriteTimeUtc"]/*' />
        public static void SetLastWriteTimeUtc(String path,DateTime lastWriteTimeUtc)
        {
            if ((Environment.OSInfo & Environment.OSName.WinNT) == Environment.OSName.WinNT)
            {
                IntPtr handle = Directory.OpenHandle(path);
                bool r = Win32Native.SetFileTime(handle,  null, null, new long[] {lastWriteTimeUtc.ToFileTimeUtc()});
                if (!r)
                {
                    int errorCode = Marshal.GetLastWin32Error();
                    Win32Native.CloseHandle(handle);
                    __Error.WinIOError(errorCode, path);
                }
                Win32Native.CloseHandle(handle);
            }
        }

        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetLastWriteTime"]/*' />
        public static DateTime GetLastWriteTime(String path)
        {
            return File.GetLastWriteTime(path);
        }

        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetLastWriteTimeUtc"]/*' />
        public static DateTime GetLastWriteTimeUtc(String path)
        {
            return File.GetLastWriteTimeUtc(path);
        }

		/// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.SetLastAccessTime"]/*' />
        public static void SetLastAccessTime(String path,DateTime lastAccessTime)
        {
            SetLastAccessTimeUtc(path, lastAccessTime.ToUniversalTime());
        }

        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.SetLastAccessTimeUtc"]/*' />
        public static void SetLastAccessTimeUtc(String path,DateTime lastAccessTimeUtc)
        {
            if ((Environment.OSInfo & Environment.OSName.WinNT) == Environment.OSName.WinNT)
            {
                IntPtr handle = Directory.OpenHandle(path);
                bool r = Win32Native.SetFileTime(handle,  null, new long[] {lastAccessTimeUtc.ToFileTimeUtc()}, null);
                if (!r)
                {
                    int errorCode = Marshal.GetLastWin32Error();
                    Win32Native.CloseHandle(handle);
                    __Error.WinIOError(errorCode, path);
                }
                Win32Native.CloseHandle(handle);
            }
        }

        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetLastAccessTime"]/*' />
        public static DateTime GetLastAccessTime(String path)
        {
            return File.GetLastAccessTime(path);
        }

        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetLastAccessTimeUtc"]/*' />
        public static DateTime GetLastAccessTimeUtc(String path)
        {
            return File.GetLastAccessTimeUtc(path);
        }
       
      
       // Returns an array of Files in the DirectoryInfo specified by path
        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetFiles"]/*' />
        public static String[] GetFiles(String path)
        {
            return GetFiles(path,"*");
        }

        // Returns an array of Files in the current DirectoryInfo matching the 
        // given search criteria (ie, "*.txt").
        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetFiles1"]/*' />
        public static String[] GetFiles(String path,String searchPattern)
        {
            if (path==null)
                throw new ArgumentNullException("path");

            if (searchPattern==null)
                throw new ArgumentNullException("searchPattern");

            searchPattern = searchPattern.TrimEnd();
            if (searchPattern.Length == 0)
                return new String[0];
			
            Path.CheckSearchPattern(searchPattern);

            // Must fully qualify the path for the security check
            String fullPath = Path.GetFullPathInternal(path);

            String demandPath;
            if (fullPath.EndsWith( '\\' ))
                demandPath = fullPath + ".";
            else
                demandPath = fullPath + "\\.";

            new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { demandPath }, false, false ).Demand();


            String searchPath = Path.GetDirectoryName(searchPattern);
            if (searchPath != null && searchPath != String.Empty) // For filters like foo\*.cs we need to verify if the directory foo is not denied access.
            {
                demandPath = Path.InternalCombine(fullPath,searchPath);
                if (demandPath.EndsWith( '\\' ))
                    demandPath = demandPath + ".";
                else
                    demandPath = demandPath + "\\.";

                new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { demandPath }, false, false ).Demand();
                path = Path.Combine(path,searchPath); // Need to add the searchPath to return correct path and for right security checks
            }

            // Note - fileNames returned by InternalGetFiles are not fully qualified.
            String [] fileNames = InternalGetFiles(fullPath, path, searchPattern);
            for(int i=0; i<fileNames.Length; i++)
                fileNames[i] = Path.InternalCombine(path, fileNames[i]);
            return fileNames;
        }

        // Internal helper function with no security checks
        // Note - fileNames returned by InternalGetFiles are not fully qualified.
        // Path should be fully qualified.  userPath is used in exceptions.
        internal static String[] InternalGetFiles(String path, String userPath, String searchPattern)
        {
            String fullPath = Path.InternalCombine(path, searchPattern);
            String[] fileNames = InternalGetFileDirectoryNames(fullPath, userPath, true);
            return fileNames;
        }

        // Returns an array of Directories in the current directory.
        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetDirectories"]/*' />
        public static String[] GetDirectories(String path)
        {
            return GetDirectories(path,"*");
        }

        // Returns an array of Directories in the current DirectoryInfo matching the 
        // given search criteria (ie, "*.txt").
        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetDirectories1"]/*' />
        public static String[] GetDirectories(String path,String searchPattern)
        {
            if (path==null)
                throw new ArgumentNullException("path");

            if (searchPattern==null)
                throw new ArgumentNullException("searchPattern");

            searchPattern = searchPattern.TrimEnd();
            if (searchPattern.Length == 0)
                return new String[0];

            Path.CheckSearchPattern(searchPattern);

            // Must fully qualify the path for the security check
            String fullPath = Path.GetFullPathInternal(path);
            String demandPath;
            if (fullPath.EndsWith( '\\' ))
                demandPath = fullPath + ".";
            else
                demandPath = fullPath + "\\.";

            new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { demandPath }, false, false ).Demand();
            
            String searchPath = Path.GetDirectoryName(searchPattern);
            if (searchPath != null && searchPath != String.Empty) // For filters like foo\*.cs we need to verify if the directory foo is not denied access.
            {
                demandPath = Path.InternalCombine(fullPath,searchPath);
                if (demandPath.EndsWith( '\\' ))
                    demandPath = demandPath + ".";
                else
                    demandPath = demandPath + "\\.";

                new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { demandPath }, false, false ).Demand();
                path = Path.Combine(path,searchPath); // Need to add the searchPath to return correct path and for right security checks
            }
						
            String [] dirNames = InternalGetDirectories(fullPath, path, searchPattern);  
            for(int i=0; i<dirNames.Length; i++)
                dirNames[i] = Path.InternalCombine(path, dirNames[i]);
            return dirNames;
        }

		// Internal helper function that has no security checks
        // Note - InternalGetDirectories returns non-qualified directory names.
        // Path should be fully qualified.  userPath is used in exceptions.
        internal static String[] InternalGetDirectories(String path, String userPath, String searchPattern)
        {
            String fullPath = Path.InternalCombine(path, searchPattern);
            String[] dirNames = InternalGetFileDirectoryNames(fullPath, userPath, false);
            return dirNames;
        }
		
			
        // Returns an array of strongly typed FileSystemInfo entries in the path
        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetFileSystemEntries"]/*' />
        public static String[] GetFileSystemEntries(String path)
        {
            return GetFileSystemEntries(path,"*");
        }


        // Returns an array of strongly typed FileSystemInfo entries in the path with the
        // given search criteria (ie, "*.txt"). We disallow .. as a part of the search criteria
        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetFileSystemEntries1"]/*' />
        public static String[] GetFileSystemEntries(String path,String searchPattern)
        {
			if (path==null)
                throw new ArgumentNullException("path");

			if (searchPattern==null)
                throw new ArgumentNullException("searchPattern");

            searchPattern = searchPattern.TrimEnd();
            if (searchPattern.Length == 0)
                return new String[0];
			
            Path.CheckSearchPattern(searchPattern);

            // Must fully qualify the path for the security check
            String fullPath = Path.GetFullPathInternal(path);
            String demandPath;
            if (fullPath.EndsWith( '\\' ))
                demandPath = fullPath + ".";
            else
                demandPath = fullPath + "\\.";

            new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { demandPath }, false, false ).Demand();  

            String searchPath = Path.GetDirectoryName(searchPattern);
            if (searchPath != null && searchPath != String.Empty) // For filters like foo\*.cs we need to verify if the directory foo is not denied access.
            {
                demandPath = Path.InternalCombine(fullPath, searchPath);
                if (demandPath.EndsWith( '\\' ))
                    demandPath = demandPath + ".";
                else
                    demandPath = demandPath + "\\.";

               new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { demandPath }, false, false ).Demand();
               path = Path.Combine(path,searchPath); // Need to add the searchPath to return correct path and for right security checks
            }

            String [] dirs = InternalGetDirectories(fullPath, path, searchPattern);
            String [] files = InternalGetFiles(fullPath, path, searchPattern);
            String [] fileSystemEntries = new String[dirs.Length + files.Length];

            int count = 0;
            for (int i = 0;i<dirs.Length;i++)
                fileSystemEntries[count++] = Path.InternalCombine(path, dirs[i]);
		   
            for (int i = 0;i<files.Length;i++)
                fileSystemEntries[count++] = Path.InternalCombine(path, files[i]);
		   
            return fileSystemEntries;
        }
        
        // Private helper function that does not do any security checks
    	internal static String[] InternalGetFileDirectoryNames(String fullPath, String userPath, bool file)
    	{
    		int hr;

    	   		
    		// If path ends in a trailing slash (\), append a * or we'll 
    		// get a "Cannot find the file specified" exception
    		char lastChar = fullPath[fullPath.Length-1];
    		if (lastChar == Path.DirectorySeparatorChar || lastChar == Path.AltDirectorySeparatorChar || lastChar == Path.VolumeSeparatorChar)
    			fullPath = fullPath + '*';
    
            String[] list = new String[10];
            int listSize = 0;
    		Win32Native.WIN32_FIND_DATA data = new Win32Native.WIN32_FIND_DATA();

    		// Open a Find handle (Win32 is weird)
    		IntPtr hnd = Win32Native.FindFirstFile(fullPath, data);
    		if (hnd==Win32Native.INVALID_HANDLE_VALUE) {
    			// Calls to GetLastWin32Error clobber HResult.  Store HResult.
    			hr = Marshal.GetLastWin32Error();
    			if (hr==Win32Native.ERROR_FILE_NOT_FOUND)
    				return new String[0];
    			__Error.WinIOError(hr, userPath);
    		}
    
    		// Keep asking for more matching files, adding file names to list
    		int numEntries = 0;  // Number of DirectoryInfo entities we see.
    		do {
                bool includeThis;  // Should this file/DirectoryInfo be included in the output?
    			if (file)
    				includeThis = (0==(data.dwFileAttributes & Win32Native.FILE_ATTRIBUTE_DIRECTORY));
    			else {
    				includeThis = (0!=(data.dwFileAttributes & Win32Native.FILE_ATTRIBUTE_DIRECTORY));
                    // Don't add "." nor ".."
                    if (includeThis && (data.cFileName.Equals(".") || data.cFileName.Equals(".."))) 
                        includeThis = false;
                }
    			
    			if (includeThis) {
    				numEntries++;
    				if (listSize==list.Length) {
    					String[] newList = new String[list.Length*2];
    	                Array.Copy(list, 0, newList, 0, listSize);
    		            list = newList;
    			    }
    				list[listSize++] = data.cFileName;
    			}
     
    		} while (Win32Native.FindNextFile(hnd, data));
    		
    		// Make sure we quit with a sensible error.
    		hr = Marshal.GetLastWin32Error();
    		Win32Native.FindClose(hnd);  // Close Find handle in all cases.
    		if (hr!=0 && hr!=Win32Native.ERROR_NO_MORE_FILES) __Error.WinIOError(hr, userPath);
    		
    		// Check for a string such as "C:\tmp", in which case we return
    		// just the DirectoryInfo name.  FindNextFile fails first time, and
    		// data still contains a directory.
	
    		if (!file && numEntries==1 && (0!=(data.dwFileAttributes & Win32Native.FILE_ATTRIBUTE_DIRECTORY))) {
    			String[] sa = new String[1];
    			sa[0] = data.cFileName;
    			return sa;
    		}
    		
    		// Return list of files/directories as an array of strings
            if (listSize == list.Length)
                return list;
    		String[] items = new String[listSize];
            Array.Copy(list, 0, items, 0, listSize);
    		return items;
    	}

    	// Retrieves the names of the logical drives on this machine in the 
    	// form "C:\". 
    	// 
    	// Your application must have System Info permission.
    	// 
        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetLogicalDrives"]/*' />
        public static String[] GetLogicalDrives()
    	{
    		new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
    							 
            int drives = Win32Native.GetLogicalDrives();
    		if (drives==0)
    			__Error.WinIOError();
            uint d = (uint)drives;
            int count = 0;
            while (d != 0) {
                if (((int)d & 1) != 0) count++;
                d >>= 1;
            }
            String[] result = new String[count];
            char[] root = new char[] {'A', ':', '\\'};
            d = (uint)drives;
            count = 0;
            while (d != 0) {
                if (((int)d & 1) != 0) {
                    result[count++] = new String(root);
                }
                d >>= 1;
                root[0]++;
            }
            return result;
        }

	
        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetDirectoryRoot"]/*' />
        public static String GetDirectoryRoot(String path) {
		    if (path==null)
                throw new ArgumentNullException("path");
			
    		String fullPath = Path.GetFullPathInternal(path);
    		String demandPath;
            if (fullPath.EndsWith( '\\' ))
                demandPath = fullPath + ".";
            else
                demandPath = fullPath + "\\.";
    		new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { demandPath }, false, false ).Demand();
         			
         			
            return fullPath.Substring(0, Path.GetRootLength(fullPath));
        }

		/// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.InternalGetDirectoryRoot"]/*' />
		internal static String InternalGetDirectoryRoot(String path) {
  			if (path == null) return null;
            return path.Substring(0, Path.GetRootLength(path));
        }

     	/*===============================CurrentDirectory===============================
        **Action:  Provides a getter and setter for the current directory.  The original
        **         current DirectoryInfo is the one from which the process was started.  
        **Returns: The current DirectoryInfo (from the getter).  Void from the setter.
        **Arguments: The current DirectoryInfo to which to switch to the setter.
        **Exceptions: 
        ==============================================================================*/
        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.GetCurrentDirectory"]/*' />
        public static String GetCurrentDirectory()
        {
            StringBuilder sb = new StringBuilder(Path.MAX_PATH + 1);
            if (Win32Native.GetCurrentDirectory(sb.Capacity, sb) == 0)
                System.IO.__Error.WinIOError();
            String currentDirectory = sb.ToString();
            String demandPath;
            if (currentDirectory.EndsWith( "\\" ))
                demandPath = currentDirectory + ".";
            else
                demandPath = currentDirectory + "\\.";
            new FileIOPermission( FileIOPermissionAccess.PathDiscovery, new String[] { demandPath }, false, false ).Demand();
            return currentDirectory;
        }

        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.SetCurrentDirectory"]/*' />
        public static void SetCurrentDirectory(String path)
        {        
            if (path==null)
                throw new ArgumentNullException("value");
            if (path.Length==0)
                throw new ArgumentException(Environment.GetResourceString("Argument_PathEmpty"));
            if (path.Length >= Path.MAX_PATH)
                throw new PathTooLongException(Environment.GetResourceString("IO.PathTooLong"));
                
            // This will have some huge effects on the rest of the runtime
            // and every other application.  Make sure app is highly trusted.
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();

            String fulldestDirName = Path.GetFullPathInternal(path);
            if (!InternalExists(Path.GetPathRoot(fulldestDirName))) // Win9x hack to behave same as Winnt. 
                throw new DirectoryNotFoundException(String.Format(Environment.GetResourceString("IO.PathNotFound_Path"), path));
            
                
            // If path doesn't exist, this sets last error to 3 (Path not Found).
            if (!Win32Native.SetCurrentDirectory(fulldestDirName))
                System.IO.__Error.WinIOError(Marshal.GetLastWin32Error(), path);
        }
       
		/// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.Move"]/*' />
		public static void Move(String sourceDirName,String destDirName) {
			if (sourceDirName==null)
    			throw new ArgumentNullException("sourceDirName");
    		if (sourceDirName.Length==0)
    			throw new ArgumentException(Environment.GetResourceString("Argument_EmptyFileName"), "sourceDirName");
    		
    		if (destDirName==null)
    			throw new ArgumentNullException("destDirName");
    		if (destDirName.Length==0)
    			throw new ArgumentException(Environment.GetResourceString("Argument_EmptyFileName"), "destDirName");

			String fullsourceDirName = Path.GetFullPathInternal(sourceDirName);
   	 		new FileIOPermission(FileIOPermissionAccess.Write | FileIOPermissionAccess.Read, new String[] { fullsourceDirName }, false, false ).Demand();

    		String fulldestDirName = Path.GetFullPathInternal(destDirName);
    		new FileIOPermission(FileIOPermissionAccess.Write, new String[] { fulldestDirName }, false, false ).Demand();

    		String sourcePath;
            if (fullsourceDirName.EndsWith( '\\' ))
                sourcePath = fullsourceDirName;
            else
                sourcePath = fullsourceDirName + "\\";

            String destPath;
    		if (fulldestDirName.EndsWith( '\\' ))
                destPath = fulldestDirName;
            else
                destPath = fulldestDirName + "\\";

            if (CultureInfo.InvariantCulture.CompareInfo.Compare(sourcePath, destPath, CompareOptions.IgnoreCase) == 0)
                throw new IOException(Environment.GetResourceString("IO.IO_SourceDestMustBeDifferent"));

            String sourceRoot = Path.GetPathRoot(sourcePath);
            String destinationRoot = Path.GetPathRoot(destPath);
            if (CultureInfo.InvariantCulture.CompareInfo.Compare(sourceRoot, destinationRoot, CompareOptions.IgnoreCase) != 0)
                throw new IOException(Environment.GetResourceString("IO.IO_SourceDestMustHaveSameRoot"));
    		
            if (!Directory.InternalExists(Path.GetPathRoot(fulldestDirName))) // Win9x hack to behave same as Winnt. 
                throw new DirectoryNotFoundException(String.Format(Environment.GetResourceString("IO.PathNotFound_Path"), destDirName));
    
            if (!Win32Native.MoveFile(sourceDirName, destDirName))
			{
				int hr = Marshal.GetLastWin32Error();
				if (hr == Win32Native.ERROR_FILE_NOT_FOUND) // Win32 is weird, it gives back a file not found
				{
					hr = Win32Native.ERROR_PATH_NOT_FOUND;
					__Error.WinIOError(hr, sourceDirName);
				}
                if (hr == Win32Native.ERROR_ACCESS_DENIED) // WinNT throws IOException. Win9x hack to do the same.
                    throw new IOException(String.Format(Environment.GetResourceString("UnauthorizedAccess_IODenied_Path"), sourceDirName));
    			__Error.WinIOError(hr,String.Empty);
			}
       
        }

    
      

        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.Delete"]/*' />
        public static void Delete(String path)
        {
            String fullPath = Path.GetFullPathInternal(path);
            Delete(fullPath, path, false);
        }
	
        /// <include file='doc\Directory.uex' path='docs/doc[@for="Directory.Delete1"]/*' />
        public static void Delete(String path, bool recursive)
        {
            String fullPath = Path.GetFullPathInternal(path);
            Delete(fullPath, path, recursive);
        }

        // Called from DirectoryInfo as well.  FullPath is fully qualified,
        // while the user path is used for feedback in exceptions.
        internal static void Delete(String fullPath, String userPath, bool recursive)
        {
            String demandPath;
            if (!recursive) { // Do normal check only on this directory
                if (fullPath.EndsWith( '\\' ))
                    demandPath = fullPath + ".";
                else
                    demandPath = fullPath + "\\.";
            }
            else { // Check for deny anywhere below and fail
                if (fullPath.EndsWith( '\\' ))
                    demandPath = fullPath.Substring(0,fullPath.Length - 1);
                else
                    demandPath = fullPath;
            }
			
            // Make sure we have write permission to this directory
            new FileIOPermission(FileIOPermissionAccess.Write, new String[] { demandPath }, false, false ).Demand();

            DeleteHelper(fullPath, userPath, recursive);
        }

        // Note that fullPath is fully qualified, while userPath may be 
        // relative.  Use userPath for all exception messages to avoid leaking
        // fully qualified path information.
        private static void DeleteHelper(String fullPath, String userPath, bool recursive)
        {
            bool r;
            int hr;
            Exception ex = null;

            if (recursive) {
                Win32Native.WIN32_FIND_DATA data = new Win32Native.WIN32_FIND_DATA();
    			
                // Open a Find handle (Win32 is weird)
                IntPtr hnd = Win32Native.FindFirstFile(fullPath+Path.DirectorySeparatorChar+"*", data);
                if (hnd==Win32Native.INVALID_HANDLE_VALUE) {
                    hr = Marshal.GetLastWin32Error();
                    __Error.WinIOError(hr, userPath);
                }
    
                do {
                    bool isDir = (0!=(data.dwFileAttributes & Win32Native.FILE_ATTRIBUTE_DIRECTORY));
                    if (isDir) {
                        if (data.cFileName.Equals(".") || data.cFileName.Equals(".."))
                            continue;

                        // recurse
                        String newFullPath = Path.InternalCombine(fullPath, data.cFileName);
                        String newUserPath = Path.InternalCombine(userPath, data.cFileName);                        
                        try {
                            DeleteHelper(newFullPath, newUserPath, recursive);
                        }
                        catch(Exception e) {
                            if (ex == null) {
                                ex = e;
                            }
                        }
                    }
                    else {
                        String fileName = fullPath + Path.DirectorySeparatorChar + data.cFileName;
                        r = Win32Native.DeleteFile(fileName);
                        if (!r) {
                            hr = Marshal.GetLastWin32Error();
                            try {
                                __Error.WinIOError(hr, data.cFileName);
                            }
                            catch(Exception e) {
                                if (ex == null) {
                                    ex = e;
                                }
                            }
                        }
                    }
                } while (Win32Native.FindNextFile(hnd, data));
    		
                // Make sure we quit with a sensible error.
                hr = Marshal.GetLastWin32Error();
                Win32Native.FindClose(hnd);  // Close Find handle in all cases.
                if (ex != null) 
                    throw ex;
                if (hr!=0 && hr!=Win32Native.ERROR_NO_MORE_FILES) 
                    __Error.WinIOError(hr, userPath);
            }

    		r = Win32Native.RemoveDirectory(fullPath);
            hr = Marshal.GetLastWin32Error();
            if (hr == Win32Native.ERROR_FILE_NOT_FOUND) // Win32 is weird, it gives back a file not found
                hr = Win32Native.ERROR_PATH_NOT_FOUND;
            if (hr == Win32Native.ERROR_ACCESS_DENIED) // WinNT throws IOException. Win9x hack to do the same.
                throw new IOException(String.Format(Environment.GetResourceString("UnauthorizedAccess_IODenied_Path"), userPath));
            
            if (!r)
                __Error.WinIOError(hr, userPath);
        }


        internal static void VerifyDriveExists(String root)
        {
            int drives = Win32Native.GetLogicalDrives();
    		if (drives==0)
    			__Error.WinIOError();
            uint d = (uint)drives;
            char drive = root.ToLower(CultureInfo.InvariantCulture)[0];
            if ((d & (1 << (drive - 'a'))) == 0)
                throw new DirectoryNotFoundException(String.Format(Environment.GetResourceString("IO.DriveNotFound_Drive"), root));
        }


		// WinNT only. Win9x this code will not work.
		private static IntPtr OpenHandle(String path)
		{
			BCLDebug.Assert((Environment.OSInfo & Environment.OSName.WinNT) == Environment.OSName.WinNT,"Not running on Winnt OS");
			String fullPath = Path.GetFullPathInternal(path);
			String root = Path.GetPathRoot(fullPath);
			if (root == fullPath && root[1] == Path.VolumeSeparatorChar)
				throw new ArgumentException(Environment.GetResourceString("Arg_PathIsVolume"));

			new FileIOPermission(FileIOPermissionAccess.Write, new String[] { fullPath + "\\." }, false, false ).Demand();

			IntPtr handle = Win32Native.SafeCreateFile (
				fullPath,
				GENERIC_WRITE,
				FILE_SHARE_WRITE|FILE_SHARE_DELETE,
				Win32Native.NULL,
				OPEN_EXISTING,
				FILE_FLAG_BACKUP_SEMANTICS,
				Win32Native.NULL
			);

			if (handle == Win32Native.INVALID_HANDLE_VALUE) {
				int hr = Marshal.GetLastWin32Error();
    			__Error.WinIOError(hr, path);
    		}
			return handle;
		}

		private const int FILE_ATTRIBUTE_DIRECTORY = 0x00000010;	
		private const int GENERIC_WRITE = unchecked((int)0x40000000);
		private const int FILE_SHARE_WRITE = 0x00000002;
		private const int FILE_SHARE_DELETE = 0x00000004;
		private const int OPEN_EXISTING = 0x00000003;
		private const int FILE_FLAG_BACKUP_SEMANTICS = 0x02000000;

	}
       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\directoryinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  DirectoryInfo
**
** Author: Rajesh Chandrashekaran(rajeshc)
**
** Purpose: Exposes routines for enumerating through a 
** directory.
**
** Date:  March 5, 2000
**		  April 11,2000
**
===========================================================*/

using System;
using System.Collections;
using System.Security;
using System.Security.Permissions;
using Microsoft.Win32;
using System.Text;
using System.Runtime.InteropServices;
using System.Globalization;
using System.Runtime.Serialization;

//@TODO: Add a static SystemDirectoryInfo property returning a URI
namespace System.IO {
    /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo"]/*' />
    [Serializable]
    public sealed class DirectoryInfo : FileSystemInfo {
		String[] demandDir;
		       
        private DirectoryInfo() {
        }


        /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.DirectoryInfo"]/*' />
        public DirectoryInfo(String path)
        {
            if (path==null)
                throw new ArgumentNullException("path");

            OriginalPath = path;

            // Must fully qualify the path for the security check
            String fullPath = Path.GetFullPathInternal(path);
            if (fullPath.EndsWith( '\\' ))
                demandDir = new String[] { fullPath + '.' };
            else
                demandDir = new String[] { fullPath + "\\." };
    				
            new FileIOPermission(FileIOPermissionAccess.Read, demandDir, false, false ).Demand();

            FullPath = fullPath;
			
		}

        internal DirectoryInfo(String fullPath, bool junk)
        {
            BCLDebug.Assert(Path.GetRootLength(fullPath) > 0, "fullPath must be fully qualified!");
            // Fast path when we know a DirectoryInfo exists.
            OriginalPath = Path.GetFileName(fullPath);
            FullPath = fullPath;

            if (fullPath.EndsWith( '\\' ))
                demandDir = new String[] { fullPath + '.' };
            else
                demandDir = new String[] { fullPath + "\\." };
        }

        private DirectoryInfo(SerializationInfo info, StreamingContext context) : base(info, context)
        {
            if (FullPath.EndsWith('\\'))
                demandDir = new String[] { FullPath + '.' };
            else
                demandDir = new String[] { FullPath + "\\." };

            new FileIOPermission(FileIOPermissionAccess.Read, demandDir, false, false ).Demand();
        }
        
        /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.Name"]/*' />
        public override String Name {
            get {
                // FullPath might be either "c:\bar" or "c:\bar\".  Handle 
                // those cases, as well as avoiding mangling "c:\".
                String s = FullPath;
                if (s.Length > 3) {
                    if (s.EndsWith(Path.DirectorySeparatorChar))
                        s = FullPath.Substring(0, FullPath.Length - 1);
                    return Path.GetFileName(s);
                }
                return FullPath;  // For rooted paths, like "c:\"
            }
        }

        /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.Parent"]/*' />
        public DirectoryInfo Parent {
            get {
                String parentName;
                // FullPath might be either "c:\bar" or "c:\bar\".  Handle 
                // those cases, as well as avoiding mangling "c:\".
                String s = FullPath;
                if (s.Length > 3 && s.EndsWith(Path.DirectorySeparatorChar))
                    s = FullPath.Substring(0, FullPath.Length - 1);                
                parentName = Path.GetDirectoryName(s);
                if (parentName==null)
                    return null;
                DirectoryInfo dir = new DirectoryInfo(parentName,false);
                new FileIOPermission(FileIOPermissionAccess.PathDiscovery | FileIOPermissionAccess.Read, dir.demandDir, false, false).Demand();
                return dir;
            }
        }

      
            
        /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.CreateSubdirectory"]/*' />
        public DirectoryInfo CreateSubdirectory(String path) {
            if (path==null)
                throw new ArgumentNullException("path");
			
            String newDirs = Path.InternalCombine(FullPath, path);
			String fullPath = Path.GetFullPathInternal(newDirs);

			if (0!=String.Compare(FullPath,0,fullPath,0, FullPath.Length,true, CultureInfo.InvariantCulture))
				throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidSubPath"),path,OriginalPath));
			
            Directory.InternalCreateDirectory(fullPath,path);
			return new DirectoryInfo(fullPath, false);
        }

		/// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.Create"]/*' />
		public void Create()
        {
            Directory.InternalCreateDirectory(FullPath,OriginalPath);
        }

        // Tests if the given path refers to an existing DirectoryInfo on disk.
    	// 
    	// Your application must have Read permission to the directory's
    	// contents.
        //
        /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.Exists"]/*' />
        public override bool Exists {
			get
			{
				try
				{
	   				if (_dataInitialised == -1)
						Refresh();
					if (_dataInitialised != 0) // Refresh was unable to initialise the data
						return false;
       			
					return _data.fileAttributes != -1 && (_data.fileAttributes & Win32Native.FILE_ATTRIBUTE_DIRECTORY) != 0;
				}
				catch(Exception)
				{
					return false;
				}
			}
        }
      
	
	

        // Returns an array of Files in the current DirectoryInfo matching the 
        // given search criteria (ie, "*.txt").
        /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.GetFiles"]/*' />
        public FileInfo[] GetFiles(String searchPattern)
        {
			new FileIOPermission(FileIOPermissionAccess.PathDiscovery, demandDir, false, false).Demand();

            if (searchPattern==null)
                throw new ArgumentNullException("searchPattern");

            searchPattern = searchPattern.TrimEnd();
            if (searchPattern.Length == 0)
                return new FileInfo[0];

			Path.CheckSearchPattern(searchPattern);
			String path = FullPath;

            String searchPath = Path.GetDirectoryName(searchPattern);

            if (searchPath != null && searchPath != String.Empty) // For filters like foo\*.cs we need to verify if the directory foo is not denied access.
            {
                String demandPath = Path.InternalCombine(FullPath,searchPath);
                if (demandPath.EndsWith( '\\' ))
                    demandPath = demandPath + ".";
                else
                    demandPath = demandPath + "\\.";

                new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { demandPath }, false, false).Demand();
                path = Path.Combine(path,searchPath);
            }

            String[] fileNames = Directory.InternalGetFiles(FullPath, OriginalPath, searchPattern);
            for (int i = 0; i < fileNames.Length; i++)
                fileNames[i] = Path.InternalCombine(path, fileNames[i]);
            if (fileNames.Length != 0)
                new FileIOPermission(FileIOPermissionAccess.Read, fileNames, false, false).Demand();

            FileInfo[] files = new FileInfo[fileNames.Length];
            for(int i=0; i<fileNames.Length; i++)
                files[i] = new FileInfo(fileNames[i], false);
            return files;
        }

		

       // Returns an array of Files in the DirectoryInfo specified by path
        /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.GetFiles1"]/*' />
        public FileInfo[] GetFiles()
        {
			return GetFiles("*");
        }

	

		
        // Returns an array of Directories in the current directory.
		/// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.GetDirectories"]/*' />
		public DirectoryInfo[] GetDirectories()
		{
			return GetDirectories("*");
		}
		
	


	

        // Returns an array of strongly typed FileSystemInfo entries in the path with the
        // given search criteria (ie, "*.txt").
        /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.GetFileSystemInfos"]/*' />
        public FileSystemInfo[] GetFileSystemInfos(String searchPattern)
        {
            new FileIOPermission(FileIOPermissionAccess.PathDiscovery, demandDir, false, false).Demand();
		   
            if (searchPattern==null)
                throw new ArgumentNullException("searchPattern");

            searchPattern = searchPattern.TrimEnd();
            if (searchPattern.Length == 0)
                return new FileSystemInfo[0];

            Path.CheckSearchPattern(searchPattern);
            String path = FullPath;
		   		  
            String searchPath = Path.GetDirectoryName(searchPattern);
            if (searchPath != null && searchPath != String.Empty) // For filters like foo\*.cs we need to verify if the directory foo is not denied access.
            {
                String demandPath = Path.InternalCombine(FullPath,searchPath);
                if (demandPath.EndsWith( '\\' ))
                    demandPath = demandPath + ".";
                else
                    demandPath = demandPath + "\\.";

                new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { demandPath }, false, false).Demand();
                path = Path.Combine(path,searchPath);
            }

            String [] dirNames = Directory.InternalGetDirectories(FullPath, OriginalPath, searchPattern);
            String [] fileNames = Directory.InternalGetFiles(FullPath, OriginalPath, searchPattern);
            FileSystemInfo [] fileSystemEntries = new FileSystemInfo[dirNames.Length + fileNames.Length];
            String[] permissionNames = new String[dirNames.Length];

            for (int i = 0;i<dirNames.Length;i++) { 
                dirNames[i] = Path.InternalCombine(path, dirNames[i]);
                permissionNames[i] = dirNames[i] +  "\\.";
            }
            if (dirNames.Length != 0)
                new FileIOPermission(FileIOPermissionAccess.Read,permissionNames,false,false).Demand();
		   
            for (int i = 0;i<fileNames.Length;i++)
                fileNames[i] = Path.InternalCombine(path, fileNames[i]);
            if (fileNames.Length != 0)
                new FileIOPermission(FileIOPermissionAccess.Read,fileNames,false,false).Demand();
		   
            int count = 0;
            for (int i = 0;i<dirNames.Length;i++)
                fileSystemEntries[count++] = new DirectoryInfo(dirNames[i], false);
		   
            for (int i = 0;i<fileNames.Length;i++)
                fileSystemEntries[count++] = new FileInfo(fileNames[i], false);
		   
            return fileSystemEntries;
        }



        // Returns an array of strongly typed FileSystemInfo entries which will contain a listing
		// of all the files and directories.
        /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.GetFileSystemInfos1"]/*' />
        public FileSystemInfo[] GetFileSystemInfos()
        {
           return GetFileSystemInfos("*");
        }

        // Returns an array of Directories in the current DirectoryInfo matching the 
        // given search criteria (ie, "System*" could match the System & System32
        // directories).
        /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.GetDirectories1"]/*' />
        public DirectoryInfo[] GetDirectories(String searchPattern)
        {
			new FileIOPermission(FileIOPermissionAccess.PathDiscovery, demandDir, false, false).Demand();

            if (searchPattern==null)
                throw new ArgumentNullException("searchPattern");

            searchPattern = searchPattern.TrimEnd();
            if (searchPattern.Length == 0)
                return new DirectoryInfo[0];

			Path.CheckSearchPattern(searchPattern);
			String path = FullPath;


            String searchPath = Path.GetDirectoryName(searchPattern);
            if (searchPath != null && searchPath != String.Empty) // For filters like foo\*.cs we need to verify if the directory foo is not denied access.
            {
                String demandPath = Path.InternalCombine(FullPath,searchPath);
                if (demandPath.EndsWith( '\\' ))
                    demandPath = demandPath + ".";
                else
                    demandPath = demandPath + "\\.";

                new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { demandPath }, false, false).Demand();
				path = Path.Combine(path,searchPath);
            }

            String fullPath = Path.InternalCombine(FullPath, searchPattern);
			
            String[] dirNames = Directory.InternalGetFileDirectoryNames(fullPath, OriginalPath, false);
            String[] permissionNames = new String[dirNames.Length];
            for (int i = 0; i<dirNames.Length; i++) {
                dirNames[i] = Path.InternalCombine(path, dirNames[i]);
                permissionNames[i] = dirNames[i] + "\\."; // these will never have a slash at end
            }
            if (dirNames.Length != 0)
                new FileIOPermission(FileIOPermissionAccess.Read,permissionNames,false, false).Demand();

            DirectoryInfo[] dirs = new DirectoryInfo[dirNames.Length];
            for(int i=0; i<dirNames.Length; i++)
                dirs[i] = new DirectoryInfo(dirNames[i], false);
            return dirs;
        }

	

    	

        // Returns the root portion of the given path. The resulting string
        // consists of those rightmost characters of the path that constitute the
        // root of the path. Possible patterns for the resulting string are: An
        // empty string (a relative path on the current drive), "\" (an absolute
        // path on the current drive), "X:" (a relative path on a given drive,
        // where X is the drive letter), "X:\" (an absolute path on a given drive),
        // and "\\server\share" (a UNC path for a given server and share name).
        // The resulting string is null if path is null.
        //
        
		/// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.Root"]/*' />
		public DirectoryInfo Root { 
			get
			{
                String demandPath;
                int rootLength = Path.GetRootLength(FullPath);
                String rootPath = FullPath.Substring(0, rootLength);
                if (rootPath.EndsWith('\\'))
                    demandPath = rootPath;
                else
                    demandPath = rootPath + '\\';
                new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { demandPath }, false, false ).Demand();
				return new DirectoryInfo(rootPath);
			}
		} 


		/// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.MoveTo"]/*' />
        public void MoveTo(String destDirName) {
            if (destDirName==null)
                throw new ArgumentNullException("destDirName");
            if (destDirName.Length==0)
                throw new ArgumentException(Environment.GetResourceString("Argument_EmptyFileName"), "destDirName");
    		
            new FileIOPermission(FileIOPermissionAccess.Write | FileIOPermissionAccess.Read, demandDir, false, false).Demand();
            String fullDestDirName = Path.GetFullPathInternal(destDirName);
            String demandPath;
            if (!fullDestDirName.EndsWith( '\\'))
                fullDestDirName = fullDestDirName + "\\";

            demandPath = fullDestDirName + ".";

            new FileIOPermission(FileIOPermissionAccess.Write, demandPath).Demand();

            String fullSourcePath;
            if (FullPath.EndsWith( '\\' ))
                fullSourcePath = FullPath;
            else
                fullSourcePath = FullPath + "\\";

            if (CultureInfo.InvariantCulture.CompareInfo.Compare(fullSourcePath, fullDestDirName, CompareOptions.IgnoreCase) == 0)
                throw new IOException(Environment.GetResourceString("IO.IO_SourceDestMustBeDifferent"));

            String sourceRoot = Path.GetPathRoot(fullSourcePath);
            String destinationRoot = Path.GetPathRoot(fullDestDirName);

            if (CultureInfo.InvariantCulture.CompareInfo.Compare(sourceRoot, destinationRoot, CompareOptions.IgnoreCase) != 0)
                throw new IOException(Environment.GetResourceString("IO.IO_SourceDestMustHaveSameRoot"));
    		
            if (!Directory.InternalExists(FullPath)) // Win9x hack to behave same as Winnt. 
                throw new DirectoryNotFoundException(String.Format(Environment.GetResourceString("IO.PathNotFound_Path"), destDirName));
    
    		
            if (!Win32Native.MoveFile(FullPath, destDirName))
            {
                int hr = Marshal.GetLastWin32Error();
                if (hr == Win32Native.ERROR_FILE_NOT_FOUND) // Win32 is weird, it gives back a file not found
                {
                    hr = Win32Native.ERROR_PATH_NOT_FOUND;
                    __Error.WinIOError(hr, OriginalPath);
                }
				
                if (hr == Win32Native.ERROR_ACCESS_DENIED) // WinNT throws IOException. Win9x hack to do the same.
                    throw new IOException(String.Format(Environment.GetResourceString("UnauthorizedAccess_IODenied_Path"), OriginalPath));
    		
                __Error.WinIOError(hr,String.Empty);
            }
            FullPath = fullDestDirName;
            OriginalPath = destDirName;
            if (FullPath.EndsWith( '\\' ))
                demandDir = new String[] { FullPath + "." };
            else
                demandDir = new String[] { FullPath + "\\." };

            // Flush any cached information about the directory.
            _dataInitialised = -1;
        }

		
        /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.Delete"]/*' />
        public override void Delete()
        {
            Directory.Delete(FullPath, OriginalPath, false);
        }

        /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.Delete1"]/*' />
        public void Delete(bool recursive)
        {
            Directory.Delete(FullPath, OriginalPath, recursive);
        }

        
	
       

        // Returns the fully qualified path
        /// <include file='doc\DirectoryInfo.uex' path='docs/doc[@for="DirectoryInfo.ToString"]/*' />
        public override String ToString()
        {
            return OriginalPath;
        }


      

		  // Constants defined in WINBASE.H
        private const int GetFileExInfoStandard = 0;
      
        // Defined in WinError.h
       private const int ERROR_SUCCESS = 0;
        
		
	}
       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\binaryreader.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: BinaryReader
**
** Author: Jay Roxe
**
** Purpose: Wraps a stream and provides convenient read functionality
** for strings and primitive types.
**
** Date: April 8, 2000
**
============================================================*/
namespace System.IO {

    using System;
    using System.Text;

    /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader"]/*' />
    public class BinaryReader : IDisposable
    {
        private const int MaxCharBytesSize = 128;

        private Stream   m_stream;
        private byte[]   m_buffer;
        private Decoder  m_decoder;
        private byte[]   m_charBytes;
        private char[]   m_singleChar;
        private char[]   m_charBuffer;

        // Performance optimization for Read() w/ Unicode.  Speeds us up by ~40% 
        private bool     m_2BytesPerChar;

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.BinaryReader"]/*' />
        public BinaryReader(Stream input) : this(input, new UTF8Encoding()) {
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.BinaryReader1"]/*' />
        public BinaryReader(Stream input, Encoding encoding) {
            if (input==null) {
                throw new ArgumentNullException("input");
            }
            if (encoding==null) {
                throw new ArgumentNullException("encoding");
            }
            if (!input.CanRead)
                throw new ArgumentException(Environment.GetResourceString("Argument_StreamNotReadable"));
            m_stream = input;
            m_decoder = encoding.GetDecoder();
            int minBufferSize = encoding.GetMaxByteCount(1);  // max bytes per one char
            if (minBufferSize < 16) 
                minBufferSize = 16;
            m_buffer = new byte[minBufferSize];
            m_charBuffer = null;
            m_charBytes  = null;

            // Performance hack - for Encodings that always use 2 bytes per char
            // (or more), special case them here to make Read() & Peek() faster.
            m_2BytesPerChar = encoding is UnicodeEncoding;

            BCLDebug.Assert(m_decoder!=null, "[BinaryReader.ctor]m_decoder!=null");
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.BaseStream"]/*' />
        public virtual Stream BaseStream {
            get {
                return m_stream;
            }
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.Close"]/*' />
        public virtual void Close() {
            Dispose(true);
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                // Close in a thread-safe way (multiple calls to Close are safe)
                Stream copyOfStream = m_stream;
                m_stream = null;
                if (copyOfStream != null)
                    copyOfStream.Close();
            }
            m_stream = null;
            m_buffer = null;
            m_decoder = null;
            m_charBytes = null;
            m_singleChar = null;
            m_charBuffer = null;
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose()
        {
            Dispose(true);
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.PeekChar"]/*' />
        public virtual int PeekChar() {
            if (m_stream==null) __Error.FileNotOpen();

            if (!m_stream.CanSeek)
                return -1;
            long origPos = m_stream.Position;
            int ch = Read();
            m_stream.Position = origPos;
            return ch;
        }
        
        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.Read"]/*' />
        public virtual int Read() {
            if (m_stream==null) {
                __Error.FileNotOpen();
            }
            return InternalReadOneChar();
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadBoolean"]/*' />
        public virtual bool ReadBoolean(){
            FillBuffer(1);
            return (m_buffer[0]!=0);
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadByte"]/*' />
        public virtual byte ReadByte() {
            FillBuffer(1);
            return (m_buffer[0]);
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadSByte"]/*' />
        [CLSCompliant(false)]
        public virtual sbyte ReadSByte() {
            FillBuffer(1);
            return (sbyte)(m_buffer[0]);
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadChar"]/*' />
        public virtual char ReadChar() {
            int value = Read();
            if (value==-1) {
                __Error.EndOfFile();
            }
            return (char)value;
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadInt16"]/*' />
        public virtual short ReadInt16() {
            FillBuffer(2);
            return (short)(m_buffer[0] & 0xFF | m_buffer[1] << 8);
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadUInt16"]/*' />
        [CLSCompliant(false)]
        public virtual ushort ReadUInt16(){
            FillBuffer(2);
            return (ushort)(m_buffer[0] & 0xFF | m_buffer[1] << 8);
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadInt32"]/*' />
        public virtual int ReadInt32() {
            FillBuffer(4);
            return (int)((m_buffer[0]&0xFF) | m_buffer[1] << 8 | m_buffer[2] << 16 | m_buffer[3] << 24);
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadUInt32"]/*' />
        [CLSCompliant(false)]
        public virtual uint ReadUInt32() {
            FillBuffer(4);
            return (uint)(m_buffer[0] | (m_buffer[1]) << 8 | (m_buffer[2]) << 16 | m_buffer[3] << 24);
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadInt64"]/*' />
        public virtual long ReadInt64() {
            FillBuffer(8);
            uint lo = (uint)(m_buffer[0] | (m_buffer[1]) << 8 |
                             (m_buffer[2]) << 16 | m_buffer[3] << 24);
            uint hi = (uint)(m_buffer[4] | (m_buffer[5]) << 8 |
                             (m_buffer[6]) << 16 | m_buffer[7] << 24);
            return (long) ((ulong)hi) << 32 | lo;
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadUInt64"]/*' />
        [CLSCompliant(false)]
        public virtual ulong ReadUInt64() {
            FillBuffer(8);
            uint lo = (uint)(m_buffer[0] | (m_buffer[1]) << 8 |
                             (m_buffer[2]) << 16 | m_buffer[3] << 24);
            uint hi = (uint)(m_buffer[4] | (m_buffer[5]) << 8 |
                             (m_buffer[6]) << 16 | m_buffer[7] << 24);
            return ((ulong)hi) << 32 | lo;
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadSingle"]/*' />
        public virtual unsafe float ReadSingle() {
            FillBuffer(4);
            float f;
            fixed(byte* b = m_buffer)
                f = *((float*)b);
            return f;
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadDouble"]/*' />
        public virtual unsafe double ReadDouble() {
            FillBuffer(8);
            double d;
            fixed(byte* b = m_buffer)
                d = *((double*)b);
            return d;
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadDecimal"]/*' />
        public virtual decimal ReadDecimal() {
            FillBuffer(16);
            return Decimal.ToDecimal(m_buffer);
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadString"]/*' />
        public virtual String ReadString() {
            int currPos = 0;
            int n;
            int stringLength;
            int readLength;
            int charsRead;

            if (m_stream==null)
                __Error.FileNotOpen();

            // Length of the string in bytes, not chars
            stringLength = Read7BitEncodedInt();
            if (stringLength<0) {
                throw new IOException(String.Format(Environment.GetResourceString("IO.IO_InvalidStringLen_Len"), stringLength));
            }

            if (stringLength==0) {
                return String.Empty;
            }

            if (m_charBytes==null) {
                m_charBytes  = new byte[MaxCharBytesSize];
            }
            
            if (m_charBuffer == null) {
                m_charBuffer = new char[MaxCharBytesSize];
            }
            
            StringBuilder sb = null; 
            do
            {
                readLength = ((stringLength - currPos)>MaxCharBytesSize)?MaxCharBytesSize:(stringLength - currPos);

                n = m_stream.Read(m_charBytes, 0, readLength);
                if (n==0) {
                    __Error.EndOfFile();
                }

                charsRead = m_decoder.GetChars(m_charBytes, 0, n, m_charBuffer, 0);

                if (currPos == 0 && n == stringLength)
                    return new String(m_charBuffer, 0, charsRead);

                if (sb == null)
                    sb = new StringBuilder(stringLength); // Actual string length in chars may be smaller.
                sb.Append(m_charBuffer, 0, charsRead);
                currPos +=n;
            
            } while (currPos<stringLength);

            return sb.ToString();
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.Read1"]/*' />
        public virtual int Read(char[] buffer, int index, int count) {
            if (buffer==null) {
                throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
            }
            if (index < 0) {
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (count < 0) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            if (buffer.Length - index < count) {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            }

            if (m_stream==null)
                __Error.FileNotOpen();

            return InternalReadChars(buffer, index, count);
        }

        private int InternalReadChars(char[] buffer, int index, int count) {
            int charsRead = 0;
            int numBytes = 0;
            int charsRemaining = count;

            if (m_charBytes==null) {
                m_charBytes = new byte[MaxCharBytesSize];
            }

            while (charsRemaining>0) {
                // We really want to know what the minimum number of bytes per char
                // is for our encoding.  Otherwise for UnicodeEncoding we'd have to
                // do ~1+log(n) reads to read n characters.
                numBytes = charsRemaining;
                if (m_2BytesPerChar)
                    numBytes <<= 1;
                if (numBytes > MaxCharBytesSize)
                    numBytes = MaxCharBytesSize;

                numBytes = m_stream.Read(m_charBytes, 0, numBytes);

                if (numBytes==0) {
                    //  Console.WriteLine("Found no bytes.  We're outta here.");
                    return (count - charsRemaining);
                }
                charsRead = m_decoder.GetChars(m_charBytes, 0, numBytes, buffer, index);
                charsRemaining -= charsRead;
                index+=charsRead;
                //                Console.WriteLine("That became: " + charsRead + " characters.");
            }
            BCLDebug.Assert(charsRemaining == 0, "We didn't read all the chars we thought we would.");
            return count;
        }

        private int InternalReadOneChar() {
            // I know having a separate InternalReadOneChar method seems a little 
            // redundant, but this makes a scenario like the security parser code
            // 20% faster, in addition to the optimizations for UnicodeEncoding I
            // put in InternalReadChars.   -- BrianGru, 5/8/2001
            int charsRead = 0;
            int numBytes = 0;

            if (m_charBytes==null) {
                m_charBytes = new byte[MaxCharBytesSize];
            }
            if (m_singleChar==null) {
                m_singleChar = new char[1];
            }

            while (charsRead == 0) {
                // We really want to know what the minimum number of bytes per char
                // is for our encoding.  Otherwise for UnicodeEncoding we'd have to
                // do ~1+log(n) reads to read n characters.
                // Assume 1 byte can be 1 char unless m_2BytesPerChar is true.
                numBytes = m_2BytesPerChar ? 2 : 1;

                int r = m_stream.ReadByte();
                m_charBytes[0] = (byte) r;
                if (r == -1)
                    numBytes = 0;
                if (numBytes == 2) {
                    r = m_stream.ReadByte();
                    m_charBytes[1] = (byte) r;
                    if (r == -1)
                        numBytes = 1;
                }

                if (numBytes==0) {
                    // Console.WriteLine("Found no bytes.  We're outta here.");
                    return -1;
                }

                BCLDebug.Assert(numBytes == 1 || numBytes == 2, "BinaryReader::InternalReadOneChar assumes it's reading one or 2 bytes only.");

                charsRead = m_decoder.GetChars(m_charBytes, 0, numBytes, m_singleChar, 0);
                BCLDebug.Assert(charsRead < 2, "InternalReadOneChar - assuming we only got 0 or 1 char, not 2!");
                //                Console.WriteLine("That became: " + charsRead + " characters.");
            }
            if (charsRead == 0)
                return -1;
            return m_singleChar[0];
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadChars"]/*' />
        public virtual char[] ReadChars(int count) {
            if (m_stream==null) {
                __Error.FileNotOpen();
            }
            if (count<0) {
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            }
            char[] chars = new char[count];
            int n = InternalReadChars(chars, 0, count);
            if (n!=count) {
                char[] copy = new char[n];
                Buffer.InternalBlockCopy(chars, 0, copy, 0, 2*n); // sizeof(char)
                chars = copy;
            }

            return chars;
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.Read2"]/*' />
        public virtual int Read(byte[] buffer, int index, int count) {
            if (buffer==null)
                throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (index < 0)
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            if (m_stream==null) __Error.FileNotOpen();
            return m_stream.Read(buffer, index, count);
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.ReadBytes"]/*' />
        public virtual byte[] ReadBytes(int count) {
            if (count < 0) throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (m_stream==null) __Error.FileNotOpen();

            byte[] result = new byte[count];

            int numRead = 0;
            do {
                int n = m_stream.Read(result, numRead, count);
                if (n == 0)
                    break;
                numRead += n;
                count -= n;
            } while (count > 0);

            if (numRead != result.Length) {
                // Trim array.  This should happen on EOF & possibly net streams.
                byte[] copy = new byte[numRead];
                Buffer.InternalBlockCopy(result, 0, copy, 0, numRead);
                result = copy;
            }

            return result;
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.FillBuffer"]/*' />
        protected virtual void FillBuffer(int numBytes) {
            BCLDebug.Assert(m_buffer==null || (numBytes>0 && numBytes<=m_buffer.Length), "[FillBuffer]numBytes>0 && numBytes<=m_buffer.Length");
            int bytesRead=0;
            int n = 0;

            if (m_stream==null) __Error.FileNotOpen();

            // @TODO: Find a good threshold for calling ReadByte() repeatedly
            // vs. calling Read(byte[], int, int) for both buffered & unbuffered
            // streams.
            if (numBytes==1) {
                n = m_stream.ReadByte();
                if (n==-1)
                    __Error.EndOfFile();
                m_buffer[0] = (byte)n;
                return;
            }

            do {
                n = m_stream.Read(m_buffer, bytesRead, numBytes-bytesRead);
                if (n==0) {
                    __Error.EndOfFile();
                }
                bytesRead+=n;
            } while (bytesRead<numBytes);
        }

        /// <include file='doc\BinaryReader.uex' path='docs/doc[@for="BinaryReader.Read7BitEncodedInt"]/*' />
        protected int Read7BitEncodedInt() {
            // Read out an int 7 bits at a time.  The high bit
            // of the byte when on means to continue reading more bytes.
            int count = 0;
            int shift = 0;
            byte b;
            do {
                b = ReadByte();
                count |= (b & 0x7F) << shift;
                shift += 7;
            } while ((b & 0x80) != 0);
            return count;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\directorynotfoundexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  DirectoryNotFoundException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Exception for accessing a path that doesn't exist.
**
** Date:  February 18, 2000
**
===========================================================*/
using System;
using System.Runtime.Serialization;

namespace System.IO {
    /*
     * Thrown when trying to access a file that doesn't exist on disk.
     * Note this is thrown for 2 HRESULTS: The Win32 errorcode-as-HRESULT 
     * ERROR_PATH_NOT_FOUND (0x80070003) and STG_E_PATHNOTFOUND (0x80030003).
     */
    /// <include file='doc\DirectoryNotFoundException.uex' path='docs/doc[@for="DirectoryNotFoundException"]/*' />
    [Serializable]
    public class DirectoryNotFoundException : IOException {
        /// <include file='doc\DirectoryNotFoundException.uex' path='docs/doc[@for="DirectoryNotFoundException.DirectoryNotFoundException"]/*' />
        public DirectoryNotFoundException() 
            : base(Environment.GetResourceString("Arg_DirectoryNotFoundException")) {
    		SetErrorCode(__HResults.COR_E_DIRECTORYNOTFOUND);
        }
    
        /// <include file='doc\DirectoryNotFoundException.uex' path='docs/doc[@for="DirectoryNotFoundException.DirectoryNotFoundException1"]/*' />
        public DirectoryNotFoundException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_DIRECTORYNOTFOUND);
        }
    
        /// <include file='doc\DirectoryNotFoundException.uex' path='docs/doc[@for="DirectoryNotFoundException.DirectoryNotFoundException2"]/*' />
        public DirectoryNotFoundException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_DIRECTORYNOTFOUND);
        }
        
        /// <include file='doc\DirectoryNotFoundException.uex' path='docs/doc[@for="DirectoryNotFoundException.DirectoryNotFoundException3"]/*' />
        protected DirectoryNotFoundException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\fileattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  FileAttributes
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: File attribute flags corresponding to NT's flags.
**
** Date:   February 16, 1999
** 
===========================================================*/
using System;

namespace System.IO {
    // File attributes for use with the FileEnumerator class.
    // These constants correspond to the constants in WinNT.h.
    // 
    /// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes"]/*' />
    [Flags,Serializable]
    public enum FileAttributes
    {
    	// From WinNT.h (FILE_ATTRIBUTE_XXX)
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.ReadOnly"]/*' />
    	ReadOnly = 0x1,
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.Hidden"]/*' />
    	Hidden = 0x2,
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.System"]/*' />
    	System = 0x4,
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.Directory"]/*' />
    	Directory = 0x10,
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.Archive"]/*' />
    	Archive = 0x20,
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.Device"]/*' />
    	Device = 0x40,
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.Normal"]/*' />
    	Normal = 0x80,
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.Temporary"]/*' />
    	Temporary = 0x100,
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.SparseFile"]/*' />
    	SparseFile = 0x200,
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.ReparsePoint"]/*' />
    	ReparsePoint = 0x400,
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.Compressed"]/*' />
    	Compressed = 0x800,
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.Offline"]/*' />
    	Offline = 0x1000,
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.NotContentIndexed"]/*' />
    	NotContentIndexed = 0x2000,
    	/// <include file='doc\FileAttributes.uex' path='docs/doc[@for="FileAttributes.Encrypted"]/*' />
    	Encrypted = 0x4000,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\file.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  File
**
** Author: Rajesh Chandrashekaran (rajeshc)
**
** Purpose: A collection of methods for manipulating Files.
**
** Date:  February 22, 2000
**        April 09,2000 (some design refactorization)
**
===========================================================*/

using System;
using System.Security.Permissions;
using PermissionSet = System.Security.PermissionSet;
using Win32Native = Microsoft.Win32.Win32Native;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;

namespace System.IO {    
    // Class for creating FileStream objects, and some basic file management
    // routines such as Delete, etc.
    /// <include file='doc\File.uex' path='docs/doc[@for="File"]/*' />
    public sealed class File
    {
        private const int GetFileExInfoStandard = 0;

        private File()
        {
        }
       
         
        /// <include file='doc\File.uex' path='docs/doc[@for="File.OpenText"]/*' />
        public static StreamReader OpenText(String path)
        {
            if (path == null)
                throw new ArgumentNullException("path");
            return new StreamReader(path);
        }

        /// <include file='doc\File.uex' path='docs/doc[@for="File.CreateText"]/*' />
        public static StreamWriter CreateText(String path)
        {
            if (path == null)
                throw new ArgumentNullException("path");
            return new StreamWriter(path,false);
        }

        /// <include file='doc\File.uex' path='docs/doc[@for="File.AppendText"]/*' />
        public static StreamWriter AppendText(String path)
        {
            if (path == null)
                throw new ArgumentNullException("path");
            return new StreamWriter(path,true);
        }


        // Copies an existing file to a new file. An exception is raised if the
        // destination file already exists. Use the 
        // Copy(String, String, boolean) method to allow 
        // overwriting an existing file.
        //
        // The caller must have certain FileIOPermissions.  The caller must have
        // Read permission to sourceFileName and Create
        // and Write permissions to destFileName.
        // 
        /// <include file='doc\File.uex' path='docs/doc[@for="File.Copy"]/*' />
        public static void Copy(String sourceFileName, String destFileName) {
            Copy(sourceFileName, destFileName, false);
        }
    
        // Copies an existing file to a new file. If overwrite is 
        // false, then an IOException is thrown if the destination file 
        // already exists.  If overwrite is true, the file is 
        // overwritten.
        //
        // The caller must have certain FileIOPermissions.  The caller must have
        // Read permission to sourceFileName 
        // and Write permissions to destFileName.
        // 
        /// <include file='doc\File.uex' path='docs/doc[@for="File.Copy1"]/*' />
        public static void Copy(String sourceFileName, String destFileName, bool overwrite) {
            InternalCopy(sourceFileName, destFileName,overwrite);
        }

        /// <include file='doc\File.uex' path='docs/doc[@for="File.InternalCopy"]/*' />
        /// <devdoc>
        ///    Note: This returns the fully qualified name of the destination file.
        /// </devdoc>
        internal static String InternalCopy(String sourceFileName, String destFileName, bool overwrite) {
            if (sourceFileName==null || destFileName==null)
                throw new ArgumentNullException((sourceFileName==null ? "sourceFileName" : "destFileName"), Environment.GetResourceString("ArgumentNull_FileName"));
            if (sourceFileName.Length==0 || destFileName.Length==0)
                throw new ArgumentException(Environment.GetResourceString("Argument_EmptyFileName"), (sourceFileName.Length==0 ? "sourceFileName" : "destFileName"));
            
            String fullSourceFileName = Path.GetFullPathInternal(sourceFileName);
            new FileIOPermission(FileIOPermissionAccess.Read, new String[] { fullSourceFileName }, false, false ).Demand();
            String fullDestFileName = Path.GetFullPathInternal(destFileName);
            new FileIOPermission(FileIOPermissionAccess.Write, new String[] { fullDestFileName }, false, false ).Demand();
            
            bool r = Win32Native.CopyFile(fullSourceFileName, fullDestFileName, !overwrite);
            if (!r) {
                // Save Win32 error because subsequent checks will overwrite this HRESULT.
                int hr = Marshal.GetLastWin32Error();
                
                if (hr != Win32Native.ERROR_FILE_EXISTS) {
                    if (!InternalExists(fullSourceFileName))
                        __Error.WinIOError(Win32Native.ERROR_FILE_NOT_FOUND,sourceFileName);

                    if (Directory.InternalExists(fullDestFileName))
                        throw new IOException(Environment.GetResourceString("Arg_DirExists"));
                }

                __Error.WinIOError(hr, destFileName);
            }
                
            return fullDestFileName;
        }

    
        // Creates a file in a particular path.  If the file exists, it is replaced.
        // The file is opened with ReadWrite accessand cannot be opened by another 
        // application until it has been closed.  An IOException is thrown if the 
        // directory specified doesn't exist.
        //
        // Your application must have Create, Read, and Write permissions to
        // the file.
        // 
        /// <include file='doc\File.uex' path='docs/doc[@for="File.Create"]/*' />
        public static FileStream Create(String path) {
            return Create(path, FileStream.DefaultBufferSize);
        }
        
        // Creates a file in a particular path.  If the file exists, it is replaced.
        // The file is opened with ReadWrite access and cannot be opened by another 
        // application until it has been closed.  An IOException is thrown if the 
        // directory specified doesn't exist.
        //
        // Your application must have Create, Read, and Write permissions to
        // the file.
        // 
        /// <include file='doc\File.uex' path='docs/doc[@for="File.Create1"]/*' />
        public static FileStream Create(String path, int bufferSize) {
            return new FileStream(path, FileMode.Create, FileAccess.ReadWrite,
                                  FileShare.None, bufferSize);
        }
            
        // Deletes a file. The file specified by the designated path is deleted. 
        // If the file does not exist, Delete succeeds without throwing
        // an exception.
        // 
        // On NT, Delete will fail for a file that is open for normal I/O
        // or a file that is memory mapped.  On Win95, the file will be 
        // deleted irregardless of whether the file is being used.
        // 
        // Your application must have Delete permission to the target file.
        // 
        /// <include file='doc\File.uex' path='docs/doc[@for="File.Delete"]/*' />
        public static void Delete(String path) {
            if (path==null)
                throw new ArgumentNullException("path");
            
            String fullPath = Path.GetFullPathInternal(path);

            // For security check, path should be resolved to an absolute path.
            new FileIOPermission(FileIOPermissionAccess.Write, new String[] { fullPath }, false, false ).Demand();

            if (Directory.InternalExists(fullPath)) // Win9x hack to behave same as Winnt. Win9x fails silently for directories
                throw new UnauthorizedAccessException(String.Format(Environment.GetResourceString("UnauthorizedAccess_IODenied_Path"), path));
    
            bool r = Win32Native.DeleteFile(fullPath);
            if (!r) {
                int hr = Marshal.GetLastWin32Error();
                if (hr==Win32Native.ERROR_FILE_NOT_FOUND)
                    return;
                else
                    __Error.WinIOError(hr, path);
            }
        }

        // Tests if a file exists. The result is true if the file
        // given by the specified path exists; otherwise, the result is
        // false.  Note that if path describes a directory,
        // Exists will return true.
        //
        // Your application must have Read permission for the target directory.
        // 
        /// <include file='doc\File.uex' path='docs/doc[@for="File.Exists"]/*' />
        public static bool Exists(String path) {
            try
            {
                if (path==null)
                    return false;
                if (path.Length==0)
                    return false;
            
                path = Path.GetFullPathInternal(path);
                    
                new FileIOPermission(FileIOPermissionAccess.Read, new String[] { path }, false, false ).Demand();
            
                return InternalExists(path);
            }
            catch(ArgumentException) {} 
            catch(NotSupportedException) {} // To deal with the fact that security can now throw this on :
            catch(SecurityException) {}
            catch(IOException) {}
            catch(UnauthorizedAccessException) 
            {
                BCLDebug.Assert(false,"Ignore this assert and send a repro to rajeshc. This assert was tracking purposes only.");
            }
            return false;
        }

         internal static bool InternalExists(String path) {
            Win32Native.WIN32_FILE_ATTRIBUTE_DATA data = new Win32Native.WIN32_FILE_ATTRIBUTE_DATA();
            int dataInitialised = FillAttributeInfo(path,ref data,false);
            if (dataInitialised != 0)
                return false;

            return (data.fileAttributes  & Win32Native.FILE_ATTRIBUTE_DIRECTORY) == 0;
        }


        /// <include file='doc\File.uex' path='docs/doc[@for="File.Open"]/*' />
        public static FileStream Open(String path,FileMode mode) {
            return Open(path, mode, (mode == FileMode.Append ? FileAccess.Write : FileAccess.ReadWrite), FileShare.None);
        }
    
        /// <include file='doc\File.uex' path='docs/doc[@for="File.Open1"]/*' />
        public static FileStream Open(String path,FileMode mode, FileAccess access) {
            return Open(path,mode, access, FileShare.None);
        }

        /// <include file='doc\File.uex' path='docs/doc[@for="File.Open2"]/*' />
        public static FileStream Open(String path, FileMode mode, FileAccess access, FileShare share) {
            return new FileStream(path, mode, access, share);
        }

		/// <include file='doc\File.uex' path='docs/doc[@for="File.SetCreationTime"]/*' />
		public static void SetCreationTime(String path, DateTime creationTime)
		{
            SetCreationTimeUtc(path, creationTime.ToUniversalTime());
		}

		/// <include file='doc\File.uex' path='docs/doc[@for="File.SetCreationTimeUtc"]/*' />
		public static void SetCreationTimeUtc(String path, DateTime creationTimeUtc)
		{
			IntPtr handle = Win32Native.INVALID_HANDLE_VALUE;
			FileStream fs = OpenFile(path, FileAccess.Write, ref handle);

			bool r = Win32Native.SetFileTime(handle,  new long[] {creationTimeUtc.ToFileTimeUtc()}, null, null);
			if (!r)
			{
				 int errorCode = Marshal.GetLastWin32Error();
				 fs.Close();
    			__Error.WinIOError(errorCode, path);
			}
			fs.Close();
		}

		/// <include file='doc\File.uex' path='docs/doc[@for="File.GetCreationTime"]/*' />
		public static DateTime GetCreationTime(String path)
		{
            return GetCreationTimeUtc(path).ToLocalTime();
		}

		/// <include file='doc\File.uex' path='docs/doc[@for="File.GetCreationTimeUtc"]/*' />
		public static DateTime GetCreationTimeUtc(String path)
		{
			String fullPath = Path.GetFullPathInternal(path);
			new FileIOPermission(FileIOPermissionAccess.Read, new String[] { fullPath }, false, false ).Demand();

            Win32Native.WIN32_FILE_ATTRIBUTE_DATA data = new Win32Native.WIN32_FILE_ATTRIBUTE_DATA();
            int dataInitialised = FillAttributeInfo(fullPath,ref data,false);
            if (dataInitialised != 0)
                __Error.WinIOError(dataInitialised, path);

			if (data.fileAttributes == -1)
				throw new IOException(String.Format(Environment.GetResourceString("IO.PathNotFound_Path"), path));
						
			long dt = ((long)(data.ftCreationTimeHigh) << 32) | ((long)data.ftCreationTimeLow);
			return DateTime.FromFileTimeUtc(dt);
		}
      
		/// <include file='doc\File.uex' path='docs/doc[@for="File.SetLastAccessTime"]/*' />
		public static void SetLastAccessTime(String path, DateTime lastAccessTime)
		{
            SetLastAccessTimeUtc(path, lastAccessTime.ToUniversalTime());
		}

		/// <include file='doc\File.uex' path='docs/doc[@for="File.SetLastAccessTimeUtc"]/*' />
		public static void SetLastAccessTimeUtc(String path, DateTime lastAccessTimeUtc)
		{
			IntPtr handle = Win32Native.NULL;
			FileStream fs = OpenFile(path, FileAccess.Write, ref handle);

			bool r = Win32Native.SetFileTime(handle, null, new long[] {lastAccessTimeUtc.ToFileTimeUtc()},  null);
			if (!r)
			{
				 int errorCode = Marshal.GetLastWin32Error();
				 fs.Close();
    			__Error.WinIOError(errorCode, path);
			}
		
			fs.Close();
		}

		/// <include file='doc\File.uex' path='docs/doc[@for="File.GetLastAccessTime"]/*' />
		public static DateTime GetLastAccessTime(String path)
		{
            return GetLastAccessTimeUtc(path).ToLocalTime();
		}

		/// <include file='doc\File.uex' path='docs/doc[@for="File.GetLastAccessTimeUtc"]/*' />
		public static DateTime GetLastAccessTimeUtc(String path)
		{
			String fullPath = Path.GetFullPathInternal(path);
			new FileIOPermission(FileIOPermissionAccess.Read, new String[] { fullPath }, false, false ).Demand();

            Win32Native.WIN32_FILE_ATTRIBUTE_DATA data = new Win32Native.WIN32_FILE_ATTRIBUTE_DATA();
            int dataInitialised = FillAttributeInfo(fullPath,ref data,false);
            if (dataInitialised != 0)
                __Error.WinIOError(dataInitialised, path);

			if (data.fileAttributes == -1)
				throw new IOException(String.Format(Environment.GetResourceString("IO.PathNotFound_Path"), path));
			
			long dt = ((long)(data.ftLastAccessTimeHigh) << 32) | ((long)data.ftLastAccessTimeLow);
			return DateTime.FromFileTimeUtc(dt);
		}

		/// <include file='doc\File.uex' path='docs/doc[@for="File.SetLastWriteTime"]/*' />
		public static void SetLastWriteTime(String path, DateTime lastWriteTime)
		{
            SetLastWriteTimeUtc(path, lastWriteTime.ToUniversalTime());
		}

		/// <include file='doc\File.uex' path='docs/doc[@for="File.SetLastWriteTimeUtc"]/*' />
		public static void SetLastWriteTimeUtc(String path, DateTime lastWriteTimeUtc)
		{
			IntPtr handle = Win32Native.INVALID_HANDLE_VALUE;
			FileStream fs = OpenFile(path, FileAccess.Write, ref handle);

			bool r = Win32Native.SetFileTime(handle, null, null, new long[] {lastWriteTimeUtc.ToFileTimeUtc()});
			if (!r)
			{
				 int errorCode = Marshal.GetLastWin32Error();
				 fs.Close();
    			__Error.WinIOError(errorCode, path);
			}
			fs.Close();
		}

		/// <include file='doc\File.uex' path='docs/doc[@for="File.GetLastWriteTime"]/*' />
		public static DateTime GetLastWriteTime(String path)
		{
            return GetLastWriteTimeUtc(path).ToLocalTime();
		}

		/// <include file='doc\File.uex' path='docs/doc[@for="File.GetLastWriteTimeUtc"]/*' />
		public static DateTime GetLastWriteTimeUtc(String path)
		{
			String fullPath = Path.GetFullPathInternal(path);
			new FileIOPermission(FileIOPermissionAccess.Read, new String[] { fullPath }, false, false ).Demand();

            Win32Native.WIN32_FILE_ATTRIBUTE_DATA data = new Win32Native.WIN32_FILE_ATTRIBUTE_DATA();
            int dataInitialised = FillAttributeInfo(fullPath,ref data,false);
            if (dataInitialised != 0)
                __Error.WinIOError(dataInitialised, path);

			if (data.fileAttributes == -1)
				throw new IOException(String.Format(Environment.GetResourceString("IO.PathNotFound_Path"), path));
			
			long dt = ((long)data.ftLastWriteTimeHigh << 32) | ((long)data.ftLastWriteTimeLow);
			return DateTime.FromFileTimeUtc(dt);
		}

        /// <include file='doc\File.uex' path='docs/doc[@for="File.GetAttributes"]/*' />
        public static FileAttributes GetAttributes(String path) 
        {
            String fullPath = Path.GetFullPathInternal(path);
            new FileIOPermission(FileIOPermissionAccess.Read, new String[] { fullPath }, false, false).Demand();

            Win32Native.WIN32_FILE_ATTRIBUTE_DATA data = new Win32Native.WIN32_FILE_ATTRIBUTE_DATA();
            int dataInitialised = FillAttributeInfo(fullPath,ref data,false);
            if (dataInitialised != 0)
                __Error.WinIOError(dataInitialised, path);

            if (data.fileAttributes == -1)
                __Error.WinIOError(Win32Native.ERROR_FILE_NOT_FOUND, path);
                
            return (FileAttributes) data.fileAttributes;
        }

        /// <include file='doc\File.uex' path='docs/doc[@for="File.SetAttributes"]/*' />
        public static void SetAttributes(String path,FileAttributes fileAttributes) 
        {
            String fullPath = Path.GetFullPathInternal(path);
            new FileIOPermission(FileIOPermissionAccess.Write, new String[] { fullPath }, false, false).Demand();
            bool r = Win32Native.SetFileAttributes(fullPath, (int) fileAttributes);
            if (!r) {
                int hr = Marshal.GetLastWin32Error();
                if (hr==ERROR_INVALID_PARAMETER || hr==ERROR_ACCESS_DENIED) // Hack for Win98 to which returns Access denied sometimes
                        throw new ArgumentException(Environment.GetResourceString("Arg_InvalidFileAttrs"));
                 __Error.WinIOError(hr, path);
            }
        }

        /// <include file='doc\File.uex' path='docs/doc[@for="File.OpenRead"]/*' />
        public static FileStream OpenRead(String path) {
            return new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read);
        }


        /// <include file='doc\File.uex' path='docs/doc[@for="File.OpenWrite"]/*' />
        public static FileStream OpenWrite(String path) {
            return new FileStream(path, FileMode.OpenOrCreate, 
                                  FileAccess.Write, FileShare.None);
        }
        

       
        // Moves a specified file to a new location and potentially a new file name.
        // This method does work across volumes.
        //
        // The caller must have certain FileIOPermissions.  The caller must
        // have Read and Write permission to 
        // sourceFileName and Write 
        // permissions to destFileName.
        // 
        /// <include file='doc\File.uex' path='docs/doc[@for="File.Move"]/*' />
        public static void Move(String sourceFileName, String destFileName) {
            if (sourceFileName==null || destFileName==null)
                throw new ArgumentNullException((sourceFileName==null ? "sourceFileName" : "destFileName"), Environment.GetResourceString("ArgumentNull_FileName"));
            if (sourceFileName.Length==0 || destFileName.Length==0)
                throw new ArgumentException(Environment.GetResourceString("Argument_EmptyFileName"), (sourceFileName.Length==0 ? "sourceFileName" : "destFileName"));
            
            String fullSourceFileName = Path.GetFullPathInternal(sourceFileName);
            new FileIOPermission(FileIOPermissionAccess.Write | FileIOPermissionAccess.Read, new String[] { fullSourceFileName }, false, false).Demand();
            String fullDestFileName = Path.GetFullPathInternal(destFileName);
            new FileIOPermission(FileIOPermissionAccess.Write, new String[] { fullDestFileName }, false, false).Demand();

            if (!InternalExists(fullSourceFileName))
                __Error.WinIOError(Win32Native.ERROR_FILE_NOT_FOUND,sourceFileName);
            
            if (!Win32Native.MoveFile(fullSourceFileName, fullDestFileName))
            {
                int errorCode = Marshal.GetLastWin32Error();
                __Error.WinIOError(errorCode, destFileName);
            }
        }

        internal static int FillAttributeInfo(String path, ref Win32Native.WIN32_FILE_ATTRIBUTE_DATA data ,bool tryagain)
        {
            int dataInitialised = 0;
            if (Environment.OSInfo == Environment.OSName.Win95 || tryagain) 
            // We are running under Windows 95 and we don't have GetFileAttributesEx API or someone has a handle to the file open
            {
                Win32Native.WIN32_FIND_DATA win95data; // We do this only on Win95 machines
                win95data =  new Win32Native.WIN32_FIND_DATA (); 
                
                // Remove trialing slash since this can cause grief to FindFirstFile. You will get an invalid argument error
                String tempPath = path.TrimEnd(new char [] {Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar});

                // For floppy drives, normally the OS will pop up a dialog saying
                // there is no disk in drive A:, please insert one.  We don't want that.
                // SetErrorMode will let us disable this, but we should set the error
                // mode back, since this may have wide-ranging effects.
                int oldMode = Win32Native.SetErrorMode(Win32Native.SEM_FAILCRITICALERRORS);
                IntPtr handle = Win32Native.FindFirstFile(tempPath,win95data);
                Win32Native.SetErrorMode(oldMode);
                if (handle == Win32Native.INVALID_HANDLE_VALUE) {
                    dataInitialised = Marshal.GetLastWin32Error();
                    if (dataInitialised == Win32Native.ERROR_FILE_NOT_FOUND ||
                        dataInitialised == Win32Native.ERROR_PATH_NOT_FOUND ||
                        dataInitialised == Win32Native.ERROR_NOT_READY)  // floppy device not ready
                        {
                            data.fileAttributes = -1;
                            dataInitialised = 0;
                        }

                    return dataInitialised;
                }
                // Close the Win32 handle
                bool r = Win32Native.FindClose(handle);
                if (!r) {
                    BCLDebug.Assert(false, "File::FillAttributeInfo - FindClose failed!");
                    __Error.WinIOError();
                }

                // Copy the information to data
                data.fileAttributes = win95data.dwFileAttributes; 
                data.ftCreationTimeLow = (uint)win95data.ftCreationTime_dwLowDateTime; 
                data.ftCreationTimeHigh = (uint)win95data.ftCreationTime_dwHighDateTime; 
                data.ftLastAccessTimeLow = (uint)win95data.ftLastAccessTime_dwLowDateTime; 
                data.ftLastAccessTimeHigh = (uint)win95data.ftLastAccessTime_dwHighDateTime; 
                data.ftLastWriteTimeLow = (uint)win95data.ftLastWriteTime_dwLowDateTime; 
                data.ftLastWriteTimeHigh = (uint)win95data.ftLastWriteTime_dwHighDateTime; 
                data.fileSizeHigh = win95data.nFileSizeHigh; 
                data.fileSizeLow = win95data.nFileSizeLow; 
            }
            else
            {   
                                  
                 // For floppy drives, normally the OS will pop up a dialog saying
                // there is no disk in drive A:, please insert one.  We don't want that.
                // SetErrorMode will let us disable this, but we should set the error
                // mode back, since this may have wide-ranging effects.
                int oldMode = Win32Native.SetErrorMode(Win32Native.SEM_FAILCRITICALERRORS);
                bool success = Win32Native.GetFileAttributesEx(path, GetFileExInfoStandard, ref data);

                Win32Native.SetErrorMode(oldMode);
                if (!success) {
                    dataInitialised = Marshal.GetLastWin32Error();
                    if (dataInitialised == Win32Native.ERROR_FILE_NOT_FOUND ||
                        dataInitialised == Win32Native.ERROR_PATH_NOT_FOUND ||
                        dataInitialised == Win32Native.ERROR_NOT_READY)  // floppy device not ready
                    {
                        data.fileAttributes = -1;
                        dataInitialised = 0;
                    }
                    else
                    {
                     // In case someone latched onto the file. Take the perf hit only for failure
                        return FillAttributeInfo(path,ref data,true);
                    }
                }
            }

            return dataInitialised;
        }

        private static FileStream OpenFile(String path, FileAccess access, ref IntPtr handle)
        {
            FileStream fs = new FileStream(path, FileMode.Open, access, FileShare.ReadWrite, 1);
            handle = fs.Handle;

            if (handle == Win32Native.INVALID_HANDLE_VALUE) {
                // Return a meaningful error, using the RELATIVE path to
                // the file to avoid returning extra information to the caller.
            
                // NT5 oddity - when trying to open "C:\" as a FileStream,
                // we usually get ERROR_PATH_NOT_FOUND from the OS.  We should
                // probably be consistent w/ every other directory.
                int hr = Marshal.GetLastWin32Error();
                String FullPath = Path.GetFullPathInternal(path);
                if (hr==__Error.ERROR_PATH_NOT_FOUND && FullPath.Equals(Directory.GetDirectoryRoot(FullPath)))
                    hr = __Error.ERROR_ACCESS_DENIED;


                __Error.WinIOError(hr, path);
            }
            return fs;
        }


         // Defined in WinError.h
        private const int ERROR_INVALID_PARAMETER = 87;
        private const int ERROR_ACCESS_DENIED = 0x5;
     
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\endofstreamexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  EndOfStreamException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Exception to be thrown when reading past end-of-file.
**
** Date:  February 18, 2000
**
===========================================================*/

using System;
using System.Runtime.Serialization;

namespace System.IO {
    /// <include file='doc\EndOfStreamException.uex' path='docs/doc[@for="EndOfStreamException"]/*' />
    [Serializable]
    public class EndOfStreamException : IOException
    {
        /// <include file='doc\EndOfStreamException.uex' path='docs/doc[@for="EndOfStreamException.EndOfStreamException"]/*' />
        public EndOfStreamException() 
            : base(Environment.GetResourceString("Arg_EndOfStreamException")) {
    		SetErrorCode(__HResults.COR_E_ENDOFSTREAM);
        }
        
        /// <include file='doc\EndOfStreamException.uex' path='docs/doc[@for="EndOfStreamException.EndOfStreamException1"]/*' />
        public EndOfStreamException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_ENDOFSTREAM);
        }
    	
        /// <include file='doc\EndOfStreamException.uex' path='docs/doc[@for="EndOfStreamException.EndOfStreamException2"]/*' />
        public EndOfStreamException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_ENDOFSTREAM);
        }

        /// <include file='doc\EndOfStreamException.uex' path='docs/doc[@for="EndOfStreamException.EndOfStreamException3"]/*' />
        protected EndOfStreamException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\fileaccess.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Enum:   FileAccess
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Enum describing whether you want read and/or write
** permission to a file.
**
** Date:  February 18, 2000
**
===========================================================*/

using System;

namespace System.IO {
    // Contains constants for specifying the access you want for a file.
    // You can have Read, Write or ReadWrite access.
    // 
    /// <include file='doc\FileAccess.uex' path='docs/doc[@for="FileAccess"]/*' />
    [Serializable, Flags]
    public enum FileAccess
    {
        // Specifies read access to the file. Data can be read from the file and
        // the file pointer can be moved. Combine with WRITE for read-write access.
        /// <include file='doc\FileAccess.uex' path='docs/doc[@for="FileAccess.Read"]/*' />
        Read = 1,
    
        // Specifies write access to the file. Data can be written to the file and
        // the file pointer can be moved. Combine with READ for read-write access.
        /// <include file='doc\FileAccess.uex' path='docs/doc[@for="FileAccess.Write"]/*' />
        Write = 2,
    
        // Specifies read and write access to the file. Data can be written to the
        // file and the file pointer can be moved. Data can also be read from the 
        // file.
        /// <include file='doc\FileAccess.uex' path='docs/doc[@for="FileAccess.ReadWrite"]/*' />
        ReadWrite = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\fileloadexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  FileLoadException
**
** Author: Suzanne Cook (SuzCook)
**
** Purpose: Exception for failure to load a file that was successfully found.
**
** Date:  February 12, 2001
**
===========================================================*/

using System;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;
using System.Security.Permissions;
using SecurityException = System.Security.SecurityException;

namespace System.IO {

    /// <include file='doc\FileLoadException.uex' path='docs/doc[@for="FileLoadException"]/*' />
    [Serializable]
    public class FileLoadException : IOException {

        private String _fileName;   // the name of the file we could not load.
        private String _fusionLog;  // fusion log (when applicable)

        /// <include file='doc\FileLoadException.uex' path='docs/doc[@for="FileLoadException.FileLoadException"]/*' />
        public FileLoadException() 
            : base(Environment.GetResourceString("IO.FileLoad")) {
            SetErrorCode(__HResults.COR_E_FILELOAD);
        }
    
        /// <include file='doc\FileLoadException.uex' path='docs/doc[@for="FileLoadException.FileLoadException1"]/*' />
        public FileLoadException(String message) 
            : base(message) {
            SetErrorCode(__HResults.COR_E_FILELOAD);
        }
    
        /// <include file='doc\FileLoadException.uex' path='docs/doc[@for="FileLoadException.FileLoadException2"]/*' />
        public FileLoadException(String message, Exception inner) 
            : base(message, inner) {
            SetErrorCode(__HResults.COR_E_FILELOAD);
        }

        /// <include file='doc\FileLoadException.uex' path='docs/doc[@for="FileLoadException.FileLoadException3"]/*' />
        public FileLoadException(String message, String fileName) : base(message)
        {
            SetErrorCode(__HResults.COR_E_FILELOAD);
            _fileName = fileName;
        }

        /// <include file='doc\FileLoadException.uex' path='docs/doc[@for="FileLoadException.FileLoadException4"]/*' />
        public FileLoadException(String message, String fileName, Exception inner) 
            : base(message, inner) {
            SetErrorCode(__HResults.COR_E_FILELOAD);
            _fileName = fileName;
        }

        /// <include file='doc\FileLoadException.uex' path='docs/doc[@for="FileLoadException.Message"]/*' />
        public override String Message
        {
            get {
                SetMessageField();
                return _message;
            }
        }

        private void SetMessageField()
        {
            if (_message == null) {
                if ((_fileName == null) &&
                    (HResult == System.__HResults.COR_E_EXCEPTION))
                    _message = Environment.GetResourceString("IO.FileLoad");

                else
                    _message = FormatFileLoadExceptionMessage(_fileName, HResult);
            }

        }

        /// <include file='doc\FileLoadException.uex' path='docs/doc[@for="FileLoadException.FileName"]/*' />
        public String FileName {
            get { return _fileName; }
        }

        /// <include file='doc\FileLoadException.uex' path='docs/doc[@for="FileLoadException.ToString"]/*' />
        public override String ToString()
        {
            String s = GetType().FullName + ": " + Message;

            if (_fileName != null && _fileName.Length != 0)
                s += Environment.NewLine + String.Format(Environment.GetResourceString("IO.FileName_Name"), _fileName);
            
            if (InnerException != null)
                s = s + " ---> " + InnerException.ToString();

            if (StackTrace != null)
                s += Environment.NewLine + StackTrace;

            try
            {
                if(FusionLog!=null)
                {
                    if (s==null)
                        s=" ";
                    s+=Environment.NewLine;
                    s+=Environment.NewLine;
                    s+=FusionLog;
                }
            }
            catch(SecurityException)
            {
            
            }

            return s;
        }

        /// <include file='doc\FileLoadException.uex' path='docs/doc[@for="FileLoadException.FileLoadException5"]/*' />
        protected FileLoadException(SerializationInfo info, StreamingContext context) : base (info, context) {
            // Base class constructor will check info != null.

            _fileName = info.GetString("FileLoad_FileName");
            try
            {
                _fusionLog = info.GetString("FileLoad_FusionLog");
            }
            catch (Exception)
            {
                _fusionLog = null;
            }
                
        }

        private FileLoadException(String fileName, String fusionLog,int hResult)
            : base(null)
        {
            SetErrorCode(hResult);
            _fileName = fileName;
            _fusionLog=fusionLog;
            SetMessageField();
        }

        /// <include file='doc\FileLoadException.uex' path='docs/doc[@for="FileLoadException.FusionLog"]/*' />
        public String FusionLog {
            [SecurityPermissionAttribute( SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlEvidence | SecurityPermissionFlag.ControlPolicy)]
            get { return _fusionLog; }
        }

        /// <include file='doc\FileLoadException.uex' path='docs/doc[@for="FileLoadException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            // Serialize data for our base classes.  base will verify info != null.
            base.GetObjectData(info, context);

            // Serialize data for this class
            info.AddValue("FileLoad_FileName", _fileName, typeof(String));
            try
            {
                info.AddValue("FileLoad_FusionLog", FusionLog, typeof(String));
            }
            catch (SecurityException)
            {
            }
        }


        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String FormatFileLoadExceptionMessage(String fileName,
                                                                     int hResult);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\filemode.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Enum:   FileMode
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Enum describing whether to create a new file or 
** open an existing one.
**
** Date:  February 18, 2000
**
===========================================================*/
	
using System;

namespace System.IO {
    // Contains constants for specifying how the OS should open a file.
    // These will control whether you overwrite a file, open an existing
    // file, or some combination thereof.
    // 
    // To append to a file, use Append (which maps to OpenOrCreate then we seek
    // to the end of the file).  To truncate a file or create it if it doesn't 
    // exist, use Create.
    // 
    /// <include file='doc\FileMode.uex' path='docs/doc[@for="FileMode"]/*' />
    [Serializable]
    public enum FileMode
    {
        // Creates a new file. An exception is raised if the file already exists.
        /// <include file='doc\FileMode.uex' path='docs/doc[@for="FileMode.CreateNew"]/*' />
        CreateNew = 1,
    
        // Creates a new file. If the file already exists, it is overwritten.
        /// <include file='doc\FileMode.uex' path='docs/doc[@for="FileMode.Create"]/*' />
        Create = 2,
    
        // Opens an existing file. An exception is raised if the file does not exist.
        /// <include file='doc\FileMode.uex' path='docs/doc[@for="FileMode.Open"]/*' />
        Open = 3,
    
        // Opens the file if it exists. Otherwise, creates a new file.
        /// <include file='doc\FileMode.uex' path='docs/doc[@for="FileMode.OpenOrCreate"]/*' />
        OpenOrCreate = 4,
    
        // Opens an existing file. Once opened, the file is truncated so that its
        // size is zero bytes. The calling process must open the file with at least
        // WRITE access. An exception is raised if the file does not exist.
        /// <include file='doc\FileMode.uex' path='docs/doc[@for="FileMode.Truncate"]/*' />
        Truncate = 5,
    	
    	// Opens the file if it exists and seeks to the end.  Otherwise, 
    	// creates a new file.
    	/// <include file='doc\FileMode.uex' path='docs/doc[@for="FileMode.Append"]/*' />
    	Append = 6,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\fileinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  File
**
** Author: Rajesh Chandrashekaran (rajeshc)
**
** Purpose: A collection of methods for manipulating Files.
**
** Date:  February 22, 2000
**		  April 09,2000 (some design refactorization)
**
===========================================================*/

using System;
using System.Security.Permissions;
using PermissionSet = System.Security.PermissionSet;
using Win32Native = Microsoft.Win32.Win32Native;
using System.Runtime.InteropServices;
using System.Text;
using System.Runtime.Serialization;

namespace System.IO {    
    // Class for creating FileStream objects, and some basic file management
    // routines such as Delete, etc.
    /// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo"]/*' />
	[Serializable]
    public sealed class FileInfo: FileSystemInfo
    {
        private String _name;
	 
        private FileInfo() {
        }

	
        /// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.FileInfo"]/*' />
        public FileInfo(String fileName)
        {
            if (fileName==null)
                 throw new ArgumentNullException("fileName");
         
			OriginalPath = fileName;
            // Must fully qualify the path for the security check
            String fullPath = Path.GetFullPathInternal(fileName);
            new FileIOPermission(FileIOPermissionAccess.Read, new String[] { fullPath }, false, false).Demand();

            _name = Path.GetFileName(fileName);
            FullPath = fullPath;
        }

        private FileInfo(SerializationInfo info, StreamingContext context) : base(info, context)
        {
            new FileIOPermission(FileIOPermissionAccess.Read, new String[] { FullPath }, false, false).Demand();
            _name = Path.GetFileName(OriginalPath);
        }


        internal FileInfo(String fullPath, bool ignoreThis)
        {
            BCLDebug.Assert(Path.GetRootLength(fullPath) > 0, "fullPath must be fully qualified!");
            _name = Path.GetFileName(fullPath);
			OriginalPath = _name;
            FullPath = fullPath;
        }

			/// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.Name"]/*' />
		public override String Name {
            get { return _name; }
        }
	
   
        /// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.Length"]/*' />
        public long Length {
            get {
				if (_dataInitialised == -1)
					Refresh();
				
				if (_dataInitialised != 0) // Refresh was unable to initialise the data
					__Error.WinIOError(_dataInitialised, OriginalPath);
		
				if ((_data.fileAttributes & Win32Native.FILE_ATTRIBUTE_DIRECTORY) != 0)
					__Error.WinIOError(Win32Native.ERROR_FILE_NOT_FOUND,OriginalPath);
				
				return ((long)_data.fileSizeHigh) << 32 | ((long)_data.fileSizeLow & 0xFFFFFFFFL);
            }
        }

		/* Returns the name of the directory that the file is in */
		/// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.DirectoryName"]/*' />
		public String DirectoryName
		{
			get
			{
				String directoryName = Path.GetDirectoryName(FullPath);
                if (directoryName != null)
				    new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { directoryName }, false, false).Demand();
				return directoryName;
            }
		}

		/* Creates an instance of the the parent directory */
		/// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.Directory"]/*' />
		public DirectoryInfo Directory
		{
			get
			{
				String dirName = DirectoryName;
                if (dirName == null)
                    return null;
				return new DirectoryInfo(dirName);	
			}
		} 

		/// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.OpenText"]/*' />
		public StreamReader OpenText()
		{
			return new StreamReader(FullPath, Encoding.UTF8, true, StreamReader.DefaultBufferSize);
		}

		/// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.CreateText"]/*' />
		public StreamWriter CreateText()
		{
			return new StreamWriter(FullPath,false);
		}


		/// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.AppendText"]/*' />
		public StreamWriter AppendText()
		{
			return new StreamWriter(FullPath,true);
		}

		
        // Copies an existing file to a new file. An exception is raised if the
        // destination file already exists. Use the 
        // Copy(String, String, boolean) method to allow 
        // overwriting an existing file.
        //
        // The caller must have certain FileIOPermissions.  The caller must have
        // Read permission to sourceFileName 
        // and Write permissions to destFileName.
        // 
        /// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.CopyTo"]/*' />
        public FileInfo CopyTo(String destFileName) {
    		return CopyTo(destFileName, false);
        }

	/// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.Create"]/*' />

        public FileStream Create() {
            return File.Create(FullPath);
        }

        // Copies an existing file to a new file. If overwrite is 
        // false, then an IOException is thrown if the destination file 
        // already exists.  If overwrite is true, the file is 
        // overwritten.
        //
        // The caller must have certain FileIOPermissions.  The caller must have
        // Read permission to sourceFileName and Create
        // and Write permissions to destFileName.
        // 
        /// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.CopyTo1"]/*' />
        public FileInfo CopyTo(String destFileName, bool overwrite) {
            destFileName = File.InternalCopy(FullPath, destFileName, overwrite);
			return new FileInfo(destFileName, false);
        }

    	// Deletes a file. The file specified by the designated path is deleted. 
    	// If the file does not exist, Delete succeeds without throwing
    	// an exception.
    	// 
    	// On NT, Delete will fail for a file that is open for normal I/O
    	// or a file that is memory mapped.  On Win95, the file will be 
    	// deleted irregardless of whether the file is being used.
    	// 
    	// Your application must have Delete permission to the target file.
    	// 
    	/// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.Delete"]/*' />
    	public override void Delete() {
			// For security check, path should be resolved to an absolute path.
    		new FileIOPermission(FileIOPermissionAccess.Write, new String[] { FullPath }, false, false).Demand();

            if (System.IO.Directory.InternalExists(FullPath)) // Win9x hack to behave same as Winnt. Win9x fails silently for directories
                throw new UnauthorizedAccessException(String.Format(Environment.GetResourceString("UnauthorizedAccess_IODenied_Path"), OriginalPath));
    
			bool r = Win32Native.DeleteFile(FullPath);
    		if (!r) {
    			int hr = Marshal.GetLastWin32Error();
    			if (hr==Win32Native.ERROR_FILE_NOT_FOUND)
    				return;
    			else
    				__Error.WinIOError(hr, OriginalPath);
    		}
    	}

	

        // Tests if the given file exists. The result is true if the file
        // given by the specified path exists; otherwise, the result is
        // false.  Note that if path describes a directory,
        // Exists will return true.
        //
        // Your application must have Read permission for the target directory.
        // 
        /// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.Exists"]/*' />
        public override bool Exists {
			get
			{
				try
				{
					if (_dataInitialised == -1)
						Refresh();
					if (_dataInitialised != 0) // Refresh was unable to initialise the data
						__Error.WinIOError(_dataInitialised, OriginalPath);

    				return (_data.fileAttributes & Win32Native.FILE_ATTRIBUTE_DIRECTORY) == 0;
				}
				catch(Exception)
				{
					return false;
				}
			}
        }

        
      
      
        // User must explicitly specify opening a new file or appending to one.
        /// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.Open"]/*' />
        public FileStream Open(FileMode mode) {
            return Open(mode, FileAccess.ReadWrite, FileShare.None);
        }

		
    
        /// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.Open1"]/*' />
        public FileStream Open(FileMode mode, FileAccess access) {
            return Open(mode, access, FileShare.None);
        }

		

        /// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.Open2"]/*' />
        public FileStream Open(FileMode mode, FileAccess access, FileShare share) {
            return new FileStream(FullPath, mode, access, share);
        }

		

        
        /// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.OpenRead"]/*' />
        public FileStream OpenRead() {
            return new FileStream(FullPath, FileMode.Open, FileAccess.Read,
                                  FileShare.Read);
        }

        

        /// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.OpenWrite"]/*' />
        public FileStream OpenWrite() {
            return new FileStream(FullPath, FileMode.OpenOrCreate, 
                                  FileAccess.Write, FileShare.None);
        }

      

       
    	

        // Moves a given file to a new location and potentially a new file name.
        // This method does work across volumes.
        //
        // The caller must have certain FileIOPermissions.  The caller must
        // have Read and Write permission to 
        // sourceFileName and Write 
        // permissions to destFileName.
        // 
        /// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.MoveTo"]/*' />
        public void MoveTo(String destFileName) {
            if (destFileName==null)
                throw new ArgumentNullException("destFileName");
            if (destFileName.Length==0)
                throw new ArgumentException(Environment.GetResourceString("Argument_EmptyFileName"), "destFileName");
    		
            new FileIOPermission(FileIOPermissionAccess.Write | FileIOPermissionAccess.Read, new String[] { FullPath }, false, false).Demand();
            String fullDestFileName = Path.GetFullPathInternal(destFileName);
            new FileIOPermission(FileIOPermissionAccess.Write, new String[] { fullDestFileName }, false, false).Demand();
    		
            if (!Win32Native.MoveFile(FullPath, fullDestFileName))
    			__Error.WinIOError();
            FullPath = fullDestFileName;
            OriginalPath = destFileName;
            _name = Path.GetFileName(fullDestFileName);

            // Flush any cached information about the file.
            _dataInitialised = -1;
        }

        // Returns the fully qualified path
        /// <include file='doc\FileInfo.uex' path='docs/doc[@for="FileInfo.ToString"]/*' />
        public override String ToString()
        {
            return OriginalPath;
        }
   
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\filenotfoundexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  FileNotFoundException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Exception for accessing a file that doesn't exist.
**
** Date:  February 18, 2000
**
===========================================================*/

using System;
using System.Runtime.Serialization;
using System.Security.Permissions;
using SecurityException = System.Security.SecurityException;

namespace System.IO {
    // Thrown when trying to access a file that doesn't exist on disk.
    /// <include file='doc\FileNotFoundException.uex' path='docs/doc[@for="FileNotFoundException"]/*' />
    [Serializable]
    public class FileNotFoundException : IOException {

        private String _fileName;  // The name of the file that isn't found.
        private String _fusionLog;  // fusion log (when applicable)
        
        /// <include file='doc\FileNotFoundException.uex' path='docs/doc[@for="FileNotFoundException.FileNotFoundException"]/*' />
        public FileNotFoundException() 
            : base(Environment.GetResourceString("IO.FileNotFound")) {
            SetErrorCode(__HResults.COR_E_FILENOTFOUND);
        }
    
        /// <include file='doc\FileNotFoundException.uex' path='docs/doc[@for="FileNotFoundException.FileNotFoundException1"]/*' />
        public FileNotFoundException(String message) 
            : base(message) {
            SetErrorCode(__HResults.COR_E_FILENOTFOUND);
        }
    
        /// <include file='doc\FileNotFoundException.uex' path='docs/doc[@for="FileNotFoundException.FileNotFoundException2"]/*' />
        public FileNotFoundException(String message, Exception innerException) 
            : base(message, innerException) {
            SetErrorCode(__HResults.COR_E_FILENOTFOUND);
        }

        /// <include file='doc\FileNotFoundException.uex' path='docs/doc[@for="FileNotFoundException.FileNotFoundException3"]/*' />
        public FileNotFoundException(String message, String fileName) : base(message)
        {
            SetErrorCode(__HResults.COR_E_FILENOTFOUND);
            _fileName = fileName;
        }

        /// <include file='doc\FileNotFoundException.uex' path='docs/doc[@for="FileNotFoundException.FileNotFoundException4"]/*' />
        public FileNotFoundException(String message, String fileName, Exception innerException) 
            : base(message, innerException) {
            SetErrorCode(__HResults.COR_E_FILENOTFOUND);
            _fileName = fileName;
        }

        /// <include file='doc\FileNotFoundException.uex' path='docs/doc[@for="FileNotFoundException.Message"]/*' />
        public override String Message
        {
            get {
                SetMessageField();
                return _message;
            }
        }

        private void SetMessageField()
        {
            if (_message == null) {
                if ((_fileName == null) &&
                    (HResult == System.__HResults.COR_E_EXCEPTION))
                    _message = Environment.GetResourceString("IO.FileNotFound");

                else
                    _message = FileLoadException.FormatFileLoadExceptionMessage(_fileName, HResult);
            }
        }

        /// <include file='doc\FileNotFoundException.uex' path='docs/doc[@for="FileNotFoundException.FileName"]/*' />
        public String FileName {
            get { return _fileName; }
        }

        /// <include file='doc\FileNotFoundException.uex' path='docs/doc[@for="FileNotFoundException.ToString"]/*' />
        public override String ToString()
        {
            String s = GetType().FullName + ": " + Message;

            if (_fileName != null && _fileName.Length != 0)
                s += Environment.NewLine + String.Format(Environment.GetResourceString("IO.FileName_Name"), _fileName);
            
            if (InnerException != null)
                s = s + " ---> " + InnerException.ToString();

            if (StackTrace != null)
                s += Environment.NewLine + StackTrace;
            
            try
            {
                if(FusionLog!=null)
                {
                    if (s==null)
                        s=" ";
                    s+=Environment.NewLine;
                    s+=Environment.NewLine;
                    s+=FusionLog;
                }
            }
            catch(SecurityException)
            {
            
            }
            return s;
        }

        /// <include file='doc\FileNotFoundException.uex' path='docs/doc[@for="FileNotFoundException.FileNotFoundException5"]/*' />
        protected FileNotFoundException(SerializationInfo info, StreamingContext context) : base (info, context) {
            // Base class constructor will check info != null.

            _fileName = info.GetString("FileNotFound_FileName");
            try
            {
                _fusionLog = info.GetString("FileNotFound_FusionLog");
            }
            catch (Exception)
            {
                _fusionLog = null;
            }
            
        }

        private FileNotFoundException(String fileName, String fusionLog,int hResult)
            : base(null)
        {
            SetErrorCode(hResult);
            _fileName = fileName;
            _fusionLog=fusionLog;
            SetMessageField();
        }

        /// <include file='doc\FileNotFoundException.uex' path='docs/doc[@for="FileNotFoundException.FusionLog"]/*' />
        public String FusionLog {
            [SecurityPermissionAttribute( SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlEvidence | SecurityPermissionFlag.ControlPolicy)]
            get { return _fusionLog; }
        }


        /// <include file='doc\FileNotFoundException.uex' path='docs/doc[@for="FileNotFoundException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            // Serialize data for our base classes.  base will verify info != null.
            base.GetObjectData(info, context);

            // Serialize data for this class
            info.AddValue("FileNotFound_FileName", _fileName, typeof(String));
            try
            {
                info.AddValue("FileNotFound_FusionLog", FusionLog, typeof(String));
            }
            catch (SecurityException)
            {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\seekorigin.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Enum:   SeekOrigin
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Enum describing locations in a stream you could
** seek relative to.
**
** Date:  February 18, 2000
**
===========================================================*/

using System;

namespace System.IO {
    // Provides seek reference points.  To seek to the end of a stream,
    // call stream.Seek(0, SeekOrigin.End).
    /// <include file='doc\SeekOrigin.uex' path='docs/doc[@for="SeekOrigin"]/*' />
	  [Serializable()]
    public enum SeekOrigin
    {
    	// These constants match Win32's FILE_BEGIN, FILE_CURRENT, and FILE_END
    	/// <include file='doc\SeekOrigin.uex' path='docs/doc[@for="SeekOrigin.Begin"]/*' />
    	Begin = 0,
    	/// <include file='doc\SeekOrigin.uex' path='docs/doc[@for="SeekOrigin.Current"]/*' />
    	Current = 1,
    	/// <include file='doc\SeekOrigin.uex' path='docs/doc[@for="SeekOrigin.End"]/*' />
    	End = 2,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\pathtoolongexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  PathTooLongException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Exception for paths and/or filenames that are 
** too long.
**
** Date:   March 24, 2000
**
===========================================================*/

using System;
using System.Runtime.Serialization;

namespace System.IO {

    /// <include file='doc\PathTooLongException.uex' path='docs/doc[@for="PathTooLongException"]/*' />
    [Serializable]
    public class PathTooLongException : IOException
    {
        /// <include file='doc\PathTooLongException.uex' path='docs/doc[@for="PathTooLongException.PathTooLongException"]/*' />
        public PathTooLongException() 
            : base(Environment.GetResourceString("IO.PathTooLong")) {
            SetErrorCode(__HResults.COR_E_PATHTOOLONG);
        }
        
        /// <include file='doc\PathTooLongException.uex' path='docs/doc[@for="PathTooLongException.PathTooLongException1"]/*' />
        public PathTooLongException(String message) 
            : base(message) {
            SetErrorCode(__HResults.COR_E_PATHTOOLONG);
        }
        
        /// <include file='doc\PathTooLongException.uex' path='docs/doc[@for="PathTooLongException.PathTooLongException2"]/*' />
        public PathTooLongException(String message, Exception innerException) 
            : base(message, innerException) {
            SetErrorCode(__HResults.COR_E_PATHTOOLONG);
        }

        /// <include file='doc\PathTooLongException.uex' path='docs/doc[@for="PathTooLongException.PathTooLongException3"]/*' />
        protected PathTooLongException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\path.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Path
**
** Author: Rajesh Chandrashekaran
**
** Purpose: A collection of path manipulation methods.
**
** Date:  February 22, 2000
**
===========================================================*/

using System;
using System.Security.Permissions;
using Win32Native = Microsoft.Win32.Win32Native;
using System.Text;
using System.Runtime.InteropServices;
using System.Security;
using System.Runtime.CompilerServices;
using System.Globalization;

namespace System.IO {
    // Provides methods for processing directory strings in an ideally
    // cross-platform manner.  Most of the methods don't do a complete
    // full parsing (such as examining a UNC hostname), but they will
    // handle most string operations.  
    // 
    // File names cannot contain backslash (\), slash (/), colon (:),
    // asterick (*), question mark (?), quote ("), less than (<), 
    // greater than (>), or pipe (|).  The first three are used as directory
    // separators on various platforms.  Asterick and question mark are treated
    // as wild cards.  Less than, Greater than, and pipe all redirect input
    // or output from a program to a file or some combination thereof.  Quotes
    // are special.
    // 
    // We are guaranteeing that Path.SeparatorChar is the correct 
    // directory separator on all platforms, and we will support 
    // Path.AltSeparatorChar as well.  To write cross platform
    // code with minimal pain, you can use slash (/) as a directory separator in
    // your strings.
     // Class contains only static data, no need to serialize
    /// <include file='doc\Path.uex' path='docs/doc[@for="Path"]/*' />
    public sealed class Path
    {
        
        private Path() {
        }
    
        // Platform specific directory separator character.  This is backslash
        // ('\') on Windows, slash ('/') on Unix, and colon (':') on Mac.
        // 
        // @TODO porting: Make this platform specific when we port.
        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.DirectorySeparatorChar"]/*' />
        public static readonly char DirectorySeparatorChar = '\\';
        
        // Platform specific alternate directory separator character.  
        // This is backslash ('\') on Unix, and slash ('/') on Windows 
        // and MacOS.
        // 
        // @TODO porting: Make this platform specific when we port.
        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.AltDirectorySeparatorChar"]/*' />
        public static readonly char AltDirectorySeparatorChar = '/';
    
        // Platform specific volume separator character.  This is colon (':')
        // on Windows and MacOS, and slash ('/') on Unix.  This is mostly
        // useful for parsing paths like "c:\windows" or "MacVolume:System Folder".  
        // 
        // @TODO porting: Make this platform specific when we port.
        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.VolumeSeparatorChar"]/*' />
        public static readonly char VolumeSeparatorChar = ':';
        
        // Platform specific invalid list of characters in a path.
        // 
        // @TODO porting: Make this platform specific when we port.
        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.InvalidPathChars"]/*' />
        public static readonly char[] InvalidPathChars = { '\"', '<', '>', '|', '\0', '\b', (Char)16, (Char)17, (Char)18, (Char)20, (Char)21, (Char)22, (Char)23, (Char)24, (Char)25 };

        internal static readonly char[] InternalInvalidPathChars = { '\"', '<', '>', '|', '\0', '\b', (Char)16, (Char)17, (Char)18, (Char)20, (Char)21, (Char)22, (Char)23, (Char)24, (Char)25 };

        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.PathSeparator"]/*' />
        public static readonly char PathSeparator = ';';
    
    
        // Changes the extension of a file path. The path parameter
        // specifies a file path, and the extension parameter
        // specifies a file extension (with a leading period, such as
        // ".exe" or ".cool").
        //
        // The function returns a file path with the same root, directory, and base
        // name parts as path, but with the file extension changed to
        // the specified extension. If path is null, the function
        // returns null. If path does not contain a file extension,
        // the new file extension is appended to the path. If extension
        // is null, any exsiting extension is removed from path.
        //
        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.ChangeExtension"]/*' />
        public static String ChangeExtension(String path, String extension) {
            if (path != null) {
                CheckInvalidPathChars(path);
    
                String s = path;
                for (int i = path.Length; --i >= 0;) {
                    char ch = path[i];
                    if (ch == '.') {
                        s = path.Substring(0, i);
                        break;
                    }
                    if (ch == DirectorySeparatorChar || ch == AltDirectorySeparatorChar || ch == VolumeSeparatorChar) break;
                }
                if (extension != null && path.Length != 0) {
                    if (extension.Length == 0 || extension[0] != '.') {
                        s = s + ".";
                    }
                    s = s + extension;
                }
                return s;
            }
            return null;
        }

        
        // Returns the directory path of a file path. This method effectively
        // removes the last element of the given file path, i.e. it returns a
        // string consisting of all characters up to but not including the last
        // backslash ("\") in the file path. The returned value is null if the file
        // path is null or if the file path denotes a root (such as "\", "C:", or
        // "\\server\share").
        //
        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.GetDirectoryName"]/*' />
        public static String GetDirectoryName(String path) {
            if (path != null) {
                CheckInvalidPathChars(path);
                path = FixupPath(path);
                int root = GetRootLength(path);
                int i = path.Length;
                if (i > root) {
                    i = path.Length;
                    if (i == root) return null;
                    while (i > root && path[--i] != DirectorySeparatorChar && path[i] != AltDirectorySeparatorChar);
                    return path.Substring(0, i);
                }
            }
            return null;
        }

        // Gets the length of the root DirectoryInfo or whatever DirectoryInfo markers
        // are specified for the first part of the DirectoryInfo name.
        // 
        internal static int GetRootLength(String path) {
            CheckInvalidPathChars(path);
            
            int i = 0;
            int length = path.Length;
            if (length >= 1 && (IsDirectorySeparator(path[0]))) {
                // handles UNC names and directories off current drive's root.
                i = 1;
                if (length >= 2 && (IsDirectorySeparator(path[1]))) {
                    i = 2;
                    int n = 2;
                    while (i < length && ((path[i] != DirectorySeparatorChar && path[i] != AltDirectorySeparatorChar) || --n > 0)) i++;
                }
            }
            else if (length >= 2 && path[1] == VolumeSeparatorChar) {
                // handles A:\foo.
                i = 2;
                if (length >= 3 && (IsDirectorySeparator(path[2]))) i++;
            }
            return i;
        }

        internal static bool IsDirectorySeparator(char c) {
            return (c==DirectorySeparatorChar || c == AltDirectorySeparatorChar);
        }


        // Returns the extension of the given path. The returned value includes the
        // period (".") character of the extension except when you have a terminal period when you get String.Empty, such as ".exe" or
        // ".cpp". The returned value is null if the given path is
        // null or if the given path does not include an extension.
        //
        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.GetExtension"]/*' />
        public static String GetExtension(String path) {
            if (path==null)
                return null;

            CheckInvalidPathChars(path);
            int length = path.Length;
            for (int i = length; --i >= 0;) {
                char ch = path[i];
                if (ch == '.')
                {
                    if (i != length - 1)
                        return path.Substring(i, length - i);
                    else
                        return String.Empty;
                }
                if (ch == DirectorySeparatorChar || ch == AltDirectorySeparatorChar || ch == VolumeSeparatorChar)
                    break;
            }
            return String.Empty;
        }

        // Expands the given path to a fully qualified path. The resulting string
        // consists of a drive letter, a colon, and a root relative path. This
        // function does not verify that the resulting path is valid or that it
        // refers to an existing file or DirectoryInfo on the associated volume.
        //
        // Your application must have unrestricted Environment permission.
        // 

        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.GetFullPath"]/*' />
        public static String GetFullPath(String path) {
            String fullPath = GetFullPathInternal(path);
            new FileIOPermission( FileIOPermissionAccess.PathDiscovery, new String[] { fullPath }, false, false ).Demand();
            return fullPath;
        }

        // This method is internal to let us quickly get a string name
        // while avoiding a security check.  This also serves a slightly
        // different purpose - when we open a file, we need to resolve the
        // path into a fully qualified, non-relative path name.  This
        // method does that, finding the current drive & directory.  But
        // as long as we don't return this info to the user, we're good.  However,
        // the public GetFullPath does need to do a security check.
        internal static String GetFullPathInternal(String path) {
            if (path == null)
                throw new ArgumentNullException("path");

            if ( (String.Compare(path, 0, "http:", 0, 5, true, CultureInfo.InvariantCulture) == 0) ||
                 (String.Compare(path, 0, "file:", 0, 5, true, CultureInfo.InvariantCulture) == 0) )
                throw new ArgumentException( Environment.GetResourceString( "Argument_PathUriFormatNotSupported" ) );
            
            String newPath;
            int hresult = nGetFullPathHelper( path, InternalInvalidPathChars, String.WhitespaceChars, DirectorySeparatorChar, AltDirectorySeparatorChar, VolumeSeparatorChar, true, out newPath );
            if (hresult != 0)
                __Error.WinIOError(hresult, path);

            return newPath;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int nGetFullPathHelper(String path, char[] invalidPathChars, char[] whitespaceChars, char directorySeparator, char altDirectorySeparator, char volumeSeparator, bool fullCheck, out String newPath);
    
        // Win9x hack to fixup path to replace multiple slashes with a single slash
        // Note: any changes you make to this function must also be reflected in
        // COMStreams::GetFullPathHelper in COMStreams.cpp
        internal static String FixupPath(String path)
        {
            String newPath;
            int hresult = nGetFullPathHelper( path, InternalInvalidPathChars, String.WhitespaceChars, DirectorySeparatorChar, AltDirectorySeparatorChar, VolumeSeparatorChar, false, out newPath );
            if (hresult != 0)
            {
                __Error.WinIOError(hresult, path);
            }
            return newPath;
        }
        
        // Returns the name and extension parts of the given path. The resulting
        // string contains the characters of path that follow the last
        // backslash ("\"), slash ("/"), or colon (":") character in 
        // path. The resulting string is the entire path if path 
        // contains no backslash after removing trailing slashes, slash, or colon characters. The resulting 
        // string is null if path is null.
        //
        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.GetFileName"]/*' />
        public static String GetFileName(String path) {
          if (path != null) {
                CheckInvalidPathChars(path);
    
                int length = path.Length;
                for (int i = length; --i >= 0;) {
                    char ch = path[i];
                    if (ch == DirectorySeparatorChar || ch == AltDirectorySeparatorChar || ch == VolumeSeparatorChar)
                        return path.Substring(i + 1, length - i - 1);

                }
            }
            return path;
        }

        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.GetFileNameWithoutExtension"]/*' />
        public static String GetFileNameWithoutExtension(String path) {
            path = GetFileName(path);
            if (path != null)
            {
                int i;
                if ((i=path.LastIndexOf('.')) == -1)
                    return path; // No path extension found
                else
                    return path.Substring(0,i);
            }
            return null;
         }



        // Returns the root portion of the given path. The resulting string
        // consists of those rightmost characters of the path that constitute the
        // root of the path. Possible patterns for the resulting string are: An
        // empty string (a relative path on the current drive), "\" (an absolute
        // path on the current drive), "X:" (a relative path on a given drive,
        // where X is the drive letter), "X:\" (an absolute path on a given drive),
        // and "\\server\share" (a UNC path for a given server and share name).
        // The resulting string is null if path is null.
        //
        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.GetPathRoot"]/*' />
        public static String GetPathRoot(String path) {
            if (path == null) return null;
            path = FixupPath(path);
            return path.Substring(0, GetRootLength(path));
        }

        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.GetTempPath"]/*' />
        public static String GetTempPath()
        {
            new EnvironmentPermission(PermissionState.Unrestricted).Demand();
            StringBuilder sb = new StringBuilder(MAX_PATH);
            uint r = Win32Native.GetTempPath(MAX_PATH, sb);
            String path = sb.ToString();
            if (r==0) __Error.WinIOError();
            return path;
        }

        // Returns a unique temporary file name, and creates a 0-byte file by that
        // name on disk.
        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.GetTempFileName"]/*' />
        public static String GetTempFileName()
        {
            String path = GetTempPath();
            StringBuilder sb = new StringBuilder(MAX_PATH);
            uint r = Win32Native.GetTempFileName(path, "tmp", 0, sb);
            if (r==0) __Error.WinIOError();
            return sb.ToString();
        }
    
        // Tests if a path includes a file extension. The result is
        // true if the characters that follow the last directory
        // separator ('\\' or '/') or volume separator (':') in the path include 
        // a period (".") other than a terminal period. The result is false otherwise.
        //
        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.HasExtension"]/*' />
        public static bool HasExtension(String path) {
            if (path != null) {
                CheckInvalidPathChars(path);
                
                for (int i = path.Length; --i >= 0;) {
                    char ch = path[i];
                    if (ch == '.') {
                        if ( i != path.Length - 1)
                            return true;
                        else
                            return false;
                    }
                    if (ch == DirectorySeparatorChar || ch == AltDirectorySeparatorChar || ch == VolumeSeparatorChar) break;
                }
            }
            return false;
        }
    
    
        // Tests if the given path contains a root. A path is considered rooted
        // if it starts with a backslash ("\") or a drive letter and a colon (":").
        //
        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.IsPathRooted"]/*' />
        public static bool IsPathRooted(String path) {
            if (path != null) {
                CheckInvalidPathChars(path);
    
                int length = path.Length;
                if (length >= 1 && (path[0] == DirectorySeparatorChar || path[0] == AltDirectorySeparatorChar) ||
                    length >= 2 && path[1] == VolumeSeparatorChar) return true;
            }
            return false;
        }

        /// <include file='doc\Path.uex' path='docs/doc[@for="Path.Combine"]/*' />
        public static String Combine(String path1, String path2) {
            if (path1==null || path2==null)
                throw new ArgumentNullException((path1==null) ? "path1" : "path2");
            CheckInvalidPathChars(path1);
            CheckInvalidPathChars(path2);
            
            if (path2.Length == 0)
                return path1;

            if (path1.Length == 0)
                return path2;
                
            if (IsPathRooted(path2))
                return path2;

            char ch = path1[path1.Length - 1];
            if (ch != DirectorySeparatorChar && ch != AltDirectorySeparatorChar && ch != VolumeSeparatorChar) 
                return path1 + DirectorySeparatorChar + path2;
            return path1 + path2;
        }


        // ".." can only be used if it is specified as a part of a valid File/Directory name. We disallow
        //  the user being able to use it to move up directories. Here are some examples eg 
        //    Valid: a..b  abc..d
        //    Invalid: ..ab   ab..  ..   abc..d\abc..
        //
        internal static void CheckSearchPattern(String searchPattern)
        {
            int index;
            // Only check for these characters on Win9x.  The problem doesn't
            // exist on WinNT and we would break other characters.
            if ((Environment.OSInfo & Environment.OSName.Win9x) != 0 && CanPathCircumventSecurityNative(searchPattern))
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidSearchPattern"));
            while ((index = searchPattern.IndexOf("..")) != -1) {
                    
                 if (index + 2 == searchPattern.Length) // Terminal ".." . Files names cannot end in ".."
                    throw new ArgumentException(Environment.GetResourceString("Arg_InvalidSearchPattern"));
                
                 if ((searchPattern[index+2] ==  DirectorySeparatorChar)
                    || (searchPattern[index+2] == AltDirectorySeparatorChar))
                    throw new ArgumentException(Environment.GetResourceString("Arg_InvalidSearchPattern"));
                
                searchPattern = searchPattern.Substring(index + 2);
            }

        }

        internal static void CheckInvalidPathChars(String path)
        {
            //if (path==null)
            //  return;
            if (-1 != path.IndexOfAny(InternalInvalidPathChars))
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPathChars"));
        }

        
        internal static String InternalCombine(String path1, String path2) {
            if (path1==null || path2==null)
                throw new ArgumentNullException((path1==null) ? "path1" : "path2");
            CheckInvalidPathChars(path1);
            CheckInvalidPathChars(path2);
            
            if (path2.Length == 0)
                throw new ArgumentException(Environment.GetResourceString("Argument_PathEmpty"), "path2");
            if (IsPathRooted(path2))
                throw new ArgumentException(Environment.GetResourceString("Arg_Path2IsRooted"), "path2");
            int i = path1.Length;
            if (i == 0) return path2;
            char ch = path1[i - 1];
            if (ch != DirectorySeparatorChar && ch != AltDirectorySeparatorChar && ch != VolumeSeparatorChar) 
                return path1 + DirectorySeparatorChar + path2;
            return path1 + path2;
        }

        // Checks for Unicode characters that map to potentially dangerous
        // characters in the system's default ANSI code page.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool CanPathCircumventSecurityNative(String partOfPath);

        // Windows API definitions
        internal const int MAX_PATH = 260;  // From WinDef.h
        internal const int ERROR_SUCCESS = 0;  // From WinError.h
        internal const int MAX_DIRECTORY_PATH = 248;   // cannot create directories greater than 248 characters
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\filestream.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  FileStream
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Exposes a Stream around a file, with full 
** synchronous and asychronous support, and buffering.
**
** Date:  February 21, 2000
**
===========================================================*/
using System;
using Microsoft.Win32;
using System.Security;
using System.Security.Permissions;
using System.Threading;
using System.Runtime.InteropServices;
using System.Runtime.Remoting.Messaging;
using System.Runtime.CompilerServices;

/*
 * Implementation notes:
 * FileStream supports different modes of accessing the disk - async mode
 * and sync mode.  They are two completely different codepaths in the
 * sync & async methods (ie, Read/Write vs. BeginRead/BeginWrite).  File
 * handles in NT can be opened in only sync or overlapped (async) mode,
 * and we have to deal with this pain.  Stream has implementations of
 * the sync methods in terms of the async ones, so we'll
 * call through to our base class to get those methods when necessary.
 *
 * I've also added buffering into FileStream as well.  I folded in the
 * code from BufferedStream, so all the comments about it being mostly
 * aggressive (and the possible perf improvement) apply to FileStream as 
 * well.  I also added some buffering to the async code paths.
 *
 * Class Invariants:
 * The class has one buffer, shared for reading & writing.  It can only be
 * used for one or the other at any point in time - not both.  The following
 * should be true:
 *   0 <= _readPos <= _readLen < _bufferSize
 *   0 <= _writePos < _bufferSize
 *   _readPos == _readLen && _readPos > 0 implies the read buffer is valid, 
 *     but we're at the end of the buffer.
 *   _readPos == _readLen == 0 means the read buffer contains garbage.
 *   Either _writePos can be greater than 0, or _readLen & _readPos can be
 *     greater than zero, but neither can be greater than zero at the same time.
 *
 *                                   -- Brian Grunkemeyer, 3/11/2002
 */

namespace System.IO {
    /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream"]/*' />
    public class FileStream : Stream
    {
        internal const int DefaultBufferSize = 4096;
        private static readonly bool _canUseAsync = RunningOnWinNTNative();

        private unsafe static readonly IOCompletionCallback IOCallback = new IOCompletionCallback(FileStream.AsyncFSCallback);

        private byte[] _buffer;   // Shared read/write buffer.  Alloc on first use.
        private String _fileName; // Fully qualified file name.
        private bool _isAsync;    // Whether we opened the handle for overlapped IO
        private bool _canRead;
        private bool _canWrite;
        private bool _canSeek;
        private int _readPos;     // Read pointer within shared buffer.
        private int _readLen;     // Number of bytes read in buffer from file.
        private int _writePos;    // Write pointer within shared buffer.
        private int _bufferSize;  // Length of internal buffer, if it's allocated.
        private long _pos;        // Cache current location in the file.
        private __HandleProtector _handleProtector;  // See the __HandleProtector class.
        private long _appendStart;// When appending, prevent overwriting file.
        private bool _isPipe;     // Whether to disable async buffering code.

        // This is an internal object implementing IAsyncResult with fields
        // for all of the relevant data necessary to complete the IO operation.
        // This is used by AsyncFSCallback and all of the async methods.
        unsafe internal class AsyncFileStream_AsyncResult : IAsyncResult
        {
            // User code callback
            internal AsyncCallback _userCallback;
            
            internal Object _userStateObject;
            internal WaitHandle _waitHandle;
            internal GCHandle _bufferHandle;  // GCHandle to pin byte[].

            internal bool _isWrite;     // Whether this is a read or a write
            internal bool _isComplete;
            internal bool _completedSynchronously;  // Which thread called callback
            internal bool _bufferIsPinned;   // Whether our _bufferHandle is valid.
            internal int _EndXxxCalled;   // Whether we've called EndXxx already.
            internal int _numBytes;     // number of bytes read OR written
            internal int _numBufferedBytes;
            internal int _errorCode;
            internal NativeOverlapped* _overlapped;

            // I tried adding in a finalizer here to catch the places 
            // where users didn't call EndRead or EndWrite on an IAsyncResult,
            // but it doesn't work.  The unmanaged memory in the NativeOverlapped
            // struct keeps a GCHandle to this IAsyncResult object alive, so we
            // never get finalized.  -- BrianGru, 5/9/2001


            /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.AsyncFileStream_AsyncResult.AsyncState"]/*' />
            public virtual Object AsyncState
            {
                get { return _userStateObject; }
            }

            /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.AsyncFileStream_AsyncResult.IsCompleted"]/*' />
            public bool IsCompleted
            {
                get { return _isComplete; }
                set { _isComplete = value; }
            }

            /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.AsyncFileStream_AsyncResult.AsyncWaitHandle"]/*' />
            public WaitHandle AsyncWaitHandle
            {
                get { return _waitHandle; }
            }

            // Returns true iff the user callback was called by the thread that 
            // called BeginRead or BeginWrite.  If we use an async delegate or
            // threadpool thread internally, this will be false.  This is used
            // by code to determine whether a successive call to BeginRead needs 
            // to be done on their main thread or in their callback to avoid a
            // stack overflow on many reads or writes.
            public bool CompletedSynchronously
            {
                get { return _completedSynchronously; }
            }

            internal static AsyncFileStream_AsyncResult CreateBufferedReadResult(int numBufferedBytes, AsyncCallback userCallback, Object userStateObject) {
                AsyncFileStream_AsyncResult asyncResult = new AsyncFileStream_AsyncResult();
                asyncResult._userCallback = userCallback;
                asyncResult._userStateObject = userStateObject;
                asyncResult._isComplete = true;
                asyncResult._isWrite = false;
                asyncResult._numBufferedBytes = numBufferedBytes;
                return asyncResult;
            }
            
            internal void CallUserCallback()
            {
                // Convenience method for me, since I have to do this in a number 
                // of places in the buffering code for fake IAsyncResults.  Note 
                // that AsyncFSCallback intentionally does not use this method.
                if (_userCallback != null) {
                    // Call user's callback on a threadpool thread.  We do
                    // not technically need to call EndInvoke - the async
                    // delegate's IAsyncResult finalizer will clean up for us.
                    // Set completedSynchronously to false, since it's on another 
                    // thread, not the main thread.
                    _completedSynchronously = false;
                    _userCallback.BeginInvoke(this, null, null);
                }
            }

            // If this OS may return from a call to ReadFile or WriteFile then
            // later fill in the buffer, presumably we should make sure we don't
            // move the buffer around in the GC heap.
            internal void PinBuffer(byte[] buffer)
            {
                _bufferHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                _bufferIsPinned = true;
            }

            internal void UnpinBuffer()
            {
                if (_bufferIsPinned) {
                    _bufferHandle.Free();
                    _bufferIsPinned = false;
                }
            }
        }

        //This exists only to support IsolatedStorageFileStream.
        //Any changes to FileStream must include the corresponding changes in IsolatedStorage.
        internal FileStream() { 
            _fileName = null;
            _handleProtector = null;
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.FileStream"]/*' />
        public FileStream(String path, FileMode mode) 
            : this(path, mode, (mode == FileMode.Append ? FileAccess.Write : FileAccess.ReadWrite), FileShare.Read, DefaultBufferSize, false, Path.GetFileName(path), false) {
        }
    
        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.FileStream1"]/*' />
        public FileStream(String path, FileMode mode, FileAccess access) 
            : this(path, mode, access, FileShare.Read, DefaultBufferSize, false, Path.GetFileName(path), false) {
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.FileStream2"]/*' />
        public FileStream(String path, FileMode mode, FileAccess access, FileShare share) 
            : this(path, mode, access, share, DefaultBufferSize, false, Path.GetFileName(path), false) {
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.FileStream3"]/*' />
        public FileStream(String path, FileMode mode, FileAccess access, FileShare share, int bufferSize) : this(path, mode, access, share, bufferSize, false, Path.GetFileName(path), false)
        {
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.FileStream4"]/*' />
        public FileStream(String path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync) : this(path, mode, access, share, bufferSize, useAsync, Path.GetFileName(path), false)
        {
        }

        internal FileStream(String path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync, String msgPath, bool bFromProxy)
        {
            // Note: msgPath must be safe to hand back to untrusted code.

            _fileName = msgPath;  // To handle odd cases of finalizing partially constructed objects.

            if (path == null)
                throw new ArgumentNullException("path", Environment.GetResourceString("ArgumentNull_Path"));
            if (path.Length == 0)
                throw new ArgumentException(Environment.GetResourceString("Argument_EmptyPath"));
            if (mode < FileMode.CreateNew || mode > FileMode.Append ||
                access < FileAccess.Read || access > FileAccess.ReadWrite ||
                share < FileShare.None || share > FileShare.ReadWrite) {
                String badArg = "mode";
                if (access < FileAccess.Read || access > FileAccess.ReadWrite)
                    badArg = "access";
                if (share < FileShare.None || share > FileShare.ReadWrite)
                    badArg = "share";
                throw new ArgumentOutOfRangeException(badArg, Environment.GetResourceString("ArgumentOutOfRange_Enum"));
            }
            if (bufferSize <= 0)
                throw new ArgumentOutOfRangeException("bufferSize", Environment.GetResourceString("ArgumentOutOfRange_NeedPosNum"));

            int fAccess = access == FileAccess.Read? GENERIC_READ:
                access == FileAccess.Write? GENERIC_WRITE:
                GENERIC_READ | GENERIC_WRITE;
            
            // Get absolute path - Security needs this to prevent something
            // like trying to create a file in c:\tmp with the name 
            // "..\WinNT\System32\ntoskrnl.exe".  Store it for user convenience.
            String filePath = Path.GetFullPathInternal(path);

            _fileName = filePath;

            // Prevent access to your disk drives as raw block devices.
            if (filePath.StartsWith("\\\\.\\"))
                throw new ArgumentException(Environment.GetResourceString("Arg_DevicesNotSupported"));

            // Build up security permissions required, as well as validate we
            // have a sensible set of parameters.  IE, creating a brand new file
            // for reading doesn't make much sense.
            FileIOPermissionAccess secAccess = FileIOPermissionAccess.NoAccess;
            if ((access & FileAccess.Read) != 0) {
                if (mode==FileMode.Append)
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidAppendMode"));
                else
                    secAccess = secAccess | FileIOPermissionAccess.Read;
            }
            // I can't think of any combos of FileMode we should disallow if we
            // don't have read access.  Writing would pretty much always be valid
            // in those cases.

            if ((access & FileAccess.Write) != 0) {
                if (mode==FileMode.Append)
                    secAccess = secAccess | FileIOPermissionAccess.Append;
                else
                    secAccess = secAccess | FileIOPermissionAccess.Write;
            }
            else {
                // No write access
                if (mode==FileMode.Truncate || mode==FileMode.CreateNew || mode==FileMode.Create || mode==FileMode.Append)
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidFileMode&AccessCombo"), mode, access));
            }

            new FileIOPermission(secAccess, new String[] { filePath }, false, false).Demand();

            bool seekToEnd = (mode==FileMode.Append);
            // Must use a valid Win32 constant here...
            if (mode == FileMode.Append)
                mode = FileMode.OpenOrCreate;

            // By default, FileStream-provided handles are not inheritable by 
            // child processes, but with FileShare.Inheritable you can redirect 
            // stdout from a child process to a log file from your parent, etc.
            Win32Native.SECURITY_ATTRIBUTES secAttrs = null;
            if ((share & FileShare.Inheritable) != 0) {
                secAttrs = new Win32Native.SECURITY_ATTRIBUTES();
                secAttrs.nLength = (int)Marshal.SizeOf(secAttrs);
                secAttrs.bInheritHandle = 1;
                share &= ~FileShare.Inheritable;
            }

            // Do the right thing for whatever platform we're on.  This way,
            // someone can easily write code that opens a file asynchronously
            // no matter what their platform is.
            IntPtr handle;
            if (_canUseAsync && useAsync) {
                handle = Win32Native.UnsafeCreateFile(filePath, fAccess, share, secAttrs, mode, FILE_FLAG_OVERLAPPED, Win32Native.NULL);
                _isAsync = true;
            }
            else {
                handle = Win32Native.UnsafeCreateFile(filePath, fAccess, share, secAttrs, mode, FILE_ATTRIBUTE_NORMAL, Win32Native.NULL);
                _isAsync = false;
            }
                
            if (handle != Win32Native.INVALID_HANDLE_VALUE) {
                _handleProtector = new __FileStreamHandleProtector(handle, true);
            }
            else {
                // Return a meaningful error, using the RELATIVE path to
                // the file to avoid returning extra information to the caller
                // unless they have path discovery permission, in which case
                // the full path is fine & useful.
                
                // NT5 oddity - when trying to open "C:\" as a FileStream,
                // we usually get ERROR_PATH_NOT_FOUND from the OS.  We should
                // probably be consistent w/ every other directory.
                int hr = Marshal.GetLastWin32Error();
                if (hr==__Error.ERROR_PATH_NOT_FOUND && filePath.Equals(Directory.InternalGetDirectoryRoot(filePath)))
                    hr = __Error.ERROR_ACCESS_DENIED;

                // We need to give an exception, and preferably it would include
                // the fully qualified path name.  Do security check here.  If
                // we fail, give back the msgPath, which should not reveal much.
                bool canGiveFullPath = false;

                if (!bFromProxy)
                {
                    try {
                        new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { _fileName }, false, false ).Demand();
                        canGiveFullPath = true;
                    }
                    catch(SecurityException) {}
                }

                if (canGiveFullPath)
                    __Error.WinIOError(hr, _fileName);
                else
                    __Error.WinIOError(hr, msgPath);
            }

            // Disallow access to all non-file devices from the FileStream
            // constructors that take a String.  Everyone else can call 
            // CreateFile themselves then use the constructor that takes an 
            // IntPtr.  Disallows "con:", "com1:", "lpt1:", etc.
            int fileType = Win32Native.GetFileType(handle);
            if (fileType != Win32Native.FILE_TYPE_DISK) {
                _handleProtector.Close();
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_FileStreamOnNonFiles"));
            }

            // This is necessary for async IO using IO Completion ports via our 
            // managed Threadpool API's.  This (theoretically) calls the OS's 
            // BindIoCompletionCallback method, and passes in a stub for the 
            // LPOVERLAPPED_COMPLETION_ROUTINE.  This stub looks at the Overlapped
            // struct for this request and gets a delegate to a managed callback 
            // from there, which it then calls on a threadpool thread.  (We allocate
            // our native OVERLAPPED structs 2 pointers too large and store EE state
            // & GC handles there, one to an IAsyncResult, the other to a delegate.)
            if (_isAsync) {
                bool b = false;
                // BindHandle requires UnmanagedCode permission
                new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
                try {
                    b = ThreadPool.BindHandle(handle);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
                if (!b) {
                    throw new IOException(Environment.GetResourceString("IO.IO_BindHandleFailed"));
                }
            }

            _canRead = (access & FileAccess.Read) != 0;
            _canWrite = (access & FileAccess.Write) != 0;
            _canSeek = true;
            _isPipe = false;
            _pos = 0;
            _bufferSize = bufferSize;
            _readPos = 0;
            _readLen = 0;
            _writePos = 0;

            // For Append mode...
            if (seekToEnd) {
                _appendStart = SeekCore(0, SeekOrigin.End);
            }
            else {
                _appendStart = -1;
            }
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.FileStream5"]/*' />
        public FileStream(IntPtr handle, FileAccess access) 
            : this(handle, access, true, DefaultBufferSize, false) {
        }
        
        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.FileStream6"]/*' />
        public FileStream(IntPtr handle, FileAccess access, bool ownsHandle) 
            : this(handle, access, ownsHandle, DefaultBufferSize, false) {
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.FileStream7"]/*' />
        public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize)
            : this(handle, access, ownsHandle, bufferSize, false) {
        }

        // Note we explicitly do a Demand, not a LinkDemand here.
        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.FileStream8"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync) {
            if (access < FileAccess.Read || access > FileAccess.ReadWrite)
                throw new ArgumentOutOfRangeException("access", Environment.GetResourceString("ArgumentOutOfRange_Enum"));
            if (bufferSize <= 0)
                throw new ArgumentOutOfRangeException("bufferSize", Environment.GetResourceString("ArgumentOutOfRange_NeedPosNum"));
            if (handle==Win32Native.INVALID_HANDLE_VALUE)
                throw new ArgumentException(Environment.GetResourceString("Arg_InvalidHandle"), "handle");

            int handleType = Win32Native.GetFileType(handle) & 0x7FFF;
            _handleProtector = new __FileStreamHandleProtector(handle, ownsHandle);
            BCLDebug.Assert(handleType == Win32Native.FILE_TYPE_DISK || handleType == Win32Native.FILE_TYPE_PIPE || handleType == Win32Native.FILE_TYPE_CHAR, "FileStream was passed an unknown file type!");
            _isAsync = isAsync && _canUseAsync;  // On Win9x, just do the right thing.
            _canRead = 0 != (access & FileAccess.Read);
            _canWrite = 0 != (access & FileAccess.Write);
            _canSeek = handleType == Win32Native.FILE_TYPE_DISK;
            _bufferSize = bufferSize;
            _readPos = 0;
            _readLen = 0;
            _writePos = 0;
            _fileName = null;
            _isPipe = handleType == Win32Native.FILE_TYPE_PIPE;


            // This is necessary for async IO using IO Completion ports via our 
            // managed Threadpool API's.  This calls the OS's 
            // BindIoCompletionCallback method, and passes in a stub for the 
            // LPOVERLAPPED_COMPLETION_ROUTINE.  This stub looks at the Overlapped
            // struct for this request and gets a delegate to a managed callback 
            // from there, which it then calls on a threadpool thread.  (We allocate
            // our native OVERLAPPED structs 2 pointers too large and store EE 
            // state & a handle to a delegate there.)
            if (_isAsync) {
                bool b = false;
                try {
                    // We're still in the constructor, so we don't need to use the 
                    // HandleProtector's TryAddRef here.
                    b = ThreadPool.BindHandle(_handleProtector.Handle);
                }
                catch (ApplicationException) {
                    // If you passed in a synchronous handle and told us to use
                    // it asynchronously, throw here.
                    throw new ArgumentException(Environment.GetResourceString("Arg_HandleNotAsync"));
                }
                if (!b) {
                    throw new IOException(Environment.GetResourceString("IO.IO_BindHandleFailed"));
                }
            }
            else {
                if (handleType != Win32Native.FILE_TYPE_PIPE)
                    VerifyHandleIsSync();
            }

            if (_canSeek) {
                _pos = SeekCore(0, SeekOrigin.Current);

                // BUGBUG: Remove this logic to seek back to the end of the stream
                // when I can freely fix bugs again.  We removed this limitation 
                // about a year ago.  -- Brian, 2/20/2002
                if (_pos > Length) {
                    _pos = SeekCore(0, SeekOrigin.End);
                }
                // END BUGBUG

            }
            else
                _pos = 0;
        }


        // Verifies that this handle supports synchronous IO operations (unless you
        // didn't open it for either reading or writing).
        private unsafe void VerifyHandleIsSync()
        {
            // Do NOT use this method on pipes.  Reading or writing to a pipe may
            // cause an app to block incorrectly, introducing a deadlock (depending
            // on whether a write will wake up an already-blocked thread or this
            // FileStream's thread).

            // Do NOT change this to use a byte[] of length 0, or test test won't
            // work.  Our ReadFile & WriteFile methods are special cased to return
            // for arrays of length 0, since we'd get an IndexOutOfRangeException 
            // while using C#'s fixed syntax.
            byte[] bytes = new byte[1];
            int hr = 0;
            int r = 0;
            
            // Note that if the handle is a pipe, ReadFile will block until there
            // has been a write on the other end.  We'll just have to deal with it,
            // I guess...  For the read end of a pipe, you can mess up and 
            // accidentally read synchronously from an async pipe.
            if (CanRead) {
                r = ReadFileNative(_handleProtector, bytes, 0, 0, null, out hr);
            }
            else if (CanWrite) {
                r = WriteFileNative(_handleProtector, bytes, 0, 0, null, out hr);
            }

            if (hr==ERROR_INVALID_PARAMETER)
                throw new ArgumentException(Environment.GetResourceString("Arg_HandleNotSync"));
            if (hr == Win32Native.ERROR_INVALID_HANDLE)
                __Error.WinIOError(hr, "<OS handle>");
        }


        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.CanRead"]/*' />
        public override bool CanRead {
            get { return _canRead; }
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.CanWrite"]/*' />
        public override bool CanWrite {
            get { return _canWrite; }
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.CanSeek"]/*' />
        public override bool CanSeek {
            get { return _canSeek; }
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.IsAsync"]/*' />
        public virtual bool IsAsync {
            get { return _isAsync; }
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.Length"]/*' />
        public override long Length {
            get {
                if (_handleProtector.IsClosed) __Error.FileNotOpen();
                if (!CanSeek) __Error.SeekNotSupported();
                int hi = 0, lo = 0;

                bool incremented = false;
                try {
                    if (_handleProtector.TryAddRef(ref incremented)) 
                        lo = Win32Native.GetFileSize(_handleProtector.Handle, out hi);
                    else
                        __Error.FileNotOpen();
                }
                finally {
                    if (incremented) _handleProtector.Release();
                }

                if (lo==-1) {  // Check for either an error or a 4GB - 1 byte file.
                    int hr = Marshal.GetLastWin32Error();
                    if (hr != 0)
                        __Error.WinIOError(hr, String.Empty);
                }
                long len = (((long)hi) << 32) | ((uint) lo);
                // If we're writing near the end of the file, we must include our
                // internal buffer in our Length calculation.  Don't flush because
                // we use the length of the file in our async write method.
                if (_writePos > 0 && _pos + _writePos > len)
                    len = _writePos + _pos;
                return len;
            }
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.Name"]/*' />
        public String Name {
            get {
                if (_fileName == null)
                    return Environment.GetResourceString("IO_UnknownFileName");
                new FileIOPermission(FileIOPermissionAccess.PathDiscovery, new String[] { _fileName }, false, false ).Demand();
                return _fileName;
            }
        }

        internal String NameInternal {
            get {
                if (_fileName == null)
                    return "<UnknownFileName>";
                return _fileName;
            }
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.Position"]/*' />
        public override long Position {
            get { 
                if (_handleProtector.IsClosed) __Error.FileNotOpen();
                if (!CanSeek) __Error.SeekNotSupported();
                BCLDebug.Assert((_readPos==0 && _readLen==0 && _writePos >= 0) || (_writePos==0 && _readPos <= _readLen), "We're either reading or writing, but not both.");

                VerifyOSHandlePosition();

                return _pos + (_readPos - _readLen + _writePos);
            }
            set {
                if (value < 0) throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                if (_writePos > 0) FlushWrite();
                _readPos = 0;
                _readLen = 0;
                Seek(value, SeekOrigin.Begin);
            }
        }


        // When doing IO asynchronously (ie, _isAsync==true), this callback is 
        // called by a free thread in the threadpool when the IO operation 
        // completes.  
        unsafe private static void AsyncFSCallback(uint errorCode, uint numBytes, NativeOverlapped* pOverlapped)
        {
            //Console.WriteLine("AsyncFSCallback called.  errorCode: "+errorCode+"  numBytes: "+numBytes);

            // Unpack overlapped
            Overlapped overlapped = Overlapped.Unpack(pOverlapped);
            // Free the overlapped struct in EndRead/EndWrite.
            
            // Extract async result from overlapped 
            AsyncFileStream_AsyncResult asyncResult = 
                (AsyncFileStream_AsyncResult)overlapped.AsyncResult;
            asyncResult._numBytes = (int)numBytes;
            
            // Handle reading from & writing to closed pipes.  While I'm not sure
            // this is entirely necessary anymore, maybe it's possible for 
            // an async read on a pipe to be issued and then the pipe is closed, 
            // returning this error.  This may very well be necessary.
            if (errorCode == ERROR_BROKEN_PIPE || errorCode == ERROR_NO_DATA)
                errorCode = 0;
            
            asyncResult._errorCode = (int)errorCode;

            //Console.WriteLine("AsyncFSCallback:  errorCode: "+errorCode+"  numBytes: "+numBytes+" was synchronous: "+asyncResult.CompletedSynchronously);

            WaitHandle wh = asyncResult._waitHandle;
            if (wh != null) {
                bool r = SetEvent(wh.Handle);
                BCLDebug.Assert(r, "SetEvent failed!  handle: "+wh.Handle);
                if (!r) __Error.WinIOError();
            }
            // Set IsCompleted to true AFTER we've signalled the WaitHandle!
            // Necessary since we close the WaitHandle after checking IsCompleted,
            // so we could cause the SetEvent call to fail.
            asyncResult._isComplete = true;

            // Call the user-provided callback.  Note that it can and often should
            // call EndRead or EndWrite.  There's no reason to use an async 
            // delegate here - we're already on a threadpool thread.  
            // Note the IAsyncResult's completedSynchronously property must return
            // false here, saying the user callback was called on another thread.
            asyncResult._completedSynchronously = false;
            AsyncCallback userCallback = asyncResult._userCallback;
            if (userCallback!=null)
                userCallback(asyncResult);
        }


        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.Close"]/*' />
        public override void Close()
        {
            Dispose(true);
            GC.nativeSuppressFinalize(this);
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.Dispose"]/*' />
        protected virtual void Dispose(bool disposing)
        {
            // Nothing will be done differently based on whether we are 
            // disposing vs. finalizing.
            if (_handleProtector != null) {
                if (!_handleProtector.IsClosed)
                    Flush();
                _handleProtector.Close();
            }

            _canRead = false;
            _canWrite = false;
            _canSeek = false;
            _buffer = null;
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.Finalize"]/*' />
        ~FileStream()
        {
            if (_handleProtector != null) {
                BCLDebug.Correctness(_handleProtector.IsClosed, "You didn't close a FileStream & it got finalized.  Name: \""+_fileName+"\"");
                Dispose(false);
            }
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.Flush"]/*' />
        public override void Flush()
        {
            if (_handleProtector.IsClosed) __Error.FileNotOpen();
            if (_writePos > 0) {
                FlushWrite();
            }
            else if (_readPos < _readLen && CanSeek) {
                FlushRead();
            }
        }

        // Reading is done by blocks from the file, but someone could read
        // 1 byte from the buffer then write.  At that point, the OS's file
        // pointer is out of sync with the stream's position.  All write 
        // functions should call this function to preserve the position in the file.
        private void FlushRead() {
            BCLDebug.Assert(_writePos == 0, "FileStream: Write buffer must be empty in FlushRead!");
            if (_readPos - _readLen != 0)
                SeekCore(_readPos - _readLen, SeekOrigin.Current);
            _readPos = 0;
            _readLen = 0;
        }

        // Writes are buffered.  Anytime the buffer fills up 
        // (_writePos + delta > _bufferSize) or the buffer switches to reading
        // and there is dirty data (_writePos > 0), this function must be called.
        private void FlushWrite() {
            BCLDebug.Assert(_readPos == 0 && _readLen == 0, "FileStream: Read buffer must be empty in FlushWrite!");
            if (_isAsync) {
                IAsyncResult asyncResult = BeginWriteCore(_buffer, 0, _writePos, null, null);
                EndWrite(asyncResult);
            }
            else
                WriteCore(_buffer, 0, _writePos);
            _writePos = 0;
        }


        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.Handle"]/*' />
        public virtual IntPtr Handle {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get { 
                Flush();
                // Explicitly dump any buffered data, since the user could move our
                // position or write to the file.
                _readPos = 0;
                _readLen = 0;
                _writePos = 0;
                return _handleProtector.Handle;
            }
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.SetLength"]/*' />
        public override void SetLength(long value)
        {
            if (value < 0)
                throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (_handleProtector.IsClosed) __Error.FileNotOpen();
            if (!CanSeek) __Error.SeekNotSupported();
            if (!CanWrite) __Error.WriteNotSupported();
            // Handle buffering updates.
            if (_writePos > 0) {
                FlushWrite();
            }
            else if (_readPos < _readLen) {
                FlushRead();
            }
            if (_appendStart != -1 && value < _appendStart)
                throw new IOException(Environment.GetResourceString("IO.IO_SetLengthAppendTruncate"));
            SetLengthCore(value);
        }

        // We absolutely need this method broken out so that BeginWriteCore can call
        // a method without having to go through buffering code that might call
        // FlushWrite.
        private void SetLengthCore(long value)
        {
            BCLDebug.Assert(value >= 0, "value >= 0");
            long origPos = _pos;

            bool incremented = false;
            try {
                if (_handleProtector.TryAddRef(ref incremented)) {
                    if (_pos != value)
                        SeekCore(value, SeekOrigin.Begin);
                    if (!Win32Native.SetEndOfFile(_handleProtector.Handle)) {
                        int hr = Marshal.GetLastWin32Error();
                        if (hr==__Error.ERROR_INVALID_PARAMETER)
                            throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_FileLengthTooBig"));
                        __Error.WinIOError(hr, String.Empty);
                    }
                    // Return file pointer to where it was before setting length
                    if (origPos != value) {
                        if (origPos < value)
                            SeekCore(origPos, SeekOrigin.Begin);
                        else
                            SeekCore(0, SeekOrigin.End);
                    }
                    VerifyOSHandlePosition();
                }
                else
                    __Error.FileNotOpen();
            }
            finally {
                if (incremented) _handleProtector.Release();
            }
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.Read"]/*' />
         public override int Read([In, Out] byte[] array, int offset, int count) {
            if (array==null)
                throw new ArgumentNullException("array", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (offset < 0)
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (array.Length - offset < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            
            if (_handleProtector.IsClosed) __Error.FileNotOpen();
            
            BCLDebug.Assert((_readPos==0 && _readLen==0 && _writePos >= 0) || (_writePos==0 && _readPos <= _readLen), "We're either reading or writing, but not both.");

            bool isBlocked = false;
            int n = _readLen - _readPos;
            // if the read buffer is empty, read into either user's array or our
            // buffer, depending on number of bytes user asked for and buffer size.
            if (n == 0) {
                if (!CanRead) __Error.ReadNotSupported();
                if (_writePos > 0) FlushWrite();
                if (count >= _bufferSize) {
                    n = ReadCore(array, offset, count);
                    // Throw away read buffer.
                    _readPos = 0;
                    _readLen = 0;
                    return n;
                }
                if (_buffer == null) _buffer = new byte[_bufferSize];
                n = ReadCore(_buffer, 0, _bufferSize);
                if (n == 0) return 0;
                isBlocked = n < _bufferSize;
                _readPos = 0;
                _readLen = n;
            }
            // Now copy min of count or numBytesAvailable (ie, near EOF) to array.
            if (n > count) n = count;
            Buffer.InternalBlockCopy(_buffer, _readPos, array, offset, n);
            _readPos += n;

            // If we hit the end of the buffer and didn't have enough bytes, we must
            // read some more from the underlying stream.  However, if we got
            // fewer bytes from the underlying stream than we asked for (ie, we're 
            // probably blocked), don't ask for more bytes.
            if (n < count && !isBlocked) {
                BCLDebug.Assert(_readPos == _readLen, "Read buffer should be empty!");                
                int moreBytesRead = ReadCore(array, offset + n, count - n);
                n += moreBytesRead;
                // We've just made our buffer inconsistent with our position 
                // pointer.  We must throw away the read buffer.
                _readPos = 0;
                _readLen = 0;
            }

            return n;
        }

        private unsafe int ReadCore(byte[] buffer, int offset, int count) {
            BCLDebug.Assert(!_handleProtector.IsClosed, "_handle != Win32Native.INVALID_HANDLE_VALUE");
            BCLDebug.Assert(CanRead, "CanRead");
            BCLDebug.Assert(_writePos == 0, "_writePos == 0");

            if (_isAsync) {
                IAsyncResult result = BeginReadCore(buffer, offset, count, null, null, 0);
                return EndRead(result);
            }

            int hr = 0;
            int r = ReadFileNative(_handleProtector, buffer, offset, count, null, out hr);
            if (r == -1) {
                // For pipes, ERROR_BROKEN_PIPE is the normal end of the pipe.
                if (hr == ERROR_BROKEN_PIPE) {
                    r = 0;
                }
                else {
                    if (hr == ERROR_INVALID_PARAMETER)
                        throw new ArgumentException(Environment.GetResourceString("Arg_HandleNotSync"));
                    
                    __Error.WinIOError(hr, String.Empty);
                }
            }
            BCLDebug.Assert(r >= 0, "FileStream's ReadCore is likely broken.");
            _pos += r;

            VerifyOSHandlePosition();
            return r;
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.Seek"]/*' />
        public override long Seek(long offset, SeekOrigin origin) {
            if (origin<SeekOrigin.Begin || origin>SeekOrigin.End)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidSeekOrigin"));
            if (_handleProtector.IsClosed) __Error.FileNotOpen();
            if (!CanSeek) __Error.SeekNotSupported();

            BCLDebug.Assert((_readPos==0 && _readLen==0 && _writePos >= 0) || (_writePos==0 && _readPos <= _readLen), "We're either reading or writing, but not both.");

            // If we've got bytes in our buffer to write, write them out.
            // If we've read in and consumed some bytes, we'll have to adjust
            // our seek positions ONLY IF we're seeking relative to the current
            // position in the stream.  This simulates doing a seek to the new
            // position, then a read for the number of bytes we have in our buffer.
            if (_writePos > 0) {
                FlushWrite();
            }
            else if (origin == SeekOrigin.Current) {
                // Don't call FlushRead here, which would have caused an infinite
                // loop.  Simply adjust the seek origin.  This isn't necessary
                // if we're seeking relative to the beginning or end of the stream.
                offset -= (_readLen - _readPos);
            }

            VerifyOSHandlePosition();

            long oldPos = _pos + (_readPos - _readLen);
            long pos = SeekCore(offset, origin);

            // Prevent users from overwriting data in a file that was opened in
            // append mode.
            if (_appendStart != -1 && pos < _appendStart) {
                SeekCore(oldPos, SeekOrigin.Begin);
                throw new IOException(Environment.GetResourceString("IO.IO_SeekAppendOverwrite"));
            }

            // We now must update the read buffer.  We can in some cases simply
            // update _readPos within the buffer, copy around the buffer so our 
            // Position property is still correct, and avoid having to do more 
            // reads from the disk.  Otherwise, discard the buffer's contents.
            if (_readLen > 0) {
                // We can optimize the following condition:
                // oldPos - _readPos <= pos < oldPos + _readLen - _readPos
                if (oldPos == pos) {
                    if (_readPos > 0) {
                        //Console.WriteLine("Seek: seeked for 0, adjusting buffer back by: "+_readPos+"  _readLen: "+_readLen);
                        Buffer.InternalBlockCopy(_buffer, _readPos, _buffer, 0, _readLen - _readPos);
                        _readLen -= _readPos;
                        _readPos = 0;
                    }
                    // If we still have buffered data, we must update the stream's 
                    // position so our Position property is correct.
                    if (_readLen > 0)
                        SeekCore(_readLen, SeekOrigin.Current);
                }
                else if (oldPos - _readPos < pos && pos < oldPos + _readLen - _readPos) {
                    int diff = (int)(pos - oldPos);
                    //Console.WriteLine("Seek: diff was "+diff+", readpos was "+_readPos+"  adjusting buffer - shrinking by "+ (_readPos + diff));
                    Buffer.InternalBlockCopy(_buffer, _readPos+diff, _buffer, 0, _readLen - (_readPos + diff));
                    _readLen -= (_readPos + diff);
                    _readPos = 0;
                    if (_readLen > 0)
                        SeekCore(_readLen, SeekOrigin.Current);
                }
                else {
                    // Lose the read buffer.
                    _readPos = 0;
                    _readLen = 0;
                }
                BCLDebug.Assert(_readLen >= 0 && _readPos <= _readLen, "_readLen should be nonnegative, and _readPos should be less than or equal _readLen");
                BCLDebug.Assert(pos == Position, "Seek optimization: pos != Position!  Buffer math was mangled.");
            }
            return pos;
        }

        // This doesn't do argument checking.  Necessary for SetLength, which must
        // set the file pointer beyond the end of the file.
        private long SeekCore(long offset, SeekOrigin origin) {
            BCLDebug.Assert(!_handleProtector.IsClosed && CanSeek, "_handle != Win32Native.INVALID_HANDLE_VALUE && CanSeek");
            BCLDebug.Assert(origin>=SeekOrigin.Begin && origin<=SeekOrigin.End, "origin>=SeekOrigin.Begin && origin<=SeekOrigin.End");
            int hr = 0;
            long ret = 0;
            
            bool incremented = false;
            try {
                if (_handleProtector.TryAddRef(ref incremented)) {
                    ret = Win32Native.SetFilePointer(_handleProtector.Handle, offset, origin, out hr);
                }
                else
                    __Error.FileNotOpen();
            }
            finally {
                if (incremented) _handleProtector.Release();
            }

            if (ret == -1) __Error.WinIOError(hr, String.Empty);
            _pos = ret;
            return ret;
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.Write"]/*' />
        public override void Write(byte[] array, int offset, int count) {
            if (array==null)
                throw new ArgumentNullException("array", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (offset < 0)
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (array.Length - offset < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            if (_handleProtector.IsClosed) __Error.FileNotOpen();
            if (_writePos==0) {
                // Ensure we can write to the stream, and ready buffer for writing.
                if (!CanWrite) __Error.WriteNotSupported();
                if (_readPos < _readLen) FlushRead();
                _readPos = 0;
                _readLen = 0;
            }

            // If our buffer has data in it, copy data from the user's array into
            // the buffer, and if we can fit it all there, return.  Otherwise, write
            // the buffer to disk and copy any remaining data into our buffer.
            // The assumption here is memcpy is cheaper than disk (or net) IO.
            // (10 milliseconds to disk vs. ~20-30 microseconds for a 4K memcpy)
            // So the extra copying will reduce the total number of writes, in 
            // non-pathological cases (ie, write 1 byte, then write for the buffer 
            // size repeatedly)
            if (_writePos > 0) {
                int numBytes = _bufferSize - _writePos;   // space left in buffer
                if (numBytes > 0) {
                    if (numBytes > count)
                        numBytes = count;
                    Buffer.InternalBlockCopy(array, offset, _buffer, _writePos, numBytes);
                    _writePos += numBytes;
                    if (count==numBytes) return;
                    offset += numBytes;
                    count -= numBytes;
                }
                // Reset our buffer.  We essentially want to call FlushWrite
                // without calling Flush on the underlying Stream.
                if (_isAsync) {
                    IAsyncResult result = BeginWriteCore(_buffer, 0, _writePos, null, null);
                    EndWrite(result);
                }
                else {
                    WriteCore(_buffer, 0, _writePos);
                }
                _writePos = 0;
            }
            // If the buffer would slow writes down, avoid buffer completely.
            if (count >= _bufferSize) {
                BCLDebug.Assert(_writePos == 0, "FileStream cannot have buffered data to write here!  Your stream will be corrupted.");
                WriteCore(array, offset, count);
                return;
            }
            else if (count == 0)
                return;  // Don't allocate a buffer then call memcpy for 0 bytes.
            if (_buffer==null) _buffer = new byte[_bufferSize];
            // Copy remaining bytes into buffer, to write at a later date.
            Buffer.InternalBlockCopy(array, offset, _buffer, _writePos, count);
            _writePos = count;
            return;
        }

        private unsafe void WriteCore(byte[] buffer, int offset, int count) {
            BCLDebug.Assert(!_handleProtector.IsClosed, "_handle != Win32Native.INVALID_HANDLE_VALUE");
            BCLDebug.Assert(CanWrite, "CanWrite");
            BCLDebug.Assert(_readPos == _readLen, "_readPos == _readLen");

            if (_isAsync) {
                IAsyncResult result = BeginWriteCore(buffer, offset, count, null, null);
                EndWrite(result);
                return;
            }

            int hr = 0;
            int r = WriteFileNative(_handleProtector, buffer, offset, count, null, out hr);
            if (r == -1) {
                // For pipes, ERROR_NO_DATA is not an error, but the pipe is closing.
                if (hr == ERROR_NO_DATA) {
                    r = 0;
                }
                else {
                    // Note that ERROR_INVALID_PARAMETER may be returned for writes
                    // where the position is too large (ie, writing at Int64.MaxValue 
                    // on Win9x) OR for synchronous writes to a handle opened 
                    // asynchronously.
                    if (hr == ERROR_INVALID_PARAMETER)
                        throw new IOException(Environment.GetResourceString("IO.IO_FileTooLongOrHandleNotSync"));
                    __Error.WinIOError(hr, String.Empty);
                }
            }
            BCLDebug.Assert(r >= 0, "FileStream's WriteCore is likely broken.");
            _pos += r;
            return;
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.BeginRead"]/*' />
        public override IAsyncResult BeginRead(byte[] array, int offset, int numBytes, AsyncCallback userCallback, Object stateObject)
        {
            if (array==null)
                throw new ArgumentNullException("array");
            if (offset < 0)
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (numBytes < 0)
                throw new ArgumentOutOfRangeException("numBytes", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (array.Length - offset < numBytes)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            if (_handleProtector.IsClosed) __Error.FileNotOpen();

            if (!_isAsync)
                return base.BeginRead(array, offset, numBytes, userCallback, stateObject);

            if (!CanRead) __Error.ReadNotSupported();

            BCLDebug.Assert((_readPos==0 && _readLen==0 && _writePos >= 0) || (_writePos==0 && _readPos <= _readLen), "We're either reading or writing, but not both.");

            if (_isPipe) {
                // Pipes are screwed up, at least when you have 2 different pipes
                // that you want to use simultaneously.  When redirecting stdout
                // & stderr with the Process class, it's easy to deadlock your
                // parent & child processes when doing writes 4K at a time.  The
                // OS appears to use a 4K buffer internally.  If you write to a
                // pipe that is full, you will block until someone read from 
                // that pipe.  If you try reading from an empty pipe and 
                // FileStream's BeginRead blocks waiting for data to fill it's 
                // internal buffer, you will be blocked.  In a case where a child
                // process writes to stdout & stderr while a parent process tries
                // reading from both, you can easily get into a deadlock here.
                // To avoid this deadlock, don't buffer when doing async IO on
                // pipes.  AS/URT Bug 100119.  -- Brian Grunkemeyer, 8/16/2001
                BCLDebug.Assert(_readPos == _readLen, "FileStream must not have buffered data here.  We'll unfortunately give you back corrupted bytes.");
                BCLDebug.Assert(_writePos == 0, "FileStream must not have buffered write data here!  Pipes should be unidirectional.");
                return BeginReadCore(array, offset, numBytes, userCallback, stateObject, 0);
            }

            // Handle buffering.
            if (_writePos > 0) FlushWrite();
            AsyncFileStream_AsyncResult asyncResult;
            if (_readPos == _readLen) {
                // I can't see how to handle buffering of async requests when 
                // filling the buffer asynchronously, without a lot of complexity.
                // The problems I see are issuing an async read, we do an async 
                // read to fill the buffer, then someone issues another read 
                // (either synchronously or asynchronously) before the first one 
                // returns.  This would involve some sort of complex buffer locking
                // that we probably don't want to get into, at least not in V1.
                // If we did a sync read to fill the buffer, we could avoid the
                // problem, and any async read less than 64K gets turned into a
                // synchronous read by NT anyways...       -- Brian, 1/22/2001.

                if (numBytes < _bufferSize) {
                    if (_buffer == null) _buffer = new byte[_bufferSize];
                    IAsyncResult bufferRead = BeginReadCore(_buffer, 0, _bufferSize, null, null, 0);
                    _readLen = EndRead(bufferRead);
                    int n = _readLen;
                    if (n > numBytes) n = numBytes;
                    Buffer.InternalBlockCopy(_buffer, 0, array, offset, n);
                    _readPos = n;
                    asyncResult = AsyncFileStream_AsyncResult.CreateBufferedReadResult(n, userCallback, stateObject);
                    asyncResult.CallUserCallback();
                    return asyncResult;
                }

                // Here we're making our position pointer inconsistent
                // with our read buffer.  Throw away the read buffer's contents.
                _readPos = 0;
                _readLen = 0;
                return BeginReadCore(array, offset, numBytes, userCallback, stateObject, 0);
            }
            else {
                int n = _readLen - _readPos;
                if (n > numBytes) n = numBytes;
                Buffer.InternalBlockCopy(_buffer, _readPos, array, offset, n);
                _readPos += n;
                if (n >= numBytes) {
                    asyncResult = AsyncFileStream_AsyncResult.CreateBufferedReadResult(n, userCallback, stateObject);
                    asyncResult.CallUserCallback();
                    return asyncResult;
                }
                // Throw away read buffer.
                _readPos = 0;
                _readLen = 0;
                asyncResult = BeginReadCore(array, offset + n, numBytes - n, userCallback, stateObject, n);
                // WARNING: all state on asyncResult objects must be set before
                // we call ReadFile in BeginReadCore, since the OS can run our
                // callback & the user's callback before ReadFile returns.
            }
            return asyncResult;
        }

        unsafe private AsyncFileStream_AsyncResult BeginReadCore(byte[] array, int offset, int numBytes, AsyncCallback userCallback, Object stateObject, int numBufferedBytesRead)
        {
            BCLDebug.Assert(!_handleProtector.IsClosed, "_handle != Win32Native.INVALID_HANDLE_VALUE");
            BCLDebug.Assert(CanRead, "CanRead");
            BCLDebug.Assert(_writePos == 0, "_writePos == 0");
            BCLDebug.Assert(_isAsync, "BeginReadCore doesn't work on synchronous file streams!");

            // Create and store async stream class library specific data in the 
            // async result
            AsyncFileStream_AsyncResult asyncResult = new AsyncFileStream_AsyncResult();
            asyncResult._userCallback = userCallback;
            asyncResult._userStateObject = stateObject;
            asyncResult._isWrite = false;

            // Must set this here to ensure all the state on the IAsyncResult 
            // object is set before we call ReadFile, which gives the OS an
            // opportunity to run our callback (including the user callback &
            // the call to EndRead) before ReadFile has returned.  See AS/URT 
            // bug 111632 for details.  -- Brian Grunkemeyer, 11/2/2001
            asyncResult._numBufferedBytes = numBufferedBytesRead;

            // For Synchronous IO, I could go with either a callback and using
            // the managed Monitor class, or I could create a handle and wait on it.
            ManualResetEvent waitHandle = new ManualResetEvent(false);
            asyncResult._waitHandle = waitHandle;

            // Create a managed overlapped class
            // We will set the file offsets later
            Overlapped overlapped = new Overlapped(0, 0, 0, asyncResult);

            // Pack the Overlapped class, and store it in the async result
            NativeOverlapped* intOverlapped = overlapped.Pack(IOCallback);
            asyncResult._overlapped = intOverlapped;

            // Calculate position in the file we should be at after the read is done
            if (CanSeek) {
                long len = Length;
                VerifyOSHandlePosition();
                if (_pos + numBytes > len) {
                    if (_pos <= len)
                        numBytes = (int) (len - _pos);
                    else
                        numBytes = 0;
                }

                // Now set the position to read from in the NativeOverlapped struct
                // Note for pipes, we should leave the offset fields set to 0.
                intOverlapped->OffsetLow = (int)_pos;
                intOverlapped->OffsetHigh = (int)(_pos>>32);
                _pos += numBytes;

                // Note: When using overlapped IO, the OS is not supposed to 
                // touch the file pointer location at all.  We will adjust it 
                // ourselves. Note that this isn't threadsafe.

                // WriteFile should not update the file pointer when writing
                // in overlapped mode, according to MSDN.  But it does update 
                // the file pointer when writing to a UNC path!  I filed this 
                // as Bug 119490 in the Windows Bugs database, and as a 
                // workaround, changed the code below to seek to an absolute 
                // location, not a relative one.  ReadFile seems consistent though.
                SeekCore(numBytes, SeekOrigin.Current);
            }

            // Keep the array in one location in memory until the OS writes the
            // relevant data into the array.  Free GCHandle later.
            asyncResult.PinBuffer(array);

            //Console.WriteLine("BeginRead finishing.  pos: "+pos+"  numBytes: "+numBytes+"  _pos: "+_pos+"  Position: "+Position);

            // queue an async ReadFile operation and pass in a packed overlapped
            //int r = ReadFile(_handle, array, numBytes, null, intOverlapped);
            int hr = 0;
            int r = ReadFileNative(_handleProtector, array, offset, numBytes, intOverlapped, out hr);
            // ReadFile, the OS version, will return 0 on failure.  But
            // my ReadFileNative wrapper returns -1.  My wrapper will return
            // the following:
            // On error, r==-1.
            // On async requests that are still pending, r==-1 w/ hr==ERROR_IO_PENDING
            // on async requests that completed sequentially, r==0
            // Note that you will NEVER RELIABLY be able to get the number of bytes
            // read back from this call when using overlapped structures!  You must
            // not pass in a non-null lpNumBytesRead to ReadFile when using 
            // overlapped structures!  This is NT bug 105512, which they've resolved
            // by design, saying I have a good enough workaround.
            if (r==-1 && numBytes!=-1) {
                //Console.WriteLine("ReadFile returned 0;  Read will complete asynchronously (if HR==3e5)  hr: 0x{0:x}", hr);
                
                // For pipes, when they hit EOF, they will come here.
                if (hr == ERROR_BROKEN_PIPE) {
                    // Not an error, but EOF.  Note AsyncFSCallback will NOT be called.
                    // Either cruft up a fake IAsyncResult (& clean up our original one)
                    // or mark the current one done so that EndRead doesn't block.
                    SetEvent(asyncResult._waitHandle.Handle);
                    asyncResult._isComplete = true;
                    asyncResult.CallUserCallback();                 
                    // EndRead will free the Overlapped struct correctly.
                }
                else if (hr != ERROR_IO_PENDING) {
                    if (!_handleProtector.IsClosed && CanSeek)  // Update Position - It could be anywhere.
                        SeekCore(0, SeekOrigin.Current);

                    if (hr == ERROR_HANDLE_EOF)
                        __Error.EndOfFile();
                    else
                        __Error.WinIOError(hr, String.Empty);
                }
            }
            else {
                // Due to a workaround for a race condition in NT's ReadFile & 
                // WriteFile routines (Bug 105512 in the Windows Bugs RAID db), 
                // we will always be returning 0 from ReadFileNative
                // when we do async IO instead of the number of bytes read, 
                // irregardless of whether the operation completed 
                // synchronously or asynchronously.  We absolutely must not
                // set asyncResult._numBytes here, since will never have correct
                // results.  
                //Console.WriteLine("ReadFile returned: "+r+" (0x"+Int32.Format(r, "x")+")  The IO completed synchronously, but the user callback was called on a separate thread");
            }

            return asyncResult;
        }


        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.EndRead"]/*' />
        public unsafe override int EndRead(IAsyncResult asyncResult)
        {
            // Note there are 3 significantly different IAsyncResults we'll accept
            // here.  One is from Stream::BeginRead.  The other two are variations
            // on our AsyncFileStream_AsyncResult.  One is from BeginReadCore,
            // while the other is from the BeginRead buffering wrapper.
            if (asyncResult==null)
                throw new ArgumentNullException("asyncResult");

            if (!_isAsync)
                return base.EndRead(asyncResult);

            AsyncFileStream_AsyncResult afsar = asyncResult as AsyncFileStream_AsyncResult;
            if (afsar==null || afsar._isWrite)
                __Error.WrongAsyncResult();

            // Ensure we can't get into any races by doing an interlocked
            // CompareExchange here.  Avoids corrupting memory via freeing the
            // NativeOverlapped class or GCHandle twice.  -- BrianGru, 4/1/2002
            if (1 == Interlocked.CompareExchange(ref afsar._EndXxxCalled, 1, 0))
                __Error.EndReadCalledTwice();

            WaitHandle wh = afsar.AsyncWaitHandle;
            if (wh != null) {
                if (!afsar.IsCompleted) {
                    wh.WaitOne();
                    // There's a subtle race condition here.  In AsyncFSCallback,
                    // I must signal the WaitHandle then set _isComplete to be true,
                    // to avoid closing the WaitHandle before AsyncFSCallback has
                    // signalled it.  But with that behavior and the optimization
                    // to call WaitOne only when IsCompleted is false, it's possible
                    // to return from this method before IsCompleted is set to true.
                    // This is currently completely harmless, so the most efficient
                    // solution of just setting the field seems like the right thing
                    // to do.     -- BrianGru, 6/19/2000
                    afsar._isComplete = true;
                }
                wh.Close();
            }

            // Free memory & GC handles.
            NativeOverlapped* overlappedPtr = afsar._overlapped;
            if (overlappedPtr != null)
                Overlapped.Free(overlappedPtr);
            afsar.UnpinBuffer();

            // Now check for any error during the read.
            if (afsar._errorCode != 0)
                __Error.WinIOError(afsar._errorCode, Path.GetFileName(_fileName));

            return afsar._numBytes + afsar._numBufferedBytes;
        }


        // Reads a byte from the file stream.  Returns the byte cast to an int
        // or -1 if reading from the end of the stream.
        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.ReadByte"]/*' />
        public override int ReadByte() {
            if (_handleProtector.IsClosed) __Error.FileNotOpen();
            if (_readLen==0 && !CanRead) __Error.ReadNotSupported();
            BCLDebug.Assert((_readPos==0 && _readLen==0 && _writePos >= 0) || (_writePos==0 && _readPos <= _readLen), "We're either reading or writing, but not both.");
            if (_readPos == _readLen) {
                if (_writePos > 0) FlushWrite();
                BCLDebug.Assert(_bufferSize > 0, "_bufferSize > 0");
                if (_buffer == null) _buffer = new byte[_bufferSize];
                _readLen = ReadCore(_buffer, 0, _bufferSize);
                _readPos = 0;
            }
            if (_readPos == _readLen)
                return -1;

            return _buffer[_readPos++];
        }


        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.BeginWrite"]/*' />
        public override IAsyncResult BeginWrite(byte[] array, int offset, int numBytes, AsyncCallback userCallback, Object stateObject)
        {
            if (array==null)
                throw new ArgumentNullException("array");
            if (offset < 0)
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (numBytes < 0)
                throw new ArgumentOutOfRangeException("numBytes", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (array.Length - offset < numBytes)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            if (_handleProtector.IsClosed) __Error.FileNotOpen();

            if (!_isAsync)
                return base.BeginWrite(array, offset, numBytes, userCallback, stateObject);

            if (!CanWrite) __Error.WriteNotSupported();

            BCLDebug.Assert((_readPos==0 && _readLen==0 && _writePos >= 0) || (_writePos==0 && _readPos <= _readLen), "We're either reading or writing, but not both.");

            if (_isPipe) {
                // Pipes are screwed up, at least when you have 2 different pipes
                // that you want to use simultaneously.  When redirecting stdout
                // & stderr with the Process class, it's easy to deadlock your
                // parent & child processes when doing writes 4K at a time.  The
                // OS appears to use a 4K buffer internally.  If you write to a
                // pipe that is full, you will block until someone read from 
                // that pipe.  If you try reading from an empty pipe and 
                // FileStream's BeginRead blocks waiting for data to fill it's 
                // internal buffer, you will be blocked.  In a case where a child
                // process writes to stdout & stderr while a parent process tries
                // reading from both, you can easily get into a deadlock here.
                // To avoid this deadlock, don't buffer when doing async IO on
                // pipes.  AS/URT Bug 100119.  -- Brian Grunkemeyer, 8/16/2001
                BCLDebug.Assert(_readPos == 0 && _readLen == 0, "FileStream must not have buffered data here!  Pipes should be unidirectional.");
                if (_writePos > 0)
                    FlushWrite();
                return BeginWriteCore(array, offset, numBytes, userCallback, stateObject);
            }

            // Handle buffering.
            AsyncFileStream_AsyncResult asyncResult;
            if (_writePos==0) {
                if (_readPos < _readLen) FlushRead();
                _readPos = 0;
                _readLen = 0;
            }
            int n = _bufferSize - _writePos;
            if (numBytes <= n) {
                if (_writePos==0) _buffer = new byte[_bufferSize];
                Buffer.InternalBlockCopy(array, offset, _buffer, _writePos, numBytes);
                _writePos += numBytes;
                asyncResult = new AsyncFileStream_AsyncResult();
                asyncResult._userCallback = userCallback;
                asyncResult._userStateObject = stateObject;
                asyncResult._waitHandle = null;
                asyncResult._isComplete = true;
                asyncResult._isWrite = true;
                asyncResult._numBufferedBytes = numBytes;
                asyncResult.CallUserCallback();
                return asyncResult;
            }
            if (_writePos > 0) FlushWrite();
            return BeginWriteCore(array, offset, numBytes, userCallback, stateObject);
        }

        unsafe private AsyncFileStream_AsyncResult BeginWriteCore(byte[] array, int offset, int numBytes, AsyncCallback userCallback, Object stateObject) 
        {
            BCLDebug.Assert(!_handleProtector.IsClosed, "!_handleProtector.IsClosed");
            BCLDebug.Assert(CanWrite, "CanWrite");
            BCLDebug.Assert(_readPos == _readLen, "_readPos == _readLen");
            BCLDebug.Assert(_isAsync, "BeginWriteCore doesn't work on synchronous file streams!");

            // Create and store async stream class library specific data in the 
            // async result
            AsyncFileStream_AsyncResult asyncResult = new AsyncFileStream_AsyncResult();
            asyncResult._userCallback = userCallback;
            asyncResult._userStateObject = stateObject;
            asyncResult._isWrite = true;

            // For Synchronous IO, I could go with either a callback and using
            // the managed Monitor class, or I could create a handle and wait on it.
            ManualResetEvent waitHandle = new ManualResetEvent(false); 
            asyncResult._waitHandle = waitHandle;

            // Create a managed overlapped class
            // We will set the file offsets later
            Overlapped overlapped = new Overlapped(0, 0, 0, asyncResult);

            // Pack the Overlapped class, and store it in the async result
            NativeOverlapped* intOverlapped = overlapped.Pack(IOCallback);
            asyncResult._overlapped = intOverlapped;
            
            if (CanSeek) {
                // Make sure we set the length of the file appropriately.
                long len = Length;
                //Console.WriteLine("BeginWrite - Calculating end pos.  pos: "+pos+"  len: "+len+"  numBytes: "+numBytes);
                VerifyOSHandlePosition();
                if (_pos + numBytes > len) {
                    //Console.WriteLine("BeginWrite - Setting length to: "+(pos + numBytes));
                    SetLengthCore(_pos + numBytes);
                }

                // Now set the position to read from in the NativeOverlapped struct
                // Note for pipes, we should leave the offset fields set to 0.
                intOverlapped->OffsetLow = (int)_pos;
                intOverlapped->OffsetHigh = (int)(_pos>>32);
                _pos += numBytes;
                
                // Note: When using overlapped IO, the OS is not supposed to 
                // touch the file pointer location at all.  We will adjust it 
                // ourselves.  Note that this isn't threadsafe.

                // WriteFile should not update the file pointer when writing
                // in overlapped mode, according to MSDN.  But it does update 
                // the file pointer when writing to a UNC path!  I filed this 
                // as Bug 119490 in the Windows Bugs database, and as a 
                // workaround, changed the code below to seek to an absolute 
                // location, not a relative one.  ReadFile seems consistent though.
                //SeekCore(pos + numBytes, SeekOrigin.Begin);
                SeekCore(numBytes, SeekOrigin.Current);
            }

            // Keep the array in one location in memory until the OS reads the
            // relevant data from the array.  Free GCHandle later.
            asyncResult.PinBuffer(array);

            //Console.WriteLine("BeginWrite finishing.  pos: "+pos+"  numBytes: "+numBytes+"  _pos: "+_pos+"  Position: "+Position);

            int hr = 0;
            // queue an async WriteFile operation and pass in a packed overlapped
            int r = WriteFileNative(_handleProtector, array, offset, numBytes, intOverlapped, out hr);

            // WriteFile, the OS version, will return 0 on failure.  But
            // my WriteFileNative wrapper returns -1.  My wrapper will return
            // the following:
            // On error, r==-1.
            // On async requests that are still pending, r==-1 w/ hr==ERROR_IO_PENDING
            // On async requests that completed sequentially, r==0
            // Note that you will NEVER RELIABLY be able to get the number of bytes
            // written back from this call when using overlapped IO!  You must
            // not pass in a non-null lpNumBytesWritten to WriteFile when using 
            // overlapped structures!  This is NT bug 105512, which they've resolved
            // by design, saying I have a good enough workaround.
            if (r==-1 && numBytes!=-1) {
                //Console.WriteLine("WriteFile returned 0;  Write will complete asynchronously (if hr==3e5)  hr: 0x{0:x}", hr);
                
                // For pipes, when they are closed on the other side, they will come here.
                if (hr == ERROR_NO_DATA) {
                    // Not an error, but EOF.  Note AsyncFSCallback will NOT be called.
                    // Either cruft up a fake IAsyncResult (& clean up our original one)
                    // or mark the current one done so that EndWrite doesn't block.
                    SetEvent(asyncResult._waitHandle.Handle);
                    asyncResult._isComplete = true;
                    asyncResult.CallUserCallback();
                    // EndWrite will free the Overlapped struct correctly.
                }
                else if (hr != ERROR_IO_PENDING) {
                    if (!_handleProtector.IsClosed && CanSeek)  // Update Position - It could be anywhere.
                        SeekCore(0, SeekOrigin.Current);

                    if (hr == ERROR_HANDLE_EOF)
                        __Error.EndOfFile();
                    else
                        __Error.WinIOError(hr, String.Empty);
                }
            }
            else {
                // Due to a workaround for a race condition in NT's ReadFile & 
                // WriteFile routines (Bug 105512 in the Windows Bugs RAID db), 
                // we will always be returning 0 from WriteFileNative
                // when we do async IO instead of the number of bytes written, 
                // irregardless of whether the operation completed 
                // synchronously or asynchronously.  We absolutely must not
                // set asyncResult._numBytes here, since will never have correct
                // results.  
                //Console.WriteLine("WriteFile returned: "+r+" (0x"+Int32.Format(r, "x")+")  The IO completed synchronously, but the user callback was called on another thread.");
            }
            
            return asyncResult;
        }


        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.EndWrite"]/*' />
        public unsafe override void EndWrite(IAsyncResult asyncResult)
        {
            if (asyncResult==null)
                throw new ArgumentNullException("asyncResult");

            if (!_isAsync) {
                base.EndWrite(asyncResult);
                return;
            }

            AsyncFileStream_AsyncResult afsar = asyncResult as AsyncFileStream_AsyncResult;
            if (afsar==null || !afsar._isWrite)
                __Error.WrongAsyncResult();

            // Ensure we can't get into any races by doing an interlocked
            // CompareExchange here.  Avoids corrupting memory via freeing the
            // NativeOverlapped class or GCHandle twice.  -- BrianGru, 4/1/2002
            if (1 == Interlocked.CompareExchange(ref afsar._EndXxxCalled, 1, 0))
                __Error.EndWriteCalledTwice();

            WaitHandle wh = afsar.AsyncWaitHandle;
            if (wh != null) {
                if (!afsar.IsCompleted) {
                    wh.WaitOne();
                    // There's a subtle race condition here.  In AsyncFSCallback,
                    // I must signal the WaitHandle then set _isComplete to be true,
                    // to avoid closing the WaitHandle before AsyncFSCallback has
                    // signalled it.  But with that behavior and the optimization
                    // to call WaitOne only when IsCompleted is false, it's possible
                    // to return from this method before IsCompleted is set to true.
                    // This is currently completely harmless, so the most efficient
                    // solution of just setting the field seems like the right thing
                    // to do.     -- BrianGru, 6/19/2000
                    afsar._isComplete = true;
                }
                wh.Close();
            }

            // Free memory & GC handles.
            NativeOverlapped* overlappedPtr = afsar._overlapped;
            if (overlappedPtr != null)
                Overlapped.Free(overlappedPtr);
            afsar.UnpinBuffer();

            // Now check for any error during the write.
            if (afsar._errorCode != 0)
                __Error.WinIOError(afsar._errorCode, Path.GetFileName(_fileName));

            // Number of bytes written is afsar._numBytes + afsar._numBufferedBytes.
            return;
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.WriteByte"]/*' />
        public override void WriteByte(byte value)
        {
            if (_handleProtector.IsClosed) __Error.FileNotOpen();
            if (_writePos==0) {
                if (!CanWrite) __Error.WriteNotSupported();
                if (_readPos < _readLen) FlushRead();
                _readPos = 0;
                _readLen = 0;
                BCLDebug.Assert(_bufferSize > 0, "_bufferSize > 0");
                if (_buffer==null) _buffer = new byte[_bufferSize];
            }
            if (_writePos == _bufferSize)
                FlushWrite();

            _buffer[_writePos++] = value;
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.Lock"]/*' />
        public virtual void Lock(long position, long length) {
            if (position < 0 || length < 0)
                throw new ArgumentOutOfRangeException((position < 0 ? "position" : "length"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));

            bool incremented = false;
            try {
                if (_handleProtector.TryAddRef(ref incremented)) {
                    if (!Win32Native.LockFile(_handleProtector.Handle, position, length))
                        __Error.WinIOError();
                }
                else
                    __Error.FileNotOpen();
            }
            finally {
                if (incremented) _handleProtector.Release();
            }
        }

        /// <include file='doc\FileStream.uex' path='docs/doc[@for="FileStream.Unlock"]/*' />
        public virtual void Unlock(long position, long length) {
            if (position < 0 || length < 0)
                throw new ArgumentOutOfRangeException((position < 0 ? "position" : "length"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));

            bool incremented = false;
            try {
                if (_handleProtector.TryAddRef(ref incremented)) {
                    if (!Win32Native.UnlockFile(_handleProtector.Handle, position, length))
                        __Error.WinIOError();
                }
                else
                    __Error.FileNotOpen();
            }
            finally {
                if (incremented) _handleProtector.Release();
            }
        }

        // Checks the position of the OS's handle equals what we expect it to.
        private void VerifyOSHandlePosition()
        {
            if (!CanSeek)
                return;

            // This will fail if someone else moved the FileStream's handle or if
            // we've hit a bug in FileStream's position updating code.

            // Calling SeekCore(...) changes _pos, making it very difficult for 
            // debugging.
            long posVariable = _pos;
            long curPos = SeekCore(0, SeekOrigin.Current);
            if (curPos != posVariable) {
                // Just do the right thing.
                _readPos = 0;
                _readLen = 0;
            }
        }

        // Windows API definitions, from winbase.h and others
        
        private const int FILE_ATTRIBUTE_NORMAL = 0x00000080;
        private const int FILE_FLAG_OVERLAPPED = 0x40000000;
        
        private const int GENERIC_READ = unchecked((int)0x80000000);
        private const int GENERIC_WRITE = 0x40000000;
    
        private const int FILE_BEGIN = 0;
        private const int FILE_CURRENT = 1;
        private const int FILE_END = 2;

        // Error codes (not HRESULTS), from winerror.h
        private const int ERROR_BROKEN_PIPE = 109;
        private const int ERROR_NO_DATA = 232;
        private const int ERROR_HANDLE_EOF = 38;
        private const int ERROR_INVALID_PARAMETER = 87;
        private const int ERROR_IO_PENDING = 997;


        // As of 8/28/2000, I can't measure a significant perf difference between
        // an HCALL method (that builds a frame, creates a pinning handle, toggles
        // the GC mode then calls ReadFile or WriteFile) vs. an implementation that
        // uses C#'s fixed syntax on a single-threaded test.  Chris thinks writing
        // this in C# should have been faster (with P/Invoke inlining) and it's 
        // more consistent with our long-term goals of moving large portions of 
        // the EE into managed.  Also, this may perhaps scale better on dual-proc 
        // multithreaded tests, since we don't have to toggle the GC mode.
        // Note __ConsoleStream also uses this code.   -- Brian Grunkemeyer
        internal unsafe int ReadFileNative(__HandleProtector hp, byte[] bytes, int offset, int count, NativeOverlapped* overlapped, out int hr)
        {
            BCLDebug.Assert(offset >= 0, "offset >= 0");
            BCLDebug.Assert(count >= 0, "count >= 0");
            BCLDebug.Assert(bytes != null, "bytes != null");

            // Don't corrupt memory when multiple threads are erroneously writing
            // to this stream simultaneously.
            if (bytes.Length - offset < count)
                throw new IndexOutOfRangeException(Environment.GetResourceString("IndexOutOfRange_IORaceCondition"));

            // You can't use the fixed statement on an array of length 0.
            if (bytes.Length==0) {
                hr = 0;
                return 0;
            }

            int r = 0;
            int numBytesRead = 0;

            bool incremented = false;
            try {
                if (hp.TryAddRef(ref incremented)) {
                    fixed(byte* p = bytes) {
                        if (_isAsync)
                            r = ReadFile(hp.Handle, p + offset, count, IntPtr.Zero, overlapped);
                        else
                            r = ReadFile(hp.Handle, p + offset, count, out numBytesRead, overlapped);
                    }
                }
                else
                    hr = Win32Native.ERROR_INVALID_HANDLE;  // Handle was closed.
            }
            finally {
                if (incremented) hp.Release();
            }

            if (r==0) {
                hr = Marshal.GetLastWin32Error();
                // Note: we should never silently swallow an error here without some
                // extra work.  We must make sure that BeginReadCore won't return an 
                // IAsyncResult that will cause EndRead to block, since the OS won't
                // call AsyncFSCallback for us.  -- Brian Grunkemeyer
                if (hr == ERROR_BROKEN_PIPE) {
                    // This handle was a pipe, and it's done. Not an error, but EOF.
                    // However, note that the OS will not call AsyncFSCallback!
                    // Let the caller handle this, since BeginReadCore & ReadCore 
                    // need to do different things.
                    return -1;
                }

                // For invalid handles, detect the error and mark our handle
                // as closed to give slightly better error messages.  Also
                // help ensure we avoid handle recycling bugs.
                if (hr == Win32Native.ERROR_INVALID_HANDLE)
                    _handleProtector.ForciblyMarkAsClosed();

                return -1;
            }
            else
                hr = 0;
            return numBytesRead;
        }

        [DllImport(Microsoft.Win32.Win32Native.KERNEL32, SetLastError=true), SuppressUnmanagedCodeSecurityAttribute]
        unsafe private static extern int ReadFile(IntPtr handle, byte* bytes, int numBytesToRead, out int numBytesRead, NativeOverlapped* overlapped);

        [DllImport(Microsoft.Win32.Win32Native.KERNEL32, SetLastError=true), SuppressUnmanagedCodeSecurityAttribute]
        unsafe private static extern int ReadFile(IntPtr handle, byte* bytes, int numBytesToRead, IntPtr numBytesRead, NativeOverlapped* overlapped);
        
        internal unsafe int WriteFileNative(__HandleProtector hp, byte[] bytes, int offset, int count, NativeOverlapped* overlapped, out int hr) {
            BCLDebug.Assert(offset >= 0, "offset >= 0");
            BCLDebug.Assert(count >= 0, "count >= 0");
            BCLDebug.Assert(bytes != null, "bytes != null");

            // Don't corrupt memory when multiple threads are erroneously writing
            // to this stream simultaneously.  (Note that the OS is reading from
            // the array we pass to WriteFile, but if we read beyond the end and
            // that memory isn't allocated, we could get an AV.)
            if (bytes.Length - offset < count)
                throw new IndexOutOfRangeException(Environment.GetResourceString("IndexOutOfRange_IORaceCondition"));

            // You can't use the fixed statement on an array of length 0.
            if (bytes.Length==0) {
                hr = 0;
                return 0;
            }

            int numBytesWritten = 0;
            int r = 0;
            
            bool incremented = false;
            try {
                if (hp.TryAddRef(ref incremented)) {
                    fixed(byte* p = bytes) {
                        
                        if (_isAsync)
                            r = WriteFile(hp.Handle, p + offset, count, IntPtr.Zero, overlapped);
                        else
                            r = WriteFile(hp.Handle, p + offset, count, out numBytesWritten, overlapped);
                    }
                }
                else
                    hr = Win32Native.ERROR_INVALID_HANDLE;  // Handle was closed.
            }
            finally {
                if (incremented) hp.Release();
            }

            if (r==0) {
                hr = Marshal.GetLastWin32Error();
                // Note: we should never silently swallow an error here without some
                // extra work.  We must make sure that BeginWriteCore won't return an 
                // IAsyncResult that will cause EndWrite to block, since the OS won't
                // call AsyncFSCallback for us.  -- Brian Grunkemeyer

                if (hr==ERROR_NO_DATA) {
                    // This handle was a pipe, and the pipe is being closed on the 
                    // other side.  Let the caller handle this, since BeginWriteCore 
                    // & WriteCore need to do different things.
                    return -1;
                }
                
                // For invalid handles, detect the error and mark our handle
                // as closed to give slightly better error messages.  Also
                // help ensure we avoid handle recycling bugs.
                if (hr == Win32Native.ERROR_INVALID_HANDLE)
                    _handleProtector.ForciblyMarkAsClosed();

                return -1;
            }
            else
                hr = 0;
            return numBytesWritten;          
        }

        private sealed class __FileStreamHandleProtector : __HandleProtector
        {
            private bool _ownsHandle;

            internal __FileStreamHandleProtector(IntPtr handle, bool ownsHandle) : base(handle)
            {
                _ownsHandle = ownsHandle;
            }

            protected internal override void FreeHandle(IntPtr handle)
            {
                // TODO: After RTM consider checking CloseHandle's return value.
                if (_ownsHandle)
                    Win32Native.CloseHandle(handle);
            }
        }
        
        [DllImport(Microsoft.Win32.Win32Native.KERNEL32 , SetLastError=true), SuppressUnmanagedCodeSecurityAttribute]
        private static unsafe extern int WriteFile(IntPtr handle, byte* bytes, int numBytesToWrite, out int numBytesWritten, NativeOverlapped* lpOverlapped);

        [DllImport(Microsoft.Win32.Win32Native.KERNEL32 , SetLastError=true), SuppressUnmanagedCodeSecurityAttribute]
        private static unsafe extern int WriteFile(IntPtr handle, byte* bytes, int numBytesToWrite, IntPtr numBytesWritten, NativeOverlapped* lpOverlapped);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool RunningOnWinNTNative();

        // @Consider: We may want to use FCALL, not P/Invoke.
        [DllImport(Microsoft.Win32.Win32Native.KERNEL32, SetLastError=true), SuppressUnmanagedCodeSecurityAttribute]
        private static extern bool SetEvent(IntPtr eventHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\ioexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  IOException
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Exception for a generic IO error.
**
** Date:  February 18, 2000
**
===========================================================*/

using System;
using System.Runtime.Serialization;

namespace System.IO {

    /// <include file='doc\IOException.uex' path='docs/doc[@for="IOException"]/*' />
    [Serializable]
    public class IOException : SystemException
    {
        /// <include file='doc\IOException.uex' path='docs/doc[@for="IOException.IOException"]/*' />
        public IOException() 
            : base(Environment.GetResourceString("Arg_IOException")) {
    		SetErrorCode(__HResults.COR_E_IO);
        }
        
        /// <include file='doc\IOException.uex' path='docs/doc[@for="IOException.IOException1"]/*' />
        public IOException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_IO);
        }

        /// <include file='doc\IOException.uex' path='docs/doc[@for="IOException.IOException2"]/*' />
        public IOException(String message, int hresult) 
            : base(message) {
    		SetErrorCode(hresult);
        }
    	
        /// <include file='doc\IOException.uex' path='docs/doc[@for="IOException.IOException3"]/*' />
        public IOException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_IO);
        }

        /// <include file='doc\IOException.uex' path='docs/doc[@for="IOException.IOException4"]/*' />
        protected IOException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\memorystream.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  MemoryStream
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: A Stream whose backing store is memory.  Great
** for temporary storage without creating a temp file.  Also
** lets users expose a byte[] as a stream.
**
** Date:  February 19, 2000
**
===========================================================*/

using System;
using System.Runtime.InteropServices;

namespace System.IO {
    // A MemoryStream represents a Stream in memory (ie, it has no backing store).
    // This stream may reduce the need for temporary buffers and files in 
    // an application.  
    // 
    // There are two ways to create a MemoryStream.  You can initialize one
    // from an unsigned byte array, or you can create an empty one.  Empty 
    // memory streams are resizable, while ones created with a byte array provide
    // a stream "view" of the data.
    /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream"]/*' />
    [Serializable]
    public class MemoryStream : Stream
    {
        private byte[] _buffer;    // Either allocated internally or externally.
        private int _origin;       // For user-provided arrays, start at this origin
        private int _position;     // read/write head.
        private int _length;       // Number of bytes within the memory stream
        private int _capacity;     // length of usable portion of buffer for stream
        // Note that _capacity == _buffer.Length for non-user-provided byte[]'s

        private bool _expandable;  // User-provided buffers aren't expandable.
        private bool _writable;    // Can user write to this stream?
        private bool _exposable;   // Whether the array can be returned to the user.
        private bool _isOpen;      // Is this stream open or closed?

        // In V2, if we get support for arrays of more than 2 GB worth of elements,
        // consider removing this constraing, or setting it to Int64.MaxValue.
        private const int MemStreamMaxLength = Int32.MaxValue;

        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.MemoryStream"]/*' />
        public MemoryStream() 
            : this(0) {
        }
        
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.MemoryStream1"]/*' />
        public MemoryStream(int capacity) {
            if (capacity < 0) throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_NegativeCapacity"));
            _buffer = new byte[capacity];
            _capacity = capacity;
            _expandable = true;
            _writable = true;
            _exposable = true;
            _origin = 0;      // Must be 0 for byte[]'s created by MemoryStream
            _isOpen = true;
        }
        
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.MemoryStream2"]/*' />
        public MemoryStream(byte[] buffer) 
            : this(buffer, true) {
        }
        
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.MemoryStream3"]/*' />
        public MemoryStream(byte[] buffer, bool writable) {
            if (buffer == null) throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
            _buffer = buffer;
            _length = _capacity = buffer.Length;
            _writable = writable;
            _exposable = false;
            _origin = 0;
            _isOpen = true;
        }
        
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.MemoryStream4"]/*' />
        public MemoryStream(byte[] buffer, int index, int count) 
            : this(buffer, index, count, true, false) {
        }
        
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.MemoryStream5"]/*' />
        public MemoryStream(byte[] buffer, int index, int count, bool writable) 
            : this(buffer, index, count, writable, false) {
        }
    
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.MemoryStream6"]/*' />
        public MemoryStream(byte[] buffer, int index, int count, bool writable, bool publiclyVisible) {
            if (buffer==null)
                throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (index < 0)
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
            _buffer = buffer;
            _origin = _position = index;
            _length = _capacity = index + count;
            _writable = writable;
            _exposable = publiclyVisible;  // Can GetBuffer return the array?
            _expandable = false;
            _isOpen = true;
        }
    
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.CanRead"]/*' />
        public override bool CanRead {
            get { return _isOpen; }
        }
        
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.CanSeek"]/*' />
        public override bool CanSeek {
            get { return _isOpen; }
        }
        
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.CanWrite"]/*' />
        public override bool CanWrite {
            get { return _writable; }
        }

        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.Close"]/*' />
        public override void Close() {
            _isOpen = false;
            _writable = false;
            _expandable = false;
            // Don't set buffer to null - allow GetBuffer & ToArray to work.
        }
        
        // returns a bool saying whether we allocated a new array.
        private bool EnsureCapacity(int value) {
            // Check for overflow
            if (value < 0)
                throw new IOException(Environment.GetResourceString("IO.IO_StreamTooLong"));
            if (value > _capacity) {
                int newCapacity = value;
                if (newCapacity < 256)
                    newCapacity = 256;
                if (newCapacity < _capacity * 2)
                    newCapacity = _capacity * 2;
                Capacity = newCapacity;
                return true;
            }
            return false;
        }
    
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.Flush"]/*' />
        public override void Flush() {
        }
    
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.GetBuffer"]/*' />
        public virtual byte[] GetBuffer() {
            if (!_exposable)
                throw new UnauthorizedAccessException(Environment.GetResourceString("UnauthorizedAccess_MemStreamBuffer"));
            return _buffer;
        }
    
        // Gets and sets the capacity (number of bytes allocated) for this stream.
        // The capacity cannot be set to a value less than the current length
        // of the stream.
        // 
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.Capacity"]/*' />
        public virtual int Capacity {
            get { 
                if (!_isOpen) __Error.StreamIsClosed();
                return _capacity - _origin;
            }
            set {
                if (!_isOpen) __Error.StreamIsClosed();
                if (value != _capacity) {
                    if (!_expandable) __Error.MemoryStreamNotExpandable();
                    if (value < _length) throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_SmallCapacity"));
                    if (value > 0) {
                        byte[] newBuffer = new byte[value];
                        if (_length > 0) Buffer.InternalBlockCopy(_buffer, 0, newBuffer, 0, _length);
                        _buffer = newBuffer;
                    }
                    else {
                        _buffer = null;
                    }
                    _capacity = value;
                }
            }
        }        

        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.Length"]/*' />
        public override long Length {
            get {
                if (!_isOpen) __Error.StreamIsClosed();
                return _length - _origin;
            }
        }

        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.Position"]/*' />
        public override long Position {
            get { 
                if (!_isOpen) __Error.StreamIsClosed();
                return _position - _origin;
            }
            set {
                if (!_isOpen) __Error.StreamIsClosed();
                if (value < 0)
                    throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                if (value > MemStreamMaxLength)
                    throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_MemStreamLength"));
                _position = _origin + (int)value;
            }
        }
        
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.Read"]/*' />
      public override int Read([In, Out] byte[] buffer, int offset, int count) {
            if (!_isOpen) __Error.StreamIsClosed();
            if (buffer==null)
                throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (offset < 0)
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - offset < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            int n = _length - _position;
            if (n > count) n = count;
            if (n <= 0)
                return 0;

            BCLDebug.Assert(_position + n >= 0, "_position + n >= 0");  // len is less than 2^31 -1.

            if (n <= 8)
            {
                int byteCount = n;
                while (--byteCount >= 0)
                    buffer[offset + byteCount] = _buffer[_position + byteCount];
            }
            else
                Buffer.InternalBlockCopy(_buffer, _position, buffer, offset, n);
            _position += n;
            return n;
        }

        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.ReadByte"]/*' />
        public override int ReadByte() {
            if (!_isOpen) __Error.StreamIsClosed();
            if (_position >= _length) return -1;
            return _buffer[_position++];
        }
        
    
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.Seek"]/*' />
        public override long Seek(long offset, SeekOrigin loc) {
            if (!_isOpen) __Error.StreamIsClosed();
            if (offset > MemStreamMaxLength)
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_MemStreamLength"));
            switch(loc) {
            case SeekOrigin.Begin:
                if (offset < 0)
                    throw new IOException(Environment.GetResourceString("IO.IO_SeekBeforeBegin"));
                _position = _origin + (int)offset;
                break;
                
            case SeekOrigin.Current:
                if (offset + _position < _origin)
                    throw new IOException(Environment.GetResourceString("IO.IO_SeekBeforeBegin"));
                _position += (int)offset;
                break;
                
            case SeekOrigin.End:
                if (_length + offset < _origin)
                    throw new IOException(Environment.GetResourceString("IO.IO_SeekBeforeBegin"));
                _position = _length + (int)offset;
                break;
                
            default:
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidSeekOrigin"));
            }

            BCLDebug.Assert(_position >= 0, "_position >= 0");
            return _position;
        }
        
        // Sets the length of the stream to a given value.  The new
        // value must be nonnegative and less than the space remaining in
        // the array, Int32.MaxValue - origin
        // Origin is 0 in all cases other than a MemoryStream created on
        // top of an existing array and a specific starting offset was passed 
        // into the MemoryStream constructor.  The upper bounds prevents any 
        // situations where a stream may be created on top of an array then 
        // the stream is made longer than the maximum possible length of the 
        // array (Int32.MaxValue).
        // 
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.SetLength"]/*' />
        public override void SetLength(long value) {
            if (!_writable) __Error.WriteNotSupported();
            if (value > MemStreamMaxLength)
                throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_MemStreamLength"));
            if (value < 0 || value > (Int32.MaxValue - _origin)) {
                throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_MemStreamLength"));
            }
            int newLength = _origin + (int)value;
            bool allocatedNewArray = EnsureCapacity(newLength);
            if (!allocatedNewArray && newLength > _length)
                Array.Clear(_buffer, _length, newLength - _length);
            _length = newLength;
            if (_position > newLength) _position = newLength;
        }
        
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.ToArray"]/*' />
        public virtual byte[] ToArray() {
            BCLDebug.Perf(_exposable, "MemoryStream::GetBuffer will let you avoid a copy.");
            byte[] copy = new byte[_length - _origin];
            Buffer.InternalBlockCopy(_buffer, _origin, copy, 0, _length - _origin);
            return copy;
        }
    
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.Write"]/*' />
        public override void Write(byte[] buffer, int offset, int count) {
            if (!_isOpen) __Error.StreamIsClosed();
            if (!_writable) __Error.WriteNotSupported();
            if (buffer==null)
                throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (offset < 0)
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - offset < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
            int i = _position + count;
            // Check for overflow
            if (i < 0)
                throw new IOException(Environment.GetResourceString("IO.IO_StreamTooLong"));

            if (i > _length) {
                bool mustZero = _position > _length;
                if (i > _capacity) {
                    bool allocatedNewArray = EnsureCapacity(i);
                    if (allocatedNewArray)
                        mustZero = false;
                }
                if (mustZero)
                    Array.Clear(_buffer, _length, i - _length);
                _length = i;
            }
            if (count <= 8)
            {
                int byteCount = count;
                while (--byteCount >= 0)
                    _buffer[_position + byteCount] = buffer[offset + byteCount];
            }
            else
                Buffer.InternalBlockCopy(buffer, offset, _buffer, _position, count);
            _position = i;
            return;
        }

        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.WriteByte"]/*' />
        public override void WriteByte(byte value) {
            if (!_isOpen) __Error.StreamIsClosed();
            if (!_writable) __Error.WriteNotSupported();
            if (_position >= _length) {
                int newLength = _position + 1;
                bool mustZero = _position > _length;
                if (newLength >= _capacity) {
                    bool allocatedNewArray = EnsureCapacity(newLength);
                    if (allocatedNewArray)
                        mustZero = false;
                }
                if (mustZero)
                    Array.Clear(_buffer, _length, _position - _length);
                _length = newLength;
            }
            _buffer[_position++] = value;
        }
    
        // Writes this MemoryStream to another stream.
        /// <include file='doc\MemoryStream.uex' path='docs/doc[@for="MemoryStream.WriteTo"]/*' />
        public virtual void WriteTo(Stream stream) {
            if (!_isOpen) __Error.StreamIsClosed();
            if (stream==null)
                throw new ArgumentNullException("stream", Environment.GetResourceString("ArgumentNull_Stream"));
            stream.Write(_buffer, _origin, _length - _origin);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\fileshare.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Enum:   FileShare
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Enum describing how to share files with other 
** processes - ie, whether two processes can simultaneously
** read from the same file.
**
** Date:  February 18, 2000
**
===========================================================*/

using System;

namespace System.IO {
    // Contains constants for controlling file sharing options while
    // opening files.  You can specify what access other processes trying
    // to open the same file concurrently can have.
    // 
    /// <include file='doc\FileShare.uex' path='docs/doc[@for="FileShare"]/*' />
    [Serializable, Flags]
    public enum FileShare
    {
        // No sharing. Any request to open the file (by this process or another
        // process) will fail until the file is closed.
        /// <include file='doc\FileShare.uex' path='docs/doc[@for="FileShare.None"]/*' />
        None = 0,
    
        // Allows subsequent opening of the file for reading. If this flag is not
        // specified, any request to open the file for reading (by this process or
        // another process) will fail until the file is closed.
        /// <include file='doc\FileShare.uex' path='docs/doc[@for="FileShare.Read"]/*' />
        Read = 1,
    
        // Allows subsequent opening of the file for writing. If this flag is not
        // specified, any request to open the file for writing (by this process or
        // another process) will fail until the file is closed.
        /// <include file='doc\FileShare.uex' path='docs/doc[@for="FileShare.Write"]/*' />
        Write = 2,
    
        // Allows subsequent opening of the file for writing or reading. If this flag
        // is not specified, any request to open the file for writing or reading (by
        // this process or another process) will fail until the file is closed.
        /// <include file='doc\FileShare.uex' path='docs/doc[@for="FileShare.ReadWrite"]/*' />
        ReadWrite = 3,


        // Whether the file handle should be inheritable by child processes.
        // Note this is not directly supported like this by Win32.
        /// <include file='doc\FileShare.uex' path='docs/doc[@for="FileShare.Inheritable"]/*' />
        Inheritable = 0x10,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\filesysteminfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  FileSystemInfo	
**
** Author: Rajesh Chandrashekaran (rajeshc)
**
** Purpose: 
**
** Date:  April 7, 2000
**
===========================================================*/

using System;
using System.Collections;
using System.Security;
using System.Security.Permissions;
using Microsoft.Win32;
using System.Text;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

//@TODO: Add a static SystemDirectory property returning a URI
namespace System.IO {
    /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo"]/*' />
	[Serializable]
    [FileIOPermissionAttribute(SecurityAction.InheritanceDemand,Unrestricted=true)]
    public abstract class FileSystemInfo : MarshalByRefObject, ISerializable {
		internal Win32Native.WIN32_FILE_ATTRIBUTE_DATA _data; // Cache the file information
		internal int _dataInitialised = -1; // We use this field in conjunction with the Refresh methods, if we succeed
										   // we store a zero, on failure we store the HResult in it so that we can
										   // give back a generic error back.

		private const int ERROR_INVALID_PARAMETER = 87;
		internal const int ERROR_ACCESS_DENIED = 0x5;

        /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.FullPath"]/*' />
        protected String FullPath;  // fully qualified path of the directory
		/// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.OriginalPath"]/*' />
		protected String OriginalPath; // path passed in by the user

        /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.FileSystemInfo"]/*' />
        protected FileSystemInfo()
        {
        }

        /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.FileSystemInfo1"]/*' />
        protected FileSystemInfo(SerializationInfo info, StreamingContext context)
        {
            if (info == null)
                throw new ArgumentNullException("info");
            
            // Must use V1 field names here, since V1 didn't implement 
            // ISerializable.
            FullPath = Path.GetFullPathInternal(info.GetString("FullPath"));
            OriginalPath = info.GetString("OriginalPath");

            // Always make people reload the file attributes.
            _dataInitialised = -1;
        }


		// Full path of the direcory/file
        /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.FullName"]/*' />
        public virtual String FullName {
            get 
			{
				String demandDir;
				if (this is DirectoryInfo) {
					if (FullPath.EndsWith( @"\" ))
						demandDir = FullPath + @".";
					else
						demandDir = FullPath + @"\.";
				}
				else
					demandDir = FullPath;
				new FileIOPermission(FileIOPermissionAccess.PathDiscovery, demandDir).Demand();
				return FullPath;
			}
        }

		/// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.Extension"]/*' />
		public String Extension 
		{
			get
			{
				// GetFullPathInternal would have already stripped out the terminating "." if present.
			   int length = FullPath.Length;
				for (int i = length; --i >= 0;) {
					char ch = FullPath[i];
					if (ch == '.')
						return FullPath.Substring(i, length - i);
					if (ch == Path.DirectorySeparatorChar || ch == Path.AltDirectorySeparatorChar || ch == Path.VolumeSeparatorChar)
						break;
				}
				return String.Empty;
			}
		}

		// For files name of the file is returned, for directories the last directory in hierarchy is returned if possible,
		// otherwise the fully qualified name s returned
        /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.Name"]/*' />
        public abstract String Name {
            get;
        }
        
		// Whether a file/directory exists
	    /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.Exists"]/*' />
	    public abstract bool Exists
		{
			get;
		}

		// Delete a file/directory
	   	/// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.Delete"]/*' />
	   	public abstract void Delete();

	   /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.CreationTime"]/*' />
       public DateTime CreationTime {
            get {
				return CreationTimeUtc.ToLocalTime();
            }
		
			set {
                CreationTimeUtc = value.ToUniversalTime();
			}
		}

	   /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.CreationTimeUtc"]/*' />
	   [ComVisible(false)]
       public DateTime CreationTimeUtc {
            get {
				if (_dataInitialised == -1) {
					_data = new Win32Native.WIN32_FILE_ATTRIBUTE_DATA();
					Refresh();
				}

				if (_dataInitialised != 0) // Refresh was unable to initialise the data
					__Error.WinIOError(_dataInitialised, OriginalPath);
				
				long fileTime = ((long)_data.ftCreationTimeHigh << 32) | _data.ftCreationTimeLow;
    			return DateTime.FromFileTimeUtc(fileTime);
				
            }
		
			set {
				if (this is DirectoryInfo)
					Directory.SetCreationTimeUtc(FullPath,value);
				else
					File.SetCreationTimeUtc(FullPath,value);
				_dataInitialised = -1;
			}
		}

        /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.LastAccessTime"]/*' />
        public DateTime LastAccessTime {
            get {
                return LastAccessTimeUtc.ToLocalTime();	
            }
			set {
                LastAccessTimeUtc = value.ToUniversalTime();
			}
        }

        /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.LastAccessTimeUtc"]/*' />
        [ComVisible(false)]
        public DateTime LastAccessTimeUtc {
            get {
				if (_dataInitialised == -1) {
					_data = new Win32Native.WIN32_FILE_ATTRIBUTE_DATA();
					Refresh();
				}

				if (_dataInitialised != 0) // Refresh was unable to initialise the data
					__Error.WinIOError(_dataInitialised, OriginalPath);
					
				long fileTime = ((long)_data.ftLastAccessTimeHigh << 32) | _data.ftLastAccessTimeLow;
    			return DateTime.FromFileTimeUtc(fileTime);
	
            }
			set {
				if (this is DirectoryInfo)
					Directory.SetLastAccessTimeUtc(FullPath,value);
				else
					File.SetLastAccessTimeUtc(FullPath,value);
				_dataInitialised = -1;
			}
        }

        /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.LastWriteTime"]/*' />
        public DateTime LastWriteTime {
            get {
				return LastWriteTimeUtc.ToLocalTime();
			}
			set {
                LastWriteTimeUtc = value.ToUniversalTime();
			}
        }

        /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.LastWriteTimeUtc"]/*' />
        [ComVisible(false)]
        public DateTime LastWriteTimeUtc {
            get {
				if (_dataInitialised == -1) {
					_data = new Win32Native.WIN32_FILE_ATTRIBUTE_DATA();
					Refresh();
				}

				if (_dataInitialised != 0) // Refresh was unable to initialise the data
					__Error.WinIOError(_dataInitialised, OriginalPath);
		
			
			    long fileTime = ((long)_data.ftLastWriteTimeHigh << 32) | _data.ftLastWriteTimeLow;
				return DateTime.FromFileTimeUtc(fileTime);
			}
			set {
				if (this is DirectoryInfo)
					Directory.SetLastWriteTimeUtc(FullPath,value);
				else
					File.SetLastWriteTimeUtc(FullPath,value);
				_dataInitialised = -1;
			}
        }

		/// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.Refresh"]/*' />
		public void Refresh()
		{
			_dataInitialised = File.FillAttributeInfo(FullPath,ref _data,false);
		}

		/// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.Attributes"]/*' />
		public FileAttributes Attributes {
            get {
                if (_dataInitialised == -1) {
					_data = new Win32Native.WIN32_FILE_ATTRIBUTE_DATA();
					Refresh(); // Call refresh to intialise the data
				}

				if (_dataInitialised != 0) // Refresh was unable to initialise the data
					__Error.WinIOError(_dataInitialised, OriginalPath);

				return (FileAttributes) _data.fileAttributes;
            }
			set {
                new FileIOPermission(FileIOPermissionAccess.Write, FullPath).Demand();
                bool r = Win32Native.SetFileAttributes(FullPath, (int) value);
                if (!r) {
                    int hr = Marshal.GetLastWin32Error();
                    if (hr==ERROR_INVALID_PARAMETER || hr == ERROR_ACCESS_DENIED)
                        throw new ArgumentException(Environment.GetResourceString("Arg_InvalidFileAttrs"));
				    __Error.WinIOError(hr, OriginalPath);
                }
				_dataInitialised = -1;
            }
        }

        /// <include file='doc\FileSystemInfo.uex' path='docs/doc[@for="FileSystemInfo.GetObjectData"]/*' />
        [ComVisible(false)]
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("OriginalPath", OriginalPath, typeof(String));
            info.AddValue("FullPath", FullPath, typeof(String));
        }
	}       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\streamreader.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  StreamReader
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: For reading text from streams in a particular 
** encoding.
**
** Date:  February 21, 2000
**
===========================================================*/

using System;
using System.Text;
using System.Runtime.InteropServices;

namespace System.IO {    
    // This class implements a TextReader for reading characters to a Stream.
    // This is designed for character input in a particular Encoding, 
    // whereas the Stream class is designed for byte input and output.  
    // 
    /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader"]/*' />
    [Serializable()]
    public class StreamReader : TextReader
    {
        // Note StreamReader.Null is threadsafe.
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.Null"]/*' />
        public new static readonly StreamReader Null = new NullStreamReader();

        // Using a 1K byte buffer and a 4K FileStream buffer works out pretty well
        // perf-wise.  On even a 40 MB text file, any perf loss by using a 4K
        // buffer is negated by the win of allocating a smaller byte[], which 
        // saves construction time.  This does break Anders' adaptive buffering,
        // but that shouldn't be a problem since this is slightly faster.  The
        // web services guys will benefit here the most.  -- Brian  7/9/2001
        internal const int DefaultBufferSize = 1024;  // Byte buffer size
        private const int DefaultFileStreamBufferSize = 4096;
        private const int MinBufferSize = 128;
    
        private Stream stream;
        private Encoding encoding;
        private Decoder decoder;
        private byte[] byteBuffer;
        private char[] charBuffer;
        private byte[] _preamble;   // Encoding's preamble, which identifies this encoding.
        private int charPos;
        private int charLen;
        // Record the number of valid bytes in the byteBuffer, for a few checks.
        private int byteLen;

        // This is the maximum number of chars we can get from one call to 
        // ReadBuffer.  Used so ReadBuffer can tell when to copy data into
        // a user's char[] directly, instead of our internal char[].
        private int _maxCharsPerBuffer;

        // We will support looking for byte order marks in the stream and trying
        // to decide what the encoding might be from the byte order marks, IF they
        // exist.  But that's all we'll do.  Note this is fragile.
        private bool _detectEncoding;

        // Whether we must still check for the encoding's given preamble at the
        // beginning of this file.
        private bool _checkPreamble;

        // Whether the stream is most likely not going to give us back as much 
        // data as we want the next time we call it.  We must do the computation
        // before we do any byte order mark handling and save the result.  Note that
        // we need this to allow people to handle streams where they block waiting
        // for you to send a response, like logging in on a Unix machine.
        private bool _isBlocked;

        internal StreamReader() {
        }
        
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.StreamReader"]/*' />
        public StreamReader(Stream stream) 
            : this(stream, Encoding.UTF8, true, DefaultBufferSize) {
        }

        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.StreamReader8"]/*' />
        public StreamReader(Stream stream, bool detectEncodingFromByteOrderMarks) 
            : this(stream, Encoding.UTF8, detectEncodingFromByteOrderMarks, DefaultBufferSize) {
        }
        
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.StreamReader1"]/*' />
        public StreamReader(Stream stream, Encoding encoding) 
            : this(stream, encoding, true, DefaultBufferSize) {
        }
        
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.StreamReader2"]/*' />
        public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks)
            : this(stream, encoding, detectEncodingFromByteOrderMarks, DefaultBufferSize) {
        }

        // Creates a new StreamReader for the given stream.  The 
        // character encoding is set by encoding and the buffer size, 
        // in number of 16-bit characters, is set by bufferSize.  
        // 
        // Note that detectEncodingFromByteOrderMarks is a very
        // loose attempt at detecting the encoding by looking at the first
        // 3 bytes of the stream.  It will recognize UTF-8, little endian
        // unicode, and big endian unicode text, but that's it.  If neither
        // of those three match, it will use the Encoding you provided.
        // 
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.StreamReader3"]/*' />
        public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize)
        {
            if (stream==null || encoding==null)
                throw new ArgumentNullException((stream==null ? "stream" : "encoding"));
            if (!stream.CanRead)
                throw new ArgumentException(Environment.GetResourceString("Argument_StreamNotReadable"));
            if (bufferSize <= 0)
                throw new ArgumentOutOfRangeException("bufferSize", Environment.GetResourceString("ArgumentOutOfRange_NeedPosNum"));

            Init(stream, encoding, detectEncodingFromByteOrderMarks, bufferSize);
        }
    
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.StreamReader4"]/*' />
        public StreamReader(String path) 
            : this(path, Encoding.UTF8, true, DefaultBufferSize) {
        }

        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.StreamReader9"]/*' />
        public StreamReader(String path, bool detectEncodingFromByteOrderMarks) 
            : this(path, Encoding.UTF8, detectEncodingFromByteOrderMarks, DefaultBufferSize) {
        }
        
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.StreamReader5"]/*' />
        public StreamReader(String path, Encoding encoding) 
            : this(path, encoding, true, DefaultBufferSize) {
        }

        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.StreamReader6"]/*' />
        public StreamReader(String path, Encoding encoding, bool detectEncodingFromByteOrderMarks) 
            : this(path, encoding, detectEncodingFromByteOrderMarks, DefaultBufferSize) {
        }

        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.StreamReader7"]/*' />
        public StreamReader(String path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize)
        {
            // Don't open a Stream before checking for invalid arguments,
            // or we'll create a FileStream on disk and we won't close it until
            // the finalizer runs, causing problems for applications.
            if (path==null || encoding==null)
                throw new ArgumentNullException((path==null ? "path" : "encoding"));
            if (path.Length==0)
                throw new ArgumentException(Environment.GetResourceString("Argument_EmptyPath"));
            if (bufferSize <= 0)
                throw new ArgumentOutOfRangeException("bufferSize", Environment.GetResourceString("ArgumentOutOfRange_NeedPosNum"));

            Stream stream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, DefaultFileStreamBufferSize);
            Init(stream, encoding, detectEncodingFromByteOrderMarks, bufferSize);
        }
        
        private void Init(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize) {
            this.stream = stream;
            this.encoding = encoding;
            decoder = encoding.GetDecoder();
            if (bufferSize < MinBufferSize) bufferSize = MinBufferSize;
            byteBuffer = new byte[bufferSize];
            _maxCharsPerBuffer = encoding.GetMaxCharCount(bufferSize);
            charBuffer = new char[_maxCharsPerBuffer];
            byteLen = 0;
            _detectEncoding = detectEncodingFromByteOrderMarks;
            _preamble = encoding.GetPreamble();
            _checkPreamble = (_preamble.Length > 0);
            _isBlocked = false;
        }

        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.Close"]/*' />
        public override void Close()
        {
            Dispose(true);
        }
        
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.Dispose"]/*' />
        protected override void Dispose(bool disposing)
        {
            if (disposing) {
                if (stream != null)
                    stream.Close();
            }
            if (stream != null) {
                stream = null;
                encoding = null;
                decoder = null;
                byteBuffer = null;
                charBuffer = null;
                charPos = 0;
                charLen = 0;
            }
            base.Dispose(disposing);
        }
        
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.CurrentEncoding"]/*' />
        public virtual Encoding CurrentEncoding {
            get { return encoding; }
        }
        
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.BaseStream"]/*' />
        public virtual Stream BaseStream {
            get { return stream; }
        }

        // DiscardBufferedData tells StreamReader to throw away its internal
        // buffer contents.  This is useful if the user needs to seek on the
        // underlying stream to a known location then wants the StreamReader
        // to start reading from this new point.  This method should be called
        // very sparingly, if ever, since it can lead to very poor performance.
        // However, it may be the only way of handling some scenarios where 
        // users need to re-read the contents of a StreamReader a second time.
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.DiscardBufferedData"]/*' />
        public void DiscardBufferedData() {
            byteLen = 0;
            charLen = 0;
            charPos = 0;
            decoder = encoding.GetDecoder();
            _isBlocked = false;
        }

        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.Peek"]/*' />
        public override int Peek() {
            if (stream == null)
                __Error.ReaderClosed();

            if (charPos == charLen) {
                if (_isBlocked || ReadBuffer() == 0) return -1;
            }
            return charBuffer[charPos];
        }
        
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.Read"]/*' />
        public override int Read() {
            if (stream == null)
                __Error.ReaderClosed();

            if (charPos == charLen) {
                if (ReadBuffer() == 0) return -1;
            }
            return charBuffer[charPos++];
        }
    
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.Read1"]/*' />
        public override int Read([In, Out] char[] buffer, int index, int count) {
            if (stream == null)
                __Error.ReaderClosed();
            if (buffer==null)
                throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (index < 0 || count < 0)
                throw new ArgumentOutOfRangeException((index < 0 ? "index" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            int charsRead = 0;
            // As a perf optimization, if we had exactly one buffer's worth of 
            // data read in, let's try writing directly to the user's buffer.
            bool readToUserBuffer = false;
            while (count > 0) {
                int n = charLen - charPos;
                if (n == 0) n = ReadBuffer(buffer, index + charsRead, count, out readToUserBuffer);
                if (n == 0) break;  // We're at EOF
                if (n > count) n = count;
                if (!readToUserBuffer) {
                    Buffer.InternalBlockCopy(charBuffer, charPos * 2, buffer, (index + charsRead) * 2, n*2);
                    charPos += n;
                }
                charsRead += n;
                count -= n;
                // This function shouldn't block for an indefinite amount of time,
                // or reading from a network stream won't work right.  If we got
                // fewer bytes than we requested, then we want to break right here.
                if (_isBlocked)
                    break;
            }
            return charsRead;
        }

        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.ReadToEnd"]/*' />
        public override String ReadToEnd()
        {
            if (stream == null)
                __Error.ReaderClosed();

            // For performance, call Read(char[], int, int) with a buffer
            // as big as the StreamReader's internal buffer, to get the 
            // readToUserBuffer optimization.
            char[] chars = new char[charBuffer.Length];
            int len;
            StringBuilder sb = new StringBuilder(charBuffer.Length);
            while((len=Read(chars, 0, chars.Length)) != 0) {
                sb.Append(chars, 0, len);
            }
            return sb.ToString();
        }

        // Trims n bytes from the front of the buffer.
        private void CompressBuffer(int n)
        {
            Buffer.InternalBlockCopy(byteBuffer, n, byteBuffer, 0, byteLen - n);
            byteLen -= n;
        }

        // returns whether the first array starts with the second array.
        private static bool BytesMatch(byte[] buffer, byte[] compareTo)
        {
            BCLDebug.Assert(buffer.Length >= compareTo.Length, "Your Encoding's Preamble array is pretty darn huge!");
            for(int i=0; i<compareTo.Length; i++)
                if (buffer[i] != compareTo[i])
                    return false;
            return true;
        }

        private void DetectEncoding()
        {
            if (byteLen < 2)
                return;
            _detectEncoding = false;
            bool changedEncoding = false;
            if (byteBuffer[0]==0xFE && byteBuffer[1]==0xFF) {
                // Big Endian Unicode
                encoding = new UnicodeEncoding(true, true);
                decoder = encoding.GetDecoder();
                CompressBuffer(2);
                changedEncoding = true;
            }
            else if (byteBuffer[0]==0xFF && byteBuffer[1]==0xFE) {
                // Little Endian Unicode
                encoding = new UnicodeEncoding(false, true);
                decoder = encoding.GetDecoder();
                CompressBuffer(2);
                changedEncoding = true;
            }
            else if (byteLen >= 3 && byteBuffer[0]==0xEF && byteBuffer[1]==0xBB && byteBuffer[2]==0xBF) {
                // UTF-8
                encoding = Encoding.UTF8;
                decoder = encoding.GetDecoder();
                CompressBuffer(3);
                changedEncoding = true;
            }
            else if (byteLen == 2)
                _detectEncoding = true;
            // Note: in the future, if we change this algorithm significantly,
            // we can support checking for the preamble of the given encoding.

            if (changedEncoding) {
                _maxCharsPerBuffer = encoding.GetMaxCharCount(byteBuffer.Length);
                charBuffer = new char[_maxCharsPerBuffer];
            }
        }


        private int ReadBuffer() {
            charLen = 0;
            byteLen = 0;
            charPos = 0;
            do {
                byteLen = stream.Read(byteBuffer, 0, byteBuffer.Length);

                if (byteLen == 0)  // We're at EOF
                    return charLen;

                // _isBlocked == whether we read fewer bytes than we asked for.
                // Note we must check it here because CompressBuffer or 
                // DetectEncoding will screw with byteLen.
                _isBlocked = (byteLen < byteBuffer.Length);
                
                if (_checkPreamble && byteLen >= _preamble.Length) {
                    _checkPreamble = false;
                    if (BytesMatch(byteBuffer, _preamble)) {
                        _detectEncoding = false;
                        CompressBuffer(_preamble.Length);
                    }
                }

                // If we're supposed to detect the encoding and haven't done so yet,
                // do it.  Note this may need to be called more than once.
                if (_detectEncoding && byteLen >= 2)
                    DetectEncoding();

                charLen += decoder.GetChars(byteBuffer, 0, byteLen, charBuffer, charLen);
            } while (charLen == 0);
            //Console.WriteLine("ReadBuffer called.  chars: "+charLen);
            return charLen;
        }


        // This version has a perf optimization to decode data DIRECTLY into the 
        // user's buffer, bypassing StreamWriter's own buffer.
        // This gives a > 20% perf improvement for our encodings across the board,
        // but only when asking for at least the number of characters that one
        // buffer's worth of bytes could produce.
        // This optimization, if run, will break SwitchEncoding, so we must not do 
        // this on the first call to ReadBuffer.  
        private int ReadBuffer(char[] userBuffer, int userOffset, int desiredChars, out bool readToUserBuffer) {
            charLen = 0;
            byteLen = 0;
            charPos = 0;
            int charsRead = 0;

            // As a perf optimization, we can decode characters DIRECTLY into a
            // user's char[].  We absolutely must not write more characters 
            // into the user's buffer than they asked for.  Calculating 
            // encoding.GetMaxCharCount(byteLen) each time is potentially very 
            // expensive - instead, cache the number of chars a full buffer's 
            // worth of data may produce.  Yes, this makes the perf optimization 
            // less aggressive, in that all reads that asked for fewer than AND 
            // returned fewer than _maxCharsPerBuffer chars won't get the user 
            // buffer optimization.  This affects reads where the end of the
            // Stream comes in the middle somewhere, and when you ask for 
            // fewer chars than than your buffer could produce.
            readToUserBuffer = desiredChars >= _maxCharsPerBuffer;

            do {
                byteLen = stream.Read(byteBuffer, 0, byteBuffer.Length);

                if (byteLen == 0)  // EOF
                    return charsRead;

                // _isBlocked == whether we read fewer bytes than we asked for.
                // Note we must check it here because CompressBuffer or 
                // DetectEncoding will screw with byteLen.
                _isBlocked = (byteLen < byteBuffer.Length);

                // On the first call to ReadBuffer, if we're supposed to detect the encoding, do it.
                if (_detectEncoding && byteLen >= 2) {
                    DetectEncoding();
                    // DetectEncoding changes some buffer state.  Recompute this.
                    readToUserBuffer = desiredChars >= _maxCharsPerBuffer;
                }

                if (_checkPreamble && byteLen >= _preamble.Length) {
                    _checkPreamble = false;
                    if (BytesMatch(byteBuffer, _preamble)) {
                        _detectEncoding = false;
                        CompressBuffer(_preamble.Length);
                        // CompressBuffer changes some buffer state.  Recompute this.
                        readToUserBuffer = desiredChars >= _maxCharsPerBuffer;
                    }
                }

                /*
                if (readToUserBuffer)
                    Console.Write('.');
                else {
                    Console.WriteLine("Desired chars is wrong.  byteBuffer.length: "+byteBuffer.Length+"  max chars is: "+encoding.GetMaxCharCount(byteLen)+"  desired: "+desiredChars);
                }
                */

                charPos = 0;
                if (readToUserBuffer) {
                    charsRead += decoder.GetChars(byteBuffer, 0, byteLen, userBuffer, userOffset + charsRead);
                    charLen = 0;  // StreamReader's buffer is empty.
                }
                else {
                    charsRead = decoder.GetChars(byteBuffer, 0, byteLen, charBuffer, charsRead);
                    charLen += charsRead;  // Number of chars in StreamReader's buffer.
                }
            } while (charsRead == 0);
            //Console.WriteLine("ReadBuffer: charsRead: "+charsRead+"  readToUserBuffer: "+readToUserBuffer);
            return charsRead;
        }
        

        // Reads a line. A line is defined as a sequence of characters followed by
        // a carriage return ('\r'), a line feed ('\n'), or a carriage return
        // immediately followed by a line feed. The resulting string does not
        // contain the terminating carriage return and/or line feed. The returned
        // value is null if the end of the input stream has been reached.
        //
        /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.ReadLine"]/*' />
        public override String ReadLine() {
            if (stream == null)
                __Error.ReaderClosed();

            if (charPos == charLen) {
                if (ReadBuffer() == 0) return null;
            }
            StringBuilder sb = null;
            do {
                int i = charPos;
                do {
                    char ch = charBuffer[i];
                    // Note the following common line feed chars:
                    // \n - UNIX   \r\n - DOS   \r - Mac
                    if (ch == '\r' || ch == '\n') {
                        String s;
                        if (sb != null) {
                            sb.Append(charBuffer, charPos, i - charPos);
                            s = sb.ToString();
                        }
                        else {
                            s = new String(charBuffer, charPos, i - charPos);
                        }
                        charPos = i + 1;
                        if (ch == '\r' && (charPos < charLen || ReadBuffer() > 0)) {
                            if (charBuffer[charPos] == '\n') charPos++;
                        }
                        return s;
                    }
                    i++;
                } while (i < charLen);
                i = charLen - charPos;
                if (sb == null) sb = new StringBuilder(i + 80);
                sb.Append(charBuffer, charPos, i);
            } while (ReadBuffer() > 0);
            return sb.ToString();
        }
        
        // No data, class doesn't need to be serializable.
        // Note this class is threadsafe.
        private class NullStreamReader : StreamReader
        {
            public override Stream BaseStream {
                get { return Stream.Null; }
            }

            public override Encoding CurrentEncoding {
                get { return Encoding.Unicode; }
            }

            public override int Peek()
            {
                return -1;
            }

            public override int Read()
            {
                return -1;
            }

            /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.NullStreamReader.Read"]/*' />
            public override int Read(char[] buffer, int index, int count) {
                return 0;
            }
            
            /// <include file='doc\StreamReader.uex' path='docs/doc[@for="StreamReader.NullStreamReader.ReadLine"]/*' />
            public override String ReadLine() {
                return null;
            }

            public override String ReadToEnd()
            {
                return String.Empty;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\stream.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Stream
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Abstract base class for all Streams.  Provides
** default implementations of asynchronous reads & writes, in
** terms of the synchronous reads & writes (and vice versa).
**
** Date:  February 15, 2000
**
===========================================================*/
using System;
using System.Threading;
using System.Runtime.InteropServices;
using System.Runtime.Remoting.Messaging;
using System.Security;


namespace System.IO {
    /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream"]/*' />
    [Serializable()]
    public abstract class Stream : MarshalByRefObject, IDisposable {

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.Null"]/*' />
        public static readonly Stream Null = new NullStream();

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.CanRead"]/*' />
        public abstract bool CanRead {
            get;
        }

        // If CanSeek is false, Position, Seek, Length, and SetLength should throw.
        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.CanSeek"]/*' />
        public abstract bool CanSeek {
            get;
        }

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.CanWrite"]/*' />
        public abstract bool CanWrite {
            get;
        }

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.Length"]/*' />
        public abstract long Length {
            get;
        }

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.Position"]/*' />
        public abstract long Position {
            get;
            set;
        }


        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.Close"]/*' />
        public virtual void Close()
        {
        }

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose()
        {
            Close();
        }

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.Flush"]/*' />
        public abstract void Flush();


        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.CreateWaitHandle"]/*' />
        protected virtual WaitHandle CreateWaitHandle()
        {
            return new ManualResetEvent(false);
        }

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.BeginRead"]/*' />
        public virtual IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, Object state)
        {
            if (!CanRead) __Error.ReadNotSupported();

            // To avoid a race with a stream's position pointer & generating race 
            // conditions with internal buffer indexes in our own streams that 
            // don't natively support async IO operations when there are multiple 
            // async requests outstanding, we will block the application's main
            // thread and do the IO synchronously.  
            SynchronousAsyncResult asyncResult = new SynchronousAsyncResult(state, false);
            try {
                int numRead = Read(buffer, offset, count);
                asyncResult._numRead = numRead;
                asyncResult._isCompleted = true;
                asyncResult._waitHandle.Set();
            }
            catch (IOException e) {
                asyncResult._exception = e;
            }
            
            if (callback != null)
                callback(asyncResult);

            return asyncResult;
        }

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.EndRead"]/*' />
        public virtual int EndRead(IAsyncResult asyncResult)
        {
            if (asyncResult == null)
                throw new ArgumentNullException("asyncResult");

            SynchronousAsyncResult ar = asyncResult as SynchronousAsyncResult;
            if (ar == null || ar.IsWrite)
                __Error.WrongAsyncResult();
            if (ar._EndXxxCalled)
                __Error.EndReadCalledTwice();
            ar._EndXxxCalled = true;

            if (ar._exception != null)
                throw ar._exception;

            return ar._numRead;
        }

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.BeginWrite"]/*' />
        public virtual IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, Object state)
        {
            if (!CanWrite) __Error.WriteNotSupported();

            // To avoid a race with a stream's position pointer & generating race 
            // conditions with internal buffer indexes in our own streams that 
            // don't natively support async IO operations when there are multiple 
            // async requests outstanding, we will block the application's main
            // thread and do the IO synchronously.  
            SynchronousAsyncResult asyncResult = new SynchronousAsyncResult(state, true);
            try {
                Write(buffer, offset, count);
                asyncResult._isCompleted = true;
                asyncResult._waitHandle.Set();
            }
            catch (IOException e) {
                asyncResult._exception = e;
            }
            
            if (callback != null)
                callback.BeginInvoke(asyncResult, null, null);

            return asyncResult;
        }

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.EndWrite"]/*' />
        public virtual void EndWrite(IAsyncResult asyncResult)
        {
            if (asyncResult==null)
                throw new ArgumentNullException("asyncResult");

            SynchronousAsyncResult ar = asyncResult as SynchronousAsyncResult;
            if (ar == null || !ar.IsWrite)
                __Error.WrongAsyncResult();
            if (ar._EndXxxCalled)
                __Error.EndWriteCalledTwice();
            ar._EndXxxCalled = true;

            if (ar._exception != null)
                throw ar._exception;
        }

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.Seek"]/*' />
        public abstract long Seek(long offset, SeekOrigin origin);

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.SetLength"]/*' />
        public abstract void SetLength(long value);

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.Read"]/*' />
        public abstract int Read([In, Out] byte[] buffer, int offset, int count);

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.ReadByte"]/*' />
        public virtual int ReadByte()
        {
            // Reads one byte from the stream by calling Read(byte[], int, int). 
            // Will return an unsigned byte cast to an int or -1 on end of stream.
            // The performance of the default implementation on Stream is bad,
            // and any subclass with an internal buffer should override this method.
            byte[] oneByteArray = new byte[1];
            int r = Read(oneByteArray, 0, 1);
            if (r==0)
                return -1;
            return oneByteArray[0];
        }

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.Write"]/*' />
        public abstract void Write(byte[] buffer, int offset, int count);

        /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.WriteByte"]/*' />
        public virtual void WriteByte(byte value)
        {
            // Writes one byte from the stream by calling Write(byte[], int, int).  
            // The performance of the default implementation on Stream is bad,
            // and any subclass with an internal buffer should override this method.
            byte[] oneByteArray = new byte[1];
            oneByteArray[0] = value;
            Write(oneByteArray, 0, 1);
        }

        // No data, no need to serialize
        private class NullStream : Stream
        {
            protected internal NullStream() {}

            /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.NullStream.CanRead"]/*' />
            public override bool CanRead {
                get { return true; }
            }

            /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.NullStream.CanWrite"]/*' />
            public override bool CanWrite {
                get { return true; }
            }

            /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.NullStream.CanSeek"]/*' />
            public override bool CanSeek {
                get { return true; }
            }

            /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.NullStream.Length"]/*' />
            public override long Length {
                get { return 0; }
            }

            /// <include file='doc\Stream.uex' path='docs/doc[@for="Stream.NullStream.Position"]/*' />
            public override long Position {
                get { return 0; }
                set {}
            }

            public override void Close()
            {
            }

            public override void Flush()
            {
            }

            public override int Read([In, Out] byte[] buffer, int offset, int count)
            {
                return 0;
            }

            public override void Write(byte[] buffer, int offset, int count)
            {
            }

            public override long Seek(long offset, SeekOrigin origin)
            {
                return 0;
            }

            public override void SetLength(long length)
            {
            }
        }

        // Used as the IAsyncResult object when using asynchronous IO methods
        // on the base Stream class.  Note I'm not using async delegates, so
        // this is necessary.
        private sealed class SynchronousAsyncResult : IAsyncResult
        {
            internal ManualResetEvent _waitHandle;
            internal Object _stateObject;
            internal int _numRead;
            internal bool _isCompleted;
            internal bool _isWrite;
            internal bool _EndXxxCalled;
            internal Exception _exception;

            internal SynchronousAsyncResult(Object asyncStateObject, bool isWrite)
            {
                _stateObject = asyncStateObject;
                _isWrite = isWrite;
                _waitHandle = new ManualResetEvent(false);
            }

            public bool IsCompleted {
                get { return _isCompleted; }
            }

            public WaitHandle AsyncWaitHandle {
                get { return _waitHandle; }
            }

            public Object AsyncState {
                get { return _stateObject; }
            }

            public bool CompletedSynchronously {
                get { return true; }
            }

            internal bool IsWrite {
                get { return _isWrite; }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\__consolestream.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ConsoleStream
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Exposes a separate Stream for Console IO and 
** handles WinCE appropriately.  Also keeps us from using the
** ThreadPool for all Console output.
**
** Date:  March 2, 2000
**
===========================================================*/

using System;
using System.Runtime.InteropServices;
using System.Security;
using Microsoft.Win32;
using System.Runtime.CompilerServices;

namespace System.IO {

    internal sealed class __ConsoleStream : Stream
    {
        internal const int DefaultBufferSize = 128;

        // Error codes (not HRESULTS), from winerror.h
        private const int ERROR_BROKEN_PIPE = 109;
        // ERROR_NO_DATA ("The pipe is being closed") is returned when we write to
        // a console that is closing.
        private const int ERROR_NO_DATA = 232; 

        private IntPtr _handle;
        private bool _canRead;
        private bool _canWrite;

        private __ConsoleStream()
        {
        }

        internal __ConsoleStream(IntPtr handle, FileAccess access)
        {
            BCLDebug.Assert(handle != Win32Native.INVALID_HANDLE_VALUE, "__ConsoleStream expects a valid handle!");
            _handle = handle;
            _canRead = access == FileAccess.Read;
            _canWrite = access == FileAccess.Write;
        }
    
        public override bool CanRead {
            get { return _canRead; }
        }

        public override bool CanWrite {
            get { return _canWrite; }
        }

        public override bool CanSeek {
            get { return false; }
        }

        public override long Length {
            get {
                __Error.SeekNotSupported();
                return 0; // compiler appeasement
            }
        }

        public override long Position {
            get { 
                __Error.SeekNotSupported();
                return 0; // compiler appeasement
            }
            set {
                __Error.SeekNotSupported();
            }
        }

        public override void Close()
        {
            // We're probably better off not closing the OS handle here.  First,
            // we allow a program to get multiple instances of __ConsoleStreams
            // around the same OS handle, so closing one handle would invalidate
            // them all.  Additionally, we want a second AppDomain to be able to 
            // write to stdout if a second AppDomain quits.
            if (_handle != Win32Native.INVALID_HANDLE_VALUE) {
                Flush();
                _handle = Win32Native.INVALID_HANDLE_VALUE;
            }
            _canRead = false;
            _canWrite = false;
        }

        public override void Flush()
        {
            if (_handle == Win32Native.INVALID_HANDLE_VALUE) __Error.FileNotOpen();
            if (!CanWrite) __Error.WriteNotSupported();
        }

        public override void SetLength(long value)
        {
            __Error.SeekNotSupported();
        }

        public override int Read([In, Out] byte[] buffer, int offset, int count) {
            if (buffer==null)
                throw new ArgumentNullException("buffer");
            if (offset < 0 || count < 0)
                throw new ArgumentOutOfRangeException((offset < 0 ? "offset" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - offset < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            if (!_canRead) __Error.ReadNotSupported();

            int hr = 0;
            int result = ReadFileNative(_handle, buffer, offset, count, 0, out hr);
            if (result == -1) {
                __Error.WinIOError(hr, String.Empty);
            }
            return result;
        }

        public override long Seek(long offset, SeekOrigin origin) {
            __Error.SeekNotSupported();
            return 0; // compiler appeasement
        }

        public override void Write(byte[] buffer, int offset, int count) {
            if (buffer==null)
                throw new ArgumentNullException("buffer");
            if (offset < 0 || count < 0)
                throw new ArgumentOutOfRangeException((offset < 0 ? "offset" : "count"), Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - offset < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            if (!_canWrite) __Error.WriteNotSupported();

            int hr = 0;
            int result = WriteFileNative(_handle, buffer, offset, count, 0, out hr);
            if (result == -1) {
                //BCLDebug.ConsoleError("__ConsoleStream::Write: throwing on error.  HR: "+hr+"  0x"+hr.ToString("x")+"  handle: "+_handle.ToString());
                __Error.WinIOError(hr, String.Empty);
            }
            return;
        }

        // P/Invoke wrappers for writing to and from a file, nearly identical
        // to the ones on FileStream.  These are duplicated to save startup/hello
        // world working set.
        internal unsafe static int ReadFileNative(IntPtr hFile, byte[] bytes, int offset, int count, int mustBeZero, out int hr)
        {
            BCLDebug.Assert(offset >= 0, "offset >= 0");
            BCLDebug.Assert(count >= 0, "count >= 0");
            BCLDebug.Assert(bytes != null, "bytes != null");

            // Don't corrupt memory when multiple threads are erroneously writing
            // to this stream simultaneously.
            if (bytes.Length - offset < count)
                throw new IndexOutOfRangeException(Environment.GetResourceString("IndexOutOfRange_IORaceCondition"));

            // You can't use the fixed statement on an array of length 0.
            if (bytes.Length==0) {
                hr = 0;
                return 0;
            }

            int r;
            int numBytesRead;
            fixed(byte* p = bytes) {
                r = ReadFile(hFile, p + offset, count, out numBytesRead, Win32Native.NULL);
            }
            if (r==0) {
                hr = Marshal.GetLastWin32Error();
                if (hr == ERROR_BROKEN_PIPE) {
                    // A pipe into stdin was closed.  Not an error, but EOF.
                    return 0;
                }
                return -1;
            }
            else
                hr = 0;
            return numBytesRead;
        }

        [DllImport(Win32Native.KERNEL32, SetLastError=true), SuppressUnmanagedCodeSecurityAttribute]
        unsafe internal static extern int ReadFile(IntPtr handle, byte* bytes, int numBytesToRead, out int numBytesRead, IntPtr mustBeZero);

        
        internal static unsafe int WriteFileNative(IntPtr hFile, byte[] bytes, int offset, int count, int mustBeZero, out int hr) {
            BCLDebug.Assert(offset >= 0, "offset >= 0");
            BCLDebug.Assert(count >= 0, "count >= 0");
            BCLDebug.Assert(bytes != null, "bytes != null");
            BCLDebug.Assert(bytes.Length >= offset + count, "bytes.Length >= offset + count");

            // You can't use the fixed statement on an array of length 0.
            if (bytes.Length==0) {
                hr = 0;
                return 0;
            }

            int numBytesWritten = 0;
            int r;
            fixed(byte* p = bytes) {
                r = WriteFile(hFile, p + offset, count, out numBytesWritten, Win32Native.NULL);
            }
            if (r==0) {
                hr = Marshal.GetLastWin32Error();
                // For pipes that are closing or broken, just stop.
                if (hr==ERROR_NO_DATA || hr==ERROR_BROKEN_PIPE)
                    return 0;
                return -1;
            }
            else {
                hr = 0;
            }
            return numBytesWritten;          
        }
        
        [DllImport(Win32Native.KERNEL32, SetLastError=true), SuppressUnmanagedCodeSecurityAttribute]
        internal static unsafe extern int WriteFile(IntPtr handle, byte* bytes, int numBytesToWrite, out int numBytesWritten, IntPtr mustBeZero);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\textreader.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  TextReader
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Abstract base class for all Text-only Readers.
** Subclasses will include StreamReader & StringReader.
**
** Date:  February 21, 2000
**
===========================================================*/

using System;
using System.Text;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Reflection;

namespace System.IO {
    // This abstract base class represents a reader that can read a sequential
    // stream of characters.  This is not intended for reading bytes -
    // there are methods on the Stream class to read bytes.
    // A subclass must minimally implement the Peek() and Read() methods.
    //
    // This class is intended for character input, not bytes.  
    // There are methods on the Stream class for reading bytes. 
    /// <include file='doc\TextReader.uex' path='docs/doc[@for="TextReader"]/*' />
    [Serializable()]
    public abstract class TextReader : MarshalByRefObject, IDisposable
    {
        /// <include file='doc\TextReader.uex' path='docs/doc[@for="TextReader.Null"]/*' />
        public static readonly TextReader Null = new NullTextReader();
    
        /// <include file='doc\TextReader.uex' path='docs/doc[@for="TextReader.TextReader"]/*' />
        protected TextReader() {}
    
        // Closes this TextReader and releases any system resources associated with the
        // TextReader. Following a call to Close, any operations on the TextReader
        // may raise exceptions.
        // 
        // This default method is empty, but descendant classes can override the
        // method to provide the appropriate functionality.
        /// <include file='doc\TextReader.uex' path='docs/doc[@for="TextReader.Close"]/*' />
        public virtual void Close() 
        {
            Dispose(true);
        }

        /// <include file='doc\TextReader.uex' path='docs/doc[@for="TextReader.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose()
        {
            Dispose(true);
        }

        /// <include file='doc\TextReader.uex' path='docs/doc[@for="TextReader.Dispose"]/*' />
        protected virtual void Dispose(bool disposing)
        {
        }

        // Returns the next available character without actually reading it from
        // the input stream. The current position of the TextReader is not changed by
        // this operation. The returned value is -1 if no further characters are
        // available.
        // 
        // This default method simply returns -1.
        //
        /// <include file='doc\TextReader.uex' path='docs/doc[@for="TextReader.Peek"]/*' />
        public virtual int Peek() 
        {
            return -1;
        }
    
        // Reads the next character from the input stream. The returned value is
        // -1 if no further characters are available.
        // 
        // This default method simply returns -1.
        //
        /// <include file='doc\TextReader.uex' path='docs/doc[@for="TextReader.Read"]/*' />
        public virtual int Read() 
        {
            return -1;
        }
    
        // Reads a block of characters. This method will read up to
        // count characters from this TextReader into the
        // buffer character array starting at position
        // index. Returns the actual number of characters read.
        //
        /// <include file='doc\TextReader.uex' path='docs/doc[@for="TextReader.Read1"]/*' />
        public virtual int Read([In, Out] char[] buffer, int index, int count) 
        {
            if (buffer==null)
                throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (index < 0)
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
            int n = 0;
            do {
                int ch = Read();
                if (ch == -1) break;
                buffer[index + n++] = (char)ch;
            } while (n < count);
            return n;
        }

        // Reads all characters from the current position to the end of the 
        // TextReader, and returns them as one string.
        /// <include file='doc\TextReader.uex' path='docs/doc[@for="TextReader.ReadToEnd"]/*' />
        public virtual String ReadToEnd()
        {
            char[] chars = new char[4096];
            int len;
            StringBuilder sb = new StringBuilder(4096);
            while((len=Read(chars, 0, chars.Length)) != 0) 
            {
                sb.Append(chars, 0, len);
            }
            return sb.ToString();
        }

        // Blocking version of read.  Returns only when count
        // characters have been read or the end of the file was reached.
        // 
        /// <include file='doc\TextReader.uex' path='docs/doc[@for="TextReader.ReadBlock"]/*' />
        public virtual int ReadBlock([In, Out] char[] buffer, int index, int count) 
        {
            int i, n = 0;
            do {
                n += (i = Read(buffer, index + n, count - n));
            } while (i > 0 && n < count);
            return n;
        }
        
        // Reads a line. A line is defined as a sequence of characters followed by
        // a carriage return ('\r'), a line feed ('\n'), or a carriage return
        // immediately followed by a line feed. The resulting string does not
        // contain the terminating carriage return and/or line feed. The returned
        // value is null if the end of the input stream has been reached.
        //
        /// <include file='doc\TextReader.uex' path='docs/doc[@for="TextReader.ReadLine"]/*' />
        public virtual String ReadLine() 
        {
            StringBuilder sb = new StringBuilder();
            while (true) {
                int ch = Read();
                if (ch == -1) break;
                if (ch == '\r' || ch == '\n') 
                {
                    if (ch == '\r' && Peek() == '\n') Read();
                    return sb.ToString();
                }
                sb.Append((char)ch);
            }
            if (sb.Length > 0) return sb.ToString();
            return null;
        }
        

        /// <include file='doc\TextReader.uex' path='docs/doc[@for="TextReader.Synchronized"]/*' />
        public static TextReader Synchronized(TextReader reader) 
        {
            if (reader==null)
                throw new ArgumentNullException("reader");
            if (reader is SyncTextReader)
                return reader;
            
            return new SyncTextReader(reader);
        }
        
        // No data, no need to serialize
        private class NullTextReader : TextReader
        {
            public override int Read(char[] buffer, int index, int count) 
            {
                return 0;
            }
            
            public override String ReadLine() 
            {
                return null;
            }
        }
        
        [Serializable()]
        internal class SyncTextReader : TextReader 
        {
            internal TextReader _in;
            
            internal SyncTextReader(TextReader t) 
            {
                _in = t;        
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Close() 
            {
                _in.Close();
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override int Peek() 
            {
                return _in.Peek();
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override int Read() 
            {
                return _in.Read();
            }       
    
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override int Read([In, Out] char[] buffer, int index, int count) 
            {
                return _in.Read(buffer, index, count);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override int ReadBlock(char[] buffer, int index, int count) 
            {
                return _in.ReadBlock(buffer, index, count);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override String ReadLine() 
            {
                return _in.ReadLine();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\stringreader.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  StringReader
**
** Author: Brian Grunkemeyer (BrianGru)
**         Original implementation by Anders Hejlsberg (AndersH)
**
** Purpose: For reading text from strings
**
** Date:  February 21, 2000
**
===========================================================*/

using System;
using System.Runtime.InteropServices;

namespace System.IO {
    // This class implements a text reader that reads from a string.
    //
    /// <include file='doc\StringReader.uex' path='docs/doc[@for="StringReader"]/*' />
	 [Serializable()]
    public class StringReader : TextReader
    {
        private String _s;
        private int _pos;
        private int _length;
    
        /// <include file='doc\StringReader.uex' path='docs/doc[@for="StringReader.StringReader"]/*' />
        public StringReader(String s) {
            if (s == null)
                throw new ArgumentNullException("s");
            _s = s;
            _length = s == null? 0: s.Length;
        }
    
        // Closes this StringReader. Following a call to this method, the String
        // Reader will throw an ObjectDisposedException.
        /// <include file='doc\StringReader.uex' path='docs/doc[@for="StringReader.Close"]/*' />
        public override void Close() {
            Dispose(true);
        }

        /// <include file='doc\StringReader.uex' path='docs/doc[@for="StringReader.Dispose"]/*' />
        protected override void Dispose(bool disposing) {
            _s = null;
            _pos = 0;
            _length = 0;
            base.Dispose(disposing);
        }
    
        // Returns the next available character without actually reading it from
        // the underlying string. The current position of the StringReader is not
        // changed by this operation. The returned value is -1 if no further
        // characters are available.
        //
        /// <include file='doc\StringReader.uex' path='docs/doc[@for="StringReader.Peek"]/*' />
        public override int Peek() {
            if (_s == null)
                __Error.ReaderClosed();
            if (_pos == _length) return -1;
            return _s[_pos];
        }
    
        // Reads the next character from the underlying string. The returned value
        // is -1 if no further characters are available.
        //
        /// <include file='doc\StringReader.uex' path='docs/doc[@for="StringReader.Read"]/*' />
        public override int Read() {
            if (_s == null)
                __Error.ReaderClosed();
            if (_pos == _length) return -1;
            return _s[_pos++];
        }
    
        // Reads a block of characters. This method will read up to count
        // characters from this StringReader into the buffer character
        // array starting at position index. Returns the actual number of
        // characters read, or zero if the end of the string is reached.
        //
        /// <include file='doc\StringReader.uex' path='docs/doc[@for="StringReader.Read1"]/*' />
        public override int Read([In, Out] char[] buffer, int index, int count) {
    		if (buffer==null)
    			throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
    		if (index < 0)
    			throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
    		if (count < 0)
    			throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            if (_s == null)
                __Error.ReaderClosed();
    
    		int n = _length - _pos;
            if (n > 0) {
                if (n > count) n = count;
                _s.CopyTo(_pos, buffer, index, n);
                _pos += n;
            }
            return n;
        }
    
        /// <include file='doc\StringReader.uex' path='docs/doc[@for="StringReader.ReadToEnd"]/*' />
        public override String ReadToEnd()
        {
            if (_s == null)
                __Error.ReaderClosed();
            String s;
            if (_pos==0)
                s = _s;
            else
                s = _s.Substring(_pos, _length - _pos);
            _pos = _length;
            return s;
        }

        // Reads a line. A line is defined as a sequence of characters followed by
        // a carriage return ('\r'), a line feed ('\n'), or a carriage return
        // immediately followed by a line feed. The resulting string does not
        // contain the terminating carriage return and/or line feed. The returned
        // value is null if the end of the underlying string has been reached.
        //
        /// <include file='doc\StringReader.uex' path='docs/doc[@for="StringReader.ReadLine"]/*' />
        public override String ReadLine() {
            if (_s == null)
                __Error.ReaderClosed();
            int i = _pos;
            while (i < _length) {
                char ch = _s[i];
                if (ch == '\r' || ch == '\n') {
                    String result = _s.Substring(_pos, i - _pos);
                    _pos = i + 1;
                    if (ch == '\r' && _pos < _length && _s[_pos] == '\n') _pos++;
                    return result;
                }
                i++;
            }
            if (i > _pos) {
                String result = _s.Substring(_pos, i - _pos);
                _pos = i;
                return result;
            }
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\textwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  TextWriter
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Abstract base class for Text-only Writers.
** Subclasses will include StreamWriter & StringWriter.
**
** Date:  February 21, 2000
**
===========================================================*/

using System;
using System.Text;
using System.Threading;
using System.Runtime.CompilerServices;
using System.Reflection;

namespace System.IO {
    // This abstract base class represents a writer that can write a sequential
    // stream of characters. A subclass must minimally implement the 
    // Write(char) method.
    //
    // This class is intended for character output, not bytes.  
    // There are methods on the Stream class for writing bytes. 
    /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter"]/*' />
    [Serializable]
    public abstract class TextWriter : MarshalByRefObject, IDisposable
    {
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Null"]/*' />
        public static readonly TextWriter Null = new NullTextWriter();

        // @TODO PORTING: This should be initialized to Environment.NewLine, but
        // we don't want to load Environment unnecessarily so I've duplicated
        // the value here.
        private const String InitialNewLine = "\r\n";

        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.CoreNewLine"]/*' />
        protected char[] CoreNewLine = InitialNewLine.ToCharArray();

        // Can be null - if so, ask for the Thread's CurrentCulture every time.
        private IFormatProvider InternalFormatProvider;

        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.TextWriter"]/*' />
        protected TextWriter()
        {
            InternalFormatProvider = null;  // Ask for CurrentCulture all the time.
        }
    
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.TextWriter1"]/*' />
        protected TextWriter(IFormatProvider formatProvider)
        {
            InternalFormatProvider = formatProvider;
        }

        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.FormatProvider"]/*' />
        public virtual IFormatProvider FormatProvider {
            get { 
                if (InternalFormatProvider == null)
                    return Thread.CurrentThread.CurrentCulture;
                else
                    return InternalFormatProvider;
            }
        }

        // Closes this TextWriter and releases any system resources associated with the
        // TextWriter. Following a call to Close, any operations on the TextWriter
        // may raise exceptions. This default method is empty, but descendant
        // classes can override the method to provide the appropriate
        // functionality.
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Close"]/*' />
        public virtual void Close() {
            Dispose(true);
        }

        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Dispose"]/*' />
        protected virtual void Dispose(bool disposing)
        {
        }


        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose()
        {
            Dispose(true);
        }
    
        // Clears all buffers for this TextWriter and causes any buffered data to be
        // written to the underlying device. This default method is empty, but
        // descendant classes can override the method to provide the appropriate
        // functionality.
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Flush"]/*' />
        public virtual void Flush() {
        }

        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Encoding"]/*' />
        public abstract Encoding Encoding {
            get;
        }

        // Returns the line terminator string used by this TextWriter. The default line
        // terminator string is a carriage return followed by a line feed ("\r\n").
        //
        // Sets the line terminator string for this TextWriter. The line terminator
        // string is written to the text stream whenever one of the
        // WriteLine methods are called. In order for text written by
        // the TextWriter to be readable by a TextReader, only one of the following line
        // terminator strings should be used: "\r", "\n", or "\r\n".
        // 
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.NewLine"]/*' />
        public virtual String NewLine {
            get { return new String(CoreNewLine); }
            set {
                if (value == null) 
                    value = InitialNewLine;
                CoreNewLine = value.ToCharArray();
            }
        }
    

        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Synchronized"]/*' />
        public static TextWriter Synchronized(TextWriter writer) {
            if (writer==null)
                throw new ArgumentNullException("writer");
            if (writer is SyncTextWriter)
                return writer;
            
            return new SyncTextWriter(writer);
        }
        
        // Writes a character to the text stream. This default method is empty,
        // but descendant classes can override the method to provide the
        // appropriate functionality.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write"]/*' />
        public virtual void Write(char value) {
        }
    
        // Writes a character array to the text stream. This default method calls
        // Write(char) for each of the characters in the character array.
        // If the character array is null, nothing is written.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write1"]/*' />
        public virtual void Write(char[] buffer) {
            if (buffer != null) Write(buffer, 0, buffer.Length);
        }
    
        // Writes a range of a character array to the text stream. This method will
        // write count characters of data into this TextWriter from the
        // buffer character array starting at position index.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write2"]/*' />
        public virtual void Write(char[] buffer, int index, int count) {
            if (buffer==null)
                throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (index < 0)
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
            for (int i = 0; i < count; i++) Write(buffer[index + i]);
        }
    
        // Writes the text representation of a boolean to the text stream. This
        // method outputs either Boolean.TrueString or Boolean.FalseString.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write3"]/*' />
        public virtual void Write(bool value) {
            Write(value ? Boolean.TrueString : Boolean.FalseString);
        }
    
        // Writes the text representation of an integer to the text stream. The
        // text representation of the given value is produced by calling the
        // Int32.ToString() method.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write4"]/*' />
        public virtual void Write(int value) {
            Write(value.ToString(FormatProvider));
        }
    
        // Writes the text representation of an integer to the text stream. The
        // text representation of the given value is produced by calling the
        // UInt32.ToString() method.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write5"]/*' />
        [CLSCompliant(false)]
        public virtual void Write(uint value) {
            Write(value.ToString(FormatProvider));
        }
    
        // Writes the text representation of a long to the text stream. The
        // text representation of the given value is produced by calling the
        // Int64.ToString() method.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write6"]/*' />
        public virtual void Write(long value) {
            Write(value.ToString(FormatProvider));
        }
    
        // Writes the text representation of an unsigned long to the text 
        // stream. The text representation of the given value is produced 
        // by calling the UInt64.ToString() method.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write7"]/*' />
        [CLSCompliant(false)]
        public virtual void Write(ulong value) {
            Write(value.ToString(FormatProvider));
        }
    
        // Writes the text representation of a float to the text stream. The
        // text representation of the given value is produced by calling the
        // Float.toString(float) method.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write8"]/*' />
        public virtual void Write(float value) {
            Write(value.ToString(FormatProvider));
        }
    
        // Writes the text representation of a double to the text stream. The
        // text representation of the given value is produced by calling the
        // Double.toString(double) method.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write9"]/*' />
        public virtual void Write(double value) {
            Write(value.ToString(FormatProvider));
        }
    
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write10"]/*' />
        public virtual void Write(Decimal value) {
            Write(value.ToString(FormatProvider));
        }
    
        // Writes a string to the text stream. If the given string is null, nothing
        // is written to the text stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write11"]/*' />
        public virtual void Write(String value) {
            if (value != null) Write(value.ToCharArray());
        }
    
        // Writes the text representation of an object to the text stream. If the
        // given object is null, nothing is written to the text stream.
        // Otherwise, the object's ToString method is called to produce the
        // string representation, and the resulting string is then written to the
        // output stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write12"]/*' />
        public virtual void Write(Object value) {
            if (value != null) {
                IFormattable f = value as IFormattable;
                if (f != null)
                    Write(f.ToString(null, FormatProvider));
                else
                    Write(value.ToString());
            }
        }
    
    //      // Converts the wchar * to a string and writes this to the stream.
    //      //
    //      __attribute NonCLSCompliantAttribute()
    //      public void Write(wchar *value) {
    //          Write(new String(value));
    //      }
    
    //      // Treats the byte* as a LPCSTR, converts it to a string, and writes it to the stream.
    //      // 
    //      __attribute NonCLSCompliantAttribute()
    //      public void Write(byte *value) {
    //          Write(new String(value));
    //      }
    
    
        // Writes out a formatted string.  Uses the same semantics as
        // String.Format.
        // 
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write13"]/*' />
        public virtual void Write(String format, Object arg0)
        {
            Write(String.Format(format, arg0));
        }
        
        // Writes out a formatted string.  Uses the same semantics as
        // String.Format.
        // 
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write14"]/*' />
        public virtual void Write(String format, Object arg0, Object arg1)
        {
            Write(String.Format(format, arg0, arg1));
        }
        
        // Writes out a formatted string.  Uses the same semantics as
        // String.Format.
        // 
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write15"]/*' />
        public virtual void Write(String format, Object arg0, Object arg1, Object arg2)
        {
            Write(String.Format(format, arg0, arg1, arg2));
        }
        
        // Writes out a formatted string.  Uses the same semantics as
        // String.Format.
        // 
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.Write16"]/*' />
        public virtual void Write(String format, params Object[] arg)
        {
            Write(String.Format(format, arg));
        }
        
    
        // Writes a line terminator to the text stream. The default line terminator
        // is a carriage return followed by a line feed ("\r\n"), but this value
        // can be changed by setting the NewLine property.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine"]/*' />
        public virtual void WriteLine() {
            Write(CoreNewLine);
        }
    
        // Writes a character followed by a line terminator to the text stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine1"]/*' />
        public virtual void WriteLine(char value) {
            Write(value);
            WriteLine();
        }
    
        // Writes an array of characters followed by a line terminator to the text
        // stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine2"]/*' />
        public virtual void WriteLine(char[] buffer) {
            Write(buffer);
            WriteLine();
        }
    
        // Writes a range of a character array followed by a line terminator to the
        // text stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine3"]/*' />
        public virtual void WriteLine(char[] buffer, int index, int count) {
            Write(buffer, index, count);
            WriteLine();
        }
    
        // Writes the text representation of a boolean followed by a line
        // terminator to the text stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine4"]/*' />
        public virtual void WriteLine(bool value) {
            Write(value);
            WriteLine();
        }
    
        // Writes the text representation of an integer followed by a line
        // terminator to the text stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine5"]/*' />
        public virtual void WriteLine(int value) {
            Write(value);
            WriteLine();
        }
    
        // Writes the text representation of an unsigned integer followed by 
        // a line terminator to the text stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine6"]/*' />
        [CLSCompliant(false)]
        public virtual void WriteLine(uint value) {
            Write(value);
            WriteLine();
        }
    
        // Writes the text representation of a long followed by a line terminator
        // to the text stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine7"]/*' />
        public virtual void WriteLine(long value) {
            Write(value);
            WriteLine();
        }
    
        // Writes the text representation of an unsigned long followed by 
        // a line terminator to the text stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine8"]/*' />
        [CLSCompliant(false)]
        public virtual void WriteLine(ulong value) {
            Write(value);
            WriteLine();
        }
    
        // Writes the text representation of a float followed by a line terminator
        // to the text stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine9"]/*' />
        public virtual void WriteLine(float value) {
            Write(value);
            WriteLine();
        }
    
        // Writes the text representation of a double followed by a line terminator
        // to the text stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine10"]/*' />
        public virtual void WriteLine(double value) {
            Write(value);
            WriteLine();
        }

        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine11"]/*' />
        public virtual void WriteLine(decimal value) {
            Write(value);
            WriteLine();
        }
    
        // Writes a string followed by a line terminator to the text stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine12"]/*' />
        public virtual void WriteLine(String value) {

            if (value==null) {
                WriteLine();
            }
            else {
                // We'd ideally like WriteLine to be atomic, in that one call
                // to WriteLine equals one call to the OS (ie, so writing to 
                // console while simultaneously calling printf will guarantee we
                // write out a string and new line chars, without any interference).
                // Additionally, we need to call ToCharArray on Strings anyways,
                // so allocating a char[] here isn't any worse than what we were
                // doing anyways.  We do reduce the number of calls to the 
                // backing store this way, potentially.
                int vLen = value.Length;
                int nlLen = CoreNewLine.Length;
                char[] chars = new char[vLen+nlLen];
                value.CopyTo(0, chars, 0, vLen);
                // CoreNewLine will almost always be 2 chars, and possibly 1.
                if (nlLen == 2) {
                    chars[vLen] = CoreNewLine[0];
                    chars[vLen+1] = CoreNewLine[1];
                }
                else if (nlLen == 1)
                    chars[vLen] = CoreNewLine[0];
                else
                    Buffer.InternalBlockCopy(CoreNewLine, 0, chars, vLen * 2, nlLen * 2);
                Write(chars, 0, vLen + nlLen);
            }
            /*
            Write(value);  // We could call Write(String) on StreamWriter...
            WriteLine();
            */
        }
    
        // Writes the text representation of an object followed by a line
        // terminator to the text stream.
        //
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine13"]/*' />
        public virtual void WriteLine(Object value) {
            if (value==null) {
                WriteLine();
            }
            else {
                // Call WriteLine(value.ToString), not Write(Object), WriteLine().
                // This makes calls to WriteLine(Object) atomic.
                IFormattable f = value as IFormattable;
                if (f != null)
                    WriteLine(f.ToString(null, FormatProvider));
                else
                    WriteLine(value.ToString());
            }
        }
    
    //      // Converts the wchar * to a string and writes this to the stream.
    //      //
    //      __attribute NonCLSCompliantAttribute()
    //      public void WriteLine(wchar *value) {
    //          Write(value);
    //          WriteLine();
    //      }
    
    //      // Treats the byte* as a LPCSTR, converts it to a string, and writes it to the stream.
    //      // 
    //      __attribute NonCLSCompliantAttribute()
    //      public void WriteLine(byte *value) {
    //          Write(value);
    //          WriteLine();
    //      }
    
        // Writes out a formatted string and a new line.  Uses the same 
        // semantics as String.Format.
        // 
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine14"]/*' />
        public virtual void WriteLine(String format, Object arg0)
        {
            WriteLine(String.Format(format, arg0));
        }
        
        // Writes out a formatted string and a new line.  Uses the same 
        // semantics as String.Format.
        // 
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine15"]/*' />
        public virtual void WriteLine (String format, Object arg0, Object arg1)
        {
            WriteLine(String.Format(format, arg0, arg1));
        }
        
        // Writes out a formatted string and a new line.  Uses the same 
        // semantics as String.Format.
        // 
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine16"]/*' />
        public virtual void WriteLine (String format, Object arg0, Object arg1, Object arg2)
        {
            WriteLine(String.Format(format, arg0, arg1, arg2));
        }
        
        // Writes out a formatted string and a new line.  Uses the same 
        // semantics as String.Format.
        // 
        /// <include file='doc\TextWriter.uex' path='docs/doc[@for="TextWriter.WriteLine17"]/*' />
        public virtual void WriteLine (String format, params Object[] arg)
        {
            WriteLine(String.Format(format, arg));
        }
        
        // No data, no need to serialize
        private sealed class NullTextWriter : TextWriter
        {
            public override Encoding Encoding {
                get { return Encoding.Default;  }
            }

            public override void Write(char[] buffer, int index, int count) {
            }
            
            public override void Write(String value) {
            }
        }
        
        [Serializable()]
        internal sealed class SyncTextWriter : TextWriter
        {
            private TextWriter _out;
            
            internal SyncTextWriter(TextWriter t) {
                _out = t;
            }

            public override Encoding Encoding {
                get { return _out.Encoding;  }
            }

            public override  String NewLine {
                [MethodImplAttribute(MethodImplOptions.Synchronized)]
                get { return _out.NewLine; }
                [MethodImplAttribute(MethodImplOptions.Synchronized)]
                set { _out.NewLine = value; }
            }
    
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Close() {
                _out.Close();
            }
    
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Flush() {
                _out.Flush();
            }
    
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(char value) {
                _out.Write(value);
            }
    
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(char[] buffer) {
                _out.Write(buffer);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(char[] buffer, int index, int count) {
                _out.Write(buffer, index, count);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(bool value) {
                _out.Write(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(int value) {
                _out.Write(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized), CLSCompliant(false)]
            public override void Write(uint value) {
                _out.Write(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(long value) {
                _out.Write(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized), CLSCompliant(false)]
            public override void Write(ulong value) {
                _out.Write(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(float value) {
                _out.Write(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(double value) {
                _out.Write(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(String value) {
                _out.Write(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(Object value) {
                _out.Write(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(String format, Object arg0) {
                _out.Write(format, arg0);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(String format, Object arg0, Object arg1) {
                _out.Write(format, arg0, arg1);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(String format, Object arg0, Object arg1, Object arg2) {
                _out.Write(format, arg0, arg1, arg2);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void Write(String format, Object[] arg) {
                _out.Write(format, arg);
            }
    
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(char value) {
                _out.WriteLine(value);
            }
    
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(char[] buffer) {
                _out.WriteLine(buffer);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(char[] buffer, int index, int count) {
                _out.WriteLine(buffer, index, count);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(bool value) {
                _out.WriteLine(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(int value) {
                _out.WriteLine(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized), CLSCompliant(false)]
            public override void WriteLine(uint value) {
                _out.WriteLine(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(long value) {
                _out.WriteLine(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized), CLSCompliant(false)]
            public override void WriteLine(ulong value) {
                _out.WriteLine(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(float value) {
                _out.WriteLine(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(double value) {
                _out.WriteLine(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(String value) {
                _out.WriteLine(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(Object value) {
                _out.WriteLine(value);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(String format, Object arg0) {
                _out.WriteLine(format, arg0);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(String format, Object arg0, Object arg1) {
                _out.WriteLine(format, arg0, arg1);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(String format, Object arg0, Object arg1, Object arg2) {
                _out.WriteLine(format, arg0, arg1, arg2);
            }
            
            [MethodImplAttribute(MethodImplOptions.Synchronized)]
            public override void WriteLine(String format, Object[] arg) {
                _out.WriteLine(format, arg);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\streamwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  StreamWriter
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: For writing text to streams in a particular 
** encoding.
**
** Date:  February 21, 2000
**
===========================================================*/
using System;
using System.Text;

namespace System.IO {
    // This class implements a TextWriter for writing characters to a Stream.
    // This is designed for character output in a particular Encoding, 
    // whereas the Stream class is designed for byte input and output.  
    // 
    /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter"]/*' />
    [Serializable]
    public class StreamWriter : TextWriter
    {
        // For UTF-8, the values of 1K for the default buffer size and 4K for the
        // file stream buffer size are reasonable & give very reasonable
        // performance for in terms of construction time for the StreamWriter and
        // write perf.  Note that for UTF-8, we end up allocating a 4K byte buffer,
        // which means we take advantage of Anders' adaptive buffering code.
        // The performance using UnicodeEncoding is acceptable.  -- Brian 7/9/2001
        private const int DefaultBufferSize = 1024;   // char[]
        private const int DefaultFileStreamBufferSize = 4096;
        private const int MinBufferSize = 128;
    
        // Bit bucket - Null has no backing store.
        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.Null"]/*' />
        public new static readonly StreamWriter Null = new StreamWriter(Stream.Null, new UTF8Encoding(false, true), 128);
        
        internal Stream stream;
        private Encoding encoding;
        private Encoder encoder;
        internal byte[] byteBuffer;
        internal char[] charBuffer;
        internal int charPos;
        internal int charLen;
        internal bool autoFlush;
        private bool haveWrittenPreamble;
        private bool closable;  // For Console.Out - should Finalize call Dispose?

#if _DEBUG
        private String allocatedFrom = String.Empty;
#endif

        internal StreamWriter() {
        }
        
        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.StreamWriter"]/*' />
        public StreamWriter(Stream stream) 
            : this(stream, new UTF8Encoding(false, true), DefaultBufferSize) {
        }
    
        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.StreamWriter1"]/*' />
        public StreamWriter(Stream stream, Encoding encoding) 
            : this(stream, encoding, DefaultBufferSize) {
        }
        
        // Creates a new StreamWriter for the given stream.  The 
        // character encoding is set by encoding and the buffer size, 
        // in number of 16-bit characters, is set by bufferSize.  
        // 
        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.StreamWriter2"]/*' />
        public StreamWriter(Stream stream, Encoding encoding, int bufferSize) {
            if (stream==null || encoding==null)
                throw new ArgumentNullException((stream==null ? "stream" : "encoding"));
            if (!stream.CanWrite)
                throw new ArgumentException(Environment.GetResourceString("Argument_StreamNotWritable"));
            if (bufferSize <= 0) throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_NeedPosNum"));

            Init(stream, encoding, bufferSize);
        }
    
        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.StreamWriter3"]/*' />
        public StreamWriter(String path) 
            : this(path, false, new UTF8Encoding(false, true), DefaultBufferSize) {
        }
    
        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.StreamWriter4"]/*' />
        public StreamWriter(String path, bool append) 
            : this(path, append, new UTF8Encoding(false, true), DefaultBufferSize) {
        }
    
        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.StreamWriter5"]/*' />
        public StreamWriter(String path, bool append, Encoding encoding) 
            : this(path, append, encoding, DefaultBufferSize) {
        }
    
        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.StreamWriter6"]/*' />
        public StreamWriter(String path, bool append, Encoding encoding, int bufferSize) {
            if (path==null || encoding==null)
                throw new ArgumentNullException((path==null ? "path" : "encoding"));
            if (bufferSize <= 0) throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_NeedPosNum"));
            
            Stream stream = CreateFile(path, append);
            Init(stream, encoding, bufferSize);
        }

        private void Init(Stream stream, Encoding encoding, int bufferSize)
        {
            this.stream = stream;
            this.encoding = encoding;
            this.encoder = encoding.GetEncoder();
            if (bufferSize < MinBufferSize) bufferSize = MinBufferSize;
            charBuffer = new char[bufferSize];
            byteBuffer = new byte[encoding.GetMaxByteCount(bufferSize)];
            charLen = bufferSize;
            // If we're appending to a Stream that already has data, don't write
            // the preamble junk.
            if (stream.CanSeek && stream.Position > 0)
                haveWrittenPreamble = true;
            closable = true;
#if _DEBUG
            if (BCLDebug.CorrectnessEnabled())
                allocatedFrom = Environment.GetStackTrace(null);
#endif
        }

        private static Stream CreateFile(String path, bool append) {
            FileMode mode = append? FileMode.Append: FileMode.Create;
            FileStream f = new FileStream(path, mode, FileAccess.Write, FileShare.Read, DefaultFileStreamBufferSize);
            return f;
        }
    

        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.Close"]/*' />
        public override void Close() {
            Dispose(true);
        }

        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.Dispose"]/*' />
        protected override void Dispose(bool disposing) {
            // Dispose of our resources if this StreamWriter is closable.
            // Note that Console.Out should not be closable.
            if (disposing) {
                if (stream != null) {
                    Flush(true, true);
                    if (Closable)
                        stream.Close();
                }
            }
            if (Closable && stream != null) {
                stream = null;
                byteBuffer = null;
                charBuffer = null;
                encoding = null;
                encoder = null;
                charLen = 0;
                base.Dispose(disposing);
            }
        }

        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.Finalize"]/*' />
        ~StreamWriter()
        {
            // Make sure people closed this StreamWriter, but of course, make
            // allowances for BufferedStream (used by Console.Out & Error) and
            // StreamWriter::Null.
#if _DEBUG
            BCLDebug.Correctness(charPos == 0, "You didn't close a StreamWriter, and you lost data!\r\nStream type: "+(stream==null ? "<null>" : stream.GetType().FullName)+((stream != null && stream is FileStream) ? "  File name: "+((FileStream)stream).NameInternal : "")+"\r\nAllocated from:\r\n"+allocatedFrom);
#endif
            Dispose(false);
        }

        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.Flush"]/*' />
        public override void Flush() {
            Flush(true, true);
        }
    
        private void Flush(bool flushStream, bool flushEncoder) {
            // flushEncoder should be true at the end of the file and if
            // the user explicitly calls Flush (though not if AutoFlush is true).
            // This is required to flush any dangling characters from our UTF-7 
            // and UTF-8 encoders.  
            if (stream == null)
                __Error.WriterClosed();

            // Perf boost for Flush on non-dirty writers.
            if (charPos==0 && !flushStream && !flushEncoder)
                return;

            if (!haveWrittenPreamble) {
                haveWrittenPreamble = true;
                byte[] preamble = encoding.GetPreamble();
                if (preamble.Length > 0)
                    stream.Write(preamble, 0, preamble.Length);
            }

            int count = encoder.GetBytes(charBuffer, 0, charPos, byteBuffer, 0, flushEncoder);
            charPos = 0;
            if (count > 0)
                stream.Write(byteBuffer, 0, count);
            // By definition, calling Flush should flush the stream, but this is
            // only necessary if we passed in true for flushStream.  The Web
            // Services guys have some perf tests where flushing needlessly hurts.
            if (flushStream)
                stream.Flush();
        }
    
        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.AutoFlush"]/*' />
        public virtual bool AutoFlush {
            get { return autoFlush; }
            set {
                autoFlush = value;
                if (value) Flush(true, false);
            }
        }
    
        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.BaseStream"]/*' />
        public virtual Stream BaseStream {
            get { return stream; }
        }

        internal bool Closable {
            get { return closable; }
            set { closable = value; }
        }

        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.Encoding"]/*' />
        public override Encoding Encoding {
            get { return encoding; }
        }

        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.Write"]/*' />
        public override void Write(char value) {
            if (charPos == charLen) Flush(false, false);
            charBuffer[charPos++] = value;
            if (autoFlush) Flush(true, false);
        }
    
        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.Write1"]/*' />
        public override void Write(char[] buffer)
        {
            // This may be faster than the one with the index & count since it
            // has to do less argument checking.
            if (buffer==null)
                return;
            int index = 0;
            int count = buffer.Length;
            while (count > 0) {
                if (charPos == charLen) Flush(false, false);
                int n = charLen - charPos;
                if (n > count) n = count;
                BCLDebug.Assert(n > 0, "StreamWriter::Write(char[]) isn't making progress!  This is most likely a race in user code.");
                Buffer.InternalBlockCopy(buffer, index*2, charBuffer, charPos*2, n*2);
                charPos += n;
                index += n;
                count -= n;
            }
            if (autoFlush) Flush(true, false);
        }


        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.Write2"]/*' />
        public override void Write(char[] buffer, int index, int count) {
            if (buffer==null)
                throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (index < 0)
                throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
            while (count > 0) {
                if (charPos == charLen) Flush(false, false);
                int n = charLen - charPos;
                if (n > count) n = count;
                BCLDebug.Assert(n > 0, "StreamWriter::Write(char[], int, int) isn't making progress!  This is most likely a race condition in user code.");
                Buffer.InternalBlockCopy(buffer, index*2, charBuffer, charPos*2, n*2);
                charPos += n;
                index += n;
                count -= n;
            }
            if (autoFlush) Flush(true, false);
        }
    
        /// <include file='doc\StreamWriter.uex' path='docs/doc[@for="StreamWriter.Write3"]/*' />
        public override void Write(String value) {
            if (value != null) {
                int count = value.Length;
                int index = 0;
                while (count > 0) {
                    if (charPos == charLen) Flush(false, false);
                    int n = charLen - charPos;
                    if (n > count) n = count;
                    BCLDebug.Assert(n > 0, "StreamWriter::Write(String) isn't making progress!  This is most likely a race condition in user code.");
                    value.CopyTo(index, charBuffer, charPos, n);
                    charPos += n;
                    index += n;
                    count -= n;
                }
                if (autoFlush) Flush(true, false);
            }
        }

        /*
        // This method is more efficient for long strings outputted to streams 
        // than the one on TextWriter, and won't cause any problems in terms of
        // hiding methods on TextWriter as long as languages respect the 
        // hide-by-name-and-sig metadata flag.
        public override void WriteLine(String value) {
            if (value != null) {
                int count = value.Length;
                int index = 0;
                while (count > 0) {
                    if (charPos == charLen) Flush(false);
                    int n = charLen - charPos;
                    if (n > count) n = count;
                    BCLDebug.Assert(n > 0, "StreamWriter::WriteLine(String) isn't making progress!  This is most likely a race condition in user code.");
                    value.CopyTo(index, charBuffer, charPos, n);
                    charPos += n;
                    index += n;
                    count -= n;
                }
            }
            if (charPos >= charLen - 2) Flush(false);
            Buffer.InternalBlockCopy(CoreNewLine, 0, charBuffer, charPos*2, CoreNewLine.Length * 2);
            charPos += CoreNewLine.Length;
            if (autoFlush) Flush(true, false);
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\stringwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  StringWriter
**
** Author: Brian Grunkemeyer (BrianGru)
**         Original implementation by Anders Hejlsberg (AndersH)
**
** Purpose: For writing text to a string
**
** Date:  February 21, 2000
**
===========================================================*/

using System;
using System.Text;

namespace System.IO {
    // This class implements a text writer that writes to a string buffer and allows
    // the resulting sequence of characters to be presented as a string.
    //
    /// <include file='doc\StringWriter.uex' path='docs/doc[@for="StringWriter"]/*' />
    [Serializable]
    public class StringWriter : TextWriter
    {
        private static UnicodeEncoding m_encoding=null;

        private StringBuilder _sb;
        private bool _isOpen;

        // Constructs a new StringWriter. A new StringBuilder is automatically
        // created and associated with the new StringWriter.
        /// <include file='doc\StringWriter.uex' path='docs/doc[@for="StringWriter.StringWriter"]/*' />
        public StringWriter() 
            : this(new StringBuilder()) {
        }

        /// <include file='doc\StringWriter.uex' path='docs/doc[@for="StringWriter.StringWriter2"]/*' />
        public StringWriter(IFormatProvider formatProvider) 
            : this(new StringBuilder(), formatProvider) {
        }
    
        // Constructs a new StringWriter that writes to the given StringBuilder.
        // 
        /// <include file='doc\StringWriter.uex' path='docs/doc[@for="StringWriter.StringWriter1"]/*' />
        public StringWriter(StringBuilder sb) : this(sb, null) {
        }

        /// <include file='doc\StringWriter.uex' path='docs/doc[@for="StringWriter.StringWriter3"]/*' />
        public StringWriter(StringBuilder sb, IFormatProvider formatProvider) : base(formatProvider) {
    		if (sb==null)
    			throw new ArgumentNullException("sb", Environment.GetResourceString("ArgumentNull_Buffer"));
            _sb = sb;
            _isOpen = true;
        }

        /// <include file='doc\StringWriter.uex' path='docs/doc[@for="StringWriter.Close"]/*' />
        public override void Close()
        {
            Dispose(true);
        }

        /// <include file='doc\StringWriter.uex' path='docs/doc[@for="StringWriter.Dispose"]/*' />
        protected override void Dispose(bool disposing)
        {
            // Do not destroy _sb, so that we can extract this after we are
            // done writing (similar to MemoryStream's GetBuffer & ToArray methods)
            _isOpen = false;
            base.Dispose(disposing);
        }


        /// <include file='doc\StringWriter.uex' path='docs/doc[@for="StringWriter.Encoding"]/*' />
        public override Encoding Encoding {
            get { 
                if (m_encoding==null) {
                    m_encoding = new UnicodeEncoding(false, false);
                }
                return m_encoding; 
            }
        }

        // Returns the underlying StringBuilder. This is either the StringBuilder
        // that was passed to the constructor, or the StringBuilder that was
        // automatically created.
        //
        /// <include file='doc\StringWriter.uex' path='docs/doc[@for="StringWriter.GetStringBuilder"]/*' />
        public virtual StringBuilder GetStringBuilder() {
            return _sb;
        }
    
        // Writes a character to the underlying string buffer.
        //
        /// <include file='doc\StringWriter.uex' path='docs/doc[@for="StringWriter.Write"]/*' />
        public override void Write(char value) {
            if (!_isOpen)
                __Error.WriterClosed();
            _sb.Append(value);
        }
    
        // Writes a range of a character array to the underlying string buffer.
        // This method will write count characters of data into this
        // StringWriter from the buffer character array starting at position
        // index.
        //
        /// <include file='doc\StringWriter.uex' path='docs/doc[@for="StringWriter.Write1"]/*' />
        public override void Write(char[] buffer, int index, int count) {
            if (!_isOpen)
                __Error.WriterClosed();
    		if (buffer==null)
    			throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
    		if (index < 0)
    			throw new ArgumentOutOfRangeException("index", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
    		if (count < 0)
    			throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - index < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
    
    		_sb.Append(buffer, index, count);
        }
    
        // Writes a string to the underlying string buffer. If the given string is
        // null, nothing is written.
        //
        /// <include file='doc\StringWriter.uex' path='docs/doc[@for="StringWriter.Write2"]/*' />
        public override void Write(String value) {
            if (!_isOpen)
                __Error.WriterClosed();
            if (value != null) _sb.Append(value);
        }
    
        // Returns a string containing the characters written to this TextWriter
        // so far.
        //
        /// <include file='doc\StringWriter.uex' path='docs/doc[@for="StringWriter.ToString"]/*' />
        public override String ToString() {
            return _sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\__error.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  __Error
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Centralized error methods for the IO package.  
** Mostly useful for translating Win32 HRESULTs into meaningful
** error strings & exceptions.
**
** Date:  February 15, 2000
**
===========================================================*/

using System;
using System.Runtime.InteropServices;
using Win32Native = Microsoft.Win32.Win32Native;
using System.Text;

namespace System.IO {
    // Only static data no need to serialize
    internal sealed class __Error
    {
        private __Error() {
        }
    
        internal static void EndOfFile() {
            throw new EndOfStreamException(Environment.GetResourceString("IO.EOF_ReadBeyondEOF"));
        }
    
        private static String GetMessage(int errorCode) {
            StringBuilder sb = new StringBuilder(512);
            int result = Win32Native.FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS |
                FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                Win32Native.NULL, errorCode, 0, sb, sb.Capacity, Win32Native.NULL);
            if (result != 0) {
                // result is the # of characters copied to the StringBuilder on NT,
                // but on Win9x, it appears to be the number of MBCS bytes.
                // Just give up and return the String as-is...
                String s = sb.ToString();
                return s;
            }
            else {
                return Environment.GetResourceString("IO_UnknownError", errorCode);
            }
        }

        internal static void FileNotOpen() {
            throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_FileClosed"));
        }

        internal static void StreamIsClosed() {
            throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_StreamClosed"));
        }
    
        internal static void MemoryStreamNotExpandable() {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_MemStreamNotExpandable"));
        }
    
        internal static void ReaderClosed() {
            throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_ReaderClosed"));
        }

        internal static void ReadNotSupported() {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnreadableStream"));
        }
    
        internal static void SeekNotSupported() {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnseekableStream"));
        }

        internal static void WrongAsyncResult() {
            throw new ArgumentException(Environment.GetResourceString("Arg_WrongAsyncResult"));
        }

        internal static void EndReadCalledTwice() {
            throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EndReadCalledMultiple"));
        }

        internal static void EndWriteCalledTwice() {
            throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EndWriteCalledMultiple"));
        }

        internal static void WinIOError() {
            int errorCode = Marshal.GetLastWin32Error();
            WinIOError(errorCode, String.Empty);
        }
    
        // After calling GetLastWin32Error(), it clears the last error field,
        // so you must save the HResult and pass it to this method.  This method
        // will determine the appropriate exception to throw dependent on your 
        // error, and depending on the error, insert a string into the message 
        // gotten from the ResourceManager.
        internal static void WinIOError(int errorCode, String str) {
            switch (errorCode) {
            case Win32Native.ERROR_FILE_NOT_FOUND:
                if (str.Length == 0)
                    throw new FileNotFoundException(Environment.GetResourceString("IO.FileNotFound"));
                else
                    throw new FileNotFoundException(String.Format(Environment.GetResourceString("IO.FileNotFound_FileName"), str), str);
                
            case Win32Native.ERROR_PATH_NOT_FOUND:
                if (str.Length == 0)
                    throw new DirectoryNotFoundException(Environment.GetResourceString("IO.PathNotFound_NoPathName"));
                else
                    throw new DirectoryNotFoundException(String.Format(Environment.GetResourceString("IO.PathNotFound_Path"), str));

            case Win32Native.ERROR_ACCESS_DENIED:
                if (str.Length == 0)
                    throw new UnauthorizedAccessException(Environment.GetResourceString("UnauthorizedAccess_IODenied_NoPathName"));
                else
                    throw new UnauthorizedAccessException(String.Format(Environment.GetResourceString("UnauthorizedAccess_IODenied_Path"), str));

            case Win32Native.ERROR_FILENAME_EXCED_RANGE:
                throw new PathTooLongException(Environment.GetResourceString("IO.PathTooLong"));

            case Win32Native.ERROR_INVALID_PARAMETER:
                //BCLDebug.Assert(false, "Got an invalid parameter HRESULT from an IO method (this is ignorable, but send a simple repro to BrianGru)");
                throw new IOException(GetMessage(errorCode), Win32Native.MakeHRFromErrorCode(errorCode));

            case Win32Native.ERROR_SHARING_VIOLATION:
                  // error message.
                if (str.Length == 0)
                    throw new IOException(Environment.GetResourceString("IO.IO_SharingViolation_NoFileName"));
                else
                    throw new IOException(Environment.GetResourceString("IO.IO_SharingViolation_File", str));

            case Win32Native.ERROR_FILE_EXISTS:
                if (str.Length == 0)
                    goto default;
                throw new IOException(String.Format(Environment.GetResourceString("IO.IO_FileExists_Name"), str));

            default:
                throw new IOException(GetMessage(errorCode), Win32Native.MakeHRFromErrorCode(errorCode));
            }
        }
    
        internal static void WriteNotSupported() {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnwritableStream"));
        }

        internal static void WriterClosed() {
            throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_WriterClosed"));
        }

        private const int FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200;
        private const int FORMAT_MESSAGE_FROM_SYSTEM    = 0x00001000;
        private const int FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000;

        // From WinError.h
        internal const int ERROR_FILE_NOT_FOUND = Win32Native.ERROR_FILE_NOT_FOUND;
        internal const int ERROR_PATH_NOT_FOUND = Win32Native.ERROR_PATH_NOT_FOUND;
        internal const int ERROR_ACCESS_DENIED  = Win32Native.ERROR_ACCESS_DENIED;
        internal const int ERROR_INVALID_PARAMETER = Win32Native.ERROR_INVALID_PARAMETER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\__unmanagedmemorystream.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  __UnmanagedMemoryStream
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Create a stream over unmanaged memory, mostly
**          useful for memory-mapped .resources files.
**
** Date:  October 20, 2000
**
===========================================================*/
using System;
using System.Runtime.InteropServices;

namespace System.IO {

    /*
     * This class is used to access a block of bytes in memory, likely outside 
     * the GC heap (or pinned in place in the GC heap, but a MemoryStream may 
     * make more sense in those cases).  It's great if you have a pointer and
     * a length for a section of memory mapped in by someone else and you don't
     * want to copy this into the GC heap.  UnmanagedMemoryStream assumes these 
     * two things:
     *
     * 1) All the memory in the specified block is readable (and potentially 
     *    writable).
     * 2) The lifetime of the block of memory is at least as long as the lifetime
     *    of the UnmanagedMemoryStream.
     * 3) You clean up the memory when appropriate.  The UnmanagedMemoryStream 
     *    currently will do NOTHING to free this memory.
     * 4) All calls to Write and WriteByte may not be threadsafe currently.
     *    (In V1, we don't use this class anywhere where this would be a 
     *    problem since it's generally read-only, but perhaps we should make 
     *    sure this class can't corrupt memory badly in V2.)
     *
     * In V2, it may become necessary to add in some sort of DeallocationMode
     * enum, specifying whether we unmap a section of memory, call free, run a 
     * user-provided delegate to free the memory, etc etc.  The lack of knowing 
     * exactly what we need to do to free memory is an excellent reason to keep 
     * this class internal in V1, besides the obvious security concerns.
     * 
     * Note: feel free to make this class not sealed if necessary.
     */
    [CLSCompliant(false)]
    internal sealed class __UnmanagedMemoryStream : Stream
    {
        private const long MemStreamMaxLength = Int32.MaxValue;

        private unsafe byte* _mem;
        // BUGBUG: Make UnmanagedMemoryStream use longs internally.  However,
        // this may expose some JIT bugs.
        private int _length;
        private int _capacity;
        private int _position;
        private bool _writable;
        private bool _isOpen;

        internal unsafe __UnmanagedMemoryStream(byte* memory, long length, long capacity, bool canWrite) 
        {
            BCLDebug.Assert(memory != null, "Expected a non-zero address to start reading from!");
            BCLDebug.Assert(length <= capacity, "Length was greater than the capacity!");

            _mem = memory;
            _length = (int)length;
            _capacity = (int)capacity;
            _writable = canWrite;
            _isOpen = true;
        }

        public override bool CanRead {
            get { return _isOpen; }
        }

        public override bool CanSeek {
            get { return _isOpen; }
        }

        public override bool CanWrite {
            get { return _writable; }
        }

        public unsafe override void Close()
        {
            _isOpen = false;
            _writable = false;
            _mem = null;
        }

        public override void Flush() {
        }

        public override long Length {
            get {
                if (!_isOpen) __Error.StreamIsClosed();
                return _length;
            }
        }

        public override long Position {
            get { 
                if (!_isOpen) __Error.StreamIsClosed();
                return _position;
            }
            set {
                if (!_isOpen) __Error.StreamIsClosed();
                if (value < 0)
                    throw new ArgumentOutOfRangeException("value", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                _position = (int)value;
            }
        }

        public unsafe byte* GetBytePtr()
        {
            int pos = _position;  // Use a temp to avoid a race
            if (pos > _capacity)
                throw new IndexOutOfRangeException(Environment.GetResourceString("IndexOutOfRange_UMSPosition"));
            byte * p = _mem + pos;
            if (!_isOpen) __Error.StreamIsClosed();
            return p;
        }

        public override unsafe int Read([In, Out] byte[] buffer, int offset, int count) {
            if (!_isOpen) __Error.StreamIsClosed();
            if (buffer==null)
                throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (offset < 0)
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - offset < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            // Use a local variable to avoid a race where another thread 
            // changes our position after we decide we can read some bytes.
            int pos = _position;
            int n = _length - pos;
            if (n > count) n = count;
            if (n < 0) n = 0;  // _position could be beyond EOF
            BCLDebug.Assert(pos + n >= 0, "_position + n >= 0");  // len is less than 2^31 -1.

            memcpy(_mem, pos, buffer, offset, n);
            _position = pos + n;
            return n;
        }

        public override unsafe int ReadByte() {
            if (!_isOpen) __Error.StreamIsClosed();
            int pos = _position;  // Use a local to avoid a race condition
            if (pos >= _length) return -1;
            _position = pos + 1;
            return _mem[pos];
        }

        public override unsafe long Seek(long offset, SeekOrigin loc) {
            if (!_isOpen) __Error.StreamIsClosed();
            if (offset > MemStreamMaxLength)
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_MemStreamLength"));
            switch(loc) {
            case SeekOrigin.Begin:
                if (offset < 0)
                    throw new IOException(Environment.GetResourceString("IO.IO_SeekBeforeBegin"));
                _position = (int)offset;
                break;
                
            case SeekOrigin.Current:
                if (offset + _position < 0)
                    throw new IOException(Environment.GetResourceString("IO.IO_SeekBeforeBegin"));
                _position += (int)offset;
                break;
                
            case SeekOrigin.End:
                if (_length + offset < 0)
                    throw new IOException(Environment.GetResourceString("IO.IO_SeekBeforeBegin"));
                _position = _length + (int)offset;
                break;
                
            default:
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidSeekOrigin"));
            }

            BCLDebug.Assert(_position >= 0, "_position >= 0");
            return _position;
        }

        public override void SetLength(long value) {
            if (!_writable) __Error.WriteNotSupported();
            if (value > _capacity)
                throw new IOException(Environment.GetResourceString("IO.IO_FixedCapacity"));
            _length = (int) value;
            if (_position > value) _position = (int) value;
        }

        public override unsafe void Write(byte[] buffer, int offset, int count) {
            if (!_isOpen) __Error.StreamIsClosed();
            if (!_writable) __Error.WriteNotSupported();
            if (buffer==null)
                throw new ArgumentNullException("buffer", Environment.GetResourceString("ArgumentNull_Buffer"));
            if (offset < 0)
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - offset < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            int pos = _position;  // Use a local to avoid a race condition
            int n = pos + count;
            // Check for overflow
            if (n < 0)
                throw new IOException(Environment.GetResourceString("IO.IO_StreamTooLong"));

            if (n > _length) {
                if (n > _capacity)
                    throw new IOException(Environment.GetResourceString("IO.IO_FixedCapacity"));
                _length = n;
            }
            memcpy(buffer, offset, _mem, pos, count);
            _position = n;
            return;
        }

        public override unsafe void WriteByte(byte value) {
            if (!_isOpen) __Error.StreamIsClosed();
            if (!_writable) __Error.WriteNotSupported();
            int pos = _position;  // Use a local to avoid a race condition
            if (pos == _length) {
                if (pos + 1 > _capacity)
                    throw new IOException(Environment.GetResourceString("IO.IO_FixedCapacity"));
                _length++;
            }
            _mem[pos] = value;
            _position = pos + 1;
        }


        internal unsafe static void memcpy(byte* src, int srcIndex, byte[] dest, int destIndex, int len) {
            BCLDebug.Assert(dest.Length - destIndex >= len, "not enough bytes in dest");
            // If dest has 0 elements, the fixed statement will throw an 
            // IndexOutOfRangeException.  Special-case 0-byte copies.
            if (len==0)
                return;
            fixed(byte* pDest = dest) {
                memcpyimpl(src+srcIndex, pDest+destIndex, len);
            }
        }

        internal unsafe static void memcpy(byte[] src, int srcIndex, byte* dest, int destIndex, int len) {
            BCLDebug.Assert(src.Length - srcIndex >= len, "not enough bytes in src");
            // If src has 0 elements, the fixed statement will throw an 
            // IndexOutOfRangeException.  Special-case 0-byte copies.
            if (len==0)
                return;
            fixed(byte* pSrc = src) {
                memcpyimpl(pSrc+srcIndex, dest+destIndex, len);
            }
        }

        internal unsafe static void memcpyimpl(byte* src, byte* dest, int len) {
            BCLDebug.Assert(len >= 0, "Negative length in memcopy!");
            // Naive implementation for testing
            /*
            while (len-- > 0)
                *dest++ = *src++;
            */
            
            // This is Peter Sollich's faster memcpy implementation, from 
            // COMString.cpp.  For our strings, this beat the processor's 
            // repeat & move single byte instruction, which memcpy expands into.  
            // (You read that correctly.)
            // This is 3x faster than a simple while loop copying byte by byte, 
            // for large copies.
            if (len >= 16) {
                do {
                    ((int*)dest)[0] = ((int*)src)[0];
                    ((int*)dest)[1] = ((int*)src)[1];
                    ((int*)dest)[2] = ((int*)src)[2];
                    ((int*)dest)[3] = ((int*)src)[3];
                    dest += 16;
                    src += 16;
                } while ((len -= 16) >= 16);
            }
            if(len > 0)  // protection against negative len and optimization for len==16*N
            {
               if ((len & 8) != 0) {
                   ((int*)dest)[0] = ((int*)src)[0];
                   ((int*)dest)[1] = ((int*)src)[1];
                   dest += 8;
                   src += 8;
               }
               if ((len & 4) != 0) {
                   ((int*)dest)[0] = ((int*)src)[0];
                   dest += 4;
                   src += 4;
               }
               if ((len & 2) != 0) {
                   ((short*)dest)[0] = ((short*)src)[0];
                   dest += 2;
                   src += 2;
               }
               if ((len & 1) != 0)
                   *dest++ = *src++;
            }
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\isolatedstorage\inormalizeforisolatedstorage.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Class:  INormalizeForIsolatedStorage
 *
 * Author: Shajan Dasan
 *
 * Purpose: Evidence types can optionaly implement this interface.
 *          IsolatedStorage calls Normalize method before evidence
 *          is serialized. The Normalize method should return a copy
 *          of the evidence instance if any of it's fields is changed.
 *
 * Date:  Oct 17, 2000
 *
 ===========================================================*/
namespace System.IO.IsolatedStorage {

	using System;

    /// <include file='doc\INormalizeForIsolatedStorage.uex' path='docs/doc[@for="INormalizeForIsolatedStorage"]/*' />
    public interface INormalizeForIsolatedStorage
    {
        /// <include file='doc\INormalizeForIsolatedStorage.uex' path='docs/doc[@for="INormalizeForIsolatedStorage.Normalize"]/*' />
        // Return a copy of the normalized version of this instance,
        // so that a the serialized version of this object can be 
        // mem-compared to another serialized object
        //
        // 1. Eg.  (pseudo code to illustrate usage)
        //
        // obj1 = MySite(WWW.MSN.COM)
        // obj2 = MySite(www.msn.com)
        //
        // obj1Norm = obj1.Normalize() 
        // obj2Norm = obj1.Normalize() 
        //
        // stream1 = Serialize(obj1Norm)
        // stream2 = Serialize(obj2Norm)
        //
        // AreStreamsEqual(stream1, stream2) returns true
        //
        // If the Object returned is a stream, the stream will be used without 
        // serialization. If the Object returned is a string, the string will 
        // be used in naming the Store. If the string is too long or if the
        // string contains chars that are illegal to use in naming the store,
        // the string will be serialized.
        //
        // 2. Eg. (pseudo code to illustrate returning string)
        //
        // obj1 = MySite(WWW.MSN.COM)
        // obj2 = MySite(www.msn.com)
        //
        // string1 = obj1.Normalize() 
        // string2 = obj1.Normalize() 
        //
        // AreStringsEqual(string1, string2) returns true
        //
        // 3. Eg. (pseudo code to illustrate returning stream)
        //
        // obj1 = MySite(WWW.MSN.COM)
        // obj2 = MySite(www.msn.com)
        //
        // stream1 = obj1.Normalize() 
        // stream2 = obj1.Normalize() 
        //
        // AreStreamsEqual(stream1, stream2) returns true

        Object Normalize();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\isolatedstorage\isolatedstorage.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Class:  IsolatedStorage
 *
 * Author: Shajan Dasan
 *
 * Purpose: Provides access to Persisted Application / Assembly data
 *
 * Date:  Feb 15, 2000
 *
 ===========================================================*/
namespace System.IO.IsolatedStorage {

    using System;
    using System.IO;
    using System.Text;
    using System.Threading;
    using System.Reflection;
    using System.Collections;
    using System.Security;
    using System.Security.Policy;
    using System.Security.Permissions;
    using System.Security.Cryptography;
    using System.Runtime.Serialization;
    using System.Runtime.CompilerServices;
    using System.Runtime.Serialization.Formatters.Binary;
    using Microsoft.Win32;

    /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorageScope"]/*' />
    [Flags, Serializable]
    public enum IsolatedStorageScope
    {
        // Dependency in native : COMIsolatedStorage.h

        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorageScope.None"]/*' />
        None       = 0x00,
        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorageScope.User"]/*' />
        User       = 0x01,
        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorageScope.Domain"]/*' />
        Domain     = 0x02,
        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorageScope.Assembly"]/*' />
        Assembly   = 0x04,

        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorageScope.Roaming"]/*' />
        Roaming    = 0x08

        //Machine    = 0x10
    }

    /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorage"]/*' />
    // not serializable
    public abstract class IsolatedStorage : MarshalByRefObject
    {
        // Helper constants
        internal const IsolatedStorageScope c_Assembly = 
                                   (IsolatedStorageScope.User |
                                    IsolatedStorageScope.Assembly);

        internal const IsolatedStorageScope c_App = 
                                   (IsolatedStorageScope.User |
                                    IsolatedStorageScope.Assembly |
                                    IsolatedStorageScope.Domain);

        internal const IsolatedStorageScope c_AssemblyRoaming = 
                                   (IsolatedStorageScope.Roaming |
                                    IsolatedStorageScope.User |
                                    IsolatedStorageScope.Assembly);

        internal const IsolatedStorageScope c_AppRoaming = 
                                   (IsolatedStorageScope.Roaming |
                                    IsolatedStorageScope.User |
                                    IsolatedStorageScope.Assembly |
                                    IsolatedStorageScope.Domain);

        private const String s_Publisher    = "Publisher";
        private const String s_StrongName   = "StrongName";
        private const String s_Site         = "Site";
        private const String s_Url          = "Url";
        private const String s_Zone         = "Zone";

        private static Char[] s_Base32Char   = {
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 
                'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
                'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 
                'y', 'z', '0', '1', '2', '3', '4', '5'};

        private ulong   m_Quota;
        private bool    m_ValidQuota;
        private Object  m_AppIdentity;
        private Object  m_AssemIdentity;

        private String  m_AppName;
        private String  m_AssemName;

        private IsolatedStorageScope m_Scope;

        private static IsolatedStorageFilePermission s_PermApp;
        private static IsolatedStorageFilePermission s_PermAppRoaming;
        private static IsolatedStorageFilePermission s_PermAssem;
        private static IsolatedStorageFilePermission s_PermAssemRoaming;
        private static SecurityPermission s_PermControlEvidence;
        private static PermissionSet s_PermReflection;
        private static PermissionSet s_PermUnrestricted;
        private static PermissionSet s_PermExecution;
        private static Zone s_InternetZone;

#if _DEBUG
        private static bool s_fDebug = false;
        private static int  s_iDebug = 0;
#endif

        // This one should be a macro, expecting JIT to inline this.
        internal static bool IsRoaming(IsolatedStorageScope scope)
        {
            return ((scope & IsolatedStorageScope.Roaming) != 0);
        }

        internal bool IsRoaming()
        {
            return ((m_Scope & IsolatedStorageScope.Roaming) != 0);
        }

        // This one should be a macro, expecting JIT to inline this.
        internal static bool IsDomain(IsolatedStorageScope scope)
        {
            return ((scope & IsolatedStorageScope.Domain) != 0);
        }

        internal bool IsDomain()
        {
            return ((m_Scope & IsolatedStorageScope.Domain) != 0);
        }

/* Not currently used
        // This one should be a macro, expecting JIT to inline this.
        internal static bool IsUser(IsolatedStorageScope scope)
        {
            return ((scope & IsolatedStorageScope.User) != 0);
        }
*/

        private String GetNameFromID(String typeID, String instanceID)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(typeID);
            sb.Append(SeparatorInternal);
            sb.Append(instanceID);

            return sb.ToString();
        }

        private static String GetPredefinedTypeName(Object o)
        {
            if (o is Publisher)
                return s_Publisher;
            else if (o is StrongName)
                return s_StrongName;
            else if (o is Url)
                return s_Url;
            else if (o is Site)
                return s_Site;
            else if (o is Zone)
                return s_Zone;

            return null;
        }

        internal static String GetHash(Stream s)
        {
            SHA1Managed sha1 = new SHA1Managed();
            byte[] b = sha1.ComputeHash(s);
            return ToBase32StringSuitableForDirName(b);
        }

        internal static String ToBase32StringSuitableForDirName(byte[] buff)
        {
            // This routine is optimised to be used with buffs of length 20
            BCLDebug.Assert(((buff.Length % 5) == 0), "Unexpected hash length");

#if _DEBUG
            if (s_fDebug)
            {
                if (s_iDebug >= 10)
                {
                    Console.Write("Stream : ");
                    for (int j = 0; j<buff.Length; ++j)
                        Console.Write("{0} ", buff[j]);

                    Console.WriteLine("");
                }
            }
#endif
            StringBuilder sb = new StringBuilder();
            byte b0, b1, b2, b3, b4;
            int  l, i;
    
            l = buff.Length;
            i = 0;

            // Create l chars using the last 5 bits of each byte.  
            // Consume 3 MSB bits 5 bytes at a time.

            do
            {
                b0 = (i < l) ? buff[i++] : (byte)0;
                b1 = (i < l) ? buff[i++] : (byte)0;
                b2 = (i < l) ? buff[i++] : (byte)0;
                b3 = (i < l) ? buff[i++] : (byte)0;
                b4 = (i < l) ? buff[i++] : (byte)0;

                // Consume the 5 Least significant bits of each byte
                sb.Append(s_Base32Char[b0 & 0x1F]);
                sb.Append(s_Base32Char[b1 & 0x1F]);
                sb.Append(s_Base32Char[b2 & 0x1F]);
                sb.Append(s_Base32Char[b3 & 0x1F]);
                sb.Append(s_Base32Char[b4 & 0x1F]);
    
                // Consume 3 MSB of b0, b1, MSB bits 6, 7 of b3, b4
                sb.Append(s_Base32Char[(
                        ((b0 & 0xE0) >> 5) | 
                        ((b3 & 0x60) >> 2))]);
    
                sb.Append(s_Base32Char[(
                        ((b1 & 0xE0) >> 5) | 
                        ((b4 & 0x60) >> 2))]);
    
                // Consume 3 MSB bits of b2, 1 MSB bit of b3, b4
                
                b2 >>= 5;
    
                BCLDebug.Assert(((b2 & 0xF8) == 0), "Unexpected set bits");
    
                if ((b3 & 0x80) != 0)
                    b2 |= 0x08;
                if ((b4 & 0x80) != 0)
                    b2 |= 0x10;
    
                sb.Append(s_Base32Char[b2]);

            } while (i < l);

#if _DEBUG
            if (s_fDebug)
            {
                if (s_iDebug >= 10)
                    Console.WriteLine("Hash : " + sb.ToString());
            }
#endif
            return sb.ToString();
        }

/* This is not used.
        private static String ToBase64StringSuitableForDirName(byte[] buff)
        {
            String s = Convert.ToBase64String(buff);
            StringBuilder sb = new StringBuilder();
    
            // Strip certain chars not suited for file names
            for (int i=0; i<s.Length; ++i)
            {
                Char c = s[i];
    
                if (Char.IsUpper(s[i]))
                {
                    // NT file system is case in-sensitive. This will
                    // weaken the hash. Preserve the streangth of the
                    // hash by adding a new "special char" before all caps
                    sb.Append("O");
                    sb.Append(s[i]);
                }
                else if (c == '/')      // replace '/' with '-'
                    sb.Append("-");
                else if (c != '=')      // ignore padding
                    sb.Append(s[i]);
            }
    
            return sb.ToString();
        }
*/

        private static bool IsValidName(String s)
        {
            for (int i=0; i<s.Length; ++i)
            {
                if (!Char.IsLetter(s[i]) && !Char.IsDigit(s[i]))
                    return false;
            }

            return true;
        }

        private static PermissionSet GetReflectionPermission()
        {
            // Don't sync. OK to create this object more than once.
            if (s_PermReflection == null)
                s_PermReflection = new PermissionSet(
                    PermissionState.Unrestricted);

            return s_PermReflection;
        }

        private static SecurityPermission GetControlEvidencePermission()
        {
            // Don't sync. OK to create this object more than once.
            if (s_PermControlEvidence == null)
                s_PermControlEvidence = new SecurityPermission(
                    SecurityPermissionFlag.ControlEvidence);

            return s_PermControlEvidence;
        }

        private static PermissionSet GetExecutionPermission()
        {
            // Don't sync. OK to create this object more than once.
            if (s_PermExecution == null)
            {
                s_PermExecution = new PermissionSet(
                    PermissionState.None);
                s_PermExecution.AddPermission(
                    new SecurityPermission(SecurityPermissionFlag.Execution));
            }

            return s_PermExecution;
        }

        private static PermissionSet GetUnrestricted()
        {
            // Don't sync. OK to create this object more than once.
            if (s_PermUnrestricted == null)
                s_PermUnrestricted = new PermissionSet(
                    PermissionState.Unrestricted);

            return s_PermUnrestricted;
        }

        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorage.SeparatorExternal"]/*' />
        protected virtual char SeparatorExternal
        {
            get { return '\\'; }
        }

        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorage.SeparatorInternal"]/*' />
        protected virtual char SeparatorInternal
        {
            get { return '.'; }
        }

        // gets "amount of space / resource used"

        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorage.MaximumSize"]/*' />
        [CLSCompliant(false)]
        public virtual ulong MaximumSize
        {
            get 
            { 
                if (m_ValidQuota) 
                    return m_Quota; 

                throw new InvalidOperationException(
                    Environment.GetResourceString(
                        "IsolatedStorage_QuotaIsUndefined"));
            }
        }

        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorage.CurrentSize"]/*' />
        [CLSCompliant(false)]
        public virtual ulong CurrentSize
        {
            get
            {
                throw new InvalidOperationException(
                    Environment.GetResourceString(
                        "IsolatedStorage_CurrentSizeUndefined"));
            }
        }

        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorage.DomainIdentity"]/*' />
        public Object DomainIdentity
        {
            [SecurityPermissionAttribute(SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlPolicy)]
            get {

                if (IsDomain())
                    return m_AppIdentity; 

                throw new InvalidOperationException(
                    Environment.GetResourceString(
                        "IsolatedStorage_DomainUndefined"));
            }
        }

        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorage.AssemblyIdentity"]/*' />
        public Object AssemblyIdentity
        {
            [SecurityPermissionAttribute(SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlPolicy)]
            get {  return m_AssemIdentity;  }
        }

        // Returns the App Stream (if present).
        // Sets assem stream
        internal MemoryStream GetIdentityStream(bool fApp)
        {
            BinaryFormatter bSer;
            MemoryStream    ms;
            Object          o;

            GetReflectionPermission().Assert();

            bSer = new BinaryFormatter();
            ms   = new MemoryStream();
            o    = fApp ? m_AppIdentity : m_AssemIdentity;

            bSer.Serialize(ms, o);
            ms.Position = 0;
            return ms;
        }

        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorage.Scope"]/*' />
        public IsolatedStorageScope Scope
        {
            get {  return m_Scope;  }
        }

        internal String AppName
        {
            get {

                if (IsDomain())
                    return m_AppName;

                throw new InvalidOperationException(
                    Environment.GetResourceString(
                        "IsolatedStorage_DomainUndefined"));
            }
        }

        internal String AssemName
        {
            get  { return m_AssemName; }
        }

        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorage.InitStore"]/*' />
        protected void InitStore(IsolatedStorageScope scope, 
                Type domainEvidenceType, Type assemblyEvidenceType)
        {
            Assembly assem;
            AppDomain domain;
            PermissionSet psAllowed, psDenied;

            psAllowed = null;
            psDenied  = null;

            assem = nGetCaller();

            GetControlEvidencePermission().Assert();

            if (IsDomain(scope))
            {
                domain = Thread.GetDomain();

                if (!IsRoaming(scope))  // No quota for roaming
                {
                    domain.nGetGrantSet(out psAllowed, out psDenied);
    
                    if (psAllowed == null)
                        throw new IsolatedStorageException(
                            Environment.GetResourceString(
                                "IsolatedStorage_DomainGrantSet"));
                }

                _InitStore(scope, domain.Evidence, domainEvidenceType,
                            assem.Evidence, assemblyEvidenceType);
            }
            else
            {
                if (!IsRoaming(scope))  // No quota for roaming
                {
                    assem.nGetGrantSet(out psAllowed, out psDenied);
    
                    if (psAllowed == null)
                        throw new IsolatedStorageException(
                            Environment.GetResourceString(
                                "IsolatedStorage_AssemblyGrantSet"));
                }

                _InitStore(scope, null, null, assem.Evidence, 
                    assemblyEvidenceType);
            }

            SetQuota(psAllowed, psDenied);
        }

        internal void InitStore(IsolatedStorageScope scope, 
            Object app, Object assem)
        {
            Assembly callerAssembly;
            PermissionSet psAllowed = null, psDenied = null;
            Evidence appEv = null, assemEv = new Evidence();

            assemEv.AddHost(assem);

            if (IsDomain(scope))
            {
                appEv = new Evidence();
                appEv.AddHost(app);
            }

            _InitStore(scope, appEv, null, assemEv, null);

            // Set the quota based on the caller, not the evidence supplied

            if (!IsRoaming(scope))  // No quota for roaming
            {
                callerAssembly = nGetCaller();

                GetControlEvidencePermission().Assert();
                callerAssembly.nGetGrantSet(out psAllowed, out psDenied);

                if (psAllowed == null)
                    throw new IsolatedStorageException(
                        Environment.GetResourceString(
                            "IsolatedStorage_AssemblyGrantSet"));
            }

            // This can be called only by trusted assemblies.
            // This quota really does not correspond to the permissions
            // granted for this evidence.
            SetQuota(psAllowed, psDenied);
        }

        internal void InitStore(IsolatedStorageScope scope,
            Evidence appEv, Type appEvidenceType,
            Evidence assemEv, Type assemEvidenceType)
        {
            PermissionSet psAllowed = null, psDenied = null;

            if (!IsRoaming(scope))
            {
                if (IsDomain(scope))
                {
                    psAllowed = SecurityManager.ResolvePolicy(
                        appEv, GetExecutionPermission(),  GetUnrestricted(),
                        null, out psDenied);
    
                    if (psAllowed == null)
                        throw new IsolatedStorageException(
                            Environment.GetResourceString(
                                "IsolatedStorage_DomainGrantSet"));
                }
                else
                {
                    psAllowed = SecurityManager.ResolvePolicy(
                        assemEv, GetExecutionPermission(),  GetUnrestricted(),
                        null, out psDenied);
    
                    if (psAllowed == null)
                        throw new IsolatedStorageException(
                            Environment.GetResourceString(
                                "IsolatedStorage_AssemblyGrantSet"));
                }
            }

            _InitStore(scope, appEv, appEvidenceType,
                assemEv, assemEvidenceType);

            SetQuota(psAllowed, psDenied);
        }

        internal bool InitStore(IsolatedStorageScope scope, 
                Stream app, Stream assem, String appName, String assemName)
        {
            BinaryFormatter bSer;

            try {

                GetReflectionPermission().Assert();
    
                bSer = new BinaryFormatter();
    
                // Get the Assem Info
                m_AssemIdentity = bSer.Deserialize(assem);
                m_AssemName = assemName;
    
                if (IsDomain(scope))
                {
                    // Get the App Info
                    m_AppIdentity = bSer.Deserialize(app);
                    m_AppName = appName;
                }

            } catch (Exception) {
                return false;
            }

            BCLDebug.Assert(m_ValidQuota == false, "Quota should be invalid here");

            m_Scope = scope;

            return true;
        }

        private void _InitStore(IsolatedStorageScope scope,
                Evidence appEv, Type appEvidenceType, 
                Evidence assemEv, Type assemblyEvidenceType)
        {

            // Input arg ckecks
            if (assemEv == null)
                throw new IsolatedStorageException(
                    Environment.GetResourceString(
                        "IsolatedStorage_AssemblyMissingIdentity"));

            if (IsDomain(scope) && (appEv == null))
                throw new IsolatedStorageException(
                    Environment.GetResourceString(
                        "IsolatedStorage_DomainMissingIdentity"));
    
            VerifyScope(scope);

            // Security checks
            DemandPermission(scope);

            String typeHash = null, instanceHash = null;

            m_AssemIdentity = GetAccountingInfo(
                                assemEv, assemblyEvidenceType, false,
                                out typeHash, out instanceHash);

            m_AssemName = GetNameFromID(typeHash, instanceHash);

            if (IsDomain(scope))
            {
                m_AppIdentity = GetAccountingInfo(appEv, appEvidenceType, 
                                    false, out typeHash, out instanceHash);

                m_AppName = GetNameFromID(typeHash, instanceHash);
            }

            m_Scope = scope;
        }

        private static Object GetAccountingInfo(
                Evidence evidence, Type evidenceType, bool fDomain,
                out String typeName, out String instanceName)
        {
            Object o, oNormalized = null;

            MemoryStream    ms;
            BinaryWriter    bw;
            BinaryFormatter bSer;

            o = _GetAccountingInfo(evidence, evidenceType, fDomain, 
                    out oNormalized);

            // Get the type name
            typeName = GetPredefinedTypeName(o);

            if (typeName == null)
            {
                // This is not a predefined type. Serialize the type
                // and get a hash for the serialized stream

                GetReflectionPermission().Assert();
                ms   = new MemoryStream();
                bSer = new BinaryFormatter();
                bSer.Serialize(ms, o.GetType());
                ms.Position = 0;
                typeName = GetHash(ms);

#if _DEBUG
                DebugLog(o.GetType(), ms);
#endif
            }

            instanceName = null;

            // Get the normalized instance name if present.
            if (oNormalized != null)
            {
                if (oNormalized is Stream)
                {
                    instanceName = GetHash((Stream)oNormalized);
                }
                else if (oNormalized is String)
                {
                    if (IsValidName((String)oNormalized))
                    {
                        instanceName = (String)oNormalized;
                    }
                    else
                    {
                        // The normalized name has illegal chars
                        // serialize and get the hash.

                        ms = new MemoryStream();
                        bw = new BinaryWriter(ms);
                        bw.Write((String)oNormalized);
                        ms.Position = 0;
                        instanceName = GetHash(ms);
#if _DEBUG
                        DebugLog(oNormalized, ms);
#endif
                    }
                }
                
            }
            else
            {
                oNormalized = o;
            }

            if (instanceName == null)
            {
                // Serialize the instance and  get the hash for the 
                // serialized stream

                GetReflectionPermission().Assert();
                ms   = new MemoryStream();
                bSer = new BinaryFormatter();
                bSer.Serialize(ms, oNormalized);
                ms.Position = 0;
                instanceName = GetHash(ms);

#if _DEBUG
                DebugLog(oNormalized, ms);
#endif
            }

            return o;
        }

        private static Object _GetAccountingInfo(
                    Evidence evidence, Type evidenceType, bool fDomain,
                    out Object oNormalized)
        {
            Object          o = null;
            IEnumerator     e;

            BCLDebug.Assert(evidence != null, "evidence != null");

            e = evidence.GetHostEnumerator();

            if (evidenceType == null)
            {
                // Caller does not have any preference
                // Order of preference is Publisher, Strong Name, Url, Site

                Publisher   pub  = null;
                StrongName  sn   = null;
                Url         url  = null;
                Site        site = null;
                Zone        zone = null;

                while (e.MoveNext())
                {
                    o = e.Current;

                    if (o is Publisher)
                    {
                        pub = (Publisher) o;
                        break;
                    }
                    else if (o is StrongName)
                        sn = (StrongName) o;
                    else if (o is Url)
                        url = (Url) o;
                    else if (o is Site)
                        site = (Site) o;
                    else if (o is Zone)
                        zone = (Zone) o;
                }

                if (pub != null)
                {
                    o = pub;
                }
                else if (sn != null)
                {
                    o = sn;
                }
                else if (url != null)
                {
                    o = url;
                }
                else if (site != null)
                {
                    o = site;
                }
                else if (zone != null)
                {
                    o = zone; 
                } 
                else
                {
                    // The evidence object can have tons of other objects
                    // creatd by the policy system. Ignore those.

                    if (fDomain)
                        throw new IsolatedStorageException(
                            Environment.GetResourceString(
                                "IsolatedStorage_DomainNoEvidence"));
                    else
                        throw new IsolatedStorageException(
                            Environment.GetResourceString(
                                "IsolatedStorage_AssemblyNoEvidence"));
                }
            }
            else
            {
                Object obj;
                while (e.MoveNext())
                {
                    obj = e.Current;

                    if (evidenceType.Equals(obj.GetType()))
                    {
                        o = obj;
                        break;
                    }
                }

                if (o == null)
                {
                    if (fDomain)
                        throw new IsolatedStorageException(
                            Environment.GetResourceString(
                                "IsolatedStorage_DomainEvidenceMissing"));
                    else
                        throw new IsolatedStorageException(
                            Environment.GetResourceString(
                                "IsolatedStorage_AssemblyEvidenceMissing"));
                }
            }

            // For startup Perf, Url, Site, StrongName types don't implement
            // INormalizeForIsolatedStorage interface, instead they have
            // Normalize() method.

            if (o is INormalizeForIsolatedStorage)
            {
                oNormalized = ((INormalizeForIsolatedStorage)o).Normalize(); 
            }
            else if (o is Publisher)
            {
                oNormalized = ((Publisher)o).Normalize(); 
            }
            else if (o is StrongName)
            {
                oNormalized = ((StrongName)o).Normalize(); 
            }
            else if (o is Url)
            {
                oNormalized = ((Url)o).Normalize(); 
            }
            else if (o is Site)
            {
                oNormalized = ((Site)o).Normalize(); 
            }
            else if (o is Zone)
            {
                oNormalized = ((Zone)o).Normalize(); 
            }
            else
            {
                oNormalized = null;
            }

            return o;
        }

        private static void DemandPermission(IsolatedStorageScope scope)
        {
            IsolatedStorageFilePermission ip = null;

            // Ok to create more than one instnace of s_PermXXX, the last one 
            // will be shared. No need to synchronize.

            // First check for permissions

            switch (scope)
            {
            case c_App:

                if (s_PermApp == null)
                    s_PermApp = new IsolatedStorageFilePermission(
                        IsolatedStorageContainment.DomainIsolationByUser, 
                        0, false);
                ip = s_PermApp;
                break;

            case c_Assembly:
                if (s_PermAssem == null)
                    s_PermAssem = new IsolatedStorageFilePermission(
                        IsolatedStorageContainment.AssemblyIsolationByUser, 
                        0, false);
                ip = s_PermAssem;
                break;

            case c_AppRoaming:
                if (s_PermAppRoaming == null)
                    s_PermAppRoaming = new IsolatedStorageFilePermission(
                        IsolatedStorageContainment.DomainIsolationByRoamingUser,
                        0, false);
                ip = s_PermAppRoaming;
                break;

            case c_AssemblyRoaming: 
                if (s_PermAssemRoaming == null)
                    s_PermAssemRoaming = new IsolatedStorageFilePermission(
                        IsolatedStorageContainment.AssemblyIsolationByRoamingUser, 
                        0, false);
                ip = s_PermAssemRoaming;
                break;

#if _DEBUG
            default:
                BCLDebug.Assert(false, "Invalid scope");
                break;
#endif
            }

            ip.Demand();
        }

        internal static void VerifyScope(IsolatedStorageScope scope)
        {
            // The only valid ones are User + Assem, User + Assem + Domain,
            // Roaming + User + Assem, Roaming + User + Assem + Domain

            if ((scope == c_App) || (scope == c_Assembly) ||
                (scope == c_AppRoaming) || (scope == c_AssemblyRoaming))
                return;

            throw new ArgumentException(
                    Environment.GetResourceString(
                        "IsolatedStorage_Scope_UA_UAD_RUA_RUAD"));
        }

        internal void SetQuota(PermissionSet psAllowed, PermissionSet psDenied)
        {
            IsolatedStoragePermission ispAllowed, ispDenied;

            ispAllowed = GetPermission(psAllowed);

            m_Quota = 0;

            if (ispAllowed != null)
            {
                if (ispAllowed.IsUnrestricted())
                    m_Quota = Int64.MaxValue;
                else
                    m_Quota = (ulong) ispAllowed.UserQuota;
            }

            if (psDenied != null)
            {
                ispDenied = GetPermission(psDenied);

                if (ispDenied != null)
                {
                    if (ispDenied.IsUnrestricted())
                    {
                        m_Quota = 0;
                    }
                    else
                    {
                        ulong denied = (ulong) ispDenied.UserQuota;
        
                        if (denied > m_Quota)
                            m_Quota = 0;
                        else
                            m_Quota -= denied;
                    }
                }
            }

            m_ValidQuota = true;

#if _DEBUG
            if (s_fDebug)
            {
                if (s_iDebug >= 1) {
                    if (psAllowed != null)
                        Console.WriteLine("Allowed PS : " + psAllowed);
                    if (psDenied != null)
                        Console.WriteLine("Denied PS : " + psDenied);
                }
            }
#endif
        }

#if _DEBUG
        private static void DebugLog(Object o, MemoryStream ms)
        {
            if (s_fDebug)
            {
                if (s_iDebug >= 1)
                    Console.WriteLine(o.ToString());

                if (s_iDebug >= 10)
                {
                    byte[] p = ms.GetBuffer();
    
                    for (int _i=0; _i<ms.Length; ++_i)
                    {
                        Console.Write(" ");
                        Console.Write(p[_i]);
                    }
    
                    Console.WriteLine("");
                }
            }
        }
#endif

        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorage.Remove"]/*' />
        public abstract void Remove();

        /// <include file='doc\IsolatedStorage.uex' path='docs/doc[@for="IsolatedStorage.GetPermission"]/*' />
        protected abstract IsolatedStoragePermission GetPermission(PermissionSet ps);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern Assembly nGetCaller();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\isolatedstorage\isolatedstorageexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Class:  IsolatedStorageException
 *
 * Author: Shajan Dasan
 *
 * Purpose: The exceptions in IsolatedStorage
 *
 * Date:  Feb 15, 2000
 *
 ===========================================================*/
namespace System.IO.IsolatedStorage {

	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\IsolatedStorageException.uex' path='docs/doc[@for="IsolatedStorageException"]/*' />
    [Serializable()]
    public class IsolatedStorageException : Exception
    {
        /// <include file='doc\IsolatedStorageException.uex' path='docs/doc[@for="IsolatedStorageException.IsolatedStorageException"]/*' />
        public IsolatedStorageException()
            : base(Environment.GetResourceString("IsolatedStorage_Exception"))
        {
            SetErrorCode(__HResults.COR_E_ISOSTORE);
        }

        /// <include file='doc\IsolatedStorageException.uex' path='docs/doc[@for="IsolatedStorageException.IsolatedStorageException1"]/*' />
        public IsolatedStorageException(String message)
            : base(message)
        {
            SetErrorCode(__HResults.COR_E_ISOSTORE);
        }

        /// <include file='doc\IsolatedStorageException.uex' path='docs/doc[@for="IsolatedStorageException.IsolatedStorageException2"]/*' />
        public IsolatedStorageException(String message, Exception inner)
            : base(message, inner)
        {
            SetErrorCode(__HResults.COR_E_ISOSTORE);
        }

        /// <include file='doc\IsolatedStorageException.uex' path='docs/doc[@for="IsolatedStorageException.IsolatedStorageException3"]/*' />
        protected IsolatedStorageException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\__debugoutputtextwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#if _DEBUG
// This class writes to wherever OutputDebugString writes to.  If you don't have
// a Windows app (ie, something hosted in IE), you can use this to redirect Console
// output for some good old-fashioned console spew in MSDEV's debug output window.

// This really shouldn't ship at all, but is intended as a quick, inefficient hack
// for debugging.  -- BrianGru, 9/26/2000

using System;
using System.IO;
using System.Text;
using System.Security;
using System.Runtime.InteropServices;
using Microsoft.Win32;

namespace System.IO {
    internal class __DebugOutputTextWriter : TextWriter {
        private readonly String _consoleType;

        internal __DebugOutputTextWriter(String consoleType)
        {
            _consoleType = consoleType;
        }

        public override Encoding Encoding {
            get {
                if (Marshal.SystemDefaultCharSize == 1)
                    return Encoding.Default;
                else
                    return new UnicodeEncoding(false, false);
            }
        }

        public override void Write(char c)
        {
            OutputDebugString(c.ToString());
        }

        public override void Write(String str)
        {
            OutputDebugString(str);
        }

        public override void Write(char[] array)
        {
            if (array != null) 
                OutputDebugString(new String(array));
        }
        
        public override void WriteLine(String str)
        {
            if (str != null)
                OutputDebugString(_consoleType + str);
            else
                OutputDebugString("<null>");
            OutputDebugString(new String(CoreNewLine));
        }

        [DllImport(Win32Native.KERNEL32, CharSet=CharSet.Auto), SuppressUnmanagedCodeSecurityAttribute()]
        private static extern void OutputDebugString(String output);
    }
}
       
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\__hresults.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//=============================================================================
//
// Class: __HResults
//
// Author: Automatically generated
//
// Purpose: Define HResult constants. Every exception has one of these.
//
// Date: 98/08/31 11:57:11 AM
//
//===========================================================================*/
namespace System.IO {
    using System;
    // Only static data no need to serialize
    internal sealed class __HResults
    {
        // These use an error code from WinError.h
        public const int COR_E_ENDOFSTREAM = unchecked((int)0x80070026);  // OS defined
        public const int COR_E_FILELOAD = unchecked((int)0x80131621);
        public const int COR_E_FILENOTFOUND = unchecked((int)0x80070002);
        public const int COR_E_DIRECTORYNOTFOUND = unchecked((int)0x80070003);
        public const int COR_E_PATHTOOLONG = unchecked((int)0x800700CE);

        public const int COR_E_IO = unchecked((int)0x80131620);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\isolatedstorage\isolatedstoragefile.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 * 
 * Class:  IsolatedStorageFile
 *
 * Author: Shajan Dasan
 *
 * Purpose: Provides access to Application files and folders
 *
 * Date:  Feb 18, 2000
 *
 ===========================================================*/
namespace System.IO.IsolatedStorage {
    using System;
    using System.Text;
    using System.IO;
    using Microsoft.Win32;
    using System.Collections;
    using System.Security;
    using System.Threading;
    using System.Security.Policy;
    using System.Security.Permissions;
    using System.Security.Cryptography;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    using System.Globalization;

    /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile"]/*' />
    public sealed class IsolatedStorageFile : IsolatedStorage, IDisposable
    {
        private  const int    s_BlockSize = 1024;
        private  const int    s_DirSize   = s_BlockSize;
        private  const String s_name      = "file.store";
        internal const String s_Files     = "Files";
        internal const String s_AssemFiles= "AssemFiles";
        internal const String s_IDFile    = "identity.dat";
        internal const String s_InfoFile  = "info.dat";

        private static String s_RootDirUser;
        private static String s_RootDirRoaming;

        private static FileIOPermission              s_PermUser;
        private static FileIOPermission              s_PermRoaming;
        private static IsolatedStorageFilePermission s_PermAdminUser;

        private FileIOPermission m_fiop;
        private String           m_RootDir;
        private String           m_InfoFile;
        private String           m_SyncObjectName;
        private IntPtr           m_handle;
        private bool             m_closed;
        private bool             m_bDisposed = false;

#if _DEBUG
        private static bool s_fDebug = false;
#endif

        internal IsolatedStorageFile() {}

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.GetUserStoreForDomain"]/*' />
        public static IsolatedStorageFile GetUserStoreForDomain()
        {
            return GetStore(
                IsolatedStorageScope.Assembly|
                IsolatedStorageScope.Domain|
                IsolatedStorageScope.User, 
                null, null);
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.GetUserStoreForAssembly"]/*' />
        public static IsolatedStorageFile GetUserStoreForAssembly()
        {
            return GetStore(
                IsolatedStorageScope.Assembly|
                IsolatedStorageScope.User, 
                null, null);
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.GetStore"]/*' />
        public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, 
            Type domainEvidenceType, Type assemblyEvidenceType)
        {
            if (domainEvidenceType != null)
                DemandAdminPermission();

            IsolatedStorageFile sf = new IsolatedStorageFile();
            sf.InitStore(scope, domainEvidenceType, assemblyEvidenceType);
            sf.Init(scope);
            return sf;
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.GetStore1"]/*' />
        public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, 
            Object domainIdentity, Object assemblyIdentity)
        {
            // Verify input params.
            if (IsDomain(scope) && (domainIdentity == null))
                throw new ArgumentNullException("domainIdentity");

            if (assemblyIdentity == null)
                throw new ArgumentNullException("assemblyIdentity");

            DemandAdminPermission();

            IsolatedStorageFile sf = new IsolatedStorageFile();
            sf.InitStore(scope, domainIdentity, assemblyIdentity); 
            sf.Init(scope);

            return sf;
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.GetStore2"]/*' />
        public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, 
            Evidence domainEvidence, Type  domainEvidenceType,
            Evidence assemblyEvidence, Type assemblyEvidenceType)
        {
            // Verify input params.
            if (IsDomain(scope) && (domainEvidence == null))
                throw new ArgumentNullException("domainEvidence");

            if (assemblyEvidence == null)
                throw new ArgumentNullException("assemblyEvidence");

            DemandAdminPermission();

            IsolatedStorageFile sf = new IsolatedStorageFile();
            sf.InitStore(scope, domainEvidence, domainEvidenceType,
                assemblyEvidence, assemblyEvidenceType);
            sf.Init(scope);

            return sf;
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.CurrentSize"]/*' />
        [CLSCompliant(false)]
        public override ulong CurrentSize
        {
            get { 
                if (IsRoaming())
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "IsolatedStorage_CurrentSizeUndefined"));

                lock (this)
                {
                    if (m_bDisposed)
                        throw new ObjectDisposedException(null, Environment.GetResourceString("IsolatedStorage_StoreNotOpen"));

                    if (m_closed)
                        throw new InvalidOperationException(
                            Environment.GetResourceString(
                                "IsolatedStorage_StoreNotOpen"));

                    if (m_handle == Win32Native.NULL)
                        m_handle = nOpen(m_InfoFile, GetSyncObjectName());

                    return nGetUsage(m_handle); 
                }
            }
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.MaximumSize"]/*' />
        [CLSCompliant(false)]
        public override ulong MaximumSize
        {
            get 
            { 
                if (IsRoaming())
                    return Int64.MaxValue;

                return base.MaximumSize;
            }
        }

        [CLSCompliant(false)]
        internal unsafe void Reserve(ulong lReserve)
        {
            if (IsRoaming())  // No Quota enforcement for roaming
                return;

            ulong quota = this.MaximumSize;
            ulong reserve = lReserve;

            lock (this)
            {
                if (m_bDisposed)
                    throw new ObjectDisposedException(null, Environment.GetResourceString("IsolatedStorage_StoreNotOpen"));

                if (m_closed)
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "IsolatedStorage_StoreNotOpen"));

                if (m_handle == Win32Native.NULL)
                    m_handle = nOpen(m_InfoFile, GetSyncObjectName());

                nReserve(m_handle, &quota, &reserve, false);
            }
        }

        [CLSCompliant(false)]
        internal unsafe void Unreserve(ulong lFree)
        {
            if (IsRoaming())  // No Quota enforcement for roaming
                return;

            ulong quota = this.MaximumSize;
            ulong free = lFree;

            lock (this)
            {
                if (m_bDisposed)
                    throw new ObjectDisposedException(null, Environment.GetResourceString("IsolatedStorage_StoreNotOpen"));

                if (m_closed)
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "IsolatedStorage_StoreNotOpen"));

                if (m_handle == Win32Native.NULL)
                    m_handle = nOpen(m_InfoFile, GetSyncObjectName());

                nReserve(m_handle, &quota, &free, true);
            }
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.DeleteFile"]/*' />
        public void DeleteFile(String file)
        {
            if (file == null)
                throw new ArgumentNullException("file");

            m_fiop.Assert();
            m_fiop.PermitOnly();

            FileInfo f = new FileInfo(GetFullPath(file));
            long oldLen = 0;

            Lock(); // protect oldLen

            try {
                try {
                    oldLen = f.Length;
                    f.Delete();
                } catch (Exception) {
                    throw new IsolatedStorageException(
                        Environment.GetResourceString(
                            "IsolatedStorage_DeleteFile"));
                }
                Unreserve(RoundToBlockSize((ulong)oldLen));
            } finally {
                Unlock();
            }
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.CreateDirectory"]/*' />
        public void CreateDirectory(String dir)
        {
            if (dir == null)
                throw new ArgumentNullException("dir");

            Reserve(s_DirSize);
            m_fiop.Assert();
            m_fiop.PermitOnly();
            try {
                Directory.CreateDirectory(GetFullPath(dir));
            } catch (Exception) {
                Unreserve(s_DirSize);
                throw new IsolatedStorageException(
                    Environment.GetResourceString(
                        "IsolatedStorage_CreateDirectory"));
            }
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.DeleteDirectory"]/*' />
        public void DeleteDirectory(String dir)
        {
            if (dir == null)
                throw new ArgumentNullException("dir");

            m_fiop.Assert();
            m_fiop.PermitOnly();

            Lock(); // Delete *.*, will beat quota enforcement without this lock

            try {
                try {
                    new DirectoryInfo(GetFullPath(dir)).Delete(false);
                } catch (Exception) {
                    throw new IsolatedStorageException(
                        Environment.GetResourceString(
                            "IsolatedStorage_DeleteDirectory"));
                }
                Unreserve(s_DirSize);
            } finally {
                Unlock();
            }
        }

        /*
         * foo\abc*.txt will give all abc*.txt files in foo directory
         */
        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.GetFileNames"]/*' />
        public String[] GetFileNames(String searchPattern)
        {
            if (searchPattern == null)
                throw new ArgumentNullException("searchPattern");

            m_fiop.Assert();
            m_fiop.PermitOnly();
            return GetFileDirectoryNames(GetFullPath(searchPattern), 
                searchPattern, true);
        }

        /*
         * foo\data* will give all directory names in foo directory that 
         * starts with data
         */
        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.GetDirectoryNames"]/*' />
        public String[] GetDirectoryNames(String searchPattern)
        {
            if (searchPattern == null)
                throw new ArgumentNullException("searchPattern");

            m_fiop.Assert();
            m_fiop.PermitOnly();
            return GetFileDirectoryNames(GetFullPath(searchPattern), 
                searchPattern, false);
        }

        // Remove this individual store
        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.Remove"]/*' />
        public override void Remove()
        {
            // No security check required here since we have already done
            // that during creation

            String rootDir, domainRoot = null;

            // First remove the logical root directory of this store, this
            // will not delete the quota file. Removes all the files and dirs
            // that applications see.

            RemoveLogicalDir();

            Close();

            // Now try to remove other files folders that become unnecessary
            // if the application directory is deleted.

            StringBuilder sb = new StringBuilder();

            sb.Append(GetRootDir(this.Scope));

            if (IsDomain())
            {
                sb.Append(this.AppName);
                sb.Append(this.SeparatorExternal);
                domainRoot = sb.ToString();
            }

            sb.Append(this.AssemName);
            sb.Append(this.SeparatorExternal);

            rootDir = sb.ToString();

            new FileIOPermission(
                FileIOPermissionAccess.AllAccess, rootDir).Assert();

            if (ContainsUnknownFiles(rootDir))
                return;

            try {

                Directory.Delete(rootDir, true);
#if _DEBUG
            } catch (Exception e) {

                if (s_fDebug)
                {
                    Console.WriteLine(e);
                    Console.WriteLine("Delete failed on rootdir");
                }
#else
            } catch (Exception) {
#endif
                return; // OK to ignore this exception.
            }

            // If this was a domain store, and if this happens to be
            // the only store around, then delete the root store for this
            // domain

            if (IsDomain())
            {
                CodeAccessPermission.RevertAssert();

                new FileIOPermission(
                    FileIOPermissionAccess.AllAccess, domainRoot).Assert();

                if (!ContainsUnknownFiles(domainRoot))
                {

                    try {

                        Directory.Delete(domainRoot, true);
#if _DEBUG
                    } catch (Exception e) {

                        if (s_fDebug)
                        {
                            Console.WriteLine(e);
                            Console.WriteLine("Delete failed on basedir");
                        }
#else
                    } catch (Exception) {
#endif
                        return; // OK to ignore this exception.
                    }
                }
            }
        }

        private void RemoveLogicalDir()
        {
            m_fiop.Assert();

            ulong oldLen;

            Lock(); // A race here with delete dir/delete file can get around 
                    // quota enforcement.

            try {
                oldLen = IsRoaming() ? 0 : CurrentSize;
    
                try {
    
                    Directory.Delete(RootDirectory, true);
#if _DEBUG
                } catch (Exception e) {
    
                    if (s_fDebug)
                    {
                        Console.WriteLine(e);
                        Console.WriteLine("Delete failed on LogicalRooDir");
                    }
#else
                    } catch (Exception) {
#endif
                    throw new IsolatedStorageException(
                        Environment.GetResourceString(
                            "IsolatedStorage_DeleteDirectories"));
                }
    
                Unreserve(oldLen);
            } finally {
                Unlock();
            }
        }

        private bool ContainsUnknownFiles(String rootDir)
        {
            String[] dirs, files;

            // Delete everything in the root directory of this store
            // if there are no Domain Stores / other files
            // Make sure that there are no other subdirs present here other
            // than the ones used by IsolatedStorageFile (Cookies in future
            // releases ?)

            try {
                files = GetFileDirectoryNames(rootDir + "*", "*", true);
                dirs = GetFileDirectoryNames(rootDir + "*", "*", false);
            } catch (Exception) {
                throw new IsolatedStorageException(
                    Environment.GetResourceString(
                        "IsolatedStorage_DeleteDirectories"));
            }

            // First see if there are any unkonwn Folders
            if ((dirs != null) && (dirs.Length > 0))
            {
                if (dirs.Length > 1)
                {
                    // More than one directory present
                    return true;
                }

                if (IsDomain())
                {
                    if (NotFilesDir(dirs[0]))
                        return true;
                }
                else
                {
                    if (NotAssemFilesDir(dirs[0]))
                        return true;
                }
            }

            // Now look at the files

            if ((files == null) || (files.Length == 0))
                return false;

            if (IsRoaming())
            {
                if ((files.Length > 1) || NotIDFile(files[0]))
                {
                    // There is one or more files unknown to this version
                    // of IsoStoreFile

                    return true;
                }

                return false;
            }

            if ((files.Length > 2) ||
                (NotIDFile(files[0]) && NotInfoFile(files[0])) ||
                ((files.Length == 2) &&
                NotIDFile(files[1]) && NotInfoFile(files[1])))
            {
                // There is one or more files unknown to this version
                // of IsoStoreFile

                return true;
            }

            return false; 
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.Close"]/*' />
        public void Close()
        {
            if (IsRoaming())
                return;
            
            lock (this) {

                if (!m_closed) {
                    m_closed = true;

                    IntPtr handle = m_handle;

                    m_handle = Win32Native.NULL;
                    nClose(handle);

                    GC.nativeSuppressFinalize(this);
                }

            }
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.Dispose"]/*' />
        public void Dispose()
        {
            Close();
            m_bDisposed = true;
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.IsolatedStorageFile"]/*' />
        ~IsolatedStorageFile()
        {
            Dispose();
        }

        // Macros, expect JIT to expand this
        private static bool NotIDFile(String file)
        {
            return (String.Compare(
                file, IsolatedStorageFile.s_IDFile, false, CultureInfo.InvariantCulture) != 0); 
        }

        private static bool NotInfoFile(String file)
        {
            return (String.Compare(
                file, IsolatedStorageFile.s_InfoFile, false, CultureInfo.InvariantCulture) != 0); 
        }

        private static bool NotFilesDir(String dir)
        {
            return (String.Compare(
                dir, IsolatedStorageFile.s_Files, false, CultureInfo.InvariantCulture) != 0);
        }

        internal static bool NotAssemFilesDir(String dir)
        {
            return (String.Compare(
                dir, IsolatedStorageFile.s_AssemFiles, false, CultureInfo.InvariantCulture) != 0);
        }

        // Remove store for all identities
        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.Remove1"]/*' />
        public static void Remove(IsolatedStorageScope scope)
        {
            VerifyGlobalScope(scope);
            DemandAdminPermission();

            String rootDir = GetRootDir(scope);

            new FileIOPermission(
                FileIOPermissionAccess.Write, rootDir).Assert();

            try {
                Directory.Delete(rootDir, true);    // Remove all sub dirs and files
                Directory.CreateDirectory(rootDir); // Recreate the root dir
            } catch (Exception) {
                throw new IsolatedStorageException(
                    Environment.GetResourceString(
                        "IsolatedStorage_DeleteDirectories"));
            }
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.GetEnumerator"]/*' />
        public static IEnumerator GetEnumerator(IsolatedStorageScope scope)
        {
            VerifyGlobalScope(scope);
            DemandAdminPermission();

            return new IsolatedStorageFileEnumerator(scope);
        }

        // Internal & private methods

        internal String RootDirectory
        {
            get { return m_RootDir; }
        }

        internal String GetFullPath(String path)
        {
            StringBuilder sb = new StringBuilder();

            sb.Append(this.RootDirectory);

            if (path[0] == SeparatorExternal)
                sb.Append(path.Substring(1));
            else
                sb.Append(path);

            return sb.ToString();
        }

        internal void Init(IsolatedStorageScope scope)
        {
            GetGlobalFileIOPerm(scope).Assert();

            StringBuilder sb = new StringBuilder();

            // Create the root directory if it is not already there

            sb.Append(GetRootDir(scope));

            if (IsDomain(scope))
            {
                sb.Append(this.AppName);
                sb.Append(this.SeparatorExternal);
    
                try {

                    Directory.CreateDirectory(sb.ToString());

                    // No exception implies this directory was created now

                    // Create the Identity blob file in the root 
                    // directory. OK if there are more than one created
                    // last one wins

                    CreateIDFile(sb.ToString(), true);

                } catch (Exception) {

                    // Ok to ignore IO exception

/* Leaving this commented for now for performance

                    // It is possible that a previous create directory
                    // succeeded, but the Identity blob file was not
                    // created. Create it now.

                    CreateIDFileIfNecessary(sb.ToString(), true);
*/
                }

                // For Domain Stores, accounting is done in the domain root
                this.m_InfoFile = sb.ToString() + s_InfoFile;
            }

            sb.Append(this.AssemName);
            sb.Append(this.SeparatorExternal);

            try {

                Directory.CreateDirectory(sb.ToString());

                // No exception implies this directory was created now

                // Create the Identity blob file in the root 
                // directory. OK if there are more than one created
                // last one wins

                CreateIDFile(sb.ToString(), false);

            } catch (Exception) {
                // Ok to ignore IO exception

/* Leaving this commented for now for performance

                // It is possible that a previous create directory
                // succeeded, but the Identity blob file was not
                // created. Create it now.

                CreateIDFileIfNecessary(sb.ToString(), false);
*/
            }

            if (IsDomain(scope))
            {
                sb.Append(s_Files);
            }
            else
            {
                // For Assem Stores, accounting is done in the assem root
                this.m_InfoFile = sb.ToString() + s_InfoFile;

                sb.Append(s_AssemFiles);
            }

            sb.Append(this.SeparatorExternal);

            String rootDir = sb.ToString();

            try {
                Directory.CreateDirectory(rootDir);
            } catch (Exception) {
                // Ok to ignore IO exception
            }

            this.m_RootDir = rootDir;

            // Use the "new" RootDirectory to create the permission.
            // This instance of permission is not the same as the
            // one we just asserted. It uses this.base.RootDirectory.

            m_fiop = new FileIOPermission(
                FileIOPermissionAccess.AllAccess, rootDir);
        }

        internal bool InitExistingStore(IsolatedStorageScope scope)
        {
            FileIOPermission fp;
            StringBuilder sb = new StringBuilder();

            sb.Append(GetRootDir(scope));

            if (IsDomain(scope))
            {
                sb.Append(this.AppName);
                sb.Append(this.SeparatorExternal);

                // For Domain Stores, accounting is done in the domain root
                this.m_InfoFile = sb.ToString() + s_InfoFile;
            }

            sb.Append(this.AssemName);
            sb.Append(this.SeparatorExternal);

            if (IsDomain(scope))
            {
                sb.Append(s_Files);
            }
            else
            {
                // For Assem Stores, accounting is done in the assem root
                this.m_InfoFile = sb.ToString() + s_InfoFile;

                sb.Append(s_AssemFiles);
            }

            sb.Append(this.SeparatorExternal);

            fp = new FileIOPermission(
                FileIOPermissionAccess.AllAccess, sb.ToString());

            fp.Assert();

            if (!Directory.Exists(sb.ToString()))
                return false;

            this.m_RootDir = sb.ToString();
            this.m_fiop = fp;

            return true;
        }

        /// <include file='doc\IsolatedStorageFile.uex' path='docs/doc[@for="IsolatedStorageFile.GetPermission"]/*' />
        protected override IsolatedStoragePermission GetPermission(
                PermissionSet ps)
        {
            if (ps == null)
                return null;
            else if (ps.IsUnrestricted())
                return new IsolatedStorageFilePermission(
                        PermissionState.Unrestricted);

            return (IsolatedStoragePermission) ps.
                    GetPermission(typeof(IsolatedStorageFilePermission));
        }

        internal void UndoReserveOperation(ulong oldLen, ulong newLen)
        {
            oldLen = RoundToBlockSize(oldLen);
            if (newLen > oldLen)
                Unreserve(RoundToBlockSize(newLen - oldLen));
        }

        internal void Reserve(ulong oldLen, ulong newLen)
        {
            oldLen = RoundToBlockSize(oldLen);
            if (newLen > oldLen)
                Reserve(RoundToBlockSize(newLen - oldLen));
        }

        internal void ReserveOneBlock()
        {
            Reserve(s_BlockSize);
        }

        internal void UnreserveOneBlock()
        {
            Unreserve(s_BlockSize);
        }

        internal static ulong RoundToBlockSize(ulong num)
        {
            if (num < s_BlockSize)
                return s_BlockSize;

            ulong rem = (num % s_BlockSize);

            if (rem != 0)
                num += (s_BlockSize - rem);

            return num;
        }

        // Helper static methods
        internal static String GetRootDir(IsolatedStorageScope scope)
        {
            if (IsRoaming(scope))
            {
                if (s_RootDirRoaming == null)
                    s_RootDirRoaming = nGetRootDir(scope);

                return s_RootDirRoaming;
            }

            if (s_RootDirUser == null)
                InitGlobalsNonRoaming(scope);

            return s_RootDirUser;
        }

        private static void InitGlobalsNonRoaming(IsolatedStorageScope scope)
        {
            String rootDir = nGetRootDir(scope);
            new FileIOPermission(FileIOPermissionAccess.AllAccess, rootDir).Assert();
            bool bMigrateNeeded = false;
            string sOldStoreLocation = null;
            String rndName = GetRandomDirectory(rootDir, out bMigrateNeeded, out sOldStoreLocation);
            if (rndName == null) {  // Create a random directory
                Mutex m = CreateMutexNotOwned(rootDir);
                if (!m.WaitOne())
                    throw new IsolatedStorageException(Environment.GetResourceString("IsolatedStorage_Init"));
                try {   // finally...
                    rndName = GetRandomDirectory(rootDir, out bMigrateNeeded, out sOldStoreLocation);  // try again with lock
                    if (rndName == null) {
                        if (bMigrateNeeded) {
                            // We have a store directory in the old format; we need to migrate it
                            rndName = MigrateOldIsoStoreDirectory(rootDir, sOldStoreLocation);
                        } else {
                            rndName = CreateRandomDirectory(rootDir);                   
                        }
                    }
                } finally {
                    m.ReleaseMutex();
                }
            }
            s_RootDirUser = rootDir + rndName + "\\";
        }

        // returns a random directory string without the path separator
        internal static string GenerateRandomDirectory() {
            // 5 bytes == 40 bits == 40/5 == 8 chars in our encoding
            // This gives us exactly 8 chars. We want to avoid the 8.3 short name issue
            byte[] key = new byte[10];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetBytes(key);
            // rndCharArray is expected to be 16 chars
            char[] rndCharArray = ToBase32StringSuitableForDirName(key).ToCharArray();
            rndCharArray[8] = '.';
            return String.CreateFromCharArray(rndCharArray, 0, 12);
        }

        // Migrates the old store location to a new one and returns the new location without the path separator
        internal static string MigrateOldIsoStoreDirectory(string rootDir, string oldRandomDirectory) {
            // First create the new random directory
            string relRandomDirectory1 = GenerateRandomDirectory();
            string relRandomDirectory2 = GenerateRandomDirectory();
            string firstRandomDirectory  = rootDir + relRandomDirectory1;
            string newRandomDirectory = firstRandomDirectory + "\\" + relRandomDirectory2;
            // Move the old directory to the new location, throw an exception and revert
            // the transaction if the operation is not successful
            try {
                // Create the first level of the new random directory
                Directory.CreateDirectory(firstRandomDirectory);
                // Move the old directory under the newly created random directory
                Directory.Move(rootDir + oldRandomDirectory, newRandomDirectory);
            } catch (Exception) {
                // We don't want to leak any information here. 
                // Throw a store initialization exception instead
                throw new IsolatedStorageException(Environment.GetResourceString("IsolatedStorage_Init"));
            }
            return (relRandomDirectory1 + "\\" + relRandomDirectory2);
        }

        // creates and returns the relative path to the random directory string without the path separator
        internal static string CreateRandomDirectory(String rootDir) {
            string rndName = GenerateRandomDirectory() + "\\" + GenerateRandomDirectory();
            try {
                Directory.CreateDirectory(rootDir + rndName);
            } catch (Exception) {
                // We don't want to leak any information here
                // Throw a store initialization exception instead
                throw new IsolatedStorageException(Environment.GetResourceString("IsolatedStorage_Init"));
            }
            return rndName;
        }

        // returns the relative path to the current random directory string if one is there without the path separator
        internal static string GetRandomDirectory(String rootDir, out bool bMigrateNeeded, out string sOldStoreLocation)
        {
            // Initialize Out Parameters 
            bMigrateNeeded = false; sOldStoreLocation = null;
            String[] nodes1 = GetFileDirectoryNames(rootDir + "*", "*", false);
            // First see if there is a new store 
            for (int i=0; i<nodes1.Length; ++i) {
                if (nodes1[i].Length == 12) {
                    String[] nodes2 = GetFileDirectoryNames(rootDir + nodes1[i] + "\\" + "*", "*", false);
                    for (int j=0; j<nodes2.Length; ++j) {
                        if (nodes2[j].Length == 12) {
                            return (nodes1[i] +  "\\" + nodes2[j]); // Get the first directory
                        }
                    }
                }
            }
            // We look for directories of length 24: if we find one
            // it means we are still using the old random directory format.
            // In that case, migrate to a new store 
            for (int i=0; i<nodes1.Length; ++i) {
                if (nodes1[i].Length == 24) {
                    bMigrateNeeded = true;
                    sOldStoreLocation = nodes1[i]; // set the old store location
                    return null;
                }
            }
            // Neither old or new store formats have been encountered, return null
            return null;
        }

        internal static Mutex CreateMutexNotOwned(string pathName)
        {
            return new Mutex(false, GetStrongHashSuitableForObjectName(pathName));
        }

        internal static String GetStrongHashSuitableForObjectName(string name)
        {
            MemoryStream ms  = new MemoryStream();
            new BinaryWriter(ms).Write(name.ToUpper(CultureInfo.InvariantCulture));
            ms.Position = 0;
            return ToBase32StringSuitableForDirName(new SHA1Managed().ComputeHash(ms));
        }

        private String GetSyncObjectName()
        {
            if (m_SyncObjectName == null)
            {
                // Don't take a lock here,  ok to create multiple times
                m_SyncObjectName = GetStrongHashSuitableForObjectName(m_InfoFile);
            }
            return m_SyncObjectName;
        }

        internal void Lock()
        {
            if (IsRoaming())     // don't lock Roaming stores
                return;

            lock (this)
            {
                if (m_bDisposed)
                    throw new ObjectDisposedException(null, Environment.GetResourceString("IsolatedStorage_StoreNotOpen"));

                if (m_closed)
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "IsolatedStorage_StoreNotOpen"));

                if (m_handle == Win32Native.NULL)
                    m_handle = nOpen(m_InfoFile, GetSyncObjectName());

                nLock(m_handle, true);
            }
        }

        internal void Unlock()
        {
            if (IsRoaming())     // don't lock Roaming stores
                return;

            lock (this)
            {
                if (m_bDisposed)
                    throw new ObjectDisposedException(null, Environment.GetResourceString("IsolatedStorage_StoreNotOpen"));

                if (m_closed)
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "IsolatedStorage_StoreNotOpen"));

                if (m_handle == Win32Native.NULL)
                    m_handle = nOpen(m_InfoFile, GetSyncObjectName());

                nLock(m_handle, false);
            }
        }

        internal static FileIOPermission GetGlobalFileIOPerm(
                IsolatedStorageScope scope)
        {
            if (IsRoaming(scope))
            {
                // no sync needed, ok to create multiple instances.
                if (s_PermRoaming == null)
                {
                    s_PermRoaming =  new FileIOPermission(
                        FileIOPermissionAccess.AllAccess, GetRootDir(scope));
                }

                return s_PermRoaming;
            }

            // no sync needed, ok to create multiple instances.
            if (s_PermUser == null)
            {
                s_PermUser =  new FileIOPermission(
                    FileIOPermissionAccess.AllAccess, GetRootDir(scope));
            }

            return s_PermUser;
        }

        private static void DemandAdminPermission()
        {
            // Ok if more than one instance is created, no need to sync.
            if (s_PermAdminUser == null)
            {
                s_PermAdminUser = new IsolatedStorageFilePermission(
                    IsolatedStorageContainment.AdministerIsolatedStorageByUser,
                        0, false);
            }

            s_PermAdminUser.Demand();
        }

        internal static void VerifyGlobalScope(IsolatedStorageScope scope)
        {
            if ((scope != IsolatedStorageScope.User) && 
                (scope != (IsolatedStorageScope.User|
                          IsolatedStorageScope.Roaming)))
            {
                throw new ArgumentException(
                    Environment.GetResourceString(
                        "IsolatedStorage_Scope_U_R"));
            }
        }

/* Not being used right now
        internal void CreateIDFileIfNecessary(String path, bool fApp)
        {
            FileInfo fi = new FileInfo(path + s_IDFile);

            if ((fi.Exists) && (fi.Length != 0))
                return;

            CreateIDFile(path, fApp);
        }
*/

        internal void CreateIDFile(String path, bool fApp)
        {
            try {

                FileStream fs = new FileStream(path + s_IDFile, 
                                        FileMode.OpenOrCreate);
    
                MemoryStream s = GetIdentityStream(fApp);
    
                byte[] b = s.GetBuffer();
                fs.Write(b, 0, (int)s.Length);
                fs.Flush();
                fs.Close();

            } catch (Exception) {
                // OK to ignore. It is possible that another thread / process
                // is writing to this file with the same data.
            }
        }

        // From IO.Directory class (make that internal if possible)
        private static String[] GetFileDirectoryNames(String path, String msg, bool file)
        {
            int hr;

            if (path==null) throw new ArgumentNullException("path", Environment.GetResourceString("ArgumentNull_Path"));
            
            bool fEndsWithDirectory = false;
            char lastChar = path[path.Length-1];
            if (lastChar == Path.DirectorySeparatorChar || 
                lastChar == Path.AltDirectorySeparatorChar || 
                lastChar == '.')
                fEndsWithDirectory = true;
                

            // Get an absolute path and do a security check
            String fullPath = Path.GetFullPathInternal(path);

            // GetFullPath() removes '\', "\." etc from path, we will restore 
            // it here. If path ends in a trailing slash (\), append a * 
            // or we'll  get a "Cannot find the file specified" exception
            if ((fEndsWithDirectory) && 
                (fullPath[fullPath.Length - 1] != lastChar))
               fullPath += "\\*";

            // Check for read permission to the directory, not to the contents.
            String dir = Path.GetDirectoryName(fullPath);

            if (dir != null)
                dir += "\\";
    
#if _DEBUG
            if (s_fDebug)
            {
                Console.WriteLine("path = " + path);
                Console.WriteLine("fullPath = " + fullPath);
                Console.WriteLine("dir = " + dir);
            }
#endif

            new FileIOPermission(FileIOPermissionAccess.Read, dir == null ? fullPath : dir).Demand();
            
    
            String[] list = new String[10];
            int listSize = 0;
            Win32Native.WIN32_FIND_DATA data = new Win32Native.WIN32_FIND_DATA();
                    
            // Open a Find handle (Win32 is weird)
            IntPtr hnd = Win32Native.FindFirstFile(fullPath, data);
            if (hnd==Win32Native.INVALID_HANDLE_VALUE) {
                // Calls to GetLastWin32Error clobber HResult.  Store HResult.
                hr = Marshal.GetLastWin32Error();
                if (hr==Win32Native.ERROR_FILE_NOT_FOUND)
                    return new String[0];
                __Error.WinIOError(hr, msg);
            }
    
            // Keep asking for more matching files, adding file names to list
            int numEntries = 0;  // Number of directory entities we see.
            do {
                bool includeThis;  // Should this file/directory be included in the output?
                if (file)
                    includeThis = (0==(data.dwFileAttributes & Win32Native.FILE_ATTRIBUTE_DIRECTORY));
                else {
                    includeThis = (0!=(data.dwFileAttributes & Win32Native.FILE_ATTRIBUTE_DIRECTORY));
                    // Don't add "." nor ".."
                    if (includeThis && (data.cFileName.Equals(".") || data.cFileName.Equals(".."))) 
                        includeThis = false;
                }
                
                if (includeThis) {
                    numEntries++;
                    if (listSize==list.Length) {
                        String[] newList = new String[list.Length*2];
                        Array.Copy(list, 0, newList, 0, listSize);
                        list = newList;
                    }
                    list[listSize++] = data.cFileName;
                }
     
            } while (Win32Native.FindNextFile(hnd, data));
            
            // Make sure we quit with a sensible error.
            hr = Marshal.GetLastWin32Error();
            Win32Native.FindClose(hnd);  // Close Find handle in all cases.
            if (hr!=0 && hr!=Win32Native.ERROR_NO_MORE_FILES) __Error.WinIOError(hr, msg);
            
            // Check for a string such as "C:\tmp", in which case we return
            // just the directory name.  FindNextFile fails first time, and
            // data still contains a directory.
            if (!file && numEntries==1 && (0!=(data.dwFileAttributes & Win32Native.FILE_ATTRIBUTE_DIRECTORY))) {
                String[] sa = new String[1];
                sa[0] = data.cFileName;
                return sa;
            }
            
            // Return list of files/directories as an array of strings
            if (listSize == list.Length)
                return list;
            String[] items = new String[listSize];
            Array.Copy(list, 0, items, 0, listSize);
            return items;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern ulong nGetUsage(IntPtr handle);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern IntPtr nOpen(String infoFile, String syncName);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void nClose(IntPtr handle);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal unsafe static extern void nReserve(IntPtr handle, 
            ulong *plQuota, ulong *plReserve, bool fFree);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern String nGetRootDir(IsolatedStorageScope scope);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void nLock(IntPtr handle, bool fLock);
    }

    internal class IsolatedStorageFileEnumerator : IEnumerator
    {
        private static char[] s_SepInternal = {'.'};
        private static char   s_SepExternal = '\\';

        private IsolatedStorageFile  m_Current;
        private IsolatedStorageScope m_Scope;
        private FileIOPermission     m_fiop;
        private String               m_rootDir;

        private TwoLevelFileEnumerator  m_fileEnum;
        private bool                    m_fReset;
        private bool                    m_fEnd;

#if _DEBUG
        private static bool s_fDebug = false;
#endif

        internal IsolatedStorageFileEnumerator(IsolatedStorageScope scope) 
        {
            m_Scope    = scope;
            m_fiop     = IsolatedStorageFile.GetGlobalFileIOPerm(scope);
            m_rootDir  = IsolatedStorageFile.GetRootDir(scope);
            m_fileEnum = new TwoLevelFileEnumerator(m_rootDir);
            Reset();
        }

        public bool MoveNext()
        {
            IsolatedStorageFile  isf;
            IsolatedStorageScope scope;
            bool     fApp;
            TwoPaths tp;
            Stream   app, assem;
            String   appName, assemName;

            m_fiop.Assert();

            m_fReset = false;

            do {

                if (m_fileEnum.MoveNext() == false)
                {
                    m_fEnd = true;
                    break;
                }

                // Create the store
                isf = new IsolatedStorageFile();
    
                tp   = (TwoPaths) m_fileEnum.Current;
                fApp = false;

#if _DEBUG
                if (s_fDebug)
                {
                    Console.Write(tp.Path1 + " ");
                    Console.WriteLine(tp.Path2);
                }
#endif

                if (IsolatedStorageFile.NotAssemFilesDir(tp.Path2))
                    fApp = true;

                // Create Roaming Store
                app   = null; 
                assem = null;

                if (fApp)
                {
                    if (!GetIDStream(tp.Path1, out app))
                        continue;

                    if (!GetIDStream(tp.Path1 + s_SepExternal + tp.Path2, 
                            out assem))
                        continue;

                    app.Position = 0;

                    if (IsolatedStorage.IsRoaming(m_Scope))
                        scope = IsolatedStorage.c_AppRoaming;
                    else
                        scope = IsolatedStorage.c_App;

                    appName = tp.Path1;
                    assemName = tp.Path2;
                }
                else
                {
                    if (!GetIDStream(tp.Path1, out assem))
                        continue;

                    if (IsolatedStorage.IsRoaming(m_Scope))
                        scope = IsolatedStorage.c_AssemblyRoaming;
                    else
                        scope = IsolatedStorage.c_Assembly;

                    appName   = null;
                    assemName = tp.Path1;
                }

                assem.Position = 0;

                if (!isf.InitStore(scope, app, assem, appName, assemName))
                    continue;

                if (!isf.InitExistingStore(scope))
                    continue;

                m_Current = isf;

                return true;

            } while (true);

            return false;
        }

        public Object Current 
        {
            get { 

                if (m_fReset)
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_EnumNotStarted"));
                }
                else if (m_fEnd)
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_EnumEnded"));
                }
    
                return (Object) m_Current; 
            }
        }

        public void Reset()
        {
            m_Current = null;
            m_fReset  = true;
            m_fEnd    = false;
            m_fileEnum.Reset();
        }

        private bool GetIDStream(String path, out Stream s)
        {
            StringBuilder sb = new StringBuilder();
            FileStream    fs;
            byte[]        b;

            sb.Append(m_rootDir);
            sb.Append(path);
            sb.Append(s_SepExternal);
            sb.Append(IsolatedStorageFile.s_IDFile);

            s = null;

            try {
                fs = new FileStream(sb.ToString(), FileMode.Open);
                b = new byte[(int)fs.Length];
                fs.Read(b, 0, b.Length);
                s = new MemoryStream(b);
                fs.Close();
            } catch (Exception) {
                return false;
            }

            return true;
        }
    }

    internal class TwoPaths
    {
        public String Path1;
        public String Path2;

        public void Reset()
        {
            Path1 = null;
            Path2 = null;
        }
    }

    // Given a directory, enumerates all subdirs of upto depth 2
    internal class TwoLevelFileEnumerator : IEnumerator
    {
        private String   m_Root;
        private TwoPaths m_Current;
        private bool     m_fReset;
    
        private String[] m_RootDir;
        private int      m_nRootDir;
        private bool     m_fRootDir;
    
        private String[] m_SubDir;
        private int      m_nSubDir;
    
    
        public TwoLevelFileEnumerator(String root)
        {
            m_Root = root;
            Reset();
        }

        public bool MoveNext()
        {
            lock (this)
            {
                // Sepecial case the Reset State
                if (m_fReset)
                {
                    m_fReset = false;
                    return AdvanceRootDir();
                }
        
                // Don't move anything if RootDir is empty
                if (m_RootDir.Length == 0)
                    return false;
    
    
                // Get Next SubDir
    
                ++m_nSubDir;
        
                if (m_nSubDir >= m_SubDir.Length)
                {
                    m_nSubDir = m_SubDir.Length;    // to avoid wrap aournd.
                    return AdvanceRootDir();
                }
    
                UpdateCurrent();
            }
    
            return true;
        }
    
        private bool AdvanceRootDir()
        {
            ++m_nRootDir;
    
            if (m_nRootDir >= m_RootDir.Length)
            {
                m_nRootDir = m_RootDir.Length;  // to prevent wrap around
                return false;                   // We are at the very end.
            }
    
            m_SubDir = Directory.GetDirectories(m_RootDir[m_nRootDir]);

            if (m_SubDir.Length == 0)
                return AdvanceRootDir();        // reccurse here.

            m_nSubDir  = 0;

            // Set m_Current
            UpdateCurrent();
    
            return true;
        }
    
        private void UpdateCurrent()
        {
            StringBuilder sb = new StringBuilder();
    
            m_Current.Path1 = Path.GetFileName(m_RootDir[m_nRootDir]);
            m_Current.Path2 = Path.GetFileName(m_SubDir[m_nSubDir]);
        }
    
        public Object Current
        {
            get {
    
                if (m_fReset)
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_EnumNotStarted"));
                }
                else if (m_nRootDir >= m_RootDir.Length)
                {
                    throw new InvalidOperationException(
                        Environment.GetResourceString(
                            "InvalidOperation_EnumEnded"));
                }
    
                return (Object) m_Current; 
            }
        }
    
        public void Reset()
        {
            m_RootDir  = null;
            m_nRootDir = -1;
            m_fRootDir = false;
    
            m_SubDir   = null;
            m_nSubDir  = -1;
    
            m_Current  = new TwoPaths();
            m_fReset   = true;
    
            m_RootDir  = Directory.GetDirectories(m_Root);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\isolatedstorage\__hresults.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Class:  __HResults
 *
 * Author: Shajan Dasan
 *
 * Purpose: The HRESULTS used by IsolatedStorage
 *
 * Date:  Feb 15, 2000
 *
 ===========================================================*/
namespace System.IO.IsolatedStorage {

    internal sealed class __HResults
    {
        public const int COR_E_ISOSTORE = unchecked((int)0x80131450);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\io\isolatedstorage\isolatedstoragefilestream.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Class:  IsolatedStorageFileStream
 *
 * Author: Shajan Dasan
 *
 * Purpose: Provides access to files using the same interface as FileStream
 *
 * Date:  Feb 18, 2000
 *
 ===========================================================*/
namespace System.IO.IsolatedStorage {
	using System;
	using System.IO;
    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;
    using System.Threading;
    using System.Runtime.InteropServices;

	/// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream"]/*' />
	public class IsolatedStorageFileStream : FileStream
    {
        private const String s_BackSlash = "\\";
        private const int    s_BlockSize = 1024;    // Should be a power of 2!
                                                    // see usage before 
                                                    // changing this constant

        private FileStream m_fs;
        private IsolatedStorageFile m_isf;
        private String m_GivenPath;
        private String m_FullPath;
        private bool   m_OwnedStore;

        private IsolatedStorageFileStream() {}

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.IsolatedStorageFileStream"]/*' />
        public IsolatedStorageFileStream(String path, FileMode mode) 
            : this(path, mode, (mode == FileMode.Append ? FileAccess.Write : FileAccess.ReadWrite), FileShare.None, null) {
        }
    
        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.IsolatedStorageFileStream1"]/*' />
        public IsolatedStorageFileStream(String path, FileMode mode,
                IsolatedStorageFile isf) 
            : this(path, mode, FileAccess.ReadWrite, FileShare.None, isf) {
        }
    
        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.IsolatedStorageFileStream2"]/*' />
        public IsolatedStorageFileStream(String path, FileMode mode, 
                FileAccess access) 
            : this(path, mode, access, access == FileAccess.Read?
                FileShare.Read: FileShare.None, DefaultBufferSize, null) {
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.IsolatedStorageFileStream3"]/*' />
        public IsolatedStorageFileStream(String path, FileMode mode, 
                FileAccess access, IsolatedStorageFile isf) 
            : this(path, mode, access, access == FileAccess.Read?
                FileShare.Read: FileShare.None, DefaultBufferSize, isf) {
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.IsolatedStorageFileStream4"]/*' />
        public IsolatedStorageFileStream(String path, FileMode mode, 
                FileAccess access, FileShare share) 
            : this(path, mode, access, share, DefaultBufferSize, null) {
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.IsolatedStorageFileStream5"]/*' />
        public IsolatedStorageFileStream(String path, FileMode mode, 
                FileAccess access, FileShare share, IsolatedStorageFile isf) 
            : this(path, mode, access, share, DefaultBufferSize, isf) {
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.IsolatedStorageFileStream6"]/*' />
        public IsolatedStorageFileStream(String path, FileMode mode, 
                FileAccess access, FileShare share, int bufferSize) 
            : this(path, mode, access, share, bufferSize, null) {
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.IsolatedStorageFileStream7"]/*' />
        public IsolatedStorageFileStream(String path, FileMode mode, 
            FileAccess access, FileShare share, int bufferSize,  
            IsolatedStorageFile isf) 
        {
            if (path == null)
                throw new ArgumentNullException("path");

            if ((path.Length == 0) || path.Equals(s_BackSlash))
                throw new ArgumentException(
                    Environment.GetResourceString(
                        "IsolatedStorage_path"));

            ulong oldFileSize=0, newFileSize;
            bool fNewFile = false, fLock=false;
            FileInfo fOld;
 
            if (isf == null)
            {
                m_OwnedStore = true;
                isf = IsolatedStorageFile.GetUserStoreForDomain();
            }

            m_isf = isf;

            FileIOPermission fiop = 
                new FileIOPermission(FileIOPermissionAccess.AllAccess,
                    m_isf.RootDirectory);

            fiop.Assert();
            fiop.PermitOnly();

            m_GivenPath = path;
            m_FullPath  = m_isf.GetFullPath(m_GivenPath);

            try { // for finally Unlocking locked store

                // Cache the old file size if the file size could change
                // Also find if we are going to create a new file.
    
                switch (mode) {
                case FileMode.CreateNew:        // Assume new file
                    fNewFile = true;
                    break;
    
                case FileMode.Create:           // Check for New file & Unreserve
                case FileMode.OpenOrCreate:     // Check for new file
                case FileMode.Truncate:         // Unreserve old file size
                case FileMode.Append:           // Check for new file
    
                    m_isf.Lock();               // oldFileSize needs to be 
                                                // protected
                    fLock = true;               // Lock succeded

                    try {
                        fOld = new FileInfo(m_FullPath);
                        oldFileSize = IsolatedStorageFile.RoundToBlockSize((ulong)fOld.Length);
                    } catch (Exception e) {
                        if (e is FileNotFoundException)
                            fNewFile = true;
                    }
    
                    break;
    
                case FileMode.Open:             // Open existing, else exception
                    break;
    
                default:
                    throw new ArgumentException(
                        Environment.GetResourceString(
                            "IsolatedStorage_FileOpenMode"));
                }
    
                if (fNewFile)
                    m_isf.ReserveOneBlock();
    
                try {
                    m_fs = new 
                        FileStream(m_FullPath, mode, access, share, bufferSize, 
                            false, m_GivenPath, true);
                } catch (Exception) {
    
                    if (fNewFile)
                        m_isf.UnreserveOneBlock();
    
                    throw;
                }
    
                // make adjustment to the Reserve / Unreserve state
    
                if ((fNewFile == false) &&
                    ((mode == FileMode.Truncate) || (mode == FileMode.Create)))
                {
                    newFileSize = IsolatedStorageFile.RoundToBlockSize((ulong)m_fs.Length);
        
                    if (oldFileSize > newFileSize)
                        m_isf.Unreserve(oldFileSize - newFileSize);
                    else if (newFileSize > oldFileSize)     // Can this happen ?
                        m_isf.Reserve(newFileSize - oldFileSize);
                }

            } finally {
                if (fLock)
                    m_isf.Unlock();
            }
        }
/*
    	public IsolatedStorageFileStream(IntPtr handle, FileAccess access) 
            : this(handle, access, true, false, DefaultBufferSize) {
        }
        
        public IsolatedStorageFileStream(IntPtr handle, FileAccess access, 
            bool ownsHandle) 
            : this(handle, access, ownsHandle, false, DefaultBufferSize) {
        }

        public IsolatedStorageFileStream(IntPtr handle, FileAccess access, 
            bool ownsHandle, bool isAsync) 
            : this(handle, access, ownsHandle, isAsync, DefaultBufferSize) {
        }

        [SecurityPermissionAttribute(SecurityAction.Demand, 
         Flags=SecurityPermissionFlag.UnmanagedCode)]
        public IsolatedStorageFileStream(IntPtr handle, FileAccess access, 
            bool ownsHandle, bool isAsync, int bufferSize) {
            NotPermittedError();
        }
*/

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.CanRead"]/*' />
        public override bool CanRead {
            get { return m_fs.CanRead; }
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.CanWrite"]/*' />
        public override bool CanWrite {
            get { return m_fs.CanWrite; }
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.CanSeek"]/*' />
        public override bool CanSeek {
            get { return m_fs.CanSeek; }
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.IsAsync"]/*' />
        public override bool IsAsync {
            get { return m_fs.IsAsync; }
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.Length"]/*' />
        public override long Length {
            get { return m_fs.Length; }
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.Position"]/*' />
        public override long Position {

            get { return m_fs.Position; }

            set 
            { 
    	        if (value < 0) 
                {
                    throw new ArgumentOutOfRangeException("value", 
                        Environment.GetResourceString(
                            "ArgumentOutOfRange_NeedNonNegNum"));
                }

    			Seek(value, SeekOrigin.Begin);
            }
        }

/*
        unsafe private static void AsyncFSCallback(uint errorCode, 
                uint numBytes, NativeOverlapped* pOverlapped) {
            NotPermittedError();
        }
*/

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.Close"]/*' />
        public override void Close() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.Dispose"]/*' />
        protected override void Dispose(bool disposing)
        {
            if (disposing) {
                if (m_fs != null)
                    m_fs.Close();
                if (m_OwnedStore && m_isf != null)
                    m_isf.Close();
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.Flush"]/*' />
        public override void Flush() {
            m_fs.Flush();
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.Handle"]/*' />
        public override IntPtr Handle {
            [SecurityPermissionAttribute(SecurityAction.LinkDemand, 
                                         Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                NotPermittedError();
                return Win32Native.INVALID_HANDLE_VALUE;
            }
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.SetLength"]/*' />
        public override void SetLength(long value) 
        {
            m_isf.Lock(); // oldLen needs to be protected

            try {
                ulong oldLen = (ulong)m_fs.Length;
                ulong newLen = (ulong)value;
    
                // Reserve before the operation.
                m_isf.Reserve(oldLen, newLen);
    
                try {
    
                    ZeroInit(oldLen, newLen);
    
                    m_fs.SetLength(value);
    
                } catch (Exception) {
    
                    // Undo the reserve
                    m_isf.UndoReserveOperation(oldLen, newLen);
    
                    throw;
                }
    
                // Unreserve if this operation reduced the file size.
                if (oldLen > newLen)
                {
                    // params oldlen, newlength reversed on purpose.
                    m_isf.UndoReserveOperation(newLen, oldLen);
                }

            } finally {
                m_isf.Unlock();
            }
        }

        // 0 out the allocated disk so that 
        // untrusted apps won't be able to read garbage, which
        // is a security  hole, if allowed.
        // This may not be necessary in some file systems ?
        private void ZeroInit(ulong oldLen, ulong newLen)
        {
            if (oldLen >= newLen)
                return;

            ulong    rem  = newLen - oldLen;
            byte[] buffer = new byte[s_BlockSize];  // buffer is zero inited 
                                                    // here by the runtime 
                                                    // memory allocator.

            // back up the current position.
            long pos      = m_fs.Position;

            m_fs.Seek((long)oldLen, SeekOrigin.Begin);

            // If we have a small number of bytes to write, do that and
            // we are done.
            if (rem <= (ulong)s_BlockSize)
            {
                m_fs.Write(buffer, 0, (int)rem);
                m_fs.Position = pos;
                return;
            }

            // Block write is better than writing a byte in a loop
            // or all bytes. The number of bytes to write could
            // be very large.

            // Align to block size
            // allign = s_BlockSize - (int)(oldLen % s_BlockSize);
            // Converting % to & operation since s_BlockSize is a power of 2

            int allign = s_BlockSize - (int)(oldLen & ((ulong)s_BlockSize - 1));

            /* 
                this will never happen since we already handled this case
                leaving this code here for documentation
            if ((ulong)allign > rem)
                allign = (int)rem;
            */

            m_fs.Write(buffer, 0, allign);
            rem -= (ulong)allign;

            int nBlocks = (int)(rem / s_BlockSize);

            // Write out one block at a time.
            for (int i=0; i<nBlocks; ++i)
                m_fs.Write(buffer, 0, s_BlockSize);

            // Write out the remaining bytes.
            // m_fs.Write(buffer, 0, (int) (rem % s_BlockSize));
            // Converting % to & operation since s_BlockSize is a power of 2
            m_fs.Write(buffer, 0, (int) (rem & ((ulong)s_BlockSize - 1)));

            // restore the current position
            m_fs.Position = pos;
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.Read"]/*' />
        public override int Read(byte[] buffer, int offset, int count) {
            return m_fs.Read(buffer, offset, count);
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.ReadByte"]/*' />
        public override int ReadByte() {
            return m_fs.ReadByte();
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.Seek"]/*' />
        public override long Seek(long offset, SeekOrigin origin) 
        {
            // Seek operation could increase the file size, make sure
            // that the quota is updated, and file is zeroed out

            ulong oldLen;
            ulong newLen;
            long  ret;

            oldLen = (ulong) m_fs.Length;

            switch (origin) {
            case SeekOrigin.Begin:
                newLen = (ulong)offset;
                break;
            case SeekOrigin.Current:
                newLen = (ulong)(m_fs.Position + offset);
                break;
            case SeekOrigin.End:
                newLen = oldLen + (ulong)offset;
                break;
            default:
                throw new ArgumentException(
                    Environment.GetResourceString(
                        "IsolatedStorage_SeekOrigin"));
            }

            m_isf.Reserve(oldLen, newLen);

            try {

                ZeroInit(oldLen, newLen);

                ret = m_fs.Seek(offset, origin);

            } catch (Exception) {

                m_isf.UndoReserveOperation(oldLen, newLen);

                throw;
            }

            return ret;
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.Write"]/*' />
        public override void Write(byte[] buffer, int offset, int count) 
        {
            ulong oldLen = (ulong)m_fs.Length;
            ulong newLen = (ulong)(m_fs.Position + count);

            m_isf.Reserve(oldLen, newLen);

            try {

                m_fs.Write(buffer, offset, count);

            } catch (Exception) {

                m_isf.UndoReserveOperation(oldLen, newLen);

                throw;
            }
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.WriteByte"]/*' />
        public override void WriteByte(byte value)
        {
            ulong oldLen = (ulong)m_fs.Length;
            ulong newLen = (ulong)m_fs.Position + 1;

            m_isf.Reserve(oldLen, newLen);

            try {
                
                m_fs.WriteByte(value);

            } catch (Exception) {

                m_isf.UndoReserveOperation(oldLen, newLen);

                throw;
            }
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.BeginRead"]/*' />
        public override IAsyncResult BeginRead(byte[] buffer, int offset, 
            int numBytes, AsyncCallback userCallback, Object stateObject) {
            return m_fs.BeginRead(buffer, offset, numBytes, userCallback, stateObject);
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.EndRead"]/*' />
        public override int EndRead(IAsyncResult asyncResult) {
            return m_fs.EndRead(asyncResult);
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.BeginWrite"]/*' />
        public override IAsyncResult BeginWrite(byte[] buffer, int offset, 
            int numBytes, AsyncCallback userCallback, Object stateObject) {
            ulong oldLen = (ulong)m_fs.Length;
            ulong newLen = (ulong)m_fs.Position + (ulong)numBytes;
            m_isf.Reserve(oldLen, newLen);

            try {
                
                return m_fs.BeginWrite(buffer, offset, numBytes, userCallback, stateObject);

            } catch (Exception) {

                m_isf.UndoReserveOperation(oldLen, newLen);

                throw;
            }
        }

        /// <include file='doc\IsolatedStorageFileStream.uex' path='docs/doc[@for="IsolatedStorageFileStream.EndWrite"]/*' />
        public override void EndWrite(IAsyncResult asyncResult) {
            m_fs.EndWrite(asyncResult);
        }

        internal void NotPermittedError(String str) {
            throw new IsolatedStorageException(str);
        }

        internal void NotPermittedError() {
            NotPermittedError(Environment.GetResourceString(
                "IsolatedStorage_Operation"));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\assemblyattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** File: AssemblyAttributes
**
** Author: Suzanne Cook
**
** Purpose: For Assembly-related custom attributes.
**
** Date: April 12, 2000
**
=============================================================================*/

namespace System.Reflection {

    using System;
    using System.Configuration.Assemblies;

    /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyCultureAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyCultureAttribute : Attribute 
    {
        private String m_culture; 

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyCultureAttribute.AssemblyCultureAttribute"]/*' />
        public AssemblyCultureAttribute(String culture)
        {
            m_culture = culture;
        }

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyCultureAttribute.Culture"]/*' />
        public String Culture
        {
            get { return m_culture; }
        }
    }

    /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyVersionAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyVersionAttribute : Attribute 
    {
        private String m_version;

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyVersionAttribute.AssemblyVersionAttribute"]/*' />
        public AssemblyVersionAttribute(String version)
        {
            m_version = version;
        }

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyVersionAttribute.Version"]/*' />
        public String Version
        {
            get { return m_version; }
        }
    }

    /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyKeyFileAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyKeyFileAttribute : Attribute 
    {
        private String m_keyFile;

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyKeyFileAttribute.AssemblyKeyFileAttribute"]/*' />
        public AssemblyKeyFileAttribute(String keyFile)
        {
            m_keyFile = keyFile;
        }

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyKeyFileAttribute.KeyFile"]/*' />
        public String KeyFile
        {
            get { return m_keyFile; }
        }
    }

    /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyKeyNameAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyKeyNameAttribute : Attribute 
    {
        private String m_keyName; 

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyKeyNameAttribute.AssemblyKeyNameAttribute"]/*' />
        public AssemblyKeyNameAttribute(String keyName)
        {
            m_keyName = keyName;
        }

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyKeyNameAttribute.KeyName"]/*' />
        public String KeyName
        {
            get { return m_keyName; }
        }
    }

    /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyDelaySignAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyDelaySignAttribute : Attribute 
    {
        private bool m_delaySign; 

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyDelaySignAttribute.AssemblyDelaySignAttribute"]/*' />
        public AssemblyDelaySignAttribute(bool delaySign)
        {
            m_delaySign = delaySign;
        }

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyDelaySignAttribute.DelaySign"]/*' />
        public bool DelaySign
        { get
            { return m_delaySign; }
        }
    }

    /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyAlgorithmIdAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple=false)]
    public sealed class AssemblyAlgorithmIdAttribute : Attribute
    {
        private uint m_algId;

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyAlgorithmIdAttribute.AssemblyAlgorithmIdAttribute"]/*' />
        public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId)
        {
            m_algId = (uint) algorithmId;
        }

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyAlgorithmIdAttribute.AssemblyAlgorithmIdAttribute1"]/*' />
        [CLSCompliant(false)]
        public AssemblyAlgorithmIdAttribute(uint algorithmId)
        {
            m_algId = algorithmId;
        }

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyAlgorithmIdAttribute.AlgorithmId"]/*' />
        [CLSCompliant(false)]
        public uint AlgorithmId
        {
            get { return m_algId; }
        }
    }

    /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyFlagsAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple=false)]
    public sealed class AssemblyFlagsAttribute : Attribute
    {
        private uint m_flags;

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyFlagsAttribute.AssemblyFlagsAttribute"]/*' />
        [CLSCompliant(false)]
        public AssemblyFlagsAttribute(uint flags)
        {
            m_flags = flags;
        }

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyFlagsAttribute.AssemblyFlagsAttribute1"]/*' />
        public AssemblyFlagsAttribute(int assemblyFlags)
        {
            m_flags = (uint)assemblyFlags;
        }

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyFlagsAttribute.Flags"]/*' />
        [CLSCompliant(false)]
        public uint Flags
        {
            get { return m_flags; }
        }

        /// <include file='doc\AssemblyAttributes.uex' path='docs/doc[@for="AssemblyFlagsAttribute.AssemblyFlags"]/*' />
        public int AssemblyFlags
        {
            get { return (int)m_flags; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\ambiguousmatchexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// AmbiguousMatchException is thrown when binding to a method results in more
//	than one method matching the binding criteria.  This exception is thrown in
//	general when something is Ambiguous.
//
// Author: darylo
// Date: March 98
//
namespace System.Reflection {
	using System;
	using SystemException = System.SystemException;
	using System.Runtime.Serialization;
    /// <include file='doc\AmbiguousMatchException.uex' path='docs/doc[@for="AmbiguousMatchException"]/*' />
	[Serializable()]    
    public sealed class AmbiguousMatchException : SystemException
	{
    	
        /// <include file='doc\AmbiguousMatchException.uex' path='docs/doc[@for="AmbiguousMatchException.AmbiguousMatchException"]/*' />
        public AmbiguousMatchException() 
	        : base(Environment.GetResourceString("Arg_AmbiguousMatchException")) {
			SetErrorCode(__HResults.COR_E_AMBIGUOUSMATCH);
        }
    
        /// <include file='doc\AmbiguousMatchException.uex' path='docs/doc[@for="AmbiguousMatchException.AmbiguousMatchException1"]/*' />
        public AmbiguousMatchException(String message) : base(message) {
    		SetErrorCode(__HResults.COR_E_AMBIGUOUSMATCH);
        }
    	
        /// <include file='doc\AmbiguousMatchException.uex' path='docs/doc[@for="AmbiguousMatchException.AmbiguousMatchException2"]/*' />
        public AmbiguousMatchException(String message, Exception inner)  : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_AMBIGUOUSMATCH);
        }

        internal AmbiguousMatchException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\assemblyfileversionattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  AssemblyFileVersionAttribute
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: Instructs a compiler to use a particular Win32
**          file version number for this assembly.
**
** Date:  December 8, 2000
**
===========================================================*/

using System;

namespace System.Reflection {

    /// <include file='doc\AssemblyFileVersionAttribute.uex' path='docs/doc[@for="AssemblyFileVersionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyFileVersionAttribute : Attribute 
    {
        private String _version;

        /// <include file='doc\AssemblyFileVersionAttribute.uex' path='docs/doc[@for="AssemblyFileVersionAttribute.AssemblyFileVersionAttribute"]/*' />
        public AssemblyFileVersionAttribute(String version)
        {
            if (version == null)
                throw new ArgumentNullException("version");
            _version = version;
        }

        /// <include file='doc\AssemblyFileVersionAttribute.uex' path='docs/doc[@for="AssemblyFileVersionAttribute.Version"]/*' />
        public String Version {
            get { return _version; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\assemblyname.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    AssemblyName
**
** Author:  
**
** Purpose: Used for binding and retrieving info about an assembly
**
** Date:    June 4, 1999
**
===========================================================*/
namespace System.Reflection {
    using System;
    using System.IO;
    using System.Configuration.Assemblies;
    using System.Runtime.CompilerServices;
    using CultureInfo = System.Globalization.CultureInfo;
    using System.Runtime.Serialization;
    using System.Security.Permissions;

  /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName"]/*' />
    [Serializable()]
    public sealed class AssemblyName : ICloneable, ISerializable, IDeserializationCallback
    {
        //
        // READ ME
        // If you modify any of these fields, you must also update the 
        // AssemblyBaseObject structure in object.h
        //
        private String          _Name;                  // Name
        private byte[]          _PublicKey;
        private byte[]          _PublicKeyToken;
        private CultureInfo     _CultureInfo;
        private String          _CodeBase;              // Potential location to get the file
        private Version         _Version;
        
        private StrongNameKeyPair            _StrongNameKeyPair;
        internal Assembly        _Assembly;   // This name's assembly, if this
        //is a def, and hasn't been passed to another appdomain
        private SerializationInfo m_siInfo; //A temporary variable which we need during deserialization.

        private byte[]                _HashForControl;
        private AssemblyHashAlgorithm _HashAlgorithm;
        private AssemblyHashAlgorithm _HashAlgorithmForControl;

        private AssemblyVersionCompatibility _VersionCompatibility;
        private AssemblyNameFlags            _Flags;
       
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.AssemblyName"]/*' />
        public AssemblyName()
        { 
            _HashAlgorithm = AssemblyHashAlgorithm.None;
            _VersionCompatibility = AssemblyVersionCompatibility.SameMachine;
            _Flags = AssemblyNameFlags.None;
        }
    
        // Set and get the name of the assembly. If this is a weak Name
        // then it optionally contains a site. For strong assembly names, 
        // the name partitions up the strong name's namespace
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.Name"]/*' />
        public String Name
        {
            get { return _Name; }
            set { _Name = value; }
        }

        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.Version"]/*' />
        public Version Version
        {
            get { 
                return _Version;
            }
            set { 
                _Version = value;
            }
        }

        // Locales, internally the LCID is used for the match.
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.CultureInfo"]/*' />
        public CultureInfo CultureInfo
        {
            get {
                return _CultureInfo;
            }
            set { 
                _CultureInfo = value; 
            }
        }
    
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.CodeBase"]/*' />
        public String CodeBase
        {
            get { return _CodeBase; }
            set { _CodeBase = value; }
        }
    
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.EscapedCodeBase"]/*' />
        public String EscapedCodeBase
        {
            get { 
                if (_CodeBase == null)
                    return null;
                else
                    return EscapeCodeBase(_CodeBase);
            }
        }

        // Make a copy of this assembly name.
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.Clone"]/*' />
        public Object Clone()
        {
            AssemblyName name = new AssemblyName();
            name.Init(_Name,
                      _PublicKey,
                      _PublicKeyToken,
                      _Version,
                      _CultureInfo,
                      _HashAlgorithm,
                      _VersionCompatibility,
                      _CodeBase,
                      _Flags,
                      _StrongNameKeyPair,
                      _Assembly);
            name._HashForControl=_HashForControl;
            name._HashAlgorithmForControl = _HashAlgorithmForControl;
            return name;
        }

        /*
         * Get the AssemblyName for a given file. This will only work
         * if the file contains an assembly manifest. This method causes
         * the file to be opened and closed.
         */
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.GetAssemblyName"]/*' />
        static public AssemblyName GetAssemblyName(String assemblyFile)
        {
            if(assemblyFile == null)
                throw new ArgumentNullException("assemblyFile");

            // Assembly.GetNameInternal() will not demand path discovery 
            //  permission, so do that first.
            String fullPath = Path.GetFullPathInternal(assemblyFile);
            new FileIOPermission( FileIOPermissionAccess.PathDiscovery, fullPath ).Demand();
            return nGetFileInformation(fullPath);
        }
    
        internal void SetHashControl(byte[] hash, AssemblyHashAlgorithm hashAlgorithm)
        {
             _HashForControl = hash;
             _HashAlgorithmForControl = hashAlgorithm;
        }
    
        // The public key that is used to verify an assemblies
        // inclusion into the namespace. If the public key associated
        // with the namespace cannot verify the assembly the assembly
        // will fail to load.
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.GetPublicKey"]/*' />
        public byte[] GetPublicKey()
        {
            return _PublicKey;
        }

        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.SetPublicKey"]/*' />
        public void SetPublicKey(byte[] publicKey)
        {
            _PublicKey = publicKey;
            _Flags |= AssemblyNameFlags.PublicKey;
        }

        // The compressed version of the public key formed from a truncated hash.
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.GetPublicKeyToken"]/*' />
        public byte[] GetPublicKeyToken()
        {
            if ((_PublicKeyToken == null) &&
                (_Flags & AssemblyNameFlags.PublicKey) != 0)
                    _PublicKeyToken = nGetPublicKeyToken();
            return _PublicKeyToken;
        }

        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.SetPublicKeyToken"]/*' />
        public void SetPublicKeyToken(byte[] publicKeyToken)
        {
            _PublicKeyToken = publicKeyToken;
        }

        // Flags modifying the name. So far the only flag is PublicKey, which
        // indicates that a full public key and not the compressed version is
        // present.
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.Flags"]/*' />
        public AssemblyNameFlags Flags
        {
            get { return _Flags; }
            set { _Flags = value; }
        }

        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.HashAlgorithm"]/*' />
        public AssemblyHashAlgorithm HashAlgorithm
        {
            get { return _HashAlgorithm; }
            set { _HashAlgorithm = value; }
        }
        
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.VersionCompatibility"]/*' />
        public AssemblyVersionCompatibility VersionCompatibility
        {
            get { return _VersionCompatibility; }
            set { _VersionCompatibility = value; }
        }

        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.KeyPair"]/*' />
        public StrongNameKeyPair KeyPair
        {
            get { return _StrongNameKeyPair; }
            set { _StrongNameKeyPair = value; }
        }
       
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.FullName"]/*' />
        public String FullName
        {
            get {
                if (_Assembly == null)
                    return nToString();
                else
                    return _Assembly.FullName;
            }
        }
    
        // Returns the stringized version of the assembly name.
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.ToString"]/*' />
        public override String ToString()
        {
            String s = FullName;
            if(s == null) 
                return base.ToString();
            else 
                return s;
        }

        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.GetObjectData"]/*' />
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (info == null)
                throw new ArgumentNullException("info");
                
            // Don't serialize with _Assembly field set, because that will
            // not load the assembly correctly (and we don't need/want to load
            // that assembly in the other domain).  Get info needed from it
            // and set to null.
            if (_Assembly != null)
                _Assembly = null;

            //Allocate the serialization info and serialize our static data.
            info.AddValue("_Name", _Name);
            info.AddValue("_PublicKey", _PublicKey, typeof(byte[]));
            info.AddValue("_PublicKeyToken", _PublicKeyToken, typeof(byte[]));
            info.AddValue("_CultureInfo", (_CultureInfo == null) ? -1 :_CultureInfo.LCID);
            info.AddValue("_CodeBase", _CodeBase);
            info.AddValue("_Version", _Version);
            info.AddValue("_HashAlgorithm", _HashAlgorithm, typeof(AssemblyHashAlgorithm));
            info.AddValue("_HashAlgorithmForControl", _HashAlgorithmForControl, typeof(AssemblyHashAlgorithm));
            info.AddValue("_StrongNameKeyPair", _StrongNameKeyPair, typeof(StrongNameKeyPair));
            info.AddValue("_VersionCompatibility", _VersionCompatibility, typeof(AssemblyVersionCompatibility));
            info.AddValue("_Flags", _Flags, typeof(AssemblyNameFlags));
            info.AddValue("_HashForControl",_HashForControl,typeof(byte[]));
       }

        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.OnDeserialization"]/*' />
        public void OnDeserialization(Object sender)
        {
            // Deserialization has already been performed
            if (m_siInfo == null)
                return;

            _Name = m_siInfo.GetString("_Name");
            _PublicKey = (byte[]) m_siInfo.GetValue("_PublicKey", typeof(byte[]));
            _PublicKeyToken = (byte[]) m_siInfo.GetValue("_PublicKeyToken", typeof(byte[]));

            int lcid = (int)m_siInfo.GetInt32("_CultureInfo");
            if (lcid != -1)
                _CultureInfo = new CultureInfo(lcid);

            _CodeBase = m_siInfo.GetString("_CodeBase");
            _Version = (Version) m_siInfo.GetValue("_Version", typeof(Version));
            _HashAlgorithm = (AssemblyHashAlgorithm) m_siInfo.GetValue("_HashAlgorithm", typeof(AssemblyHashAlgorithm));
            _StrongNameKeyPair = (StrongNameKeyPair) m_siInfo.GetValue("_StrongNameKeyPair", typeof(StrongNameKeyPair));
            _Assembly = null;
            _VersionCompatibility = (AssemblyVersionCompatibility)m_siInfo.GetValue("_VersionCompatibility", typeof(AssemblyVersionCompatibility));
            _Flags = (AssemblyNameFlags) m_siInfo.GetValue("_Flags", typeof(AssemblyNameFlags));

            try {
                _HashAlgorithmForControl = (AssemblyHashAlgorithm) m_siInfo.GetValue("_HashAlgorithmForControl", typeof(AssemblyHashAlgorithm));
                _HashForControl = (byte[]) m_siInfo.GetValue("_HashForControl", typeof(byte[]));    
            }
            catch (SerializationException) { // RTM did not have these defined
                _HashAlgorithmForControl = AssemblyHashAlgorithm.None;
                _HashForControl = null;
            }
            
            m_siInfo = null;
        }

        // Constructs a new AssemblyName during deserialization.
        /// <include file='doc\AssemblyName.uex' path='docs/doc[@for="AssemblyName.AssemblyName1"]/*' />
        internal AssemblyName(SerializationInfo info, StreamingContext context)
        {
            //The graph is not valid until OnDeserialization() has been called.
            m_siInfo = info; 
        }
    
        internal AssemblyName(String name, 
                              byte[] publicKeyOrToken,
                              String codeBase,
                              AssemblyHashAlgorithm hashType,
                              Version version, 
                              CultureInfo cultureInfo,
                              AssemblyNameFlags flags)
        {
            bool publicKeyToken = ((flags & AssemblyNameFlags.PublicKey) == 0);

            Init(name,
                 (!publicKeyToken) ? publicKeyOrToken : null,
                 publicKeyToken ? publicKeyOrToken : null,
                 version,
                 cultureInfo,
                 hashType,
                 AssemblyVersionCompatibility.SameMachine,
                 codeBase,
                 flags,
                 null,     // strong name key pair
                 null);    // Assembly
        }

        /*
         * Initialize this AssemblyName.
         */
        internal void Init(String name, 
                           byte[] publicKey,
                           byte[] publicKeyToken,
                           Version version,
                           CultureInfo cultureInfo,
                           AssemblyHashAlgorithm hashAlgorithm,
                           AssemblyVersionCompatibility versionCompatibility,
                           String codeBase,
                           AssemblyNameFlags flags,
                           StrongNameKeyPair keyPair,
                           Assembly assembly) // Null if ref, matching Assembly if def
        {
            _Name = name;

            if (publicKey != null) {
                _PublicKey = new byte[publicKey.Length];
                Array.Copy(publicKey, _PublicKey, publicKey.Length);
            }
    
            if (publicKeyToken != null) {
                _PublicKeyToken = new byte[publicKeyToken.Length];
                Array.Copy(publicKeyToken, _PublicKeyToken, publicKeyToken.Length);
            }
    
            if (version != null)
                _Version = (Version) version.Clone();

            _CultureInfo = cultureInfo;
            _HashAlgorithm = hashAlgorithm;
            _VersionCompatibility = versionCompatibility;
            _CodeBase = codeBase;
            _Flags = flags;
            _StrongNameKeyPair = keyPair;
            _Assembly = assembly;
        }

        // This call opens and closes the file, but does not add the
        // assembly to the domain.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static internal extern AssemblyName nGetFileInformation(String s);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String nToString();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[] nGetPublicKeyToken();
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static internal extern String EscapeCodeBase(String codeBase);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\assembly.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: Assembly
**
** Author: Brian Grunkemeyer (BrianGru) for Craig Sinclair (CraigSi)
**
** Purpose: For Assembly-related stuff.
**
** Date: April 1, 1999
**
=============================================================================*/

namespace System.Reflection {

    using System;
    using IEnumerator = System.Collections.IEnumerator;
    using CultureInfo = System.Globalization.CultureInfo;
    using System.Security;
    using System.Security.Policy;
    using System.Security.Permissions;
    using System.IO;
    using System.Reflection.Emit;
    using System.Reflection.Cache;
    using StringBuilder = System.Text.StringBuilder;
    using System.Configuration.Assemblies;
    using StackCrawlMark = System.Threading.StackCrawlMark;
    using System.Runtime.InteropServices;
    using BinaryFormatter = System.Runtime.Serialization.Formatters.Binary.BinaryFormatter;
    using System.Runtime.CompilerServices;
    using SecurityZone = System.Security.SecurityZone;
    using IEvidenceFactory = System.Security.IEvidenceFactory;
    using System.Runtime.Serialization;
    using Microsoft.Win32;
    using ArrayList = System.Collections.ArrayList;

    /// <include file='doc\Assembly.uex' path='docs/doc[@for="ModuleResolveEventHandler"]/*' />
    [Serializable()]
    public delegate Module ModuleResolveEventHandler(Object sender, ResolveEventArgs e);


    /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly"]/*' />
    [Serializable()]
    [ClassInterface(ClassInterfaceType.AutoDual)]
    public class Assembly : IEvidenceFactory, ICustomAttributeProvider, ISerializable
    {
        //
        // READ ME
        // If you modify any of these fields, you must also update the 
        // AssemblyBaseObject structure in object.h
        //
        internal AssemblyBuilderData m_assemblyData;

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.ModuleResolve"]/*' />
        [method:SecurityPermissionAttribute( SecurityAction.LinkDemand, ControlAppDomain = true )]
        public event ModuleResolveEventHandler ModuleResolve;

        private InternalCache m_cachedData;
        private IntPtr _DontTouchThis;      // slack for ptr datum on unmanaged side
    
        private const String s_localFilePrefix = "file:";
       
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.CodeBase"]/*' />
        public virtual String CodeBase {
            get {
                String codeBase = nGetCodeBase(false);
                VerifyCodeBaseDiscovery(codeBase);
                return codeBase;
            }
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.EscapedCodeBase"]/*' />
        public virtual String EscapedCodeBase {
            get {
                return AssemblyName.EscapeCodeBase(CodeBase);
            }
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetName"]/*' />
        public virtual AssemblyName GetName()
        {
            return GetName(false);
        }
    
        // If the assembly is copied before it is loaded, the codebase will be set to the
        // actual file loaded if fCopiedName is true. If it is false, then the original code base
        // is returned.
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetName1"]/*' />
        public virtual AssemblyName GetName(bool copiedName)
        {
            AssemblyName an = new AssemblyName();

            String codeBase = nGetCodeBase(copiedName);
            VerifyCodeBaseDiscovery(codeBase);

            an.Init(nGetSimpleName(), 
                    nGetPublicKey(),
                    null, // public key token
                    GetVersion(),
                    GetLocale(),
                    nGetHashAlgorithm(),
                    AssemblyVersionCompatibility.SameMachine,
                    codeBase,
                    nGetFlags() | AssemblyNameFlags.PublicKey,
                    null, // strong name key pair
                    this);

            return an;
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.FullName"]/*' />
        public virtual String FullName {
            get {
                // If called by Object.ToString(), return val may be NULL.
                String s;
                if ((s = (String)Cache[CacheObjType.AssemblyName]) != null)
                    return s;

                s = GetFullName();
                if (s != null)
                    Cache[CacheObjType.AssemblyName] = s;

                return s;
            }
        }


        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.CreateQualifiedName"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern String CreateQualifiedName(String assemblyName, String typeName);
           
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.EntryPoint"]/*' />
        public virtual MethodInfo EntryPoint {
            get { return nGetEntryPoint(); }
        }


        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetAssembly"]/*' />
        public static Assembly GetAssembly(Type type)
        {
            if (type == null)
                throw new ArgumentNullException("type");
    
            Module m = type.Module;
            if (m == null)
                return null;
            else
                return m.Assembly;
        }


        // Case sensitive.  Does not throw on error.
        /************** PLEASE NOTE - THE GETTYPE METHODS NEED TO BE INTERNAL CALLS
        // EE USES THE ECALL FRAME TO FIND WHO THE CALLER IS. THIS"LL BREAK IF A METHOD BODY IS ADDED */
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetType"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern virtual Type GetType(String name);
    
        // Case sensitive.
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetType1"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern virtual Type GetType(String name, bool throwOnError) ;
            
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetType2"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern Type GetType(String name, bool throwOnError, bool ignoreCase) ;

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetExportedTypes"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern virtual Type[] GetExportedTypes();


        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetTypes"]/*' />
        public virtual Type[] GetTypes()
        {
            Module[] m = nGetModules(true, false);

            int iNumModules = m.Length;
            int iFinalLength = 0;
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            Type[][] ModuleTypes = new Type[iNumModules][];

            for (int i = 0; i < iNumModules; i++) {
                if (m[i] != null) {
                    ModuleTypes[i] = m[i].GetTypesInternal(ref stackMark);
                    iFinalLength += ModuleTypes[i].Length;
                }
            }
            
            int iCurrent = 0;
            Type[] ret = new Type[iFinalLength];
            for (int i = 0; i < iNumModules; i++) {
                int iLength = ModuleTypes[i].Length;
                Array.Copy(ModuleTypes[i], 0, ret, iCurrent, iLength);
                iCurrent += iLength;
            }

            return ret;
        }

        // Load a resource based on the NameSpace of the type.
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetManifestResourceStream"]/*' />
        public virtual Stream GetManifestResourceStream(Type type, String name)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return GetManifestResourceStream(type, name, false, ref stackMark);
        }
    
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetManifestResourceStream1"]/*' />
        public virtual Stream GetManifestResourceStream(String name)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return GetManifestResourceStream(name, ref stackMark, false);
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetSatelliteAssembly"]/*' />
        public Assembly GetSatelliteAssembly(CultureInfo culture)
        {
            return InternalGetSatelliteAssembly(culture, null, true);
        }

        // Useful for binding to a very specific version of a satellite assembly
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetSatelliteAssembly1"]/*' />
        public Assembly GetSatelliteAssembly(CultureInfo culture, Version version)
        {
            return InternalGetSatelliteAssembly(culture, version, true);
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.Evidence"]/*' />
        public virtual Evidence Evidence
        {
            [SecurityPermissionAttribute( SecurityAction.Demand, ControlEvidence = true )]
            get
            {
                return nGetEvidence().Copy();
            }           
        }


        // ISerializable implementation
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetObjectData"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (info==null)
                throw new ArgumentNullException("info");


            UnitySerializationHolder.GetUnitySerializationInfo(info,
                                                               UnitySerializationHolder.AssemblyUnity, 
                                                               this.FullName, 
                                                               this);
        }
    
       // ICustomAttributeProvider implementation
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetCustomAttributes"]/*' />
        public virtual Object[] GetCustomAttributes(bool inherit)
        {
            return CustomAttribute.GetCustomAttributes(this, null);
        }
        
            
        // Return a custom attribute identified by Type
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetCustomAttributes1"]/*' />
        public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            else 
                attributeType = attributeType.UnderlyingSystemType;

            if (!(attributeType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");

            return CustomAttribute.GetCustomAttributes(this, attributeType);
         }
    
        // Return if a custom attribute identified by Type
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.IsDefined"]/*' />
        public virtual bool IsDefined(Type attributeType, bool inherit)
        {
            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            return CustomAttribute.IsDefined(this, attributeType);
        }
        
        
        // Locate an assembly by the name of the file containing the manifest.
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.LoadFrom"]/*' />
        public static Assembly LoadFrom(String assemblyFile)
        {
            return LoadFrom(assemblyFile, null);
        }

        // Evidence is protected in Assembly.Load()
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.LoadFrom1"]/*' />
        public static Assembly LoadFrom(String assemblyFile, 
                                        Evidence securityEvidence)
        {
            return LoadFrom(assemblyFile,
                            securityEvidence,
                            null,
                            AssemblyHashAlgorithm.None);
        }

        // Evidence is protected in Assembly.Load()
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.LoadFrom2"]/*' />
        public static Assembly LoadFrom(String assemblyFile, 
                                        Evidence securityEvidence,
                                        byte[] hashValue, 
                                        AssemblyHashAlgorithm hashAlgorithm)
        {
            if (assemblyFile == null)
                throw new ArgumentNullException("assemblyFile");
    
            AssemblyName an = new AssemblyName();
            an.CodeBase = assemblyFile;
            an.SetHashControl(hashValue, hashAlgorithm);

            // The stack mark is ignored for LoadFrom()
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return InternalLoad(an, false, securityEvidence, ref stackMark);
        }

        // Locate an assembly by the long form of the assembly name. 
        // eg. "Toolbox.dll, version=1.1.10.1220, locale=en, publickey=1234567890123456789012345678901234567890"
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.Load"]/*' />
        public static Assembly Load(String assemblyString)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return InternalLoad(assemblyString, null, ref stackMark);
        }
    
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.Load1"]/*' />
        public static Assembly Load(String assemblyString, Evidence assemblySecurity)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return InternalLoad(assemblyString, assemblySecurity, ref stackMark);
        }

        // Locate an assembly by its name. The name can be strong or
        // weak. The assembly is loaded into the domain of the caller.
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.Load2"]/*' />
        static public Assembly Load(AssemblyName assemblyRef)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return InternalLoad(assemblyRef, false, null, ref stackMark);
        }
    
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.Load3"]/*' />
        static public Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return InternalLoad(assemblyRef, false, assemblySecurity, ref stackMark);
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.LoadWithPartialName"]/*' />
        static public Assembly LoadWithPartialName(String partialName)
        {
            return LoadWithPartialName(partialName, null);
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.LoadWithPartialName1"]/*' />
        static public Assembly LoadWithPartialName(String partialName, Evidence securityEvidence)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            Assembly result = null;
            try {
                result = InternalLoad(partialName, securityEvidence, ref stackMark);
            }
            catch(Exception) {
                AssemblyInformation fusionAssembly = EnumerateCache(partialName);
                if(fusionAssembly.FullName != null) {
                    result = InternalLoad(fusionAssembly.FullName, securityEvidence, ref stackMark);
                }
            }
            return result;
        }

        
        static internal Type LoadTypeWithPartialName(String typeName, bool fSecurityCheck)
        {
            Type t = null;
            Assembly a = null;
            String[] name = Assembly.ParseTypeName(typeName);

            // Check to see if we have an assembly and a type name in the string
            if(name != null && name.Length == 2 && name[0] != null && name[1] != null) {
                if(t == null) {
                    try {
                        a = LoadWithPartialName(name[0]);
                        if(a != null) {
                            if(fSecurityCheck)
                                // @todo: none of the callers are using this security check,
                                // and it's using the wrong stackmark, anyway
                                t = a.GetType(name[1]);
                            else
                                t = a.GetTypeInternal(name[1], false, false, false);
                        }
                    }
                    catch(Exception) {
                    }
                }
            }
            return t;
        }
                    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static internal extern String[] ParseTypeName(String typeName);

        static private AssemblyInformation EnumerateCache(String partialName)
        {
            ArrayList                       a = new ArrayList();
            AssemblyInformation             ainfo;
            AssemblyInformation             ainfoHighest = new AssemblyInformation();
            partialName = StripVersionFromAssemblyString(partialName);
            Fusion.ReadCache(a, partialName, ASM_CACHE.GAC);
            
            IEnumerator myEnum = a.GetEnumerator();
            while (myEnum.MoveNext()) {
                ainfo = (AssemblyInformation) myEnum.Current;
                if (ainfoHighest.Version == null) {
                    // Use the first valid version number
                    string[]  astrVer1 = ainfo.Version.Split('.');
                    if(astrVer1.Length == 4)
                        ainfoHighest = ainfo;
                }
                else {
                    int compare = 0;
                    if (CompareVersionString(ainfo.Version, ainfoHighest.Version, ref compare) == 0 &&
                        compare > 0)
                        ainfoHighest = ainfo;
                }
            }

            return ainfoHighest;
        }

        private static String StripVersionFromAssemblyString(String assemblyName)
        {
            int index = assemblyName.IndexOf(",");
            if (index != -1)
            {
                // find end of version
                index = assemblyName.IndexOf("Version", index);
                if (index != -1) {
                    int end = index + "Version".Length;         
                    while ((end < assemblyName.Length) && (assemblyName[end] != ','))
                        end++;

                    if(end < assemblyName.Length)
                        end++;

                    // remove version string
                    assemblyName = assemblyName.Remove(index, end - index);
                }
            }    
            return assemblyName; 
        } // StripVersionFromTypeString
        

        static private int CompareVersionString(String ver1, String ver2, ref int retn)
        {
            string[]  astrVer1 = ver1.Split('.');
            string[]  astrVer2 = ver2.Split('.');
            
            retn = 0;
            if (astrVer1.Length != 4 || astrVer2.Length != 4) {
                return -1;
            }
            
            UInt16 a = Convert.ToUInt16(astrVer1[0]);
            UInt16 b = Convert.ToUInt16(astrVer1[1]);
            UInt16 c = Convert.ToUInt16(astrVer1[2]);
            UInt16 d = Convert.ToUInt16(astrVer1[3]);
            
            UInt64 ui64Ver1 = (UInt64)a << 48 | (UInt64)b << 32 | (UInt64)c << 16 | (UInt64)d;
            
            a = Convert.ToUInt16(astrVer2[0]);
            b = Convert.ToUInt16(astrVer2[1]);
            c = Convert.ToUInt16(astrVer2[2]);
            d = Convert.ToUInt16(astrVer2[3]);
            
            UInt64 ui64Ver2 = (UInt64)a << 48 | (UInt64)b << 32 | (UInt64)c << 16 | (UInt64)d;
            
            if (ui64Ver1 > ui64Ver2)
                retn = 1;
            else if (ui64Ver1 < ui64Ver2)
                retn = -1;
            
            return 0;
        }

        // Loads the assembly with a COFF based IMAGE containing
        // an emitted assembly. The assembly is loaded into the domain
        // of the caller.
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.Load4"]/*' />
        static public Assembly Load(byte[] rawAssembly)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return nLoadImage(rawAssembly,
                              null, // symbol store
                              null, // evidence
                              ref stackMark);
        }

        // Loads the assembly with a COFF based IMAGE containing
        // an emitted assembly. The assembly is loaded into the domain
        // of the caller. The second parameter is the raw bytes
        // representing the symbol store that matches the assembly.
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.Load5"]/*' />
        static public Assembly Load(byte[] rawAssembly,
                                    byte[] rawSymbolStore)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return nLoadImage(rawAssembly,
                              rawSymbolStore,
                              null, // evidence
                              ref stackMark);
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.Load6"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlEvidence)]
        static public Assembly Load(byte[] rawAssembly,
                                    byte[] rawSymbolStore,
                                    Evidence securityEvidence)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return nLoadImage(rawAssembly,
                              rawSymbolStore,
                              securityEvidence,
                              ref stackMark);
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.LoadFile"]/*' />
        static public Assembly LoadFile(String path)
        {
            new FileIOPermission(FileIOPermissionAccess.PathDiscovery | FileIOPermissionAccess.Read, path).Demand();
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return nLoadFile(path,
                             null, // evidence
                             ref stackMark);
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.LoadFile2"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlEvidence)]
        static public Assembly LoadFile(String path,
                                        Evidence securityEvidence)
        {
            new FileIOPermission(FileIOPermissionAccess.PathDiscovery | FileIOPermissionAccess.Read, path).Demand();
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return nLoadFile(path,
                             securityEvidence,
                             ref stackMark);
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.LoadModule"]/*' />
        public Module LoadModule(String moduleName,
                                 byte[] rawModule)
        {
            return nLoadModule(moduleName,
                               rawModule,
                               null,
                               Evidence); // does a ControlEvidence demand
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.LoadModule1"]/*' />
        public Module LoadModule(String moduleName,
                                 byte[] rawModule,
                                 byte[] rawSymbolStore)
        {
            return nLoadModule(moduleName,
                               rawModule,
                               rawSymbolStore,
                               Evidence); // does a ControlEvidence demand
        }

        //
        // Locates a type from this assembly and creates an instance of it using
        // the system activator. 
        //
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.CreateInstance"]/*' />
        public Object CreateInstance(String typeName)
        {
            return CreateInstance(typeName,
                                  false, // ignore case
                                  BindingFlags.Public | BindingFlags.Instance,
                                  null, // binder
                                  null, // args
                                  null, // culture
                                  null); // activation attributes
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.CreateInstance1"]/*' />
        public Object CreateInstance(String typeName,
                                     bool ignoreCase)
        {
            return CreateInstance(typeName,
                                  ignoreCase,
                                  BindingFlags.Public | BindingFlags.Instance,
                                  null, // binder
                                  null, // args
                                  null, // culture
                                  null); // activation attributes
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.CreateInstance2"]/*' />
        public Object CreateInstance(String typeName, 
                                     bool ignoreCase,
                                     BindingFlags bindingAttr, 
                                     Binder binder,
                                     Object[] args,
                                     CultureInfo culture,
                                     Object[] activationAttributes)
        {
            Type t = GetTypeInternal(typeName, false, ignoreCase, false);
            if (t == null) return null;
            return Activator.CreateInstance(t,
                                            bindingAttr,
                                            binder,
                                            args,
                                            culture,
                                            activationAttributes);
        }
                                     
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetLoadedModules"]/*' />
        public Module[] GetLoadedModules()
        {
            return nGetModules(false, false);
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetLoadedModules2"]/*' />
        public Module[] GetLoadedModules(bool getResourceModules)
        {
            return nGetModules(false, getResourceModules);
        }
                                     
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetModules"]/*' />
        public Module[] GetModules()
        {
            return nGetModules(true, false);
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetModules2"]/*' />
        public Module[] GetModules(bool getResourceModules)
        {
            return nGetModules(true, getResourceModules);
        }

        // Returns the module in this assembly with name 'name'
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetModule"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern Module GetModule(String name);

        // Returns the file in the File table of the manifest that matches the
        // given name.  (Name should not include path.)
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetFile"]/*' />
        public virtual FileStream GetFile(String name)
        {
            Module m = GetModule(name);
            if (m == null)
                return null;

            return new FileStream(m.FullyQualifiedName, FileMode.Open,
                                  FileAccess.Read, FileShare.Read);
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetFiles"]/*' />
        public virtual FileStream[] GetFiles()
        {
            return GetFiles(false);
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetFiles2"]/*' />
        public virtual FileStream[] GetFiles(bool getResourceModules)
        {
            Module[] m = nGetModules(true, getResourceModules);
            int iLength = m.Length;
            FileStream[] fs = new FileStream[iLength];

            for(int i = 0; i < iLength; i++) {
                if (m[i] != null)
                    fs[i] = new FileStream(m[i].FullyQualifiedName, FileMode.Open,
                                           FileAccess.Read, FileShare.Read);
            }

            return fs;
        }

        // Returns the names of all the resources
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetManifestResourceNames"]/*' />
        public virtual String[] GetManifestResourceNames()
        {
            return nGetManifestResourceNames();
        }
    
        // Returns the names of all the resources
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern String[] nGetManifestResourceNames();
        
        /*
         * Get the assembly that the current code is running from.
         */
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetExecutingAssembly"]/*' />
        public static Assembly GetExecutingAssembly()
        {
                // passing address of local will also prevent inlining
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return nGetExecutingAssembly(ref stackMark);
        }
       
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetCallingAssembly"]/*' />
        public static Assembly GetCallingAssembly()
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCallersCaller;
            return nGetExecutingAssembly(ref stackMark);
        }
       
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetEntryAssembly"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern Assembly GetEntryAssembly();
    
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetReferencedAssemblies"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern AssemblyName[] GetReferencedAssemblies();


        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GetManifestResourceInfo"]/*' />
        public virtual ManifestResourceInfo GetManifestResourceInfo(String resourceName)
        {
            Assembly assemblyRef;
            String fileName;
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            int location = nGetManifestResourceInfo(resourceName,
                                                    out assemblyRef,
                                                    out fileName, ref stackMark);

            if (location == -1)
                return null;
            else
                return new ManifestResourceInfo(assemblyRef, fileName,
                                                (ResourceLocation) location);
        }
        
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.ToString"]/*' />
        public override String ToString()
        {
            String displayName = FullName; 
            if (displayName == null)
                return base.ToString();
            else
                return displayName;
        }

        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.Location"]/*' />
        public virtual String Location
        {
            get {
                String location = GetLocation();

                if (location != null)
                    new FileIOPermission( FileIOPermissionAccess.PathDiscovery, location ).Demand();

                return location;
            }
        }

        // To not break compatibility with the V1 _Assembly interface we need to make this
        // new member ComVisible(false). This should be cleaned up in Whidbey.
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.ImageRuntimeVersion"]/*' />
        [ComVisible(false)]
        public virtual String ImageRuntimeVersion
        {
            get{
                return nGetImageRuntimeVersion();
            }
        }
       
        
        /*
          Returns true if the assembly was loaded from the global assembly cache.
        */
        
        /// <include file='doc\Assembly.uex' path='docs/doc[@for="Assembly.GlobalAssemblyCache"]/*' />
        public bool GlobalAssemblyCache
        {
            get {
                return nGlobalAssemblyCache();
            }
        }

    
        internal static String VerifyCodeBase(String codebase)
        {
            if(codebase == null)
                return null;

            int len = codebase.Length;
            if (len == 0)
                return null;


            int j = codebase.IndexOf(':');
            // Check to see if the url has a prefix
            if( (j != -1) &&
                (j+2 < len) &&
                ((codebase[j+1] == '/') || (codebase[j+1] == '\\')) &&
                ((codebase[j+2] == '/') || (codebase[j+2] == '\\')) )
                return codebase;
            else if ((len > 2) && (codebase[0] == '\\') && (codebase[1] == '\\'))
                return "file://" + codebase;
            else
                return "file:///" + Path.GetFullPathInternal( codebase );
        }

        internal virtual Stream GetManifestResourceStream(Type type, String name,
                                                          bool skipSecurityCheck, ref StackCrawlMark stackMark)
        {
            StringBuilder sb = new StringBuilder();
            if(type == null) {
                if (name == null)
                    throw new ArgumentNullException("type");
            }
            else {
                String nameSpace = type.Namespace;
                if(nameSpace != null) {
                    sb.Append(nameSpace);
                    if(name != null) 
                        sb.Append(Type.Delimiter);
                }
            }

            if(name != null)
                sb.Append(name);
    
            return GetManifestResourceStream(sb.ToString(), ref stackMark, skipSecurityCheck);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern Type GetTypeInternal(String typeName, bool throwOnError, bool ignoreCase, bool publicOnly);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Module nLoadModule(String moduleName,
                                          byte[] rawModule,
                                          byte[] rawSymbolStore,
                                          Evidence securityEvidence);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern bool nGlobalAssemblyCache();
                
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String nGetImageRuntimeVersion();        

        internal Assembly()
        {
            m_assemblyData = null;
        }
    
        // Create a new module in which to emit code. This module will not contain the manifest.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static internal extern ModuleBuilder nDefineDynamicModule(Assembly containingAssembly, bool emitSymbolInfo, String filename, ref StackCrawlMark stackMark);
        
        // The following functions are native helpers for creating on-disk manifest
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void nPrepareForSavingManifestToDisk(Module assemblyModule);  // module to contain assembly information if assembly is embedded
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int nSaveToFileList(String strFileName);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int nSetHashValue(int tkFile, String strFullFileName);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int nSaveExportedType(String strComTypeName, int tkAssemblyRef, int tkTypeDef, TypeAttributes flags);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void nSavePermissionRequests(byte[] required, byte[] optional, byte[] refused);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void nSaveManifestToDisk(String strFileName, int entryPoint, int fileKind);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int nAddFileToInMemoryFileList(String strFileName, Module module);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern ModuleBuilder nGetOnDiskAssemblyModule();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern ModuleBuilder nGetInMemoryAssemblyModule();

        // Helper to get the exported typelib's guid.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern byte[] nGetExportedTypeLibGuid();
        
        // Functions for defining unmanaged resources.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static internal extern String nDefineVersionInfoResource(String filename, String title, String iconFilename, String description, 
                                                                 String copyright, String trademark, String company, String product, 
                                                                 String productVersion, String fileVersion, int lcid, bool isDll);
    
        private void DecodeSerializedEvidence( Evidence evidence,
                                               byte[] serializedEvidence )
        {
            MemoryStream ms = new MemoryStream( serializedEvidence );
            BinaryFormatter formatter = new BinaryFormatter();
                
            Evidence asmEvidence = null;
                
            PermissionSet permSet = new PermissionSet( false );
            permSet.SetPermission( new SecurityPermission( SecurityPermissionFlag.SerializationFormatter ) );
            permSet.PermitOnly();
            permSet.Assert();

            try
            {
                asmEvidence = (Evidence)formatter.Deserialize( ms );
            }
            catch (Exception)
            {
            }
                
            if (asmEvidence != null)
            {
                // Any evidence from the serialized input must:
                // 1. be placed in the assembly list since it is unverifiable.
                // 2. not be a built in class used as evidence (e.g. Zone, Site, URL, etc.)
                    
                IEnumerator enumerator = asmEvidence.GetAssemblyEnumerator();
                    
                while (enumerator.MoveNext())
                {
                    Object obj = enumerator.Current;
                    
                    if (!(obj is Zone || obj is Site || obj is Url || obj is StrongName || obj is Publisher || obj is PermissionRequestEvidence))
                        evidence.AddAssembly( obj );
                }
            }
        }       
                   
        private void AddX509Certificate( Evidence evidence, byte[] cert )
        {
            evidence.AddHost(new Publisher(new System.Security.Cryptography.X509Certificates.X509Certificate(cert)));
        }
        
        private void AddStrongName( Evidence evidence, byte[] blob )
        {
            evidence.AddHost( new StrongName( new StrongNamePublicKeyBlob( blob ), nGetSimpleName(), GetVersion() ) );
        }
    
        private Evidence CreateSecurityIdentity(String url,
                                                byte[] uniqueID,
                                                int zone,
                                                byte[] cert,
                                                byte[] serializedEvidence,
                                                Evidence additionalEvidence)
        {
            Evidence evidence = new Evidence();

            if (zone != -1)
                evidence.AddHost( new Zone((SecurityZone)zone) );
            if (url != null)
            {
                evidence.AddHost( new Url(url, true) );

                // Only create a site piece of evidence if we are not loading from a file.
                if (String.Compare( url, 0, s_localFilePrefix, 0, 5, true, CultureInfo.InvariantCulture) != 0)
                    evidence.AddHost( Site.CreateFromUrl( url ) );
            }

            if (cert != null)
                AddX509Certificate( evidence, cert );

            // This code was moved to a different function because:
            // 1) it is rarely called so we should only JIT it if we need it.
            // 2) it references lots of classes that otherwise aren't loaded.
            if (serializedEvidence != null)
                DecodeSerializedEvidence( evidence, serializedEvidence );

            byte[] blob = nGetPublicKey();

            if ((blob != null) &&
                (blob.Length != 0))
                AddStrongName( evidence, blob );
            
            evidence.AddHost( new Hash( this ) );

            // If the host (caller of Assembly.Load) provided evidence, merge it
            // with the evidence we've just created. The host evidence takes
            // priority.
            if (additionalEvidence != null)
                evidence.MergeWithNoDuplicates(additionalEvidence);

            return evidence;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern static Assembly nGetExecutingAssembly(ref StackCrawlMark stackMark);

        internal unsafe virtual Stream GetManifestResourceStream(String name, ref StackCrawlMark stackMark, bool skipSecurityCheck)
        {
            ulong length = 0;
            byte* pbInMemoryResource = GetResource(name, out length, ref stackMark, skipSecurityCheck);

            if (pbInMemoryResource != null) {
                //Console.WriteLine("Creating an unmanaged memory stream of length "+length);
                if (length > Int64.MaxValue)
                    throw new NotImplementedException(Environment.GetResourceString("NotImplemented_ResourcesLongerThan2^63"));

                // For cases where we're loading an embedded resource from an assembly,
                // in V1 we do not have any serious lifetime issues with the 
                // UnmanagedMemoryStream, according to CraigSi.  If the Stream is only used
                // in the AppDomain that contains the assembly, then if that AppDomain
                // is unloaded, we will collect all of the objects in the AppDomain first
                // before unloading assemblies.  If the Stream is shared across AppDomains,
                // then the original AppDomain was unloaded, accesses to this Stream will
                // throw an exception saying the appdomain was unloaded.  This is 
                // guaranteed be EE AppDomain goo.  And for shared assemblies like 
                // mscorlib, their lifetime is the lifetime of the process, so the 
                // assembly will NOT be unloaded, so the resource will always be in memory.
                return new __UnmanagedMemoryStream(pbInMemoryResource, (long)length, (long)length, false);
            }

            //Console.WriteLine("GetManifestResourceStream: Blob "+name+" not found...");
            return null;
        }

        internal Version GetVersion()
        {
            int majorVer, minorVer, build, revision;
            if (nGetVersion(out majorVer, out minorVer, out build, out revision) == 1)
                return new Version (majorVer, minorVer, build, revision);
            else
                return null;
        }

        internal CultureInfo GetLocale()
        {
            String locale = nGetLocale();
            if (locale == null)
                return CultureInfo.InvariantCulture;
            
            return new CultureInfo(locale);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String nGetLocale();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int nGetVersion(out int majVer, out int minVer,
                                        out int buildNum, out int revNum);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int nGetManifestResourceInfo(String resourceName,
                                                    out Assembly assemblyRef,
                                                    out String fileName,
                                                    ref StackCrawlMark stackMark);

        private void VerifyCodeBaseDiscovery(String codeBase)
        {                
            if ((codeBase != null) &&
                (String.Compare( codeBase, 0, s_localFilePrefix, 0, 5, true, CultureInfo.InvariantCulture) == 0)) {
                System.Security.Util.URLString urlString = new System.Security.Util.URLString( codeBase );
                new FileIOPermission( FileIOPermissionAccess.PathDiscovery, urlString.GetFileName() ).Demand();
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern String GetLocation();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern byte[] nGetPublicKey();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern String  nGetSimpleName();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern String nGetCodeBase(bool fCopiedName);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern AssemblyHashAlgorithm nGetHashAlgorithm();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern AssemblyNameFlags nGetFlags();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void nForceResolve();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern Evidence nGetEvidence();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void nGetGrantSet(out PermissionSet newGrant, out PermissionSet newDenied);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String GetFullName();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern MethodInfo nGetEntryPoint();

        // GetResource will return a handle to a file (or -1) and set the length.
        // It will also return a pointer to the resources if they're in memory.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private unsafe extern byte* GetResource(String resourceName, out ulong length,
                                                ref StackCrawlMark stackMark, 
                                                bool skipSecurityCheck);

        internal static Assembly InternalLoad(String assemblyString,
                                              Evidence assemblySecurity,
                                              ref StackCrawlMark stackMark)
        {
            if (assemblyString == null)
                throw new ArgumentNullException("assemblyString");
            AssemblyName an = new AssemblyName();
            an.Name = assemblyString;
            return InternalLoad(an, true, assemblySecurity, ref stackMark);
        }

        internal static Assembly InternalLoad(AssemblyName assemblyRef, bool stringized,
                                              Evidence assemblySecurity, ref StackCrawlMark stackMark)
        {
       
            if (assemblyRef == null)
                throw new ArgumentNullException("assemblyRef");

            assemblyRef=(AssemblyName)assemblyRef.Clone();

            if (assemblySecurity != null)
                new SecurityPermission( SecurityPermissionFlag.ControlEvidence ).Demand();

            String codeBase = VerifyCodeBase(assemblyRef.CodeBase);

            if (codeBase != null) {
                
                if (String.Compare( codeBase, 0, s_localFilePrefix, 0, 5, true, CultureInfo.InvariantCulture ) != 0) {
                    IPermission perm = CreateWebPermission( assemblyRef.EscapedCodeBase );
                    
                    if (perm == null) {
                        BCLDebug.Assert( false, "Unable to create System.Net.WebPermission" );
                        return null;
                    }
                    
                    perm.Demand();
                }
                else {
                    System.Security.Util.URLString urlString = new System.Security.Util.URLString( codeBase, true );
                    new FileIOPermission( FileIOPermissionAccess.PathDiscovery | FileIOPermissionAccess.Read , urlString.GetFileName() ).Demand();
                }   
            }

            return nLoad(assemblyRef, codeBase, stringized, assemblySecurity, true, null, ref stackMark);
        }

        // demandFlag:
        // 0 demand PathDiscovery permission only
        // 1 demand Read permission only
        // 2 demand both Read and PathDiscovery
        // 3 demand Web permission only
        private static void DemandPermission(String codeBase, bool havePath,
                                             int demandFlag)
        {
            FileIOPermissionAccess access = FileIOPermissionAccess.PathDiscovery;
            switch(demandFlag) {

            case 0: // default
                break;
            case 1:
                access = FileIOPermissionAccess.Read;
                break;
            case 2:
                access = FileIOPermissionAccess.PathDiscovery | FileIOPermissionAccess.Read;
                break;

            case 3:
                IPermission perm = CreateWebPermission(AssemblyName.EscapeCodeBase(codeBase));
                
                if (perm == null) {
                    BCLDebug.Assert( false, "Unable to create System.Net.WebPermission" );
                    throw new ExecutionEngineException();
                }
                else
                    perm.Demand();
                return;
            }

            if (havePath)
                codeBase = Path.GetFullPathInternal(codeBase);  // canonicalize
            else {
                System.Security.Util.URLString urlString = new System.Security.Util.URLString( codeBase, true );
                codeBase = urlString.GetFileName();
            }

            new FileIOPermission(access, codeBase).Demand();
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern Assembly nLoad(AssemblyName fileName,
                                             String codeBase,
                                             bool isStringized, 
                                             Evidence assemblySecurity,
                                             bool throwOnFileNotFound,
                                             Assembly locationHint,
                                             ref StackCrawlMark stackMark);

        private static IPermission CreateWebPermission( String codeBase )
        {
            BCLDebug.Assert( codeBase != null, "Must pass in a valid code base" );

            Object[] webArgs = new Object[2];

            Type type = RuntimeType.GetTypeInternal( "System.Net.NetworkAccess, System, Version=" + Assembly.GetExecutingAssembly().GetVersion().ToString() + ", Culture=neutral, PublicKeyToken=b77a5c561934e089", false, false, true );

            if (type == null || !type.IsEnum)
                return null;

            webArgs[0] = (Enum)Enum.Parse( type, "Connect", true );
            webArgs[1] = codeBase;

            if (webArgs[1] == null)
                return null;

            type = RuntimeType.GetTypeInternal( "System.Net.WebPermission, System, Version=" + Assembly.GetExecutingAssembly().GetVersion().ToString() + ", Culture=neutral, PublicKeyToken=b77a5c561934e089", false, false, true );

            if (type == null)
                return null;

            return (IPermission)Activator.CreateInstance( type, webArgs );
        }

        
        private Module OnModuleResolveEvent(String moduleName)
        {
            if (ModuleResolve == null)
                return null;

            Delegate[] ds = ModuleResolve.GetInvocationList();
            int len = ds.Length;
            for (int i = 0; i < len; i++) {
                Module ret = ((ModuleResolveEventHandler) ds[i])(this, new ResolveEventArgs(moduleName));
                if (ret != null)
                    return ret;              
            }

            return null;
        }
    
    
        internal Assembly InternalGetSatelliteAssembly(CultureInfo culture,
                                                       Version version,
                                                       bool throwOnFileNotFound)
        {
            if (culture == null)
                throw new ArgumentNullException("culture");
                
            AssemblyName an = new AssemblyName();
            an.SetPublicKey(nGetPublicKey());
            an.Flags = nGetFlags() | AssemblyNameFlags.PublicKey;

            if (version == null)
                an.Version = GetVersion();
            else
                an.Version = version;

            an.CultureInfo = culture;
            an.Name = nGetSimpleName() + ".resources";

            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            Assembly a = nLoad(an, null, false, null, throwOnFileNotFound, this, ref stackMark);
            if (a == this) {
                if (throwOnFileNotFound)
                    throw new FileNotFoundException(String.Format(Environment.GetResourceString("IO.FileNotFound_FileName"), an.Name));
                return null;
            }

            return a;
        }

        internal InternalCache Cache {
            get {
                // This grabs an internal copy of m_cachedData and uses
                // that instead of looking at m_cachedData directly because
                // the cache may get cleared asynchronously.  This prevents
                // us from having to take a lock.
                InternalCache cache = m_cachedData;
                if (cache == null) {
                    cache = new InternalCache("Assembly");
                    m_cachedData = cache;
                    GC.ClearCache += new ClearCacheHandler(OnCacheClear);
                }
                return cache;
            } 
        }

        internal void OnCacheClear(Object sender, ClearCacheEventArgs cacheEventArgs) {
            m_cachedData = null;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static internal extern Assembly nLoadFile(String path,
                                                  Evidence evidence,
                                                  ref StackCrawlMark stackMark);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static internal extern Assembly nLoadImage(byte[] rawAssembly,
                                                   byte[] rawSymbolStore,
                                                   Evidence evidence,
                                                   ref StackCrawlMark stackMark);
    
        // Add an entry to assembly's manifestResource table for a stand alone resource.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void nAddStandAloneResource(String strName, 
                                                    String strFileName,
                                                    String strFullFileName,
                                                    int    attribute);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern Module[] nGetModules(bool loadIfNotFound,
                                             bool getResourceModules);

        //
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
            _DontTouchThis = (IntPtr)0;
        }
#endif
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\assemblyreflectionattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** File: AssemblyReflectionAttributes.cool
**
** Author: 
**
** Purpose: For Assembly-related reflection custom attributes.
**
** Date: April 12, 2000
**
=============================================================================*/

namespace System.Reflection {

    using System;

    /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyCopyrightAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyCopyrightAttribute : Attribute 
    {
        private String m_copyright;

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyCopyrightAttribute.AssemblyCopyrightAttribute"]/*' />
        public AssemblyCopyrightAttribute(String copyright)
        {
            m_copyright = copyright;
        }

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyCopyrightAttribute.Copyright"]/*' />
        public String Copyright
        {
            get { return m_copyright; }
        }
    }

    /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyTrademarkAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyTrademarkAttribute : Attribute 
    {
        private String m_trademark;

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyTrademarkAttribute.AssemblyTrademarkAttribute"]/*' />
        public AssemblyTrademarkAttribute(String trademark)
        {
            m_trademark = trademark;
        }

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyTrademarkAttribute.Trademark"]/*' />
        public String Trademark
        {
            get { return m_trademark; }
        }
    }

    /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyProductAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyProductAttribute : Attribute 
    {
        private String m_product;

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyProductAttribute.AssemblyProductAttribute"]/*' />
        public AssemblyProductAttribute(String product)
        {
            m_product = product;
        }

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyProductAttribute.Product"]/*' />
        public String Product
        {
            get { return m_product; }
        }
    }

    /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyCompanyAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyCompanyAttribute : Attribute 
    {
        private String m_company; 

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyCompanyAttribute.AssemblyCompanyAttribute"]/*' />
        public AssemblyCompanyAttribute(String company)
        {
            m_company = company;
        }

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyCompanyAttribute.Company"]/*' />
        public String Company
        {
            get { return m_company; }
        }
    }

    /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyDescriptionAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyDescriptionAttribute : Attribute 
    {
        private String m_description; 

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyDescriptionAttribute.AssemblyDescriptionAttribute"]/*' />
        public AssemblyDescriptionAttribute(String description)
        {
            m_description = description;
        }

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyDescriptionAttribute.Description"]/*' />
        public String Description
        {
            get { return m_description; }
        }
    }

    /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyTitleAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyTitleAttribute : Attribute 
    {
        private String m_title;

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyTitleAttribute.AssemblyTitleAttribute"]/*' />
        public AssemblyTitleAttribute(String title)
        {
            m_title = title;
        }

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyTitleAttribute.Title"]/*' />
        public String Title
        {
            get { return m_title; }
        }
    }

    /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyConfigurationAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyConfigurationAttribute : Attribute 
    {
        private String m_configuration; 

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyConfigurationAttribute.AssemblyConfigurationAttribute"]/*' />
        public AssemblyConfigurationAttribute(String configuration)
        {
            m_configuration = configuration;
        }

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyConfigurationAttribute.Configuration"]/*' />
        public String Configuration
        {
            get { return m_configuration; }
        }
    }

    /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyDefaultAliasAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyDefaultAliasAttribute : Attribute 
    {
        private String m_defaultAlias;

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyDefaultAliasAttribute.AssemblyDefaultAliasAttribute"]/*' />
        public AssemblyDefaultAliasAttribute(String defaultAlias)
        {
            m_defaultAlias = defaultAlias;
        }

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyDefaultAliasAttribute.DefaultAlias"]/*' />
        public String DefaultAlias
        {
            get { return m_defaultAlias; }
        }
    }
        
    /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyInformationalVersionAttribute"]/*' />
    [AttributeUsage (AttributeTargets.Assembly, AllowMultiple=false)]  
    public sealed class AssemblyInformationalVersionAttribute : Attribute 
    {
        private String m_informationalVersion;

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyInformationalVersionAttribute.AssemblyInformationalVersionAttribute"]/*' />
        public AssemblyInformationalVersionAttribute(String informationalVersion)
        {
            m_informationalVersion = informationalVersion;
        }

        /// <include file='doc\AssemblyReflectionAttributes.uex' path='docs/doc[@for="AssemblyInformationalVersionAttribute.InformationalVersion"]/*' />
        public String InformationalVersion
        {
            get { return m_informationalVersion; }
        }
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\callingconventions.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// CallingConventions is a set of Bits representing the calling conventions
//	in the system.
//
// Author: meichint
// Date: Aug 99
//
namespace System.Reflection {
	using System.Runtime.InteropServices;
	using System;
    /// <include file='doc\CallingConventions.uex' path='docs/doc[@for="CallingConventions"]/*' />
    [Flags, Serializable]
    public enum CallingConventions
    {
		//NOTE: If you change this please update COMMember.cpp.  These
		//	are defined there.
    	/// <include file='doc\CallingConventions.uex' path='docs/doc[@for="CallingConventions.Standard"]/*' />
    	Standard		= 0x0001,
    	/// <include file='doc\CallingConventions.uex' path='docs/doc[@for="CallingConventions.VarArgs"]/*' />
    	VarArgs			= 0x0002,
    	/// <include file='doc\CallingConventions.uex' path='docs/doc[@for="CallingConventions.Any"]/*' />
    	Any				= Standard | VarArgs,
        /// <include file='doc\CallingConventions.uex' path='docs/doc[@for="CallingConventions.HasThis"]/*' />
        HasThis         = 0x0020,
        /// <include file='doc\CallingConventions.uex' path='docs/doc[@for="CallingConventions.ExplicitThis"]/*' />
        ExplicitThis    = 0x0040,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\binder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
//
// This interface defines a set of methods which interact with reflection
//	during the binding process.  This control allows systems to apply language
//	specific semantics to the binding and invocation process.
//
// Author: darylo
// Date: June 98
//
namespace System.Reflection {
    using System;
    using System.Runtime.InteropServices;
    using CultureInfo = System.Globalization.CultureInfo;
    
    /// <include file='doc\Binder.uex' path='docs/doc[@for="Binder"]/*' />
    [Serializable()]
    [ClassInterface(ClassInterfaceType.AutoDual)]
    public abstract class Binder
    {	
    	// Given a set of methods that match the basic criteria, select a method to
    	// invoke.  When this method is finished, we should have 
    	/// <include file='doc\Binder.uex' path='docs/doc[@for="Binder.BindToMethod"]/*' />
    	public abstract MethodBase BindToMethod(BindingFlags bindingAttr,MethodBase[] match,ref Object[] args,
			ParameterModifier[] modifiers,CultureInfo culture,String[] names, out Object state);
    
    	// Given a set of methods that match the basic criteria, select a method to
    	// invoke.  When this method is finished, we should have 
    	/// <include file='doc\Binder.uex' path='docs/doc[@for="Binder.BindToField"]/*' />
    	public abstract FieldInfo BindToField(BindingFlags bindingAttr,FieldInfo[] match,
			Object value,CultureInfo culture);
    								   
    	// Given a set of methods that match the base criteria, select a method based
    	// upon an array of types.  This method should return null if no method matchs
    	// the criteria.
    	/// <include file='doc\Binder.uex' path='docs/doc[@for="Binder.SelectMethod"]/*' />
    	public abstract MethodBase SelectMethod(BindingFlags bindingAttr,MethodBase[] match,
			Type[] types,ParameterModifier[] modifiers);
    	
    	
    	// Given a set of propreties that match the base criteria, select one.
    	/// <include file='doc\Binder.uex' path='docs/doc[@for="Binder.SelectProperty"]/*' />
    	public abstract PropertyInfo SelectProperty(BindingFlags bindingAttr,PropertyInfo[] match,
			Type returnType,Type[] indexes,ParameterModifier[] modifiers);
    	
		// ChangeType
		// This method will convert the value into the property type.
		//	It throws a cast exception if this fails.
    	/// <include file='doc\Binder.uex' path='docs/doc[@for="Binder.ChangeType"]/*' />
    	public abstract Object ChangeType(Object value,Type type,CultureInfo culture);

        /// <include file='doc\Binder.uex' path='docs/doc[@for="Binder.ReorderArgumentArray"]/*' />
        public abstract void ReorderArgumentArray(ref Object[] args, Object state);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\assemblynameproxy.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    AssemblyNameProxy
**
** Author:  
**
** Purpose: Remotable version the AssemblyName
**
** Date:    June 4, 1999
**
===========================================================*/
namespace System.Reflection {
    using System;

    /// <include file='doc\AssemblyNameProxy.uex' path='docs/doc[@for="AssemblyNameProxy"]/*' />
    public class AssemblyNameProxy : MarshalByRefObject 
    {
        /// <include file='doc\AssemblyNameProxy.uex' path='docs/doc[@for="AssemblyNameProxy.GetAssemblyName"]/*' />
        public AssemblyName GetAssemblyName(String assemblyFile)
        {
            return AssemblyName.nGetFileInformation(assemblyFile);
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\assemblynameflags.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    AssemblyNameFlags
**
** Author:  
**
** Purpose: Flags controlling how an AssemblyName is used
**          during binding
**
** Date:    Sept 29, 1999
**
===========================================================*/
namespace System.Reflection {
    
    using System;
    /// <include file='doc\AssemblyNameFlags.uex' path='docs/doc[@for="AssemblyNameFlags"]/*' />
    [Serializable, FlagsAttribute()]
    public enum AssemblyNameFlags
    {
        /// <include file='doc\AssemblyNameFlags.uex' path='docs/doc[@for="AssemblyNameFlags.None"]/*' />
        None            = 0,
    
        // Flag used to indicate that an assembly ref contains the full public key, not the compressed token.
        // Must match afPublicKey in CorHdr.h.
        /// <include file='doc\AssemblyNameFlags.uex' path='docs/doc[@for="AssemblyNameFlags.PublicKey"]/*' />
        PublicKey       = 1,
        /// <include file='doc\AssemblyNameFlags.uex' path='docs/doc[@for="AssemblyNameFlags.Retargetable"]/*' />
        Retargetable    = 0x100,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\bindingflags.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// BindingFlags are a set of flags that control the binding and invocation process
//	in Reflection.  There are two processes.  The first is selection of a Member which
//	is the binding phase.  The second, is invocation.  These flags control how this
//	process works.
//
// Author: darylo
// Date: June 99
//
namespace System.Reflection {
    
	using System;
    /// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags"]/*' />
    [Flags, Serializable]
    public enum BindingFlags
    {

		// NOTES: We have lookup masks defined in RuntimeType and Activator.  If we
		//	change the lookup values then these masks may need to change also.

        // a place holder for no flag specifed
    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.Default"]/*' />
    	Default             = 0x00,		

    	// These flags indicate what to search for when binding
    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.IgnoreCase"]/*' />
    	IgnoreCase			= 0x01,		// Ignore the case of Names while searching
 		/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.DeclaredOnly"]/*' />
 		DeclaredOnly		= 0x02,		// Only look at the members declared on the Type
		/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.Instance"]/*' />
		Instance			= 0x04,		// Include Instance members in search
    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.Static"]/*' />
    	Static				= 0x08,		// Include Static members in search
		/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.Public"]/*' />
		Public				= 0x10,		// Include Public members in search
    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.NonPublic"]/*' />
    	NonPublic			= 0x20,		// Include Non-Public members in search
		/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.FlattenHierarchy"]/*' />
		FlattenHierarchy	= 0x40,		// Rollup the statics into the class.
   
    	// These flags are used by InvokeMember to determine
    	// what type of member we are trying to Invoke.
    	// BindingAccess = 0xFF00;
    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.InvokeMethod"]/*' />
    	InvokeMethod		= 0x0100,
    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.CreateInstance"]/*' />
    	CreateInstance		= 0x0200,
    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.GetField"]/*' />
    	GetField			= 0x0400,
    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.SetField"]/*' />
    	SetField			= 0x0800,
    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.GetProperty"]/*' />
    	GetProperty			= 0x1000,
    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.SetProperty"]/*' />
    	SetProperty			= 0x2000,

		// These flags are also used by InvokeMember but they should only
		// be used when calling InvokeMember on a COM object.
		/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.PutDispProperty"]/*' />
		PutDispProperty     = 0x4000,
		/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.PutRefDispProperty"]/*' />
		PutRefDispProperty  = 0x8000,

    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.ExactBinding"]/*' />
    	ExactBinding		= 0x010000,		// Bind with Exact Type matching, No Change type
    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.SuppressChangeType"]/*' />
    	SuppressChangeType		= 0x020000,

    	// DefaultValueBinding will return the set of methods having ArgCount or 
    	//	more parameters.  This is used for default values, etc.
    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.OptionalParamBinding"]/*' />
    	OptionalParamBinding		= 0x040000,

		// These are a couple of misc attributes used
    	/// <include file='doc\BindingFlags.uex' path='docs/doc[@for="BindingFlags.IgnoreReturn"]/*' />
    	IgnoreReturn	= 0x01000000,	// This is used in COM Interop
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\customattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// CustomAttribute is a class representing a single custom attribute
//
namespace System.Reflection {

    using System;
    using System.Runtime.CompilerServices;
    using System.Collections;
	
    [Serializable()]    
	internal sealed class CustomAttribute {
        
        private CustomAttribute m_next;
        private Type m_caType;
        private int m_ctorToken;
        private IntPtr m_blob;
        private int m_blobCount;
        private int m_currPos;
        private IntPtr m_module;
        private int m_inheritLevel;

        internal CustomAttribute() {
            m_caType = null;
            m_inheritLevel = 0;
        }

        internal Object GetObject() {
            int propNum = 0;
            Assembly assembly = null;
            Object ca = CreateCAObject(ref propNum, ref assembly);
            if (propNum > 0) {
                Type caType = ca.GetType();
                do {
                    // deal with named properties
                    bool isProperty = false;
                    Object value = null;
                    Type type = null;
                    string propOrFieldName = GetDataForPropertyOrField(ref isProperty, out value, out type, propNum == 1);
                    if (isProperty) {
                        try {
                            // a type only comes back when a enum or an object is specified in all other cases the value 
                            // already holds the info of what type that is
                            if (type == null && value != null) 
                                type = (value is System.Type) ? s_TypeType : value.GetType();
                            RuntimePropertyInfo p = null;
                            if (type == null) 
                                p = caType.GetProperty(propOrFieldName) as RuntimePropertyInfo;
                            else
                                p = caType.GetProperty(propOrFieldName, type) as RuntimePropertyInfo;
                            p.SetValueInternal(ca, value, assembly);
                        }
                        catch(Exception e) {
                            throw new CustomAttributeFormatException(String.Format(Environment.GetResourceString("RFLCT.InvalidPropFail"),
                                                                                   propOrFieldName), 
                                                                     e);
                        }
                    }
                    else {
                        try {
                            FieldInfo f = caType.GetField(propOrFieldName);
                            f.SetValue(ca, value);
                        }
                        catch(Exception e) {
                            throw new CustomAttributeFormatException(String.Format(Environment.GetResourceString("RFLCT.InvalidFieldFail"),
                                                                                   propOrFieldName), 
                                                                     e);
                        }
                    }
                } while (--propNum > 0);
            }
            return ca;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Object CreateCAObject(ref int propNum, ref Assembly assembly);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String GetDataForPropertyOrField(ref bool isProperty, out Object value, out Type type, bool isLast);

        //[MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal ConstructorInfo GetConstructor() {
            return null;
        }

        internal Type GetAttributeType() {
            return m_caType;
        }

        //
        // IsDefined
        //

        // called by every *runtime* class implementing ICustomAttribute
        static internal bool IsDefined(Type type, Type caType, bool inherit) {
            if (type != null && type.GetElementType() != null) 
                return false;
            return CustomAttribute.IsDefined((MemberInfo)type, caType, inherit);
        }

        static internal bool IsDefined(MemberInfo member, Type caType, bool inherit) {
            if (member == null) 
                throw new ArgumentNullException("member");

            bool isDefined = CustomAttribute.IsDefined(member, caType);
            if (isDefined) 
                return true;
            
            if (inherit) {
                AttributeUsageAttribute usage = CustomAttribute.GetAttributeUsage(caType);
                if (!usage.Inherited) 
                    return false; // kill the inheritance request, the attribute does not allow for it

                // walk up the inheritance chain and look for the specified type
                switch (member.MemberType) {
                case MemberTypes.Method:
                {
                    RuntimeMethodInfo baseMethod = ((MethodInfo)member).GetParentDefinition() as RuntimeMethodInfo;
                    while (baseMethod != null) {
                        isDefined = CustomAttribute.IsDefined(baseMethod, caType);
                        if (isDefined) 
                            return true;
                        baseMethod = baseMethod.GetParentDefinition() as RuntimeMethodInfo;
                    }
                    break;
                }

                case MemberTypes.TypeInfo:
                case MemberTypes.NestedType:
                {
                    RuntimeType baseType = ((Type)member).BaseType as RuntimeType;
                    while (baseType != null) {
                        isDefined = CustomAttribute.IsDefined((MemberInfo)baseType, caType);
                        if (isDefined) 
                            return true;
                        baseType = ((Type)baseType).BaseType as RuntimeType;
                    }
                    break;
                }

                }
            }
            return false;
        }

        static private bool IsDefined(MemberInfo member, Type caType) {
            MemberTypes memberType = member.MemberType;
            int token = CustomAttribute.GetMemberToken(member, memberType);
            IntPtr module = CustomAttribute.GetMemberModule(member, memberType);
            return CustomAttribute.IsCADefinedCheckType(caType, module, token);
        }

        static private bool IsDefined(MemberInfo member, Type caType, CustomAttribute caItem) {
            MemberTypes memberType = member.MemberType;
            int token = CustomAttribute.GetMemberToken(member, memberType);
            IntPtr module = CustomAttribute.GetMemberModule(member, memberType);
            return CustomAttribute.IsCADefinedCheckType(caType, module, token);
        }

        static internal bool IsDefined(Assembly assembly, Type caType) {
            if (assembly == null) 
                throw new ArgumentNullException("assembly");

            int token = CustomAttribute.GetAssemblyToken(assembly);
            if (token != 0) {
                IntPtr module = CustomAttribute.GetAssemblyModule(assembly);
                return CustomAttribute.IsCADefinedCheckType(caType, module, token);
            }
            return false;
        }

        static internal bool IsDefined(Module module, Type caType) {
            if (module == null) 
                throw new ArgumentNullException("module");

            int token = CustomAttribute.GetModuleToken(module);
            if (token != 0) {
                IntPtr mod = CustomAttribute.GetModuleModule(module);
                return CustomAttribute.IsCADefinedCheckType(caType, mod, token);
            }
            return false;
        }

        static internal bool IsDefined(ParameterInfo param, Type caType, bool inherit) {
            if (param == null) 
                throw new ArgumentNullException("param");

            int token = param.GetToken();
            IntPtr module = param.GetModule();
            return CustomAttribute.IsCADefinedCheckType(caType, module, token);
        }

        static internal bool IsCAReturnValueDefined(RuntimeMethodInfo method, Type caType, bool inherit) {
            int token = CustomAttribute.GetMethodRetValueToken(method);
            if (token != 0) {
                IntPtr module = CustomAttribute.GetMemberModule(method, MemberTypes.Method);
                return IsCADefinedCheckType(caType, module, token);
            }
            return false;
        }

        static private bool IsCADefinedCheckType(Type caType, IntPtr module, int token)
        {
            if (caType != null) {
                caType = caType.UnderlyingSystemType;
                if (!(caType is RuntimeType)) 
        			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"caType");
            }
            return IsCADefined(((RuntimeType)caType), module, token);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static private extern bool IsCADefined(RuntimeType caType, IntPtr module, int token);
        
        //
        // GetCustomAttribute
        //

        // called by every *runtime* class implementing ICustomAttribute
        static internal Object[] GetCustomAttributes(Type type, Type caType, bool inherit) {
            if (type != null && type.GetElementType() != null) 
                return (caType == null || caType.IsValueType) ? s_gObjectEmptyArray : (Object[])Array.CreateInstance(caType, 0);
            return GetCustomAttributes((MemberInfo)type, caType, inherit);
        }

        static internal Object[] GetCustomAttributes(MemberInfo member, Type caType, bool inherit) {
            if (member == null) 
                throw new ArgumentNullException("member");

            CustomAttribute caItem = GetCustomAttributeList(member, caType, null, 0);
            
            // if we are asked to go up the hierarchy chain we have to do it now and regardless of the
            // attribute usage for the specific attribute because a derived attribute may ovveride the usage...
            
            // ... however if the attribute is sealed we can rely on the attribute usage
            if (caType != null && caType.IsSealed && inherit) {
                AttributeUsageAttribute usage = CustomAttribute.GetAttributeUsage(caType);
                if (!usage.Inherited) 
                    inherit = false; // kill the inheritance request, the attribute does not allow for it
            }
            
            if (inherit) {
                // walk up the inheritance chain and keep accumulating attributes
                int level = 1;
                switch (member.MemberType) {
                case MemberTypes.Method:
                {
                    RuntimeMethodInfo baseMethod = ((MethodInfo)member).GetParentDefinition() as RuntimeMethodInfo;
                    while (baseMethod != null) {
                        caItem = GetCustomAttributeList(baseMethod, caType, caItem, level++);
                        baseMethod = baseMethod.GetParentDefinition() as RuntimeMethodInfo;
                    }
                    break;
                }

                case MemberTypes.TypeInfo:
                case MemberTypes.NestedType:
                {
                    RuntimeType baseType = ((Type)member).BaseType as RuntimeType;
                    while (baseType != null) {
                        caItem = GetCustomAttributeList((MemberInfo)baseType, caType, caItem, level++);
                        baseType = ((Type)baseType).BaseType as RuntimeType;
                    }
                    break;
                }

                }
            }
            return CustomAttribute.CheckConsistencyAndCreateArray(caItem, caType);
        }

        static private CustomAttribute GetCustomAttributeList(MemberInfo member, Type caType, CustomAttribute caItem, int level) {
            MemberTypes memberType = member.MemberType;
            int token = CustomAttribute.GetMemberToken(member, memberType);
            IntPtr module = CustomAttribute.GetMemberModule(member, memberType);
            return CustomAttribute.GetCustomAttributeListCheckType(token, module, caType, caItem, level);
        }

        static internal Object[] GetCustomAttributes(Assembly assembly, Type caType) {
            if (assembly == null) 
                throw new ArgumentNullException("assembly");

            int token = CustomAttribute.GetAssemblyToken(assembly);
            if (token != 0) {
                IntPtr module = CustomAttribute.GetAssemblyModule(assembly);
                CustomAttribute caItem = CustomAttribute.GetCustomAttributeListCheckType(token, module, caType, null, 0);
                return CustomAttribute.CheckConsistencyAndCreateArray(caItem, caType);
            }
            return (caType == null || caType.IsValueType) ? s_gObjectEmptyArray : (Object[])Array.CreateInstance(caType, 0);
        }

        static internal Object[] GetCustomAttributes(Module module, Type caType) {
            if (module == null) 
                throw new ArgumentNullException("module");

            int token = CustomAttribute.GetModuleToken(module);
            if (token != 0) {
                IntPtr mod = CustomAttribute.GetModuleModule(module);
                CustomAttribute caItem = CustomAttribute.GetCustomAttributeListCheckType(token, mod, caType, null, 0);
                return CustomAttribute.CheckConsistencyAndCreateArray(caItem, caType);
            }
            return (caType == null || caType.IsValueType) ? s_gObjectEmptyArray : (Object[])Array.CreateInstance(caType, 0);
        }

        static internal Object[] GetCustomAttributes(ParameterInfo param, Type caType, bool inherit) {
            if (param == null) 
                throw new ArgumentNullException("param");

            int token = param.GetToken();
            IntPtr module = param.GetModule();
            CustomAttribute caItem = CustomAttribute.GetCustomAttributeListCheckType(token, module, caType, null, 0);
            return CustomAttribute.CheckConsistencyAndCreateArray(caItem, caType);
        }

        static internal Object[] GetCAReturnValue(RuntimeMethodInfo method, Type caType, bool inherit) {
            int token = CustomAttribute.GetMethodRetValueToken(method);
            if (token != 0) {
                IntPtr module = CustomAttribute.GetMemberModule(method, MemberTypes.Method);
                CustomAttribute caItem = CustomAttribute.GetCustomAttributeListCheckType(token, module, caType, null, 0);
                return CustomAttribute.CheckConsistencyAndCreateArray(caItem, caType);
            }
            return (caType == null || caType.IsValueType) ? s_gObjectEmptyArray : (Object[])Array.CreateInstance(caType, 0);
            
        }

        // private class used by the next function to properly filter CA
        class CAData {
            internal Type caType; 
            internal AttributeUsageAttribute usage; 
            internal int level; 

            internal CAData(Type caType, AttributeUsageAttribute usage, int level) {
                this.caType = caType; 
                this.usage = usage; 
                this.level = level; 
            }
        }

        // does some consisitency check between the CA list and every CA attribute usage and after
        // discarding unwanted CA return an array of them
        static private Object[] CheckConsistencyAndCreateArray(CustomAttribute caItem, Type caType) {
            // we got the max number of attributes, we may have to trim this list but let's get a count for now
            if (caItem == null) 
                return (caType == null || caType.IsValueType) ? s_gObjectEmptyArray : (Object[])Array.CreateInstance(caType, 0);
            
            int caCount = 0;
            int hasInherited = (caItem == null) ? 0 : caItem.m_inheritLevel;
            CustomAttribute caNext = caItem;
            CustomAttribute caPrev = null;
            // walk and revert the list
            while (caNext != null) {
                caCount++;
                CustomAttribute caTemp = caNext.m_next;
                caNext.m_next = caPrev;
                caPrev = caNext;
                caNext = caTemp;
            }
            caItem = caPrev;
            
            // now we have a list of custom attribute of some type. That list may contain subtype of the specific
            // type, so for every other type we have to go and check whether multiple and inherited are respected
            if (caCount > 0 && hasInherited > 0) {

                // keep track of the CA types so we can make inspection reasonable fast
                Hashtable htCAData = new Hashtable(11);

                // loop through the list of attributes checking for consistency, once an attribute
                // has been inspected is never going to be looked at again, and neither an attribute 
                // of the same type. 
                // This loop and the inspectedCATypes array should make that happen
                caNext = caItem;
                CustomAttribute caLast = null;
                while (caNext != null) {
                    AttributeUsageAttribute usage = null;
                    int caTypeLevelFound = 0;
                    
                    // get current attribute type
                    Type t = caNext.GetAttributeType();
                    
                    // look if the type has already been seen
                    CAData caData = (CAData)htCAData[t];
                    if (caData != null) {
                        usage = caData.usage;
                        caTypeLevelFound = caData.level;
                    }
                    
                    if (usage == null) 
                        // no type found, load the attribute usage 
                        // do not save the attribute usage yet because the next block may discard 
                        // the attribute which implies we pretend we never saw. That is kind of
                        // bad because we may end up reloading it again if another type comes into the picture 
                        // but we prefer the perf hit to more code complication for a case that seem to
                        // be submarginal
                        usage = CustomAttribute.GetAttributeUsage(t);

                    // if this is an inherited attribute and the attribute usage does not allow that, OR
                    // if the attribute was seen already on a different inheritance level and multiple is not allowed
                    // THEN discard
                    if ((caNext.m_inheritLevel > 0 && !usage.Inherited) || 
                            (caData != null && caTypeLevelFound < caNext.m_inheritLevel && !usage.AllowMultiple)) {
                        if (caLast == null) 
                            caItem = caNext.m_next;
                        else 
                            caLast.m_next = caNext.m_next;
                        caNext = caNext.m_next;
                        caCount--;
                        continue;
                    }

                    if (caData == null) 
                        // the attribute was never seen so far so we should add it to the table and keep going
                        htCAData[t] = new CAData(t, usage, caNext.m_inheritLevel);

                    caLast = caNext;
                    caNext = caNext.m_next;
                }
            }

            // time to return the array
            if (caCount > 0) {
                if (caType == null || caType.IsValueType) 
                    caType = s_ObjectType;
                Object[] cas = (Object[])Array.CreateInstance(caType, caCount);
                caNext = caItem;
                for (int i = 0; i < caCount; i++) {
                    cas[i] = caNext.GetObject();
                    caNext = caNext.m_next;
                }
                return cas;
            }
            else
                return (caType == null || caType.IsValueType) ? s_gObjectEmptyArray : (Object[])Array.CreateInstance(caType, 0);
        }
	
        // return the attribute usage attribute for a specific custom attribute type
        static private AttributeUsageAttribute GetAttributeUsage(Type attributeType) {
            Object[] attributeUsage = CustomAttribute.GetCustomAttributes(attributeType, s_AttributeUsageType, false);
            if (attributeUsage == null || attributeUsage.Length == 0) {
                // Check for the AttributeUsage on the base class.  Do not use 
                // inheritance in the call above, because it will recurse through
                // here endlessly.
                AttributeUsageAttribute baseUsage = null;
                if (attributeType.BaseType != null)
                    baseUsage = GetAttributeUsage(attributeType.BaseType);
                if (baseUsage != null)
                    return baseUsage;
                return AttributeUsageAttribute.Default;
            }
            else {
                if (attributeUsage.Length > 1) 
                    throw new FormatException(Environment.GetResourceString("Format_AttributeUsage"));
                return (AttributeUsageAttribute)attributeUsage[0];
            }
        }

        static private CustomAttribute GetCustomAttributeListCheckType(int token, IntPtr module, Type caType, CustomAttribute caItem, int level) {
            if (caType != null) {
                caType = caType.UnderlyingSystemType;
                if (!(caType is RuntimeType)) 
        			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"caType");
            }
            return GetCustomAttributeList(token, module, ((RuntimeType)caType), caItem, level);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static private extern CustomAttribute GetCustomAttributeList(int token, IntPtr module, RuntimeType caType, CustomAttribute caItem, int level);
        
        // list of utility functions
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static extern int GetMemberToken(MemberInfo m, MemberTypes type);
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static extern IntPtr GetMemberModule(MemberInfo m, MemberTypes type);
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static extern int GetAssemblyToken(Assembly assembly);
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static extern IntPtr GetAssemblyModule(Assembly assembly);
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static extern int GetModuleToken(Module module);
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static extern IntPtr GetModuleModule(Module module);
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        static extern int GetMethodRetValueToken(RuntimeMethodInfo method);

        private static readonly Object[] s_gObjectEmptyArray = new Object[0];
        private static readonly Type s_AttributeUsageType = typeof(System.AttributeUsageAttribute);
        private static readonly Type s_ObjectType = typeof(Object);
        private static readonly Type s_TypeType = typeof(Type);
    }   

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\customattributeformatexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// CustomAttributeFormatException is thrown when the binary format of a 
//	custom attribute is invalid.
//
// Author: darylo
// Date: March 98
//
namespace System.Reflection {
	using System;
	using ApplicationException = System.ApplicationException;
	using System.Runtime.Serialization;
    /// <include file='doc\CustomAttributeFormatException.uex' path='docs/doc[@for="CustomAttributeFormatException"]/*' />
	[Serializable()] 
    public class CustomAttributeFormatException  : FormatException {
    
        /// <include file='doc\CustomAttributeFormatException.uex' path='docs/doc[@for="CustomAttributeFormatException.CustomAttributeFormatException"]/*' />
        public CustomAttributeFormatException()
	        : base(Environment.GetResourceString("Arg_CustomAttributeFormatException")) {
    		SetErrorCode(__HResults.COR_E_CUSTOMATTRIBUTEFORMAT);
        }
    
        /// <include file='doc\CustomAttributeFormatException.uex' path='docs/doc[@for="CustomAttributeFormatException.CustomAttributeFormatException1"]/*' />
        public CustomAttributeFormatException(String message) : base(message) {
    		SetErrorCode(__HResults.COR_E_CUSTOMATTRIBUTEFORMAT);
        }
    	
        /// <include file='doc\CustomAttributeFormatException.uex' path='docs/doc[@for="CustomAttributeFormatException.CustomAttributeFormatException2"]/*' />
        public CustomAttributeFormatException(String message, Exception inner) : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_CUSTOMATTRIBUTEFORMAT);
        }

        /// <include file='doc\CustomAttributeFormatException.uex' path='docs/doc[@for="CustomAttributeFormatException.CustomAttributeFormatException3"]/*' />
        protected CustomAttributeFormatException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\eventattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// EventAttributes are an enum defining the attributes associated with
//	and Event.  These are defined in CorHdr.h and are a combination of
//	bits and enums.
//
// Author: darylo
// Date: Aug 99
//
namespace System.Reflection {
    
	using System;
    /// <include file='doc\EventAttributes.uex' path='docs/doc[@for="EventAttributes"]/*' />
	[Flags, Serializable()] 
    public enum EventAttributes
    {
    	/// <include file='doc\EventAttributes.uex' path='docs/doc[@for="EventAttributes.None"]/*' />
    	None			=   0x0000,

		// This Enum matchs the CorEventAttr defined in CorHdr.h
        /// <include file='doc\EventAttributes.uex' path='docs/doc[@for="EventAttributes.SpecialName"]/*' />
        SpecialName       =   0x0200,     // event is special.  Name describes how.

		// Reserved flags for Runtime use only.
		/// <include file='doc\EventAttributes.uex' path='docs/doc[@for="EventAttributes.ReservedMask"]/*' />
		ReservedMask          =   0x0400,
		/// <include file='doc\EventAttributes.uex' path='docs/doc[@for="EventAttributes.RTSpecialName"]/*' />
		RTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\fieldattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Reflection {
    
	using System;
    // This Enum matchs the CorFieldAttr defined in CorHdr.h
    /// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes"]/*' />
	[Flags, Serializable()] 
    public enum FieldAttributes
    {
    	// member access mask - Use this mask to retrieve accessibility information.
    	/// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.FieldAccessMask"]/*' />
    	FieldAccessMask 	=	0x0007,
    	/// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.PrivateScope"]/*' />
    	PrivateScope 		=	0x0000,	// Member not referenceable.
        /// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.Private"]/*' />
        Private   			=	0x0001,	// Accessible only by the parent type.  
    	/// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.FamANDAssem"]/*' />
    	FamANDAssem 		=	0x0002,	// Accessible by sub-types only in this Assembly.
    	/// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.Assembly"]/*' />
    	Assembly			=	0x0003,	// Accessibly by anyone in the Assembly.
        /// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.Family"]/*' />
        Family				=	0x0004,	// Accessible only by type and sub-types.    
    	/// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.FamORAssem"]/*' />
    	FamORAssem 			=	0x0005,	// Accessibly by sub-types anywhere, plus anyone in assembly.
        /// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.Public"]/*' />
        Public    			=	0x0006,	// Accessibly by anyone who has visibility to this scope.    
    	// end member access mask
    
        // field contract attributes.
    	/// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.Static"]/*' />
    	Static				=	0x0010,		// Defined on type, else per instance.
        /// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.InitOnly"]/*' />
        InitOnly  			=  	0x0020,     // Field may only be initialized, not written to after init.
        /// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.Literal"]/*' />
        Literal				=	0x0040,		// Value is compile time constant.
    	/// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.NotSerialized"]/*' />
    	NotSerialized		=	0x0080,		// Field does not have to be serialized when type is remoted.
    	
        /// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.SpecialName"]/*' />
        SpecialName			=   0x0200,     // field is special.  Name describes how.
    
    	// interop attributes
    	/// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.PinvokeImpl"]/*' />
    	PinvokeImpl 		= 	0x2000,		// Implementation is forwarded through pinvoke.

		// Reserved flags for runtime use only.
		/// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.ReservedMask"]/*' />
		ReservedMask              =   0x9500,
		/// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.RTSpecialName"]/*' />
		RTSpecialName             =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
		/// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.HasFieldMarshal"]/*' />
		HasFieldMarshal           =   0x1000,     // Field has marshalling information.
		/// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.HasDefault"]/*' />
		HasDefault                =   0x8000,     // Field has default.
		/// <include file='doc\FieldAttributes.uex' path='docs/doc[@for="FieldAttributes.HasFieldRVA"]/*' />
		HasFieldRVA               =   0x0100,     // Field has RVA.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\defaultmemberattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// DefaultMemberAttribute is defines the Member of a Type that is the "default"
//	member used by Type.InvokeMember.  The default member is simply a name given
//	to a type.
//
// Author: darylo
// Date: Oct 99
//
namespace System.Reflection {
    
    using System;

    /// <include file='doc\DefaultMemberAttribute.uex' path='docs/doc[@for="DefaultMemberAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface),Serializable]
    public sealed class DefaultMemberAttribute : Attribute
    {
		// The name of the member
    	private String m_memberName;

		// You must provide the name of the member, this is required
    	/// <include file='doc\DefaultMemberAttribute.uex' path='docs/doc[@for="DefaultMemberAttribute.DefaultMemberAttribute"]/*' />
    	public DefaultMemberAttribute(String memberName) {
    		m_memberName = memberName;
    	}

		// A get accessor to return the name from the attribute.
		// NOTE: There is no setter because the name must be provided
		//	to the constructor.  The name is not optional.
    	/// <include file='doc\DefaultMemberAttribute.uex' path='docs/doc[@for="DefaultMemberAttribute.MemberName"]/*' />
        public String MemberName {
    		get {return m_memberName;}
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\constructorinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// ConstructorInfo represents a constructor in the system.  There are two types
//	of constructors, Class constructors and Class initializers..
//
// Author: darylo
// Date: April 98
//
namespace System.Reflection {

    using System;
    using System.Runtime.InteropServices;
    using CultureInfo = System.Globalization.CultureInfo;
    using DebuggerStepThroughAttribute = System.Diagnostics.DebuggerStepThroughAttribute;

    //This class is marked serializable, but it's really the subclasses that
    //are responsible for handling the actual work of serialization if they need it.
    /// <include file='doc\ConstructorInfo.uex' path='docs/doc[@for="ConstructorInfo"]/*' />
    [Serializable()] 
    [ClassInterface(ClassInterfaceType.AutoDual)]
    abstract public class ConstructorInfo : MethodBase
    {
    	// String name of a COM+ constructor and clas initializer.
		//	NOTE: These are made readonly because they may change.
    	/// <include file='doc\ConstructorInfo.uex' path='docs/doc[@for="ConstructorInfo.ConstructorName"]/*' />
    	public readonly static String ConstructorName = ".ctor";
     	/// <include file='doc\ConstructorInfo.uex' path='docs/doc[@for="ConstructorInfo.TypeConstructorName"]/*' />
     	public readonly static String TypeConstructorName = ".cctor";
    	
		// Protected constructor.
    	/// <include file='doc\ConstructorInfo.uex' path='docs/doc[@for="ConstructorInfo.ConstructorInfo"]/*' />
    	protected ConstructorInfo() {}

		// MemberTypes
    	// Return the type MemberTypes.Constructor.
    	/// <include file='doc\ConstructorInfo.uex' path='docs/doc[@for="ConstructorInfo.MemberType"]/*' />
    	public override MemberTypes MemberType {
    		get {return System.Reflection.MemberTypes.Constructor;}
    	}
    
    	// Invoke
    	// This will invoke the constructor.  The abstract Invoke
		//	is implemented by subclasses.  The other Invoke provides
		//	default values for the parameters not commonly used.
    	/// <include file='doc\ConstructorInfo.uex' path='docs/doc[@for="ConstructorInfo.Invoke"]/*' />
		[DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
    	public Object Invoke(Object[] parameters)
    	{
    		return Invoke(BindingFlags.Default,null,parameters,null);
    	}

     	/// <include file='doc\ConstructorInfo.uex' path='docs/doc[@for="ConstructorInfo.Invoke1"]/*' />
     	public abstract Object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\eventinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// EventInfo is an abstract base class for the Events in the system.  The runtime
//  provides an __RuntimeEventInfo class that represents the events known by the
//  system.
//
// Author: darylo
// Date: July 98
//
namespace System.Reflection {
    
    //This class doesn't actually do anything yet, so we're not worrying about
    //serialization.
    using System;
    using System.Runtime.InteropServices;
    using DebuggerStepThroughAttribute = System.Diagnostics.DebuggerStepThroughAttribute;

    /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo"]/*' />
    [ClassInterface(ClassInterfaceType.AutoDual)]
    public abstract class EventInfo : MemberInfo
    {
        // Prevent from begin created
        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.EventInfo"]/*' />
        protected EventInfo() {}
    
        // The Member type Event.
        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.MemberType"]/*' />
        public override MemberTypes MemberType {
            get {return MemberTypes.Event;}
        }
        
        // GetAddMethod
        // Return the event subscribe method
        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.GetAddMethod"]/*' />
        public MethodInfo GetAddMethod() {
            return GetAddMethod(false);
        }
        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.GetAddMethod1"]/*' />
        public abstract MethodInfo GetAddMethod(bool nonPublic);
    
        // GetRemoveMethod
        // This method will return the unsubscribe method
        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.GetRemoveMethod"]/*' />
        public MethodInfo GetRemoveMethod() {
            return GetRemoveMethod(false);
        }
        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.GetRemoveMethod1"]/*' />
        abstract public MethodInfo GetRemoveMethod(bool nonPublic);

        // GetRemoveMethod
        // This method will return the unsubscribe method
        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.GetRaiseMethod"]/*' />
        public MethodInfo GetRaiseMethod() {
            return GetRaiseMethod(false);
        }
        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.GetRaiseMethod1"]/*' />
        abstract public MethodInfo GetRaiseMethod(bool nonPublic);

        
        // AddEventHandler
        // This method will attempt to add a delegate to sync the event
        //  on the target object.
        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.AddEventHandler"]/*' />
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public void AddEventHandler(Object target, Delegate handler)
        {
            MethodInfo m = GetAddMethod();
            if (m == null)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_NoPublicAddMethod"));

            Object[] obj = new Object[1];
            obj[0] = handler;
            m.Invoke(target,obj);       
        }
        
        // RemoveEventHandler
        // This method will attempt to remove the delegate that may
        //  sync this event on the target object.
        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.RemoveEventHandler"]/*' />
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public void RemoveEventHandler(Object target, Delegate handler)
        {
            MethodInfo m = GetRemoveMethod();
            if (m == null)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_NoPublicRemoveMethod"));

            Object[] obj = new Object[1];
            obj[0] = handler;
            m.Invoke(target,obj);       
        }
                
        // Return the class representing the delegate event handler.
        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.EventHandlerType"]/*' />
        public Type EventHandlerType {
            get {
                // @TODO: Right now we will simply get the delegate from
                // The signature on the Add Method.  Is this the right thing
                //  to do?
                MethodInfo m = GetAddMethod(true);
                ParameterInfo[] p = m.GetParameters();
                Type del = typeof(Delegate);
                for (int i=0;i<p.Length;i++) {
                    Type c = p[i].ParameterType;
                    if (c.IsSubclassOf(del))
                        return c;
                }
                return null;
            }
        }
        
        // Attribute -- Return the attributes associated
        //  with this event.
        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.Attributes"]/*' />
        public abstract EventAttributes Attributes {
            get;
        }

        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.IsSpecialName"]/*' />
        public bool IsSpecialName {
            get {
                return ((Attributes & EventAttributes.SpecialName) != 0);
            }
        }

        /// <include file='doc\EventInfo.uex' path='docs/doc[@for="EventInfo.IsMulticast"]/*' />
        public bool IsMulticast {
            get {
                Type cl = EventHandlerType;
                Type mc = typeof(MulticastDelegate);
                return mc.IsAssignableFrom(cl);
            }
        } 

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\fieldinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// FieldInfo is an abstract base class that represents fields.  Fields may be either
//	defined on a class or global.  The system provides __RuntimeFieldInfo as the 
//	implementation representing fields in the runtime.
//
// Author: darylo
// Date: April 98
//
namespace System.Reflection {
	using System;
	using System.Runtime.InteropServices;
	using CultureInfo = System.Globalization.CultureInfo;
    using DebuggerStepThroughAttribute = System.Diagnostics.DebuggerStepThroughAttribute;

    /// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo"]/*' />
	[Serializable()] 
    [ClassInterface(ClassInterfaceType.AutoDual)]
    public abstract class FieldInfo : MemberInfo
    {
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.FieldInfo"]/*' />
    	protected FieldInfo() {}
		
    	/////////////// MemberInfo Routines /////////////////////////////////////////////    	
    	// The Member type Field.
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.MemberType"]/*' />
    	public override MemberTypes MemberType {
    		get {return System.Reflection.MemberTypes.Field;}
    	}
    		
    	// Return the Type that represents the type of the field
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.FieldType"]/*' />
    	public abstract Type FieldType {
    		get;
    	}	
    	
    	// GetValue 
    	// This method will return a variant which represents the 
    	//	value of the field
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.GetValue"]/*' />
    	abstract public Object GetValue(Object obj);

		/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.GetValueDirect"]/*' />
     	[CLSCompliant(false)]
		public virtual Object GetValueDirect(TypedReference obj)
		{
			throw new NotSupportedException(Environment.GetResourceString("NotSupported_AbstractNonCLS"));
		}
   
    
    
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.SetValue"]/*' />
		[DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
    	public void SetValue(Object obj, Object value)
    	{
    		SetValue(obj,value,BindingFlags.Default,Type.DefaultBinder,null);
    	}
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.SetValue1"]/*' />
    	abstract public void SetValue(Object obj, Object value,BindingFlags invokeAttr,Binder binder,CultureInfo culture);

		/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.SetValueDirect"]/*' />
    	[CLSCompliant(false)]
		public virtual void SetValueDirect(TypedReference obj,Object value)
		{
			throw new NotSupportedException(Environment.GetResourceString("NotSupported_AbstractNonCLS"));
		}

 		// Field Handle routines
		/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.FieldHandle"]/*' />
		public abstract RuntimeFieldHandle FieldHandle {
			get;
		}

		/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.GetFieldFromHandle"]/*' />
		public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle)
		{
			return RuntimeFieldInfo.GetFieldFromHandleImp(handle);
		}
   		
    	////////////////////////////////////////////////////////////////////////////////
    	//   Attributes
    	////////////////////////////////////////////////////////////////////////////////
    	
    	// Property representing the Attributes associated with a Member.  All 
    	// members have a set of attributes which are defined in relation to 
    	// the specific type of member.
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.Attributes"]/*' />
    	public abstract FieldAttributes Attributes {
    		get;
    	}
    	
    
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.IsPublic"]/*' />
    	public bool IsPublic {
    		get {return ((Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Public);}
    	}
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.IsPrivate"]/*' />
    	public bool IsPrivate {
    		get {return ((Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Private);}
    	}
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.IsFamily"]/*' />
    	public bool IsFamily {
    		get {return ((Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Family);}
    	}
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.IsAssembly"]/*' />
    	public bool IsAssembly {
    		get {return ((Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Assembly);}
    	}
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.IsFamilyAndAssembly"]/*' />
    	public bool IsFamilyAndAssembly {
    		get {return ((Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.FamANDAssem);}
    	}
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.IsFamilyOrAssembly"]/*' />
    	public bool IsFamilyOrAssembly {
    		get {return ((Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.FamORAssem);}
    	}
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.IsStatic"]/*' />
    	public bool IsStatic {
    		get {return ((Attributes & FieldAttributes.Static) != 0);}
    	}
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.IsInitOnly"]/*' />
    	public bool IsInitOnly {
    		get {return ((Attributes & FieldAttributes.InitOnly) != 0);}
    	}
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.IsLiteral"]/*' />
    	public bool IsLiteral {
    		get {return ((Attributes & FieldAttributes.Literal) != 0);}
    	}
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.IsNotSerialized"]/*' />
    	public bool IsNotSerialized {
    		get {return ((Attributes & FieldAttributes.NotSerialized) != 0);}
    	}
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.IsSpecialName"]/*' />
    	public bool IsSpecialName {
    		get {return ((Attributes & FieldAttributes.SpecialName) != 0);}
    	}
    	/// <include file='doc\FieldInfo.uex' path='docs/doc[@for="FieldInfo.IsPinvokeImpl"]/*' />
    	public bool IsPinvokeImpl {
    		get {return ((Attributes & FieldAttributes.PinvokeImpl) != 0);}
    	}
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\memberfilter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// MemberFilter is a delegate used to filter Members.  This delegate is used
//	as a callback from Type.FindMembers.
//
// Author: darylo
// Date: March 98
//
namespace System.Reflection {
    
    // Define the delegate
    /// <include file='doc\MemberFilter.uex' path='docs/doc[@for="MemberFilter"]/*' />
	[Serializable()] 
    public delegate bool MemberFilter(MemberInfo m, Object filterCriteria);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\invalidfiltercriteriaexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// InvalidFilterCriteriaException is thrown in FindMembers when the
//	filter criteria is not valid for the type of filter being used. 
//
// Author: darylo
// Date: March 98
//
namespace System.Reflection {

	using System;
	using System.Runtime.Serialization;
	using ApplicationException = System.ApplicationException;
    /// <include file='doc\InvalidFilterCriteriaException.uex' path='docs/doc[@for="InvalidFilterCriteriaException"]/*' />
	[Serializable()] 
    public class InvalidFilterCriteriaException  : ApplicationException {
    
        /// <include file='doc\InvalidFilterCriteriaException.uex' path='docs/doc[@for="InvalidFilterCriteriaException.InvalidFilterCriteriaException"]/*' />
        public InvalidFilterCriteriaException()
	        : base(Environment.GetResourceString("Arg_InvalidFilterCriteriaException")) {
    		SetErrorCode(__HResults.COR_E_INVALIDFILTERCRITERIA);
        }
    
        /// <include file='doc\InvalidFilterCriteriaException.uex' path='docs/doc[@for="InvalidFilterCriteriaException.InvalidFilterCriteriaException1"]/*' />
        public InvalidFilterCriteriaException(String message) : base(message) {
    		SetErrorCode(__HResults.COR_E_INVALIDFILTERCRITERIA);
        }
    	
        /// <include file='doc\InvalidFilterCriteriaException.uex' path='docs/doc[@for="InvalidFilterCriteriaException.InvalidFilterCriteriaException2"]/*' />
        public InvalidFilterCriteriaException(String message, Exception inner) : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_INVALIDFILTERCRITERIA);
        }

        /// <include file='doc\InvalidFilterCriteriaException.uex' path='docs/doc[@for="InvalidFilterCriteriaException.InvalidFilterCriteriaException3"]/*' />
        protected InvalidFilterCriteriaException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\interfacemapping.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// Interface Map.  This struct returns the mapping of an interface into the actual methods on a class
//	that implement that interface.
//
// Author: darylo
// Date: March 2000
//
namespace System.Reflection {
    using System;

	/// <include file='doc\InterfaceMapping.uex' path='docs/doc[@for="InterfaceMapping"]/*' />
	public struct InterfaceMapping {
		/// <include file='doc\InterfaceMapping.uex' path='docs/doc[@for="InterfaceMapping.TargetType"]/*' />
		public Type				TargetType;			// The type implementing the interface
		/// <include file='doc\InterfaceMapping.uex' path='docs/doc[@for="InterfaceMapping.InterfaceType"]/*' />
		public Type				InterfaceType;		// The type representing the interface
		/// <include file='doc\InterfaceMapping.uex' path='docs/doc[@for="InterfaceMapping.TargetMethods"]/*' />
		public MethodInfo[]		TargetMethods;		// The methods implementing the interface
		/// <include file='doc\InterfaceMapping.uex' path='docs/doc[@for="InterfaceMapping.InterfaceMethods"]/*' />
		public MethodInfo[]		InterfaceMethods;	// The methods defined on the interface
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\ireflect.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// IReflect is an interface that defines a subset of the Type reflection methods.
//	This interface is used to access and invoke members of a Type.  It can be either
//	type based (like Type) or instance based (like Expando). This interface is used in 
//	combination with IExpando to model the IDispatchEx expando capibilities in
//	the interop layer. 
//
// Author: darylo
// Date: Sep 98
//
namespace System.Reflection {
    using System;
	using System.Runtime.InteropServices;
    using CultureInfo = System.Globalization.CultureInfo;
    
	// Interface does not need to be marked with the serializable attribute
    /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect"]/*' />
    [Guid("AFBF15E5-C37C-11d2-B88E-00A0C9B471B8")]
    public interface IReflect
    {
    	// Return the requested method if it is implemented by the Reflection object.  The
    	// match is based upon the name and DescriptorInfo which describes the signature
    	// of the method. 
	    /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethod"]/*' />
	    MethodInfo GetMethod(String name,BindingFlags bindingAttr,Binder binder,
    			Type[] types,ParameterModifier[] modifiers);

    	// Return the requested method if it is implemented by the Reflection object.  The
    	// match is based upon the name of the method.  If the object implementes multiple methods
    	// with the same name an AmbiguousMatchException is thrown.
	    /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethod1"]/*' />
	    MethodInfo GetMethod(String name,BindingFlags bindingAttr);

	    /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMethods"]/*' />
	    MethodInfo[] GetMethods(BindingFlags bindingAttr);
    	
    	// Return the requestion field if it is implemented by the Reflection object.  The
    	// match is based upon a name.  There cannot be more than a single field with
    	// a name.
	    /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetField"]/*' />
	    FieldInfo GetField(
	            String name,
	            BindingFlags bindingAttr);

	    /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetFields"]/*' />
	    FieldInfo[] GetFields(
	            BindingFlags bindingAttr);

    	// Return the property based upon name.  If more than one property has the given
    	// name an AmbiguousMatchException will be thrown.  Returns null if no property
    	// is found.
	    /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperty"]/*' />
	    PropertyInfo GetProperty(
	            String name,
	            BindingFlags bindingAttr);
    	
    	// Return the property based upon the name and Descriptor info describing the property
    	// indexing.  Return null if no property is found.
	    /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperty1"]/*' />
	    PropertyInfo GetProperty(
				String name,
				BindingFlags bindingAttr,
				Binder binder,	            
				Type returnType,
				Type[] types,
				ParameterModifier[] modifiers);
    	
    	// Returns an array of PropertyInfos for all the properties defined on 
    	// the Reflection object.
	    /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetProperties"]/*' />
	    PropertyInfo[] GetProperties(
	            BindingFlags bindingAttr);

    	// Return an array of members which match the passed in name.
	    /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMember"]/*' />
	    MemberInfo[] GetMember(
	            String name,
	            BindingFlags bindingAttr);

    	// Return an array of all of the members defined for this object.
	    /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.GetMembers"]/*' />
	    MemberInfo[] GetMembers(
	            BindingFlags bindingAttr);
    	
    	// Description of the Binding Process.
    	// We must invoke a method that is accessable and for which the provided
    	// parameters have the most specific match.  A method may be called if
    	// 1. The number of parameters in the method declaration equals the number of 
    	//	arguments provided to the invocation
    	// 2. The type of each argument can be converted by the binder to the
    	//	type of the type of the parameter.
    	// 
    	// The binder will find all of the matching methods.  These method are found based
    	// upon the type of binding requested (MethodInvoke, Get/Set Properties).  The set
    	// of methods is filtered by the name, number of arguments and a set of search modifiers
    	// defined in the Binder.
    	// 
    	// After the method is selected, it will be invoked.  Accessability is checked
    	// at that point.  The search may be control which set of methods are searched based
    	// upon the accessibility attribute associated with the method.
    	// 
    	// The BindToMethod method is responsible for selecting the method to be invoked.
    	// For the default binder, the most specific method will be selected.
    	// 
        // This will invoke a specific member...
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.InvokeMember"]/*' />
        Object InvokeMember(
                String name,
                BindingFlags invokeAttr,
				Binder binder,
                Object target,
                Object[] args,
                ParameterModifier[] modifiers,
                CultureInfo culture,
                String[] namedParameters);

    	// Return the underlying Type that represents the IReflect Object.  For expando object,
    	// this is the (Object) IReflectInstance.GetType().  For Type object it is this.
        /// <include file='doc\IReflect.uex' path='docs/doc[@for="IReflect.UnderlyingSystemType"]/*' />
        Type UnderlyingSystemType {
            get;
        }	
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\manifestresourceinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ManifestResourceInfo
**
** Author: Suzanne Cook
**
** Purpose: For info regarding a manifest resource's topology.
**
** Date: July 24, 2000
**
=============================================================================*/

namespace System.Reflection {
    using System;
    
    /// <include file='doc\ManifestResourceInfo.uex' path='docs/doc[@for="ManifestResourceInfo"]/*' />
    public class ManifestResourceInfo {
        private Assembly _containingAssembly;
        private String _containingFileName;
        private ResourceLocation _resourceLocation;

        internal ManifestResourceInfo(Assembly containingAssembly,
                                      String containingFileName,
                                      ResourceLocation resourceLocation)
        {
            _containingAssembly = containingAssembly;
            _containingFileName = containingFileName;
            _resourceLocation = resourceLocation;
        }

        /// <include file='doc\ManifestResourceInfo.uex' path='docs/doc[@for="ManifestResourceInfo.ReferencedAssembly"]/*' />
        public virtual Assembly ReferencedAssembly
        {
            get {
                return _containingAssembly;
            }
        }

        /// <include file='doc\ManifestResourceInfo.uex' path='docs/doc[@for="ManifestResourceInfo.FileName"]/*' />
        public virtual String FileName
        {
            get {
                return _containingFileName;
            }
        }

        /// <include file='doc\ManifestResourceInfo.uex' path='docs/doc[@for="ManifestResourceInfo.ResourceLocation"]/*' />
        public virtual ResourceLocation ResourceLocation
        {
            get {
                return _resourceLocation;
            }
        }
    }

    // The ResourceLocation is a combination of these flags, set or not.
    // Linked means not Embedded.
    /// <include file='doc\ManifestResourceInfo.uex' path='docs/doc[@for="ResourceLocation"]/*' />
    [Flags, Serializable]
    public enum ResourceLocation
    {
        /// <include file='doc\ManifestResourceInfo.uex' path='docs/doc[@for="ResourceLocation.Embedded"]/*' />
        Embedded = 0x1,
        /// <include file='doc\ManifestResourceInfo.uex' path='docs/doc[@for="ResourceLocation.ContainedInAnotherAssembly"]/*' />
        ContainedInAnotherAssembly = 0x2,
        /// <include file='doc\ManifestResourceInfo.uex' path='docs/doc[@for="ResourceLocation.ContainedInManifestFile"]/*' />
        ContainedInManifestFile = 0x4
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\icustomattributeprovider.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// ICustomAttributeProvider is an interface that is implemented by reflection
//	objects which support custom attributes.
//
// Author: darylo & Rajesh Chandrashekaran (rajeshc)
// Date: July 99
//
namespace System.Reflection {
    
    using System;

	// Interface does not need to be marked with the serializable attribute
    /// <include file='doc\ICustomAttributeProvider.uex' path='docs/doc[@for="ICustomAttributeProvider"]/*' />
    public interface ICustomAttributeProvider
    {
    	/// <include file='doc\ICustomAttributeProvider.uex' path='docs/doc[@for="ICustomAttributeProvider.GetCustomAttributes"]/*' />

    	// Return an array of custom attributes identified by Type
    	Object[] GetCustomAttributes(Type attributeType, bool inherit);

    	/// <include file='doc\ICustomAttributeProvider.uex' path='docs/doc[@for="ICustomAttributeProvider.GetCustomAttributes1"]/*' />

    	// Return an array of all of the custom attributes (named attributes are not included)
    	Object[] GetCustomAttributes(bool inherit);

		/// <include file='doc\ICustomAttributeProvider.uex' path='docs/doc[@for="ICustomAttributeProvider.IsDefined"]/*' />
    
		// Returns true if one or more instance of attributeType is defined on this member. 
		bool IsDefined (Type attributeType, bool inherit);
	
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\memberinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// MemberInfo is an abstract base class for all of the members of a reflection. 
//	Members include Methods, Properties, Events, Constructors and Fields.  This
//	class introduces basic functionality that all members provide.
//
// Author: darylo
// Date: June 98
//
namespace System.Reflection {

	using System;
	using System.Runtime.Remoting.Metadata;
	using System.Runtime.InteropServices;
    using System.Reflection.Cache;
    using System.Security;
    using System.Security.Permissions;

	/// <include file='doc\MemberInfo.uex' path='docs/doc[@for="MemberInfo"]/*' />
	[Serializable()] 
	[ClassInterface(ClassInterfaceType.AutoDual)]
    [PermissionSetAttribute( SecurityAction.InheritanceDemand, Name="FullTrust" )]
	public abstract class MemberInfo : ICustomAttributeProvider
	{
		// Only subclass can create this.
		/// <include file='doc\MemberInfo.uex' path='docs/doc[@for="MemberInfo.MemberInfo"]/*' />
		protected MemberInfo() {}

        // The size of CachedData is accounted for by BaseObjectWithCachedData in object.h.
        // This member is currently being used by Remoting for caching remoting data. If you
        // need to cache data here, talk to the Remoting team to work out a mechanism, so that
        // both caching systems can happily work together (calebd).
        private InternalCache m_cachedData;

        internal InternalCache Cache {
            get {
                // This grabs an internal copy of m_cachedData and uses
                // that instead of looking at m_cachedData directly because
                // the cache may get cleared asynchronously.  This prevents
                // us from having to take a lock.
                InternalCache cache = m_cachedData;
                if (cache == null) {
                    cache = new InternalCache("MemberInfo");
                    m_cachedData = cache;
                    GC.ClearCache+=new ClearCacheHandler(OnCacheClear);
                }
                return cache;
            } 
        }
        
        internal void OnCacheClear(Object sender, ClearCacheEventArgs cacheEventArgs) {
            m_cachedData = null;
        }

		// Property the Member Type of the specific memeber.  This
		// is useful for switch statements.
		/// <include file='doc\MemberInfo.uex' path='docs/doc[@for="MemberInfo.MemberType"]/*' />
		public abstract MemberTypes MemberType {
    		get;
		}
    
		// Property representing the name of the Member.
		/// <include file='doc\MemberInfo.uex' path='docs/doc[@for="MemberInfo.Name"]/*' />
		public abstract String Name {
    		get;
		}
    
		// Property representing the class that declared the member.  This may be different
		// from the reflection class because a sub-class inherits methods from its base class.
		// These inheritted methods will have a declared class of the last base class to
		// declare the member.
		/// <include file='doc\MemberInfo.uex' path='docs/doc[@for="MemberInfo.DeclaringType"]/*' />
		public abstract Type DeclaringType {
    		get;
		}
    
		// Property representing the class that was used in reflection to obtain
		// this Member.
		/// <include file='doc\MemberInfo.uex' path='docs/doc[@for="MemberInfo.ReflectedType"]/*' />
		public abstract Type ReflectedType {
    		get;
		}

		// ICustomAttributeProvider...
		// Return an array of all of the custom attributes
		/// <include file='doc\MemberInfo.uex' path='docs/doc[@for="MemberInfo.GetCustomAttributes"]/*' />
		public abstract Object[] GetCustomAttributes(bool inherit);

		// Return an array of custom attributes identified by Type
		/// <include file='doc\MemberInfo.uex' path='docs/doc[@for="MemberInfo.GetCustomAttributes1"]/*' />
		public abstract Object[] GetCustomAttributes(Type attributeType, bool inherit);

		// Returns true if one or more instance of attributeType is defined on this member. 
		/// <include file='doc\MemberInfo.uex' path='docs/doc[@for="MemberInfo.IsDefined"]/*' />
		public abstract bool IsDefined (Type attributeType, bool inherit);

    	// Return the class that was reflected on to obtain this member.  Providing
		// a bogus implementation since internal members can't be abstract.
    	internal virtual Type InternalReflectedClass(bool returnGlobalClass)
		{
			return null;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\memberinfoserializationholder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// MemberInfoSerializationHolder provides a reference to a MemberInfo during serialization.
// For the Runtime*Infos, we currently guarantee that only one instance
// exists in the runtime for any particular member.  This means that we
// can't simply create an instance and fill in it's data, so we send the
// data (name, class, etc) needed to get an instance of it through 
// reflection.
//
// Author: jroxe
// Date: Oct 99
//
namespace System.Reflection {
    
    using System;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization;
    //This is deliberately not serializable -- this class is only designed to hold references to other members during
    //serialization and should not itself be serializable.
    internal class MemberInfoSerializationHolder : ISerializable, IObjectReference {
        private String m_memberName;
        private Type   m_reflectedType;
        private String m_signature;
        private MemberTypes m_memberType;
    
        public static void GetSerializationInfo (SerializationInfo info, String name, Type reflectedClass, String signature, MemberTypes type) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }

            String assemblyName = reflectedClass.Module.Assembly.FullName;
            String typeName = reflectedClass.FullName;

            info.SetType(typeof(MemberInfoSerializationHolder));
            info.AddValue("Name", name, typeof(String));
            info.AddValue("AssemblyName", assemblyName, typeof(String));
            info.AddValue("ClassName", typeName, typeof(String));
            info.AddValue("Signature", signature, typeof(String));
            info.AddValue("MemberType",(int)type);
        }
    
        internal MemberInfoSerializationHolder(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }

            String assemblyName = info.GetString("AssemblyName");
            String typeName     = info.GetString("ClassName");
            
            if (assemblyName==null || typeName==null) {
                throw new SerializationException(Environment.GetResourceString("Serialization_InsufficientState"));
            }

            Assembly assem = FormatterServices.LoadAssemblyFromString(assemblyName);
            m_reflectedType = assem.GetTypeInternal(typeName, true, false, false);
            m_memberName =     info.GetString("Name");
            m_signature =      info.GetString("Signature");
            m_memberType =     (MemberTypes)info.GetInt32("MemberType");
        }

        public virtual void GetObjectData(SerializationInfo info, StreamingContext context) {
            //@ToDo: JLR Fix This
            throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_Method));
        }
    
        // We now know that the member name, class and type have been completed.  With this information, we can
        // use reflection to get the member info that was serialized.
        //
        public virtual Object GetRealObject(StreamingContext context) {
            //We have no use for the context, so we'll just ignore it.
            if (m_memberName==null || m_reflectedType==null || m_memberType==0) {
                throw new SerializationException(Environment.GetResourceString(ResId.Serialization_InsufficientState));
            }
    
            // We can shortcur lookups (skip access checks) for RuntimeType.
            RuntimeType rType = m_reflectedType as RuntimeType;

            switch (m_memberType) {
            case MemberTypes.Field:
                if (rType != null) {
                    FieldInfo[] foundFields;
                    foundFields = rType.GetMemberField(m_memberName,
                                                       BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static,
                                                       false);
                    if (foundFields.Length == 1)
                        return foundFields[0];
                    if (foundFields.Length > 1)
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_MultipleMembersEx"), m_memberName));
                } else {
                    FieldInfo foundField = m_reflectedType.GetField(m_memberName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
                    if (foundField != null)
                        return foundField;
                }
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_UnknownMember"), m_memberName));

            case MemberTypes.Property:
                if (rType != null) {
                    PropertyInfo[] foundProperties;
                    foundProperties = rType.GetMatchingProperties(m_memberName,
                                                                  BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.OptionalParamBinding,
                                                                  0,
                                                                  null,
                                                                  false);
                    if (foundProperties.Length == 1)
                        return foundProperties[0];
                    if (foundProperties.Length > 1)
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_MultipleMembersEx"), m_memberName));
                } else {
                    PropertyInfo foundProperty = m_reflectedType.GetProperty(m_memberName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
                    if (foundProperty != null)
                        return foundProperty;
                }
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_UnknownMember"), m_memberName));

            case MemberTypes.Constructor:
                if (m_signature==null)
                    throw new SerializationException(Environment.GetResourceString(ResId.Serialization_NullSignature));

                ConstructorInfo[] foundCtors;
                bool isDelegate;

                if (rType != null)
                    foundCtors = rType.GetMemberCons(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.OptionalParamBinding, CallingConventions.Any, null, -1, false, out isDelegate);
                else
                    foundCtors = m_reflectedType.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
                //If we only found 1, this for loop will exit immediately.
                for (int i=0; i<foundCtors.Length; i++) {
                    if (foundCtors[i].ToString().Equals(m_signature)) {
                        return foundCtors[i];
                    }
                }
                throw new SerializationException(String.Format(Environment.GetResourceString(ResId.Serialization_UnknownMember), m_memberName));            
            case MemberTypes.Method:
                if (m_signature==null)
                    throw new SerializationException(Environment.GetResourceString(ResId.Serialization_NullSignature));

                MethodInfo[] foundMethods;

                if (rType != null)
                    foundMethods = rType.GetMemberMethod(m_memberName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.OptionalParamBinding | BindingFlags.InvokeMethod, CallingConventions.Any, null, -1, false);
                else
                    foundMethods = m_reflectedType.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
                //If we only found 1, this for loop will exit immediately.
                for (int i=0; i<foundMethods.Length; i++) {
                    if ((foundMethods[i]).ToString().Equals(m_signature)) {
                        return foundMethods[i];
                    }
                }
                throw new SerializationException(String.Format(Environment.GetResourceString(ResId.Serialization_UnknownMember), m_memberName));            
            default:
                throw new ArgumentException(Environment.GetResourceString("Serialization_MemberTypeNotRecognized"));
            }
    
        }
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\methodsemanticsattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// This enum defines the Semantics that can be associated with Methods.  These
//	semantics are set for methods that have special meaning as part of a property
//	or event. 
//
// Author: meichint
// Date: June 99
//
namespace System.Reflection {
    
	using System;
	[Flags, Serializable()] 
    enum MethodSemanticsAttributes {
        Setter			    =   0x0001,	// 
        Getter			    =   0x0002,	// 
        Other				=   0x0004,	// 
        AddOn		        =   0x0008,	// 
        RemoveOn			=   0x0010,	// 
        Fire		        =   0x0020,	// 
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\missing.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// Missing
//	This class represents a Missing Variant
////////////////////////////////////////////////////////////////////////////////
namespace System.Reflection {
    
	using System;
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
	// This is not serializable because it is a reflection command.
    /// <include file='doc\Missing.uex' path='docs/doc[@for="Missing"]/*' />
    public sealed class Missing {
    
        //Package Private Constructor
        internal Missing(){
        }
    
    	/// <include file='doc\Missing.uex' path='docs/doc[@for="Missing.Value"]/*' />
    	public static readonly Missing Value = new Missing();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\membertypes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// MemberTypes is an bit mask marking each type of Member that is defined as
//	a subclass of MemberInfo.  These are returned by MemberInfo.MemberType and 
//	are useful in switch statements.
//
// Author: darylo
// Date: July 99
//
namespace System.Reflection {
    
	using System;
    // This Enum matchs the CorTypeAttr defined in CorHdr.h
    /// <include file='doc\MemberTypes.uex' path='docs/doc[@for="MemberTypes"]/*' />
	[Flags, Serializable()] 
    public enum MemberTypes
    {
    	// The following are the known classes which extend MemberInfo
    	/// <include file='doc\MemberTypes.uex' path='docs/doc[@for="MemberTypes.Constructor"]/*' />
    	Constructor		= 0x01,
    	/// <include file='doc\MemberTypes.uex' path='docs/doc[@for="MemberTypes.Event"]/*' />
    	Event			= 0x02,
    	/// <include file='doc\MemberTypes.uex' path='docs/doc[@for="MemberTypes.Field"]/*' />
    	Field			= 0x04,
    	/// <include file='doc\MemberTypes.uex' path='docs/doc[@for="MemberTypes.Method"]/*' />
    	Method			= 0x08,
    	/// <include file='doc\MemberTypes.uex' path='docs/doc[@for="MemberTypes.Property"]/*' />
    	Property		= 0x10,
    	/// <include file='doc\MemberTypes.uex' path='docs/doc[@for="MemberTypes.TypeInfo"]/*' />
    	TypeInfo		= 0x20,
    	/// <include file='doc\MemberTypes.uex' path='docs/doc[@for="MemberTypes.Custom"]/*' />
    	Custom			= 0x40,
    	/// <include file='doc\MemberTypes.uex' path='docs/doc[@for="MemberTypes.NestedType"]/*' />
    	NestedType		= 0x80,
    	/// <include file='doc\MemberTypes.uex' path='docs/doc[@for="MemberTypes.All"]/*' />
    	All				= Constructor | Event | Field | Method | Property | TypeInfo | NestedType,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\methodinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// MethodInfo is an abstract base class representing a Method.  Methods may be defined
//	either on a type or as a global.  The system provides a __RuntimeMethodInfo representing
//	the real methods of the system.
//
// Author: darylo
// Date: March 98
//
namespace System.Reflection {
	using System;
	using System.Runtime.InteropServices;
	using CultureInfo = System.Globalization.CultureInfo;

    ////////////////////////////////////////////////////////////////////////////////
    //   Method is the class which represents a Method. These are accessed from
    //   Class through getMethods() or getMethod(). This class contains information
    //   about each method and also allows the method to be dynamically invoked 
    //   on an instance.
    ////////////////////////////////////////////////////////////////////////////////
    /// <include file='doc\MethodInfo.uex' path='docs/doc[@for="MethodInfo"]/*' />
	[Serializable()] 
    [ClassInterface(ClassInterfaceType.AutoDual)]
    abstract public class MethodInfo : MethodBase
    {
    	/// <include file='doc\MethodInfo.uex' path='docs/doc[@for="MethodInfo.MethodInfo"]/*' />
    	protected MethodInfo() {}
    
    	/////////////// MemberInfo Routines /////////////////////////////////////////////
    	
    	// The Member type Method.
    	/// <include file='doc\MethodInfo.uex' path='docs/doc[@for="MethodInfo.MemberType"]/*' />
    	public override MemberTypes MemberType {
    		get {return System.Reflection.MemberTypes.Method;}
    	}
    		
    	// Return type Type of the methods return type
    	/// <include file='doc\MethodInfo.uex' path='docs/doc[@for="MethodInfo.ReturnType"]/*' />
    	public abstract Type ReturnType {
    		get; 
    	}

		// This method will return an object that represents the 
		//	custom attributes for the return type.
		/// <include file='doc\MethodInfo.uex' path='docs/doc[@for="MethodInfo.ReturnTypeCustomAttributes"]/*' />
		public abstract ICustomAttributeProvider ReturnTypeCustomAttributes {
    		get; 
		}
    						  
    	// Return the base implementation for a method.
    	/// <include file='doc\MethodInfo.uex' path='docs/doc[@for="MethodInfo.GetBaseDefinition"]/*' />
    	abstract public MethodInfo GetBaseDefinition();

    	// Return the parents definition for a method in an inheritance chain.
    	internal virtual MethodInfo GetParentDefinition()
		{
			return null;
		}
		    	
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\methodimplattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// MethodImplAttributes is a Enum defining the flags that are the methodimpl
//	flags defined on a method.  These are all defined in CorHdr.h and are a combintation
//	of bit flags and enumerations.
//
// Author: darylo
// Date: Aug 99
//
namespace System.Reflection {
    
	using System;
    // This Enum matchs the CorMethodImpl defined in CorHdr.h
    /// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes"]/*' />
	[Flags, Serializable()] 
    public enum MethodImplAttributes
    {
    	// code impl mask
    	/// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.CodeTypeMask"]/*' />
    	CodeTypeMask		=	0x0003,   // Flags about code type.   
       	/// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.IL"]/*' />
       	IL					=	0x0000,   // Method impl is IL.
       	/// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.Native"]/*' />
       	Native				=	0x0001,   // Method impl is native.     
       	/// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.OPTIL"]/*' />
        /// <internalonly/>
       	OPTIL				=	0x0002,   // Method impl is OPTIL 
        /// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.Runtime"]/*' />
        Runtime				=	0x0003,   // Method impl is provided by the runtime.
    	// end code impl mask
    
        // managed mask
    	/// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.ManagedMask"]/*' />
    	ManagedMask       =   0x0004,   // Flags specifying whether the code is managed or unmanaged.
    	/// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.Unmanaged"]/*' />
    	Unmanaged         =   0x0004,   // Method impl is unmanaged, otherwise managed.
        /// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.Managed"]/*' />
        Managed           =   0x0000,   // Method impl is managed.
        // end managed mask
    
    	// implementation info and interop
    	/// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.ForwardRef"]/*' />
    	ForwardRef			=	0x0010,	  // Indicates method is not defined; used primarily in merge scenarios.
    	/// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.PreserveSig"]/*' />
    	PreserveSig			=	0x0080,	  // Indicates method sig is exported exactly as declared.

		/// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.InternalCall"]/*' />
		InternalCall		=   0x1000,	  // Internal Call...
    
        /// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.Synchronized"]/*' />
        Synchronized      =   0x0020,   // Method is single threaded through the body.
        /// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.NoInlining"]/*' />
        NoInlining        =   0x0008,   // Method may not be inlined.

		/// <include file='doc\MethodImplAttributes.uex' path='docs/doc[@for="MethodImplAttributes.MaxMethodImplVal"]/*' />
		MaxMethodImplVal	= 0xFFFF,	// Range check value
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\methodbase.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// MethodBase is an abstract base class for all Methods and Constructors.  
//	Method and Constructors are logically the same so this class introduces 
//	the functionality that is common between them.
//
// Author: darylo
// Date: March 98
//
namespace System.Reflection {
	using System.Runtime.InteropServices;
	using CultureInfo = System.Globalization.CultureInfo;
    using DebuggerStepThroughAttribute = System.Diagnostics.DebuggerStepThroughAttribute;
    using System.Security;
    using System.Threading;

    ////////////////////////////////////////////////////////////////////////////////
    //   Method is the class which represents a Method. These are accessed from
    //   Class through getMethods() or getMethod(). This class contains information
    //   about each method and also allows the method to be dynamically invoked 
    //   on an instance.
    ////////////////////////////////////////////////////////////////////////////////
	using System;
    /// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase"]/*' />
	[Serializable()] 
    [ClassInterface(ClassInterfaceType.AutoDual)]
    public abstract class MethodBase : MemberInfo
    {
		// Only created by the system
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.MethodBase"]/*' />
    	protected MethodBase() {}
    		
/*    	
        // GetDescriptor
    	// This method returns a DescriptorInfo which matchs exactly
    	//	the signature of this method or constructor
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.GetDescriptor"]/*' />
    	public virtual DescriptorInfo GetDescriptor()
    	{
    		ParameterInfo[] p = GetParameters();
    		DescriptorInfo d = new DescriptorInfo(p.Length);
    		for (int i=0;i<p.Length;i++) {
    			d.SetArgument(i,p[i].ParameterType);
    		}
    		if (this.MemberType == System.Reflection.MemberTypes.Method) {
    			MethodInfo m = (MethodInfo) this;
    			d.SetReturnType(m.ReturnType);
    		}
    		return d;
    	}
*/

    	// GetParameters
    	// This method returns an array of parameters for this method
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.GetParameters"]/*' />
    	abstract public ParameterInfo[] GetParameters();
    
    	// Return the MethodImpl flags.
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.GetMethodImplementationFlags"]/*' />
    	abstract public MethodImplAttributes GetMethodImplementationFlags();

		// Method Handle routines
		/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.MethodHandle"]/*' />
		public abstract RuntimeMethodHandle MethodHandle {
			get;
		}

		/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.GetMethodFromHandle"]/*' />
		public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle)
		{
			return RuntimeMethodInfo.GetMethodFromHandleImp(handle);
		}

    
    	////////////////////////////////////////////////////////////////////////////////
    	//   Attributes
    	////////////////////////////////////////////////////////////////////////////////
    	// Property representing the Attributes associated with a Member.  All 
    	// members have a set of attributes which are defined in relation to 
    	// the specific type of member.
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.Attributes"]/*' />
    	public abstract MethodAttributes Attributes {
    		get;
    	}
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.IsPublic"]/*' />
    	public bool IsPublic {
    		get {return ((Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Public);}
    	}
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.IsPrivate"]/*' />
    	public bool IsPrivate {
    		get {return ((Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Private);}
    	}
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.IsFamily"]/*' />
    	public bool IsFamily {
    		get {return ((Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Family);}
    	}
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.IsAssembly"]/*' />
    	public bool IsAssembly {
    		get {return ((Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Assembly);}
    	}
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.IsFamilyAndAssembly"]/*' />
    	public bool IsFamilyAndAssembly {
    		get {return ((Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.FamANDAssem);}
    	}
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.IsFamilyOrAssembly"]/*' />
    	public bool IsFamilyOrAssembly {
    		get {return ((Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.FamORAssem);}
    	}
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.IsStatic"]/*' />
    	public bool IsStatic {
    		get {return ((Attributes & MethodAttributes.Static) != 0);}
    	}
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.IsFinal"]/*' />
    	public bool IsFinal {
    		get {return ((Attributes & MethodAttributes.Final) != 0);}
    	}
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.IsVirtual"]/*' />
    	public bool IsVirtual {
    		get {return ((Attributes & MethodAttributes.Virtual) != 0);}
    	}	
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.IsHideBySig"]/*' />
    	public bool IsHideBySig {
    		get {return ((Attributes & MethodAttributes.HideBySig) != 0);}
    	}	
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.IsAbstract"]/*' />
    	public bool IsAbstract {
    		get {return ((Attributes & MethodAttributes.Abstract) != 0);}
    	}
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.IsSpecialName"]/*' />
    	public bool IsSpecialName {
    		get {return ((Attributes & MethodAttributes.SpecialName) != 0);}
    	}
    	
    	// These methods are not stricly defined based upon the 
    	//	attributes associated with a method.
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.IsConstructor"]/*' />
    	public bool IsConstructor {
    		get {return ( ((Attributes & MethodAttributes.RTSpecialName) != 0) && 
    					  Name.Equals(ConstructorInfo.ConstructorName));}
    	}
    
    	// the calling convention
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.CallingConvention"]/*' />
    	public virtual CallingConventions CallingConvention {
    		get {return CallingConventions.Standard;}
    	}
    	
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.GetCurrentMethod"]/*' />
        // Specify DynamicSecurityMethod attribute to prevent inlining of the caller.
        [DynamicSecurityMethod]
    	public static MethodBase GetCurrentMethod()
    	{
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return RuntimeMethodInfo.InternalGetCurrentMethod(ref stackMark);
    	}

    	////////////////////////////////////////////////////////////////////////////////
    	//  This method will attempt to invoke the method on the object.  The object
    	//	must be the same type as the the declaring class of the method.  The parameters
    	//	must match the method signature.
    	////
    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.Invoke"]/*' />
		[DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
    	public Object Invoke(Object obj, Object[] parameters)
    	{
    		return Invoke(obj,BindingFlags.Default,null,parameters,null);
    	}

    	/// <include file='doc\MethodBase.uex' path='docs/doc[@for="MethodBase.Invoke1"]/*' />
    	abstract public Object Invoke(Object obj,BindingFlags invokeAttr,Binder binder, 
									  Object[] parameters, CultureInfo culture);

        virtual internal bool IsOverloaded
        {
            get {
                throw new NotSupportedException(Environment.GetResourceString("InvalidOperation_Method"));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\methodattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// MethodAttributes define the attributes of that can be associated with
//  a method.  These are all defined in CorHdr.h.  This set of attributes
//  is a combination of Enumeration and bit flags.  
//
// Author: darylo
// Date: March 99
//
namespace System.Reflection {
    
	using System;
    /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes"]/*' />
    [Flags, Serializable()] 
    public enum MethodAttributes
    {
        // NOTE: This Enum matchs the CorMethodAttr defined in CorHdr.h

        // member access mask - Use this mask to retrieve accessibility information.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.MemberAccessMask"]/*' />
        MemberAccessMask    =   0x0007,
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.PrivateScope"]/*' />
        PrivateScope        =   0x0000,     // Member not referenceable.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.Private"]/*' />
        Private             =   0x0001,     // Accessible only by the parent type.  
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.FamANDAssem"]/*' />
        FamANDAssem         =   0x0002,     // Accessible by sub-types only in this Assembly.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.Assembly"]/*' />
        Assembly            =   0x0003,     // Accessibly by anyone in the Assembly.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.Family"]/*' />
        Family              =   0x0004,     // Accessible only by type and sub-types.    
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.FamORAssem"]/*' />
        FamORAssem          =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.Public"]/*' />
        Public              =   0x0006,     // Accessibly by anyone who has visibility to this scope.    
        // end member access mask
    
        // method contract attributes.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.Static"]/*' />
        Static              =   0x0010,     // Defined on type, else per instance.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.Final"]/*' />
        Final               =   0x0020,     // Method may not be overridden.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.Virtual"]/*' />
        Virtual             =   0x0040,     // Method virtual.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.HideBySig"]/*' />
        HideBySig           =   0x0080,     // Method hides by name+sig, else just by name.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.CheckAccessOnOverride"]/*' />
        CheckAccessOnOverride=  0x0200,
        
        // vtable layout mask - Use this mask to retrieve vtable attributes.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.VtableLayoutMask"]/*' />
        VtableLayoutMask    =   0x0100,
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.ReuseSlot"]/*' />
        ReuseSlot           =   0x0000,     // The default.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.NewSlot"]/*' />
        NewSlot             =   0x0100,     // Method always gets a new slot in the vtable.
        // end vtable layout mask
    
        // method implementation attributes.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.Abstract"]/*' />
        Abstract            =   0x0400,     // Method does not provide an implementation.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.SpecialName"]/*' />
        SpecialName         =   0x0800,     // Method is special.  Name describes how.
        
        // interop attributes
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.PinvokeImpl"]/*' />
        PinvokeImpl         =   0x2000,     // Implementation is forwarded through pinvoke.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.UnmanagedExport"]/*' />
        UnmanagedExport     =   0x0008,     // Managed method exported via thunk to unmanaged code.
        /// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.RTSpecialName"]/*' />
        RTSpecialName       =   0x1000,     // Runtime should check name encoding.

		// Reserved flags for runtime use only.
		/// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.ReservedMask"]/*' />
		ReservedMask              =   0xd000,
		/// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.HasSecurity"]/*' />
		HasSecurity               =   0x4000,     // Method has security associate with it.
		/// <include file='doc\MethodAttributes.uex' path='docs/doc[@for="MethodAttributes.RequireSecObject"]/*' />
		RequireSecObject          =   0x8000,     // Method calls another method containing security code.

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\pointer.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
//
// This is a wrapper class for Pointers
//
// Author: darylo
// Date: March 200
//
namespace System.Reflection {
    using System;
    using CultureInfo = System.Globalization.CultureInfo;
    using System.Runtime.Serialization;

	/// <include file='doc\Pointer.uex' path='docs/doc[@for="Pointer"]/*' />
    [CLSCompliant(false)]
	public sealed class Pointer : ISerializable {
		unsafe private void* _ptr;
		private Type _ptrType;

		private Pointer() {}

		// This method will box an pointer.  We save both the
		//	value and the type so we can access it from the native code
		//	during an Invoke.
		/// <include file='doc\Pointer.uex' path='docs/doc[@for="Pointer.Box"]/*' />
		public static unsafe Object Box(void *ptr,Type type) {
			if (type == null)
				throw new ArgumentNullException("type");
			if (!type.IsPointer)
				throw new ArgumentException(Environment.GetResourceString("Arg_MustBePointer"),"ptr");

			Pointer x = new Pointer();
			x._ptr = ptr;
			x._ptrType = type;
			return x;
		}

		// Returned the stored pointer.
		/// <include file='doc\Pointer.uex' path='docs/doc[@for="Pointer.Unbox"]/*' />
		public static unsafe void* Unbox(Object ptr) {
			if (!(ptr is Pointer))
				throw new ArgumentException(Environment.GetResourceString("Arg_MustBePointer"),"ptr");
			return ((Pointer)ptr)._ptr;
		}

        //This is a temporary fix until we turn on the serialization bit.
        /// <include file='doc\Pointer.uex' path='docs/doc[@for="Pointer.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_PointerSerialization"));
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\parametermodifier.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// ParameterModifier is a struct that is used to attach modifier to parameters
//	so that binding can work against signatures where the types have been modified.
//	Modifications include, ByRef, etc.
//
// Author: darylo
// Date: Aug 99
//
namespace System.Reflection {
    
	using System;
    /// <include file='doc\ParameterModifier.uex' path='docs/doc[@for="ParameterModifier"]/*' />
    [Serializable]
    public struct ParameterModifier {
		internal bool[] _byRef;
		/// <include file='doc\ParameterModifier.uex' path='docs/doc[@for="ParameterModifier.ParameterModifier"]/*' />
		public ParameterModifier(int parameterCount) {
			if (parameterCount <= 0)
				throw new ArgumentException(Environment.GetResourceString("Arg_ParmArraySize"));

			_byRef = new bool[parameterCount];
		}

        /// <include file='doc\ParameterModifier.uex' path='docs/doc[@for="ParameterModifier.this"]/*' />
        public bool this[int index] {
            get {return _byRef[index]; }
            set {_byRef[index] = value;}
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\propertyattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// PropertyAttributes is an enum which defines the attributes that may be associated
//	with a property.  The values here are defined in Corhdr.h.
//
// Author: darylo
// Date: Aug 99
//
namespace System.Reflection {
    
	using System;
	// This Enum matchs the CorPropertyAttr defined in CorHdr.h
	/// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes"]/*' />
	[Serializable, Flags]  
	public enum PropertyAttributes
    {
    	/// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes.None"]/*' />
    	None			=   0x0000,
        /// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes.SpecialName"]/*' />
        SpecialName     =   0x0200,     // property is special.  Name describes how.

		// Reserved flags for Runtime use only.
		/// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes.ReservedMask"]/*' />
		ReservedMask          =   0xf400,
		/// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes.RTSpecialName"]/*' />
		RTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
		/// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes.HasDefault"]/*' />
		HasDefault            =   0x1000,     // Property has default 
		/// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes.Reserved2"]/*' />
		Reserved2             =   0x2000,     // reserved bit
		/// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes.Reserved3"]/*' />
		Reserved3             =   0x4000,     // reserved bit 
		/// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes.Reserved4"]/*' />
		Reserved4             =   0x8000      // reserved bit 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\module.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// The Module class represents a module in the COM+ runtime.  A module
//  may consist of one or more classes and interfaces and represents a physical
//  deployment such as a DLL or EXE of those classes. There may be multple namespaces
//  contained in a single module and a namespace may be span multiple modules.
// 
// The runtime supports a special type of module that are dynamically created.  New
//  classes can be created through the dynamic IL generation process.
//
// Author: darylo
// Date: April 98
//
namespace System.Reflection {
    using System;
    using System.Diagnostics.SymbolStore;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Reflection.Emit;
    using System.Collections;
    using System.Threading;
    using System.Runtime.CompilerServices;
    using System.Security.Permissions;
    using System.IO;

    /// <include file='doc\Module.uex' path='docs/doc[@for="Module"]/*' />
    [Serializable()]
    public class Module : ISerializable, ICustomAttributeProvider 
    {   

        private const BindingFlags DefaultLookup = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public;

        // Warning!! Warning!! begin of data variable declaration.
        // Module is allocated in unmanaged side. So if you add any data members, you need to update the
        // native declaration ReflectModuleBaseObject.
        //
        internal ArrayList          m_TypeBuilderList;
        internal ISymbolWriter      m_iSymWriter;
        internal ModuleBuilderData  m_moduleData;
    
        private IntPtr              m_pRefClass;
        private IntPtr              m_pData;
        internal IntPtr             m_pInternalSymWriter;
        private IntPtr              m_pGlobals;
        private IntPtr              m_pFields;
        internal MethodToken        m_EntryPoint;
        // Warning!! Warning!! End of data variable declaration.
    
        // Construct a new module.  This returns the default dynamic module.
        // 0 is defined as being a module without an entry point (ie a DLL);
        internal Module() {
            // This must throw because this dies in ToString() when constructed here...
            throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_Constructor));
            //m_EntryPoint=new MethodToken(0);
        }
    
        // Filters the list of Types defined
        // in this Module based upon the Name.  This is case sensitive and
        // supports a trailing "*" wildcard.
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.FilterTypeName"]/*' />
        public static readonly TypeFilter FilterTypeName;
        
        // Filters the list of Classes defined
        // in this Module based upon the Name.  This is case insensitive and
        // supports a trailing "*" wildcard.
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.FilterTypeNameIgnoreCase"]/*' />
        public static readonly TypeFilter FilterTypeNameIgnoreCase;
        
        
        // The _Filter class contains the predefined filters
        static Module() {
            __Filters _fltObj;
            _fltObj = new __Filters();
            FilterTypeName = new TypeFilter(_fltObj.FilterTypeName);
            FilterTypeNameIgnoreCase = new TypeFilter(_fltObj.FilterTypeNameIgnoreCase);
        }
        
        
        // Returns the HInstance for this module.  Returns -1 if the module doesn't
        // have an HInstance.  In Memory (Dynamic) Modules won't have an HInstance.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern IntPtr GetHINSTANCE();
    
        // Returns a Type defined in defined within the Module.  The name of the
        // class must be fully qualified with the namespace. If the
        // class isn't found, null is returned.
        // 
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetType"]/*' />
        public virtual Type GetType(String className, bool ignoreCase)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return GetTypeInternal(className, ignoreCase, false, ref stackMark);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern Type GetTypeInternal(String className, bool ignoreCase, bool throwOnError, ref StackCrawlMark stackMark);

        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetType1"]/*' />
        public virtual Type GetType(String className) {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return GetTypeInternal(className, false, false, ref stackMark);
        }
        
        // Returns a Type defined in defined within the Module.  The name of the
        // class must be fully qualified with the namespace. If the
        // class isn't found, return null if throwOnError is false, otherwise throw an exception.
        // 
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetType2"]/*' />
        public virtual Type GetType(String className, bool throwOnError, bool ignoreCase) {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return GetTypeInternal(className, ignoreCase, throwOnError, ref stackMark);
        }

        // Returns a String representing the Name of the Module.
        // 
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.ScopeName"]/*' />
        public String ScopeName {
            get {return InternalGetName();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InternalGetName();
    
        // Returns the fully qualified name and path to this Module.
        //
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.FullyQualifiedName"]/*' />
        public virtual String FullyQualifiedName {
            get
            {
                String fullyQualifiedName = InteralGetFullyQualifiedName();
                
                if (fullyQualifiedName != null) {
                    bool checkPermission = true;
                    try {
                        Path.GetFullPathInternal(fullyQualifiedName);
                    }
                    catch(ArgumentException) {
                        checkPermission = false;
                    }
                    if (checkPermission) {
                        new FileIOPermission( FileIOPermissionAccess.PathDiscovery, fullyQualifiedName ).Demand();
                    }
                }

                return fullyQualifiedName;
            }
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InteralGetFullyQualifiedName();

        // Returns the name of the module with the path removed.
        //
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.Name"]/*' />
        public String Name {
            get {
                String s = FullyQualifiedName;
                int i = s.LastIndexOf('\\');
                if (i == -1)
                    return s;
                return new String(s.ToCharArray(),i+1,s.Length-i-1);
            }
        }
    
        // Returns an array of classes which have been excepted by the filter.  A user provided 
        // Filter filter will be called with each class defined in the module.  The
        // filterCriteria is also passed to the filter.  If the filter returns true
        // the class will be included in the output array.  
        // 
        // If filter is null, then the all classes are returned and the filterCriteria will
        // be ignored. 
        // 
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.FindTypes"]/*' />
        public virtual Type[] FindTypes(TypeFilter filter,Object filterCriteria)
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            Type[] c = GetTypesInternal(ref stackMark);
            int cnt = 0;
            for (int i = 0;i<c.Length;i++) {
                if (filter!=null && !filter(c[i],filterCriteria))
                    c[i] = null;
                else
                    cnt++;
            }
            if (cnt == c.Length)
                return c;
            
            Type[] ret = new Type[cnt];
            cnt=0;
            for (int i=0;i<c.Length;i++) {
                if (c[i] != null)
                    ret[cnt++] = c[i];
            }
            return ret;
        }
    
        
        // Returns an array of classes defined within the Module.
        // 
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetTypes"]/*' />
        public virtual Type[] GetTypes()
        {
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return GetTypesInternal(ref stackMark);
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern Type[] GetTypesInternal(ref StackCrawlMark stackMark);
        
        // Returns the name of the module as a String.
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.ToString"]/*' />
        public override String ToString()
        {
            return ScopeName;
        }
    
        // GetSignerCertificate
        //
        // This method will return an X509Certificate object corresponding to
        // the signer certficiate for the module.  If the module isn't signed,
        // null is returned.
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetSignerCertificate"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate();
            
        // Returns the appropriate Assembly for this instance of Module

        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.Assembly"]/*' />
        public Assembly Assembly {
            get {return nGetAssembly();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Assembly nGetAssembly();
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern static int NativeGetIMetaDataEmit(ModuleBuilder modBuilder);        
        
        // This is now a package helper
        internal virtual bool IsDynamic()
        { 
            if (this is ModuleBuilder)
                return true;
            else 
                return false; 
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int InternalGetTypeToken(String strFullName, Module refedModule, String strRefedModuleFileName, int tkResolution);
    
        // force in memory type to be loaded                                     
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern Type InternalLoadInMemoryTypeByName(String className);
                                                                
        // return MemberRef token given a def token in refedModule.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int InternalGetMemberRef(Module refedModule, int tr, int defToken);
    
        // return MemberRef token given a MethodBase or FieldInfo. This is for generating
        // MemberRef tokens defined in static library.
       
        // getting a MemberRef token given a signature
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int InternalGetMemberRefFromSignature(int tr, String methodName, byte[] signature, int length);

        // getting a MemberRef token given a MethodInfo
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int InternalGetMemberRefOfMethodInfo(int tr, MethodBase method);

        // getting a MemberRef token given a FieldInfo
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int InternalGetMemberRefOfFieldInfo(int tr, RuntimeFieldInfo con);

        // getting a TypeSpec token given an array class and the type token for the array base class
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int InternalGetTypeSpecToken(RuntimeType arrayClass, int baseToken);

        // getting a TypeSpec token given a signature
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int InternalGetTypeSpecTokenWithBytes(byte[] signature, int length);
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern MethodToken nativeGetArrayMethodToken(int tkTypeSpec, String methodName, byte[] signature, int sigLength, int baseToken);
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void InternalSetFieldRVAContent(int fdToken, byte[] data, int length);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern int InternalGetStringConstant(String str);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void InternalPreSavePEFile();        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void InternalSavePEFile(String fileName, MethodToken entryPoint, int isExe, bool isManifestFile);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void InternalSetResourceCounts(int resCount);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void InternalAddResource(String strName, 
                                                 byte[] resBytes,
                                                 int    resByteCount,
                                                 int    tkFile,
                                                 int    attribute);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void InternalSetModuleProps(String strModuleName); 

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void InternalDefineNativeResourceFile(String strFilename); 

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void InternalDefineNativeResourceBytes(byte[] resource); 

        
        // This method will return an array of all of the global
        // methods defined on the Module.
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetMethods"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern MethodInfo[] GetMethods();
    
        // Return a method based upon the passed criteria.  The name of the method
        // must be provided, and exception is thrown if it is not.  The bindingAttr
        // parameter indicates if non-public methods should be searched.  The types
        // array indicates the types of the parameters being looked for.
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetMethod"]/*' />
        public MethodInfo GetMethod(String name,BindingFlags bindingAttr,Binder binder,
                        CallingConventions callConvention,Type[] types,ParameterModifier[] modifiers)
        {
            if (name == null)
                throw new ArgumentNullException("name");
            if (types == null)
                throw new ArgumentNullException("types");
            for (int i=0;i<types.Length;i++)
                if (types[i] == null)
                    throw new ArgumentNullException("types");
            return GetMethodImpl(name,bindingAttr,binder,callConvention,types,modifiers);
            
        }
        
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetMethod1"]/*' />
        public MethodInfo GetMethod(String name,Type[] types)
        {
            if (name == null)
                throw new ArgumentNullException("name");
            if (types == null)
                    throw new ArgumentNullException("types");
            for (int i=0;i<types.Length;i++)
                if (types[i] == null)
                    throw new ArgumentNullException("types");
            return GetMethodImpl(name,Module.DefaultLookup,null,CallingConventions.Any,
                                 types,null);
        }
        
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetMethod2"]/*' />
        public MethodInfo GetMethod(String name)
        {
            if (name == null)
                throw new ArgumentNullException("name");
            return GetMethodImpl(name,Module.DefaultLookup,null,CallingConventions.Any,
                                 null,null);
        }
            
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetMethodImpl"]/*' />
        protected virtual MethodInfo GetMethodImpl(String name,BindingFlags bindingAttr,Binder binder,
                CallingConventions callConvention, Type[] types,ParameterModifier[] modifiers)
        {
            if (binder == null)
                binder = Type.DefaultBinder;
            
            // If the types array is null that means we don't care about the arguments to the method, we will simply
            // return the one that matchs or throw an argument error...
            int argCnt = (types != null) ? types.Length : -1;
            MethodBase[] meths = InternalGetMethod(name,
                                                   bindingAttr,
                                                   callConvention,
                                                   types,
                                                   argCnt);
            // at this point a proper filter with respect to BindingAttributes and calling convention already happened
            if (meths == null)
                return null;
            if (argCnt <= 0) {
                // either no args or a method with 0 args was specified
                if (meths.Length == 1)
                    return (MethodInfo) meths[0];
                else if (argCnt < 0) {
                    // There are multiple methods with the same name. Check to see if they are all
                    // new slots with the same name and sig.
                    foreach(MethodBase m in meths) {
                        if (!System.DefaultBinder.CompareMethodSigAndName(m, meths[0]))
                            // One of the methods is not a new slot. So the match is ambigous.
                            throw new AmbiguousMatchException(Environment.GetResourceString("RFLCT.Ambiguous"));
                    }

                    // All the methods are new slots with the same name and sig so return the most derived one.
                    return (MethodInfo) System.DefaultBinder.FindMostDerivedNewSlotMeth(meths, meths.Length);
                }
            }

            return (MethodInfo) binder.SelectMethod(bindingAttr, meths, types, modifiers);                  
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern MethodInfo[] InternalGetMethod(String name,
                                                      BindingFlags invokeAttr,
                                                      CallingConventions callConv,
                                                      Type[] types,
                                                      int argCnt);
        
        // GetFields
        // Get fields will return a full array of fields implemented by a class
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetFields"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern FieldInfo[] GetFields();

        // GetField
        // Get Field will return a specific field based upon name
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetField"]/*' />
        public FieldInfo GetField(String name) {
            if (name == null)
                throw new ArgumentNullException("name");
            return GetField(name,Module.DefaultLookup);
        }
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetField1"]/*' />
        public FieldInfo GetField(String name, BindingFlags bindingAttr)
        {
            if (name == null)
                throw new ArgumentNullException("name");

            return InternalGetField(name, bindingAttr);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern FieldInfo InternalGetField(String name, BindingFlags bindingAttr);
    

        //
        // ISerializable Implementation
        //
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetObjectData"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            UnitySerializationHolder.GetUnitySerializationInfo(info, UnitySerializationHolder.ModuleUnity, this.ScopeName, nGetAssembly());
        }
    
        /////////////////////////// ICustomAttributeProvider Interface
       // Return an array of all of the custom attributes
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetCustomAttributes"]/*' />
        public virtual Object[] GetCustomAttributes(bool inherit)
        {
            return CustomAttribute.GetCustomAttributes(this, null);
        }
        
            
        // Return a custom attribute identified by Type
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.GetCustomAttributes1"]/*' />
        public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            attributeType = attributeType.UnderlyingSystemType;
            if (!(attributeType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");

            return CustomAttribute.GetCustomAttributes(this, attributeType);
         }
    
        // Return if a custom attribute identified by Type
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.IsDefined"]/*' />
        public virtual bool IsDefined (Type attributeType, bool inherit)
        {
            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            return CustomAttribute.IsDefined(this, attributeType);
        }
        
        /// <include file='doc\Module.uex' path='docs/doc[@for="Module.IsResource"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern bool IsResource();

        //
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
            m_pRefClass = IntPtr.Zero;    
            m_pData = IntPtr.Zero;
            m_pInternalSymWriter = IntPtr.Zero;
            m_pGlobals = IntPtr.Zero;
            m_pFields = IntPtr.Zero;
        }
#endif
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\reflectiontypeloadexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// ReflectionTypeLoadException is thrown when multiple TypeLoadExceptions may occur.  
//	Specifically, when you call Module.GetTypes() this causes multiple class loads to occur.
//	If there are failures, we continue to load classes and build an array of the successfully
//	loaded classes.  We also build an array of the errors that occur.  Then we throw this exception
//	which exposes both the array of classes and the array of TypeLoadExceptions. 
//
// Author: darylo
// Date: March 99
//
namespace System.Reflection {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\ReflectionTypeLoadException.uex' path='docs/doc[@for="ReflectionTypeLoadException"]/*' />
	[Serializable()] 
    public sealed class ReflectionTypeLoadException : SystemException, ISerializable {
    	private Type[] _classes;
    	private Exception[] _exceptions;

		// private constructor.  This is not called.
    	private ReflectionTypeLoadException()
	        : base(Environment.GetResourceString("Arg_ReflectionTypeLoadException")) {
    		SetErrorCode(__HResults.COR_E_REFLECTIONTYPELOAD);
    	}

		// private constructor.  This is called from inside the runtime.
    	private ReflectionTypeLoadException(String message) : base(message)	{
    		SetErrorCode(__HResults.COR_E_REFLECTIONTYPELOAD);
    	}

        /// <include file='doc\ReflectionTypeLoadException.uex' path='docs/doc[@for="ReflectionTypeLoadException.ReflectionTypeLoadException"]/*' />
        public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions) : base(null)
		{
    		_classes = classes;
    		_exceptions = exceptions;
    		SetErrorCode(__HResults.COR_E_REFLECTIONTYPELOAD);
        }

        /// <include file='doc\ReflectionTypeLoadException.uex' path='docs/doc[@for="ReflectionTypeLoadException.ReflectionTypeLoadException1"]/*' />
        public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, String message) : base(message)
		{
    		_classes = classes;
    		_exceptions = exceptions;
    		SetErrorCode(__HResults.COR_E_REFLECTIONTYPELOAD);
        }

        internal ReflectionTypeLoadException(SerializationInfo info, StreamingContext context) : base (info, context) {
            _classes = (Type[])(info.GetValue("Types", typeof(Type[])));
            _exceptions = (Exception[])(info.GetValue("Exceptions", typeof(Exception[])));
        }
    
    	/// <include file='doc\ReflectionTypeLoadException.uex' path='docs/doc[@for="ReflectionTypeLoadException.Types"]/*' />
    	public Type[] Types {
    	    get {return _classes;}
    	}
    	
    	/// <include file='doc\ReflectionTypeLoadException.uex' path='docs/doc[@for="ReflectionTypeLoadException.LoaderExceptions"]/*' />
    	public Exception[] LoaderExceptions {
    	    get {return _exceptions;}
    	}    

        /// <include file='doc\ReflectionTypeLoadException.uex' path='docs/doc[@for="ReflectionTypeLoadException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            base.GetObjectData(info, context);
            info.AddValue("Types", _classes, typeof(Type[]));
            info.AddValue("Exceptions", _exceptions, typeof(Exception[]));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\parameterattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// ParameterAttributes is an enum defining the attributes that may be 
//	associated with a Parameter.  These are defined in CorHdr.h.
//
// Author: darylo
// Date: Aug 99
//
namespace System.Reflection {
    
	using System;
	// This Enum matchs the CorParamAttr defined in CorHdr.h
    /// <include file='doc\ParameterAttributes.uex' path='docs/doc[@for="ParameterAttributes"]/*' />
	[Flags, Serializable]  
    public enum ParameterAttributes
    {
    	/// <include file='doc\ParameterAttributes.uex' path='docs/doc[@for="ParameterAttributes.None"]/*' />
    	None	  =	  0x0000,	  // no flag is specified
        /// <include file='doc\ParameterAttributes.uex' path='docs/doc[@for="ParameterAttributes.In"]/*' />
        In        =   0x0001,     // Param is [In]    
        /// <include file='doc\ParameterAttributes.uex' path='docs/doc[@for="ParameterAttributes.Out"]/*' />
        Out       =   0x0002,     // Param is [Out]   
        /// <include file='doc\ParameterAttributes.uex' path='docs/doc[@for="ParameterAttributes.Lcid"]/*' />
        Lcid      =   0x0004,     // Param is [lcid]  
        /// <include file='doc\ParameterAttributes.uex' path='docs/doc[@for="ParameterAttributes.Retval"]/*' />
        Retval    =   0x0008,     // Param is [Retval]    
        /// <include file='doc\ParameterAttributes.uex' path='docs/doc[@for="ParameterAttributes.Optional"]/*' />
        Optional  =   0x0010,     // Param is optional 

		// Reserved flags for Runtime use only.
		/// <include file='doc\ParameterAttributes.uex' path='docs/doc[@for="ParameterAttributes.ReservedMask"]/*' />
		ReservedMask              =   0xf000,
		/// <include file='doc\ParameterAttributes.uex' path='docs/doc[@for="ParameterAttributes.HasDefault"]/*' />
		HasDefault                =   0x1000,     // Param has default value.
		/// <include file='doc\ParameterAttributes.uex' path='docs/doc[@for="ParameterAttributes.HasFieldMarshal"]/*' />
		HasFieldMarshal           =   0x2000,     // Param has FieldMarshal.
		/// <include file='doc\ParameterAttributes.uex' path='docs/doc[@for="ParameterAttributes.Reserved3"]/*' />
		Reserved3                 =   0x4000,     // reserved bit
		/// <include file='doc\ParameterAttributes.uex' path='docs/doc[@for="ParameterAttributes.Reserved4"]/*' />
		Reserved4                 =   0x8000      // reserved bit 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\resourceattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// ResourceAttributes is an enum which defines the attributes that may be associated
//  with a manifest resource.  The values here are defined in Corhdr.h.
//
// Author: meichint
// Date: April 2000
//
namespace System.Reflection {
    
    using System;
    /// <include file='doc\ResourceAttributes.uex' path='docs/doc[@for="ResourceAttributes"]/*' />
    [Serializable, Flags]  
    public enum ResourceAttributes
    {
        /// <include file='doc\ResourceAttributes.uex' path='docs/doc[@for="ResourceAttributes.Public"]/*' />
        Public          =   0x0001,
        /// <include file='doc\ResourceAttributes.uex' path='docs/doc[@for="ResourceAttributes.Private"]/*' />
        Private         =   0x0002,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\runtimeeventinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// EventInfo is an abstract base class for the Events in the system.  The runtime
//  provides an __RuntimeEventInfo class that represents the events known by the
//  system.
//
// Author: darylo
// Date: July 98
//
namespace System.Reflection {
    
    //This class doesn't actually do anything yet, so we're not worrying about
    //serialization.
    using System;
    using System.Runtime.CompilerServices;

    //@TODO: This will be fixed in Beta.  Currently its completely out
    //  of date. (And broken)
    // No data, does not need to be marked with the serializable attribute
    class RuntimeEventInfo : EventInfo
    {
        // The two integers are pointers to internal data structures
        //  within the runtime.  Don't modify their values.
        // (maps to ReflectTokenBaseObject in unmanaged world)
        private ParameterInfo[] _params;
        private IntPtr _pRefClass = IntPtr.Zero;
        private IntPtr _pData = IntPtr.Zero;
        private int _m_token = 0;
        
    
        // Prevent from begin created
        private RuntimeEventInfo() {}
    
        // GetAddMethod
        // Return the add method
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        extern public override MethodInfo GetAddMethod(bool nonPublic); 
        
        // GetRemoveMethod
        // This method will return the unsubscribe method
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        extern public override MethodInfo GetRemoveMethod(bool nonPublic);
        
        // GetRaiseMethod
        // This method will return the raise event method
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        extern public override MethodInfo GetRaiseMethod(bool nonPublic);

        // Return the class that declared this Event.
        public override String Name {
            get {return InternalGetName();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        extern private String InternalGetName();
        
        // Return the string representation of EventInfo.
        public override String ToString() {
            return InternalToString();
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InternalToString();   
        
        // Return the class that declared this EventInfo.
        public override Type DeclaringType {
            get {return InternalDeclaringClass();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Type InternalDeclaringClass();
    
        // Return the class that was used to obtain this property.
        public override Type ReflectedType {
            get {return InternalReflectedClass(false);}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern override Type InternalReflectedClass(bool returnGlobalClass);
        
        // Attribute -- Return the attributes associated
        //  with this event.
        public override EventAttributes Attributes {
            get {return InternalGetAttributeFlags();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern EventAttributes InternalGetAttributeFlags( );
        
        // Overridden Methods...
        // Equals
        // Must determine if the method is the same
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override bool Equals(Object obj);

        public override int GetHashCode() {
            //Since this is a constant pointer, we should be fine.
            return _m_token;
        }
        
        /////////////////////////// ICustomAttributeProvider Interface
       // Return an array of all of the custom attributes
        public override Object[] GetCustomAttributes(bool inherit)
        {
            return CustomAttribute.GetCustomAttributes(this, null, inherit);
        }
    
        // Return an array of custom attribute identified by Type
        public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
    		if (attributeType == null)
    			throw new ArgumentNullException("attributeType");
    		attributeType = attributeType.UnderlyingSystemType;
    		if (!(attributeType is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
            return CustomAttribute.GetCustomAttributes(this, attributeType, inherit);
        }

       // Returns true if one or more instance of attributeType is defined on this member. 
        public override bool IsDefined (Type attributeType, bool inherit)
        {
            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            return CustomAttribute.IsDefined(this, attributeType, inherit);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\propertyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// PropertyInfo is an abstract base class representing a Property in the system.  
//	Properties are logically collections of methods that act as accessors.
//	In the system, __RuntimePropertyInfo represents a property.
//
// Author: darylo
// Date: July 98
//
namespace System.Reflection {
	using System;
	using System.Runtime.InteropServices;
	using CultureInfo = System.Globalization.CultureInfo;
    using DebuggerStepThroughAttribute = System.Diagnostics.DebuggerStepThroughAttribute;

    /// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo"]/*' />
	[Serializable()]  
    [ClassInterface(ClassInterfaceType.AutoDual)]
    abstract public class PropertyInfo : MemberInfo
    {
    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.PropertyInfo"]/*' />
    	protected PropertyInfo() {}
    	// The Member type Property.
    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.MemberType"]/*' />
    	public override MemberTypes MemberType {
    		get {return System.Reflection.MemberTypes.Property;}
    	}
    						  
    	// Return the Type that represents the type of the field
    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.PropertyType"]/*' />
    	public abstract Type PropertyType {
    		get;
    	}
    	
    	// Get the value of the property.
    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.GetValue"]/*' />
		[DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
    	public virtual Object GetValue(Object obj,Object[] index)
    	{
    		return GetValue(obj,BindingFlags.Default,null,index,null);
    	}

    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.GetValue1"]/*' />
    	abstract public Object GetValue(Object obj,BindingFlags invokeAttr,Binder binder,
										Object[] index,	CultureInfo culture);
    	
    	// Set the value of the property.
    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.SetValue"]/*' />
		[DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
    	public virtual void SetValue(Object obj, Object value, Object[] index)
    	{
    		SetValue(obj,value,BindingFlags.Default,null,index,null);
    	}

    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.SetValue1"]/*' />
    	abstract public void SetValue(Object obj, Object value, BindingFlags invokeAttr, Binder binder,
									  Object[] index, CultureInfo culture);
    	
    	// GetAccessors
    	// This method will return an array of accessors.  The array
    	//	will be empty if no accessors are found.
    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.GetAccessors"]/*' />
    	public MethodInfo[] GetAccessors() {
    		return GetAccessors(false);
    	}

    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.GetAccessors1"]/*' />
    	abstract public MethodInfo[] GetAccessors(bool nonPublic);
    	
    	// GetMethod 
    	// This propertery is the MethodInfo representing the Get Accessor
    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.GetGetMethod"]/*' />
    	public MethodInfo GetGetMethod()
    	{
    		return GetGetMethod(false);
    	}

    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.GetGetMethod1"]/*' />
    	abstract public MethodInfo GetGetMethod(bool nonPublic);
    	
    	// SetMethod
    	// This property is the MethodInfo representing the Set Accessor
    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.GetSetMethod"]/*' />
    	public MethodInfo GetSetMethod()
    	{
    		return GetSetMethod(false);
    	}

    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.GetSetMethod1"]/*' />
    	abstract public MethodInfo GetSetMethod(bool nonPublic);
    	    	
    	// Return the parameters for the indexes
    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.GetIndexParameters"]/*' />
    	abstract public ParameterInfo[] GetIndexParameters();
    		
    	////////////////////////////////////////////////////////////////////////////////
    	//   Attributes
    	////////////////////////////////////////////////////////////////////////////////
    	// Property representing the Attributes associated with a Member.  All 
    	// members have a set of attributes which are defined in relation to 
    	// the specific type of member.
    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.Attributes"]/*' />
    	public abstract PropertyAttributes Attributes {
    		get;
    	}
    	
    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.IsSpecialName"]/*' />
    	public bool IsSpecialName {
    		get {return ((Attributes & PropertyAttributes.SpecialName) != 0);}
    	}

    	// Boolean property indicating if the property can be read.
    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.CanRead"]/*' />
    	public abstract bool CanRead {
    		get;
    	}
    									
    	// Boolean property indicating if the property can be written.
    	/// <include file='doc\PropertyInfo.uex' path='docs/doc[@for="PropertyInfo.CanWrite"]/*' />
    	public abstract bool CanWrite {
    		get;
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\parameterinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// ParameterInfo is an class that represents a parameter.  This contains information
//  about the type of a parameter, the default value, etc. 
//
// Author: darylo
// Date: Aug 99
//
namespace System.Reflection {
    
    using System;
    using System.Reflection.Cache;
    using System.Runtime.CompilerServices;
    
    /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo"]/*' />
    [Serializable()]
    public class ParameterInfo : ICustomAttributeProvider
    {
        // these are the fields that store the public attributes.
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.NameImpl"]/*' />
        protected String NameImpl;                  // The name of the parameter
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.ClassImpl"]/*' />
        protected Type ClassImpl;                   // The class which represents the type of the param
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.PositionImpl"]/*' />
        protected int PositionImpl;                 // Zero based position
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.AttrsImpl"]/*' />
        protected ParameterAttributes AttrsImpl;    // Other attrs like ByRef, etc.
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.DefaultValueImpl"]/*' />
        protected Object DefaultValueImpl;          // The default value
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.MemberImpl"]/*' />
        protected MemberInfo MemberImpl;            // The member
        
        // The following fields are used to get the custom attributes.
        private IntPtr _importer;
        private int _token;

        // keep track whether GetCustomAttributes(s_DecimalConstantAttributeType, false); has beencalled yet
        private bool bExtraConstChecked;

        static private Type ParameterInfoType = typeof(System.Reflection.ParameterInfo);
        
        // Prevent users from creating empty parameters.
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.ParameterInfo"]/*' />
        protected ParameterInfo() {}
        
        // There is a single constructor that is used to create a Parameter.  This is
        //  only called from native so it can be private.
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.ParameterInfo1"]/*' />
        internal ParameterInfo(Type theClass, String name, int position, ParameterAttributes attributes) 
        {
            ClassImpl = theClass;
            NameImpl = name;
            PositionImpl = position;
            AttrsImpl = attributes;
            DefaultValueImpl = DBNull.Value;
            MemberImpl = null;
            
            _importer = (IntPtr)0;
            _token = 0;
        }
        
        // This is a private constructor called inside the runtime.  There is
        //  a signature defined in Metasig.cpp  The attrsmod is two things.
        // We store the token an importer here so that the code dealing with
        //  custom attributes will work.
        // CALLED FROM NATIVE IN COMMEMBER.CPP!!!!
        private ParameterInfo(Type cls, MemberInfo member, String name, int pos, int attrs, int notUsed, bool hasDefaultValue,
                Object defValue, IntPtr importer, int token) 
        {
            ClassImpl = cls;
            NameImpl = name;
            PositionImpl = pos;
            AttrsImpl = (ParameterAttributes) attrs;
            MemberImpl = member;
    		
            _importer = importer;
            _token = token;

            if (hasDefaultValue) {
                // If there is a default value in the metadata then set it.
                DefaultValueImpl = defValue;
            }
            else {
				if (IsOptional)
                    // If the argument is marked as optional then the default value is Missing.Value.
                    DefaultValueImpl = Missing.Value;
                else
                    DefaultValueImpl = DBNull.Value;
            }
        }
    
        // This is an internal constructor called to set up parameter info's for 
        // properties. For properties, we take the parameter info's for the getter
        // or the setter and we simply change the member that owns the parameter info.
        internal ParameterInfo(ParameterInfo srcParamInfo, MemberInfo newMember)
        {
            // Copy the fields from the source param info.
            ClassImpl = srcParamInfo.ClassImpl;
            NameImpl = srcParamInfo.NameImpl;
            PositionImpl = srcParamInfo.PositionImpl;
            AttrsImpl = srcParamInfo.AttrsImpl;
            DefaultValueImpl = srcParamInfo.DefaultValueImpl;
            _importer = srcParamInfo._importer;
            _token = srcParamInfo._token;
            bExtraConstChecked = srcParamInfo.bExtraConstChecked;

            // Set the new member info that owns this param info.
            MemberImpl = newMember;         
        }

        // The class that represents the type of the parameter.
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.ParameterType"]/*' />
        public virtual Type ParameterType {
            get {return ClassImpl;}
        }
        
        // The name of the parameter.  This may not be present in all parameters because
        // all compilers do not generate this in the meta data.
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.Name"]/*' />
        public virtual String Name {
            get {return NameImpl;}
        }
        
        // The position in the signature.  This is a one based offset that represents
        // the order the parameters are declared in the signature.
        // ???Is this really one based?
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.Position"]/*' />
        public virtual int Position {
            get {return PositionImpl;}
        }
                            
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.Attributes"]/*' />
        public virtual ParameterAttributes Attributes {
            get {return AttrsImpl;}
        }
                            
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.IsIn"]/*' />
        public bool IsIn {
            get {return ((AttrsImpl & ParameterAttributes.In) != 0);}
        }
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.IsOut"]/*' />
        public bool IsOut {
            get {return ((AttrsImpl & ParameterAttributes.Out) != 0);}
        }
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.IsLcid"]/*' />
        public bool IsLcid {
            get {return ((AttrsImpl & ParameterAttributes.Lcid) != 0);}
        }
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.IsRetval"]/*' />
        public bool IsRetval {
            get {return ((AttrsImpl & ParameterAttributes.Retval) != 0);}
        }
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.IsOptional"]/*' />
        public bool IsOptional {
            get {return ((AttrsImpl & ParameterAttributes.Optional) != 0);}
        }
        
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.DefaultValue"]/*' />
        public virtual Object DefaultValue {
            get {
                if (!bExtraConstChecked) {
                    bExtraConstChecked = true;
                    if (DefaultValueImpl == Missing.Value || DefaultValueImpl == DBNull.Value) {
                        // If there is no default value in the metadata, then we still need to check
                        // for default values specified by custom attributes.
                        Object[] CustomAttrs = GetCustomAttributes(s_CustomConstantAttributeType, false);
                        if (CustomAttrs.Length != 0)
                        {
                            DefaultValueImpl = ((CustomConstantAttribute)CustomAttrs[0]).Value;
                        }
                        else {
                            CustomAttrs = GetCustomAttributes(s_DecimalConstantAttributeType, false);
                            if (CustomAttrs.Length != 0)
                            {
                                DefaultValueImpl = ((DecimalConstantAttribute)CustomAttrs[0]).Value;
                            }
                        }
                    }
                }
                return DefaultValueImpl;
            }
        }

        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.Member"]/*' />
        public virtual MemberInfo Member {
            get {return MemberImpl;}
        }

        /////////////////////////// ICustomAttributeProvider Interface
       // Return an array of all of the custom attributes
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.GetCustomAttributes"]/*' />
        public virtual Object[] GetCustomAttributes(bool inherit)
        {
            if (GetType() == ParameterInfo.ParameterInfoType) {
                return CustomAttribute.GetCustomAttributes(this, null, inherit);
            }
            return null;
        }
    
        // Return a custom attribute identified by Type
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.GetCustomAttributes1"]/*' />
        public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            attributeType = attributeType.UnderlyingSystemType;
            if (!(attributeType is RuntimeType))
                throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
            
            if (GetType() == ParameterInfo.ParameterInfoType) {
                return CustomAttribute.GetCustomAttributes(this, attributeType, inherit);
            }
            return null;
        }

       // Returns true if one or more instance of attributeType is defined on this member. 
        /// <include file='doc\ParameterInfo.uex' path='docs/doc[@for="ParameterInfo.IsDefined"]/*' />
        public virtual bool IsDefined (Type attributeType, bool inherit)
        {
            if (GetType() == ParameterInfo.ParameterInfoType) {
                if (attributeType == null)
                    throw new ArgumentNullException("attributeType");
                return CustomAttribute.IsDefined(this, attributeType, inherit);
            }
            return false;
        }
        
        // The size of CachedData here does not have to be accounted for (as it does when in
        // MemberInfo) because ParameterInfo has no unmanaged counterpart.
        private InternalCache m_cachedData;

        internal InternalCache Cache {
            get {
                // This grabs an internal copy of m_cachedData and uses
                // that instead of looking at m_cachedData directly because
                // the cache may get cleared asynchronously.  This prevents
                // us from having to take a lock.
                InternalCache cache = m_cachedData;
                if (cache == null) {
                    cache = new InternalCache("ParameterInfo");
                    m_cachedData = cache;
                    GC.ClearCache+=new ClearCacheHandler(OnCacheClear);
                }
                return cache;
            } 
        }
        
        internal void OnCacheClear(Object sender, ClearCacheEventArgs cacheEventArgs) {
            m_cachedData = null;
        }

        internal int GetToken() {
            return _token;
        }

        internal IntPtr GetModule() {
            return _importer;
        }

        static private readonly Type s_DecimalConstantAttributeType = typeof(DecimalConstantAttribute);
        static private readonly Type s_CustomConstantAttributeType = typeof(CustomConstantAttribute);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\runtimeconstructorinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// __RuntimeConstructorInfo is the concrete implementation of ConstructorInfo.  This
//	class represents a real constructor in the Runtime.  There is always a single
//	object for a constructor created.
//
// Author: darylo
// Date: April 98
//
namespace System.Reflection {

	using System;
	using System.Runtime.Remoting;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Reflection.Emit;
	using System.Runtime.CompilerServices;
	using CultureInfo = System.Globalization.CultureInfo;   
    using DebuggerStepThroughAttribute = System.Diagnostics.DebuggerStepThroughAttribute;
    using System.Security.Permissions;

    [Serializable()] 
    internal sealed class RuntimeConstructorInfo : ConstructorInfo, ISerializable
    {	
        // The two integers are pointers to internal data structures
        //  within the runtime.  Don't modify their values.
        // (maps to ReflectBaseObject in unmanaged world)
        private ParameterInfo[] _params;
        private IntPtr _pData = IntPtr.Zero;
        private IntPtr _pRefClass = IntPtr.Zero;
    
    	// Prevent from begin created
    	private RuntimeConstructorInfo() {throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_Constructor));}
    	
    	/////////////// MemberInfo Routines /////////////////////////////////////////////
    	
    	// Return the class that declared this Constructor.
    	public override String Name {
    		get {return InternalGetName();}
    	}
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private extern String InternalGetName();
    
    	// Invoke
    	// This will invoke the constructor
		[DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public override Object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
        {
            // Do they want us to process Default Values?
            if (parameters != null && parameters.Length > 0) {
                int length = parameters.Length;
                ParameterInfo[] p = null;
                for (int i=0;i<length;i++) {
                    // if the parameter is missing we need to get a default value.
                    if (parameters[i] == Type.Missing) {
                        if (p == null) {
                            p = GetParameters();
                            // If the parameters and the number of parameters passed are 
                            //	not the same then we need to exit.
                            if (p.Length != length)
                                throw new ArgumentException(Environment.GetResourceString("Arg_ParmCnt"),"parameters");
                        }
                        if (p[i].DefaultValue == System.DBNull.Value)
                            throw new ArgumentException(Environment.GetResourceString("Arg_VarMissNull"),"parameters");
                        parameters[i] = p[i].DefaultValue;
                    }
                }
            
                // Check for attempt to create a delegate class, we demand unmanaged
                // code permission for this since it's hard to validate the target
                // address.
                if (RuntimeType.CanCastTo((RuntimeType)DeclaringType, (RuntimeType)typeof(Delegate)))
                    new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
                
                Object[] args = new Object[length];
                for (int index = 0; index < length; index++) 
                args[index] = parameters[index];
                Object retValue = InternalInvoke(invokeAttr,binder,args,culture,binder == Type.DefaultBinder);
                for (int index = 0; index < length; index++) 
                parameters[index] = args[index];
                return retValue;
            }
            return InternalInvoke(invokeAttr,binder,parameters,culture,binder == Type.DefaultBinder);
        }
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private extern Object InternalInvoke(BindingFlags invokeAttr,Binder binder, Object[] parameters,CultureInfo culture, bool isBinderDefault);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void SerializationInvoke(Object target, SerializationInfo info, StreamingContext context);

		[DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
    	public override Object Invoke(Object obj,BindingFlags invokeAttr,Binder binder, Object[] parameters, CultureInfo culture) 
		{
            if (parameters != null && parameters.Length > 0) {
                int length = parameters.Length;
                Object[] args = new Object[length];
                for (int index = 0; index < length; index++) 
                    args[index] = parameters[index];
                Object retValue = InternalInvokeNoAllocation(obj, invokeAttr, binder, args, culture, binder == Type.DefaultBinder, null, true);
                for (int index = 0; index < length; index++) 
                    parameters[index] = args[index];
                return retValue;
            }
            return InternalInvokeNoAllocation(obj, invokeAttr, binder, parameters, culture, binder == Type.DefaultBinder, null, true);
		}
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Object InternalInvokeNoAllocation(Object obj,BindingFlags invokeAttr,Binder binder, Object[] parameters,CultureInfo culture, bool isBinderDefault, Assembly caller, bool verifyAccess);

    	// Return the class that declared this Constructor.
    	public override Type DeclaringType {
    		get {return InternalDeclaringClass();}
    	}
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private extern Type InternalDeclaringClass();
    
    	// Return the class that was used to obtain this constructor.
    	public override Type ReflectedType {
    		get {return InternalReflectedClass(false);}
    	}
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	internal extern override Type InternalReflectedClass(bool returnGlobalClass);
    	
    	// Return a string representing the constructor.
    	public override String ToString() {
    		return InternalToString();
    	}
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private extern String InternalToString();
    
    	// GetParameters
    	// This method returns an array of parameters for this method
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public extern override ParameterInfo[] GetParameters();
    
    	// Return the Attribute associated with this constructor.
    	public override MethodAttributes Attributes {
    		get {return InternalGetAttributeFlags();}
    	}
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private extern MethodAttributes InternalGetAttributeFlags( );
    	
    	// the calling convention
    	public override CallingConventions CallingConvention {
    		get {return InternalGetCallingConvention();}
    	}
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	private extern CallingConventions InternalGetCallingConvention( );
    	
    	// Return the Method Impl flags.
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public extern override MethodImplAttributes GetMethodImplementationFlags();
    	
    	/////////////////////////// ICustomAttribute Interface
       // Return an array of all of the custom attributes
        public override Object[] GetCustomAttributes(bool inherit)
        {
            return CustomAttribute.GetCustomAttributes(this, null, inherit);
    	}
    	
        // Return a custom attribute identified by Type
        public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
    		if (attributeType == null)
    			throw new ArgumentNullException("attributeType");
    		attributeType = attributeType.UnderlyingSystemType;
    		if (!(attributeType is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
            return CustomAttribute.GetCustomAttributes(this, attributeType, inherit);
        }

		// Returns true if one or more instance of attributeType is defined on this member. 
		public override bool IsDefined (Type attributeType, bool inherit)
        {
            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            return CustomAttribute.IsDefined(this, attributeType, false);
        }
        
    	// Equals
    	// Must determine if the method is the same
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public extern override bool Equals(Object obj);

		// Method Handle routines
		public override RuntimeMethodHandle MethodHandle {
			get {return GetMethodHandleImpl();}
		}
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		internal extern RuntimeMethodHandle GetMethodHandleImpl();

        // ISerializable Implementation
        public void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            MemberInfoSerializationHolder.GetSerializationInfo(info,
                                                               this.Name, 
                                                               this.InternalReflectedClass(false), 
                                                               this.ToString(),
                                                               MemberTypes.Constructor);
        }

	    public override int GetHashCode() {
			return (int)_pData + (int)_pRefClass;
		}

        internal override bool IsOverloaded
        {
            get {
                return IsOverloadedInternal();
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern bool IsOverloadedInternal();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern bool HasLinktimeDemand();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\runtimemethodinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// __RuntimeMethodInfo is the concrete implementation of MethodInfo inside the
//  runtime.  There is always a single __RuntimeMethodInfo created per method
//  on a class.  The runtime has internal knowledge of this class and accesses
//  the private fields from unmanaged code.
//
// Author: darylo
// Date: March 98
//
namespace System.Reflection {

    using System;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Reflection.Emit;
    using System.Runtime.CompilerServices;
    using CultureInfo = System.Globalization.CultureInfo;
    using DebuggerStepThroughAttribute = System.Diagnostics.DebuggerStepThroughAttribute;
    using System.Threading;

    // This is defined to support VarArgs
    //typedef ArgIterator  va_list;
    [Serializable()] 
    internal sealed class RuntimeMethodInfo : MethodInfo, ISerializable
    {
        // The two integers are pointers to internal data structures
        //  within the runtime.  Don't modify their values.
        // (maps to ReflectBaseObject in unmanaged world)
        private ParameterInfo[] _params;
        private IntPtr _pData = IntPtr.Zero;
        private IntPtr _pRefClass = IntPtr.Zero;


        // This constructor is private so that RuntimeMethodInfo objects
        // cannot be created.  These are always created internally.
        private RuntimeMethodInfo() {throw new NotSupportedException(Environment.GetResourceString("NotSupported_Constructor"));}
        /////////////// MemberInfo Routines /////////////////////////////////////////////

        // Return the class that declared this Method.
        public override String Name {
            get {return InternalGetName();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InternalGetName();

        // Return the string representation od MethodInfo.
        public override String ToString() {
                return InternalToString();
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InternalToString();   
    
        // This version of the Invoke method will call back on the Binder change any parameters
        // if the parameters don't match exactly.
        // PLEASE NOTE - ANY CHANGES MADE TO INVOKE METHOD HAVE TO BE PROPAGATED TO DispatchInfo::InvokeMember IN EE
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public override Object Invoke(Object obj,BindingFlags invokeAttr,Binder binder, Object[] parameters,CultureInfo culture)
        {
            return InternalInvoke(obj,invokeAttr,binder,parameters,culture,true);
        }

        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        internal Object InternalInvoke(Object obj,BindingFlags invokeAttr,Binder binder, Object[] parameters,CultureInfo culture, bool verifyAccess)
        {
            // Do they want us to process Default Values?
            if (parameters != null && parameters.Length > 0) {
                int length = parameters.Length;
                ParameterInfo[] p = null;
                for (int i=0;i<length;i++) {
                    // if the parameter is missing we need to get a default value.
                    if (parameters[i] == Type.Missing) {
                        if (p == null) {
                            p = GetParameters();
                            // If the parameters and the number of parameters passed are 
                            //  not the same then we need to exit.
                            if (p.Length != length)
                                throw new ArgumentException(Environment.GetResourceString("Arg_ParmCnt"),"parameters");
                        }
                        if (p[i].DefaultValue == System.DBNull.Value)
                            throw new ArgumentException(Environment.GetResourceString("Arg_VarMissNull"),"parameters");
                        parameters[i] = p[i].DefaultValue;
                    }
                }
                BCLDebug.Assert(this!=null, "[RuntimeMethodInfo.Invoke]this!=null");
                Object[] args = new Object[length];
                for (int index = 0; index < length; index++) 
                    args[index] = parameters[index];
                Object retValue = InternalInvoke(obj,invokeAttr,binder,args,culture,binder == Type.DefaultBinder, null, verifyAccess);
                for (int index = 0; index < length; index++) 
                    parameters[index] = args[index];
                return retValue;
            }
            return InternalInvoke(obj,invokeAttr,binder,parameters,culture,binder == Type.DefaultBinder, null, verifyAccess);
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern Object InternalInvoke(Object obj,BindingFlags invokeAttr,Binder binder, Object[] parameters,CultureInfo culture, bool isBinderDefault, Assembly caller, bool verifyAccess);
    
        //@COOLPORT:
        //[CLSCompliant(false)]
        //public override Variant DirectInvoke(Object obj, BindingFlags invokeAttr, Binder binder, CultureInfo culture, ...)
        //{
    
        //  va_list  args;
        //  va_start(args, culture);
        //  return InternalDirectInvoke(obj,invokeAttr,binder,culture,args);
        //}   
        //[MethodImplAttribute(MethodImplOptions.InternalCall)]
        //private extern Object InternalDirectInvoke(Object obj, BindingFlags invokeAttr, Binder binder, CultureInfo culture, ArgIterator args);
    
        // Return the base implementation for a method.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override MethodInfo GetBaseDefinition();

        // Return the base implementation for a method.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern override MethodInfo GetParentDefinition();


        // Return type Type of the methods return type
        public override Type ReturnType {
            get {return InternalGetReturnType();} 
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Type InternalGetReturnType();

        // This method will return an object that represents the 
        //  custom attributes for the return type.
        public override ICustomAttributeProvider ReturnTypeCustomAttributes {
            get {
                return new ReturnCustomAttributes(this);
            } 
        }

        // Return the Type that declared this Method.
        public override Type DeclaringType {
            get {return InternalDeclaringClass();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Type InternalDeclaringClass();

        // Return the class that was used to obtain this method.
        public override Type ReflectedType {
            get {return InternalReflectedClass(false);}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern override Type InternalReflectedClass(bool returnGlobalClass);

        // GetParameters
        // This method returns an array of parameters for this method
        public override ParameterInfo[] GetParameters()
        {
            if (_params == null)
                _params = InternalGetParameters();
            ParameterInfo[] ret = new ParameterInfo[_params.Length];
            Array.Copy(_params,ret,_params.Length);
            return ret;
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern ParameterInfo[] InternalGetParameters();
    
        // Return the Attribute associated with this Method.
        public override MethodAttributes Attributes {
            get {return InternalGetAttributeFlags();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern MethodAttributes InternalGetAttributeFlags( );
    
        // the calling convention
        public override CallingConventions CallingConvention {
            get {return InternalGetCallingConvention();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern CallingConventions InternalGetCallingConvention( );
    
        // Return the Method Impl flags.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override MethodImplAttributes GetMethodImplementationFlags();
    
        /////////////////////////// ICustomAttribute Interface
       // Return an array of all of the custom attributes
        public override Object[] GetCustomAttributes(bool inherit)
        {
            return CustomAttribute.GetCustomAttributes(this, null, inherit);
        }
        
        // Return a custom attribute identified by Type
        public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
    		if (attributeType == null)
    			throw new ArgumentNullException("attributeType");
    		attributeType = attributeType.UnderlyingSystemType;
    		if (!(attributeType is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
            return CustomAttribute.GetCustomAttributes(this, attributeType, inherit);
        }

       // Returns true if one or more instance of attributeType is defined on this member. 
        public override bool IsDefined (Type attributeType, bool inherit)
        {
            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            return CustomAttribute.IsDefined(this, attributeType, inherit);
        }
        
        // Equals
        // Must determine if the method is the same
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override bool Equals(Object obj);
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern MethodBase InternalGetCurrentMethod(ref StackCrawlMark stackMark);
        
        // Method Handle routines
        public override RuntimeMethodHandle MethodHandle {
            get {return GetMethodHandleImpl();}
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern RuntimeMethodHandle GetMethodHandleImpl();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern MethodBase GetMethodFromHandleImp(RuntimeMethodHandle handle);

        // ISerializable Implementation
        //

        public void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            MemberInfoSerializationHolder.GetSerializationInfo(info,
                                                               this.Name, 
                                                               this.InternalReflectedClass(false), 
                                                               this.ToString(), 
                                                               System.Reflection.MemberTypes.Method);
        }

	    public override int GetHashCode() {
			return (int)_pData + (int)_pRefClass;
		}

        internal override bool IsOverloaded
        {
            get {
                return IsOverloadedInternal();
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern bool IsOverloadedInternal();
    }

    [Serializable()]
    class ReturnCustomAttributes : ICustomAttributeProvider
    {
        RuntimeMethodInfo m_method;

        public ReturnCustomAttributes(RuntimeMethodInfo method)
        {
            if (method == null) 
                throw new ArgumentNullException("method");
            m_method = method;
        }

       // Return an array of custom attributes identified by Type
        public Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
            return CustomAttribute.GetCAReturnValue(m_method, attributeType, inherit);
        }

       // Return an array of all of the custom attributes (named attributes are not included)
        public Object[] GetCustomAttributes(bool inherit)
        {
            return CustomAttribute.GetCAReturnValue(m_method, null, inherit);
        }
    
       // Returns true if one or more instance of attributeType is defined on this member. 
        public bool IsDefined (Type attributeType, bool inherit) 
        {
            return CustomAttribute.IsCAReturnValueDefined(m_method, attributeType, inherit);
        }
    
    }
}   // Namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\runtimefieldinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// __RuntimeFieldInfo is the concrete implementation of FieldInfo representing
//  a real field in the system.  This class is known by the runtime and stores
//  data that is accessed in Native code.
//
// Author: darylo
// Date: March 98
//
namespace System.Reflection {

    using System;
    using System.Reflection.Cache;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization;
    using System.Runtime.CompilerServices;
    using CultureInfo = System.Globalization.CultureInfo;
    using DebuggerStepThroughAttribute = System.Diagnostics.DebuggerStepThroughAttribute;

    [Serializable()] 
    internal sealed class RuntimeFieldInfo : FieldInfo, ISerializable {
        // The two integers are pointers to internal data structures
        //  within the runtime.  Don't modify their values.
        // (maps to ReflectBaseObject in unmanaged world)
        private IntPtr _pData = IntPtr.Zero;
        private IntPtr _pRefClass = IntPtr.Zero;
        private ParameterInfo[] _params;
        
        // This constsructor is private so that it is never called.  RuntimeFieldInfo's
        // are always constructed internally.
        private RuntimeFieldInfo() {throw new NotSupportedException(Environment.GetResourceString("NotSupported_Constructor"));}
            
        /////////////// MemberInfo Routines /////////////////////////////////////////////
        
        // Return the class that declared this Field.
        public override String Name {
            get {
                String s;
                 if ((s = (String)Cache[CacheObjType.FieldName])==null) {
                     s = InternalGetName();
                     Cache[CacheObjType.FieldName] = s;
                 }
                 return s;
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InternalGetName();
        
        
        // Return the string representation of FieldInfo.
        public override String ToString() {
            return InternalToString();
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InternalToString();   
        
        // Return the class that declared this Field.
        public override Type DeclaringType {
            get {return InternalDeclaringClass();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Type InternalDeclaringClass();
        
        // Return the class that was used to obtain this field.
        public override Type ReflectedType {
            get {return InternalReflectedClass(false);}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern override Type InternalReflectedClass(bool returnGlobalClass);
        
        // Return the Type that represents the type of the field
        public override Type FieldType {
             get { 
                 Type t;
                 if ((t = (Type)Cache[CacheObjType.FieldType])==null) {
                     t = InternalGetFieldType();
                     Cache[CacheObjType.FieldType] = t;
                 }
                 return t;
             }
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Type InternalGetFieldType();
        
        // GetValue 
        // This method will return a object which represents the 
        //  value of the field
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public override Object GetValue(Object obj) {
            return InternalGetValue(obj, true);
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern Object InternalGetValue(Object obj, bool requiresAccessCheck);

        [CLSCompliant(false)]
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public override Object GetValueDirect(TypedReference obj)
        {
            return GetValueDirectImpl(obj,true);
        }

        [CLSCompliant(false)]
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public override void SetValueDirect(TypedReference obj,Object value) {
            SetValueDirectImpl(obj,value,true);
        }

        [CLSCompliant(false),
        MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern Object GetValueDirectImpl(TypedReference obj,bool requiresAccessCheck);

        [CLSCompliant(false),
        MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void SetValueDirectImpl(TypedReference obj,Object value, bool requiresAccessCheck);

        // SetValue
        // This method will set the value of a field in an object (if the
        //  field is marked final an exception is thrown)
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public override void SetValue(Object obj,Object val,BindingFlags invokeAttr,Binder binder,CultureInfo culture) {
            InternalSetValue(obj, val, invokeAttr, binder, culture, true, binder == Type.DefaultBinder);
        }
        
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void InternalSetValue(Object obj,Object val,BindingFlags invokeAttr,Binder binder,CultureInfo culture, bool requiresAccessCheck, bool isBinderDefault);
    
        public override RuntimeFieldHandle FieldHandle {
            get {return GetFieldHandleImpl();}
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern RuntimeFieldHandle GetFieldHandleImpl();
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern FieldInfo GetFieldFromHandleImp(RuntimeFieldHandle handle);

        // Return the Attribute associated with this field.
        public override FieldAttributes Attributes {
            get {return InternalGetAttributeFlags();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern FieldAttributes InternalGetAttributeFlags();
    
        /////////////////////////// ICustomAttributeProvider Interface
       // Return an array of all of the custom attributes
        public override Object[] GetCustomAttributes(bool inherit)
        {
            return CustomAttribute.GetCustomAttributes(this, null, inherit);
        }
        
        // Return a custom attribute identified by Type
        public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
    		if (attributeType == null)
    			throw new ArgumentNullException("attributeType");
    		attributeType = attributeType.UnderlyingSystemType;
    		if (!(attributeType is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
            return CustomAttribute.GetCustomAttributes(this, attributeType, inherit);
        }
    
        // Return if there is a  custom attribute identified by Type
        public override bool IsDefined (Type attributeType, bool inherit)
        {
            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            return CustomAttribute.IsDefined(this, attributeType, inherit);
        }
        
        // ISerializable Implementation
        //
        public void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            MemberInfoSerializationHolder.GetSerializationInfo(info, 
                                                               this.Name, 
                                                               this.InternalReflectedClass(false), 
                                                               this.ToString(), 
                                                               System.Reflection.MemberTypes.Field);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\strongnamekeypair.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    StrongNameKeyPair.cs
**
** Author:  Rudi Martin (rudim)
**
** Purpose: Encapsulate access to a public/private key pair
**          used to sign strong name assemblies.
**
** Date:    Feb 23, 2000
**
===========================================================*/
namespace System.Reflection
{

	using System;
	using System.IO;
	using System.Security.Permissions;
	using System.Runtime.CompilerServices;

    /// <include file='doc\StrongNameKeyPair.uex' path='docs/doc[@for="StrongNameKeyPair"]/*' />
	[Serializable()]
    public class StrongNameKeyPair
    {
        private bool    _keyPairExported;
        private byte[]  _keyPairArray;
        private String  _keyPairContainer;
        private byte[]  _publicKey;

        // Build key pair from file.
        /// <include file='doc\StrongNameKeyPair.uex' path='docs/doc[@for="StrongNameKeyPair.StrongNameKeyPair"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public StrongNameKeyPair(FileStream keyPairFile)
        {
            if (keyPairFile == null)
                throw new ArgumentNullException("keyPairFile");

            int length = (int)keyPairFile.Length;
            _keyPairArray = new byte[length];
            keyPairFile.Read(_keyPairArray, 0, length);

            _keyPairExported = true;
        }

        // Build key pair from byte array in memory.
        /// <include file='doc\StrongNameKeyPair.uex' path='docs/doc[@for="StrongNameKeyPair.StrongNameKeyPair1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public StrongNameKeyPair(byte[] keyPairArray)
        {
            if (keyPairArray == null)
                throw new ArgumentNullException("keyPairArray");

            _keyPairArray = new byte[keyPairArray.Length];
            Array.Copy(keyPairArray, _keyPairArray, keyPairArray.Length);

            _keyPairExported = true;
        }

        // Reference key pair in named key container.
        /// <include file='doc\StrongNameKeyPair.uex' path='docs/doc[@for="StrongNameKeyPair.StrongNameKeyPair2"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public StrongNameKeyPair(String keyPairContainer)
        {
            if (keyPairContainer == null)
                throw new ArgumentNullException("keyPairContainer");

            _keyPairContainer = keyPairContainer;

            _keyPairExported = false;
        }

        // Get the public portion of the key pair.
        /// <include file='doc\StrongNameKeyPair.uex' path='docs/doc[@for="StrongNameKeyPair.PublicKey"]/*' />
        public byte[] PublicKey
        {
            get
            {
                if (_publicKey == null)
                    _publicKey = nGetPublicKey(_keyPairExported, _keyPairArray, _keyPairContainer);

                return _publicKey;
            }
        }

        // Internal routine used to retrieve key pair info from unmanaged code.
        private bool GetKeyPair(out Object arrayOrContainer)
        {
            arrayOrContainer = _keyPairExported ? (Object)_keyPairArray : (Object)_keyPairContainer;
            return _keyPairExported;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[] nGetPublicKey(bool exported, byte[] array, String container);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\runtimepropertyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// __RuntimePropertyInfo is the concrete implementation of PropertyInfo inside the runtime.
//  The data associated with this class is known by the runtime and accessed
//  in unmanaged code.
//
// Author: darylo
// Date: July 98
//
namespace System.Reflection {
    
    using System;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization;
    using System.Runtime.CompilerServices;
    using CultureInfo = System.Globalization.CultureInfo;
    using DebuggerStepThroughAttribute = System.Diagnostics.DebuggerStepThroughAttribute;

    [Serializable()] 
    internal sealed class RuntimePropertyInfo : PropertyInfo, ISerializable
    {
        // The two integers are pointers to internal data structures
        //  within the runtime.  Don't modify their values.
        // (maps to ReflectBaseObject in unmanaged world)
        private ParameterInfo[] _params;
        private IntPtr _pData = IntPtr.Zero;
        private IntPtr _pRefClass = IntPtr.Zero;

        
    
        // This constructor is private so that PropertyInfo's cannot
        // be created.  They are always constructed internally.
        private RuntimePropertyInfo() {throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_Constructor));}
        
        // Get the value of the property.
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public override Object GetValue(Object obj,Object[] index)
        {
            MethodInfo m = InternalGetter(true, false);
            if (m == null)
                throw new ArgumentException(System.Environment.GetResourceString("Arg_GetMethNotFnd"));
            return m.Invoke(obj,index); 
        }
        
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public override Object GetValue(Object obj,BindingFlags invokeAttr,Binder binder,Object[] index,CultureInfo culture)
        {
            MethodInfo m = InternalGetter(true, false);
            if (m == null)
                throw new ArgumentException(System.Environment.GetResourceString("Arg_GetMethNotFnd"));
            return m.Invoke(obj,invokeAttr,binder,index,culture);   
        }
        
        // Set the value of the property.
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public override void SetValue(Object obj,Object value,Object[] index)
        {
            MethodInfo m = InternalSetter(true, false);
            if (m == null)
                throw new ArgumentException(System.Environment.GetResourceString("Arg_SetMethNotFnd"));
            Object[] args = null;
            if (index != null) {
                args = new Object[index.Length + 1];
                for (int i=0;i<index.Length;i++)
                    args[i] = index[i];
                args[index.Length] = value;
            }
            else {
                args = new Object[1];
                args[0] = value;
            }
            m.Invoke(obj,args);
        }

        internal void SetValueInternal(Object obj, Object value, Assembly caller)
        {
            RuntimeMethodInfo m = InternalSetter(true, false) as RuntimeMethodInfo;
            if (m == null)
                throw new ArgumentException(System.Environment.GetResourceString("Arg_SetMethNotFnd"));
            m.InternalInvoke(obj, BindingFlags.Default, null, new Object[]{value}, null, true, caller, true);
        }
            
        [DebuggerStepThroughAttribute]
        [Diagnostics.DebuggerHidden]
        public override void SetValue(Object obj,Object value,BindingFlags invokeAttr,Binder binder,Object[] index,CultureInfo culture)
        {
            MethodInfo m = InternalSetter(true, false);
            if (m == null)
                throw new ArgumentException(System.Environment.GetResourceString("Arg_SetMethNotFnd"));
            Object[] args = null;
            if (index != null) {
                args = new Object[index.Length + 1];
                for (int i=0;i<index.Length;i++)
                    args[i] = index[i];
                args[index.Length] = value;
            }
            else {
                args = new Object[1];
                args[0] = value;
            }
            m.Invoke(obj,invokeAttr,binder,args,culture);
        }
            
        // GetAccessors
        // This method will return an array of accessors.  The array
        //  will be empty if no accessors are found.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        extern public override MethodInfo[] GetAccessors(bool nonPublic);
        
        
        // GetMethod 
        // This propertery is the MethodInfo representing the Get Accessor
        public override MethodInfo GetGetMethod(bool nonPublic)
        {
            return InternalGetter(nonPublic, true);
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        extern private MethodInfo InternalGetter(bool nonPublic, bool verifyAccess);   
        
        // SetMethod
        // This property is the MethodInfo representing the Set Accessor
        public override MethodInfo GetSetMethod(bool nonPublic)
        {
            return InternalSetter(nonPublic, true);
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        extern private MethodInfo InternalSetter(bool nonPublic, bool verifyAccess);
        
        //extern private MethodInfo InternalResetter(bool nonPublic);
                
        // Return the class that declared this Field.
        public override String Name {
            get {return InternalGetName();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InternalGetName();
    
        // Return the string representation of PropertyInfo
        public override String ToString() {
                return InternalToString();
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern String InternalToString();   
        
        // Return the Type that represents the type of the field
        public override Type PropertyType {
            get {return InternalGetType();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Type InternalGetType();
        
        // Return the parameters for the indexes
        public override ParameterInfo[] GetIndexParameters()
        {
            int numParams = 0;
            ParameterInfo[] methParams = null;

            // First try to get the Get method.
    		MethodInfo m = GetGetMethod(true);
            if (m != null)
            {
                // There is a Get method so use it.
                methParams = m.GetParameters();
                numParams = methParams.Length;
            }
            else
            {
                // If there is no Get method then use the Set method.
                m = GetSetMethod(true);

                if (m != null)
                {
                    methParams = m.GetParameters();
                    numParams = methParams.Length - 1;
                }
            }

            // Now copy over the parameter info's and change their 
            // owning member info to the current property info.
            ParameterInfo[] propParams = new ParameterInfo[numParams];
            for (int i = 0; i < numParams; i++)
                propParams[i] = new ParameterInfo(methParams[i], this);

            return propParams;
        }   
        
        // Return the class that declared this Property.
        public override Type DeclaringType {
            get {return InternalDeclaringClass();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern Type InternalDeclaringClass();
    
        // Return the class that was used to obtain this property.
        public override Type ReflectedType {
            get {return InternalReflectedClass(false);}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern override Type InternalReflectedClass(bool returnGlobalClass);
        
        
        // Return the Attribute associated with this Method.
        public override PropertyAttributes Attributes {
            get {return InternalGetAttributeFlags();}
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern PropertyAttributes InternalGetAttributeFlags( );
        
        // Boolean property indicating if the property can be read.
        public override bool CanRead {
            get {return InternalCanRead();}
        }
                                        
        // Boolean property indicating if the property can be written.
        public override bool CanWrite {
            get {return InternalCanWrite();}
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]                         
        extern private bool InternalCanRead();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        extern private bool InternalCanWrite();
    
    
        // Overridden Methods...
        // Equals
        // Must determine if the method is the same
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern override bool Equals(Object obj);
        
        /////////////////////////// ICustomAttributeProvider Interface
       // Return an array of all of the custom attributes
        public override Object[] GetCustomAttributes(bool inherit)
        {
            return CustomAttribute.GetCustomAttributes(this, null, inherit);
        }
        
    
        // Return a custom attribute identified by Type
        public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
    		if (attributeType == null)
    			throw new ArgumentNullException("attributeType");
    		attributeType = attributeType.UnderlyingSystemType;
    		if (!(attributeType is RuntimeType))
    			throw new ArgumentException(Environment.GetResourceString("Arg_MustBeType"),"elementType");
            return CustomAttribute.GetCustomAttributes(this, attributeType, inherit);
        }

        // Return a custom attribute identified by Type
        public override bool IsDefined (Type attributeType, bool inherit)
        {
            if (attributeType == null)
                throw new ArgumentNullException("attributeType");
            return CustomAttribute.IsDefined(this, attributeType, inherit);
        }
        
        //
        // ISerializable Implementation
        //
        public void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            MemberInfoSerializationHolder.GetSerializationInfo(info,
                                                               this.Name, 
                                                               this.InternalReflectedClass(false), 
                                                               null, 
                                                               System.Reflection.MemberTypes.Property);
        }

	    public override int GetHashCode() {
			return (int)_pData + (int)_pRefClass;
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\targetparametercountexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// TargetParameterCountException is thrown when the number of parameter to an
//	invocation doesn't match the number expected.
//
// Author: darylo
// Date: Oct 99
//
namespace System.Reflection {

	using System;
	using SystemException = System.SystemException;
	using System.Runtime.Serialization;
    /// <include file='doc\TargetParameterCountException.uex' path='docs/doc[@for="TargetParameterCountException"]/*' />
	[Serializable()] 
    public sealed class TargetParameterCountException : ApplicationException {
    	
        /// <include file='doc\TargetParameterCountException.uex' path='docs/doc[@for="TargetParameterCountException.TargetParameterCountException"]/*' />
        public TargetParameterCountException()
	        : base(Environment.GetResourceString("Arg_TargetParameterCountException")) {
    		SetErrorCode(__HResults.COR_E_TARGETPARAMCOUNT);
        }
    
        /// <include file='doc\TargetParameterCountException.uex' path='docs/doc[@for="TargetParameterCountException.TargetParameterCountException1"]/*' />
        public TargetParameterCountException(String message) 
			: base(message) {
    		SetErrorCode(__HResults.COR_E_TARGETPARAMCOUNT);
        }
    	
        /// <include file='doc\TargetParameterCountException.uex' path='docs/doc[@for="TargetParameterCountException.TargetParameterCountException2"]/*' />
        public TargetParameterCountException(String message, Exception inner)  
			: base(message, inner) {
    		SetErrorCode(__HResults.COR_E_TARGETPARAMCOUNT);
        }

        internal TargetParameterCountException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\targetinvocationexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// TargetInvocationException is used to report an exception that was thrown
//	by the target of an invocation.
//
// Author: darylo
// Date: March 98
//
namespace System.Reflection {
    
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\TargetInvocationException.uex' path='docs/doc[@for="TargetInvocationException"]/*' />
	[Serializable()] 
    public sealed class TargetInvocationException : ApplicationException {

		// This exception is not creatable without specifying the
		//	inner exception.
    	private TargetInvocationException()
	        : base(Environment.GetResourceString("Arg_TargetInvocationException")) {
    		SetErrorCode(__HResults.COR_E_TARGETINVOCATION);
    	}

		// This is called from within the runtime.
        private TargetInvocationException(String message) : base(message) {
    		SetErrorCode(__HResults.COR_E_TARGETINVOCATION);
        }   	
    	
        /// <include file='doc\TargetInvocationException.uex' path='docs/doc[@for="TargetInvocationException.TargetInvocationException"]/*' />
        public TargetInvocationException(System.Exception inner) 
			: base(Environment.GetResourceString("Arg_TargetInvocationException"), inner) {
    		SetErrorCode(__HResults.COR_E_TARGETINVOCATION);
        }
    
        /// <include file='doc\TargetInvocationException.uex' path='docs/doc[@for="TargetInvocationException.TargetInvocationException1"]/*' />
        public TargetInvocationException(String message, Exception inner) : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_TARGETINVOCATION);
        }

        internal TargetInvocationException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\typeattributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Reflection {
	using System.Runtime.InteropServices;
	using System;
    // This Enum matchs the CorTypeAttr defined in CorHdr.h
    /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes"]/*' />
    [Serializable, Flags] 
	public enum TypeAttributes
    {
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.VisibilityMask"]/*' />
        VisibilityMask    =   0x00000007,
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.NotPublic"]/*' />
        NotPublic         =   0x00000000,     // Class is not public scope.
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.Public"]/*' />
        Public            =   0x00000001,     // Class is public scope.
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.NestedPublic"]/*' />
        NestedPublic      =   0x00000002,     // Class is nested with public visibility.
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.NestedPrivate"]/*' />
        NestedPrivate     =   0x00000003,     // Class is nested with private visibility.
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.NestedFamily"]/*' />
        NestedFamily      =   0x00000004,     // Class is nested with family visibility.
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.NestedAssembly"]/*' />
        NestedAssembly    =   0x00000005,     // Class is nested with assembly visibility.
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.NestedFamANDAssem"]/*' />
        NestedFamANDAssem =   0x00000006,     // Class is nested with family and assembly visibility.
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.NestedFamORAssem"]/*' />
        NestedFamORAssem  =   0x00000007,     // Class is nested with family or assembly visibility.
    
    	// Use this mask to retrieve class layout informaiton
    	// 0 is AutoLayout, 0x2 is SequentialLayout, 4 is ExplicitLayout
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.LayoutMask"]/*' />
        LayoutMask        =   0x00000018,
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.AutoLayout"]/*' />
        AutoLayout        =   0x00000000,     // Class fields are auto-laid out
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.SequentialLayout"]/*' />
        SequentialLayout  =   0x00000008,     // Class fields are laid out sequentially
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.ExplicitLayout"]/*' />
        ExplicitLayout    =   0x00000010,     // Layout is supplied explicitly
    	// end layout mask
    
    	// Use this mask to distinguish a type declaration as a Class, ValueType or Interface
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.ClassSemanticsMask"]/*' />
        ClassSemanticsMask=   0x00000020,
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.Class"]/*' />
        Class             =   0x00000000,     // Type is a class.
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.Interface"]/*' />
        Interface         =   0x00000020,     // Type is an interface.
        // end semantics mask
    
        // Special semantics in addition to class semantics.
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.Abstract"]/*' />
        Abstract          =   0x00000080,     // Class is abstract
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.Sealed"]/*' />
        Sealed            =   0x00000100,     // Class is concrete and may not be extended
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.SpecialName"]/*' />
        SpecialName       =   0x00000400,     // Class name is special.  Name describes how.
    
        // Implementation attributes.
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.Import"]/*' />
        Import            =   0x00001000,     // Class / interface is imported
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.Serializable"]/*' />
        Serializable	  =	  0x00002000, 	// The class is Serializable.
    
        // Use tdStringFormatMask to retrieve string information for native interop
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.StringFormatMask"]/*' />
        StringFormatMask  =   0x00030000,     
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.AnsiClass"]/*' />
        AnsiClass         =   0x00000000,     // LPTSTR is interpreted as ANSI in this class
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.UnicodeClass"]/*' />
        UnicodeClass      =   0x00010000,     // LPTSTR is interpreted as UNICODE
        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.AutoClass"]/*' />
        AutoClass         =   0x00020000,     // LPTSTR is interpreted automatically
        // end string format mask

        /// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.BeforeFieldInit"]/*' />
        BeforeFieldInit   =   0x00100000,     // Initialize the class any time before first static field access.

		// Flags reserved for runtime use.
		/// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.ReservedMask"]/*' />
		ReservedMask	  =   0x00040800,
		/// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.RTSpecialName"]/*' />
		RTSpecialName     =   0x00000800,     // Runtime should check name encoding.
		/// <include file='doc\TypeAttributes.uex' path='docs/doc[@for="TypeAttributes.HasSecurity"]/*' />
		HasSecurity       =   0x00040000,     // Class has security associate with it.
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\targetexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// TargetException is thrown when the target to an Invoke is invalid.  This may
//	occur because the caller doesn't have access to the member, or the target doesn't
//	define the member, etc.
//
// Author: darylo
// Date: March 98
//
namespace System.Reflection {
    
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\TargetException.uex' path='docs/doc[@for="TargetException"]/*' />
	[Serializable()] 
    public class TargetException : ApplicationException {
    	
        /// <include file='doc\TargetException.uex' path='docs/doc[@for="TargetException.TargetException"]/*' />
        public TargetException() : base() {
    		SetErrorCode(__HResults.COR_E_TARGET);
        }
    
        /// <include file='doc\TargetException.uex' path='docs/doc[@for="TargetException.TargetException1"]/*' />
        public TargetException(String message) : base(message) {
    		SetErrorCode(__HResults.COR_E_TARGET);
        }
    	
        /// <include file='doc\TargetException.uex' path='docs/doc[@for="TargetException.TargetException2"]/*' />
        public TargetException(String message, Exception inner) : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_TARGET);
        }

        /// <include file='doc\TargetException.uex' path='docs/doc[@for="TargetException.TargetException3"]/*' />
        protected TargetException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\cache\cacheobjtype.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: CacheObjType
**
** Author: Jay Roxe
**
** Purpose: Enum specifying the various cache obj types.
**
** Date: Dec 11, 2000
**
============================================================*/
namespace System.Reflection.Cache {

    [Serializable]
	internal enum CacheObjType {
        EmptyElement  = 0,
        ParameterInfo = 1,
        TypeName      = 2,
        RemotingData  = 3,
        SerializableAttribute = 4,
        AssemblyName = 5,
        ConstructorInfo = 6,
        FieldType = 7,
        FieldName = 8,
        DefaultMember = 9
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\cache\clearcachehandler.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: ClearCacheHandler
**
** Author: Jay Roxe
**
** Purpose: Delegate fired when clearing the cache used in
** Reflection
**
** Date: December 20, 2000
**
============================================================*/
namespace System.Reflection.Cache {
    internal delegate void ClearCacheHandler(Object sender, ClearCacheEventArgs cacheEventArgs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\unmanagedmarshal.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Reflection.Emit
{
	using System.Runtime.InteropServices;
	using System;
    // This class is describing the fieldmarshal.
    /// <include file='doc\UnmanagedMarshal.uex' path='docs/doc[@for="UnmanagedMarshal"]/*' />
	[Serializable()]  
    public sealed class UnmanagedMarshal
    {
        /******************************
        * public static constructors. You can only construct
        * UnmanagedMarshal using these static constructors. 
        ******************************/
        /// <include file='doc\UnmanagedMarshal.uex' path='docs/doc[@for="UnmanagedMarshal.DefineUnmanagedMarshal"]/*' />
        public static UnmanagedMarshal DefineUnmanagedMarshal(UnmanagedType unmanagedType)
        {
            if (unmanagedType == UnmanagedType.ByValTStr ||
                unmanagedType == UnmanagedType.SafeArray ||
                unmanagedType == UnmanagedType.ByValArray ||
                unmanagedType == UnmanagedType.LPArray ||
                unmanagedType == UnmanagedType.CustomMarshaler)
            {
                // not a simple native marshal
                throw new ArgumentException(Environment.GetResourceString("Argument_NotASimpleNativeType"));
            }
            return new UnmanagedMarshal(unmanagedType, Guid.Empty, 0, (UnmanagedType) 0);
        }
        /// <include file='doc\UnmanagedMarshal.uex' path='docs/doc[@for="UnmanagedMarshal.DefineByValTStr"]/*' />
        public static UnmanagedMarshal DefineByValTStr(int elemCount)
        {
            return new UnmanagedMarshal(UnmanagedType.ByValTStr, Guid.Empty, elemCount, (UnmanagedType) 0);
        }
  
        /// <include file='doc\UnmanagedMarshal.uex' path='docs/doc[@for="UnmanagedMarshal.DefineSafeArray"]/*' />
        public static UnmanagedMarshal DefineSafeArray(UnmanagedType elemType)
        {
            return new UnmanagedMarshal(UnmanagedType.SafeArray, Guid.Empty, 0, elemType);
        }

        /// <include file='doc\UnmanagedMarshal.uex' path='docs/doc[@for="UnmanagedMarshal.DefineByValArray"]/*' />
        public static UnmanagedMarshal DefineByValArray(int elemCount)
        {
            return new UnmanagedMarshal(UnmanagedType.ByValArray, Guid.Empty, elemCount, (UnmanagedType) 0);
        }
    
        /// <include file='doc\UnmanagedMarshal.uex' path='docs/doc[@for="UnmanagedMarshal.DefineLPArray"]/*' />
        public static UnmanagedMarshal DefineLPArray(UnmanagedType elemType)
        {
            return new UnmanagedMarshal(UnmanagedType.LPArray, Guid.Empty, 0, elemType);
        }
    
 
        // @todo: meichint
        // DeinfeCustomMarshal(Type marshalProviderType, GUID comIID, String cookie)
        // Not implemented!

        // accessor function for the native type
    	/// <include file='doc\UnmanagedMarshal.uex' path='docs/doc[@for="UnmanagedMarshal.GetUnmanagedType"]/*' />
    	public UnmanagedType GetUnmanagedType 
		{
    		get { return m_unmanagedType; }
    	}
    
    	/// <include file='doc\UnmanagedMarshal.uex' path='docs/doc[@for="UnmanagedMarshal.IIDGuid"]/*' />
    	public Guid IIDGuid 
		{
    		get 
			{ 
                if (m_unmanagedType != UnmanagedType.CustomMarshaler) 
                {
                    // throw exception here. There is Guid only if CustomMarshaler
                    throw new ArgumentException(Environment.GetResourceString("Argument_NotACustomMarshaler"));
                }
                return m_guid; 
            }
    	}
    	/// <include file='doc\UnmanagedMarshal.uex' path='docs/doc[@for="UnmanagedMarshal.ElementCount"]/*' />
    	public int ElementCount 
		{
     		get 
			{ 
                if (m_unmanagedType != UnmanagedType.ByValArray &&
                    m_unmanagedType != UnmanagedType.ByValTStr) 
                {
                    // throw exception here. There is NumElement only if NativeTypeFixedArray
                    throw new ArgumentException(Environment.GetResourceString("Argument_NoUnmanagedElementCount"));
                }
                return m_numElem;
            } 
    	}
    	/// <include file='doc\UnmanagedMarshal.uex' path='docs/doc[@for="UnmanagedMarshal.BaseType"]/*' />
    	public UnmanagedType BaseType 
		{
     		get 
			{ 
                if (m_unmanagedType != UnmanagedType.LPArray && 
                    m_unmanagedType != UnmanagedType.SafeArray) 
                {
                    // throw exception here. There is NestedUnmanagedType only if LPArray or SafeArray
                    throw new ArgumentException(Environment.GetResourceString("Argument_NoNestedMarshal"));
                }
                return m_baseType;
            } 
    	}
    
        private UnmanagedMarshal(UnmanagedType unmanagedType, Guid guid, int numElem, UnmanagedType type)
        {
            m_unmanagedType = unmanagedType;
            m_guid = guid;
            m_numElem = numElem;
            m_baseType = type;
        }
    
        /************************
        *
        * Data member
        *
        *************************/
        internal UnmanagedType       m_unmanagedType;
        internal Guid                m_guid;
        internal int                 m_numElem;
        internal UnmanagedType       m_baseType;
    
    
        /************************
        * this function return the byte representation of the marshal info.
        *************************/
        internal byte[] InternalGetBytes()
        {
            byte[] buf;
            /*
            if (m_unmanagedType == UnmanagedType.NativeTypeInterface)
            {
    
                // syntax for NativeTypeInterface is 
                // <NativeTypeInterface> <16 bytes of guid>
                //
                byte[] guidBuf;
                int     cBuf;
                int     iBuf = 0;
    
                guidBuf = m_guid.ToByteArray();
                cBuf = 1 + guidBuf.Length;
                buf = new byte[cBuf];
                buf[iBuf++] = (byte) (m_unmanagedType);
                for (int i = 0; i < guidBuf.Length; i++)
                {
                    buf[iBuf++] = guidBuf[i];
                }   
                return buf;
            }
            */

            if (m_unmanagedType == UnmanagedType.SafeArray || m_unmanagedType == UnmanagedType.LPArray)
			{
    
                // syntax for NativeTypeSafeArray is 
                // <SafeArray | LPArray> <base type>
                //
                int     cBuf = 2;
                buf = new byte[cBuf];
                buf[0] = (byte) (m_unmanagedType);
                buf[1] = (byte) (m_baseType);
                return buf;
            }
            else
			if (m_unmanagedType == UnmanagedType.ByValArray || 
                    m_unmanagedType == UnmanagedType.ByValTStr) 
			{
                // <ByValArray | ByValTStr> <encoded integer>
                //
                int     cBuf;
                int     iBuf = 0;
    
                if (m_numElem <= 0x7f)
                    cBuf = 1;
                else if (m_numElem <= 0x3FFF)
                    cBuf = 2;
                else
                    cBuf = 4;
    
                // the total buffer size is the one byte + encoded integer size 
                cBuf = cBuf + 1;
                buf = new byte[cBuf];
    
                // @todo: how do we share the encoding with the one in SignatureHelper.cool
                buf[iBuf++] = (byte) (m_unmanagedType);
                if (m_numElem <= 0x7F) 
				{
                    buf[iBuf++] = (byte)(m_numElem & 0xFF);
                } else if (m_numElem <= 0x3FFF) 
				{
                    buf[iBuf++] = (byte)((m_numElem >> 8) | 0x80);
                    buf[iBuf++] = (byte)(m_numElem & 0xFF);
                } else if (m_numElem <= 0x1FFFFFFF) 
				{
                    buf[iBuf++] = (byte)((m_numElem >> 24) | 0xC0);
                    buf[iBuf++] = (byte)((m_numElem >> 16) & 0xFF);
                    buf[iBuf++] = (byte)((m_numElem >> 8)  & 0xFF);
                    buf[iBuf++] = (byte)((m_numElem)     & 0xFF);
                }            
                return buf;
            }
            buf = new byte[1];
            buf[0] = (byte) (m_unmanagedType);
            return buf;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\typefilter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// TypeFilter defines a delegate that is as a callback function for filtering
//	a list of Types.
//
// Author: darylo
// Date: March 98
//
namespace System.Reflection {
    
    // Define the delegate
    /// <include file='doc\TypeFilter.uex' path='docs/doc[@for="TypeFilter"]/*' />
	[Serializable()]
    public delegate bool TypeFilter(Type m, Object filterCriteria);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\cache\clearcacheeventargs.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: ClearCacheEventArgs
**
** Author: Jay Roxe
**
** Purpose: Empty eventargs used with the ClearCacheEvent
**
** Date: December 20, 2000
**
============================================================*/
namespace System.Reflection.Cache {
    [Serializable]
    internal class ClearCacheEventArgs : EventArgs {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\typedelegator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// TypeDelegator
// This class wraps a Type object and delegates all methods to that Type.

namespace System.Reflection {

    using System;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.InteropServices;
    using CultureInfo = System.Globalization.CultureInfo;

    /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator"]/*' />
	[Serializable()]
    public class TypeDelegator : Type
    {
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.typeImpl"]/*' />
        protected Type typeImpl;
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.TypeDelegator"]/*' />
        protected TypeDelegator() {}
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.TypeDelegator1"]/*' />
        public TypeDelegator(Type delegatingType) {
            if (delegatingType == null)
                throw new ArgumentNullException("delegatingType");
                
            typeImpl = delegatingType;
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GUID"]/*' />
        public override Guid GUID {
            get {return typeImpl.GUID;}
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.InvokeMember"]/*' />
        public override Object InvokeMember(String name,BindingFlags invokeAttr,Binder binder,Object target,
            Object[] args,ParameterModifier[] modifiers,CultureInfo culture,String[] namedParameters)
        {
            return typeImpl.InvokeMember(name,invokeAttr,binder,target,args,modifiers,culture,namedParameters);
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.Module"]/*' />
        public override Module Module {
                get {return typeImpl.Module;}
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.Assembly"]/*' />
        public override Assembly Assembly {
                get {return typeImpl.Assembly;}
        }

        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.TypeHandle"]/*' />
        public override RuntimeTypeHandle TypeHandle {
                get{return typeImpl.TypeHandle;}
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.Name"]/*' />
        public override String Name {
            get{return typeImpl.Name;}
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.FullName"]/*' />
        public override String FullName {
            get{return typeImpl.FullName;}
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.Namespace"]/*' />
        public override String Namespace {
            get{return typeImpl.Namespace;}
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.AssemblyQualifiedName"]/*' />
        public override String AssemblyQualifiedName {
            get { 
                return typeImpl.AssemblyQualifiedName;
            }
        }
            
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.BaseType"]/*' />
        public override Type BaseType {
            get{return typeImpl.BaseType;}
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetConstructorImpl"]/*' />
        protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr,Binder binder,
                CallingConventions callConvention, Type[] types,ParameterModifier[] modifiers)
        {
            return typeImpl.GetConstructor(bindingAttr,binder,callConvention,types,modifiers);
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetConstructors"]/*' />
        public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
        {
            return typeImpl.GetConstructors(bindingAttr);
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetMethodImpl"]/*' />
        protected override MethodInfo GetMethodImpl(String name,BindingFlags bindingAttr,Binder binder,
                CallingConventions callConvention, Type[] types,ParameterModifier[] modifiers)
        {
            // This is interesting there are two paths into the impl.  One that validates
            //  type as non-null and one where type may be null.
            if (types == null)
                return typeImpl.GetMethod(name,bindingAttr);
            else
                return typeImpl.GetMethod(name,bindingAttr,binder,callConvention,types,modifiers);
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetMethods"]/*' />
        public override MethodInfo[] GetMethods(BindingFlags bindingAttr)
        {
            return typeImpl.GetMethods(bindingAttr);
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetField"]/*' />
        public override FieldInfo GetField(String name, BindingFlags bindingAttr)
        {
            return typeImpl.GetField(name,bindingAttr);
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetFields"]/*' />
        public override FieldInfo[] GetFields(BindingFlags bindingAttr)
        {
            return typeImpl.GetFields(bindingAttr);
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetInterface"]/*' />
        public override Type GetInterface(String name, bool ignoreCase)
        {
            return typeImpl.GetInterface(name,ignoreCase);
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetInterfaces"]/*' />
        public override Type[] GetInterfaces()
        {
            return typeImpl.GetInterfaces();
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetEvent"]/*' />
        public override EventInfo GetEvent(String name,BindingFlags bindingAttr)
        {
            return typeImpl.GetEvent(name,bindingAttr);
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetEvents"]/*' />
        public override EventInfo[] GetEvents()
        {
            return typeImpl.GetEvents();
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetPropertyImpl"]/*' />
        protected override PropertyInfo GetPropertyImpl(String name,BindingFlags bindingAttr,Binder binder,
                        Type returnType, Type[] types, ParameterModifier[] modifiers)
        {
            if (returnType == null && types == null)
                return typeImpl.GetProperty(name,bindingAttr);
            else
                return typeImpl.GetProperty(name,bindingAttr,binder,returnType,types,modifiers);
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetProperties"]/*' />
        public override PropertyInfo[] GetProperties(BindingFlags bindingAttr)
        {
            return typeImpl.GetProperties(bindingAttr);
        }

        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetEvents1"]/*' />
        public override EventInfo[] GetEvents(BindingFlags bindingAttr)
		{
			return typeImpl.GetEvents(bindingAttr);
		}
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetNestedTypes"]/*' />
        public override Type[] GetNestedTypes(BindingFlags bindingAttr)
        {
            return typeImpl.GetNestedTypes(bindingAttr);
        }

        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetNestedType"]/*' />
        public override Type GetNestedType(String name, BindingFlags bindingAttr)
        {
            return typeImpl.GetNestedType(name,bindingAttr);
        }

        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetMember"]/*' />
        public override MemberInfo[] GetMember(String name,  MemberTypes type, BindingFlags bindingAttr)
        {
            return typeImpl.GetMember(name,type,bindingAttr);
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetMembers"]/*' />
        public override MemberInfo[] GetMembers(BindingFlags bindingAttr)
        {
            return typeImpl.GetMembers(bindingAttr);
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetAttributeFlagsImpl"]/*' />
        protected override TypeAttributes GetAttributeFlagsImpl()
        {
            return typeImpl.Attributes;
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.IsArrayImpl"]/*' />
        protected override bool IsArrayImpl()
        {
            return typeImpl.IsArray;
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.IsPrimitiveImpl"]/*' />
        protected override bool IsPrimitiveImpl()
        {
            return typeImpl.IsPrimitive;
        }

        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.IsByRefImpl"]/*' />
        protected override bool IsByRefImpl()
        {
            return typeImpl.IsByRef;
        }

        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.IsPointerImpl"]/*' />
        protected override bool IsPointerImpl()
        {
            return typeImpl.IsPointer;
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.IsValueTypeImpl"]/*' />
        protected override bool IsValueTypeImpl() 
        {
            return typeImpl.IsValueType;
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.IsCOMObjectImpl"]/*' />
        protected override bool IsCOMObjectImpl()
        {
            return typeImpl.IsCOMObject;
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetElementType"]/*' />
        public override Type GetElementType()
        {
            return typeImpl.GetElementType();
        }

        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.HasElementTypeImpl"]/*' />
        protected override bool HasElementTypeImpl()
        {
            return typeImpl.HasElementType;
        }
        
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.UnderlyingSystemType"]/*' />
        public override Type UnderlyingSystemType 
        {
            get {return typeImpl.UnderlyingSystemType;}
        }
        
        // ICustomAttributeProvider
        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetCustomAttributes"]/*' />
        public override Object[] GetCustomAttributes(bool inherit)
        {
            return typeImpl.GetCustomAttributes(inherit);
        }

        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetCustomAttributes1"]/*' />
        public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
            return typeImpl.GetCustomAttributes(attributeType, inherit);
        }

        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.IsDefined"]/*' />
        public override bool IsDefined(Type attributeType, bool inherit)
        {
            return typeImpl.IsDefined(attributeType, inherit);
        }

        /// <include file='doc\TypeDelegator.uex' path='docs/doc[@for="TypeDelegator.GetInterfaceMap"]/*' />
        public override InterfaceMapping GetInterfaceMap(Type interfaceType)
		{
            return typeImpl.GetInterfaceMap(interfaceType);
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\__filters.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// This class defines the delegate methods for the COM+ implemented filters.
//	This is the reflection version of these.  There is also a _Filters class in
//	runtime which is related to this.
//
// Author: darylo
// Date: July 98
//
namespace System.Reflection {
	using System;
        using System.Globalization;
    //@TODO: Use region matches...
    //Marked as serializable because it's constructable even though it has no
    //instance data.  If we make this static, remove the serializable bit.
	//@TODO: Mark as sealed and place a private constructor here.
	[Serializable()] 
    internal class __Filters {
    	
    	// FilterTypeName 
    	// This method will filter the class based upon the name.  It supports
    	//	a trailing wild card.
    	public virtual bool FilterTypeName(Type cls,Object filterCriteria)
    	{
    		// Check that the criteria object is a String object
    		if (filterCriteria == null || !(filterCriteria is String))
    			throw new InvalidFilterCriteriaException(System.Environment.GetResourceString("RFLCT.FltCritString"));
    
    		String str = (String) filterCriteria;
    		//str = str.Trim();
    
    		// Check to see if this is a prefix or exact match requirement
    		if (str.Length > 0 && str[str.Length - 1] == '*') {
    			str = str.Substring(0, str.Length - 1);
    			return cls.Name.StartsWith(str);
    		}
    
    		return cls.Name.Equals(str);
    	}
    	
    	// FilterFieldNameIgnoreCase
    	// This method filter the Type based upon name, it ignores case.
    	public virtual bool FilterTypeNameIgnoreCase(Type cls, Object filterCriteria)
    	{
    		// Check that the criteria object is a String object
    		if(filterCriteria == null || !(filterCriteria is String))
    			throw new InvalidFilterCriteriaException(System.Environment.GetResourceString("RFLCT.FltCritString"));
    
    		String str = (String) filterCriteria;
    		//str = str.Trim();
    
    		// Check to see if this is a prefix or exact match requirement
    		if (str.Length > 0 && str[str.Length - 1] == '*') {
    			str = str.Substring(0, str.Length - 1);
                            String name = cls.Name;
							if (name.Length >= str.Length)
								return (String.Compare(name,0,str,0,str.Length,true, CultureInfo.InvariantCulture)==0);
							else
								return false;
    		}
    		return (String.Compare(str,cls.Name, true, CultureInfo.InvariantCulture) == 0);
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\cache\internalcache.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: InternalCache
**
** Author: Jay Roxe
**
** Purpose: A high-performance internal caching class.  All key
** lookups are done on the basis of the CacheObjType enum.  The
** cache is limited to one object of any particular type per
** instance.
**
** Date: Dec 11, 2000
**
============================================================*/
using System;
using System.Threading;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.Remoting.Metadata;

namespace System.Reflection.Cache {

    [Serializable] 
	internal enum CacheAction {
        AllocateCache  = 1,
            AddItem    = 2,
            ClearCache = 3,
            LookupItemHit  = 4,
            LookupItemMiss = 5,
            GrowCache  = 6,
            SetItemReplace = 7,
            ReplaceFailed = 8
    }


    [Serializable] internal class InternalCache {
        private const int MinCacheSize = 2;

        //We'll start the cache as null and only grow it as we need it.
        private InternalCacheItem[] m_cache=null;
        private int m_numItems = 0;
        //        private bool m_copying = false;

        //Knowing the name of the cache is very useful for debugging, but we don't
        //want to take the working-set hit in the debug build.  We'll only include
        //the field in that build.
#if _LOGGING
        private String m_cacheName;
#endif

        internal InternalCache(String cacheName) {
#if _LOGGING
            m_cacheName = cacheName;
#endif
            //We won't allocate any items until the first time that they're requested.
        }

        internal Object this[CacheObjType cacheType] {
            get {

                //Let's snapshot a reference to the array up front so that
                //we don't have to worry about any writers.  It's important
                //to grab the cache first and then numItems.  In the event that
                //the cache gets cleared, m_numItems will be set to 0 before
                //we actually release the cache.  Getting it second will cause
                //us to walk only 0 elements, but not to fault.
                InternalCacheItem[] cache = m_cache;
                int numItems = m_numItems;

                int position = FindObjectPosition(cache, numItems, cacheType, false);
                if (position>=0) {
                    LogAction(CacheAction.LookupItemHit, cacheType, cache[position].Value);
                    return cache[position].Value;
                }

                //Couldn't find it -- oh, well.
                LogAction(CacheAction.LookupItemMiss, cacheType);
                return null;
            }
    
            set { 
                int position;

                LogAction(CacheAction.AddItem, cacheType, value);
                lock(this) {
                    position = FindObjectPosition(m_cache, m_numItems, cacheType, true);
                    if (position>0) {
                        m_cache[position].Value = value;
                        m_cache[position].Key = cacheType;
                        if (position==m_numItems) {
                            m_numItems++;
                        }
                        return;
                    }

                    if (m_cache==null) {
                        LogAction(CacheAction.AllocateCache, cacheType);
                        //                        m_copying = true;
                        m_cache = new InternalCacheItem[MinCacheSize];
                        m_cache[0].Value = value;
                        m_cache[0].Key = cacheType;
                        m_numItems = 1;
                        //                        m_copying = false;
                    } else {
                        LogAction(CacheAction.GrowCache, cacheType);

                        //                        m_copying = true;
                        InternalCacheItem[] tempCache = new InternalCacheItem[m_numItems * 2];
                        for (int i=0; i<m_numItems; i++) {
                            tempCache[i] = m_cache[i];
                        }
                        tempCache[m_numItems].Value = value;
                        tempCache[m_numItems].Key = cacheType;
                        m_cache = tempCache;
                        m_numItems++;
                        //                        m_copying = false;
                    }
                }
            }
        }
         
        internal void OnCacheClear(Object sender, ClearCacheEventArgs cacheEventArgs) {
            LogAction(CacheAction.ClearCache, CacheObjType.EmptyElement); 
            //NB: The order of these operations is important to maintaining
            //a no-read-lock-required operation.  We need to take a lock in case there is 
            //a thread in the insert code at the time that we update this.
            lock (this) {
                m_numItems = 0;
                m_cache = null;
            }
        }
        
        private int FindObjectPosition(InternalCacheItem[] cache, int itemCount, CacheObjType cacheType, bool findEmpty) {
            if (cache==null) {
                return -1;
            }

            //This helps us in the case where we grabbed the cache and then
            //somebody added an item, forced a reallocation, and hence made
            //itemCount greater than the length of cache.
            if (itemCount > cache.Length) {
                itemCount = cache.Length;
            }
            
            for (int i=0; i<itemCount; i++) {
                if (cacheType==cache[i].Key) {
                    return i;
                }
            }
            if (findEmpty) {
                if (itemCount<(cache.Length-1)) {
                    return itemCount + 1;
                }
            }
            return -1;
        }

        //This is a debugging-only function which verifies that the object is of the
        //the correct type and follows some arbitrary set of constraints.  Please
        //add any validation code which you require to the switch statement below.
        //
        //Note to Testing: These are not localized strings because this error checking
        //occurs only in the debug build and I don't want to push extra resources
        //into the build which are not going to be used for customers.
        [Conditional("_DEBUG")] private void OnValidate(InternalCacheItem item) {
            switch (item.Key) {
            case CacheObjType.ParameterInfo:
                if (!(item.Value is System.Reflection.ParameterInfo)) {
                    throw new ArgumentException("Invalid type for the internal cache.  " + item.Value + " requires a ParameterInfo");
                }
                break;
            case CacheObjType.TypeName:
                if (!(item.Value is String)) {
                    throw new ArgumentException("Invalid type for the internal cache.  " + item.Value + " requires a non-null String");
                }
                break;
            case CacheObjType.AssemblyName:
                if (!(item.Value is String)) {
                    throw new ArgumentException("Invalid type for the internal cache.  " + item.Value + " requires a non-null String");
                }
                break;
            case CacheObjType.RemotingData:
                if (!(item.Value is RemotingCachedData)) {
                    throw new ArgumentException("Invalid type for the internal cache.  " + item.Value + " requires a RemotingCacheData");
                }
                break;
            case CacheObjType.SerializableAttribute:
                if (!(item.Value is SerializableAttribute)) {
                    throw new ArgumentException("Invalid type for the internal cache.  " + item.Value + " requires a SerializableAttribute");
                }
                break;
            case CacheObjType.FieldName:
                if (!(item.Value is String)) {
                    throw new ArgumentException("Invalid type for the internal cache.  " + item.Value + " requires a non-null String");
                }
                break;
            case CacheObjType.FieldType:
                if (!(item.Value is Type)) {
                    throw new ArgumentException("Invalid type for the internal cache.  " + item.Value + " requires a non-null Type");
                }
                break;
            case CacheObjType.DefaultMember:
                if (!(item.Value is String)) {
                    throw new ArgumentException("Invalid type for the internal cache.  " + item.Value + " requires a non-null String");
                }
                break;
            default:
                throw new ArgumentException("Invalid caching type.  Please add " + item.Value + " to the validated types in InternalCache.");
            }
        }
    
        //Debugging method to log whatever action was taken in the cache.  This will
        //include lookups, adding after cache misses, and times when we clear the
        //cache.
        [Conditional("_LOGGING")] private void LogAction(CacheAction action, CacheObjType cacheType) {
#if _LOGGING
            BCLDebug.Trace("CACHE", "Took action ", action, " in cache named ", m_cacheName, " on object ", cacheType, " on thread ", 
                           Thread.CurrentThread.GetHashCode());
#endif
        }

        //Debugging method to log whatever action was taken in the cache.  This will
        //include lookups, adding after cache misses, and times when we clear the
        //cache.
        [Conditional("_LOGGING")] private void LogAction(CacheAction action, CacheObjType cacheType, Object obj) {
#if _LOGGING
            BCLDebug.Trace("CACHE", "Took action ", action, " in cache named ", m_cacheName, " on object ", cacheType, " on thread ", 
                           Thread.CurrentThread.GetHashCode(), " Object was ", obj);

            if (action == CacheAction.AddItem) {
                BCLDebug.DumpStack("CACHE");
            }
#endif
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\cache\internalcacheitem.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: InternalCacheItem.cs
**
** Author: Jay Roxe
**
** Purpose: Enum/Value pair used with the internal cache
**
** Date: December 20, 2000
**
============================================================*/
namespace System.Reflection.Cache {
    [Serializable]internal struct InternalCacheItem {
        internal CacheObjType Key;
        internal Object       Value;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\cache\typenamestruct.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: TypeNameStruct
**
** Author: Jay Roxe
**
** Purpose: 
**
** Date: Feb 23, 2001
**
============================================================*/
namespace System.Reflection.Cache {

    internal struct TypeNameStruct {
        internal int HashKey;
        internal String TypeName;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\assemblybuilderaccess.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Reflection.Emit {
    
	using System;
    // This enumeration defines the access modes for a dynamic assembly.
    // EE uses these enum values..look for m_dwDynamicAssemblyAccess in Assembly.hpp
    /// <include file='doc\AssemblyBuilderAccess.uex' path='docs/doc[@for="AssemblyBuilderAccess"]/*' />
	[Flags, Serializable]
    public enum AssemblyBuilderAccess
    {
    	/// <include file='doc\AssemblyBuilderAccess.uex' path='docs/doc[@for="AssemblyBuilderAccess.Run"]/*' />
    	Run = 1,
    	/// <include file='doc\AssemblyBuilderAccess.uex' path='docs/doc[@for="AssemblyBuilderAccess.Save"]/*' />
    	Save = 2,
    	/// <include file='doc\AssemblyBuilderAccess.uex' path='docs/doc[@for="AssemblyBuilderAccess.RunAndSave"]/*' />
    	RunAndSave = Run | Save,
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\cache\typenamecache.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: TypeNameCache
**
** Author: Jay Roxe
**
** Purpose: Highly performant caching for type names.
**
** Date: Feb 23, 2001
**
============================================================*/
namespace System.Reflection.Cache {

    using System;
    using System.Reflection;

    internal class TypeNameCache {
        private static TypeNameCache m_cache = null;

        private TypeNameStruct[] m_data;

        internal static int CacheSize = 919;

        internal TypeNameCache() {
            BCLDebug.Trace("CACHE", "[TypeNameCache.ctor]Allocating a TypeName Cache with ", CacheSize, " elements.");
            m_data = new TypeNameStruct[CacheSize];
        }

        internal static int CalculateHash(int hashKey) {
            //We know that the bottom two bits of a 32-bit pointer are going to be zero, so
            //let's not include them in the value that we hash.
            return (int)((((uint)hashKey)>>2)%CacheSize);
        }

        internal String GetTypeName(int hashKey) {
            int iPos = CalculateHash(hashKey);
            BCLDebug.Assert(iPos<CacheSize, "[TypeNameCache]iPos<CacheSize");
            BCLDebug.Assert(hashKey!=0, "[TypeNameCache]hashKey!=0");

            TypeNameStruct t;
            t.HashKey = m_data[iPos].HashKey;
            t.TypeName = m_data[iPos].TypeName;

            if (t.HashKey==hashKey && m_data[iPos].HashKey==t.HashKey) {
                BCLDebug.Trace("CACHE", "[TypeNameCache.GetTypeName]Hit. Hash key: ", hashKey, 
                               ". Value: ", t.TypeName);
                return t.TypeName;
            }
            BCLDebug.Trace("CACHE", "[TypeNameCache.GetTypeName]Miss. Hash key: ", hashKey);
            return null;
        }

        internal void AddValue(int hashKey, String typeName) {
            int iPos = CalculateHash(hashKey);
            BCLDebug.Assert(iPos<CacheSize, "[TypeNameCache]iPos<CacheSize");
            
            lock(typeof(TypeNameCache)) {
                m_data[iPos].HashKey = 0x0;       //Invalidate the bucket.
                m_data[iPos].TypeName = typeName; //Set the type name.
                m_data[iPos].HashKey = hashKey;   //Revalidate the bucket.
            }

            BCLDebug.Trace("CACHE", "[TypeNameCache.AddValue]Added Item.  Hash key: ", hashKey, " Value: ", typeName);
        }

        internal static TypeNameCache GetCache() {
            if (m_cache==null) {
                lock (typeof(TypeNameCache)) {
                    if (m_cache==null) {
                        m_cache = new TypeNameCache();
                    }
                }
            }
            return m_cache;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\constructorbuilder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  ConstructorBuilder
**
** Author: meichint
**
** ConstructorBuilder is the class used to construct instance Constructor and Type Constructor
**
** Date:  Oct 99
** 
===========================================================*/

namespace System.Reflection.Emit {    
    using System;
    using System.Reflection;
    using CultureInfo = System.Globalization.CultureInfo;
    using System.Diagnostics.SymbolStore;
    using System.Security;
    using System.Security.Permissions;
    
    /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder"]/*' />
    public sealed class ConstructorBuilder : ConstructorInfo
    { 
        
        /**********************************************
         * Return the Token for this constructor method within the TypeBuilder that the
         * method is defined within.
         * @return the token of this method.
        **********************************************/
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.GetToken"]/*' />
        public MethodToken GetToken()
        {
            return m_methodBuilder.GetToken();
        }
    
        /*******************
        *
        * This is setting the parameter information
        *
        ********************/
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.DefineParameter"]/*' />
        public ParameterBuilder DefineParameter(
            int         iSequence, 
            ParameterAttributes attributes, 
            String      strParamName)           // can be NULL string
        {
            return m_methodBuilder.DefineParameter(iSequence, attributes, strParamName);
        }
    
    
    
        /*******************
        *
        * This is different from CustomAttribute. This is stored into the SymWriter.
        *
        ********************/
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.SetSymCustomAttribute"]/*' />
        public void SetSymCustomAttribute(
            String      name,           // SymCustomAttribute's name
            byte[]     data)           // the data blob
        {
            m_methodBuilder.SetSymCustomAttribute(name, data);
        }
    
        /**********************************************
         * Get the implementation flags for method
        **********************************************/
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.GetILGenerator"]/*' />
        public ILGenerator GetILGenerator() 
        {
            if (!m_ReturnILGen)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_DefaultConstructorILGen"));
            return m_methodBuilder.GetILGenerator();
        }
        
        // Add declarative security to the constructor.
        //
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.AddDeclarativeSecurity"]/*' />
        public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset)
        {
            if ((action < SecurityAction.Demand) || (action > SecurityAction.InheritanceDemand))
            throw new ArgumentOutOfRangeException("action");
    
            if (pset == null)
                throw new ArgumentNullException("pset");
    
            // Cannot add declarative security after type is created.
            if (m_methodBuilder.IsTypeCreated())
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_TypeHasBeenCreated"));
    
            // Translate permission set into serialized format (use standard binary serialization).
            byte[] blob = pset.EncodeXml();
    
            // Write the blob into the metadata.
            TypeBuilder.InternalAddDeclarativeSecurity(GetModule(), GetToken().Token, action, blob);
        }
    
        /**********************************************
         * Generates a debug printout of the name, attributes and 
         * exceptions in this method followed by the current IL Stream.
         * This will eventually be wired into the disassembler to be more
         * useful in debugging.  The current implementation requires that
         * the bytes on the stream be debugged by hand.
        **********************************************/
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.ToString"]/*' />
        public override String ToString() 
        {
            return m_methodBuilder.ToString();
        }
    
    
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.GetModule"]/*' />
        public Module GetModule()
        {
            return m_methodBuilder.GetModule();
        }
    
        /**********************************************
         * 
         * Abstract methods inherited from the base class
         * 
         **********************************************/
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.ReturnType"]/*' />
        public Type ReturnType 
        {
            get { return m_methodBuilder.ReturnType; }
        }
                               
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.Invoke"]/*' />
        public override Object Invoke(BindingFlags invokeAttr,Binder binder, Object[] parameters,CultureInfo culture)
        {
            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule")); 
        }
    
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.Invoke1"]/*' />
        public override Object Invoke(Object obj,BindingFlags invokeAttr,Binder binder, Object[] parameters, CultureInfo culture) 
        {
            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule")); 
        }

        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.Signature"]/*' />
        public  String Signature 
        {
            get {return m_methodBuilder.Signature;}
        }
    
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.GetParameters"]/*' />
        public override ParameterInfo[] GetParameters()
        {
            if (!m_methodBuilder.m_bIsBaked)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_TypeNotCreated"));

            Type rti = m_methodBuilder.GetTypeBuilder().m_runtimeType;
            ConstructorInfo rci = rti.GetConstructor(m_methodBuilder.m_parameterTypes);

            return rci.GetParameters();
        }
                    
        internal Type[] GetParameterTypes()
        {
            return m_methodBuilder.GetParameterTypes();
        }

        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.Attributes"]/*' />
        public override MethodAttributes Attributes {
            get {return m_methodBuilder.Attributes;}
        }

        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.GetCustomAttributes"]/*' />
        public override Object[] GetCustomAttributes(bool inherit)
        {
            return m_methodBuilder.GetCustomAttributes(inherit);
        }

        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.GetMethodImplementationFlags"]/*' />
        public override MethodImplAttributes GetMethodImplementationFlags()
        {
            return m_methodBuilder.GetMethodImplementationFlags();
        }
        
        // ICustomAttributeProvider
        // Return a custom attribute identified by Type
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.GetCustomAttributes1"]/*' />
        public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
            return m_methodBuilder.GetCustomAttributes(attributeType, inherit);
        }
        
       // Use this function if client decides to form the custom attribute blob themselves
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.SetCustomAttribute"]/*' />
        public void SetCustomAttribute(ConstructorInfo con,byte[] binaryAttribute)
        {
            m_methodBuilder.SetCustomAttribute(con, binaryAttribute);
        }

       // Use this function if client wishes to build CustomAttribute using CustomAttributeBuilder
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.SetCustomAttribute1"]/*' />
        public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
        {
            m_methodBuilder.SetCustomAttribute(customBuilder);
        }

        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.IsDefined"]/*' />
        public override bool IsDefined (Type attributeType, bool inherit)
        {
            return m_methodBuilder.IsDefined(attributeType, inherit);
        }

        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.SetImplementationFlags"]/*' />
        public void SetImplementationFlags(MethodImplAttributes attributes) {
            m_methodBuilder.SetImplementationFlags(attributes);
        }
                
        
        // Property representing the class that was used in reflection to obtain
        // this Member.
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.ReflectedType"]/*' />
        public override Type ReflectedType 
        {
            get {return m_methodBuilder.ReflectedType;}
        }

        // Return the Type that declared this Method.
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.DeclaringType"]/*' />
        public override Type DeclaringType {
        get {return m_methodBuilder.DeclaringType;}
        }
   
        // Property is set to true if user wishes to have zero initialized stack frame for this constructory. Default to false.
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.InitLocals"]/*' />
        public bool InitLocals {
            get {return m_methodBuilder.InitLocals;}
            set {m_methodBuilder.InitLocals = value;}
        }

        /**********************************************
         * 
         * Private methods
         * 
         **********************************************/
    
        /**********************************************
         * Make a private constructor so these cannot be constructed externally.
         * @internonly
         **********************************************/
        private ConstructorBuilder() {}
        
        /**********************************************
         * Constructs a ConstructorBuilder.  
         * @internalonly
        **********************************************/
        internal ConstructorBuilder(
            String              name, 
            MethodAttributes    attributes, 
            CallingConventions  callingConvention,
            Type[]              parameterTypes, 
            Module              mod, 
            TypeBuilder         type) 
        {
            int         sigLength;
            byte[]     sigBytes;
            MethodToken token;

            m_methodBuilder = new MethodBuilder(name, attributes, callingConvention, null, parameterTypes, mod, type, false);
            type.m_listMethods.Add(m_methodBuilder);
            
            sigBytes = m_methodBuilder.GetMethodSignature().InternalGetSignature(out sigLength);
    
            token = TypeBuilder.InternalDefineMethod(type.TypeToken,
                                                     name, 
                                                     sigBytes, 
                                                     sigLength, 
                                                     attributes, 
                                                     mod);
            m_ReturnILGen = true;
            m_methodBuilder.SetToken(token);     
        }

        
        /**********************************************
         * Returns the name of this Method.
         * @return The name of this method class.
        **********************************************/
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.Name"]/*' />
        public override String Name {
            get { return m_methodBuilder.Name; }
        }

        // Method Handle routines
        /// <include file='doc\ConstructorBuilder.uex' path='docs/doc[@for="ConstructorBuilder.MethodHandle"]/*' />
        public override RuntimeMethodHandle MethodHandle {
            get { return m_methodBuilder.MethodHandle;}
        }
        
        /**********************************************
         * 
         * Private variables
         * 
         **********************************************/
    
        internal MethodBuilder       m_methodBuilder;
        internal bool                m_ReturnILGen;
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\assemblybuilderdata.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

namespace System.Reflection.Emit {
    using System;
    using IList = System.Collections.IList;
    using ArrayList = System.Collections.ArrayList;
    using System.Reflection;
    using System.Security;
    using System.Diagnostics;
    using CultureInfo = System.Globalization.CultureInfo;
    using ResourceWriter = System.Resources.ResourceWriter;
    using MemoryStream = System.IO.MemoryStream;
    
    // This is a package private class. This class hold all of the managed
    // data member for AssemblyBuilder. Note that what ever data members added to
    // this class cannot be accessed from the EE.
    internal class AssemblyBuilderData
    {
        internal AssemblyBuilderData(
            Assembly            assembly, 
            String              strAssemblyName, 
            AssemblyBuilderAccess access,
            String              dir)
        {
            m_assembly = assembly;
            m_strAssemblyName = strAssemblyName;
            m_access = access;
            m_moduleBuilderList = new ArrayList();
            m_resWriterList = new ArrayList();
            m_publicComTypeList = null;
            m_CABuilders = null;
            m_CABytes = null;
            m_CACons = null;
            m_iPublicComTypeCount = 0;    
            m_iCABuilder = 0;
            m_iCAs = 0;
            m_entryPointModule = null;
            m_isSaved = false;
            if (dir == null && access != AssemblyBuilderAccess.Run)
                m_strDir = Environment.CurrentDirectory;
            else
                m_strDir = dir;
            m_RequiredPset = null;
            m_OptionalPset = null;
            m_RefusedPset = null;
            m_isSynchronized = false;
            m_hasUnmanagedVersionInfo = false;
            m_OverrideUnmanagedVersionInfo = false;

            m_InMemoryAssemblyModule = null;
            m_OnDiskAssemblyModule = null;
            m_peFileKind = PEFileKinds.Dll;

            m_strResourceFileName = null;
            m_resourceBytes = null;
            m_nativeVersion = null;
            m_entryPointMethod = null;
            m_ISymWrapperAssembly = null;
         }
    
        // Helper to add a dynamic module into the tracking list
        internal void AddModule(ModuleBuilder dynModule)
        {
            m_moduleBuilderList.Add(dynModule);

            if(m_assembly != null) 
                // also add the Module into the file list in the Assembly.
                m_assembly.nAddFileToInMemoryFileList(dynModule.m_moduleData.m_strFileName, dynModule);
        }
    
        // Helper to add a resource information into the tracking list
        internal void AddResWriter(ResWriterData resData)
        {
            m_resWriterList.Add(resData);
        }


        // Helper to track CAs to persist onto disk
        internal void AddCustomAttribute(CustomAttributeBuilder customBuilder)
        {

            // make sure we have room for this CA
            if (m_CABuilders == null)
            {
                m_CABuilders = new CustomAttributeBuilder[m_iInitialSize];
            }
            if (m_iCABuilder == m_CABuilders.Length)
            {
                CustomAttributeBuilder[]  tempCABuilders = new CustomAttributeBuilder[m_iCABuilder * 2];
                Array.Copy(m_CABuilders, tempCABuilders, m_iCABuilder);
                m_CABuilders = tempCABuilders;            
            }
            m_CABuilders[m_iCABuilder] = customBuilder;
            
            m_iCABuilder++;
        }

        // Helper to track CAs to persist onto disk
        internal void AddCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)
        {

            // make sure we have room for this CA
            if (m_CABytes == null)
            {
                m_CABytes = new byte[m_iInitialSize][];
                m_CACons = new ConstructorInfo[m_iInitialSize];                
            }
            if (m_iCAs == m_CABytes.Length)
            {
                // enlarge the arrays
                byte[][]  temp = new byte[m_iCAs * 2][];
                ConstructorInfo[] tempCon = new ConstructorInfo[m_iCAs * 2];
                for (int i=0; i < m_iCAs; i++)
                {
                    temp[i] = m_CABytes[i];
                    tempCon[i] = m_CACons[i];
                }
                m_CABytes = temp;
                m_CACons = tempCon;
            }

            byte[] attrs = new byte[binaryAttribute.Length];
            Array.Copy(binaryAttribute, attrs, binaryAttribute.Length);
            m_CABytes[m_iCAs] = attrs;
            m_CACons[m_iCAs] = con;
            m_iCAs++;
        }
        
        // Helper to calculate unmanaged version info from Assembly's custom attributes.
        // If DefineUnmanagedVersionInfo is called, the parameter provided will override
        // the CA's value.
        //                      
        internal void FillUnmanagedVersionInfo()
        {
            // Get the lcid set on the assembly name as default if available
            // Note that if LCID is not avaible from neither AssemblyName or AssemblyCultureAttribute,
            // it is default to -1 which is treated as language neutral. 
            //
            CultureInfo locale = m_assembly.GetLocale();
            if (locale != null)
                m_nativeVersion.m_lcid = locale.LCID;
                                                    
            for (int i = 0; i < m_iCABuilder; i++)
            {
                // check for known attributes
                Type conType = m_CABuilders[i].m_con.DeclaringType;
                if (m_CABuilders[i].m_constructorArgs.Length == 0 || m_CABuilders[i].m_constructorArgs[0] == null)
                    continue;

                if (conType.Equals(typeof(System.Reflection.AssemblyCopyrightAttribute)))
                {
                        // assert that we should only have one argument for this CA and the type should
                        // be a string.
                        // 
                    if (m_CABuilders[i].m_constructorArgs.Length != 1)
                    {
                        throw new ArgumentException(String.Format(Environment.GetResourceString(
                            "Argument_BadCAForUnmngRSC"),
                            m_CABuilders[i].m_con.ReflectedType.Name));
                    }
                    if (m_OverrideUnmanagedVersionInfo == false)
                    {
                        m_nativeVersion.m_strCopyright = m_CABuilders[i].m_constructorArgs[0].ToString();
                    }
                }
                else if (conType.Equals(typeof(System.Reflection.AssemblyTrademarkAttribute))) 
                {
                        // assert that we should only have one argument for this CA and the type should
                        // be a string.
                        // 
                    if (m_CABuilders[i].m_constructorArgs.Length != 1)
                    {
                        throw new ArgumentException(String.Format(Environment.GetResourceString(
                            "Argument_BadCAForUnmngRSC"),
                            m_CABuilders[i].m_con.ReflectedType.Name));
                    }
                    if (m_OverrideUnmanagedVersionInfo == false)
                    {
                        m_nativeVersion.m_strTrademark = m_CABuilders[i].m_constructorArgs[0].ToString();
                    }
                }
                else if (conType.Equals(typeof(System.Reflection.AssemblyProductAttribute))) 
                {
                    if (m_OverrideUnmanagedVersionInfo == false)
                    {
                        // assert that we should only have one argument for this CA and the type should
                        // be a string.
                        // 
                        m_nativeVersion.m_strProduct = m_CABuilders[i].m_constructorArgs[0].ToString();
                    }
                }
                else if (conType.Equals(typeof(System.Reflection.AssemblyCompanyAttribute))) 
                {
                    if (m_CABuilders[i].m_constructorArgs.Length != 1)
                    {
                        throw new ArgumentException(String.Format(Environment.GetResourceString(
                            "Argument_BadCAForUnmngRSC"),
                            m_CABuilders[i].m_con.ReflectedType.Name));
                    }
                    if (m_OverrideUnmanagedVersionInfo == false)
                    {
                        // assert that we should only have one argument for this CA and the type should
                        // be a string.
                        // 
                        m_nativeVersion.m_strCompany = m_CABuilders[i].m_constructorArgs[0].ToString();
                    }
                }
                else if (conType.Equals(typeof(System.Reflection.AssemblyDescriptionAttribute))) 
                {
                    if (m_CABuilders[i].m_constructorArgs.Length != 1)
                    {
                        throw new ArgumentException(String.Format(Environment.GetResourceString(
                            "Argument_BadCAForUnmngRSC"),
                            m_CABuilders[i].m_con.ReflectedType.Name));
                    }
                    m_nativeVersion.m_strDescription = m_CABuilders[i].m_constructorArgs[0].ToString();
                }
                else if (conType.Equals(typeof(System.Reflection.AssemblyTitleAttribute))) 
                {
                    if (m_CABuilders[i].m_constructorArgs.Length != 1)
                    {
                        throw new ArgumentException(String.Format(Environment.GetResourceString(
                            "Argument_BadCAForUnmngRSC"),
                            m_CABuilders[i].m_con.ReflectedType.Name));
                    }
                    m_nativeVersion.m_strTitle = m_CABuilders[i].m_constructorArgs[0].ToString();
                }
                else if (conType.Equals(typeof(System.Reflection.AssemblyInformationalVersionAttribute))) 
                {
                    if (m_CABuilders[i].m_constructorArgs.Length != 1)
                    {
                        throw new ArgumentException(String.Format(Environment.GetResourceString(
                            "Argument_BadCAForUnmngRSC"),
                            m_CABuilders[i].m_con.ReflectedType.Name));
                    }
                    if (m_OverrideUnmanagedVersionInfo == false)
                    {
                        m_nativeVersion.m_strProductVersion = m_CABuilders[i].m_constructorArgs[0].ToString();
                    }
                }
                else if (conType.Equals(typeof(System.Reflection.AssemblyCultureAttribute))) 
                {
                    // retrieve the LCID
                    if (m_CABuilders[i].m_constructorArgs.Length != 1)
                    {
                        throw new ArgumentException(String.Format(Environment.GetResourceString(
                            "Argument_BadCAForUnmngRSC"),
                            m_CABuilders[i].m_con.ReflectedType.Name));
                    }
                    // CultureInfo attribute overrides the lcid from AssemblyName.                                      
                    CultureInfo culture = new CultureInfo(m_CABuilders[i].m_constructorArgs[0].ToString());
                    m_nativeVersion.m_lcid = culture.LCID;
                }
                else if (conType.Equals(typeof(System.Reflection.AssemblyFileVersionAttribute))) 
                {
                    if (m_CABuilders[i].m_constructorArgs.Length != 1)
                    {
                        throw new ArgumentException(String.Format(Environment.GetResourceString(
                            "Argument_BadCAForUnmngRSC"),
                            m_CABuilders[i].m_con.ReflectedType.Name));
                    }
                    if (m_OverrideUnmanagedVersionInfo == false)
                    {
                        m_nativeVersion.m_strFileVersion = m_CABuilders[i].m_constructorArgs[0].ToString();
                    }
                }
            }
        }
        
        // Helper to ensure the resource name is unique underneath assemblyBuilder
        internal void CheckResNameConflict(String strNewResName)
        {
            int         size = m_resWriterList.Count;
            int         i;
            for (i = 0; i < size; i++) 
            {
                ResWriterData resWriter = (ResWriterData) m_resWriterList[i];
                if (resWriter.m_strName.Equals(strNewResName))
                {
                    // Cannot have two resources with the same name
                    throw new ArgumentException(Environment.GetResourceString("Argument_DuplicateResourceName"));
                }
            }        
        }

    
        // Helper to ensure the module name is unique underneath assemblyBuilder
        internal void CheckNameConflict(String strNewModuleName)
        {
            int         size = m_moduleBuilderList.Count;
            int         i;
            for (i = 0; i < size; i++) 
            {
                ModuleBuilder moduleBuilder = (ModuleBuilder) m_moduleBuilderList[i];
                if (moduleBuilder.m_moduleData.m_strModuleName.Equals(strNewModuleName))
                {
                    // Cannot have two dynamic modules with the same name
                    throw new ArgumentException(Environment.GetResourceString("Argument_DuplicateModuleName"));
                }
            }
            // Also check to see if there is any loaded module with the same name.
            // This is to take care of the case where a Dynamic module might be
            // added to a static assembly.
            if (!(m_assembly is AssemblyBuilder))
            {
                if (m_assembly.GetModule(strNewModuleName) != null)
                {
                    // Cannot have two dynamic modules with the same name
                    throw new ArgumentException(Environment.GetResourceString("Argument_DuplicateModuleName"));
                }
            }
        }
    
        // Helper to ensure the type name is unique underneath assemblyBuilder
        internal void CheckTypeNameConflict(String strTypeName, TypeBuilder enclosingType)
        {
            BCLDebug.Log("DYNIL","## DYNIL LOGGING: AssemblyBuilderData.CheckTypeNameConflict( " + strTypeName + " )"); 
            for (int i = 0; i < m_moduleBuilderList.Count; i++) 
            {
                ModuleBuilder curModule = (ModuleBuilder)m_moduleBuilderList[i];
                for (int j = 0; j < curModule.m_TypeBuilderList.Count; j++)
                {
                    Type curType = (Type)curModule.m_TypeBuilderList[j];
                    if (curType.FullName.Equals(strTypeName) && curType.DeclaringType == enclosingType)
                    {
                        // Cannot have two types with the same name
                        throw new ArgumentException(Environment.GetResourceString("Argument_DuplicateTypeName"));
                    }
                }
            }

            // Also check to see if there is any loaded type with the same name.
            // You only need to make this test for non-nested types since any
            // duplicates in nested types will be caught at the top level.
            if ((enclosingType == null) && !(m_assembly is AssemblyBuilder))
            {
                if (m_assembly.GetTypeInternal(strTypeName, false, false, false) != null)
                {
                    // Cannot have two types with the same name
                    throw new ArgumentException(Environment.GetResourceString("Argument_DuplicateTypeName"));
                }
            }
        }
        

        // Helper to ensure the file name is unique underneath assemblyBuilder. This includes 
        // modules and resources.
        // @todo:  At this time, this function will do a case insensitive comparision of the
        // filename, but if and when some IO function becomes available that'll do filename
        // comparsion in a platform agnostic manner, we'll need to start using that.
        internal void CheckFileNameConflict(String strFileName)
        {
            int         size = m_moduleBuilderList.Count;
            int         i;
            for (i = 0; i < size; i++) 
            {
                ModuleBuilder moduleBuilder = (ModuleBuilder) m_moduleBuilderList[i];
                if (moduleBuilder.m_moduleData.m_strFileName != null)
                {
                    if (String.Compare(moduleBuilder.m_moduleData.m_strFileName, strFileName, true, CultureInfo.InvariantCulture) == 0)
                    {
                        // Cannot have two dynamic module with the same name
                        throw new ArgumentException(Environment.GetResourceString("Argument_DuplicatedFileName"));
                    }
                }
            }    
            size = m_resWriterList.Count;
            for (i = 0; i < size; i++) 
            {
                ResWriterData resWriter = (ResWriterData) m_resWriterList[i];
                if (resWriter.m_strFileName != null)
                {
                    if (String.Compare(resWriter.m_strFileName, strFileName, true, CultureInfo.InvariantCulture) == 0)
                    {
                        // Cannot have two dynamic module with the same name
                        throw new ArgumentException(Environment.GetResourceString("Argument_DuplicatedFileName"));
                    }
                }
            }    

        }
    
        // Helper to look up which module that assembly is supposed to be stored at
        // @todo:  At this time, this function will do a case insensitive comparision of the
        // filename, but if and when some IO function becomes available that'll do filename
        // comparsion in a platform agnostic manner, we'll need to start using that.
        internal ModuleBuilder FindModuleWithFileName(String strFileName)
        {
            int         size = m_moduleBuilderList.Count;
            int         i;
            for (i = 0; i < size; i++) 
            {
                ModuleBuilder moduleBuilder = (ModuleBuilder) m_moduleBuilderList[i];
                if (moduleBuilder.m_moduleData.m_strFileName != null)
                {
                    if (String.Compare(moduleBuilder.m_moduleData.m_strFileName, strFileName, true, CultureInfo.InvariantCulture) == 0)
                    {
                        return moduleBuilder;
                    }
                }
            } 
            return null;       
        }

        // Helper to look up module by name.
        // @todo:  At this time, this function will do a case insensitive comparision of the
        // filename, but if and when some IO function becomes available that'll do filename
        // comparsion in a platform agnostic manner, we'll need to start using that.
        internal ModuleBuilder FindModuleWithName(String strName)
        {
            int         size = m_moduleBuilderList.Count;
            int         i;
            for (i = 0; i < size; i++) 
            {
                ModuleBuilder moduleBuilder = (ModuleBuilder) m_moduleBuilderList[i];
                if (moduleBuilder.m_moduleData.m_strModuleName != null)
                {
                    if (String.Compare(moduleBuilder.m_moduleData.m_strModuleName, strName, true, CultureInfo.InvariantCulture) == 0)
                        return moduleBuilder;
                }
            } 
            return null;       
        }

        
        // add type to public COMType tracking list
        internal void AddPublicComType(Type type)
        {
            BCLDebug.Log("DYNIL","## DYNIL LOGGING: AssemblyBuilderData.AddPublicComType( " + type.FullName + " )"); 
            if (m_isSaved == true)
            {
                // assembly has been saved before!
                throw new InvalidOperationException(Environment.GetResourceString(
                    "InvalidOperation_CannotAlterAssembly"));
            }        
            EnsurePublicComTypeCapacity();
            m_publicComTypeList[m_iPublicComTypeCount] = type;
            m_iPublicComTypeCount++;
        }
        
        // add security permission requests
        internal void AddPermissionRequests(
            PermissionSet       required,
            PermissionSet       optional,
            PermissionSet       refused)
        {
            BCLDebug.Log("DYNIL","## DYNIL LOGGING: AssemblyBuilderData.AddPermissionRequests");
            if (m_isSaved == true)
            {
                // assembly has been saved before!
                throw new InvalidOperationException(Environment.GetResourceString(
                    "InvalidOperation_CannotAlterAssembly"));
            }        
            m_RequiredPset = required;
            m_OptionalPset = optional;
            m_RefusedPset = refused;
        }
        
        internal void EnsurePublicComTypeCapacity()
        {
            if (m_publicComTypeList == null)
            {
                m_publicComTypeList = new Type[m_iInitialSize];
            }
            if (m_iPublicComTypeCount == m_publicComTypeList.Length)
            {
                Type[]  tempTypeList = new Type[m_iPublicComTypeCount * 2];
                Array.Copy(m_publicComTypeList, tempTypeList, m_iPublicComTypeCount);
                m_publicComTypeList = tempTypeList;            
            }
        }
         
        internal void Enter()
        {
            if (m_isSynchronized)
                System.Threading.Monitor.Enter(this);
        }
        
        internal void Exit()
        {
            if (m_isSynchronized)
                System.Threading.Monitor.Exit(this);
        }

        internal ModuleBuilder GetInMemoryAssemblyModule()
        {
            if (m_InMemoryAssemblyModule == null)
            {
                ModuleBuilder modBuilder = m_assembly.nGetInMemoryAssemblyModule();
                modBuilder.Init("RefEmit_InMemoryManifestModule", null, null);
                m_InMemoryAssemblyModule = modBuilder;
            }
            return m_InMemoryAssemblyModule;
        }

        internal ModuleBuilder GetOnDiskAssemblyModule()
        {
            if (m_OnDiskAssemblyModule == null)
            {
                ModuleBuilder modBuilder = m_assembly.nGetOnDiskAssemblyModule();
                modBuilder.Init("RefEmit_OnDiskManifestModule", null, null);
                m_OnDiskAssemblyModule = modBuilder;
            }
            return m_OnDiskAssemblyModule;
        }

        internal void SetOnDiskAssemblyModule(ModuleBuilder modBuilder)
        {
            m_OnDiskAssemblyModule = modBuilder;
        }

        internal ArrayList              m_moduleBuilderList;
        internal ArrayList              m_resWriterList;
        internal String                 m_strAssemblyName;
        internal AssemblyBuilderAccess  m_access;
        internal Assembly               m_assembly;
        
        internal Type[]                 m_publicComTypeList;
        internal int                    m_iPublicComTypeCount;
        
        internal ModuleBuilder          m_entryPointModule;
        internal bool                   m_isSaved;    
        internal static int             m_iInitialSize = 16;
        internal String                 m_strDir;

        // hard coding the assembly def token
        internal static int             m_tkAssembly = 0x20000001;
    
        // Security permission requests
        internal PermissionSet          m_RequiredPset;
        internal PermissionSet          m_OptionalPset;
        internal PermissionSet          m_RefusedPset;
        
        // Assembly builder may be optionally synchronized.
        internal bool                   m_isSynchronized;

        // tracking AssemblyDef's CAs for persistence to disk
        internal CustomAttributeBuilder[] m_CABuilders;
        internal int                    m_iCABuilder;
        internal byte[][]               m_CABytes;
        internal ConstructorInfo[]      m_CACons;
        internal int                    m_iCAs;
        internal PEFileKinds            m_peFileKind;           // assembly file kind
        private  ModuleBuilder          m_InMemoryAssemblyModule;
        private  ModuleBuilder          m_OnDiskAssemblyModule;
        internal MethodInfo             m_entryPointMethod;
        internal Assembly               m_ISymWrapperAssembly;
                                  
        // For unmanaged resources
        internal String                 m_strResourceFileName;
        internal byte[]                 m_resourceBytes;
        internal NativeVersionInfo      m_nativeVersion;
        internal bool                   m_hasUnmanagedVersionInfo;
        internal bool                   m_OverrideUnmanagedVersionInfo;

    }

    
    /**********************************************
    *
    * Internal structure to track the list of ResourceWriter for
    * AssemblyBuilder & ModuleBuilder.
    *
    **********************************************/
    internal class ResWriterData 
    {
        internal ResWriterData(
            ResourceWriter  resWriter,
            MemoryStream    memoryStream,
            String          strName,
            String          strFileName,
            String          strFullFileName,
            ResourceAttributes attribute)
        {
            m_resWriter = resWriter;
            m_memoryStream = memoryStream;
            m_strName = strName;
            m_strFileName = strFileName;
            m_strFullFileName = strFullFileName;
            m_nextResWriter = null;
            m_attribute = attribute;
        }

        internal ResourceWriter         m_resWriter;
        internal String                 m_strName;
        internal String                 m_strFileName;
        internal String                 m_strFullFileName;
        internal MemoryStream           m_memoryStream;
        internal ResWriterData          m_nextResWriter;
        internal ResourceAttributes     m_attribute;
    }

    internal class NativeVersionInfo
    {
        internal NativeVersionInfo()
        {
            m_strDescription = null;
            m_strCompany = null;
            m_strTitle = null;
            m_strCopyright = null;
            m_strTrademark = null;
            m_strProduct = null;
            m_strProductVersion = null;
            m_strFileVersion = null;
            m_lcid = -1;
        }
        
        internal String     m_strDescription;
        internal String     m_strCompany;           
        internal String     m_strTitle;
        internal String     m_strCopyright;         
        internal String     m_strTrademark;
        internal String     m_strProduct;           
        internal String     m_strProductVersion;        
        internal String     m_strFileVersion;
        internal int        m_lcid;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\assemblybuilder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Reflection.Emit {
  
    using System;
    using System.IO;
    using System.Diagnostics.SymbolStore;
    using System.Reflection;
    using System.Diagnostics;
    using System.Resources;    
    using System.Security.Permissions;
    using System.Runtime.Remoting.Activation;
    using CultureInfo = System.Globalization.CultureInfo;
    using ResourceWriter = System.Resources.ResourceWriter;
    using System.Runtime.Serialization;
    using System.Security;
    using System.Threading;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;

    // AssemblyBuilder class.
    /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder"]/*' />
    // deliberately not [serializable]
    public sealed class AssemblyBuilder : Assembly
    {

        /**********************************************
        *
        * Defines a named dynamic module. It is an error to define multiple 
        * modules within an Assembly with the same name. This dynamic module is
        * a transient module.
        * 
        **********************************************/
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.DefineDynamicModule"]/*' />
        public ModuleBuilder DefineDynamicModule(
            String      name)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return DefineDynamicModuleInternal(name, false, ref stackMark);
        }
    

        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.DefineDynamicModule1"]/*' />
        public ModuleBuilder DefineDynamicModule(
            String      name,
            bool        emitSymbolInfo)         // specify if emit symbol info or not
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return DefineDynamicModuleInternal( name, emitSymbolInfo, ref stackMark );
        }


        internal ModuleBuilder DefineDynamicModuleInternal(
            String      name,
            bool        emitSymbolInfo,         // specify if emit symbol info or not
            ref StackCrawlMark stackMark)
        {
            BCLDebug.Log("DYNIL","## DYNIL LOGGING: AssemblyBuilder.DefineDynamicModule( " + name + " )");
            
            BCLDebug.Assert(m_assemblyData != null, "m_assemblyData is null in DefineDynamicModuleInternal");

            if (name == null)
                throw new ArgumentNullException("name");
            if (name.Length == 0)
                throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "name");
           if (name[0] == '\0')
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidName"), "name");
             
            m_assemblyData.CheckNameConflict(name);
    
            // create the dynamic module
            ModuleBuilder   dynModule = nDefineDynamicModule(this, emitSymbolInfo, name, ref stackMark);
            ISymbolWriter   writer = null;

            if (emitSymbolInfo)
            {
            
                // create the default SymWriter
                Assembly assem = LoadISymWrapper();
                Type symWriter = assem.GetTypeInternal("System.Diagnostics.SymbolStore.SymWriter", true, false, true);
                if (symWriter == null)
                {
                    // cannot find SymWriter
                    throw new ExecutionEngineException(String.Format(Environment.GetResourceString(ResId.MissingType), "SymWriter")); 
                }
                try {
                    (new PermissionSet(PermissionState.Unrestricted)).Assert();
                    writer = (ISymbolWriter) Activator.CreateInstance(symWriter);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
            }

            dynModule.Init(name, null, writer);
            m_assemblyData.AddModule(dynModule);
            return dynModule;
        }
        
        private Assembly LoadISymWrapper()
        {
            if (m_assemblyData.m_ISymWrapperAssembly != null)
                return m_assemblyData.m_ISymWrapperAssembly;
            Version version = new Version(
                System.Reflection.Emit.InternalVersion.MajorVersion,
                System.Reflection.Emit.InternalVersion.MinorVersion, 
                System.Reflection.Emit.InternalVersion.BuildNumber, 
                System.Reflection.Emit.InternalVersion.RevisionNumber);
            AssemblyName name;
            byte[] bPublicKeyToken = new byte[8];
            bPublicKeyToken[0] = 0xb0;
            bPublicKeyToken[1] = 0x3f;
            bPublicKeyToken[2] = 0x5f;
            bPublicKeyToken[3] = 0x7f;
            bPublicKeyToken[4] = 0x11;
            bPublicKeyToken[5] = 0xd5;
            bPublicKeyToken[6] = 0x0a;
            bPublicKeyToken[7] = 0x3a;
            
            name = new AssemblyName(
                "ISymWrapper", 
                null, 
                null, // code base
                System.Configuration.Assemblies.AssemblyHashAlgorithm.None,
                version, 
                CultureInfo.InvariantCulture,
                AssemblyNameFlags.PublicKey);
            name.SetPublicKeyToken(bPublicKeyToken);                                   
                        
            Assembly assem = Assembly.Load(name);        
            if (assem == null)
            {
                // throw exception
                throw new ExecutionEngineException(String.Format(Environment.GetResourceString(ResId.MissingModule), "ISymWrapper")); 
            }
            m_assemblyData.m_ISymWrapperAssembly = assem;
            return assem;
        }

        /**********************************************
        *
        * Defines a named dynamic module. It is an error to define multiple 
        * modules within an Assembly with the same name. No symbol information
        * will be emitted.
        * 
        **********************************************/
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.DefineDynamicModule2"]/*' />
        public ModuleBuilder DefineDynamicModule(
            String      name, 
            String      fileName)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);

            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;

            // delegate to the next DefineDynamicModule 
            return DefineDynamicModuleInternal(name, fileName, false, ref stackMark); 
        }
    
        /**********************************************
        *
        * Emit symbol information if emitSymbolInfo is true using the
        * default symbol writer interface.
        * An exception will be thrown if the assembly is transient.
        *
        **********************************************/
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.DefineDynamicModule3"]/*' />
        public ModuleBuilder DefineDynamicModule(
            String      name,                   // module name
            String      fileName,               // module file name
            bool        emitSymbolInfo)         // specify if emit symbol info or not
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            return DefineDynamicModuleInternal(name, fileName, emitSymbolInfo, ref stackMark); 
        }


        private ModuleBuilder DefineDynamicModuleInternal(
            String      name,                   // module name
            String      fileName,               // module file name
            bool        emitSymbolInfo,         // specify if emit symbol info or not
            ref StackCrawlMark stackMark)       // stack crawl mark used to find caller
        {
            try
            {
                Enter();
                    
                BCLDebug.Log("DYNIL","## DYNIL LOGGING: AssemblyBuilder.DefineDynamicModule( " + name + ", " + fileName + ", " + emitSymbolInfo + " )");
                if (m_assemblyData.m_access == AssemblyBuilderAccess.Run)
                {
                    // Error! You cannot define a persistable module within a transient data.
                    throw new NotSupportedException(Environment.GetResourceString("Argument_BadPersistableModuleInTransientAssembly"));
                }
        
                if (m_assemblyData.m_isSaved == true)
                {
                    // assembly has been saved before!
                    throw new InvalidOperationException(Environment.GetResourceString(
                        "InvalidOperation_CannotAlterAssembly"));                          
                }
        
                if (name == null)
                    throw new ArgumentNullException("name");
                if (name.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "name");
                if (name[0] == '\0')
                    throw new ArgumentException(Environment.GetResourceString("Argument_InvalidName"), "name");
                
                if (fileName == null)
                    throw new ArgumentNullException("fileName");
                if (fileName.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyFileName"), "fileName");
                if (!String.Equals(fileName, Path.GetFileName(fileName)))
                    throw new ArgumentException(Environment.GetResourceString("Argument_NotSimpleFileName"), "fileName");
        
                m_assemblyData.CheckNameConflict(name);
                m_assemblyData.CheckFileNameConflict(fileName);
        
                // ecall to create the dynamic module
                ModuleBuilder   dynModule = nDefineDynamicModule(this, emitSymbolInfo, fileName, ref stackMark);
                ISymbolWriter      writer = null;
        
                if (emitSymbolInfo)
                {
                
                    // create the default SymWriter
                    Assembly assem = LoadISymWrapper();
                    Type symWriter = assem.GetTypeInternal("System.Diagnostics.SymbolStore.SymWriter", true, false, true);
                    if (symWriter == null)
                    {
                        // cannot find SymWriter
                        throw new ExecutionEngineException(String.Format(Environment.GetResourceString("MissingType"), "SymWriter")); 
                    }
                    try {
                        (new PermissionSet(PermissionState.Unrestricted)).Assert();
                        writer = (ISymbolWriter) Activator.CreateInstance(symWriter);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
        
                }

                // initialize the dynamic module's managed side information
                dynModule.Init(name, fileName, writer);
                m_assemblyData.AddModule(dynModule);
                return dynModule;
                
            }
            finally
            {
                Exit();
            }
        }
    
    
        /**********************************************
        *
        * Define stand alone managed resource for Assembly
        *
        **********************************************/
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.DefineResource"]/*' />
        public IResourceWriter DefineResource(
            String      name,
            String      description,
            String      fileName)
        {
            return DefineResource(name, description, fileName, ResourceAttributes.Public);
        }

        /**********************************************
        *
        * Define stand alone managed resource for Assembly
        *
        **********************************************/
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.DefineResource1"]/*' />
        public IResourceWriter DefineResource(
            String      name,
            String      description,
            String      fileName,
            ResourceAttributes attribute)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: AssemblyBuilder.DefineResource( " + name + ", " + fileName + ")");

                if (name == null)
                    throw new ArgumentNullException("name");
                if (name.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), name);
                if (fileName == null)
                    throw new ArgumentNullException("fileName");
                if (fileName.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyFileName"), "fileName");
                if (!String.Equals(fileName, Path.GetFileName(fileName)))
                    throw new ArgumentException(Environment.GetResourceString("Argument_NotSimpleFileName"), "fileName");

                m_assemblyData.CheckResNameConflict(name);
                m_assemblyData.CheckFileNameConflict(fileName);

                ResourceWriter resWriter;
                String  fullFileName;

                if (m_assemblyData.m_strDir == null)
                {
                    // If assembly directory is null, use current directory
                    fullFileName = Path.Combine(Environment.CurrentDirectory, fileName);
                    resWriter = new ResourceWriter(fullFileName);
                }
                else
                {
                    // Form the full path given the directory provided by user
                    fullFileName = Path.Combine(m_assemblyData.m_strDir, fileName);
                    resWriter = new ResourceWriter(fullFileName);
                }
                // get the full path    
                fullFileName = Path.GetFullPath(fullFileName);                            
                
                // retrieve just the file name
                fileName = Path.GetFileName(fullFileName);
                
                m_assemblyData.AddResWriter( new ResWriterData( resWriter, null, name, fileName, fullFileName, attribute) );
                return resWriter;
            }
            finally
            {
                Exit();
            }
        }


        /**********************************************
        *
        * Add an existing resource file to the Assembly
        *
        **********************************************/
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.AddResourceFile"]/*' />
        public void AddResourceFile(
            String      name,
            String      fileName)
        {
            AddResourceFile(name, fileName, ResourceAttributes.Public);
        }

        /**********************************************
        *
        * Add an existing resource file to the Assembly
        *
        **********************************************/
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.AddResourceFile1"]/*' />
        public void AddResourceFile(
            String      name,
            String      fileName,
            ResourceAttributes attribute)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: AssemblyBuilder.DefineResource( " + name + ", " + fileName + ")");

                if (name == null)
                    throw new ArgumentNullException("name");
                if (name.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), name);
                if (fileName == null)
                    throw new ArgumentNullException("fileName");
                if (fileName.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyFileName"), fileName);
                if (!String.Equals(fileName, Path.GetFileName(fileName)))
                    throw new ArgumentException(Environment.GetResourceString("Argument_NotSimpleFileName"), "fileName");

                m_assemblyData.CheckResNameConflict(name);
                m_assemblyData.CheckFileNameConflict(fileName);

                String  fullFileName;

                if (m_assemblyData.m_strDir == null)
                {
                    // If assembly directory is null, use current directory
                    fullFileName = Path.Combine(Environment.CurrentDirectory, fileName);
                }
                else
                {
                    // Form the full path given the directory provided by user
                    fullFileName = Path.Combine(m_assemblyData.m_strDir, fileName);
                }
                
                // get the full path    
                fullFileName = Path.GetFullPath(fullFileName);                            
                
                // retrieve just the file name
                fileName = Path.GetFileName(fullFileName);
                
                if (File.Exists(fullFileName) == false)
                    throw new FileNotFoundException(String.Format(Environment.GetResourceString(
                        "IO.FileNotFound_FileName"),
                        fileName), fileName);
                m_assemblyData.AddResWriter( new ResWriterData( null, null, name, fileName, fullFileName, attribute) );
            }
            finally
            {
                Exit();
            }
        }
        
        // Returns the names of all the resources
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.GetManifestResourceNames"]/*' />
        public override String[] GetManifestResourceNames()
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }
        
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.GetFile"]/*' />
        public override FileStream GetFile(String name)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }
        
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.GetFiles"]/*' />
        public override FileStream[] GetFiles(bool getResourceModules)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }     
        
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.GetManifestResourceStream"]/*' />
        public override Stream GetManifestResourceStream(Type type, String name)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }     
        
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.GetManifestResourceStream1"]/*' />
        public override Stream GetManifestResourceStream(String name)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }
                      
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.GetManifestResourceInfo"]/*' />
        public override ManifestResourceInfo GetManifestResourceInfo(String resourceName)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }        

        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.Location"]/*' />
        public override String Location
        {
            get {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
            }
        }

        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.ImageRuntimeVersion"]/*' />
        public override String ImageRuntimeVersion
        {
            get
            {
                return RuntimeEnvironment.GetSystemVersion();
            }
        }
        
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.CodeBase"]/*' />
        public override String CodeBase {
            get {
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
            }
        }
        
       
                 
        /**********************************************
        *
        * Add an unmanaged Version resource to the
        *  assembly
        *
        **********************************************/
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.DefineVersionInfoResource"]/*' />
        public void DefineVersionInfoResource(
            String      product,            
            String      productVersion,     
            String      company,            
            String      copyright,          
            String      trademark)
        {
            if (m_assemblyData.m_strResourceFileName != null ||
                m_assemblyData.m_resourceBytes != null ||
                m_assemblyData.m_nativeVersion != null)
                throw new ArgumentException(Environment.GetResourceString("Argument_NativeResourceAlreadyDefined"));

            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            
            m_assemblyData.m_nativeVersion = new NativeVersionInfo();

            m_assemblyData.m_nativeVersion.m_strCopyright = copyright;
            m_assemblyData.m_nativeVersion.m_strTrademark = trademark;
            m_assemblyData.m_nativeVersion.m_strCompany = company;
            m_assemblyData.m_nativeVersion.m_strProduct = product;
            m_assemblyData.m_nativeVersion.m_strProductVersion = productVersion;
            m_assemblyData.m_hasUnmanagedVersionInfo = true;
            m_assemblyData.m_OverrideUnmanagedVersionInfo = true;

        }
        
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.DefineVersionInfoResource1"]/*' />
        public void DefineVersionInfoResource()
        {
            if (m_assemblyData.m_strResourceFileName != null ||
                m_assemblyData.m_resourceBytes != null ||
                m_assemblyData.m_nativeVersion != null)
                throw new ArgumentException(Environment.GetResourceString("Argument_NativeResourceAlreadyDefined"));
            
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            
            m_assemblyData.m_hasUnmanagedVersionInfo = true;
            m_assemblyData.m_nativeVersion = new NativeVersionInfo();
        }

        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.DefineUnmanagedResource"]/*' />
        public void DefineUnmanagedResource(
            Byte[]      resource)
        {
            if (m_assemblyData.m_strResourceFileName != null ||
                m_assemblyData.m_resourceBytes != null ||
                m_assemblyData.m_nativeVersion != null)
                throw new ArgumentException(Environment.GetResourceString("Argument_NativeResourceAlreadyDefined"));
            if (resource == null)            
                throw new ArgumentNullException("resource");
            
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            
            m_assemblyData.m_resourceBytes = new byte[resource.Length];
            System.Array.Copy(resource, m_assemblyData.m_resourceBytes, resource.Length);
        }

        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.DefineUnmanagedResource1"]/*' />
        public void DefineUnmanagedResource(
            String      resourceFileName)
        {        
            if (m_assemblyData.m_strResourceFileName != null ||
                m_assemblyData.m_resourceBytes != null ||
                m_assemblyData.m_nativeVersion != null)
                throw new ArgumentException(Environment.GetResourceString("Argument_NativeResourceAlreadyDefined"));
            
            if (resourceFileName == null)            
                throw new ArgumentNullException("resourceFileName");            
            
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
        
            // Check caller has the right to read the file.
            string      strFullFileName;
            if (m_assemblyData.m_strDir == null)
            {
                // If assembly directory is null, use current directory
                strFullFileName = Path.Combine(Environment.CurrentDirectory, resourceFileName);
            }
            else
            {
                // Form the full path given the directory provided by user
                strFullFileName = Path.Combine(m_assemblyData.m_strDir, resourceFileName);
            }
            strFullFileName = Path.GetFullPath(resourceFileName);
            new FileIOPermission(FileIOPermissionAccess.Read, strFullFileName).Demand();  
            
            if (File.Exists(strFullFileName) == false)
                throw new FileNotFoundException(String.Format(Environment.GetResourceString(
                    "IO.FileNotFound_FileName"),
                    resourceFileName), resourceFileName);                         
            m_assemblyData.m_strResourceFileName = strFullFileName;
        }
        

        
        /**********************************************
        *
        * return a dynamic module with the specified name.
        *
        **********************************************/
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.GetDynamicModule"]/*' />
        public ModuleBuilder GetDynamicModule(
            String      name)                   // the name of module for the look up
        {
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: AssemblyBuilder.GetDynamicModule( " + name + " )");
                if (name == null)
                    throw new ArgumentNullException("name");
                if (name.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "name");
    
                int size = m_assemblyData.m_moduleBuilderList.Count;
                for (int i=0;i<size;i++) {
                    ModuleBuilder moduleBuilder = (ModuleBuilder) m_assemblyData.m_moduleBuilderList[i];
                    if (moduleBuilder.m_moduleData.m_strModuleName.Equals(name))
                    {
                        return moduleBuilder;
                    }
                }        
                return null;
            }
            finally
            {
                Exit();
            }
        }
    
        /**********************************************
        *
        * Setting the entry point if the assembly builder is building
        * an exe.
        *
        **********************************************/
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.SetEntryPoint"]/*' />
        public void SetEntryPoint(
            MethodInfo  entryMethod) 
        {
            SetEntryPoint(entryMethod, PEFileKinds.ConsoleApplication);
        }
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.SetEntryPoint1"]/*' />
        public void SetEntryPoint(
            MethodInfo  entryMethod,        // entry method for the assembly. We use this to determine the entry module
            PEFileKinds fileKind)           // file kind for the assembly.
        {

            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            try
            {
                Enter();

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: AssemblyBuilder.SetEntryPoint");
                if (entryMethod == null)
                    throw new ArgumentNullException("entryMethod");
    
                // @todo: list module builder restriction when we allow AddModule in AssemblyBuilder.
                //
                Module tmpModule = entryMethod.InternalReflectedClass(true).Module;
                if (!(tmpModule is ModuleBuilder && this.Equals(tmpModule.Assembly)))
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EntryMethodNotDefinedInAssembly"));
                m_assemblyData.m_entryPointModule = (ModuleBuilder) tmpModule;
                m_assemblyData.m_entryPointMethod = entryMethod;
                m_assemblyData.m_peFileKind = fileKind;
                m_assemblyData.m_entryPointModule.SetEntryPoint(entryMethod);
            }
            finally
            {
                Exit();
            }
        }


        // Override the EntryPoint method on Assembly.
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.EntryPoint"]/*' />
        public override MethodInfo EntryPoint {
            get {return m_assemblyData.m_entryPointMethod;}
        }

        /**********************************************
        * Use this function if client decides to form the custom attribute blob themselves
        **********************************************/
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.SetCustomAttribute"]/*' />
        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            if (con == null)
                throw new ArgumentNullException("con");
            if (binaryAttribute == null)
                throw new ArgumentNullException("binaryAttribute");
            
            ModuleBuilder       inMemoryAssemblyModule;
            inMemoryAssemblyModule = m_assemblyData.GetInMemoryAssemblyModule();
            TypeBuilder.InternalCreateCustomAttribute(
                AssemblyBuilderData.m_tkAssembly,           // This is the AssemblyDef token
                inMemoryAssemblyModule.GetConstructorToken(con).Token,
                binaryAttribute,
                inMemoryAssemblyModule,                     // pass in the in-memory assembly module
                false);

            // Track the CA for persistence
            if (m_assemblyData.m_access == AssemblyBuilderAccess.Run)
            {
                return;
            }

            // tracking the CAs for persistence
            m_assemblyData.AddCustomAttribute(con, binaryAttribute);
        }

        /**********************************************
        * Use this function if client wishes to build CustomAttribute using CustomAttributeBuilder
        **********************************************/
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.SetCustomAttribute1"]/*' />
        public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
        {
            CodeAccessPermission.DemandInternal(PermissionType.ReflectionEmit);
            if (customBuilder == null)
            {
                throw new ArgumentNullException("customBuilder");
            }

            ModuleBuilder       inMemoryAssemblyModule;
            inMemoryAssemblyModule = m_assemblyData.GetInMemoryAssemblyModule();
            customBuilder.CreateCustomAttribute(
                inMemoryAssemblyModule, 
                AssemblyBuilderData.m_tkAssembly);          // This is the AssemblyDef token 

            // Track the CA for persistence
            if (m_assemblyData.m_access == AssemblyBuilderAccess.Run)
            {
                return;
            }
            m_assemblyData.AddCustomAttribute(customBuilder);
        }


        /**********************************************
        *
        * Saves the assembly to disk. Also saves all dynamic modules defined
        * in this dynamic assembly. Assembly file name can be the same as one of 
        * the module's name. If so, assembly info is stored within that module.
        * Assembly file name can be different from all of the modules underneath. In
        * this case, assembly is stored stand alone. 
        *
        **********************************************/

        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.Save"]/*' />
        public void Save(String      assemblyFileName)       // assembly file name
        {
            String      tmpVersionFile = null;
            try
            {
                Enter();

                int         i;
                int         size;
                Type        type;
                TypeBuilder typeBuilder;
                ModuleBuilder modBuilder;
                String      strModFileName;
                ModuleBuilder assemblyModule;
                ResWriterData tempRes;
                int[]       tkAttrs = null;
                int[]       tkAttrs2 = null;
                ModuleBuilder onDiskAssemblyModule;

                BCLDebug.Log("DYNIL","## DYNIL LOGGING: AssemblyBuilder.Save( " + assemblyFileName + " )");

                if (m_assemblyData.m_iCABuilder != 0)
                    tkAttrs = new int[m_assemblyData.m_iCABuilder];
                if ( m_assemblyData.m_iCAs != 0)
                    tkAttrs2 = new int[m_assemblyData.m_iCAs];

                if (m_assemblyData.m_isSaved == true)
                {
                    // assembly has been saved before!
                    throw new InvalidOperationException(String.Format(Environment.GetResourceString(
                        ResId.InvalidOperation_AssemblyHasBeenSaved),
                        nGetSimpleName()));
                }
    
                if (m_assemblyData.m_access == AssemblyBuilderAccess.Run)
                {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_CantSaveTransientAssembly"));
                }
    
                if (assemblyFileName == null)
                    throw new ArgumentNullException("assemblyFileName");
                if (assemblyFileName.Length == 0)
                    throw new ArgumentException(Environment.GetResourceString("Argument_EmptyFileName"), "assemblyFileName");
                if (!String.Equals(assemblyFileName, Path.GetFileName(assemblyFileName)))
                    throw new ArgumentException(Environment.GetResourceString("Argument_NotSimpleFileName"), "assemblyFileName");
    
                // Check if assembly info is supposed to be stored with one of the module files.    
                assemblyModule = m_assemblyData.FindModuleWithFileName(assemblyFileName);

                if (assemblyModule != null)
                {
                    m_assemblyData.SetOnDiskAssemblyModule(assemblyModule);
                }

                // If assembly is to be stored alone, then no file name should conflict with it.
                // This check will ensure resource file names are different assembly file name.
                //
                if (assemblyModule == null)
                {
                    m_assemblyData.CheckFileNameConflict(assemblyFileName);

                }

                if (m_assemblyData.m_strDir == null)
                {
                    // set it to current directory
                    m_assemblyData.m_strDir = Environment.CurrentDirectory;
                }
                else if (Directory.Exists(m_assemblyData.m_strDir) == false)
                {
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_InvalidDirectory"), 
                        m_assemblyData.m_strDir));
                }

                // after this point, assemblyFileName is the full path name.
                assemblyFileName = Path.Combine(m_assemblyData.m_strDir, assemblyFileName);
                assemblyFileName = Path.GetFullPath(assemblyFileName);

                // Check caller has the right to create the assembly file itself.
                new FileIOPermission(FileIOPermissionAccess.Write | FileIOPermissionAccess.Append, assemblyFileName).Demand();

                // 1. setup/create the IMetaDataAssemblyEmit for the on disk version
                if (assemblyModule != null)
                {
                    // prepare saving CAs on assembly def. We need to introduce the MemberRef for
                    // the CA's type first of all. This is for the case the we have embedded manifest.
                    // We need to introduce these MRs before we call PreSave where we will snap
                    // into a ondisk metadata. If we do it after this, the ondisk metadata will
                    // not contain the proper MRs.
                    //
                    for (i=0; i < m_assemblyData.m_iCABuilder; i++)
                    {
                        tkAttrs[i] = m_assemblyData.m_CABuilders[i].PrepareCreateCustomAttributeToDisk(
                            assemblyModule); 
                    }
                    for (i=0; i < m_assemblyData.m_iCAs; i++)
                    {
                        tkAttrs2[i] = assemblyModule.InternalGetConstructorToken(m_assemblyData.m_CACons[i], true).Token;
                    }
                    assemblyModule.PreSave(assemblyFileName);
                }
                nPrepareForSavingManifestToDisk(assemblyModule);

                // This function will return the embedded manifest module, an already exposed ModuleBuilder
                // created by user, or make the stand alone manifest module exposed through managed code.
                //
                onDiskAssemblyModule = m_assemblyData.GetOnDiskAssemblyModule();

                // Set any native resources on the OnDiskAssemblyModule.
                if (m_assemblyData.m_strResourceFileName != null)
                    onDiskAssemblyModule.DefineUnmanagedResource(m_assemblyData.m_strResourceFileName);
                else if (m_assemblyData.m_resourceBytes != null)
                    onDiskAssemblyModule.DefineUnmanagedResource(m_assemblyData.m_resourceBytes);
                else if (m_assemblyData.m_hasUnmanagedVersionInfo == true)
                {
                    // calculate unmanaged version info from assembly's custom attributes
                    m_assemblyData.FillUnmanagedVersionInfo();

                    String strFileVersion = m_assemblyData.m_nativeVersion.m_strFileVersion;
                    if (strFileVersion == null)
                        strFileVersion = GetVersion().ToString();

                    // Create the file.
                    tmpVersionFile = nDefineVersionInfoResource(
                         assemblyFileName,
                         m_assemblyData.m_nativeVersion.m_strTitle,   // title
                         null, // Icon filename
                         m_assemblyData.m_nativeVersion.m_strDescription,   // description
                         m_assemblyData.m_nativeVersion.m_strCopyright,
                         m_assemblyData.m_nativeVersion.m_strTrademark,
                         m_assemblyData.m_nativeVersion.m_strCompany,
                         m_assemblyData.m_nativeVersion.m_strProduct,
                         m_assemblyData.m_nativeVersion.m_strProductVersion,
                         strFileVersion, 
                         m_assemblyData.m_nativeVersion.m_lcid,
                         m_assemblyData.m_peFileKind == PEFileKinds.Dll);

                    onDiskAssemblyModule.DefineUnmanagedResourceFileInternal(tmpVersionFile);
                }


                if (assemblyModule == null)
                {
                
                    // This is for introducing the MRs for CA's type. This case is for stand alone
                    // manifest. We need to wait till nPrepareForSavingManifestToDisk is called. 
                    // That will trigger the creation of the on-disk stand alone manifest module.
                    //
                    for (i=0; i < m_assemblyData.m_iCABuilder; i++)
                    {
                        tkAttrs[i] = m_assemblyData.m_CABuilders[i].PrepareCreateCustomAttributeToDisk(
                            onDiskAssemblyModule); 
                    }
                    for (i=0; i < m_assemblyData.m_iCAs; i++)
                    {
                        tkAttrs2[i] = onDiskAssemblyModule.InternalGetConstructorToken(m_assemblyData.m_CACons[i], true).Token;
                    }
                }
            
                // 2. save all of the persistable modules contained by this AssemblyBuilder except the module that is going to contain
                // Assembly information
                // 
                // 3. create the file list in the manifest and track the file token. If it is embedded assembly,
                // the assembly file should not be on the file list.
                // 
                size = m_assemblyData.m_moduleBuilderList.Count;
                for (i = 0; i < size; i++) 
                {
                    ModuleBuilder mBuilder = (ModuleBuilder) m_assemblyData.m_moduleBuilderList[i];
                    if (mBuilder.IsTransient() == false && mBuilder != assemblyModule)
                    {
                        strModFileName = mBuilder.m_moduleData.m_strFileName;              
                        if (m_assemblyData.m_strDir != null)
                        {
                            strModFileName = Path.Combine(m_assemblyData.m_strDir, strModFileName);
                            strModFileName = Path.GetFullPath(strModFileName);                            
                        }
                        
                        // Check caller has the right to create the Module file itself.
                        new FileIOPermission(FileIOPermissionAccess.Write | FileIOPermissionAccess.Append, strModFileName).Demand();
                        
                        mBuilder.m_moduleData.m_tkFile = nSaveToFileList(mBuilder.m_moduleData.m_strFileName);
                        mBuilder.PreSave(strModFileName);
                        mBuilder.Save(strModFileName, false);
                        // Cannot set the hash value when creating the file since the file token
                        // is needed to created the entries for the embedded resources in the
                        // module and the resources need to be there before you figure the hash.
                        nSetHashValue(mBuilder.m_moduleData.m_tkFile, strModFileName);
                    }
                }
        
                // 4. Add the public ComType
                for (i=0; i < m_assemblyData.m_iPublicComTypeCount; i++)
                {   
                    type = m_assemblyData.m_publicComTypeList[i];
                    // If the type that was added as a Public Com Type was obtained via Reflection,
                    //  it will be a System.RuntimeType, even if it was really, at the same time,
                    //  a TypeBuilder.  Unfortunately, you can't get back to the TypeBuilder, so 
                    //  this code has to deal with either-or.
                    if (type is System.RuntimeType)
                    {
                        modBuilder = m_assemblyData.FindModuleWithName(type.Module.m_moduleData.m_strModuleName);
                        if (modBuilder != assemblyModule)
                            DefineNestedComType(type, modBuilder.m_moduleData.m_tkFile, type.InternalGetTypeDefToken());
                    }
                    else
                    {
                        // Could assert that "type" is a TypeBuilder, but next statement throws if it isn't.
                        typeBuilder = (TypeBuilder) type;
                        modBuilder = (ModuleBuilder) type.Module;
                        if (modBuilder != assemblyModule)
                            DefineNestedComType(type, modBuilder.m_moduleData.m_tkFile, typeBuilder.TypeToken.Token);
                    }
                }

                // 5. write AssemblyDef's CAs
                for (i=0; i < m_assemblyData.m_iCABuilder; i++)
                {
                    m_assemblyData.m_CABuilders[i].CreateCustomAttribute(
                        onDiskAssemblyModule, 
                        AssemblyBuilderData.m_tkAssembly,           // This is the AssemblyDef token 
                        tkAttrs[i], true);
                }

                for (i=0; i < m_assemblyData.m_iCAs; i++)
                {
                    TypeBuilder.InternalCreateCustomAttribute(
                        AssemblyBuilderData.m_tkAssembly,           // This is the AssemblyDef token
                        tkAttrs2[i],
                        m_assemblyData.m_CABytes[i],
                        onDiskAssemblyModule,                       // pass in the in-memory assembly module
                        false);
                }

                // 6. write security permission requests to the manifest.
                if (m_assemblyData.m_RequiredPset  != null || m_assemblyData.m_OptionalPset != null || m_assemblyData.m_RefusedPset != null)
                {
                    // Translate sets into internal encoding (uses standard binary serialization).
                    byte[] required = null;
                    byte[] optional = null;
                    byte[] refused = null;
                    if (m_assemblyData.m_RequiredPset != null)
                        required = m_assemblyData.m_RequiredPset.EncodeXml();
                    if (m_assemblyData.m_OptionalPset != null)
                        optional = m_assemblyData.m_OptionalPset.EncodeXml();
                    if (m_assemblyData.m_RefusedPset != null)
                        refused = m_assemblyData.m_RefusedPset.EncodeXml();
                    nSavePermissionRequests(required, optional, refused);
                }

                // 7. Save the stand alone managed resources
                size = m_assemblyData.m_resWriterList.Count;
                for ( i = 0; i < size; i++ )
                {
                    tempRes = (ResWriterData) m_assemblyData.m_resWriterList[i];
                    // If the user added an existing resource to the manifest, the
                    // corresponding ResourceWriter will be null.
                    if (tempRes.m_resWriter != null)
                    {
                        // Check caller has the right to create the Resource file itself.
                        new FileIOPermission(FileIOPermissionAccess.Write | FileIOPermissionAccess.Append, tempRes.m_strFullFileName).Demand();                
                        tempRes.m_resWriter.Close();
                    }
                            
                    // Add entry to manifest for this stand alone resource
                    nAddStandAloneResource(tempRes.m_strName, tempRes.m_strFileName, tempRes.m_strFullFileName, (int) tempRes.m_attribute);
                }

                // Save now!!
                if (assemblyModule == null)
                {
                    
                    if (onDiskAssemblyModule.m_moduleData.m_strResourceFileName != null)                        
                        onDiskAssemblyModule.InternalDefineNativeResourceFile(onDiskAssemblyModule.m_moduleData.m_strResourceFileName);
                    else if (onDiskAssemblyModule.m_moduleData.m_resourceBytes != null)
                        onDiskAssemblyModule.InternalDefineNativeResourceBytes(onDiskAssemblyModule.m_moduleData.m_resourceBytes);

                    // Stand alone manifest
                    if (m_assemblyData.m_entryPointModule != null)
                    {
                        nSaveManifestToDisk(assemblyFileName, 
                                            m_assemblyData.m_entryPointModule.m_moduleData.m_tkFile,
                                            (int) m_assemblyData.m_peFileKind);
                    }
                    else
                    {
                        nSaveManifestToDisk(assemblyFileName, 0, (int) m_assemblyData.m_peFileKind);
                    }
                }
                else
                {
                    // embedded manifest
                    
                    // If the module containing the entry point is not the manifest file, we need to
                    // let the manifest file point to the module which contains the entry point.
                    // @FUTURE: We fix this at RTM time for V1. So minimum code change is desired. 
                    // @FUTURE: We are creating a MethodToken given a file token value. This is not really
                    // @FUTURE: correctly. Please clean up.
                    // 
                    if (m_assemblyData.m_entryPointModule != null && m_assemblyData.m_entryPointModule != assemblyModule)
                        assemblyModule.m_EntryPoint = new MethodToken(m_assemblyData.m_entryPointModule.m_moduleData.m_tkFile);
                    assemblyModule.Save(assemblyFileName, true);
                }    
                m_assemblyData.m_isSaved = true;
            }
            finally
            {
                Exit();
                if (tmpVersionFile != null)
                {
                    // Delete file.
                    System.IO.File.Delete(tmpVersionFile);
                }
            }
        }
    

        
        // Get an array of all the public types defined in this assembly
        /// <include file='doc\AssemblyBuilder.uex' path='docs/doc[@for="AssemblyBuilder.GetExportedTypes"]/*' />
        public override Type[] GetExportedTypes()
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicAssembly"));
        }
    
        internal bool IsPersistable()
        {
            if ((m_assemblyData.m_access & AssemblyBuilderAccess.Save) == AssemblyBuilderAccess.Save)
                return true;
            else
                return false;
        }
    
        /**********************************************
         * If the instance of the assembly builder is
         * to be synchronized, obtain the lock.
         **********************************************/ 
        internal void Enter()
        {
            m_assemblyData.Enter();
        }
        
        /**********************************************
         * If the instance of the assembly builder is
         * to be synchronized, free the lock.
         **********************************************/ 
        internal void Exit()
        {
            m_assemblyData.Exit();
        }
   
        /**********************************************
        *
        * Internal helper to walk the nested type hierachy
        *
        **********************************************/
        private int DefineNestedComType(Type type, int tkResolutionScope, int tkTypeDef)
        {
            Type        enclosingType = type.DeclaringType;
            if (enclosingType == null)
            {
                return nSaveExportedType(type.FullName, tkResolutionScope, tkTypeDef, type.Attributes);
            }
            else
            {
                tkResolutionScope = DefineNestedComType(enclosingType, tkResolutionScope, tkTypeDef);
            }
            return nSaveExportedType(type.FullName, tkResolutionScope, tkTypeDef, type.Attributes);
        }

        /**********************************************
         * 
         * Private methods
         * 
         **********************************************/
    
        /**********************************************
         * Make a private constructor so these cannot be constructed externally.
         * @internonly
         **********************************************/
        private AssemblyBuilder() {}

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\customattributebuilder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  CustomAttrbuteBuilder
**
** Author: Mei-Chin Tsai (meichint)
**
** CustomAttributeBuilder is a helper class to help building custom attribute.
**
** Date:  Jan, 2000
** 
===========================================================*/
namespace System.Reflection.Emit {
    
    
    using System;
    using System.Reflection;
    using System.IO;
    using System.Text;

    /// <include file='doc\CustomAttributeBuilder.uex' path='docs/doc[@for="CustomAttributeBuilder"]/*' />
    public class CustomAttributeBuilder
    {
        // public constructor to form the custom attribute with constructor and constructor
        // parameters.
        /// <include file='doc\CustomAttributeBuilder.uex' path='docs/doc[@for="CustomAttributeBuilder.CustomAttributeBuilder"]/*' />
        public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs)
        {
            InitCustomAttributeBuilder(con, constructorArgs,
                                       new PropertyInfo[]{}, new Object[]{},
                                       new FieldInfo[]{}, new Object[]{});
        }
    
        // public constructor to form the custom attribute with constructor, constructor
        // parameters and named properties.
        /// <include file='doc\CustomAttributeBuilder.uex' path='docs/doc[@for="CustomAttributeBuilder.CustomAttributeBuilder1"]/*' />
        public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs,
									  PropertyInfo[] namedProperties, Object[] propertyValues)
        {
            InitCustomAttributeBuilder(con, constructorArgs, namedProperties,
                                       propertyValues, new FieldInfo[]{}, new Object[]{});
        }

        // public constructor to form the custom attribute with constructor and constructor
        // parameters.
        /// <include file='doc\CustomAttributeBuilder.uex' path='docs/doc[@for="CustomAttributeBuilder.CustomAttributeBuilder2"]/*' />
        public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs,
                                      FieldInfo[] namedFields, Object[] fieldValues)
        {
            InitCustomAttributeBuilder(con, constructorArgs, new PropertyInfo[]{},
                                       new Object[]{}, namedFields, fieldValues);
        }

        // public constructor to form the custom attribute with constructor and constructor
        // parameters.
        /// <include file='doc\CustomAttributeBuilder.uex' path='docs/doc[@for="CustomAttributeBuilder.CustomAttributeBuilder3"]/*' />
        public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs,
                                      PropertyInfo[] namedProperties, Object[] propertyValues,
                                      FieldInfo[] namedFields, Object[] fieldValues)
        {
            InitCustomAttributeBuilder(con, constructorArgs, namedProperties,
                                       propertyValues, namedFields, fieldValues);
        }

        private const byte SERIALIZATION_TYPE_BOOLEAN = SignatureHelper.ELEMENT_TYPE_BOOLEAN;
        private const byte SERIALIZATION_TYPE_CHAR = SignatureHelper.ELEMENT_TYPE_CHAR;
        private const byte SERIALIZATION_TYPE_I1 = SignatureHelper.ELEMENT_TYPE_I1;
        private const byte SERIALIZATION_TYPE_U1 = SignatureHelper.ELEMENT_TYPE_U1;
        private const byte SERIALIZATION_TYPE_I2 = SignatureHelper.ELEMENT_TYPE_I2;
        private const byte SERIALIZATION_TYPE_U2 = SignatureHelper.ELEMENT_TYPE_U2;
        private const byte SERIALIZATION_TYPE_I4 = SignatureHelper.ELEMENT_TYPE_I4;
        private const byte SERIALIZATION_TYPE_U4 = SignatureHelper.ELEMENT_TYPE_U4;
        private const byte SERIALIZATION_TYPE_I8 = SignatureHelper.ELEMENT_TYPE_I8;
        private const byte SERIALIZATION_TYPE_U8 = SignatureHelper.ELEMENT_TYPE_U8;
        private const byte SERIALIZATION_TYPE_R4 = SignatureHelper.ELEMENT_TYPE_R4;
        private const byte SERIALIZATION_TYPE_R8 = SignatureHelper.ELEMENT_TYPE_R8;
        private const byte SERIALIZATION_TYPE_STRING = SignatureHelper.ELEMENT_TYPE_STRING;
        private const byte SERIALIZATION_TYPE_SZARRAY = SignatureHelper.ELEMENT_TYPE_SZARRAY;
        private const byte SERIALIZATION_TYPE_TYPE = 0x50;
        private const byte SERIALIZATION_TYPE_TAGGED_OBJECT = 0x51;
        private const byte SERIALIZATION_TYPE_FIELD = 0x53;
        private const byte SERIALIZATION_TYPE_PROPERTY = 0x54;
        private const byte SERIALIZATION_TYPE_ENUM = 0x55;

        // Check that a type is suitable for use in a custom attribute.
        private bool ValidateType(Type t)
        {
            if (t.IsPrimitive || t == typeof(String) || t == typeof(Type))
                return true;
            if (t.IsEnum)
            {
                switch (Type.GetTypeCode(Enum.GetUnderlyingType(t)))
                {
                    case TypeCode.SByte:
                    case TypeCode.Byte:
                    case TypeCode.Int16:
                    case TypeCode.UInt16:
                    case TypeCode.Int32:
                    case TypeCode.UInt32:
                    case TypeCode.Int64:
                    case TypeCode.UInt64:
                        return true;
                    default:
                        return false;
                }
            }
            if (t.IsArray)
            {
                if (t.GetArrayRank() != 1)
                    return false;
                return ValidateType(t.GetElementType());
            }
            return t == typeof(Object);
        }

        internal void InitCustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs,
                                                 PropertyInfo[] namedProperties, Object[] propertyValues,
                                                 FieldInfo[] namedFields, Object[] fieldValues)
        {
            if (con == null)
                throw new ArgumentNullException("con");
            if (constructorArgs == null)
                throw new ArgumentNullException("constructorArgs");
            if (namedProperties == null)
                throw new ArgumentNullException("constructorArgs");
            if (propertyValues == null)
                throw new ArgumentNullException("propertyValues");
            if (namedFields == null)
                throw new ArgumentNullException("namedFields");
            if (fieldValues == null)
                throw new ArgumentNullException("fieldValues");
            if (namedProperties.Length != propertyValues.Length)
                throw new ArgumentException(Environment.GetResourceString("Arg_ArrayLengthsDiffer"), "namedProperties, propertyValues");
            if (namedFields.Length != fieldValues.Length)
                throw new ArgumentException(Environment.GetResourceString("Arg_ArrayLengthsDiffer"), "namedFields, fieldValues");

            if ((con.Attributes & MethodAttributes.Static) == MethodAttributes.Static ||
                (con.Attributes & MethodAttributes.Private) == MethodAttributes.Private)
                throw new ArgumentException(Environment.GetResourceString("Argument_BadConstructor"));
                        
            if ((con.CallingConvention & CallingConventions.Standard) != CallingConventions.Standard)
                throw new ArgumentException(Environment.GetResourceString("Argument_BadConstructorCallConv"));

            // Cache information used elsewhere.
            m_con = con;
            m_constructorArgs = new Object[constructorArgs.Length];
            Array.Copy(constructorArgs, m_constructorArgs, constructorArgs.Length);

            Type[] paramTypes;
            int i;

            // Get the types of the constructor's formal parameters.
            if (con is ConstructorBuilder)
            {
                paramTypes = ((ConstructorBuilder)con).GetParameterTypes();
                if (paramTypes == null)
                    paramTypes = new Type[0];
            }
            else
            {
                ParameterInfo[] paramInfos = con.GetParameters();
                paramTypes = new Type[paramInfos.Length];
                for (i = 0; i < paramInfos.Length; i++)
                    paramTypes[i] = paramInfos[i].ParameterType;
            }

            // Since we're guaranteed a non-var calling convention, the number of arguments must equal the number of parameters.
            if (paramTypes.Length != constructorArgs.Length)
                throw new ArgumentException(Environment.GetResourceString("Argument_BadParameterCountsForConstructor"));

            // Verify that the constructor has a valid signature (custom attributes only support a subset of our type system).
            for (i = 0; i < paramTypes.Length; i++)
                if (!ValidateType(paramTypes[i]))
                    throw new ArgumentException(Environment.GetResourceString("Argument_BadTypeInCustomAttribute"));

            // Now verify that the types of the actual parameters are compatible with the types of the formal parameters.
            for (i = 0; i < paramTypes.Length; i++)
            {
                if (constructorArgs[i] == null)
                    continue;
                TypeCode paramTC = Type.GetTypeCode(paramTypes[i]);
                if (paramTC != Type.GetTypeCode(constructorArgs[i].GetType()))
                    if (paramTC != TypeCode.Object || !ValidateType(constructorArgs[i].GetType())) 
                        throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_BadParameterTypeForConstructor"), i));
            }

            // Allocate a memory stream to represent the CA blob in the metadata and a binary writer to help format it.
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);

            // Write the blob protocol version (currently 1).
            writer.Write((ushort)1);

            // Now emit the constructor argument values (no need for types, they're inferred from the constructor signature).
            for (i = 0; i < constructorArgs.Length; i++)
                EmitValue(writer, paramTypes[i], constructorArgs[i]);

            // Next a short with the count of properties and fields.
            writer.Write((ushort)(namedProperties.Length + namedFields.Length));

            // Emit all the property sets.
            for (i = 0; i < namedProperties.Length; i++)
            {
                // Validate the property.
                if (namedProperties[i] == null)
                    throw new ArgumentNullException("namedProperties[" + i + "]");

                // Allow null for non-primitive types only.
                Type propType = namedProperties[i].PropertyType;
                if (propertyValues[i] == null && propType.IsPrimitive)
                    throw new ArgumentNullException("propertyValues[" + i + "]");

                // Validate property type.
                if (!ValidateType(propType))
                    throw new ArgumentException(Environment.GetResourceString("Argument_BadTypeInCustomAttribute"));

                // Property has to be writable.
                if (!namedProperties[i].CanWrite)                
                    throw new ArgumentException(Environment.GetResourceString("Argument_NotAWritableProperty"));
                    
                // Property has to be from the same class or base class as ConstructorInfo.
                if (namedProperties[i].DeclaringType != con.DeclaringType &&
                    !con.DeclaringType.IsSubclassOf(namedProperties[i].DeclaringType))
                {
                    // Might have failed check because one type is a XXXBuilder
                    // and the other is not. Deal with these special cases
                    // separately.
                    if (!TypeBuilder.IsTypeEqual(namedProperties[i].DeclaringType, con.DeclaringType))
                    {
                        // IsSubclassOf is overloaded to do the right thing if
                        // the constructor is a TypeBuilder, but we still need
                        // to deal with the case where the property's declaring
                        // type is one.
                        if (!(namedProperties[i].DeclaringType is TypeBuilder) ||
                            !con.DeclaringType.IsSubclassOf(((TypeBuilder)namedProperties[i].DeclaringType).m_runtimeType))
                            throw new ArgumentException(Environment.GetResourceString("Argument_BadPropertyForConstructorBuilder"));
                    }
                }

                // Make sure the property's type can take the given value.
                // Note that there will no no coersion.
                if (propertyValues[i] != null && Type.GetTypeCode(propertyValues[i].GetType()) != Type.GetTypeCode(propType))
                    throw new ArgumentException(Environment.GetResourceString("Argument_ConstantDoesntMatch"));
                
                // First a byte indicating that this is a property.
                writer.Write(SERIALIZATION_TYPE_PROPERTY);

                // Emit the property type, name and value.
                EmitType(writer, propType);
                EmitString(writer, namedProperties[i].Name);
                EmitValue(writer, propType, propertyValues[i]);
            }

            // Emit all the field sets.
            for (i = 0; i < namedFields.Length; i++)
            {
                // Validate the field.
                if (namedFields[i] == null)
                    throw new ArgumentNullException("namedFields[" + i + "]");

                // Allow null for non-primitive types only.
                Type fldType = namedFields[i].FieldType;
                if (fieldValues[i] == null && fldType.IsPrimitive)
                    throw new ArgumentNullException("fieldValues[" + i + "]");

                // Validate field type.
                if (!ValidateType(fldType))
                    throw new ArgumentException(Environment.GetResourceString("Argument_BadTypeInCustomAttribute"));

                // Field has to be from the same class or base class as ConstructorInfo.
                if (namedFields[i].DeclaringType != con.DeclaringType &&
                    !con.DeclaringType.IsSubclassOf(namedFields[i].DeclaringType))
                {
                    // Might have failed check because one type is a XXXBuilder
                    // and the other is not. Deal with these special cases
                    // separately.
                    if (!TypeBuilder.IsTypeEqual(namedFields[i].DeclaringType, con.DeclaringType))
                    {
                        // IsSubclassOf is overloaded to do the right thing if
                        // the constructor is a TypeBuilder, but we still need
                        // to deal with the case where the field's declaring
                        // type is one.
                        if (!(namedFields[i].DeclaringType is TypeBuilder) ||
                            !con.DeclaringType.IsSubclassOf(((TypeBuilder)namedFields[i].DeclaringType).m_runtimeType))
                            throw new ArgumentException(Environment.GetResourceString("Argument_BadFieldForConstructorBuilder"));
                    }
                }

                // Make sure the field's type can take the given value.
                // Note that there will no no coersion.
                if (fieldValues[i] != null && Type.GetTypeCode(fieldValues[i].GetType()) != Type.GetTypeCode(fldType))
                    throw new ArgumentException(Environment.GetResourceString("Argument_ConstantDoesntMatch"));
                
                // First a byte indicating that this is a field.
                writer.Write(SERIALIZATION_TYPE_FIELD);

                // Emit the field type, name and value.
                EmitType(writer, fldType);
                EmitString(writer, namedFields[i].Name);
                EmitValue(writer, fldType, fieldValues[i]);
            }

            // Create the blob array.
            m_blob = ((MemoryStream)writer.BaseStream).ToArray();
        }

        private void EmitType(BinaryWriter writer, Type type)
        {
            if (type.IsPrimitive)
            {
                switch (Type.GetTypeCode(type))
                {
                    case TypeCode.SByte:
                        writer.Write(SERIALIZATION_TYPE_I1);
                        break;
                    case TypeCode.Byte:
                        writer.Write(SERIALIZATION_TYPE_U1);
                        break;
                    case TypeCode.Char:
                        writer.Write(SERIALIZATION_TYPE_CHAR);
                        break;
                    case TypeCode.Boolean:
                        writer.Write(SERIALIZATION_TYPE_BOOLEAN);
                        break;
                    case TypeCode.Int16:
                        writer.Write(SERIALIZATION_TYPE_I2);
                        break;
                    case TypeCode.UInt16:
                        writer.Write(SERIALIZATION_TYPE_U2);
                        break;
                    case TypeCode.Int32:
                        writer.Write(SERIALIZATION_TYPE_I4);
                        break;
                    case TypeCode.UInt32:
                        writer.Write(SERIALIZATION_TYPE_U4);
                        break;
                    case TypeCode.Int64:
                        writer.Write(SERIALIZATION_TYPE_I8);
                        break;
                    case TypeCode.UInt64:
                        writer.Write(SERIALIZATION_TYPE_U8);
                        break;
                    case TypeCode.Single:
                        writer.Write(SERIALIZATION_TYPE_R4);
                        break;
                    case TypeCode.Double:
                        writer.Write(SERIALIZATION_TYPE_R8);
                        break;
                    default:
                        BCLDebug.Assert(false, "Invalid primitive type");
                        break;
                }
            }
            else if (type.IsEnum)
            {
                writer.Write(SERIALIZATION_TYPE_ENUM);
                EmitString(writer, type.AssemblyQualifiedName);
            }
            else if (type == typeof(String))
            {
                writer.Write(SERIALIZATION_TYPE_STRING);
            }
            else if (type == typeof(Type))
            {
                writer.Write(SERIALIZATION_TYPE_TYPE);
            }
            else if (type.IsArray)
            {
                writer.Write(SERIALIZATION_TYPE_SZARRAY);
                EmitType(writer, type.GetElementType());
            }
            else
            {
                // Tagged object case.
                writer.Write(SERIALIZATION_TYPE_TAGGED_OBJECT);
            }
        }

        private void EmitString(BinaryWriter writer, String str)
        {
            // Strings are emitted with a length prefix in a compressed format (1, 2 or 4 bytes) as used internally by metadata.
            byte[] utf8Str = Encoding.UTF8.GetBytes(str);
            uint length = (uint)utf8Str.Length;
            if (length <= 0x7f)
            {
                writer.Write((byte)length);
            }
            else if (length <= 0x3fff)
            {
                writer.Write((byte)((length >> 8) | 0x80));
                writer.Write((byte)(length & 0xff));
            }
            else
            {
                writer.Write((byte)((length >> 24) | 0xc0));
                writer.Write((byte)((length >> 16) & 0xff));
                writer.Write((byte)((length >> 8) & 0xff));
                writer.Write((byte)(length & 0xff));
            }
            writer.Write(utf8Str);
        }

        private void EmitValue(BinaryWriter writer, Type type, Object value)
        {
            if (type.IsEnum)
            {
                switch (Type.GetTypeCode(Enum.GetUnderlyingType(type)))
                {
                    case TypeCode.SByte:
                        writer.Write((sbyte)value);
                        break;
                    case TypeCode.Byte:
                        writer.Write((byte)value);
                        break;
                    case TypeCode.Int16:
                        writer.Write((short)value);
                        break;
                    case TypeCode.UInt16:
                        writer.Write((ushort)value);
                        break;
                    case TypeCode.Int32:
                        writer.Write((int)value);
                        break;
                    case TypeCode.UInt32:
                        writer.Write((uint)value);
                        break;
                    case TypeCode.Int64:
                        writer.Write((long)value);
                        break;
                    case TypeCode.UInt64:
                        writer.Write((ulong)value);
                        break;
                    default:
                        BCLDebug.Assert(false, "Invalid enum base type");
                        break;
                }
            }
            else if (type == typeof(String))
            {
                if (value == null)
                    writer.Write((byte)0xff);
                else
                    EmitString(writer, (String)value);
            }
            else if (type == typeof(Type))
            {
                if (value == null)
                    writer.Write((byte)0xff);
                else
                    EmitString(writer, ((Type)value).AssemblyQualifiedName);
            }
            else if (type.IsArray)
            {
                if (value == null)
                    writer.Write((uint)0xffffffff);
                else
                {
                    Array a = (Array)value;
                    Type et = type.GetElementType();
                    writer.Write(a.Length);
                    for (int i = 0; i < a.Length; i++)
                        EmitValue(writer, et, a.GetValue(i));
                }
            }
            else if (type.IsPrimitive)
            {
                switch (Type.GetTypeCode(type))
                {
                    case TypeCode.SByte:
                        writer.Write((sbyte)value);
                        break;
                    case TypeCode.Byte:
                        writer.Write((byte)value);
                        break;
                    case TypeCode.Char:
                        writer.Write(Convert.ToInt16((char)value));
                        break;
                    case TypeCode.Boolean:
                        writer.Write((byte)((bool)value ? 1 : 0));
                        break;
                    case TypeCode.Int16:
                        writer.Write((short)value);
                        break;
                    case TypeCode.UInt16:
                        writer.Write((ushort)value);
                        break;
                    case TypeCode.Int32:
                        writer.Write((int)value);
                        break;
                    case TypeCode.UInt32:
                        writer.Write((uint)value);
                        break;
                    case TypeCode.Int64:
                        writer.Write((long)value);
                        break;
                    case TypeCode.UInt64:
                        writer.Write((ulong)value);
                        break;
                    case TypeCode.Single:
                        writer.Write((float)value);
                        break;
                    case TypeCode.Double:
                        writer.Write((double)value);
                        break;
                    default:
                        BCLDebug.Assert(false, "Invalid primitive type");
                        break;
                }
            }
            else
            {
                // Tagged object case.
                Type ot = value.GetType();
                EmitType(writer, ot);
                EmitValue(writer, ot, value);
            }
        }

        // @todo: add another constructor to form serialized format. Brad is not sure if this will
        // exist or not. So we are not going to support it for this moment!

        // return the byte interpretation of the custom attribute
        internal void CreateCustomAttribute(ModuleBuilder mod, int tkOwner)
        {
            CreateCustomAttribute(mod, tkOwner, mod.GetConstructorToken(m_con).Token, false);
        }

        //*************************************************
        // Upon saving to disk, we need to create the memberRef token for the custom attribute's type
        // first of all. So when we snap the in-memory module for on disk, this token will be there.
        // We also need to enforce the use of MemberRef. Because MemberDef token might move. 
        // This function has to be called before we snap the in-memory module for on disk (i.e. Presave on
        // ModuleBuilder.
        //*************************************************
        internal int PrepareCreateCustomAttributeToDisk(ModuleBuilder mod)
        {
            return mod.InternalGetConstructorToken(m_con, true).Token;
        }

        //*************************************************
        // Call this function with toDisk=1, after on disk module has been snapped.
        //*************************************************
        internal void CreateCustomAttribute(ModuleBuilder mod, int tkOwner, int tkAttrib, bool toDisk)
        {
            TypeBuilder.InternalCreateCustomAttribute(tkOwner, tkAttrib, m_blob, mod, toDisk);
        }

        internal ConstructorInfo    m_con;
        internal Object[]           m_constructorArgs;
        private byte[]              m_blob;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\eventbuilder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  EventBuilder
**
** Author: Mei-Chin Tsai
**
** Eventbuilder is for client to define eevnts for a class
**
** Date: June 7, 99
** 
===========================================================*/
namespace System.Reflection.Emit {
    
	using System;
	using System.Reflection;
    // 
    // A EventBuilder is always associated with a TypeBuilder.  The TypeBuilder.DefineEvent
    // method will return a new EventBuilder to a client.
    // 
    /// <include file='doc\EventBuilder.uex' path='docs/doc[@for="EventBuilder"]/*' />
    public sealed class EventBuilder
    { 
    
    	// Make a private constructor so these cannot be constructed externally.
        private EventBuilder() {}
    	
        // Constructs a EventBuilder.  
    	//
        internal EventBuilder(
    		Module			mod,					// the module containing this EventBuilder		
    		String			name,					// Event name
    		EventAttributes attr,					// event attribute such as Public, Private, and Protected defined above
    		int				eventType,				// event type
    		TypeBuilder     type,                   // containing type
            EventToken		evToken)
        {   		
            m_name = name;
            m_module = mod;
            m_attributes = attr;
    		m_evToken = evToken;
            m_type = type;
        }
    
    	// Return the Token for this event within the TypeBuilder that the
    	// event is defined within.
        /// <include file='doc\EventBuilder.uex' path='docs/doc[@for="EventBuilder.GetEventToken"]/*' />
        public EventToken GetEventToken()
        {
            return m_evToken;
        }
    
    	// @todo: we need to add in the corresponding ones that take MethodInfo
    	/// <include file='doc\EventBuilder.uex' path='docs/doc[@for="EventBuilder.SetAddOnMethod"]/*' />
    	public void SetAddOnMethod(MethodBuilder mdBuilder)
    	{
            if (mdBuilder == null)
            {
    			throw new ArgumentNullException("mdBuilder");
            }
            
            m_type.ThrowIfCreated();
    		TypeBuilder.InternalDefineMethodSemantics(
    			m_module,
    			m_evToken.Token,
    			MethodSemanticsAttributes.AddOn, 
    			mdBuilder.GetToken().Token);
    	}
    
    
    	/// <include file='doc\EventBuilder.uex' path='docs/doc[@for="EventBuilder.SetRemoveOnMethod"]/*' />
    	public void SetRemoveOnMethod(MethodBuilder mdBuilder)
    	{
            if (mdBuilder == null)
            {
    			throw new ArgumentNullException("mdBuilder");
            }
            m_type.ThrowIfCreated();
    		TypeBuilder.InternalDefineMethodSemantics(
    			m_module,
    			m_evToken.Token,
    			MethodSemanticsAttributes.RemoveOn, 
    			mdBuilder.GetToken().Token);
    	}
    
    
    	/// <include file='doc\EventBuilder.uex' path='docs/doc[@for="EventBuilder.SetRaiseMethod"]/*' />
    	public void SetRaiseMethod(MethodBuilder mdBuilder)
    	{
            if (mdBuilder == null)
            {
    			throw new ArgumentNullException("mdBuilder");
            }
            m_type.ThrowIfCreated();
    		TypeBuilder.InternalDefineMethodSemantics(
    			m_module,
    			m_evToken.Token,
    			MethodSemanticsAttributes.Fire, 
    			mdBuilder.GetToken().Token);
    	}
    
    
    	/// <include file='doc\EventBuilder.uex' path='docs/doc[@for="EventBuilder.AddOtherMethod"]/*' />
    	public void AddOtherMethod(MethodBuilder mdBuilder)
    	{
            if (mdBuilder == null)
            {
    			throw new ArgumentNullException("mdBuilder");
            }

            m_type.ThrowIfCreated();
    		TypeBuilder.InternalDefineMethodSemantics(
    			m_module,
    			m_evToken.Token,
    			MethodSemanticsAttributes.Other, 
    			mdBuilder.GetToken().Token);
    	}
    
		// Use this function if client decides to form the custom attribute blob themselves
    	/// <include file='doc\EventBuilder.uex' path='docs/doc[@for="EventBuilder.SetCustomAttribute"]/*' />
    	public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)
    	{
    		if (con == null)
    			throw new ArgumentNullException("con");
    		if (binaryAttribute == null)
    			throw new ArgumentNullException("binaryAttribute");
            m_type.ThrowIfCreated();
    		
            TypeBuilder.InternalCreateCustomAttribute(
                m_evToken.Token,
                ((ModuleBuilder )m_module).GetConstructorToken(con).Token,
                binaryAttribute,
                m_module,
                false);
    	}

		// Use this function if client wishes to build CustomAttribute using CustomAttributeBuilder
        /// <include file='doc\EventBuilder.uex' path='docs/doc[@for="EventBuilder.SetCustomAttribute1"]/*' />
        public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
        {
            if (customBuilder == null)
            {
    			throw new ArgumentNullException("customBuilder");
            }
            m_type.ThrowIfCreated();
            customBuilder.CreateCustomAttribute((ModuleBuilder)m_module, m_evToken.Token);
        }

        // These are package private so that TypeBuilder can access them.
        private String				m_name;				// The name of the event
        private EventToken			m_evToken;			// The token of this event
        private Module				m_module;
    	private EventAttributes		m_attributes;
        private TypeBuilder         m_type;       
    }




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\eventtoken.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  EventToken	
**
** Author: Mei-Chin Tsai
**
** Propertybuilder is for client to define properties for a class
**
** Date: June 7, 99
** 
===========================================================*/
namespace System.Reflection.Emit {
    
	using System;
	using System.Reflection;
    /// <include file='doc\EventToken.uex' path='docs/doc[@for="EventToken"]/*' />
	[Serializable()] 
    public struct EventToken {

		/// <include file='doc\EventToken.uex' path='docs/doc[@for="EventToken.Empty"]/*' />
		public static readonly EventToken Empty = new EventToken();
    
        internal int m_event;
    
        //public EventToken() {
        //    m_event=0;
        //}
        
        /// <include file='doc\EventToken.uex' path='docs/doc[@for="EventToken.Token"]/*' />
        public int Token {
            get { return m_event; }
        }
        
    	// Satisfy JVC's value class requirements
    	/// <include file='doc\EventToken.uex' path='docs/doc[@for="EventToken.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
    		return m_event;
    	}
    	
    	// Satisfy JVC's value class requirements
    	/// <include file='doc\EventToken.uex' path='docs/doc[@for="EventToken.Equals"]/*' />
    	public override bool Equals(Object obj)
    	{
    		if (obj!=null && (obj is EventToken))
    			return ((EventToken)obj).m_event == m_event;
    		else
    			return false;
    	}
    }




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\enumbuilder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  EnumBuilder
**
** Author: Mei-Chin Tsai
**
** EnumBuilder is a helper class to build Enum ( a special type ). 
**
** Date:  Jan 2000
** 
===========================================================*/
namespace System.Reflection.Emit {
    
    using System;
    using System.Reflection;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.InteropServices;
    using CultureInfo = System.Globalization.CultureInfo;

    /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder"]/*' />
    sealed public class EnumBuilder : Type
    {

        // Define literal for enum
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.DefineLiteral"]/*' />

        public FieldBuilder DefineLiteral(String literalName, Object literalValue)
        {                                                                                
            BCLDebug.Log("DYNIL","## DYNIL LOGGING: EnumBuilder.DefineLiteral( " + literalName + " )");    

            // Define the underlying field for the enum. It will be a non-static, private field with special name bit set. 
            FieldBuilder fieldBuilder = m_typeBuilder.DefineField(
                literalName, 
                m_underlyingType, 
                FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
            fieldBuilder.SetConstant(literalValue);
            return fieldBuilder;
        }

        // CreateType cause EnumBuilder to be baked.
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.CreateType"]/*' />
        public Type CreateType() 
        {
            BCLDebug.Log("DYNIL","## DYNIL LOGGING: EnumBuilder.CreateType() ");
            return m_typeBuilder.CreateType();    
        }
    
        // Get the internal metadata token for this class.
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.TypeToken"]/*' />
        public TypeToken TypeToken {
            get {return  m_typeBuilder.TypeToken; }
        }

    
        // return the underlying field for the enum
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.UnderlyingField"]/*' />
        public FieldBuilder UnderlyingField {
            get {return  m_underlyingField; }
        }

        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.Name"]/*' />
        public override String Name {
            get { return m_typeBuilder.Name; }
        }
    
        /****************************************************
         * 
         * abstract methods defined in the base class
         * 
         */
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GUID"]/*' />
        public override Guid GUID {
            get {
                return m_typeBuilder.GUID;
            }
        }

        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.InvokeMember"]/*' />
        public override Object InvokeMember(
            String      name,
            BindingFlags invokeAttr,
            Binder     binder,
            Object      target,
            Object[]   args,
            ParameterModifier[]       modifiers,
            CultureInfo culture,
            String[]    namedParameters)
        {
            return m_typeBuilder.InvokeMember(name, invokeAttr, binder, target, args, modifiers, culture, namedParameters);
        }
        
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.Module"]/*' />
        public override Module Module {
            get {return m_typeBuilder.Module;}
        }
        
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.Assembly"]/*' />
        public override Assembly Assembly {
            get {return m_typeBuilder.Assembly;}
        }

        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.TypeHandle"]/*' />
        public override RuntimeTypeHandle TypeHandle {
            get {return m_typeBuilder.TypeHandle;}
        }
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.FullName"]/*' />
        public override String FullName {
            get { return m_typeBuilder.FullName;}
        }
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.AssemblyQualifiedName"]/*' />
        public override String AssemblyQualifiedName {
            get { 
                return m_typeBuilder.AssemblyQualifiedName;
            }
        }
            
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.Namespace"]/*' />
        public override String Namespace {
            get { return m_typeBuilder.Namespace;}
        }
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.BaseType"]/*' />
        public override Type BaseType {
            get{return m_typeBuilder.BaseType;}
        }
        
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetConstructorImpl"]/*' />
        protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr,Binder binder,
                CallingConventions callConvention, Type[] types,ParameterModifier[] modifiers)
        {
            return m_typeBuilder.GetConstructor(bindingAttr, binder, callConvention,
                            types, modifiers);
        }
        
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetConstructors"]/*' />
        public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
        {
            return m_typeBuilder.GetConstructors(bindingAttr);
        }
        
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetMethodImpl"]/*' />
        protected override MethodInfo GetMethodImpl(String name,BindingFlags bindingAttr,Binder binder,
                CallingConventions callConvention, Type[] types,ParameterModifier[] modifiers)
        {
            if (types == null)
                return m_typeBuilder.GetMethod(name, bindingAttr);
            else
                return m_typeBuilder.GetMethod(name, bindingAttr, binder, callConvention, types, modifiers);
        }
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetMethods"]/*' />
        public override MethodInfo[] GetMethods(BindingFlags bindingAttr)
        {
            return m_typeBuilder.GetMethods(bindingAttr);
        }
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetField"]/*' />
        public override FieldInfo GetField(String name, BindingFlags bindingAttr)
        {
            return m_typeBuilder.GetField(name, bindingAttr);
        }
        
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetFields"]/*' />
        public override FieldInfo[] GetFields(BindingFlags bindingAttr)
        {
            return m_typeBuilder.GetFields(bindingAttr);
        }
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetInterface"]/*' />
        public override Type GetInterface(String name, bool ignoreCase)
        {
            return m_typeBuilder.GetInterface(name, ignoreCase);
        }
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetInterfaces"]/*' />
        public override Type[] GetInterfaces()
        {
            return m_typeBuilder.GetInterfaces();
        }
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetEvent"]/*' />
        public override EventInfo GetEvent(String name, BindingFlags bindingAttr)
        {
            return m_typeBuilder.GetEvent(name, bindingAttr);
        }
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetEvents"]/*' />
        public override EventInfo[] GetEvents()
        {
            return m_typeBuilder.GetEvents();
        }
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetPropertyImpl"]/*' />
        protected override PropertyInfo GetPropertyImpl(String name, BindingFlags bindingAttr, Binder binder, 
                Type returnType, Type[] types, ParameterModifier[] modifiers)
        {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetProperties"]/*' />
        public override PropertyInfo[] GetProperties(BindingFlags bindingAttr)
        {
            return m_typeBuilder.GetProperties(bindingAttr);
        }

        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetNestedTypes"]/*' />
        public override Type[] GetNestedTypes(BindingFlags bindingAttr)
        {
            return m_typeBuilder.GetNestedTypes(bindingAttr);
        }

        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetNestedType"]/*' />
        public override Type GetNestedType(String name, BindingFlags bindingAttr)
        {
            return m_typeBuilder.GetNestedType(name,bindingAttr);
        }
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetMember"]/*' />
        public override MemberInfo[] GetMember(String name,  MemberTypes type, BindingFlags bindingAttr)
        {
            return m_typeBuilder.GetMember(name, type, bindingAttr);
        }
        
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetMembers"]/*' />
        public override MemberInfo[] GetMembers(BindingFlags bindingAttr)
        {
            return m_typeBuilder.GetMembers(bindingAttr);
        }

        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetInterfaceMap"]/*' />
        public override InterfaceMapping GetInterfaceMap(Type interfaceType)
		{
            return m_typeBuilder.GetInterfaceMap(interfaceType);
		}

        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetEvents1"]/*' />
        public override EventInfo[] GetEvents(BindingFlags bindingAttr)
		{
            return m_typeBuilder.GetEvents(bindingAttr);
		}
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetAttributeFlagsImpl"]/*' />
        protected override TypeAttributes GetAttributeFlagsImpl()
        {
            return m_typeBuilder.m_iAttr;
        }
        
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.IsArrayImpl"]/*' />
        protected override bool IsArrayImpl()
        {
            return false;
        }
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.IsPrimitiveImpl"]/*' />
        protected override bool IsPrimitiveImpl()
        {
            return false;
        }

        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.IsValueTypeImpl"]/*' />
        protected override bool IsValueTypeImpl() 
        {
            return true;
        }

        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.IsByRefImpl"]/*' />
        protected override bool IsByRefImpl()
        {
            return false;
        }

        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.IsPointerImpl"]/*' />
        protected override bool IsPointerImpl()
        {
            return false;
        }
        
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.IsCOMObjectImpl"]/*' />
        protected override bool IsCOMObjectImpl()
        {
            return false;
        }
            
        
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetElementType"]/*' />
        public override Type GetElementType()
        {
            return m_typeBuilder.GetElementType();
        }

        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.HasElementTypeImpl"]/*' />
        protected override bool HasElementTypeImpl()
        {
            return m_typeBuilder.HasElementType;
        }
    
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.UnderlyingSystemType"]/*' />
        public override Type UnderlyingSystemType {
            get {
                return m_underlyingType;
            }
        }
            
        //ICustomAttributeProvider
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetCustomAttributes"]/*' />
        public override Object[] GetCustomAttributes(bool inherit)
        {
            return m_typeBuilder.GetCustomAttributes(inherit);
        }

        // Return a custom attribute identified by Type
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.GetCustomAttributes1"]/*' />
        public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
            return m_typeBuilder.GetCustomAttributes(attributeType, inherit);
        }

       // Use this function if client decides to form the custom attribute blob themselves
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.SetCustomAttribute"]/*' />
        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)
        {
             m_typeBuilder.SetCustomAttribute(con, binaryAttribute);
        }

       // Use this function if client wishes to build CustomAttribute using CustomAttributeBuilder
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.SetCustomAttribute1"]/*' />
        public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
        {
            m_typeBuilder.SetCustomAttribute(customBuilder);
        }

        // Return the class that declared this Field.
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.DeclaringType"]/*' />
        public override Type DeclaringType {
                get {return m_typeBuilder.DeclaringType;}
        }

        // Return the class that was used to obtain this field.
        // @todo: fix this to return enclosing type if nested
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.ReflectedType"]/*' />
        public override Type ReflectedType {
                get {return m_typeBuilder.ReflectedType;}
        }


       // Returns true if one or more instance of attributeType is defined on this member. 
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.IsDefined"]/*' />
        public override bool IsDefined (Type attributeType, bool inherit)
        {
            return m_typeBuilder.IsDefined(attributeType, inherit);
        }


        internal override int InternalGetTypeDefToken()
        {
            return m_typeBuilder.InternalGetTypeDefToken();
        }
    
        /*
        /// <include file='doc\EnumBuilder.uex' path='docs/doc[@for="EnumBuilder.EnumBuilder"]/*' />
        public TypeToken TypeToken {
            get { return m_typeBuilder.TypeToken; }
        }
        */
        
        /*****************************************************
         * 
         * private/protected functions
         * 
         */
    
        //*******************************
    	// Make a private constructor so these cannot be constructed externally.
        //*******************************
        private EnumBuilder() {}

            
        // Constructs a EnumBuilder. 
        internal EnumBuilder(
            String      name,                       // name of type
            Type        underlyingType,             // underlying type for an Enum
            TypeAttributes visibility,              // any bits on TypeAttributes.VisibilityMask)
            Module      module)                     // module containing this type
        {
            // Client should not set any bits other than the visibility bits.
            if ((visibility & ~TypeAttributes.VisibilityMask) != 0)
                throw new ArgumentException(Environment.GetResourceString("Argument_ShouldOnlySetVisibilityFlags"), "name");
            m_typeBuilder = new TypeBuilder(name, visibility | TypeAttributes.Sealed, typeof(System.Enum), null, module, PackingSize.Unspecified, null);
            m_underlyingType = underlyingType;

            // Define the underlying field for the enum. It will be a non-static, private field with special name bit set. 
            // @todo: Billev 
            // Please change the underlying field when we have a final decision
            m_underlyingField = m_typeBuilder.DefineField("value__", underlyingType, FieldAttributes.Private| FieldAttributes.SpecialName);
        }
        
    
        /*****************************************************
         * 
         * private data members
         * 
         */
        private Type            m_underlyingType;
        internal TypeBuilder    m_typeBuilder;
        private FieldBuilder    m_underlyingField;
        internal Type           m_runtimeType = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\flowcontrol.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
**Class: FlowControl
**
**Author: Craig Schertz (cschertz)
**
**Purpose: Exposes FlowControl Attribute of IL .
**
** THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT BY HAND!
** See cschertz for more information.**
============================================================*/
namespace System.Reflection.Emit {

using System;

/// <include file='doc\FlowControl.uex' path='docs/doc[@for="FlowControl"]/*' />
[Serializable]
public enum FlowControl
{

	/// <include file='doc\FlowControl.uex' path='docs/doc[@for="FlowControl.Branch"]/*' />
	Branch	= 0,
	/// <include file='doc\FlowControl.uex' path='docs/doc[@for="FlowControl.Break"]/*' />
	Break	= 1,
	/// <include file='doc\FlowControl.uex' path='docs/doc[@for="FlowControl.Call"]/*' />
	Call	= 2,
	/// <include file='doc\FlowControl.uex' path='docs/doc[@for="FlowControl.Cond_Branch"]/*' />
	Cond_Branch	= 3,
	/// <include file='doc\FlowControl.uex' path='docs/doc[@for="FlowControl.Meta"]/*' />
	Meta	= 4,
	/// <include file='doc\FlowControl.uex' path='docs/doc[@for="FlowControl.Next"]/*' />
	Next	= 5,
	/// <include file='doc\FlowControl.uex' path='docs/doc[@for="FlowControl.Phi"]/*' />
	/// <internalonly/>
	Phi	= 6,
	/// <include file='doc\FlowControl.uex' path='docs/doc[@for="FlowControl.Return"]/*' />
	Return	= 7,
	/// <include file='doc\FlowControl.uex' path='docs/doc[@for="FlowControl.Throw"]/*' />
	Throw	= 8,
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\fieldbuilder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

namespace System.Reflection.Emit {
    using System.Runtime.InteropServices;
    using System;
    using CultureInfo = System.Globalization.CultureInfo;
    using System.Reflection;
    /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder"]/*' />
    public sealed class FieldBuilder : FieldInfo
    {
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.GetToken"]/*' />
        public FieldToken GetToken() 
        {
            return m_tkField;
        }
    
        // set the field offset
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.SetOffset"]/*' />
        public void SetOffset(int iOffset) 
        {
            m_typeBuilder.ThrowIfCreated();        
            TypeBuilder.InternalSetFieldOffset(m_typeBuilder.Module, GetToken().Token, iOffset);
        }
    
        // set FieldMarshal
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.SetMarshal"]/*' />
        public void SetMarshal(UnmanagedMarshal unmanagedMarshal)
        {
            m_typeBuilder.ThrowIfCreated();        
            
            if (unmanagedMarshal == null)
            {
                throw new ArgumentNullException("unmanagedMarshal");
            }
            byte []        ubMarshal = unmanagedMarshal.InternalGetBytes();
            TypeBuilder.InternalSetMarshalInfo(m_typeBuilder.Module, GetToken().Token, ubMarshal, ubMarshal.Length);
        }
    
        // Set the default value of the field
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.SetConstant"]/*' />
        public void SetConstant(Object defaultValue) 
        {
            m_typeBuilder.ThrowIfCreated();        
            TypeBuilder.SetConstantValue(m_typeBuilder.Module, GetToken().Token, m_fieldType, defaultValue);
        }
        
        internal void SetData(byte[] data, int size)
        {
            if (data != null)
            {
                m_data = new byte[data.Length];
                Array.Copy(data, m_data, data.Length);
            }
            m_typeBuilder.Module.InternalSetFieldRVAContent(m_tkField.Token, data, size);
        }

        //*******************************
        // Make a private constructor so these cannot be constructed externally.
        //*******************************
        private FieldBuilder() {}

        
        internal FieldBuilder(TypeBuilder typeBuilder, String fieldName, Type type, FieldAttributes attributes)
        {
            if (fieldName==null)
                throw new ArgumentNullException("fieldName");
            if (fieldName.Length == 0)
                throw new ArgumentException(Environment.GetResourceString("Argument_EmptyName"), "fieldName");
            if (fieldName[0] == '\0')
                throw new ArgumentException(Environment.GetResourceString("Argument_IllegalName"), "fieldName");
            if (type==null)
                throw new ArgumentNullException("type");
            if (type == SystemVoid)
                throw new ArgumentException(Environment.GetResourceString("Argument_BadFieldType"));
    
            m_fieldName = fieldName;
            m_typeBuilder = typeBuilder;
            m_fieldType = type;
            m_Attributes = attributes;
            
            SignatureHelper sigHelp = SignatureHelper.GetFieldSigHelper(m_typeBuilder.Module);
            sigHelp.AddArgument(type);
    
            int sigLength;
            byte[] signature = sigHelp.InternalGetSignature(out sigLength);
            
            m_tkField = new FieldToken(TypeBuilder.InternalDefineField(
                typeBuilder.TypeToken, 
                fieldName, 
                signature, 
                sigLength, 
                attributes, 
                m_typeBuilder.Module), type);
        }
    
        /********************************************
         * abstract method inherited
         ********************************************/
    
        // Return the Type that represents the type of the field
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.FieldType"]/*' />
        public override Type FieldType {
            get { return m_fieldType; }
        }
    
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.GetValue"]/*' />
        public override Object GetValue(Object obj)
        { 
            // NOTE!!  If this is implemented, make sure that this throws 
            // a NotSupportedException for Save-only dynamic assemblies.
            // Otherwise, it could cause the .cctor to be executed.

            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }
    
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.SetValue"]/*' />
        public override void SetValue(Object obj,Object val,BindingFlags invokeAttr,Binder binder,CultureInfo culture)
        { 
            // NOTE!!  If this is implemented, make sure that this throws 
            // a NotSupportedException for Save-only dynamic assemblies.
            // Otherwise, it could cause the .cctor to be executed.

            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }
    
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.Name"]/*' />
        public override String Name {
            get {return m_fieldName; }
        }

        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.DeclaringType"]/*' />
        public override Type DeclaringType {
            get {
                if (m_typeBuilder.m_isHiddenGlobalType == true)
                    return null;
                return m_typeBuilder;
            }
        }
        
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.ReflectedType"]/*' />
        public override Type ReflectedType {
            get {
                if (m_typeBuilder.m_isHiddenGlobalType == true)
                    return null;
                return m_typeBuilder;
            }
        }

        // Field Handle routines
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.FieldHandle"]/*' />
        public override RuntimeFieldHandle FieldHandle {
            get {throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));}
        }
    
        // Property representing the Attributes associated with a Member.  All 
        // members have a set of attributes which are defined in relation to 
        // the specific type of member.
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.Attributes"]/*' />
        public override FieldAttributes Attributes {
            get {return m_Attributes;}
        }
    

        // ICustomAttributeProvider
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.GetCustomAttributes"]/*' />
        public override Object[] GetCustomAttributes(bool inherit)
        {
            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }
            
        // Return a custom attribute identified by Type
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.GetCustomAttributes1"]/*' />
        public override Object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }

        // Use this function if client decides to form the custom attribute blob themselves
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.SetCustomAttribute"]/*' />
        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)
        {
            ModuleBuilder module = (ModuleBuilder)  m_typeBuilder.Module;
            m_typeBuilder.ThrowIfCreated();        
            if (con == null)
                throw new ArgumentNullException("con");
            if (binaryAttribute == null)
                throw new ArgumentNullException("binaryAttribute");
            
            TypeBuilder.InternalCreateCustomAttribute(
                m_tkField.Token,
                module.GetConstructorToken(con).Token,
                binaryAttribute,
                module,
                false);
        }

        // Use this function if client wishes to build CustomAttribute using CustomAttributeBuilder
        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.SetCustomAttribute1"]/*' />
        public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
        {
            m_typeBuilder.ThrowIfCreated();        
            if (customBuilder == null)
            {
                throw new ArgumentNullException("customBuilder");
            }
            ModuleBuilder module = (ModuleBuilder)  m_typeBuilder.Module;
            customBuilder.CreateCustomAttribute(module, m_tkField.Token);
        }

        /// <include file='doc\FieldBuilder.uex' path='docs/doc[@for="FieldBuilder.IsDefined"]/*' />
        public override bool IsDefined(Type attributeType, bool inherit)
        {
            // @todo: implement this
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
        }
   
        internal TypeBuilder GetTypeBuilder() { return m_typeBuilder;}

        /**********************************************
         *
         * Private data members
         *
         ***********************************************/
        private FieldToken      m_tkField;
        private TypeBuilder     m_typeBuilder;
        private String          m_fieldName;
        private FieldAttributes m_Attributes;
        private Type            m_fieldType;
        internal byte[]         m_data;
        internal static readonly Type SystemVoid         = typeof(void);
        internal static readonly Type SystemEmpty        = typeof(System.Empty);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\fieldtoken.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  FieldToken
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Represents a Field to the ILGenerator Class
**
** Date:  December 15, 1998
** 
===========================================================*/
namespace System.Reflection.Emit {
    
	using System;
	using System.Reflection;
    // The FieldToken class is an opaque representation of the Token returned
    // by the MetaData to represent the field.  FieldTokens are generated by 
    // Module.GetFieldToken().  There are no meaningful accessors on this class,
    // but it can be passed to ILGenerator which understands it's internals.
    /// <include file='doc\FieldToken.uex' path='docs/doc[@for="FieldToken"]/*' />
	[Serializable()] 
    public struct FieldToken {
    
		/// <include file='doc\FieldToken.uex' path='docs/doc[@for="FieldToken.Empty"]/*' />
		public static readonly FieldToken Empty = new FieldToken();

        internal int m_fieldTok;
        internal Object m_class;
    
        // Creates an empty FieldToken.  A publicly visible constructor so that
        // it can be created on the stack.
        //public FieldToken() {
        //    m_fieldTok=0;
        //    m_attributes=0;
        //    m_class=null;
        //}
        // The actual constructor.  Sets the field, attributes and class
        // variables
    
        internal FieldToken (int field, Type fieldClass) {
            m_fieldTok=field;
            m_class = fieldClass;
        }
    	
        /// <include file='doc\FieldToken.uex' path='docs/doc[@for="FieldToken.Token"]/*' />
        public int Token {
            get { return m_fieldTok; }
        }
        
    
        // Generates the hash code for this field.  Fulfills jvc's requirement
        // that all value classes implement GetHashCode.
        /// <include file='doc\FieldToken.uex' path='docs/doc[@for="FieldToken.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return (m_fieldTok);
        }
    
        // Returns true if obj is an instance of FieldToken and is 
        // equal to this instance.  Fulfills jvc's requirement that all value
        // classes implement Equals.
        /// <include file='doc\FieldToken.uex' path='docs/doc[@for="FieldToken.Equals"]/*' />
        public override bool Equals(Object obj)
        {
            if (obj!=null && (obj is FieldToken)) {
                FieldToken that = (FieldToken) obj;
                return (that.m_fieldTok == m_fieldTok && that.m_class == m_class);
            }
            else
                return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\localbuilder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  LocalBuilder
**
** Author: Mei-Chin Tsai
**
** LocalBuilder represent a local within a Method. Get to LocalBuilder from ILGenerator:DeclareLocal
**
** Date:  Feb, 2000
** 
===========================================================*/

namespace System.Reflection.Emit {
    
	using System;
	using System.Reflection;
    /// <include file='doc\LocalBuilder.uex' path='docs/doc[@for="LocalBuilder"]/*' />
    public sealed class LocalBuilder
    { 

    	/***************************************
    	 * Set the current local variable's name
    	**********************************************/
        /// <include file='doc\LocalBuilder.uex' path='docs/doc[@for="LocalBuilder.SetLocalSymInfo"]/*' />
        public void SetLocalSymInfo(	
            String 	    name)
        {
            SetLocalSymInfo(name, 0, 0);
        }
    
    	/***************************************
    	 * Set current local variable's name and also the variable scope
    	**********************************************/
        /// <include file='doc\LocalBuilder.uex' path='docs/doc[@for="LocalBuilder.SetLocalSymInfo1"]/*' />
        public void SetLocalSymInfo(
            String 	    name, 
            int 		startOffset,            // this pair of offset declare the scope of the local
            int 		endOffset)
        {
            ModuleBuilder   dynMod;
            SignatureHelper sigHelp;
            int             sigLength;
            byte[]          signature;
            byte[]          mungedSig;
            int             index;

            dynMod = (ModuleBuilder) m_methodBuilder.DeclaringType.Module;
            if (m_methodBuilder.IsTypeCreated())
            {
                // cannot change method after its containing type has been created
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_TypeHasBeenCreated"));
            }
    
            // set the name and range of offset for the local
            if (dynMod.GetSymWriter() == null)
            {
                // cannot set local name if not debug module
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_NotADebugModule"));
            }
    
            sigHelp = SignatureHelper.GetFieldSigHelper(dynMod);
            sigHelp.AddArgument(m_localType);
            signature = sigHelp.InternalGetSignature(out sigLength);
    
            // The symbol store doesn't want the calling convention on the
            // front of the signature, but InternalGetSignature returns
            // the callinging convention. So we strip it off. This is a
            // bit unfortunate, since it means that we need to allocate
            // yet another array of bytes... ugh...
            mungedSig = new byte[sigLength - 1];
            Array.Copy(signature, 1, mungedSig, 0, sigLength - 1);
            
            index = m_methodBuilder.GetILGenerator().m_ScopeTree.GetCurrentActiveScopeIndex();
            if (index == -1)
            {
                // top level scope information is kept with methodBuilder
                m_methodBuilder.m_localSymInfo.AddLocalSymInfo(
                     name,
                     mungedSig,
                     m_localIndex,   
                     startOffset,
                     endOffset);
            }
            else
            {
                m_methodBuilder.GetILGenerator().m_ScopeTree.AddLocalSymInfoToCurrentScope(
                     name,
                     mungedSig,
                     m_localIndex,   
                     startOffset,
                     endOffset);
            }
        }

        internal int GetLocalIndex() 
        {
            return m_localIndex;
        }

        internal MethodBuilder GetMethodBuilder() 
        {
            return m_methodBuilder;
        }
    	/// <include file='doc\LocalBuilder.uex' path='docs/doc[@for="LocalBuilder.LocalType"]/*' />
    	public Type LocalType {
    		get { return m_localType; }
    	}
        
    
        //*******************************
    	// Make a private constructor so these cannot be constructed externally.
        //*******************************
        private LocalBuilder() {}

        
        //*******************************
        // Internal constructor.
        //*******************************
        internal LocalBuilder(int localIndex, Type localType, MethodBuilder methodBuilder) 
        {
            m_localIndex = localIndex;
            m_localType = localType;
            m_methodBuilder = methodBuilder;
        }

        private int         m_localIndex;                   // index in the local signature
        private Type        m_localType;
        private MethodBuilder m_methodBuilder;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\label.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Label
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Represents a Label to the ILGenerator class.
**
** Date:  December 4, 1998
** 
===========================================================*/
namespace System.Reflection.Emit {
	using System;
	using System.Reflection;
    // The Label class is an opaque representation of a label used by the 
    // ILGenerator class.  The token is used to mark where labels occur in the IL
    // stream and then the necessary offsets are put back in the code when the ILGenerator 
    // is passed to the MethodWriter.
    // Labels are created by using ILGenerator.CreateLabel and their position is set
    // by using ILGenerator.MarkLabel.
    /// <include file='doc\Label.uex' path='docs/doc[@for="Label"]/*' />
	[Serializable()] 
    public struct Label {
    
        internal int m_label;
    
        //public Label() {
        //    m_label=0;
        //}
        
        internal Label (int label) {
            m_label=label;
        }
    
        internal int GetLabelValue() {
            return m_label;
        }
    	
        // Satisfy JVC's value class requirements
        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return m_label;
        }
    	
        // Satisfy JVC's value class requirements
        /// <include file='doc\Label.uex' path='docs/doc[@for="Label.Equals"]/*' />
        public override bool Equals(Object obj)
        {
            if (obj!=null && (obj is Label))
                return ((Label)obj).m_label == m_label;
            else
                return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\localtoken.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  LocalToken
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Represents a Local to the ILGenerator class.
**
** Date:  December 4, 1998
** 
===========================================================*/
namespace System.Reflection.Emit {
    
	using System;
	using System.Reflection;
    /// <include file='doc\LocalToken.uex' path='docs/doc[@for="LocalToken"]/*' />
	[Serializable()] 
    internal struct LocalToken {

		public static readonly LocalToken Empty = new LocalToken();
    
        internal int m_local;
        internal Object m_class;
    
        //public LocalToken() {
        //    m_local=0;
        //    m_class=null;
        //}
        
        internal LocalToken(int local, Type cls) {
            m_local=local;
            m_class = cls;
        }
    
    	// @deprecated: remove this since
    	// TypeBuilder is now deriving from Type
        internal LocalToken(int local, TypeBuilder cls) {
            m_local=local;
            m_class = (Object)cls;
        }
    
        internal int GetLocalValue() {
            return m_local;
        }
    
        internal Object GetClassType() {
            return m_class;
        }
    
    	// Satisfy JVC's value class requirements
    	/// <include file='doc\LocalToken.uex' path='docs/doc[@for="LocalToken.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
    		return m_local;
    	}
    	
    	// Satisfy JVC's value class requirements
    	/// <include file='doc\LocalToken.uex' path='docs/doc[@for="LocalToken.Equals"]/*' />
    	public override bool Equals(Object obj)
    	{
    		if (obj!=null && (obj is LocalToken)) {
    			LocalToken that = (LocalToken) obj;
    			return (that.m_class == m_class && that.m_local == m_local);
    		}
    		else
    			return false;
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\methodrental.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  MethodRental
**
** Author: Mei-Chin Tsai (meichint)
**
** MethodRental class is to provide a fast way to swap method body implementation
**  given a method of a class
**
** Date:  May 1999
** 
===========================================================*/
namespace System.Reflection.Emit {
    
	using System;
	using System.Reflection;
    using System.Threading;
	using System.Runtime.CompilerServices;
    using System.Security.Permissions;

    // MethodRental class provides the ability to insert a new method body of an 
    // existing method on a class defined in a DynamicModule.
    // Can throw OutOfMemory exception.
    // 
    //This class contains only static methods and does not require serialization.p
    /// <include file='doc\MethodRental.uex' path='docs/doc[@for="MethodRental"]/*' />
    sealed public class MethodRental
    {
    	/// <include file='doc\MethodRental.uex' path='docs/doc[@for="MethodRental.JitOnDemand"]/*' />
    	public const int JitOnDemand			= 0x0000;		// jit the method body when it is necessary
    	/// <include file='doc\MethodRental.uex' path='docs/doc[@for="MethodRental.JitImmediate"]/*' />
    	public const int JitImmediate		= 0x0001;		// jit the method body now 
    
    	/// <include file='doc\MethodRental.uex' path='docs/doc[@for="MethodRental.SwapMethodBody"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, UnmanagedCode=true)]
        public static void SwapMethodBody(
    		Type		cls,				// [in] class containing the method
    		int			methodtoken,		// [in] method token
    		IntPtr		rgIL,				// [in] pointer to bytes
    		int			methodSize,			// [in] the size of the new method body in bytes
    		int			flags)				// [in] flags
		{
            if (methodSize <= 0 || methodSize >= 0x3f0000)
                throw new ArgumentException(Environment.GetResourceString("Argument_BadSizeForData"), "methodSize");

            if (cls==null)
                throw new ArgumentNullException("cls");
                
            // can only swap method body on dynamic module
			if (!(cls.Module is ModuleBuilder))
				throw new NotSupportedException(Environment.GetResourceString("NotSupported_NotDynamicModule"));

            RuntimeType rType;

            if (cls is TypeBuilder)
            {
                // If it is a TypeBuilder, make sure that TypeBuilder is already been baked.
                TypeBuilder typeBuilder = (TypeBuilder) cls;
                if (typeBuilder.m_hasBeenCreated == false)
                    throw new NotSupportedException(String.Format(Environment.GetResourceString("NotSupported_NotAllTypesAreBaked"), typeBuilder.Name)); 
                    
                // get the corresponding runtime type for the TypeBuilder.
                rType = typeBuilder.m_runtimeType as RuntimeType;
                
            }
            else
            {
                rType = cls as RuntimeType;
            }

            if (rType == null)
                throw new ArgumentException(Environment.GetResourceString("Argument_MustBeRuntimeType"), "cls");

            StackCrawlMark mark = StackCrawlMark.LookForMyCaller;

            SwapMethodBodyHelper(rType, methodtoken, rgIL, methodSize, flags, ref mark);
		}
    
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern static void SwapMethodBodyHelper(
    		RuntimeType	cls,				// [in] class containing the method
    		int			methodtoken,		// [in] method token
    		IntPtr		rgIL,				// [in] pointer to bytes
    		int			methodSize,			// [in] the size of the new method body in bytes
            int         flags,              // [in] flags
            ref StackCrawlMark stackMark);  // [in] stack crawl mark used to find caller

    	// private constructor to prevent class to be constructed.
    	private MethodRental() {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\methodtoken.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  MethodToken
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Represents a Method to the ILGenerator class.
**
** Date:  December 4, 1998
** 
===========================================================*/
namespace System.Reflection.Emit {
    
	using System;
	using System.Reflection;
    /// <include file='doc\MethodToken.uex' path='docs/doc[@for="MethodToken"]/*' />
	[Serializable()] 
    public struct MethodToken {
    
		/// <include file='doc\MethodToken.uex' path='docs/doc[@for="MethodToken.Empty"]/*' />
		public static readonly MethodToken Empty = new MethodToken();
        internal int m_method;
    
        //public MethodToken() {
        //    m_method=0;
        //}
        
        internal MethodToken(int str) {
            m_method=str;
        }
    
        /// <include file='doc\MethodToken.uex' path='docs/doc[@for="MethodToken.Token"]/*' />
        public int Token {
            get { return m_method; }
        }
        
  		// Satisfy JVC's value class requirements
    	/// <include file='doc\MethodToken.uex' path='docs/doc[@for="MethodToken.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
    		return m_method;
    	}
    	
    	// Satisfy JVC's value class requirements
    	/// <include file='doc\MethodToken.uex' path='docs/doc[@for="MethodToken.Equals"]/*' />
    	public override bool Equals(Object obj)
    	{
    		if (obj!=null && (obj is MethodToken))
    			return ((MethodToken)obj).m_method == m_method;
    		else
    			return false;
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\modulebuilderdata.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

namespace System.Reflection.Emit {    
    using System;
    using System.Reflection;
    using System.IO;
    
    // This is a package private class. This class hold all of the managed
    // data member for ModuleBuilder. Note that what ever data members added to
    // this class cannot be accessed from the EE.
    [Serializable()]
    internal class ModuleBuilderData
    {
        internal ModuleBuilderData(ModuleBuilder module, String strModuleName, String strFileName)
        {
            Init(module, strModuleName, strFileName);
        }
    
        internal virtual void Init(ModuleBuilder module, String strModuleName, String strFileName)
        {
            m_fGlobalBeenCreated = false;
            m_fHasGlobal = false;
            m_globalTypeBuilder = new TypeBuilder(module);
            m_module = module;
            m_strModuleName = strModuleName;
            m_tkFile = 0;
            m_isSaved = false;
            m_embeddedRes = null;
            m_strResourceFileName = null;
            m_resourceBytes = null;
            m_fHasExplicitUnmanagedResource = false;
            if (strFileName == null)
            {
                // fake a transient module file name
                m_strFileName = strModuleName;
                m_isTransient = true;
            }
            else
            {
                String strExtension = Path.GetExtension(strFileName);
                if (strExtension == null || strExtension == String.Empty)
                {                    
                    // This is required by our loader. It cannot load module file that does not have file extension.
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_NoModuleFileExtension"), strFileName)); 
                } 
                m_strFileName = strFileName; 
                m_isTransient = false; 
            }
            m_module.InternalSetModuleProps(m_strModuleName);
        }
        internal virtual bool IsTransient()
        {
            return m_isTransient;
        }
        
        internal String      m_strModuleName; // scope name (can be different from file name)
        internal String      m_strFileName;
        internal bool        m_fGlobalBeenCreated;   
        internal bool        m_fHasGlobal;   
        internal TypeBuilder m_globalTypeBuilder;
        internal ModuleBuilder m_module;
        internal int         m_tkFile;           // this is the file token for this module builder
        internal bool        m_isSaved;
        internal ResWriterData m_embeddedRes;
        internal static readonly String MULTI_BYTE_VALUE_CLASS = "$ArrayType$";
        internal bool        m_isTransient;
        internal bool        m_fHasExplicitUnmanagedResource;
        internal String      m_strResourceFileName;
        internal byte[]      m_resourceBytes;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\opcode.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Reflection.Emit {
using System;
/// <include file='doc\Opcode.uex' path='docs/doc[@for="OpCode"]/*' />
public struct OpCode
{
	internal String m_stringname;
	internal StackBehaviour m_pop;
	internal StackBehaviour m_push;
	internal OperandType m_operand;
	internal OpCodeType m_type;
	internal int m_size;
	internal byte m_s1;
	internal byte m_s2;
	internal FlowControl m_ctrl;

	// Specifies whether the current instructions causes the control flow to
	// change unconditionally.
	internal bool m_endsUncondJmpBlk;


	// Specifies the stack change that the current instruction causes not
	// taking into account the operand dependant stack changes.
	internal int m_stackChange;

	internal OpCode(String stringname, StackBehaviour pop, StackBehaviour push, OperandType operand, OpCodeType type, int size, byte s1, byte s2, FlowControl ctrl, bool endsjmpblk, int stack)
	{
		m_stringname = stringname;
		m_pop = pop;
		m_push = push;
		m_operand = operand;
		m_type = type;
		m_size = size;
		m_s1 = s1;
		m_s2 = s2;
		m_ctrl = ctrl;
		m_endsUncondJmpBlk = endsjmpblk;
		m_stackChange = stack;

	}

	internal bool EndsUncondJmpBlk()
	{
		return m_endsUncondJmpBlk;
	}

	internal int StackChange()
	{
		return m_stackChange;
	}

	/// <include file='doc\Opcode.uex' path='docs/doc[@for="OpCode.OperandType"]/*' />
	public OperandType OperandType
	{
		get
		{
			return (m_operand);
		}
	}

	/// <include file='doc\Opcode.uex' path='docs/doc[@for="OpCode.FlowControl"]/*' />
	public FlowControl FlowControl
	{
		get
		{
			return (m_ctrl);
		}
	}

	/// <include file='doc\Opcode.uex' path='docs/doc[@for="OpCode.OpCodeType"]/*' />
	public OpCodeType OpCodeType
	{
		get
		{
			return (m_type);
		}
	}


	/// <include file='doc\Opcode.uex' path='docs/doc[@for="OpCode.StackBehaviourPop"]/*' />
	public StackBehaviour StackBehaviourPop
	{
		get
		{
			return (m_pop);
		}
	}

	/// <include file='doc\Opcode.uex' path='docs/doc[@for="OpCode.StackBehaviourPush"]/*' />
	public StackBehaviour StackBehaviourPush
	{
		get
		{
			return (m_push);
		}
	}

	/// <include file='doc\Opcode.uex' path='docs/doc[@for="OpCode.Size"]/*' />
	public int Size
	{
		get
		{
			return (m_size);
		}
	}

	/// <include file='doc\Opcode.uex' path='docs/doc[@for="OpCode.Value"]/*' />
	public short Value
	{
		get
		{
			if (m_size == 2)
				return (short) (m_s1 << 8 | m_s2);
			return (short) m_s2;
		}
	}


	/// <include file='doc\Opcode.uex' path='docs/doc[@for="OpCode.Name"]/*' />
	public String Name
	{
		get
		{
			return m_stringname;
		}
	}

	/// <include file='doc\Opcode.uex' path='docs/doc[@for="OpCode.Equals"]/*' />
	public override bool Equals(Object obj)
	{
		if (obj is OpCode)
		{
			if (m_s1 == ((OpCode)obj).m_s1 && m_s2 == ((OpCode)obj).m_s2)
			{
				return true;
			}
		}
		return false;
	}
	
	/// <include file='doc\Opcode.uex' path='docs/doc[@for="OpCode.GetHashCode"]/*' />
	public override int GetHashCode()
	{
		return this.m_stringname.GetHashCode();
	}

	/// <include file='doc\Opcode.uex' path='docs/doc[@for="OpCode.ToString"]/*' />
	public override String ToString()
	{
		return m_stringname;
	}


}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\opcodetype.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
**Class: OpCodeType
**
**Author: Craig Schertz (cschertz)
**
**Purpose: Exposes OpCodeType Attribute of IL .
**
** THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT BY HAND!
** See cschertz for more information.**
============================================================*/
namespace System.Reflection.Emit {

using System;

/// <include file='doc\OpcodeType.uex' path='docs/doc[@for="OpCodeType"]/*' />
[Serializable]
public enum OpCodeType
{

	/// <include file='doc\OpcodeType.uex' path='docs/doc[@for="OpCodeType.Annotation"]/*' />
	/// <internalonly/>
	Annotation	= 0,
	/// <include file='doc\OpcodeType.uex' path='docs/doc[@for="OpCodeType.Macro"]/*' />
	Macro	= 1,
	/// <include file='doc\OpcodeType.uex' path='docs/doc[@for="OpCodeType.Nternal"]/*' />
	Nternal	= 2,
	/// <include file='doc\OpcodeType.uex' path='docs/doc[@for="OpCodeType.Objmodel"]/*' />
	Objmodel	= 3,
	/// <include file='doc\OpcodeType.uex' path='docs/doc[@for="OpCodeType.Prefix"]/*' />
	Prefix	= 4,
	/// <include file='doc\OpcodeType.uex' path='docs/doc[@for="OpCodeType.Primitive"]/*' />
	Primitive	= 5,
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\reflection\emit\methodbuilder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  MethodBuilder
**
** Author: Daryl Olander (darylo)
**
** MethodBuilder is the class used to build a method in reflection emit
**
** Date:  November 98
**
===========================================================*/

namespace System.Reflection.Emit {
	using System.Text;
	using System;
	using CultureInfo = System.Globalization.CultureInfo;
	using System.Diagnostics.SymbolStore;
	using System.Reflection;
	using System.Security;
	using System.Security.Permissions;

    // The MethodBuilder is a full description of a Method, including the
    // name, attributes and IL.  This class is used with the TypeBuilder to define
    // a Method on a dynamically created class.  A MethodBuilder is used to create
    // both methods and constructors for classes.
    //
    // A MethodBuilder is always associated with a TypeBuilder.  The TypeBuilder.DefineMethod
    // method will return a new MethodBuilder to a client.
    //
    /// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder"]/*' />
    public sealed class MethodBuilder : MethodInfo
    {

    	/**********************************************
    	 * Return the Token for this method within the TypeBuilder that the
    	 * method is defined within.
    	 * @return the token of this method.
    	**********************************************/
        /// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.GetToken"]/*' />
        public MethodToken GetToken()
        {
            return m_mdMethod;
        }

    	/**********************************************
         * Overriden from System.Object.
         * Returns true if Object represents a MethodBuilder of the same
         * name and signature as the current instance.
         *
         * @param obj The object against which to compare the current instance.
    	**********************************************/
        /// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (!(obj is MethodBuilder)) {
                return false;
            }
            if (!(this.m_strName.Equals(((MethodBuilder)obj).m_strName))) {
                return false;
            }

            if (m_iAttributes!=(((MethodBuilder)obj).m_iAttributes)) {
                return false;
            }

            SignatureHelper thatSig = ((MethodBuilder)obj).m_signature;
            if (thatSig.Equals(m_signature)) {
                return true;
            }
            return false;
        }

        /// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.GetHashCode"]/*' />
        public override int GetHashCode()
        {
            return this.m_strName.GetHashCode();
        }


        /*******************
        *
    	* This is setting the parameter information
        *
        ********************/
        /// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.DefineParameter"]/*' />
        public ParameterBuilder DefineParameter(
            int 		position,
            ParameterAttributes attributes,
            String 	    strParamName)			// can be NULL string
        {
            m_containingType.ThrowIfCreated();
    
            if (position <= 0 ||
				m_parameterTypes == null ||
				position > m_parameterTypes.Length)
			{
                throw new ArgumentOutOfRangeException(Environment.GetResourceString("ArgumentOutOfRange_ParamSequence"));
            }
        
            return new ParameterBuilder(this, position, attributes, strParamName);
        }

        // set Marshal info for the return type
        /// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.SetMarshal"]/*' />
        public void SetMarshal(UnmanagedMarshal unmanagedMarshal)
        {
            m_containingType.ThrowIfCreated();
            
			if (m_retParam == null)
            {
                m_retParam = new ParameterBuilder(this, 0, 0, null);
            }

			if (m_retParam == null)
            {
                m_retParam = new ParameterBuilder(this, 0, 0, null);
            }
            m_retParam.SetMarshal(unmanagedMarshal);
        }

        /*******************
        *
        * This is different from CustomAttribute. This is stored into the SymWriter.
        *
        ********************/
        /// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.SetSymCustomAttribute"]/*' />
        public void SetSymCustomAttribute(
            String      name,           // SymCustomAttribute's name
            byte[]      data)           // the data blob
        {
            m_containingType.ThrowIfCreated();

            ModuleBuilder       dynMod = (ModuleBuilder) m_module;
            if ( dynMod.GetSymWriter() == null)
            {
                // Cannot SetSymCustomAttribute when it is not a debug module
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_NotADebugModule"));
            }

            SymbolToken  tk = new SymbolToken(m_mdMethod.Token);
            dynMod.GetSymWriter().SetSymAttribute(tk, name, data);
        }

        // Add declarative security to the method.
        //
        /// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.AddDeclarativeSecurity"]/*' />
        public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset)
        {
            if ((action < SecurityAction.Demand) || (action > SecurityAction.InheritanceDemand))
                throw new ArgumentOutOfRangeException("action");

            if (pset == null)
    	        throw new ArgumentNullException("pset");

    	    // cannot declarative security after type is created
            m_containingType.ThrowIfCreated();

    	    // Translate permission set into serialized format (uses standard binary serialization format).
            byte[] blob = null;
            if (!pset.IsEmpty())
                blob = pset.EncodeXml();

            // Write the blob into the metadata.
            TypeBuilder.InternalAddDeclarativeSecurity(m_module, m_mdMethod.Token, action, blob);
        }

    	/**********************************************
         * Sets the IL of the Method.  A byte array containing IL is passed along
         * with a count of the number of bytes of valid IL contained within the array.
         * The result is that the IL associated with this MethodBuilder will be set.
         *
         * @param il A byte array containing valid il.  If this parameter is null then
         * the il is cleared.
         * @param count A count of the number of valid bytes in the <var>il</var> array.  This
         * value is ignored if <var>il</var> is null.
         * Note that when user calls this function, there are a few information that client is
         * not able to supply: local signature, exception handlers, max stack size, a list of Token fixup, a list of RVA fixup
    	**********************************************/
    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.CreateMethodBody"]/*' />
    	public void CreateMethodBody(byte[] il,int count)
    	{
            if (m_bIsBaked)
    		{
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_MethodBaked"));
            }

            m_containingType.ThrowIfCreated();

    		if (il != null && (count < 0 || count > il.Length))
    			throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_Index"));
    		if (il == null) {
    			m_ubBody = null;
    			return;
    		}
    		m_ubBody = new byte[count];
    		Array.Copy(il,m_ubBody,count);
            m_bIsBaked=true;
    	}

    	/**********************************************
    	 * Set the implementation flags for method
    	**********************************************/
    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.SetImplementationFlags"]/*' />
    	public void SetImplementationFlags(MethodImplAttributes attributes) 
        {
            m_containingType.ThrowIfCreated();

    		m_dwMethodImplFlags = attributes;

    		TypeBuilder.InternalSetMethodImpl( m_module, m_mdMethod.Token, attributes);
    	}


    	/**********************************************
    	 * Get the implementation flags for method
    	**********************************************/
    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.GetILGenerator"]/*' />
    	public ILGenerator GetILGenerator() {
    		if ((m_dwMethodImplFlags & MethodImplAttributes.PreserveSig) != 0 ||
    			(m_dwMethodImplFlags&MethodImplAttributes.CodeTypeMask) != MethodImplAttributes.IL ||
        		(m_dwMethodImplFlags & MethodImplAttributes.Unmanaged) != 0 ||
				(m_iAttributes & MethodAttributes.PinvokeImpl) != 0)
            {
    			// cannot attach method body if methodimpl is marked not marked as managed IL
    			//
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ShouldNotHaveMethodBody"));
    		}

            if (m_ilGenerator == null)
                m_ilGenerator = new ILGenerator(this);
    		return m_ilGenerator;
    	}


		// Creates a new ILGenerator setting the default size of the IL Stream
    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.GetILGenerator1"]/*' />
    	public ILGenerator GetILGenerator(int size) {
    		if ((m_dwMethodImplFlags & MethodImplAttributes.PreserveSig) != 0 ||
    			(m_dwMethodImplFlags&MethodImplAttributes.CodeTypeMask) != MethodImplAttributes.IL ||
        		(m_dwMethodImplFlags & MethodImplAttributes.Unmanaged) != 0 ||
				(m_iAttributes & MethodAttributes.PinvokeImpl) != 0)
            {
    			// cannot attach method body if methodimpl is marked not marked as managed IL
    			//
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ShouldNotHaveMethodBody"));
    		}
            if (m_ilGenerator == null)
                m_ilGenerator = new ILGenerator(this, size);
    		return m_ilGenerator;
    	}


    	// Property is set to true if user wishes to have zero initialized stack frame for this method. Default to false.
    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.InitLocals"]/*' />
    	public bool InitLocals {
    		get {return m_fInitLocals;}
    		set {m_fInitLocals = value;}
    	}

    	/**********************************************
         * Sets the IL of the method.  An ILGenerator is passed as an argument and the method
         * queries this instance to get all of the information which it needs.
         * @param il An ILGenerator with some il defined.
         * @exception ArgumentException if <EM>il</EM> is null.
    	**********************************************/
    	internal void CreateMethodBodyHelper(ILGenerator il)
    	{
            __ExceptionInfo[]   excp;
            int                 counter=0;
            int[]				filterAddrs;
    		int[]               catchAddrs;
            int[]               catchEndAddrs;
            Type[]              catchClass;
            int[]               type;
            int                 numCatch;
            int                 start, end;
            ModuleBuilder       dynMod = (ModuleBuilder) m_module;

            m_containingType.ThrowIfCreated();

            if (m_bIsBaked)
            {
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_MethodHasBody"));
            }

            if (il==null)
            {
                throw new ArgumentNullException("il");
            }

            if (il.m_methodBuilder != this && il.m_methodBuilder != null)
            {
                // you don't need to call CreateMethodBody when you get your ILGenerator
                // through MethodBuilder::GetILGenerator.
                //

                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_BadILGeneratorUsage"));
            }
    		if ((m_dwMethodImplFlags & MethodImplAttributes.PreserveSig) != 0 ||
    			(m_dwMethodImplFlags&MethodImplAttributes.CodeTypeMask) != MethodImplAttributes.IL ||
        		(m_dwMethodImplFlags & MethodImplAttributes.Unmanaged) != 0 ||
				(m_iAttributes & MethodAttributes.PinvokeImpl) != 0)
            {
    			// cannot attach method body if methodimpl is marked not marked as managed IL
    			// @todo: what error should we throw here?
    			//
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_ShouldNotHaveMethodBody"));
    		}

            if (il.m_ScopeTree.m_iOpenScopeCount != 0)
            {
                // There are still unclosed local scope
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_OpenLocalVariableScope"));
            }


            m_ubBody = il.BakeByteArray();

            m_RVAFixups = il.GetRVAFixups();
            mm_mdMethodFixups = il.GetTokenFixups();

            //Okay, now the fun part.  Calculate all of the exceptions.
            excp = il.GetExceptions();
            m_numExceptions = CalculateNumberOfExceptions(excp);
            if (m_numExceptions>0)
            {

                m_exceptions = new __ExceptionInstance[m_numExceptions];

                for (int i=0; i<excp.Length; i++) {
                    filterAddrs = excp[i].GetFilterAddresses();
    				catchAddrs = excp[i].GetCatchAddresses();
                    catchEndAddrs = excp[i].GetCatchEndAddresses();
                    catchClass = excp[i].GetCatchClass();


                    // track the reference of the catch class
                    for (int j=0; j < catchClass.Length; j++)
                    {
                        if (catchClass[j] != null)
                            dynMod.GetTypeToken(catchClass[j]);
                    }

                    numCatch = excp[i].GetNumberOfCatches();
                    start = excp[i].GetStartAddress();
                    end = excp[i].GetEndAddress();
                    type = excp[i].GetExceptionTypes();
                    for (int j=0; j<numCatch; j++) {
                        int tkExceptionClass = 0;
                        if (catchClass[j] != null)
                            tkExceptionClass = dynMod.GetTypeToken(catchClass[j]).Token;
                        switch (type[j]) {
                        case __ExceptionInfo.None:
                        case __ExceptionInfo.Fault:
    					case __ExceptionInfo.Filter:
                            m_exceptions[counter++]=new __ExceptionInstance(start, end, filterAddrs[j], catchAddrs[j], catchEndAddrs[j], type[j], tkExceptionClass);
                            break;

                        case __ExceptionInfo.Finally:
                            m_exceptions[counter++]=new __ExceptionInstance(start, excp[i].GetFinallyEndAddress(), filterAddrs[j], catchAddrs[j], catchEndAddrs[j], type[j], tkExceptionClass);
                            break;
                        }
                    }

                }
            }


            m_bIsBaked=true;

            if (dynMod.GetSymWriter() != null)
            {

                // set the debugging information such as scope and line number
                // if it is in a debug module
                //
                SymbolToken  tk = new SymbolToken(m_mdMethod.Token);
                ISymbolWriter symWriter = dynMod.GetSymWriter();

                // call OpenMethod to make this method the current method
                symWriter.OpenMethod(tk);

                // call OpenScope because OpenMethod no longer implicitly creating
                // the top-levelsmethod scope
                //
                symWriter.OpenScope(0);
                if (m_localSymInfo != null)
                    m_localSymInfo.EmitLocalSymInfo(symWriter);
                il.m_ScopeTree.EmitScopeTree(symWriter);
                il.m_LineNumberInfo.EmitLineNumberInfo(symWriter);
                symWriter.CloseScope(il.m_length);
                symWriter.CloseMethod();
            }
        }


    	/**********************************************
         * Generates a debug printout of the name, attributes and
         * exceptions in this method followed by the current IL Stream.
         * This will eventually be wired into the disassembler to be more
         * useful in debugging.  The current implementation requires that
         * the bytes on the stream be debugged by hand.
    	**********************************************/
        /// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.ToString"]/*' />
        public override String ToString() {
            StringBuilder sb = new StringBuilder(1000);
            sb.Append("Name: " + m_strName + " " + Environment.NewLine);
            sb.Append("Attributes: " + (int) m_iAttributes + Environment.NewLine);
            sb.Append("Method Signature: " + m_signature + Environment.NewLine);

    		// @todo: The ToString really should print out whatever format is printing out
    		// in RuntimeMethodInfo.ToString. M11.

    		/*
            sb.Append("Exceptions: " + m_numExceptions + Environment.NewLine);
            sb.Append("Local Signature: " + m_localSignature + Environment.NewLine);
            for (int i=0; i<m_numExceptions; i++) {
                switch (m_exceptions[i].m_type) {
                case __ExceptionInfo.None:
                    sb.Append("Exception " + i + " [" + m_exceptions[i].m_startAddress + ".." + m_exceptions[i].m_endAddress + ") ");
                    sb.Append("Handled by: " + m_exceptions[i].m_handleAddress + ".." + m_exceptions[i].m_handleEndAddress + " Type: " + m_exceptions[i].m_exceptionClass+ " " + Environment.NewLine);
                    break;
                case __ExceptionInfo.Finally:
                    sb.Append("Finally Block " + i + " [" + m_exceptions[i].m_startAddress + ".." + m_exceptions[i].m_endAddress + ") ");
                    sb.Append("Handled at: " + m_exceptions[i].m_handleAddress + ".." + m_exceptions[i].m_handleEndAddress);
                    break;
                default:
                    sb.Append("Unknown Exception type!");
                }
            }
            sb.Append(Environment.NewLine + "Body length is: " + m_ubBody.Length + Environment.NewLine);
            for (int i=0; i<m_ubBody.Length; i++) {
                if (m_ubBody[i]==(ubyte)0xFF) {
                    sb.Append(Environment.NewLine);
                    sb.Append(Convert.ToString(i,16) + " | ");
                }
                sb.Append(Convert.ToString(m_ubBody[i],16)+" ");
            }
    		*/
            sb.Append(Environment.NewLine);
            return sb.ToString();
        }


        /// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.GetModule"]/*' />
        public Module GetModule()
        {
            return m_module;
        }

     	internal Type[] GetParameterTypes()
    	{
            return m_parameterTypes;
    	}


    	/**********************************************
    	 *
    	 * Abstract methods inherited from the base class
    	 *
    	 **********************************************/

    	// Return the base implementation for a method.
    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.GetBaseDefinition"]/*' />
    	public override MethodInfo GetBaseDefinition()
    	{
    		return this;
    	}

		// Return the Type that declared this Method.
		//COOLPORT: Do something....
		/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.DeclaringType"]/*' />
		public override Type DeclaringType {
    		get {
                if (m_containingType.m_isHiddenGlobalType == true)
                    return null;
                return m_containingType;
            }
		}

    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.ReturnType"]/*' />
    	public override Type ReturnType {
    		get {
                return m_returnType;
            }
    	}

  		// This method will return an object that represents the
		//	custom attributes for the return type.
		/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.ReturnTypeCustomAttributes"]/*' />
		public override ICustomAttributeProvider ReturnTypeCustomAttributes {
			get {return null;}
		}

    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.Invoke"]/*' />
    	public override Object Invoke(Object obj,BindingFlags invokeAttr,Binder binder, Object[] parameters,CultureInfo culture)
    	{
    		// This will not be supported.
    		throw new NotSupportedException(Environment.GetResourceString("NotSupported_DynamicModule"));
    	}

    	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.Signature"]/*' />
    	public  String Signature {
    		get {return m_signature.ToString();}
    	}

     	/// <include file='doc\MethodBuilder.uex' path='docs/doc[@for="MethodBuilder.GetParameters"]/*' />
     	public override ParameterInfo[] GetParameters()
    	{
            if (!m_bIsBaked)
                throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_TypeNotCreated"));

            Type rti = m_containingType.m_runtimeType;
            MethodInfo rmi = rti.GetMethod(m_strName, m_parameterTypes);

            return rmi.GetParameters();
    	}

    	/// <include f